'use strict';

(function ($) {
    'use strict';

    var gotoSection = function gotoSection(e) {
        e.preventDefault();

        var $that = $(this);
        var target = $that.attr('href');
        var $content = $('body, html');
        var $target = $(target);

        console.log(target);

        $content.stop().animate({
            'scrollTop': $target.position().top - 50
        });
    };

    $('.smooth-scroll a').on('click', gotoSection);
})(jQuery);
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 4);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

/* globals __VUE_SSR_CONTEXT__ */

// this module is a runtime utility for cleaner component module output and will
// be included in the final webpack user bundle

module.exports = function normalizeComponent (
  rawScriptExports,
  compiledTemplate,
  injectStyles,
  scopeId,
  moduleIdentifier /* server only */
) {
  var esModule
  var scriptExports = rawScriptExports = rawScriptExports || {}

  // ES6 modules interop
  var type = typeof rawScriptExports.default
  if (type === 'object' || type === 'function') {
    esModule = rawScriptExports
    scriptExports = rawScriptExports.default
  }

  // Vue.extend constructor export interop
  var options = typeof scriptExports === 'function'
    ? scriptExports.options
    : scriptExports

  // render functions
  if (compiledTemplate) {
    options.render = compiledTemplate.render
    options.staticRenderFns = compiledTemplate.staticRenderFns
  }

  // scopedId
  if (scopeId) {
    options._scopeId = scopeId
  }

  var hook
  if (moduleIdentifier) { // server build
    hook = function (context) {
      // 2.3 injection
      context =
        context || // cached call
        (this.$vnode && this.$vnode.ssrContext) || // stateful
        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional
      // 2.2 with runInNewContext: true
      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
        context = __VUE_SSR_CONTEXT__
      }
      // inject component styles
      if (injectStyles) {
        injectStyles.call(this, context)
      }
      // register component module identifier for async chunk inferrence
      if (context && context._registeredComponents) {
        context._registeredComponents.add(moduleIdentifier)
      }
    }
    // used by ssr in case component is cached and beforeCreate
    // never gets called
    options._ssrRegister = hook
  } else if (injectStyles) {
    hook = injectStyles
  }

  if (hook) {
    var functional = options.functional
    var existing = functional
      ? options.render
      : options.beforeCreate
    if (!functional) {
      // inject component registration as beforeCreate hook
      options.beforeCreate = existing
        ? [].concat(existing, hook)
        : [hook]
    } else {
      // register for functioal component in vue file
      options.render = function renderWithStyleInjection (h, context) {
        hook.call(context)
        return existing(h, context)
      }
    }
  }

  return {
    esModule: esModule,
    exports: scriptExports,
    options: options
  }
}


/***/ }),
/* 1 */
/***/ (function(module, exports) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
module.exports = function (useSourceMap) {
	var list = [];

	// return the list of modules as css string
	list.toString = function toString() {
		return this.map(function (item) {
			var content = cssWithMappingToString(item, useSourceMap);
			if (item[2]) {
				return "@media " + item[2] + "{" + content + "}";
			} else {
				return content;
			}
		}).join("");
	};

	// import a list of modules into the list
	list.i = function (modules, mediaQuery) {
		if (typeof modules === "string") modules = [[null, modules, ""]];
		var alreadyImportedModules = {};
		for (var i = 0; i < this.length; i++) {
			var id = this[i][0];
			if (typeof id === "number") alreadyImportedModules[id] = true;
		}
		for (i = 0; i < modules.length; i++) {
			var item = modules[i];
			// skip already imported module
			// this implementation is not 100% perfect for weird media query combinations
			//  when a module is imported multiple times with different media queries.
			//  I hope this will never occur (Hey this way we have smaller bundles)
			if (typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
				if (mediaQuery && !item[2]) {
					item[2] = mediaQuery;
				} else if (mediaQuery) {
					item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
				}
				list.push(item);
			}
		}
	};
	return list;
};

function cssWithMappingToString(item, useSourceMap) {
	var content = item[1] || '';
	var cssMapping = item[3];
	if (!cssMapping) {
		return content;
	}

	if (useSourceMap && typeof btoa === 'function') {
		var sourceMapping = toComment(cssMapping);
		var sourceURLs = cssMapping.sources.map(function (source) {
			return '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */';
		});

		return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
	}

	return [content].join('\n');
}

// Adapted from convert-source-map (MIT)
function toComment(sourceMap) {
	// eslint-disable-next-line no-undef
	var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
	var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;

	return '/*# ' + data + ' */';
}

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
  Modified by Evan You @yyx990803
*/

var hasDocument = typeof document !== 'undefined'

if (typeof DEBUG !== 'undefined' && DEBUG) {
  if (!hasDocument) {
    throw new Error(
    'vue-style-loader cannot be used in a non-browser environment. ' +
    "Use { target: 'node' } in your Webpack config to indicate a server-rendering environment."
  ) }
}

var listToStyles = __webpack_require__(10)

/*
type StyleObject = {
  id: number;
  parts: Array<StyleObjectPart>
}

type StyleObjectPart = {
  css: string;
  media: string;
  sourceMap: ?string
}
*/

var stylesInDom = {/*
  [id: number]: {
    id: number,
    refs: number,
    parts: Array<(obj?: StyleObjectPart) => void>
  }
*/}

var head = hasDocument && (document.head || document.getElementsByTagName('head')[0])
var singletonElement = null
var singletonCounter = 0
var isProduction = false
var noop = function () {}

// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
// tags it will allow on a page
var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\b/.test(navigator.userAgent.toLowerCase())

module.exports = function (parentId, list, _isProduction) {
  isProduction = _isProduction

  var styles = listToStyles(parentId, list)
  addStylesToDom(styles)

  return function update (newList) {
    var mayRemove = []
    for (var i = 0; i < styles.length; i++) {
      var item = styles[i]
      var domStyle = stylesInDom[item.id]
      domStyle.refs--
      mayRemove.push(domStyle)
    }
    if (newList) {
      styles = listToStyles(parentId, newList)
      addStylesToDom(styles)
    } else {
      styles = []
    }
    for (var i = 0; i < mayRemove.length; i++) {
      var domStyle = mayRemove[i]
      if (domStyle.refs === 0) {
        for (var j = 0; j < domStyle.parts.length; j++) {
          domStyle.parts[j]()
        }
        delete stylesInDom[domStyle.id]
      }
    }
  }
}

function addStylesToDom (styles /* Array<StyleObject> */) {
  for (var i = 0; i < styles.length; i++) {
    var item = styles[i]
    var domStyle = stylesInDom[item.id]
    if (domStyle) {
      domStyle.refs++
      for (var j = 0; j < domStyle.parts.length; j++) {
        domStyle.parts[j](item.parts[j])
      }
      for (; j < item.parts.length; j++) {
        domStyle.parts.push(addStyle(item.parts[j]))
      }
      if (domStyle.parts.length > item.parts.length) {
        domStyle.parts.length = item.parts.length
      }
    } else {
      var parts = []
      for (var j = 0; j < item.parts.length; j++) {
        parts.push(addStyle(item.parts[j]))
      }
      stylesInDom[item.id] = { id: item.id, refs: 1, parts: parts }
    }
  }
}

function createStyleElement () {
  var styleElement = document.createElement('style')
  styleElement.type = 'text/css'
  head.appendChild(styleElement)
  return styleElement
}

function addStyle (obj /* StyleObjectPart */) {
  var update, remove
  var styleElement = document.querySelector('style[data-vue-ssr-id~="' + obj.id + '"]')

  if (styleElement) {
    if (isProduction) {
      // has SSR styles and in production mode.
      // simply do nothing.
      return noop
    } else {
      // has SSR styles but in dev mode.
      // for some reason Chrome can't handle source map in server-rendered
      // style tags - source maps in <style> only works if the style tag is
      // created and inserted dynamically. So we remove the server rendered
      // styles and inject new ones.
      styleElement.parentNode.removeChild(styleElement)
    }
  }

  if (isOldIE) {
    // use singleton mode for IE9.
    var styleIndex = singletonCounter++
    styleElement = singletonElement || (singletonElement = createStyleElement())
    update = applyToSingletonTag.bind(null, styleElement, styleIndex, false)
    remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true)
  } else {
    // use multi-style-tag mode in all other cases
    styleElement = createStyleElement()
    update = applyToTag.bind(null, styleElement)
    remove = function () {
      styleElement.parentNode.removeChild(styleElement)
    }
  }

  update(obj)

  return function updateStyle (newObj /* StyleObjectPart */) {
    if (newObj) {
      if (newObj.css === obj.css &&
          newObj.media === obj.media &&
          newObj.sourceMap === obj.sourceMap) {
        return
      }
      update(obj = newObj)
    } else {
      remove()
    }
  }
}

var replaceText = (function () {
  var textStore = []

  return function (index, replacement) {
    textStore[index] = replacement
    return textStore.filter(Boolean).join('\n')
  }
})()

function applyToSingletonTag (styleElement, index, remove, obj) {
  var css = remove ? '' : obj.css

  if (styleElement.styleSheet) {
    styleElement.styleSheet.cssText = replaceText(index, css)
  } else {
    var cssNode = document.createTextNode(css)
    var childNodes = styleElement.childNodes
    if (childNodes[index]) styleElement.removeChild(childNodes[index])
    if (childNodes.length) {
      styleElement.insertBefore(cssNode, childNodes[index])
    } else {
      styleElement.appendChild(cssNode)
    }
  }
}

function applyToTag (styleElement, obj) {
  var css = obj.css
  var media = obj.media
  var sourceMap = obj.sourceMap

  if (media) {
    styleElement.setAttribute('media', media)
  }

  if (sourceMap) {
    // https://developer.chrome.com/devtools/docs/javascript-debugging
    // this makes source maps inside style tags work properly in Chrome
    css += '\n/*# sourceURL=' + sourceMap.sources[0] + ' */'
    // http://stackoverflow.com/a/26603875
    css += '\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + ' */'
  }

  if (styleElement.styleSheet) {
    styleElement.styleSheet.cssText = css
  } else {
    while (styleElement.firstChild) {
      styleElement.removeChild(styleElement.firstChild)
    }
    styleElement.appendChild(document.createTextNode(css))
  }
}


/***/ }),
/* 3 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = function () {
	return this;
}();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1, eval)("this");
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;

/***/ }),
/* 4 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_vue__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_vue__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_vue_custom_element__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__App_vue__ = __webpack_require__(7);
// The Vue build version to load with the `import` command
// (runtime-only or standalone) has been set in webpack.base.conf with an alias.

// import _ from 'lodash'

// include vue-custom-element plugin to Vue

__WEBPACK_IMPORTED_MODULE_0_vue___default.a.use(__WEBPACK_IMPORTED_MODULE_1_vue_custom_element__["a" /* default */]);

__WEBPACK_IMPORTED_MODULE_0_vue___default.a.config.productionTip = false;

/* eslint-disable no-new */
// new Vue({
//     el: '#app',
//     template: '<App/>',
//     components: { App }
// })

// import and register your component(s)

__WEBPACK_IMPORTED_MODULE_0_vue___default.a.customElement('saws-house', __WEBPACK_IMPORTED_MODULE_2__App_vue__["a" /* default */]);

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/*!
 * Vue.js v2.4.4
 * (c) 2014-2017 Evan You
 * Released under the MIT License.
 */


/*  */

// these helpers produces better vm code in JS engines due to their
// explicitness and function inlining

function isUndef(v) {
  return v === undefined || v === null;
}

function isDef(v) {
  return v !== undefined && v !== null;
}

function isTrue(v) {
  return v === true;
}

function isFalse(v) {
  return v === false;
}

/**
 * Check if value is primitive
 */
function isPrimitive(value) {
  return typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean';
}

/**
 * Quick object check - this is primarily used to tell
 * Objects from primitive values when we know the value
 * is a JSON-compliant type.
 */
function isObject(obj) {
  return obj !== null && typeof obj === 'object';
}

var _toString = Object.prototype.toString;

/**
 * Strict object type check. Only returns true
 * for plain JavaScript objects.
 */
function isPlainObject(obj) {
  return _toString.call(obj) === '[object Object]';
}

function isRegExp(v) {
  return _toString.call(v) === '[object RegExp]';
}

/**
 * Check if val is a valid array index.
 */
function isValidArrayIndex(val) {
  var n = parseFloat(val);
  return n >= 0 && Math.floor(n) === n && isFinite(val);
}

/**
 * Convert a value to a string that is actually rendered.
 */
function toString(val) {
  return val == null ? '' : typeof val === 'object' ? JSON.stringify(val, null, 2) : String(val);
}

/**
 * Convert a input value to a number for persistence.
 * If the conversion fails, return original string.
 */
function toNumber(val) {
  var n = parseFloat(val);
  return isNaN(n) ? val : n;
}

/**
 * Make a map and return a function for checking if a key
 * is in that map.
 */
function makeMap(str, expectsLowerCase) {
  var map = Object.create(null);
  var list = str.split(',');
  for (var i = 0; i < list.length; i++) {
    map[list[i]] = true;
  }
  return expectsLowerCase ? function (val) {
    return map[val.toLowerCase()];
  } : function (val) {
    return map[val];
  };
}

/**
 * Check if a tag is a built-in tag.
 */
var isBuiltInTag = makeMap('slot,component', true);

/**
 * Check if a attribute is a reserved attribute.
 */
var isReservedAttribute = makeMap('key,ref,slot,is');

/**
 * Remove an item from an array
 */
function remove(arr, item) {
  if (arr.length) {
    var index = arr.indexOf(item);
    if (index > -1) {
      return arr.splice(index, 1);
    }
  }
}

/**
 * Check whether the object has the property.
 */
var hasOwnProperty = Object.prototype.hasOwnProperty;
function hasOwn(obj, key) {
  return hasOwnProperty.call(obj, key);
}

/**
 * Create a cached version of a pure function.
 */
function cached(fn) {
  var cache = Object.create(null);
  return function cachedFn(str) {
    var hit = cache[str];
    return hit || (cache[str] = fn(str));
  };
}

/**
 * Camelize a hyphen-delimited string.
 */
var camelizeRE = /-(\w)/g;
var camelize = cached(function (str) {
  return str.replace(camelizeRE, function (_, c) {
    return c ? c.toUpperCase() : '';
  });
});

/**
 * Capitalize a string.
 */
var capitalize = cached(function (str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
});

/**
 * Hyphenate a camelCase string.
 */
var hyphenateRE = /\B([A-Z])/g;
var hyphenate = cached(function (str) {
  return str.replace(hyphenateRE, '-$1').toLowerCase();
});

/**
 * Simple bind, faster than native
 */
function bind(fn, ctx) {
  function boundFn(a) {
    var l = arguments.length;
    return l ? l > 1 ? fn.apply(ctx, arguments) : fn.call(ctx, a) : fn.call(ctx);
  }
  // record original fn length
  boundFn._length = fn.length;
  return boundFn;
}

/**
 * Convert an Array-like object to a real Array.
 */
function toArray(list, start) {
  start = start || 0;
  var i = list.length - start;
  var ret = new Array(i);
  while (i--) {
    ret[i] = list[i + start];
  }
  return ret;
}

/**
 * Mix properties into target object.
 */
function extend(to, _from) {
  for (var key in _from) {
    to[key] = _from[key];
  }
  return to;
}

/**
 * Merge an Array of Objects into a single Object.
 */
function toObject(arr) {
  var res = {};
  for (var i = 0; i < arr.length; i++) {
    if (arr[i]) {
      extend(res, arr[i]);
    }
  }
  return res;
}

/**
 * Perform no operation.
 * Stubbing args to make Flow happy without leaving useless transpiled code
 * with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/)
 */
function noop(a, b, c) {}

/**
 * Always return false.
 */
var no = function (a, b, c) {
  return false;
};

/**
 * Return same value
 */
var identity = function (_) {
  return _;
};

/**
 * Generate a static keys string from compiler modules.
 */
function genStaticKeys(modules) {
  return modules.reduce(function (keys, m) {
    return keys.concat(m.staticKeys || []);
  }, []).join(',');
}

/**
 * Check if two values are loosely equal - that is,
 * if they are plain objects, do they have the same shape?
 */
function looseEqual(a, b) {
  if (a === b) {
    return true;
  }
  var isObjectA = isObject(a);
  var isObjectB = isObject(b);
  if (isObjectA && isObjectB) {
    try {
      var isArrayA = Array.isArray(a);
      var isArrayB = Array.isArray(b);
      if (isArrayA && isArrayB) {
        return a.length === b.length && a.every(function (e, i) {
          return looseEqual(e, b[i]);
        });
      } else if (!isArrayA && !isArrayB) {
        var keysA = Object.keys(a);
        var keysB = Object.keys(b);
        return keysA.length === keysB.length && keysA.every(function (key) {
          return looseEqual(a[key], b[key]);
        });
      } else {
        /* istanbul ignore next */
        return false;
      }
    } catch (e) {
      /* istanbul ignore next */
      return false;
    }
  } else if (!isObjectA && !isObjectB) {
    return String(a) === String(b);
  } else {
    return false;
  }
}

function looseIndexOf(arr, val) {
  for (var i = 0; i < arr.length; i++) {
    if (looseEqual(arr[i], val)) {
      return i;
    }
  }
  return -1;
}

/**
 * Ensure a function is called only once.
 */
function once(fn) {
  var called = false;
  return function () {
    if (!called) {
      called = true;
      fn.apply(this, arguments);
    }
  };
}

var SSR_ATTR = 'data-server-rendered';

var ASSET_TYPES = ['component', 'directive', 'filter'];

var LIFECYCLE_HOOKS = ['beforeCreate', 'created', 'beforeMount', 'mounted', 'beforeUpdate', 'updated', 'beforeDestroy', 'destroyed', 'activated', 'deactivated'];

/*  */

var config = {
  /**
   * Option merge strategies (used in core/util/options)
   */
  optionMergeStrategies: Object.create(null),

  /**
   * Whether to suppress warnings.
   */
  silent: false,

  /**
   * Show production mode tip message on boot?
   */
  productionTip: "production" !== 'production',

  /**
   * Whether to enable devtools
   */
  devtools: "production" !== 'production',

  /**
   * Whether to record perf
   */
  performance: false,

  /**
   * Error handler for watcher errors
   */
  errorHandler: null,

  /**
   * Warn handler for watcher warns
   */
  warnHandler: null,

  /**
   * Ignore certain custom elements
   */
  ignoredElements: [],

  /**
   * Custom user key aliases for v-on
   */
  keyCodes: Object.create(null),

  /**
   * Check if a tag is reserved so that it cannot be registered as a
   * component. This is platform-dependent and may be overwritten.
   */
  isReservedTag: no,

  /**
   * Check if an attribute is reserved so that it cannot be used as a component
   * prop. This is platform-dependent and may be overwritten.
   */
  isReservedAttr: no,

  /**
   * Check if a tag is an unknown element.
   * Platform-dependent.
   */
  isUnknownElement: no,

  /**
   * Get the namespace of an element
   */
  getTagNamespace: noop,

  /**
   * Parse the real tag name for the specific platform.
   */
  parsePlatformTagName: identity,

  /**
   * Check if an attribute must be bound using property, e.g. value
   * Platform-dependent.
   */
  mustUseProp: no,

  /**
   * Exposed for legacy reasons
   */
  _lifecycleHooks: LIFECYCLE_HOOKS
};

/*  */

var emptyObject = Object.freeze({});

/**
 * Check if a string starts with $ or _
 */
function isReserved(str) {
  var c = (str + '').charCodeAt(0);
  return c === 0x24 || c === 0x5F;
}

/**
 * Define a property.
 */
function def(obj, key, val, enumerable) {
  Object.defineProperty(obj, key, {
    value: val,
    enumerable: !!enumerable,
    writable: true,
    configurable: true
  });
}

/**
 * Parse simple path.
 */
var bailRE = /[^\w.$]/;
function parsePath(path) {
  if (bailRE.test(path)) {
    return;
  }
  var segments = path.split('.');
  return function (obj) {
    for (var i = 0; i < segments.length; i++) {
      if (!obj) {
        return;
      }
      obj = obj[segments[i]];
    }
    return obj;
  };
}

/*  */

var warn = noop;
var tip = noop;
var formatComponentName = null; // work around flow check

if (false) {
  var hasConsole = typeof console !== 'undefined';
  var classifyRE = /(?:^|[-_])(\w)/g;
  var classify = function (str) {
    return str.replace(classifyRE, function (c) {
      return c.toUpperCase();
    }).replace(/[-_]/g, '');
  };

  warn = function (msg, vm) {
    var trace = vm ? generateComponentTrace(vm) : '';

    if (config.warnHandler) {
      config.warnHandler.call(null, msg, vm, trace);
    } else if (hasConsole && !config.silent) {
      console.error("[Vue warn]: " + msg + trace);
    }
  };

  tip = function (msg, vm) {
    if (hasConsole && !config.silent) {
      console.warn("[Vue tip]: " + msg + (vm ? generateComponentTrace(vm) : ''));
    }
  };

  formatComponentName = function (vm, includeFile) {
    if (vm.$root === vm) {
      return '<Root>';
    }
    var name = typeof vm === 'string' ? vm : typeof vm === 'function' && vm.options ? vm.options.name : vm._isVue ? vm.$options.name || vm.$options._componentTag : vm.name;

    var file = vm._isVue && vm.$options.__file;
    if (!name && file) {
      var match = file.match(/([^/\\]+)\.vue$/);
      name = match && match[1];
    }

    return (name ? "<" + classify(name) + ">" : "<Anonymous>") + (file && includeFile !== false ? " at " + file : '');
  };

  var repeat = function (str, n) {
    var res = '';
    while (n) {
      if (n % 2 === 1) {
        res += str;
      }
      if (n > 1) {
        str += str;
      }
      n >>= 1;
    }
    return res;
  };

  var generateComponentTrace = function (vm) {
    if (vm._isVue && vm.$parent) {
      var tree = [];
      var currentRecursiveSequence = 0;
      while (vm) {
        if (tree.length > 0) {
          var last = tree[tree.length - 1];
          if (last.constructor === vm.constructor) {
            currentRecursiveSequence++;
            vm = vm.$parent;
            continue;
          } else if (currentRecursiveSequence > 0) {
            tree[tree.length - 1] = [last, currentRecursiveSequence];
            currentRecursiveSequence = 0;
          }
        }
        tree.push(vm);
        vm = vm.$parent;
      }
      return '\n\nfound in\n\n' + tree.map(function (vm, i) {
        return "" + (i === 0 ? '---> ' : repeat(' ', 5 + i * 2)) + (Array.isArray(vm) ? formatComponentName(vm[0]) + "... (" + vm[1] + " recursive calls)" : formatComponentName(vm));
      }).join('\n');
    } else {
      return "\n\n(found in " + formatComponentName(vm) + ")";
    }
  };
}

/*  */

function handleError(err, vm, info) {
  if (config.errorHandler) {
    config.errorHandler.call(null, err, vm, info);
  } else {
    if (false) {
      warn("Error in " + info + ": \"" + err.toString() + "\"", vm);
    }
    /* istanbul ignore else */
    if (inBrowser && typeof console !== 'undefined') {
      console.error(err);
    } else {
      throw err;
    }
  }
}

/*  */
/* globals MutationObserver */

// can we use __proto__?
var hasProto = '__proto__' in {};

// Browser environment sniffing
var inBrowser = typeof window !== 'undefined';
var UA = inBrowser && window.navigator.userAgent.toLowerCase();
var isIE = UA && /msie|trident/.test(UA);
var isIE9 = UA && UA.indexOf('msie 9.0') > 0;
var isEdge = UA && UA.indexOf('edge/') > 0;
var isAndroid = UA && UA.indexOf('android') > 0;
var isIOS = UA && /iphone|ipad|ipod|ios/.test(UA);
var isChrome = UA && /chrome\/\d+/.test(UA) && !isEdge;

// Firefox has a "watch" function on Object.prototype...
var nativeWatch = {}.watch;

var supportsPassive = false;
if (inBrowser) {
  try {
    var opts = {};
    Object.defineProperty(opts, 'passive', {
      get: function get() {
        /* istanbul ignore next */
        supportsPassive = true;
      }
    }); // https://github.com/facebook/flow/issues/285
    window.addEventListener('test-passive', null, opts);
  } catch (e) {}
}

// this needs to be lazy-evaled because vue may be required before
// vue-server-renderer can set VUE_ENV
var _isServer;
var isServerRendering = function () {
  if (_isServer === undefined) {
    /* istanbul ignore if */
    if (!inBrowser && typeof global !== 'undefined') {
      // detect presence of vue-server-renderer and avoid
      // Webpack shimming the process
      _isServer = global['process'].env.VUE_ENV === 'server';
    } else {
      _isServer = false;
    }
  }
  return _isServer;
};

// detect devtools
var devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;

/* istanbul ignore next */
function isNative(Ctor) {
  return typeof Ctor === 'function' && /native code/.test(Ctor.toString());
}

var hasSymbol = typeof Symbol !== 'undefined' && isNative(Symbol) && typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);

/**
 * Defer a task to execute it asynchronously.
 */
var nextTick = function () {
  var callbacks = [];
  var pending = false;
  var timerFunc;

  function nextTickHandler() {
    pending = false;
    var copies = callbacks.slice(0);
    callbacks.length = 0;
    for (var i = 0; i < copies.length; i++) {
      copies[i]();
    }
  }

  // the nextTick behavior leverages the microtask queue, which can be accessed
  // via either native Promise.then or MutationObserver.
  // MutationObserver has wider support, however it is seriously bugged in
  // UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It
  // completely stops working after triggering a few times... so, if native
  // Promise is available, we will use it:
  /* istanbul ignore if */
  if (typeof Promise !== 'undefined' && isNative(Promise)) {
    var p = Promise.resolve();
    var logError = function (err) {
      console.error(err);
    };
    timerFunc = function () {
      p.then(nextTickHandler).catch(logError);
      // in problematic UIWebViews, Promise.then doesn't completely break, but
      // it can get stuck in a weird state where callbacks are pushed into the
      // microtask queue but the queue isn't being flushed, until the browser
      // needs to do some other work, e.g. handle a timer. Therefore we can
      // "force" the microtask queue to be flushed by adding an empty timer.
      if (isIOS) {
        setTimeout(noop);
      }
    };
  } else if (!isIE && typeof MutationObserver !== 'undefined' && (isNative(MutationObserver) ||
  // PhantomJS and iOS 7.x
  MutationObserver.toString() === '[object MutationObserverConstructor]')) {
    // use MutationObserver where native Promise is not available,
    // e.g. PhantomJS, iOS7, Android 4.4
    var counter = 1;
    var observer = new MutationObserver(nextTickHandler);
    var textNode = document.createTextNode(String(counter));
    observer.observe(textNode, {
      characterData: true
    });
    timerFunc = function () {
      counter = (counter + 1) % 2;
      textNode.data = String(counter);
    };
  } else {
    // fallback to setTimeout
    /* istanbul ignore next */
    timerFunc = function () {
      setTimeout(nextTickHandler, 0);
    };
  }

  return function queueNextTick(cb, ctx) {
    var _resolve;
    callbacks.push(function () {
      if (cb) {
        try {
          cb.call(ctx);
        } catch (e) {
          handleError(e, ctx, 'nextTick');
        }
      } else if (_resolve) {
        _resolve(ctx);
      }
    });
    if (!pending) {
      pending = true;
      timerFunc();
    }
    if (!cb && typeof Promise !== 'undefined') {
      return new Promise(function (resolve, reject) {
        _resolve = resolve;
      });
    }
  };
}();

var _Set;
/* istanbul ignore if */
if (typeof Set !== 'undefined' && isNative(Set)) {
  // use native Set when available.
  _Set = Set;
} else {
  // a non-standard Set polyfill that only works with primitive keys.
  _Set = function () {
    function Set() {
      this.set = Object.create(null);
    }
    Set.prototype.has = function has(key) {
      return this.set[key] === true;
    };
    Set.prototype.add = function add(key) {
      this.set[key] = true;
    };
    Set.prototype.clear = function clear() {
      this.set = Object.create(null);
    };

    return Set;
  }();
}

/*  */

var uid = 0;

/**
 * A dep is an observable that can have multiple
 * directives subscribing to it.
 */
var Dep = function Dep() {
  this.id = uid++;
  this.subs = [];
};

Dep.prototype.addSub = function addSub(sub) {
  this.subs.push(sub);
};

Dep.prototype.removeSub = function removeSub(sub) {
  remove(this.subs, sub);
};

Dep.prototype.depend = function depend() {
  if (Dep.target) {
    Dep.target.addDep(this);
  }
};

Dep.prototype.notify = function notify() {
  // stabilize the subscriber list first
  var subs = this.subs.slice();
  for (var i = 0, l = subs.length; i < l; i++) {
    subs[i].update();
  }
};

// the current target watcher being evaluated.
// this is globally unique because there could be only one
// watcher being evaluated at any time.
Dep.target = null;
var targetStack = [];

function pushTarget(_target) {
  if (Dep.target) {
    targetStack.push(Dep.target);
  }
  Dep.target = _target;
}

function popTarget() {
  Dep.target = targetStack.pop();
}

/*
 * not type checking this file because flow doesn't play well with
 * dynamically accessing methods on Array prototype
 */

var arrayProto = Array.prototype;
var arrayMethods = Object.create(arrayProto);['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'].forEach(function (method) {
  // cache original method
  var original = arrayProto[method];
  def(arrayMethods, method, function mutator() {
    var args = [],
        len = arguments.length;
    while (len--) args[len] = arguments[len];

    var result = original.apply(this, args);
    var ob = this.__ob__;
    var inserted;
    switch (method) {
      case 'push':
      case 'unshift':
        inserted = args;
        break;
      case 'splice':
        inserted = args.slice(2);
        break;
    }
    if (inserted) {
      ob.observeArray(inserted);
    }
    // notify change
    ob.dep.notify();
    return result;
  });
});

/*  */

var arrayKeys = Object.getOwnPropertyNames(arrayMethods);

/**
 * By default, when a reactive property is set, the new value is
 * also converted to become reactive. However when passing down props,
 * we don't want to force conversion because the value may be a nested value
 * under a frozen data structure. Converting it would defeat the optimization.
 */
var observerState = {
  shouldConvert: true
};

/**
 * Observer class that are attached to each observed
 * object. Once attached, the observer converts target
 * object's property keys into getter/setters that
 * collect dependencies and dispatches updates.
 */
var Observer = function Observer(value) {
  this.value = value;
  this.dep = new Dep();
  this.vmCount = 0;
  def(value, '__ob__', this);
  if (Array.isArray(value)) {
    var augment = hasProto ? protoAugment : copyAugment;
    augment(value, arrayMethods, arrayKeys);
    this.observeArray(value);
  } else {
    this.walk(value);
  }
};

/**
 * Walk through each property and convert them into
 * getter/setters. This method should only be called when
 * value type is Object.
 */
Observer.prototype.walk = function walk(obj) {
  var keys = Object.keys(obj);
  for (var i = 0; i < keys.length; i++) {
    defineReactive$$1(obj, keys[i], obj[keys[i]]);
  }
};

/**
 * Observe a list of Array items.
 */
Observer.prototype.observeArray = function observeArray(items) {
  for (var i = 0, l = items.length; i < l; i++) {
    observe(items[i]);
  }
};

// helpers

/**
 * Augment an target Object or Array by intercepting
 * the prototype chain using __proto__
 */
function protoAugment(target, src, keys) {
  /* eslint-disable no-proto */
  target.__proto__ = src;
  /* eslint-enable no-proto */
}

/**
 * Augment an target Object or Array by defining
 * hidden properties.
 */
/* istanbul ignore next */
function copyAugment(target, src, keys) {
  for (var i = 0, l = keys.length; i < l; i++) {
    var key = keys[i];
    def(target, key, src[key]);
  }
}

/**
 * Attempt to create an observer instance for a value,
 * returns the new observer if successfully observed,
 * or the existing observer if the value already has one.
 */
function observe(value, asRootData) {
  if (!isObject(value)) {
    return;
  }
  var ob;
  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
    ob = value.__ob__;
  } else if (observerState.shouldConvert && !isServerRendering() && (Array.isArray(value) || isPlainObject(value)) && Object.isExtensible(value) && !value._isVue) {
    ob = new Observer(value);
  }
  if (asRootData && ob) {
    ob.vmCount++;
  }
  return ob;
}

/**
 * Define a reactive property on an Object.
 */
function defineReactive$$1(obj, key, val, customSetter, shallow) {
  var dep = new Dep();

  var property = Object.getOwnPropertyDescriptor(obj, key);
  if (property && property.configurable === false) {
    return;
  }

  // cater for pre-defined getter/setters
  var getter = property && property.get;
  var setter = property && property.set;

  var childOb = !shallow && observe(val);
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: function reactiveGetter() {
      var value = getter ? getter.call(obj) : val;
      if (Dep.target) {
        dep.depend();
        if (childOb) {
          childOb.dep.depend();
          if (Array.isArray(value)) {
            dependArray(value);
          }
        }
      }
      return value;
    },
    set: function reactiveSetter(newVal) {
      var value = getter ? getter.call(obj) : val;
      /* eslint-disable no-self-compare */
      if (newVal === value || newVal !== newVal && value !== value) {
        return;
      }
      /* eslint-enable no-self-compare */
      if (false) {
        customSetter();
      }
      if (setter) {
        setter.call(obj, newVal);
      } else {
        val = newVal;
      }
      childOb = !shallow && observe(newVal);
      dep.notify();
    }
  });
}

/**
 * Set a property on an object. Adds the new property and
 * triggers change notification if the property doesn't
 * already exist.
 */
function set(target, key, val) {
  if (Array.isArray(target) && isValidArrayIndex(key)) {
    target.length = Math.max(target.length, key);
    target.splice(key, 1, val);
    return val;
  }
  if (hasOwn(target, key)) {
    target[key] = val;
    return val;
  }
  var ob = target.__ob__;
  if (target._isVue || ob && ob.vmCount) {
    "production" !== 'production' && warn('Avoid adding reactive properties to a Vue instance or its root $data ' + 'at runtime - declare it upfront in the data option.');
    return val;
  }
  if (!ob) {
    target[key] = val;
    return val;
  }
  defineReactive$$1(ob.value, key, val);
  ob.dep.notify();
  return val;
}

/**
 * Delete a property and trigger change if necessary.
 */
function del(target, key) {
  if (Array.isArray(target) && isValidArrayIndex(key)) {
    target.splice(key, 1);
    return;
  }
  var ob = target.__ob__;
  if (target._isVue || ob && ob.vmCount) {
    "production" !== 'production' && warn('Avoid deleting properties on a Vue instance or its root $data ' + '- just set it to null.');
    return;
  }
  if (!hasOwn(target, key)) {
    return;
  }
  delete target[key];
  if (!ob) {
    return;
  }
  ob.dep.notify();
}

/**
 * Collect dependencies on array elements when the array is touched, since
 * we cannot intercept array element access like property getters.
 */
function dependArray(value) {
  for (var e = void 0, i = 0, l = value.length; i < l; i++) {
    e = value[i];
    e && e.__ob__ && e.__ob__.dep.depend();
    if (Array.isArray(e)) {
      dependArray(e);
    }
  }
}

/*  */

/**
 * Option overwriting strategies are functions that handle
 * how to merge a parent option value and a child option
 * value into the final value.
 */
var strats = config.optionMergeStrategies;

/**
 * Options with restrictions
 */
if (false) {
  strats.el = strats.propsData = function (parent, child, vm, key) {
    if (!vm) {
      warn("option \"" + key + "\" can only be used during instance " + 'creation with the `new` keyword.');
    }
    return defaultStrat(parent, child);
  };
}

/**
 * Helper that recursively merges two data objects together.
 */
function mergeData(to, from) {
  if (!from) {
    return to;
  }
  var key, toVal, fromVal;
  var keys = Object.keys(from);
  for (var i = 0; i < keys.length; i++) {
    key = keys[i];
    toVal = to[key];
    fromVal = from[key];
    if (!hasOwn(to, key)) {
      set(to, key, fromVal);
    } else if (isPlainObject(toVal) && isPlainObject(fromVal)) {
      mergeData(toVal, fromVal);
    }
  }
  return to;
}

/**
 * Data
 */
function mergeDataOrFn(parentVal, childVal, vm) {
  if (!vm) {
    // in a Vue.extend merge, both should be functions
    if (!childVal) {
      return parentVal;
    }
    if (!parentVal) {
      return childVal;
    }
    // when parentVal & childVal are both present,
    // we need to return a function that returns the
    // merged result of both functions... no need to
    // check if parentVal is a function here because
    // it has to be a function to pass previous merges.
    return function mergedDataFn() {
      return mergeData(typeof childVal === 'function' ? childVal.call(this) : childVal, typeof parentVal === 'function' ? parentVal.call(this) : parentVal);
    };
  } else if (parentVal || childVal) {
    return function mergedInstanceDataFn() {
      // instance merge
      var instanceData = typeof childVal === 'function' ? childVal.call(vm) : childVal;
      var defaultData = typeof parentVal === 'function' ? parentVal.call(vm) : parentVal;
      if (instanceData) {
        return mergeData(instanceData, defaultData);
      } else {
        return defaultData;
      }
    };
  }
}

strats.data = function (parentVal, childVal, vm) {
  if (!vm) {
    if (childVal && typeof childVal !== 'function') {
      "production" !== 'production' && warn('The "data" option should be a function ' + 'that returns a per-instance value in component ' + 'definitions.', vm);

      return parentVal;
    }
    return mergeDataOrFn.call(this, parentVal, childVal);
  }

  return mergeDataOrFn(parentVal, childVal, vm);
};

/**
 * Hooks and props are merged as arrays.
 */
function mergeHook(parentVal, childVal) {
  return childVal ? parentVal ? parentVal.concat(childVal) : Array.isArray(childVal) ? childVal : [childVal] : parentVal;
}

LIFECYCLE_HOOKS.forEach(function (hook) {
  strats[hook] = mergeHook;
});

/**
 * Assets
 *
 * When a vm is present (instance creation), we need to do
 * a three-way merge between constructor options, instance
 * options and parent options.
 */
function mergeAssets(parentVal, childVal) {
  var res = Object.create(parentVal || null);
  return childVal ? extend(res, childVal) : res;
}

ASSET_TYPES.forEach(function (type) {
  strats[type + 's'] = mergeAssets;
});

/**
 * Watchers.
 *
 * Watchers hashes should not overwrite one
 * another, so we merge them as arrays.
 */
strats.watch = function (parentVal, childVal) {
  // work around Firefox's Object.prototype.watch...
  if (parentVal === nativeWatch) {
    parentVal = undefined;
  }
  if (childVal === nativeWatch) {
    childVal = undefined;
  }
  /* istanbul ignore if */
  if (!childVal) {
    return Object.create(parentVal || null);
  }
  if (!parentVal) {
    return childVal;
  }
  var ret = {};
  extend(ret, parentVal);
  for (var key in childVal) {
    var parent = ret[key];
    var child = childVal[key];
    if (parent && !Array.isArray(parent)) {
      parent = [parent];
    }
    ret[key] = parent ? parent.concat(child) : Array.isArray(child) ? child : [child];
  }
  return ret;
};

/**
 * Other object hashes.
 */
strats.props = strats.methods = strats.inject = strats.computed = function (parentVal, childVal) {
  if (!parentVal) {
    return childVal;
  }
  var ret = Object.create(null);
  extend(ret, parentVal);
  if (childVal) {
    extend(ret, childVal);
  }
  return ret;
};
strats.provide = mergeDataOrFn;

/**
 * Default strategy.
 */
var defaultStrat = function (parentVal, childVal) {
  return childVal === undefined ? parentVal : childVal;
};

/**
 * Validate component names
 */
function checkComponents(options) {
  for (var key in options.components) {
    var lower = key.toLowerCase();
    if (isBuiltInTag(lower) || config.isReservedTag(lower)) {
      warn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + key);
    }
  }
}

/**
 * Ensure all props option syntax are normalized into the
 * Object-based format.
 */
function normalizeProps(options) {
  var props = options.props;
  if (!props) {
    return;
  }
  var res = {};
  var i, val, name;
  if (Array.isArray(props)) {
    i = props.length;
    while (i--) {
      val = props[i];
      if (typeof val === 'string') {
        name = camelize(val);
        res[name] = { type: null };
      } else if (false) {
        warn('props must be strings when using array syntax.');
      }
    }
  } else if (isPlainObject(props)) {
    for (var key in props) {
      val = props[key];
      name = camelize(key);
      res[name] = isPlainObject(val) ? val : { type: val };
    }
  }
  options.props = res;
}

/**
 * Normalize all injections into Object-based format
 */
function normalizeInject(options) {
  var inject = options.inject;
  if (Array.isArray(inject)) {
    var normalized = options.inject = {};
    for (var i = 0; i < inject.length; i++) {
      normalized[inject[i]] = inject[i];
    }
  }
}

/**
 * Normalize raw function directives into object format.
 */
function normalizeDirectives(options) {
  var dirs = options.directives;
  if (dirs) {
    for (var key in dirs) {
      var def = dirs[key];
      if (typeof def === 'function') {
        dirs[key] = { bind: def, update: def };
      }
    }
  }
}

/**
 * Merge two option objects into a new one.
 * Core utility used in both instantiation and inheritance.
 */
function mergeOptions(parent, child, vm) {
  if (false) {
    checkComponents(child);
  }

  if (typeof child === 'function') {
    child = child.options;
  }

  normalizeProps(child);
  normalizeInject(child);
  normalizeDirectives(child);
  var extendsFrom = child.extends;
  if (extendsFrom) {
    parent = mergeOptions(parent, extendsFrom, vm);
  }
  if (child.mixins) {
    for (var i = 0, l = child.mixins.length; i < l; i++) {
      parent = mergeOptions(parent, child.mixins[i], vm);
    }
  }
  var options = {};
  var key;
  for (key in parent) {
    mergeField(key);
  }
  for (key in child) {
    if (!hasOwn(parent, key)) {
      mergeField(key);
    }
  }
  function mergeField(key) {
    var strat = strats[key] || defaultStrat;
    options[key] = strat(parent[key], child[key], vm, key);
  }
  return options;
}

/**
 * Resolve an asset.
 * This function is used because child instances need access
 * to assets defined in its ancestor chain.
 */
function resolveAsset(options, type, id, warnMissing) {
  /* istanbul ignore if */
  if (typeof id !== 'string') {
    return;
  }
  var assets = options[type];
  // check local registration variations first
  if (hasOwn(assets, id)) {
    return assets[id];
  }
  var camelizedId = camelize(id);
  if (hasOwn(assets, camelizedId)) {
    return assets[camelizedId];
  }
  var PascalCaseId = capitalize(camelizedId);
  if (hasOwn(assets, PascalCaseId)) {
    return assets[PascalCaseId];
  }
  // fallback to prototype chain
  var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];
  if (false) {
    warn('Failed to resolve ' + type.slice(0, -1) + ': ' + id, options);
  }
  return res;
}

/*  */

function validateProp(key, propOptions, propsData, vm) {
  var prop = propOptions[key];
  var absent = !hasOwn(propsData, key);
  var value = propsData[key];
  // handle boolean props
  if (isType(Boolean, prop.type)) {
    if (absent && !hasOwn(prop, 'default')) {
      value = false;
    } else if (!isType(String, prop.type) && (value === '' || value === hyphenate(key))) {
      value = true;
    }
  }
  // check default value
  if (value === undefined) {
    value = getPropDefaultValue(vm, prop, key);
    // since the default value is a fresh copy,
    // make sure to observe it.
    var prevShouldConvert = observerState.shouldConvert;
    observerState.shouldConvert = true;
    observe(value);
    observerState.shouldConvert = prevShouldConvert;
  }
  if (false) {
    assertProp(prop, key, value, vm, absent);
  }
  return value;
}

/**
 * Get the default value of a prop.
 */
function getPropDefaultValue(vm, prop, key) {
  // no default, return undefined
  if (!hasOwn(prop, 'default')) {
    return undefined;
  }
  var def = prop.default;
  // warn against non-factory defaults for Object & Array
  if (false) {
    warn('Invalid default value for prop "' + key + '": ' + 'Props with type Object/Array must use a factory function ' + 'to return the default value.', vm);
  }
  // the raw prop value was also undefined from previous render,
  // return previous default value to avoid unnecessary watcher trigger
  if (vm && vm.$options.propsData && vm.$options.propsData[key] === undefined && vm._props[key] !== undefined) {
    return vm._props[key];
  }
  // call factory function for non-Function types
  // a value is Function if its prototype is function even across different execution context
  return typeof def === 'function' && getType(prop.type) !== 'Function' ? def.call(vm) : def;
}

/**
 * Assert whether a prop is valid.
 */
function assertProp(prop, name, value, vm, absent) {
  if (prop.required && absent) {
    warn('Missing required prop: "' + name + '"', vm);
    return;
  }
  if (value == null && !prop.required) {
    return;
  }
  var type = prop.type;
  var valid = !type || type === true;
  var expectedTypes = [];
  if (type) {
    if (!Array.isArray(type)) {
      type = [type];
    }
    for (var i = 0; i < type.length && !valid; i++) {
      var assertedType = assertType(value, type[i]);
      expectedTypes.push(assertedType.expectedType || '');
      valid = assertedType.valid;
    }
  }
  if (!valid) {
    warn('Invalid prop: type check failed for prop "' + name + '".' + ' Expected ' + expectedTypes.map(capitalize).join(', ') + ', got ' + Object.prototype.toString.call(value).slice(8, -1) + '.', vm);
    return;
  }
  var validator = prop.validator;
  if (validator) {
    if (!validator(value)) {
      warn('Invalid prop: custom validator check failed for prop "' + name + '".', vm);
    }
  }
}

var simpleCheckRE = /^(String|Number|Boolean|Function|Symbol)$/;

function assertType(value, type) {
  var valid;
  var expectedType = getType(type);
  if (simpleCheckRE.test(expectedType)) {
    var t = typeof value;
    valid = t === expectedType.toLowerCase();
    // for primitive wrapper objects
    if (!valid && t === 'object') {
      valid = value instanceof type;
    }
  } else if (expectedType === 'Object') {
    valid = isPlainObject(value);
  } else if (expectedType === 'Array') {
    valid = Array.isArray(value);
  } else {
    valid = value instanceof type;
  }
  return {
    valid: valid,
    expectedType: expectedType
  };
}

/**
 * Use function string name to check built-in types,
 * because a simple equality check will fail when running
 * across different vms / iframes.
 */
function getType(fn) {
  var match = fn && fn.toString().match(/^\s*function (\w+)/);
  return match ? match[1] : '';
}

function isType(type, fn) {
  if (!Array.isArray(fn)) {
    return getType(fn) === getType(type);
  }
  for (var i = 0, len = fn.length; i < len; i++) {
    if (getType(fn[i]) === getType(type)) {
      return true;
    }
  }
  /* istanbul ignore next */
  return false;
}

/*  */

var mark;
var measure;

if (false) {
  var perf = inBrowser && window.performance;
  /* istanbul ignore if */
  if (perf && perf.mark && perf.measure && perf.clearMarks && perf.clearMeasures) {
    mark = function (tag) {
      return perf.mark(tag);
    };
    measure = function (name, startTag, endTag) {
      perf.measure(name, startTag, endTag);
      perf.clearMarks(startTag);
      perf.clearMarks(endTag);
      perf.clearMeasures(name);
    };
  }
}

/* not type checking this file because flow doesn't play well with Proxy */

var initProxy;

if (false) {
  var allowedGlobals = makeMap('Infinity,undefined,NaN,isFinite,isNaN,' + 'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' + 'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' + 'require' // for Webpack/Browserify
  );

  var warnNonPresent = function (target, key) {
    warn("Property or method \"" + key + "\" is not defined on the instance but " + "referenced during render. Make sure to declare reactive data " + "properties in the data option.", target);
  };

  var hasProxy = typeof Proxy !== 'undefined' && Proxy.toString().match(/native code/);

  if (hasProxy) {
    var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta');
    config.keyCodes = new Proxy(config.keyCodes, {
      set: function set(target, key, value) {
        if (isBuiltInModifier(key)) {
          warn("Avoid overwriting built-in modifier in config.keyCodes: ." + key);
          return false;
        } else {
          target[key] = value;
          return true;
        }
      }
    });
  }

  var hasHandler = {
    has: function has(target, key) {
      var has = key in target;
      var isAllowed = allowedGlobals(key) || key.charAt(0) === '_';
      if (!has && !isAllowed) {
        warnNonPresent(target, key);
      }
      return has || !isAllowed;
    }
  };

  var getHandler = {
    get: function get(target, key) {
      if (typeof key === 'string' && !(key in target)) {
        warnNonPresent(target, key);
      }
      return target[key];
    }
  };

  initProxy = function initProxy(vm) {
    if (hasProxy) {
      // determine which proxy handler to use
      var options = vm.$options;
      var handlers = options.render && options.render._withStripped ? getHandler : hasHandler;
      vm._renderProxy = new Proxy(vm, handlers);
    } else {
      vm._renderProxy = vm;
    }
  };
}

/*  */

var VNode = function VNode(tag, data, children, text, elm, context, componentOptions, asyncFactory) {
  this.tag = tag;
  this.data = data;
  this.children = children;
  this.text = text;
  this.elm = elm;
  this.ns = undefined;
  this.context = context;
  this.functionalContext = undefined;
  this.key = data && data.key;
  this.componentOptions = componentOptions;
  this.componentInstance = undefined;
  this.parent = undefined;
  this.raw = false;
  this.isStatic = false;
  this.isRootInsert = true;
  this.isComment = false;
  this.isCloned = false;
  this.isOnce = false;
  this.asyncFactory = asyncFactory;
  this.asyncMeta = undefined;
  this.isAsyncPlaceholder = false;
};

var prototypeAccessors = { child: {} };

// DEPRECATED: alias for componentInstance for backwards compat.
/* istanbul ignore next */
prototypeAccessors.child.get = function () {
  return this.componentInstance;
};

Object.defineProperties(VNode.prototype, prototypeAccessors);

var createEmptyVNode = function (text) {
  if (text === void 0) text = '';

  var node = new VNode();
  node.text = text;
  node.isComment = true;
  return node;
};

function createTextVNode(val) {
  return new VNode(undefined, undefined, undefined, String(val));
}

// optimized shallow clone
// used for static nodes and slot nodes because they may be reused across
// multiple renders, cloning them avoids errors when DOM manipulations rely
// on their elm reference.
function cloneVNode(vnode, deep) {
  var cloned = new VNode(vnode.tag, vnode.data, vnode.children, vnode.text, vnode.elm, vnode.context, vnode.componentOptions, vnode.asyncFactory);
  cloned.ns = vnode.ns;
  cloned.isStatic = vnode.isStatic;
  cloned.key = vnode.key;
  cloned.isComment = vnode.isComment;
  cloned.isCloned = true;
  if (deep && vnode.children) {
    cloned.children = cloneVNodes(vnode.children);
  }
  return cloned;
}

function cloneVNodes(vnodes, deep) {
  var len = vnodes.length;
  var res = new Array(len);
  for (var i = 0; i < len; i++) {
    res[i] = cloneVNode(vnodes[i], deep);
  }
  return res;
}

/*  */

var normalizeEvent = cached(function (name) {
  var passive = name.charAt(0) === '&';
  name = passive ? name.slice(1) : name;
  var once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first
  name = once$$1 ? name.slice(1) : name;
  var capture = name.charAt(0) === '!';
  name = capture ? name.slice(1) : name;
  var plain = !(passive || once$$1 || capture);
  return {
    name: name,
    plain: plain,
    once: once$$1,
    capture: capture,
    passive: passive
  };
});

function createFnInvoker(fns) {
  function invoker() {
    var arguments$1 = arguments;

    var fns = invoker.fns;
    if (Array.isArray(fns)) {
      var cloned = fns.slice();
      for (var i = 0; i < cloned.length; i++) {
        cloned[i].apply(null, arguments$1);
      }
    } else {
      // return handler return value for single handlers
      return fns.apply(null, arguments);
    }
  }
  invoker.fns = fns;
  return invoker;
}

// #6552
function prioritizePlainEvents(a, b) {
  return a.plain ? -1 : b.plain ? 1 : 0;
}

function updateListeners(on, oldOn, add, remove$$1, vm) {
  var name, cur, old, event;
  var toAdd = [];
  var hasModifier = false;
  for (name in on) {
    cur = on[name];
    old = oldOn[name];
    event = normalizeEvent(name);
    if (!event.plain) {
      hasModifier = true;
    }
    if (isUndef(cur)) {
      "production" !== 'production' && warn("Invalid handler for event \"" + event.name + "\": got " + String(cur), vm);
    } else if (isUndef(old)) {
      if (isUndef(cur.fns)) {
        cur = on[name] = createFnInvoker(cur);
      }
      event.handler = cur;
      toAdd.push(event);
    } else if (cur !== old) {
      old.fns = cur;
      on[name] = old;
    }
  }
  if (toAdd.length) {
    if (hasModifier) {
      toAdd.sort(prioritizePlainEvents);
    }
    for (var i = 0; i < toAdd.length; i++) {
      var event$1 = toAdd[i];
      add(event$1.name, event$1.handler, event$1.once, event$1.capture, event$1.passive);
    }
  }
  for (name in oldOn) {
    if (isUndef(on[name])) {
      event = normalizeEvent(name);
      remove$$1(event.name, oldOn[name], event.capture);
    }
  }
}

/*  */

function mergeVNodeHook(def, hookKey, hook) {
  var invoker;
  var oldHook = def[hookKey];

  function wrappedHook() {
    hook.apply(this, arguments);
    // important: remove merged hook to ensure it's called only once
    // and prevent memory leak
    remove(invoker.fns, wrappedHook);
  }

  if (isUndef(oldHook)) {
    // no existing hook
    invoker = createFnInvoker([wrappedHook]);
  } else {
    /* istanbul ignore if */
    if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {
      // already a merged invoker
      invoker = oldHook;
      invoker.fns.push(wrappedHook);
    } else {
      // existing plain hook
      invoker = createFnInvoker([oldHook, wrappedHook]);
    }
  }

  invoker.merged = true;
  def[hookKey] = invoker;
}

/*  */

function extractPropsFromVNodeData(data, Ctor, tag) {
  // we are only extracting raw values here.
  // validation and default values are handled in the child
  // component itself.
  var propOptions = Ctor.options.props;
  if (isUndef(propOptions)) {
    return;
  }
  var res = {};
  var attrs = data.attrs;
  var props = data.props;
  if (isDef(attrs) || isDef(props)) {
    for (var key in propOptions) {
      var altKey = hyphenate(key);
      if (false) {
        var keyInLowerCase = key.toLowerCase();
        if (key !== keyInLowerCase && attrs && hasOwn(attrs, keyInLowerCase)) {
          tip("Prop \"" + keyInLowerCase + "\" is passed to component " + formatComponentName(tag || Ctor) + ", but the declared prop name is" + " \"" + key + "\". " + "Note that HTML attributes are case-insensitive and camelCased " + "props need to use their kebab-case equivalents when using in-DOM " + "templates. You should probably use \"" + altKey + "\" instead of \"" + key + "\".");
        }
      }
      checkProp(res, props, key, altKey, true) || checkProp(res, attrs, key, altKey, false);
    }
  }
  return res;
}

function checkProp(res, hash, key, altKey, preserve) {
  if (isDef(hash)) {
    if (hasOwn(hash, key)) {
      res[key] = hash[key];
      if (!preserve) {
        delete hash[key];
      }
      return true;
    } else if (hasOwn(hash, altKey)) {
      res[key] = hash[altKey];
      if (!preserve) {
        delete hash[altKey];
      }
      return true;
    }
  }
  return false;
}

/*  */

// The template compiler attempts to minimize the need for normalization by
// statically analyzing the template at compile time.
//
// For plain HTML markup, normalization can be completely skipped because the
// generated render function is guaranteed to return Array<VNode>. There are
// two cases where extra normalization is needed:

// 1. When the children contains components - because a functional component
// may return an Array instead of a single root. In this case, just a simple
// normalization is needed - if any child is an Array, we flatten the whole
// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep
// because functional components already normalize their own children.
function simpleNormalizeChildren(children) {
  for (var i = 0; i < children.length; i++) {
    if (Array.isArray(children[i])) {
      return Array.prototype.concat.apply([], children);
    }
  }
  return children;
}

// 2. When the children contains constructs that always generated nested Arrays,
// e.g. <template>, <slot>, v-for, or when the children is provided by user
// with hand-written render functions / JSX. In such cases a full normalization
// is needed to cater to all possible types of children values.
function normalizeChildren(children) {
  return isPrimitive(children) ? [createTextVNode(children)] : Array.isArray(children) ? normalizeArrayChildren(children) : undefined;
}

function isTextNode(node) {
  return isDef(node) && isDef(node.text) && isFalse(node.isComment);
}

function normalizeArrayChildren(children, nestedIndex) {
  var res = [];
  var i, c, last;
  for (i = 0; i < children.length; i++) {
    c = children[i];
    if (isUndef(c) || typeof c === 'boolean') {
      continue;
    }
    last = res[res.length - 1];
    //  nested
    if (Array.isArray(c)) {
      res.push.apply(res, normalizeArrayChildren(c, (nestedIndex || '') + "_" + i));
    } else if (isPrimitive(c)) {
      if (isTextNode(last)) {
        // merge adjacent text nodes
        // this is necessary for SSR hydration because text nodes are
        // essentially merged when rendered to HTML strings
        last.text += String(c);
      } else if (c !== '') {
        // convert primitive to vnode
        res.push(createTextVNode(c));
      }
    } else {
      if (isTextNode(c) && isTextNode(last)) {
        // merge adjacent text nodes
        res[res.length - 1] = createTextVNode(last.text + c.text);
      } else {
        // default key for nested array children (likely generated by v-for)
        if (isTrue(children._isVList) && isDef(c.tag) && isUndef(c.key) && isDef(nestedIndex)) {
          c.key = "__vlist" + nestedIndex + "_" + i + "__";
        }
        res.push(c);
      }
    }
  }
  return res;
}

/*  */

function ensureCtor(comp, base) {
  if (comp.__esModule && comp.default) {
    comp = comp.default;
  }
  return isObject(comp) ? base.extend(comp) : comp;
}

function createAsyncPlaceholder(factory, data, context, children, tag) {
  var node = createEmptyVNode();
  node.asyncFactory = factory;
  node.asyncMeta = { data: data, context: context, children: children, tag: tag };
  return node;
}

function resolveAsyncComponent(factory, baseCtor, context) {
  if (isTrue(factory.error) && isDef(factory.errorComp)) {
    return factory.errorComp;
  }

  if (isDef(factory.resolved)) {
    return factory.resolved;
  }

  if (isTrue(factory.loading) && isDef(factory.loadingComp)) {
    return factory.loadingComp;
  }

  if (isDef(factory.contexts)) {
    // already pending
    factory.contexts.push(context);
  } else {
    var contexts = factory.contexts = [context];
    var sync = true;

    var forceRender = function () {
      for (var i = 0, l = contexts.length; i < l; i++) {
        contexts[i].$forceUpdate();
      }
    };

    var resolve = once(function (res) {
      // cache resolved
      factory.resolved = ensureCtor(res, baseCtor);
      // invoke callbacks only if this is not a synchronous resolve
      // (async resolves are shimmed as synchronous during SSR)
      if (!sync) {
        forceRender();
      }
    });

    var reject = once(function (reason) {
      "production" !== 'production' && warn("Failed to resolve async component: " + String(factory) + (reason ? "\nReason: " + reason : ''));
      if (isDef(factory.errorComp)) {
        factory.error = true;
        forceRender();
      }
    });

    var res = factory(resolve, reject);

    if (isObject(res)) {
      if (typeof res.then === 'function') {
        // () => Promise
        if (isUndef(factory.resolved)) {
          res.then(resolve, reject);
        }
      } else if (isDef(res.component) && typeof res.component.then === 'function') {
        res.component.then(resolve, reject);

        if (isDef(res.error)) {
          factory.errorComp = ensureCtor(res.error, baseCtor);
        }

        if (isDef(res.loading)) {
          factory.loadingComp = ensureCtor(res.loading, baseCtor);
          if (res.delay === 0) {
            factory.loading = true;
          } else {
            setTimeout(function () {
              if (isUndef(factory.resolved) && isUndef(factory.error)) {
                factory.loading = true;
                forceRender();
              }
            }, res.delay || 200);
          }
        }

        if (isDef(res.timeout)) {
          setTimeout(function () {
            if (isUndef(factory.resolved)) {
              reject( false ? "timeout (" + res.timeout + "ms)" : null);
            }
          }, res.timeout);
        }
      }
    }

    sync = false;
    // return in case resolved synchronously
    return factory.loading ? factory.loadingComp : factory.resolved;
  }
}

/*  */

function isAsyncPlaceholder(node) {
  return node.isComment && node.asyncFactory;
}

/*  */

function getFirstComponentChild(children) {
  if (Array.isArray(children)) {
    for (var i = 0; i < children.length; i++) {
      var c = children[i];
      if (isDef(c) && (isDef(c.componentOptions) || isAsyncPlaceholder(c))) {
        return c;
      }
    }
  }
}

/*  */

/*  */

function initEvents(vm) {
  vm._events = Object.create(null);
  vm._hasHookEvent = false;
  // init parent attached events
  var listeners = vm.$options._parentListeners;
  if (listeners) {
    updateComponentListeners(vm, listeners);
  }
}

var target;

function add(event, fn, once$$1) {
  if (once$$1) {
    target.$once(event, fn);
  } else {
    target.$on(event, fn);
  }
}

function remove$1(event, fn) {
  target.$off(event, fn);
}

function updateComponentListeners(vm, listeners, oldListeners) {
  target = vm;
  updateListeners(listeners, oldListeners || {}, add, remove$1, vm);
}

function eventsMixin(Vue) {
  var hookRE = /^hook:/;
  Vue.prototype.$on = function (event, fn) {
    var this$1 = this;

    var vm = this;
    if (Array.isArray(event)) {
      for (var i = 0, l = event.length; i < l; i++) {
        this$1.$on(event[i], fn);
      }
    } else {
      (vm._events[event] || (vm._events[event] = [])).push(fn);
      // optimize hook:event cost by using a boolean flag marked at registration
      // instead of a hash lookup
      if (hookRE.test(event)) {
        vm._hasHookEvent = true;
      }
    }
    return vm;
  };

  Vue.prototype.$once = function (event, fn) {
    var vm = this;
    function on() {
      vm.$off(event, on);
      fn.apply(vm, arguments);
    }
    on.fn = fn;
    vm.$on(event, on);
    return vm;
  };

  Vue.prototype.$off = function (event, fn) {
    var this$1 = this;

    var vm = this;
    // all
    if (!arguments.length) {
      vm._events = Object.create(null);
      return vm;
    }
    // array of events
    if (Array.isArray(event)) {
      for (var i = 0, l = event.length; i < l; i++) {
        this$1.$off(event[i], fn);
      }
      return vm;
    }
    // specific event
    var cbs = vm._events[event];
    if (!cbs) {
      return vm;
    }
    if (arguments.length === 1) {
      vm._events[event] = null;
      return vm;
    }
    if (fn) {
      // specific handler
      var cb;
      var i$1 = cbs.length;
      while (i$1--) {
        cb = cbs[i$1];
        if (cb === fn || cb.fn === fn) {
          cbs.splice(i$1, 1);
          break;
        }
      }
    }
    return vm;
  };

  Vue.prototype.$emit = function (event) {
    var vm = this;
    if (false) {
      var lowerCaseEvent = event.toLowerCase();
      if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {
        tip("Event \"" + lowerCaseEvent + "\" is emitted in component " + formatComponentName(vm) + " but the handler is registered for \"" + event + "\". " + "Note that HTML attributes are case-insensitive and you cannot use " + "v-on to listen to camelCase events when using in-DOM templates. " + "You should probably use \"" + hyphenate(event) + "\" instead of \"" + event + "\".");
      }
    }
    var cbs = vm._events[event];
    if (cbs) {
      cbs = cbs.length > 1 ? toArray(cbs) : cbs;
      var args = toArray(arguments, 1);
      for (var i = 0, l = cbs.length; i < l; i++) {
        try {
          cbs[i].apply(vm, args);
        } catch (e) {
          handleError(e, vm, "event handler for \"" + event + "\"");
        }
      }
    }
    return vm;
  };
}

/*  */

/**
 * Runtime helper for resolving raw children VNodes into a slot object.
 */
function resolveSlots(children, context) {
  var slots = {};
  if (!children) {
    return slots;
  }
  var defaultSlot = [];
  for (var i = 0, l = children.length; i < l; i++) {
    var child = children[i];
    var data = child.data;
    // remove slot attribute if the node is resolved as a Vue slot node
    if (data && data.attrs && data.attrs.slot) {
      delete data.attrs.slot;
    }
    // named slots should only be respected if the vnode was rendered in the
    // same context.
    if ((child.context === context || child.functionalContext === context) && data && data.slot != null) {
      var name = child.data.slot;
      var slot = slots[name] || (slots[name] = []);
      if (child.tag === 'template') {
        slot.push.apply(slot, child.children);
      } else {
        slot.push(child);
      }
    } else {
      defaultSlot.push(child);
    }
  }
  // ignore whitespace
  if (!defaultSlot.every(isWhitespace)) {
    slots.default = defaultSlot;
  }
  return slots;
}

function isWhitespace(node) {
  return node.isComment || node.text === ' ';
}

function resolveScopedSlots(fns, // see flow/vnode
res) {
  res = res || {};
  for (var i = 0; i < fns.length; i++) {
    if (Array.isArray(fns[i])) {
      resolveScopedSlots(fns[i], res);
    } else {
      res[fns[i].key] = fns[i].fn;
    }
  }
  return res;
}

/*  */

var activeInstance = null;
var isUpdatingChildComponent = false;

function initLifecycle(vm) {
  var options = vm.$options;

  // locate first non-abstract parent
  var parent = options.parent;
  if (parent && !options.abstract) {
    while (parent.$options.abstract && parent.$parent) {
      parent = parent.$parent;
    }
    parent.$children.push(vm);
  }

  vm.$parent = parent;
  vm.$root = parent ? parent.$root : vm;

  vm.$children = [];
  vm.$refs = {};

  vm._watcher = null;
  vm._inactive = null;
  vm._directInactive = false;
  vm._isMounted = false;
  vm._isDestroyed = false;
  vm._isBeingDestroyed = false;
}

function lifecycleMixin(Vue) {
  Vue.prototype._update = function (vnode, hydrating) {
    var vm = this;
    if (vm._isMounted) {
      callHook(vm, 'beforeUpdate');
    }
    var prevEl = vm.$el;
    var prevVnode = vm._vnode;
    var prevActiveInstance = activeInstance;
    activeInstance = vm;
    vm._vnode = vnode;
    // Vue.prototype.__patch__ is injected in entry points
    // based on the rendering backend used.
    if (!prevVnode) {
      // initial render
      vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */
      , vm.$options._parentElm, vm.$options._refElm);
      // no need for the ref nodes after initial patch
      // this prevents keeping a detached DOM tree in memory (#5851)
      vm.$options._parentElm = vm.$options._refElm = null;
    } else {
      // updates
      vm.$el = vm.__patch__(prevVnode, vnode);
    }
    activeInstance = prevActiveInstance;
    // update __vue__ reference
    if (prevEl) {
      prevEl.__vue__ = null;
    }
    if (vm.$el) {
      vm.$el.__vue__ = vm;
    }
    // if parent is an HOC, update its $el as well
    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {
      vm.$parent.$el = vm.$el;
    }
    // updated hook is called by the scheduler to ensure that children are
    // updated in a parent's updated hook.
  };

  Vue.prototype.$forceUpdate = function () {
    var vm = this;
    if (vm._watcher) {
      vm._watcher.update();
    }
  };

  Vue.prototype.$destroy = function () {
    var vm = this;
    if (vm._isBeingDestroyed) {
      return;
    }
    callHook(vm, 'beforeDestroy');
    vm._isBeingDestroyed = true;
    // remove self from parent
    var parent = vm.$parent;
    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {
      remove(parent.$children, vm);
    }
    // teardown watchers
    if (vm._watcher) {
      vm._watcher.teardown();
    }
    var i = vm._watchers.length;
    while (i--) {
      vm._watchers[i].teardown();
    }
    // remove reference from data ob
    // frozen object may not have observer.
    if (vm._data.__ob__) {
      vm._data.__ob__.vmCount--;
    }
    // call the last hook...
    vm._isDestroyed = true;
    // invoke destroy hooks on current rendered tree
    vm.__patch__(vm._vnode, null);
    // fire destroyed hook
    callHook(vm, 'destroyed');
    // turn off all instance listeners.
    vm.$off();
    // remove __vue__ reference
    if (vm.$el) {
      vm.$el.__vue__ = null;
    }
  };
}

function mountComponent(vm, el, hydrating) {
  vm.$el = el;
  if (!vm.$options.render) {
    vm.$options.render = createEmptyVNode;
    if (false) {
      /* istanbul ignore if */
      if (vm.$options.template && vm.$options.template.charAt(0) !== '#' || vm.$options.el || el) {
        warn('You are using the runtime-only build of Vue where the template ' + 'compiler is not available. Either pre-compile the templates into ' + 'render functions, or use the compiler-included build.', vm);
      } else {
        warn('Failed to mount component: template or render function not defined.', vm);
      }
    }
  }
  callHook(vm, 'beforeMount');

  var updateComponent;
  /* istanbul ignore if */
  if (false) {
    updateComponent = function () {
      var name = vm._name;
      var id = vm._uid;
      var startTag = "vue-perf-start:" + id;
      var endTag = "vue-perf-end:" + id;

      mark(startTag);
      var vnode = vm._render();
      mark(endTag);
      measure(name + " render", startTag, endTag);

      mark(startTag);
      vm._update(vnode, hydrating);
      mark(endTag);
      measure(name + " patch", startTag, endTag);
    };
  } else {
    updateComponent = function () {
      vm._update(vm._render(), hydrating);
    };
  }

  vm._watcher = new Watcher(vm, updateComponent, noop);
  hydrating = false;

  // manually mounted instance, call mounted on self
  // mounted is called for render-created child components in its inserted hook
  if (vm.$vnode == null) {
    vm._isMounted = true;
    callHook(vm, 'mounted');
  }
  return vm;
}

function updateChildComponent(vm, propsData, listeners, parentVnode, renderChildren) {
  if (false) {
    isUpdatingChildComponent = true;
  }

  // determine whether component has slot children
  // we need to do this before overwriting $options._renderChildren
  var hasChildren = !!(renderChildren || // has new static slots
  vm.$options._renderChildren || // has old static slots
  parentVnode.data.scopedSlots || // has new scoped slots
  vm.$scopedSlots !== emptyObject // has old scoped slots
  );

  vm.$options._parentVnode = parentVnode;
  vm.$vnode = parentVnode; // update vm's placeholder node without re-render

  if (vm._vnode) {
    // update child tree's parent
    vm._vnode.parent = parentVnode;
  }
  vm.$options._renderChildren = renderChildren;

  // update $attrs and $listeners hash
  // these are also reactive so they may trigger child update if the child
  // used them during render
  vm.$attrs = parentVnode.data && parentVnode.data.attrs || emptyObject;
  vm.$listeners = listeners || emptyObject;

  // update props
  if (propsData && vm.$options.props) {
    observerState.shouldConvert = false;
    var props = vm._props;
    var propKeys = vm.$options._propKeys || [];
    for (var i = 0; i < propKeys.length; i++) {
      var key = propKeys[i];
      props[key] = validateProp(key, vm.$options.props, propsData, vm);
    }
    observerState.shouldConvert = true;
    // keep a copy of raw propsData
    vm.$options.propsData = propsData;
  }

  // update listeners
  if (listeners) {
    var oldListeners = vm.$options._parentListeners;
    vm.$options._parentListeners = listeners;
    updateComponentListeners(vm, listeners, oldListeners);
  }
  // resolve slots + force update if has children
  if (hasChildren) {
    vm.$slots = resolveSlots(renderChildren, parentVnode.context);
    vm.$forceUpdate();
  }

  if (false) {
    isUpdatingChildComponent = false;
  }
}

function isInInactiveTree(vm) {
  while (vm && (vm = vm.$parent)) {
    if (vm._inactive) {
      return true;
    }
  }
  return false;
}

function activateChildComponent(vm, direct) {
  if (direct) {
    vm._directInactive = false;
    if (isInInactiveTree(vm)) {
      return;
    }
  } else if (vm._directInactive) {
    return;
  }
  if (vm._inactive || vm._inactive === null) {
    vm._inactive = false;
    for (var i = 0; i < vm.$children.length; i++) {
      activateChildComponent(vm.$children[i]);
    }
    callHook(vm, 'activated');
  }
}

function deactivateChildComponent(vm, direct) {
  if (direct) {
    vm._directInactive = true;
    if (isInInactiveTree(vm)) {
      return;
    }
  }
  if (!vm._inactive) {
    vm._inactive = true;
    for (var i = 0; i < vm.$children.length; i++) {
      deactivateChildComponent(vm.$children[i]);
    }
    callHook(vm, 'deactivated');
  }
}

function callHook(vm, hook) {
  var handlers = vm.$options[hook];
  if (handlers) {
    for (var i = 0, j = handlers.length; i < j; i++) {
      try {
        handlers[i].call(vm);
      } catch (e) {
        handleError(e, vm, hook + " hook");
      }
    }
  }
  if (vm._hasHookEvent) {
    vm.$emit('hook:' + hook);
  }
}

/*  */

var MAX_UPDATE_COUNT = 100;

var queue = [];
var activatedChildren = [];
var has = {};
var circular = {};
var waiting = false;
var flushing = false;
var index = 0;

/**
 * Reset the scheduler's state.
 */
function resetSchedulerState() {
  index = queue.length = activatedChildren.length = 0;
  has = {};
  if (false) {
    circular = {};
  }
  waiting = flushing = false;
}

/**
 * Flush both queues and run the watchers.
 */
function flushSchedulerQueue() {
  flushing = true;
  var watcher, id;

  // Sort queue before flush.
  // This ensures that:
  // 1. Components are updated from parent to child. (because parent is always
  //    created before the child)
  // 2. A component's user watchers are run before its render watcher (because
  //    user watchers are created before the render watcher)
  // 3. If a component is destroyed during a parent component's watcher run,
  //    its watchers can be skipped.
  queue.sort(function (a, b) {
    return a.id - b.id;
  });

  // do not cache length because more watchers might be pushed
  // as we run existing watchers
  for (index = 0; index < queue.length; index++) {
    watcher = queue[index];
    id = watcher.id;
    has[id] = null;
    watcher.run();
    // in dev build, check and stop circular updates.
    if (false) {
      circular[id] = (circular[id] || 0) + 1;
      if (circular[id] > MAX_UPDATE_COUNT) {
        warn('You may have an infinite update loop ' + (watcher.user ? "in watcher with expression \"" + watcher.expression + "\"" : "in a component render function."), watcher.vm);
        break;
      }
    }
  }

  // keep copies of post queues before resetting state
  var activatedQueue = activatedChildren.slice();
  var updatedQueue = queue.slice();

  resetSchedulerState();

  // call component updated and activated hooks
  callActivatedHooks(activatedQueue);
  callUpdatedHooks(updatedQueue);

  // devtool hook
  /* istanbul ignore if */
  if (devtools && config.devtools) {
    devtools.emit('flush');
  }
}

function callUpdatedHooks(queue) {
  var i = queue.length;
  while (i--) {
    var watcher = queue[i];
    var vm = watcher.vm;
    if (vm._watcher === watcher && vm._isMounted) {
      callHook(vm, 'updated');
    }
  }
}

/**
 * Queue a kept-alive component that was activated during patch.
 * The queue will be processed after the entire tree has been patched.
 */
function queueActivatedComponent(vm) {
  // setting _inactive to false here so that a render function can
  // rely on checking whether it's in an inactive tree (e.g. router-view)
  vm._inactive = false;
  activatedChildren.push(vm);
}

function callActivatedHooks(queue) {
  for (var i = 0; i < queue.length; i++) {
    queue[i]._inactive = true;
    activateChildComponent(queue[i], true /* true */);
  }
}

/**
 * Push a watcher into the watcher queue.
 * Jobs with duplicate IDs will be skipped unless it's
 * pushed when the queue is being flushed.
 */
function queueWatcher(watcher) {
  var id = watcher.id;
  if (has[id] == null) {
    has[id] = true;
    if (!flushing) {
      queue.push(watcher);
    } else {
      // if already flushing, splice the watcher based on its id
      // if already past its id, it will be run next immediately.
      var i = queue.length - 1;
      while (i > index && queue[i].id > watcher.id) {
        i--;
      }
      queue.splice(i + 1, 0, watcher);
    }
    // queue the flush
    if (!waiting) {
      waiting = true;
      nextTick(flushSchedulerQueue);
    }
  }
}

/*  */

var uid$2 = 0;

/**
 * A watcher parses an expression, collects dependencies,
 * and fires callback when the expression value changes.
 * This is used for both the $watch() api and directives.
 */
var Watcher = function Watcher(vm, expOrFn, cb, options) {
  this.vm = vm;
  vm._watchers.push(this);
  // options
  if (options) {
    this.deep = !!options.deep;
    this.user = !!options.user;
    this.lazy = !!options.lazy;
    this.sync = !!options.sync;
  } else {
    this.deep = this.user = this.lazy = this.sync = false;
  }
  this.cb = cb;
  this.id = ++uid$2; // uid for batching
  this.active = true;
  this.dirty = this.lazy; // for lazy watchers
  this.deps = [];
  this.newDeps = [];
  this.depIds = new _Set();
  this.newDepIds = new _Set();
  this.expression =  false ? expOrFn.toString() : '';
  // parse expression for getter
  if (typeof expOrFn === 'function') {
    this.getter = expOrFn;
  } else {
    this.getter = parsePath(expOrFn);
    if (!this.getter) {
      this.getter = function () {};
      "production" !== 'production' && warn("Failed watching path: \"" + expOrFn + "\" " + 'Watcher only accepts simple dot-delimited paths. ' + 'For full control, use a function instead.', vm);
    }
  }
  this.value = this.lazy ? undefined : this.get();
};

/**
 * Evaluate the getter, and re-collect dependencies.
 */
Watcher.prototype.get = function get() {
  pushTarget(this);
  var value;
  var vm = this.vm;
  try {
    value = this.getter.call(vm, vm);
  } catch (e) {
    if (this.user) {
      handleError(e, vm, "getter for watcher \"" + this.expression + "\"");
    } else {
      throw e;
    }
  } finally {
    // "touch" every property so they are all tracked as
    // dependencies for deep watching
    if (this.deep) {
      traverse(value);
    }
    popTarget();
    this.cleanupDeps();
  }
  return value;
};

/**
 * Add a dependency to this directive.
 */
Watcher.prototype.addDep = function addDep(dep) {
  var id = dep.id;
  if (!this.newDepIds.has(id)) {
    this.newDepIds.add(id);
    this.newDeps.push(dep);
    if (!this.depIds.has(id)) {
      dep.addSub(this);
    }
  }
};

/**
 * Clean up for dependency collection.
 */
Watcher.prototype.cleanupDeps = function cleanupDeps() {
  var this$1 = this;

  var i = this.deps.length;
  while (i--) {
    var dep = this$1.deps[i];
    if (!this$1.newDepIds.has(dep.id)) {
      dep.removeSub(this$1);
    }
  }
  var tmp = this.depIds;
  this.depIds = this.newDepIds;
  this.newDepIds = tmp;
  this.newDepIds.clear();
  tmp = this.deps;
  this.deps = this.newDeps;
  this.newDeps = tmp;
  this.newDeps.length = 0;
};

/**
 * Subscriber interface.
 * Will be called when a dependency changes.
 */
Watcher.prototype.update = function update() {
  /* istanbul ignore else */
  if (this.lazy) {
    this.dirty = true;
  } else if (this.sync) {
    this.run();
  } else {
    queueWatcher(this);
  }
};

/**
 * Scheduler job interface.
 * Will be called by the scheduler.
 */
Watcher.prototype.run = function run() {
  if (this.active) {
    var value = this.get();
    if (value !== this.value ||
    // Deep watchers and watchers on Object/Arrays should fire even
    // when the value is the same, because the value may
    // have mutated.
    isObject(value) || this.deep) {
      // set new value
      var oldValue = this.value;
      this.value = value;
      if (this.user) {
        try {
          this.cb.call(this.vm, value, oldValue);
        } catch (e) {
          handleError(e, this.vm, "callback for watcher \"" + this.expression + "\"");
        }
      } else {
        this.cb.call(this.vm, value, oldValue);
      }
    }
  }
};

/**
 * Evaluate the value of the watcher.
 * This only gets called for lazy watchers.
 */
Watcher.prototype.evaluate = function evaluate() {
  this.value = this.get();
  this.dirty = false;
};

/**
 * Depend on all deps collected by this watcher.
 */
Watcher.prototype.depend = function depend() {
  var this$1 = this;

  var i = this.deps.length;
  while (i--) {
    this$1.deps[i].depend();
  }
};

/**
 * Remove self from all dependencies' subscriber list.
 */
Watcher.prototype.teardown = function teardown() {
  var this$1 = this;

  if (this.active) {
    // remove self from vm's watcher list
    // this is a somewhat expensive operation so we skip it
    // if the vm is being destroyed.
    if (!this.vm._isBeingDestroyed) {
      remove(this.vm._watchers, this);
    }
    var i = this.deps.length;
    while (i--) {
      this$1.deps[i].removeSub(this$1);
    }
    this.active = false;
  }
};

/**
 * Recursively traverse an object to evoke all converted
 * getters, so that every nested property inside the object
 * is collected as a "deep" dependency.
 */
var seenObjects = new _Set();
function traverse(val) {
  seenObjects.clear();
  _traverse(val, seenObjects);
}

function _traverse(val, seen) {
  var i, keys;
  var isA = Array.isArray(val);
  if (!isA && !isObject(val) || !Object.isExtensible(val)) {
    return;
  }
  if (val.__ob__) {
    var depId = val.__ob__.dep.id;
    if (seen.has(depId)) {
      return;
    }
    seen.add(depId);
  }
  if (isA) {
    i = val.length;
    while (i--) {
      _traverse(val[i], seen);
    }
  } else {
    keys = Object.keys(val);
    i = keys.length;
    while (i--) {
      _traverse(val[keys[i]], seen);
    }
  }
}

/*  */

var sharedPropertyDefinition = {
  enumerable: true,
  configurable: true,
  get: noop,
  set: noop
};

function proxy(target, sourceKey, key) {
  sharedPropertyDefinition.get = function proxyGetter() {
    return this[sourceKey][key];
  };
  sharedPropertyDefinition.set = function proxySetter(val) {
    this[sourceKey][key] = val;
  };
  Object.defineProperty(target, key, sharedPropertyDefinition);
}

function initState(vm) {
  vm._watchers = [];
  var opts = vm.$options;
  if (opts.props) {
    initProps(vm, opts.props);
  }
  if (opts.methods) {
    initMethods(vm, opts.methods);
  }
  if (opts.data) {
    initData(vm);
  } else {
    observe(vm._data = {}, true /* asRootData */);
  }
  if (opts.computed) {
    initComputed(vm, opts.computed);
  }
  if (opts.watch && opts.watch !== nativeWatch) {
    initWatch(vm, opts.watch);
  }
}

function checkOptionType(vm, name) {
  var option = vm.$options[name];
  if (!isPlainObject(option)) {
    warn("component option \"" + name + "\" should be an object.", vm);
  }
}

function initProps(vm, propsOptions) {
  var propsData = vm.$options.propsData || {};
  var props = vm._props = {};
  // cache prop keys so that future props updates can iterate using Array
  // instead of dynamic object key enumeration.
  var keys = vm.$options._propKeys = [];
  var isRoot = !vm.$parent;
  // root instance props should be converted
  observerState.shouldConvert = isRoot;
  var loop = function (key) {
    keys.push(key);
    var value = validateProp(key, propsOptions, propsData, vm);
    /* istanbul ignore else */
    if (false) {
      if (isReservedAttribute(key) || config.isReservedAttr(key)) {
        warn("\"" + key + "\" is a reserved attribute and cannot be used as component prop.", vm);
      }
      defineReactive$$1(props, key, value, function () {
        if (vm.$parent && !isUpdatingChildComponent) {
          warn("Avoid mutating a prop directly since the value will be " + "overwritten whenever the parent component re-renders. " + "Instead, use a data or computed property based on the prop's " + "value. Prop being mutated: \"" + key + "\"", vm);
        }
      });
    } else {
      defineReactive$$1(props, key, value);
    }
    // static props are already proxied on the component's prototype
    // during Vue.extend(). We only need to proxy props defined at
    // instantiation here.
    if (!(key in vm)) {
      proxy(vm, "_props", key);
    }
  };

  for (var key in propsOptions) loop(key);
  observerState.shouldConvert = true;
}

function initData(vm) {
  var data = vm.$options.data;
  data = vm._data = typeof data === 'function' ? getData(data, vm) : data || {};
  if (!isPlainObject(data)) {
    data = {};
    "production" !== 'production' && warn('data functions should return an object:\n' + 'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function', vm);
  }
  // proxy data on instance
  var keys = Object.keys(data);
  var props = vm.$options.props;
  var methods = vm.$options.methods;
  var i = keys.length;
  while (i--) {
    var key = keys[i];
    if (false) {
      if (methods && hasOwn(methods, key)) {
        warn("Method \"" + key + "\" has already been defined as a data property.", vm);
      }
    }
    if (props && hasOwn(props, key)) {
      "production" !== 'production' && warn("The data property \"" + key + "\" is already declared as a prop. " + "Use prop default value instead.", vm);
    } else if (!isReserved(key)) {
      proxy(vm, "_data", key);
    }
  }
  // observe data
  observe(data, true /* asRootData */);
}

function getData(data, vm) {
  try {
    return data.call(vm);
  } catch (e) {
    handleError(e, vm, "data()");
    return {};
  }
}

var computedWatcherOptions = { lazy: true };

function initComputed(vm, computed) {
  "production" !== 'production' && checkOptionType(vm, 'computed');
  var watchers = vm._computedWatchers = Object.create(null);
  // computed properties are just getters during SSR
  var isSSR = isServerRendering();

  for (var key in computed) {
    var userDef = computed[key];
    var getter = typeof userDef === 'function' ? userDef : userDef.get;
    if (false) {
      warn("Getter is missing for computed property \"" + key + "\".", vm);
    }

    if (!isSSR) {
      // create internal watcher for the computed property.
      watchers[key] = new Watcher(vm, getter || noop, noop, computedWatcherOptions);
    }

    // component-defined computed properties are already defined on the
    // component prototype. We only need to define computed properties defined
    // at instantiation here.
    if (!(key in vm)) {
      defineComputed(vm, key, userDef);
    } else if (false) {
      if (key in vm.$data) {
        warn("The computed property \"" + key + "\" is already defined in data.", vm);
      } else if (vm.$options.props && key in vm.$options.props) {
        warn("The computed property \"" + key + "\" is already defined as a prop.", vm);
      }
    }
  }
}

function defineComputed(target, key, userDef) {
  var shouldCache = !isServerRendering();
  if (typeof userDef === 'function') {
    sharedPropertyDefinition.get = shouldCache ? createComputedGetter(key) : userDef;
    sharedPropertyDefinition.set = noop;
  } else {
    sharedPropertyDefinition.get = userDef.get ? shouldCache && userDef.cache !== false ? createComputedGetter(key) : userDef.get : noop;
    sharedPropertyDefinition.set = userDef.set ? userDef.set : noop;
  }
  if (false) {
    sharedPropertyDefinition.set = function () {
      warn("Computed property \"" + key + "\" was assigned to but it has no setter.", this);
    };
  }
  Object.defineProperty(target, key, sharedPropertyDefinition);
}

function createComputedGetter(key) {
  return function computedGetter() {
    var watcher = this._computedWatchers && this._computedWatchers[key];
    if (watcher) {
      if (watcher.dirty) {
        watcher.evaluate();
      }
      if (Dep.target) {
        watcher.depend();
      }
      return watcher.value;
    }
  };
}

function initMethods(vm, methods) {
  "production" !== 'production' && checkOptionType(vm, 'methods');
  var props = vm.$options.props;
  for (var key in methods) {
    if (false) {
      if (methods[key] == null) {
        warn("Method \"" + key + "\" has an undefined value in the component definition. " + "Did you reference the function correctly?", vm);
      }
      if (props && hasOwn(props, key)) {
        warn("Method \"" + key + "\" has already been defined as a prop.", vm);
      }
      if (key in vm && isReserved(key)) {
        warn("Method \"" + key + "\" conflicts with an existing Vue instance method. " + "Avoid defining component methods that start with _ or $.");
      }
    }
    vm[key] = methods[key] == null ? noop : bind(methods[key], vm);
  }
}

function initWatch(vm, watch) {
  "production" !== 'production' && checkOptionType(vm, 'watch');
  for (var key in watch) {
    var handler = watch[key];
    if (Array.isArray(handler)) {
      for (var i = 0; i < handler.length; i++) {
        createWatcher(vm, key, handler[i]);
      }
    } else {
      createWatcher(vm, key, handler);
    }
  }
}

function createWatcher(vm, keyOrFn, handler, options) {
  if (isPlainObject(handler)) {
    options = handler;
    handler = handler.handler;
  }
  if (typeof handler === 'string') {
    handler = vm[handler];
  }
  return vm.$watch(keyOrFn, handler, options);
}

function stateMixin(Vue) {
  // flow somehow has problems with directly declared definition object
  // when using Object.defineProperty, so we have to procedurally build up
  // the object here.
  var dataDef = {};
  dataDef.get = function () {
    return this._data;
  };
  var propsDef = {};
  propsDef.get = function () {
    return this._props;
  };
  if (false) {
    dataDef.set = function (newData) {
      warn('Avoid replacing instance root $data. ' + 'Use nested data properties instead.', this);
    };
    propsDef.set = function () {
      warn("$props is readonly.", this);
    };
  }
  Object.defineProperty(Vue.prototype, '$data', dataDef);
  Object.defineProperty(Vue.prototype, '$props', propsDef);

  Vue.prototype.$set = set;
  Vue.prototype.$delete = del;

  Vue.prototype.$watch = function (expOrFn, cb, options) {
    var vm = this;
    if (isPlainObject(cb)) {
      return createWatcher(vm, expOrFn, cb, options);
    }
    options = options || {};
    options.user = true;
    var watcher = new Watcher(vm, expOrFn, cb, options);
    if (options.immediate) {
      cb.call(vm, watcher.value);
    }
    return function unwatchFn() {
      watcher.teardown();
    };
  };
}

/*  */

function initProvide(vm) {
  var provide = vm.$options.provide;
  if (provide) {
    vm._provided = typeof provide === 'function' ? provide.call(vm) : provide;
  }
}

function initInjections(vm) {
  var result = resolveInject(vm.$options.inject, vm);
  if (result) {
    observerState.shouldConvert = false;
    Object.keys(result).forEach(function (key) {
      /* istanbul ignore else */
      if (false) {
        defineReactive$$1(vm, key, result[key], function () {
          warn("Avoid mutating an injected value directly since the changes will be " + "overwritten whenever the provided component re-renders. " + "injection being mutated: \"" + key + "\"", vm);
        });
      } else {
        defineReactive$$1(vm, key, result[key]);
      }
    });
    observerState.shouldConvert = true;
  }
}

function resolveInject(inject, vm) {
  if (inject) {
    // inject is :any because flow is not smart enough to figure out cached
    var result = Object.create(null);
    var keys = hasSymbol ? Reflect.ownKeys(inject).filter(function (key) {
      /* istanbul ignore next */
      return Object.getOwnPropertyDescriptor(inject, key).enumerable;
    }) : Object.keys(inject);

    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      var provideKey = inject[key];
      var source = vm;
      while (source) {
        if (source._provided && provideKey in source._provided) {
          result[key] = source._provided[provideKey];
          break;
        }
        source = source.$parent;
      }
      if (false) {
        warn("Injection \"" + key + "\" not found", vm);
      }
    }
    return result;
  }
}

/*  */

function createFunctionalComponent(Ctor, propsData, data, context, children) {
  var props = {};
  var propOptions = Ctor.options.props;
  if (isDef(propOptions)) {
    for (var key in propOptions) {
      props[key] = validateProp(key, propOptions, propsData || emptyObject);
    }
  } else {
    if (isDef(data.attrs)) {
      mergeProps(props, data.attrs);
    }
    if (isDef(data.props)) {
      mergeProps(props, data.props);
    }
  }
  // ensure the createElement function in functional components
  // gets a unique context - this is necessary for correct named slot check
  var _context = Object.create(context);
  var h = function (a, b, c, d) {
    return createElement(_context, a, b, c, d, true);
  };
  var vnode = Ctor.options.render.call(null, h, {
    data: data,
    props: props,
    children: children,
    parent: context,
    listeners: data.on || emptyObject,
    injections: resolveInject(Ctor.options.inject, context),
    slots: function () {
      return resolveSlots(children, context);
    }
  });
  if (vnode instanceof VNode) {
    vnode.functionalContext = context;
    vnode.functionalOptions = Ctor.options;
    if (data.slot) {
      (vnode.data || (vnode.data = {})).slot = data.slot;
    }
  }
  return vnode;
}

function mergeProps(to, from) {
  for (var key in from) {
    to[camelize(key)] = from[key];
  }
}

/*  */

// hooks to be invoked on component VNodes during patch
var componentVNodeHooks = {
  init: function init(vnode, hydrating, parentElm, refElm) {
    if (!vnode.componentInstance || vnode.componentInstance._isDestroyed) {
      var child = vnode.componentInstance = createComponentInstanceForVnode(vnode, activeInstance, parentElm, refElm);
      child.$mount(hydrating ? vnode.elm : undefined, hydrating);
    } else if (vnode.data.keepAlive) {
      // kept-alive components, treat as a patch
      var mountedNode = vnode; // work around flow
      componentVNodeHooks.prepatch(mountedNode, mountedNode);
    }
  },

  prepatch: function prepatch(oldVnode, vnode) {
    var options = vnode.componentOptions;
    var child = vnode.componentInstance = oldVnode.componentInstance;
    updateChildComponent(child, options.propsData, // updated props
    options.listeners, // updated listeners
    vnode, // new parent vnode
    options.children // new children
    );
  },

  insert: function insert(vnode) {
    var context = vnode.context;
    var componentInstance = vnode.componentInstance;
    if (!componentInstance._isMounted) {
      componentInstance._isMounted = true;
      callHook(componentInstance, 'mounted');
    }
    if (vnode.data.keepAlive) {
      if (context._isMounted) {
        // vue-router#1212
        // During updates, a kept-alive component's child components may
        // change, so directly walking the tree here may call activated hooks
        // on incorrect children. Instead we push them into a queue which will
        // be processed after the whole patch process ended.
        queueActivatedComponent(componentInstance);
      } else {
        activateChildComponent(componentInstance, true /* direct */);
      }
    }
  },

  destroy: function destroy(vnode) {
    var componentInstance = vnode.componentInstance;
    if (!componentInstance._isDestroyed) {
      if (!vnode.data.keepAlive) {
        componentInstance.$destroy();
      } else {
        deactivateChildComponent(componentInstance, true /* direct */);
      }
    }
  }
};

var hooksToMerge = Object.keys(componentVNodeHooks);

function createComponent(Ctor, data, context, children, tag) {
  if (isUndef(Ctor)) {
    return;
  }

  var baseCtor = context.$options._base;

  // plain options object: turn it into a constructor
  if (isObject(Ctor)) {
    Ctor = baseCtor.extend(Ctor);
  }

  // if at this stage it's not a constructor or an async component factory,
  // reject.
  if (typeof Ctor !== 'function') {
    if (false) {
      warn("Invalid Component definition: " + String(Ctor), context);
    }
    return;
  }

  // async component
  var asyncFactory;
  if (isUndef(Ctor.cid)) {
    asyncFactory = Ctor;
    Ctor = resolveAsyncComponent(asyncFactory, baseCtor, context);
    if (Ctor === undefined) {
      // return a placeholder node for async component, which is rendered
      // as a comment node but preserves all the raw information for the node.
      // the information will be used for async server-rendering and hydration.
      return createAsyncPlaceholder(asyncFactory, data, context, children, tag);
    }
  }

  data = data || {};

  // resolve constructor options in case global mixins are applied after
  // component constructor creation
  resolveConstructorOptions(Ctor);

  // transform component v-model data into props & events
  if (isDef(data.model)) {
    transformModel(Ctor.options, data);
  }

  // extract props
  var propsData = extractPropsFromVNodeData(data, Ctor, tag);

  // functional component
  if (isTrue(Ctor.options.functional)) {
    return createFunctionalComponent(Ctor, propsData, data, context, children);
  }

  // extract listeners, since these needs to be treated as
  // child component listeners instead of DOM listeners
  var listeners = data.on;
  // replace with listeners with .native modifier
  // so it gets processed during parent component patch.
  data.on = data.nativeOn;

  if (isTrue(Ctor.options.abstract)) {
    // abstract components do not keep anything
    // other than props & listeners & slot

    // work around flow
    var slot = data.slot;
    data = {};
    if (slot) {
      data.slot = slot;
    }
  }

  // merge component management hooks onto the placeholder node
  mergeHooks(data);

  // return a placeholder vnode
  var name = Ctor.options.name || tag;
  var vnode = new VNode("vue-component-" + Ctor.cid + (name ? "-" + name : ''), data, undefined, undefined, undefined, context, { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children }, asyncFactory);
  return vnode;
}

function createComponentInstanceForVnode(vnode, // we know it's MountedComponentVNode but flow doesn't
parent, // activeInstance in lifecycle state
parentElm, refElm) {
  var vnodeComponentOptions = vnode.componentOptions;
  var options = {
    _isComponent: true,
    parent: parent,
    propsData: vnodeComponentOptions.propsData,
    _componentTag: vnodeComponentOptions.tag,
    _parentVnode: vnode,
    _parentListeners: vnodeComponentOptions.listeners,
    _renderChildren: vnodeComponentOptions.children,
    _parentElm: parentElm || null,
    _refElm: refElm || null
  };
  // check inline-template render functions
  var inlineTemplate = vnode.data.inlineTemplate;
  if (isDef(inlineTemplate)) {
    options.render = inlineTemplate.render;
    options.staticRenderFns = inlineTemplate.staticRenderFns;
  }
  return new vnodeComponentOptions.Ctor(options);
}

function mergeHooks(data) {
  if (!data.hook) {
    data.hook = {};
  }
  for (var i = 0; i < hooksToMerge.length; i++) {
    var key = hooksToMerge[i];
    var fromParent = data.hook[key];
    var ours = componentVNodeHooks[key];
    data.hook[key] = fromParent ? mergeHook$1(ours, fromParent) : ours;
  }
}

function mergeHook$1(one, two) {
  return function (a, b, c, d) {
    one(a, b, c, d);
    two(a, b, c, d);
  };
}

// transform component v-model info (value and callback) into
// prop and event handler respectively.
function transformModel(options, data) {
  var prop = options.model && options.model.prop || 'value';
  var event = options.model && options.model.event || 'input';(data.props || (data.props = {}))[prop] = data.model.value;
  var on = data.on || (data.on = {});
  if (isDef(on[event])) {
    on[event] = [data.model.callback].concat(on[event]);
  } else {
    on[event] = data.model.callback;
  }
}

/*  */

var SIMPLE_NORMALIZE = 1;
var ALWAYS_NORMALIZE = 2;

// wrapper function for providing a more flexible interface
// without getting yelled at by flow
function createElement(context, tag, data, children, normalizationType, alwaysNormalize) {
  if (Array.isArray(data) || isPrimitive(data)) {
    normalizationType = children;
    children = data;
    data = undefined;
  }
  if (isTrue(alwaysNormalize)) {
    normalizationType = ALWAYS_NORMALIZE;
  }
  return _createElement(context, tag, data, children, normalizationType);
}

function _createElement(context, tag, data, children, normalizationType) {
  if (isDef(data) && isDef(data.__ob__)) {
    "production" !== 'production' && warn("Avoid using observed data object as vnode data: " + JSON.stringify(data) + "\n" + 'Always create fresh vnode data objects in each render!', context);
    return createEmptyVNode();
  }
  // object syntax in v-bind
  if (isDef(data) && isDef(data.is)) {
    tag = data.is;
  }
  if (!tag) {
    // in case of component :is set to falsy value
    return createEmptyVNode();
  }
  // warn against non-primitive key
  if (false) {
    warn('Avoid using non-primitive value as key, ' + 'use string/number value instead.', context);
  }
  // support single function children as default scoped slot
  if (Array.isArray(children) && typeof children[0] === 'function') {
    data = data || {};
    data.scopedSlots = { default: children[0] };
    children.length = 0;
  }
  if (normalizationType === ALWAYS_NORMALIZE) {
    children = normalizeChildren(children);
  } else if (normalizationType === SIMPLE_NORMALIZE) {
    children = simpleNormalizeChildren(children);
  }
  var vnode, ns;
  if (typeof tag === 'string') {
    var Ctor;
    ns = context.$vnode && context.$vnode.ns || config.getTagNamespace(tag);
    if (config.isReservedTag(tag)) {
      // platform built-in elements
      vnode = new VNode(config.parsePlatformTagName(tag), data, children, undefined, undefined, context);
    } else if (isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {
      // component
      vnode = createComponent(Ctor, data, context, children, tag);
    } else {
      // unknown or unlisted namespaced elements
      // check at runtime because it may get assigned a namespace when its
      // parent normalizes children
      vnode = new VNode(tag, data, children, undefined, undefined, context);
    }
  } else {
    // direct component options / constructor
    vnode = createComponent(tag, data, context, children);
  }
  if (isDef(vnode)) {
    if (ns) {
      applyNS(vnode, ns);
    }
    return vnode;
  } else {
    return createEmptyVNode();
  }
}

function applyNS(vnode, ns) {
  vnode.ns = ns;
  if (vnode.tag === 'foreignObject') {
    // use default namespace inside foreignObject
    return;
  }
  if (isDef(vnode.children)) {
    for (var i = 0, l = vnode.children.length; i < l; i++) {
      var child = vnode.children[i];
      if (isDef(child.tag) && isUndef(child.ns)) {
        applyNS(child, ns);
      }
    }
  }
}

/*  */

/**
 * Runtime helper for rendering v-for lists.
 */
function renderList(val, render) {
  var ret, i, l, keys, key;
  if (Array.isArray(val) || typeof val === 'string') {
    ret = new Array(val.length);
    for (i = 0, l = val.length; i < l; i++) {
      ret[i] = render(val[i], i);
    }
  } else if (typeof val === 'number') {
    ret = new Array(val);
    for (i = 0; i < val; i++) {
      ret[i] = render(i + 1, i);
    }
  } else if (isObject(val)) {
    keys = Object.keys(val);
    ret = new Array(keys.length);
    for (i = 0, l = keys.length; i < l; i++) {
      key = keys[i];
      ret[i] = render(val[key], key, i);
    }
  }
  if (isDef(ret)) {
    ret._isVList = true;
  }
  return ret;
}

/*  */

/**
 * Runtime helper for rendering <slot>
 */
function renderSlot(name, fallback, props, bindObject) {
  var scopedSlotFn = this.$scopedSlots[name];
  if (scopedSlotFn) {
    // scoped slot
    props = props || {};
    if (bindObject) {
      props = extend(extend({}, bindObject), props);
    }
    return scopedSlotFn(props) || fallback;
  } else {
    var slotNodes = this.$slots[name];
    // warn duplicate slot usage
    if (slotNodes && "production" !== 'production') {
      slotNodes._rendered && warn("Duplicate presence of slot \"" + name + "\" found in the same render tree " + "- this will likely cause render errors.", this);
      slotNodes._rendered = true;
    }
    return slotNodes || fallback;
  }
}

/*  */

/**
 * Runtime helper for resolving filters
 */
function resolveFilter(id) {
  return resolveAsset(this.$options, 'filters', id, true) || identity;
}

/*  */

/**
 * Runtime helper for checking keyCodes from config.
 */
function checkKeyCodes(eventKeyCode, key, builtInAlias) {
  var keyCodes = config.keyCodes[key] || builtInAlias;
  if (Array.isArray(keyCodes)) {
    return keyCodes.indexOf(eventKeyCode) === -1;
  } else {
    return keyCodes !== eventKeyCode;
  }
}

/*  */

/**
 * Runtime helper for merging v-bind="object" into a VNode's data.
 */
function bindObjectProps(data, tag, value, asProp, isSync) {
  if (value) {
    if (!isObject(value)) {
      "production" !== 'production' && warn('v-bind without argument expects an Object or Array value', this);
    } else {
      if (Array.isArray(value)) {
        value = toObject(value);
      }
      var hash;
      var loop = function (key) {
        if (key === 'class' || key === 'style' || isReservedAttribute(key)) {
          hash = data;
        } else {
          var type = data.attrs && data.attrs.type;
          hash = asProp || config.mustUseProp(tag, type, key) ? data.domProps || (data.domProps = {}) : data.attrs || (data.attrs = {});
        }
        if (!(key in hash)) {
          hash[key] = value[key];

          if (isSync) {
            var on = data.on || (data.on = {});
            on["update:" + key] = function ($event) {
              value[key] = $event;
            };
          }
        }
      };

      for (var key in value) loop(key);
    }
  }
  return data;
}

/*  */

/**
 * Runtime helper for rendering static trees.
 */
function renderStatic(index, isInFor) {
  var tree = this._staticTrees[index];
  // if has already-rendered static tree and not inside v-for,
  // we can reuse the same tree by doing a shallow clone.
  if (tree && !isInFor) {
    return Array.isArray(tree) ? cloneVNodes(tree) : cloneVNode(tree);
  }
  // otherwise, render a fresh tree.
  tree = this._staticTrees[index] = this.$options.staticRenderFns[index].call(this._renderProxy);
  markStatic(tree, "__static__" + index, false);
  return tree;
}

/**
 * Runtime helper for v-once.
 * Effectively it means marking the node as static with a unique key.
 */
function markOnce(tree, index, key) {
  markStatic(tree, "__once__" + index + (key ? "_" + key : ""), true);
  return tree;
}

function markStatic(tree, key, isOnce) {
  if (Array.isArray(tree)) {
    for (var i = 0; i < tree.length; i++) {
      if (tree[i] && typeof tree[i] !== 'string') {
        markStaticNode(tree[i], key + "_" + i, isOnce);
      }
    }
  } else {
    markStaticNode(tree, key, isOnce);
  }
}

function markStaticNode(node, key, isOnce) {
  node.isStatic = true;
  node.key = key;
  node.isOnce = isOnce;
}

/*  */

function bindObjectListeners(data, value) {
  if (value) {
    if (!isPlainObject(value)) {
      "production" !== 'production' && warn('v-on without argument expects an Object value', this);
    } else {
      var on = data.on = data.on ? extend({}, data.on) : {};
      for (var key in value) {
        var existing = on[key];
        var ours = value[key];
        on[key] = existing ? [].concat(ours, existing) : ours;
      }
    }
  }
  return data;
}

/*  */

function initRender(vm) {
  vm._vnode = null; // the root of the child tree
  vm._staticTrees = null;
  var parentVnode = vm.$vnode = vm.$options._parentVnode; // the placeholder node in parent tree
  var renderContext = parentVnode && parentVnode.context;
  vm.$slots = resolveSlots(vm.$options._renderChildren, renderContext);
  vm.$scopedSlots = emptyObject;
  // bind the createElement fn to this instance
  // so that we get proper render context inside it.
  // args order: tag, data, children, normalizationType, alwaysNormalize
  // internal version is used by render functions compiled from templates
  vm._c = function (a, b, c, d) {
    return createElement(vm, a, b, c, d, false);
  };
  // normalization is always applied for the public version, used in
  // user-written render functions.
  vm.$createElement = function (a, b, c, d) {
    return createElement(vm, a, b, c, d, true);
  };

  // $attrs & $listeners are exposed for easier HOC creation.
  // they need to be reactive so that HOCs using them are always updated
  var parentData = parentVnode && parentVnode.data;

  /* istanbul ignore else */
  if (false) {
    defineReactive$$1(vm, '$attrs', parentData && parentData.attrs || emptyObject, function () {
      !isUpdatingChildComponent && warn("$attrs is readonly.", vm);
    }, true);
    defineReactive$$1(vm, '$listeners', vm.$options._parentListeners || emptyObject, function () {
      !isUpdatingChildComponent && warn("$listeners is readonly.", vm);
    }, true);
  } else {
    defineReactive$$1(vm, '$attrs', parentData && parentData.attrs || emptyObject, null, true);
    defineReactive$$1(vm, '$listeners', vm.$options._parentListeners || emptyObject, null, true);
  }
}

function renderMixin(Vue) {
  Vue.prototype.$nextTick = function (fn) {
    return nextTick(fn, this);
  };

  Vue.prototype._render = function () {
    var vm = this;
    var ref = vm.$options;
    var render = ref.render;
    var staticRenderFns = ref.staticRenderFns;
    var _parentVnode = ref._parentVnode;

    if (vm._isMounted) {
      // if the parent didn't update, the slot nodes will be the ones from
      // last render. They need to be cloned to ensure "freshness" for this render.
      for (var key in vm.$slots) {
        var slot = vm.$slots[key];
        if (slot._rendered) {
          vm.$slots[key] = cloneVNodes(slot, true /* deep */);
        }
      }
    }

    vm.$scopedSlots = _parentVnode && _parentVnode.data.scopedSlots || emptyObject;

    if (staticRenderFns && !vm._staticTrees) {
      vm._staticTrees = [];
    }
    // set parent vnode. this allows render functions to have access
    // to the data on the placeholder node.
    vm.$vnode = _parentVnode;
    // render self
    var vnode;
    try {
      vnode = render.call(vm._renderProxy, vm.$createElement);
    } catch (e) {
      handleError(e, vm, "render function");
      // return error render result,
      // or previous vnode to prevent render error causing blank component
      /* istanbul ignore else */
      if (false) {
        vnode = vm.$options.renderError ? vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e) : vm._vnode;
      } else {
        vnode = vm._vnode;
      }
    }
    // return empty vnode in case the render function errored out
    if (!(vnode instanceof VNode)) {
      if (false) {
        warn('Multiple root nodes returned from render function. Render function ' + 'should return a single root node.', vm);
      }
      vnode = createEmptyVNode();
    }
    // set parent
    vnode.parent = _parentVnode;
    return vnode;
  };

  // internal render helpers.
  // these are exposed on the instance prototype to reduce generated render
  // code size.
  Vue.prototype._o = markOnce;
  Vue.prototype._n = toNumber;
  Vue.prototype._s = toString;
  Vue.prototype._l = renderList;
  Vue.prototype._t = renderSlot;
  Vue.prototype._q = looseEqual;
  Vue.prototype._i = looseIndexOf;
  Vue.prototype._m = renderStatic;
  Vue.prototype._f = resolveFilter;
  Vue.prototype._k = checkKeyCodes;
  Vue.prototype._b = bindObjectProps;
  Vue.prototype._v = createTextVNode;
  Vue.prototype._e = createEmptyVNode;
  Vue.prototype._u = resolveScopedSlots;
  Vue.prototype._g = bindObjectListeners;
}

/*  */

var uid$1 = 0;

function initMixin(Vue) {
  Vue.prototype._init = function (options) {
    var vm = this;
    // a uid
    vm._uid = uid$1++;

    var startTag, endTag;
    /* istanbul ignore if */
    if (false) {
      startTag = "vue-perf-init:" + vm._uid;
      endTag = "vue-perf-end:" + vm._uid;
      mark(startTag);
    }

    // a flag to avoid this being observed
    vm._isVue = true;
    // merge options
    if (options && options._isComponent) {
      // optimize internal component instantiation
      // since dynamic options merging is pretty slow, and none of the
      // internal component options needs special treatment.
      initInternalComponent(vm, options);
    } else {
      vm.$options = mergeOptions(resolveConstructorOptions(vm.constructor), options || {}, vm);
    }
    /* istanbul ignore else */
    if (false) {
      initProxy(vm);
    } else {
      vm._renderProxy = vm;
    }
    // expose real self
    vm._self = vm;
    initLifecycle(vm);
    initEvents(vm);
    initRender(vm);
    callHook(vm, 'beforeCreate');
    initInjections(vm); // resolve injections before data/props
    initState(vm);
    initProvide(vm); // resolve provide after data/props
    callHook(vm, 'created');

    /* istanbul ignore if */
    if (false) {
      vm._name = formatComponentName(vm, false);
      mark(endTag);
      measure(vm._name + " init", startTag, endTag);
    }

    if (vm.$options.el) {
      vm.$mount(vm.$options.el);
    }
  };
}

function initInternalComponent(vm, options) {
  var opts = vm.$options = Object.create(vm.constructor.options);
  // doing this because it's faster than dynamic enumeration.
  opts.parent = options.parent;
  opts.propsData = options.propsData;
  opts._parentVnode = options._parentVnode;
  opts._parentListeners = options._parentListeners;
  opts._renderChildren = options._renderChildren;
  opts._componentTag = options._componentTag;
  opts._parentElm = options._parentElm;
  opts._refElm = options._refElm;
  if (options.render) {
    opts.render = options.render;
    opts.staticRenderFns = options.staticRenderFns;
  }
}

function resolveConstructorOptions(Ctor) {
  var options = Ctor.options;
  if (Ctor.super) {
    var superOptions = resolveConstructorOptions(Ctor.super);
    var cachedSuperOptions = Ctor.superOptions;
    if (superOptions !== cachedSuperOptions) {
      // super option changed,
      // need to resolve new options.
      Ctor.superOptions = superOptions;
      // check if there are any late-modified/attached options (#4976)
      var modifiedOptions = resolveModifiedOptions(Ctor);
      // update base extend options
      if (modifiedOptions) {
        extend(Ctor.extendOptions, modifiedOptions);
      }
      options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);
      if (options.name) {
        options.components[options.name] = Ctor;
      }
    }
  }
  return options;
}

function resolveModifiedOptions(Ctor) {
  var modified;
  var latest = Ctor.options;
  var extended = Ctor.extendOptions;
  var sealed = Ctor.sealedOptions;
  for (var key in latest) {
    if (latest[key] !== sealed[key]) {
      if (!modified) {
        modified = {};
      }
      modified[key] = dedupe(latest[key], extended[key], sealed[key]);
    }
  }
  return modified;
}

function dedupe(latest, extended, sealed) {
  // compare latest and sealed to ensure lifecycle hooks won't be duplicated
  // between merges
  if (Array.isArray(latest)) {
    var res = [];
    sealed = Array.isArray(sealed) ? sealed : [sealed];
    extended = Array.isArray(extended) ? extended : [extended];
    for (var i = 0; i < latest.length; i++) {
      // push original options and not sealed options to exclude duplicated options
      if (extended.indexOf(latest[i]) >= 0 || sealed.indexOf(latest[i]) < 0) {
        res.push(latest[i]);
      }
    }
    return res;
  } else {
    return latest;
  }
}

function Vue$3(options) {
  if (false) {
    warn('Vue is a constructor and should be called with the `new` keyword');
  }
  this._init(options);
}

initMixin(Vue$3);
stateMixin(Vue$3);
eventsMixin(Vue$3);
lifecycleMixin(Vue$3);
renderMixin(Vue$3);

/*  */

function initUse(Vue) {
  Vue.use = function (plugin) {
    var installedPlugins = this._installedPlugins || (this._installedPlugins = []);
    if (installedPlugins.indexOf(plugin) > -1) {
      return this;
    }

    // additional parameters
    var args = toArray(arguments, 1);
    args.unshift(this);
    if (typeof plugin.install === 'function') {
      plugin.install.apply(plugin, args);
    } else if (typeof plugin === 'function') {
      plugin.apply(null, args);
    }
    installedPlugins.push(plugin);
    return this;
  };
}

/*  */

function initMixin$1(Vue) {
  Vue.mixin = function (mixin) {
    this.options = mergeOptions(this.options, mixin);
    return this;
  };
}

/*  */

function initExtend(Vue) {
  /**
   * Each instance constructor, including Vue, has a unique
   * cid. This enables us to create wrapped "child
   * constructors" for prototypal inheritance and cache them.
   */
  Vue.cid = 0;
  var cid = 1;

  /**
   * Class inheritance
   */
  Vue.extend = function (extendOptions) {
    extendOptions = extendOptions || {};
    var Super = this;
    var SuperId = Super.cid;
    var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});
    if (cachedCtors[SuperId]) {
      return cachedCtors[SuperId];
    }

    var name = extendOptions.name || Super.options.name;
    if (false) {
      if (!/^[a-zA-Z][\w-]*$/.test(name)) {
        warn('Invalid component name: "' + name + '". Component names ' + 'can only contain alphanumeric characters and the hyphen, ' + 'and must start with a letter.');
      }
    }

    var Sub = function VueComponent(options) {
      this._init(options);
    };
    Sub.prototype = Object.create(Super.prototype);
    Sub.prototype.constructor = Sub;
    Sub.cid = cid++;
    Sub.options = mergeOptions(Super.options, extendOptions);
    Sub['super'] = Super;

    // For props and computed properties, we define the proxy getters on
    // the Vue instances at extension time, on the extended prototype. This
    // avoids Object.defineProperty calls for each instance created.
    if (Sub.options.props) {
      initProps$1(Sub);
    }
    if (Sub.options.computed) {
      initComputed$1(Sub);
    }

    // allow further extension/mixin/plugin usage
    Sub.extend = Super.extend;
    Sub.mixin = Super.mixin;
    Sub.use = Super.use;

    // create asset registers, so extended classes
    // can have their private assets too.
    ASSET_TYPES.forEach(function (type) {
      Sub[type] = Super[type];
    });
    // enable recursive self-lookup
    if (name) {
      Sub.options.components[name] = Sub;
    }

    // keep a reference to the super options at extension time.
    // later at instantiation we can check if Super's options have
    // been updated.
    Sub.superOptions = Super.options;
    Sub.extendOptions = extendOptions;
    Sub.sealedOptions = extend({}, Sub.options);

    // cache constructor
    cachedCtors[SuperId] = Sub;
    return Sub;
  };
}

function initProps$1(Comp) {
  var props = Comp.options.props;
  for (var key in props) {
    proxy(Comp.prototype, "_props", key);
  }
}

function initComputed$1(Comp) {
  var computed = Comp.options.computed;
  for (var key in computed) {
    defineComputed(Comp.prototype, key, computed[key]);
  }
}

/*  */

function initAssetRegisters(Vue) {
  /**
   * Create asset registration methods.
   */
  ASSET_TYPES.forEach(function (type) {
    Vue[type] = function (id, definition) {
      if (!definition) {
        return this.options[type + 's'][id];
      } else {
        /* istanbul ignore if */
        if (false) {
          if (type === 'component' && config.isReservedTag(id)) {
            warn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + id);
          }
        }
        if (type === 'component' && isPlainObject(definition)) {
          definition.name = definition.name || id;
          definition = this.options._base.extend(definition);
        }
        if (type === 'directive' && typeof definition === 'function') {
          definition = { bind: definition, update: definition };
        }
        this.options[type + 's'][id] = definition;
        return definition;
      }
    };
  });
}

/*  */

var patternTypes = [String, RegExp, Array];

function getComponentName(opts) {
  return opts && (opts.Ctor.options.name || opts.tag);
}

function matches(pattern, name) {
  if (Array.isArray(pattern)) {
    return pattern.indexOf(name) > -1;
  } else if (typeof pattern === 'string') {
    return pattern.split(',').indexOf(name) > -1;
  } else if (isRegExp(pattern)) {
    return pattern.test(name);
  }
  /* istanbul ignore next */
  return false;
}

function pruneCache(cache, current, filter) {
  for (var key in cache) {
    var cachedNode = cache[key];
    if (cachedNode) {
      var name = getComponentName(cachedNode.componentOptions);
      if (name && !filter(name)) {
        if (cachedNode !== current) {
          pruneCacheEntry(cachedNode);
        }
        cache[key] = null;
      }
    }
  }
}

function pruneCacheEntry(vnode) {
  if (vnode) {
    vnode.componentInstance.$destroy();
  }
}

var KeepAlive = {
  name: 'keep-alive',
  abstract: true,

  props: {
    include: patternTypes,
    exclude: patternTypes
  },

  created: function created() {
    this.cache = Object.create(null);
  },

  destroyed: function destroyed() {
    var this$1 = this;

    for (var key in this$1.cache) {
      pruneCacheEntry(this$1.cache[key]);
    }
  },

  watch: {
    include: function include(val) {
      pruneCache(this.cache, this._vnode, function (name) {
        return matches(val, name);
      });
    },
    exclude: function exclude(val) {
      pruneCache(this.cache, this._vnode, function (name) {
        return !matches(val, name);
      });
    }
  },

  render: function render() {
    var vnode = getFirstComponentChild(this.$slots.default);
    var componentOptions = vnode && vnode.componentOptions;
    if (componentOptions) {
      // check pattern
      var name = getComponentName(componentOptions);
      if (name && (this.include && !matches(this.include, name) || this.exclude && matches(this.exclude, name))) {
        return vnode;
      }
      var key = vnode.key == null
      // same constructor may get registered as different local components
      // so cid alone is not enough (#3269)
      ? componentOptions.Ctor.cid + (componentOptions.tag ? "::" + componentOptions.tag : '') : vnode.key;
      if (this.cache[key]) {
        vnode.componentInstance = this.cache[key].componentInstance;
      } else {
        this.cache[key] = vnode;
      }
      vnode.data.keepAlive = true;
    }
    return vnode;
  }
};

var builtInComponents = {
  KeepAlive: KeepAlive
};

/*  */

function initGlobalAPI(Vue) {
  // config
  var configDef = {};
  configDef.get = function () {
    return config;
  };
  if (false) {
    configDef.set = function () {
      warn('Do not replace the Vue.config object, set individual fields instead.');
    };
  }
  Object.defineProperty(Vue, 'config', configDef);

  // exposed util methods.
  // NOTE: these are not considered part of the public API - avoid relying on
  // them unless you are aware of the risk.
  Vue.util = {
    warn: warn,
    extend: extend,
    mergeOptions: mergeOptions,
    defineReactive: defineReactive$$1
  };

  Vue.set = set;
  Vue.delete = del;
  Vue.nextTick = nextTick;

  Vue.options = Object.create(null);
  ASSET_TYPES.forEach(function (type) {
    Vue.options[type + 's'] = Object.create(null);
  });

  // this is used to identify the "base" constructor to extend all plain-object
  // components with in Weex's multi-instance scenarios.
  Vue.options._base = Vue;

  extend(Vue.options.components, builtInComponents);

  initUse(Vue);
  initMixin$1(Vue);
  initExtend(Vue);
  initAssetRegisters(Vue);
}

initGlobalAPI(Vue$3);

Object.defineProperty(Vue$3.prototype, '$isServer', {
  get: isServerRendering
});

Object.defineProperty(Vue$3.prototype, '$ssrContext', {
  get: function get() {
    /* istanbul ignore next */
    return this.$vnode && this.$vnode.ssrContext;
  }
});

Vue$3.version = '2.4.4';

/*  */

// these are reserved for web because they are directly compiled away
// during template compilation
var isReservedAttr = makeMap('style,class');

// attributes that should be using props for binding
var acceptValue = makeMap('input,textarea,option,select,progress');
var mustUseProp = function (tag, type, attr) {
  return attr === 'value' && acceptValue(tag) && type !== 'button' || attr === 'selected' && tag === 'option' || attr === 'checked' && tag === 'input' || attr === 'muted' && tag === 'video';
};

var isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');

var isBooleanAttr = makeMap('allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' + 'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' + 'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' + 'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' + 'required,reversed,scoped,seamless,selected,sortable,translate,' + 'truespeed,typemustmatch,visible');

var xlinkNS = 'http://www.w3.org/1999/xlink';

var isXlink = function (name) {
  return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink';
};

var getXlinkProp = function (name) {
  return isXlink(name) ? name.slice(6, name.length) : '';
};

var isFalsyAttrValue = function (val) {
  return val == null || val === false;
};

/*  */

function genClassForVnode(vnode) {
  var data = vnode.data;
  var parentNode = vnode;
  var childNode = vnode;
  while (isDef(childNode.componentInstance)) {
    childNode = childNode.componentInstance._vnode;
    if (childNode.data) {
      data = mergeClassData(childNode.data, data);
    }
  }
  while (isDef(parentNode = parentNode.parent)) {
    if (parentNode.data) {
      data = mergeClassData(data, parentNode.data);
    }
  }
  return renderClass(data.staticClass, data.class);
}

function mergeClassData(child, parent) {
  return {
    staticClass: concat(child.staticClass, parent.staticClass),
    class: isDef(child.class) ? [child.class, parent.class] : parent.class
  };
}

function renderClass(staticClass, dynamicClass) {
  if (isDef(staticClass) || isDef(dynamicClass)) {
    return concat(staticClass, stringifyClass(dynamicClass));
  }
  /* istanbul ignore next */
  return '';
}

function concat(a, b) {
  return a ? b ? a + ' ' + b : a : b || '';
}

function stringifyClass(value) {
  if (Array.isArray(value)) {
    return stringifyArray(value);
  }
  if (isObject(value)) {
    return stringifyObject(value);
  }
  if (typeof value === 'string') {
    return value;
  }
  /* istanbul ignore next */
  return '';
}

function stringifyArray(value) {
  var res = '';
  var stringified;
  for (var i = 0, l = value.length; i < l; i++) {
    if (isDef(stringified = stringifyClass(value[i])) && stringified !== '') {
      if (res) {
        res += ' ';
      }
      res += stringified;
    }
  }
  return res;
}

function stringifyObject(value) {
  var res = '';
  for (var key in value) {
    if (value[key]) {
      if (res) {
        res += ' ';
      }
      res += key;
    }
  }
  return res;
}

/*  */

var namespaceMap = {
  svg: 'http://www.w3.org/2000/svg',
  math: 'http://www.w3.org/1998/Math/MathML'
};

var isHTMLTag = makeMap('html,body,base,head,link,meta,style,title,' + 'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' + 'div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,' + 'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' + 's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' + 'embed,object,param,source,canvas,script,noscript,del,ins,' + 'caption,col,colgroup,table,thead,tbody,td,th,tr,' + 'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' + 'output,progress,select,textarea,' + 'details,dialog,menu,menuitem,summary,' + 'content,element,shadow,template,blockquote,iframe,tfoot');

// this map is intentionally selective, only covering SVG elements that may
// contain child elements.
var isSVG = makeMap('svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' + 'foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' + 'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view', true);

var isPreTag = function (tag) {
  return tag === 'pre';
};

var isReservedTag = function (tag) {
  return isHTMLTag(tag) || isSVG(tag);
};

function getTagNamespace(tag) {
  if (isSVG(tag)) {
    return 'svg';
  }
  // basic support for MathML
  // note it doesn't support other MathML elements being component roots
  if (tag === 'math') {
    return 'math';
  }
}

var unknownElementCache = Object.create(null);
function isUnknownElement(tag) {
  /* istanbul ignore if */
  if (!inBrowser) {
    return true;
  }
  if (isReservedTag(tag)) {
    return false;
  }
  tag = tag.toLowerCase();
  /* istanbul ignore if */
  if (unknownElementCache[tag] != null) {
    return unknownElementCache[tag];
  }
  var el = document.createElement(tag);
  if (tag.indexOf('-') > -1) {
    // http://stackoverflow.com/a/28210364/1070244
    return unknownElementCache[tag] = el.constructor === window.HTMLUnknownElement || el.constructor === window.HTMLElement;
  } else {
    return unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString());
  }
}

var isTextInputType = makeMap('text,number,password,search,email,tel,url');

/*  */

/**
 * Query an element selector if it's not an element already.
 */
function query(el) {
  if (typeof el === 'string') {
    var selected = document.querySelector(el);
    if (!selected) {
      "production" !== 'production' && warn('Cannot find element: ' + el);
      return document.createElement('div');
    }
    return selected;
  } else {
    return el;
  }
}

/*  */

function createElement$1(tagName, vnode) {
  var elm = document.createElement(tagName);
  if (tagName !== 'select') {
    return elm;
  }
  // false or null will remove the attribute but undefined will not
  if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {
    elm.setAttribute('multiple', 'multiple');
  }
  return elm;
}

function createElementNS(namespace, tagName) {
  return document.createElementNS(namespaceMap[namespace], tagName);
}

function createTextNode(text) {
  return document.createTextNode(text);
}

function createComment(text) {
  return document.createComment(text);
}

function insertBefore(parentNode, newNode, referenceNode) {
  parentNode.insertBefore(newNode, referenceNode);
}

function removeChild(node, child) {
  node.removeChild(child);
}

function appendChild(node, child) {
  node.appendChild(child);
}

function parentNode(node) {
  return node.parentNode;
}

function nextSibling(node) {
  return node.nextSibling;
}

function tagName(node) {
  return node.tagName;
}

function setTextContent(node, text) {
  node.textContent = text;
}

function setAttribute(node, key, val) {
  node.setAttribute(key, val);
}

var nodeOps = Object.freeze({
  createElement: createElement$1,
  createElementNS: createElementNS,
  createTextNode: createTextNode,
  createComment: createComment,
  insertBefore: insertBefore,
  removeChild: removeChild,
  appendChild: appendChild,
  parentNode: parentNode,
  nextSibling: nextSibling,
  tagName: tagName,
  setTextContent: setTextContent,
  setAttribute: setAttribute
});

/*  */

var ref = {
  create: function create(_, vnode) {
    registerRef(vnode);
  },
  update: function update(oldVnode, vnode) {
    if (oldVnode.data.ref !== vnode.data.ref) {
      registerRef(oldVnode, true);
      registerRef(vnode);
    }
  },
  destroy: function destroy(vnode) {
    registerRef(vnode, true);
  }
};

function registerRef(vnode, isRemoval) {
  var key = vnode.data.ref;
  if (!key) {
    return;
  }

  var vm = vnode.context;
  var ref = vnode.componentInstance || vnode.elm;
  var refs = vm.$refs;
  if (isRemoval) {
    if (Array.isArray(refs[key])) {
      remove(refs[key], ref);
    } else if (refs[key] === ref) {
      refs[key] = undefined;
    }
  } else {
    if (vnode.data.refInFor) {
      if (!Array.isArray(refs[key])) {
        refs[key] = [ref];
      } else if (refs[key].indexOf(ref) < 0) {
        // $flow-disable-line
        refs[key].push(ref);
      }
    } else {
      refs[key] = ref;
    }
  }
}

/**
 * Virtual DOM patching algorithm based on Snabbdom by
 * Simon Friis Vindum (@paldepind)
 * Licensed under the MIT License
 * https://github.com/paldepind/snabbdom/blob/master/LICENSE
 *
 * modified by Evan You (@yyx990803)
 *
 * Not type-checking this because this file is perf-critical and the cost
 * of making flow understand it is not worth it.
 */

var emptyNode = new VNode('', {}, []);

var hooks = ['create', 'activate', 'update', 'remove', 'destroy'];

function sameVnode(a, b) {
  return a.key === b.key && (a.tag === b.tag && a.isComment === b.isComment && isDef(a.data) === isDef(b.data) && sameInputType(a, b) || isTrue(a.isAsyncPlaceholder) && a.asyncFactory === b.asyncFactory && isUndef(b.asyncFactory.error));
}

function sameInputType(a, b) {
  if (a.tag !== 'input') {
    return true;
  }
  var i;
  var typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type;
  var typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;
  return typeA === typeB || isTextInputType(typeA) && isTextInputType(typeB);
}

function createKeyToOldIdx(children, beginIdx, endIdx) {
  var i, key;
  var map = {};
  for (i = beginIdx; i <= endIdx; ++i) {
    key = children[i].key;
    if (isDef(key)) {
      map[key] = i;
    }
  }
  return map;
}

function createPatchFunction(backend) {
  var i, j;
  var cbs = {};

  var modules = backend.modules;
  var nodeOps = backend.nodeOps;

  for (i = 0; i < hooks.length; ++i) {
    cbs[hooks[i]] = [];
    for (j = 0; j < modules.length; ++j) {
      if (isDef(modules[j][hooks[i]])) {
        cbs[hooks[i]].push(modules[j][hooks[i]]);
      }
    }
  }

  function emptyNodeAt(elm) {
    return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm);
  }

  function createRmCb(childElm, listeners) {
    function remove$$1() {
      if (--remove$$1.listeners === 0) {
        removeNode(childElm);
      }
    }
    remove$$1.listeners = listeners;
    return remove$$1;
  }

  function removeNode(el) {
    var parent = nodeOps.parentNode(el);
    // element may have already been removed due to v-html / v-text
    if (isDef(parent)) {
      nodeOps.removeChild(parent, el);
    }
  }

  var inPre = 0;
  function createElm(vnode, insertedVnodeQueue, parentElm, refElm, nested) {
    vnode.isRootInsert = !nested; // for transition enter check
    if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {
      return;
    }

    var data = vnode.data;
    var children = vnode.children;
    var tag = vnode.tag;
    if (isDef(tag)) {
      if (false) {
        if (data && data.pre) {
          inPre++;
        }
        if (!inPre && !vnode.ns && !(config.ignoredElements.length && config.ignoredElements.indexOf(tag) > -1) && config.isUnknownElement(tag)) {
          warn('Unknown custom element: <' + tag + '> - did you ' + 'register the component correctly? For recursive components, ' + 'make sure to provide the "name" option.', vnode.context);
        }
      }
      vnode.elm = vnode.ns ? nodeOps.createElementNS(vnode.ns, tag) : nodeOps.createElement(tag, vnode);
      setScope(vnode);

      /* istanbul ignore if */
      {
        createChildren(vnode, children, insertedVnodeQueue);
        if (isDef(data)) {
          invokeCreateHooks(vnode, insertedVnodeQueue);
        }
        insert(parentElm, vnode.elm, refElm);
      }

      if (false) {
        inPre--;
      }
    } else if (isTrue(vnode.isComment)) {
      vnode.elm = nodeOps.createComment(vnode.text);
      insert(parentElm, vnode.elm, refElm);
    } else {
      vnode.elm = nodeOps.createTextNode(vnode.text);
      insert(parentElm, vnode.elm, refElm);
    }
  }

  function createComponent(vnode, insertedVnodeQueue, parentElm, refElm) {
    var i = vnode.data;
    if (isDef(i)) {
      var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;
      if (isDef(i = i.hook) && isDef(i = i.init)) {
        i(vnode, false /* hydrating */, parentElm, refElm);
      }
      // after calling the init hook, if the vnode is a child component
      // it should've created a child instance and mounted it. the child
      // component also has set the placeholder vnode's elm.
      // in that case we can just return the element and be done.
      if (isDef(vnode.componentInstance)) {
        initComponent(vnode, insertedVnodeQueue);
        if (isTrue(isReactivated)) {
          reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);
        }
        return true;
      }
    }
  }

  function initComponent(vnode, insertedVnodeQueue) {
    if (isDef(vnode.data.pendingInsert)) {
      insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);
      vnode.data.pendingInsert = null;
    }
    vnode.elm = vnode.componentInstance.$el;
    if (isPatchable(vnode)) {
      invokeCreateHooks(vnode, insertedVnodeQueue);
      setScope(vnode);
    } else {
      // empty component root.
      // skip all element-related modules except for ref (#3455)
      registerRef(vnode);
      // make sure to invoke the insert hook
      insertedVnodeQueue.push(vnode);
    }
  }

  function reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm) {
    var i;
    // hack for #4339: a reactivated component with inner transition
    // does not trigger because the inner node's created hooks are not called
    // again. It's not ideal to involve module-specific logic in here but
    // there doesn't seem to be a better way to do it.
    var innerNode = vnode;
    while (innerNode.componentInstance) {
      innerNode = innerNode.componentInstance._vnode;
      if (isDef(i = innerNode.data) && isDef(i = i.transition)) {
        for (i = 0; i < cbs.activate.length; ++i) {
          cbs.activate[i](emptyNode, innerNode);
        }
        insertedVnodeQueue.push(innerNode);
        break;
      }
    }
    // unlike a newly created component,
    // a reactivated keep-alive component doesn't insert itself
    insert(parentElm, vnode.elm, refElm);
  }

  function insert(parent, elm, ref$$1) {
    if (isDef(parent)) {
      if (isDef(ref$$1)) {
        if (ref$$1.parentNode === parent) {
          nodeOps.insertBefore(parent, elm, ref$$1);
        }
      } else {
        nodeOps.appendChild(parent, elm);
      }
    }
  }

  function createChildren(vnode, children, insertedVnodeQueue) {
    if (Array.isArray(children)) {
      for (var i = 0; i < children.length; ++i) {
        createElm(children[i], insertedVnodeQueue, vnode.elm, null, true);
      }
    } else if (isPrimitive(vnode.text)) {
      nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(vnode.text));
    }
  }

  function isPatchable(vnode) {
    while (vnode.componentInstance) {
      vnode = vnode.componentInstance._vnode;
    }
    return isDef(vnode.tag);
  }

  function invokeCreateHooks(vnode, insertedVnodeQueue) {
    for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
      cbs.create[i$1](emptyNode, vnode);
    }
    i = vnode.data.hook; // Reuse variable
    if (isDef(i)) {
      if (isDef(i.create)) {
        i.create(emptyNode, vnode);
      }
      if (isDef(i.insert)) {
        insertedVnodeQueue.push(vnode);
      }
    }
  }

  // set scope id attribute for scoped CSS.
  // this is implemented as a special case to avoid the overhead
  // of going through the normal attribute patching process.
  function setScope(vnode) {
    var i;
    var ancestor = vnode;
    while (ancestor) {
      if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {
        nodeOps.setAttribute(vnode.elm, i, '');
      }
      ancestor = ancestor.parent;
    }
    // for slot content they should also get the scopeId from the host instance.
    if (isDef(i = activeInstance) && i !== vnode.context && isDef(i = i.$options._scopeId)) {
      nodeOps.setAttribute(vnode.elm, i, '');
    }
  }

  function addVnodes(parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {
    for (; startIdx <= endIdx; ++startIdx) {
      createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm);
    }
  }

  function invokeDestroyHook(vnode) {
    var i, j;
    var data = vnode.data;
    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.destroy)) {
        i(vnode);
      }
      for (i = 0; i < cbs.destroy.length; ++i) {
        cbs.destroy[i](vnode);
      }
    }
    if (isDef(i = vnode.children)) {
      for (j = 0; j < vnode.children.length; ++j) {
        invokeDestroyHook(vnode.children[j]);
      }
    }
  }

  function removeVnodes(parentElm, vnodes, startIdx, endIdx) {
    for (; startIdx <= endIdx; ++startIdx) {
      var ch = vnodes[startIdx];
      if (isDef(ch)) {
        if (isDef(ch.tag)) {
          removeAndInvokeRemoveHook(ch);
          invokeDestroyHook(ch);
        } else {
          // Text node
          removeNode(ch.elm);
        }
      }
    }
  }

  function removeAndInvokeRemoveHook(vnode, rm) {
    if (isDef(rm) || isDef(vnode.data)) {
      var i;
      var listeners = cbs.remove.length + 1;
      if (isDef(rm)) {
        // we have a recursively passed down rm callback
        // increase the listeners count
        rm.listeners += listeners;
      } else {
        // directly removing
        rm = createRmCb(vnode.elm, listeners);
      }
      // recursively invoke hooks on child component root node
      if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {
        removeAndInvokeRemoveHook(i, rm);
      }
      for (i = 0; i < cbs.remove.length; ++i) {
        cbs.remove[i](vnode, rm);
      }
      if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {
        i(vnode, rm);
      } else {
        rm();
      }
    } else {
      removeNode(vnode.elm);
    }
  }

  function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {
    var oldStartIdx = 0;
    var newStartIdx = 0;
    var oldEndIdx = oldCh.length - 1;
    var oldStartVnode = oldCh[0];
    var oldEndVnode = oldCh[oldEndIdx];
    var newEndIdx = newCh.length - 1;
    var newStartVnode = newCh[0];
    var newEndVnode = newCh[newEndIdx];
    var oldKeyToIdx, idxInOld, elmToMove, refElm;

    // removeOnly is a special flag used only by <transition-group>
    // to ensure removed elements stay in correct relative positions
    // during leaving transitions
    var canMove = !removeOnly;

    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
      if (isUndef(oldStartVnode)) {
        oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left
      } else if (isUndef(oldEndVnode)) {
        oldEndVnode = oldCh[--oldEndIdx];
      } else if (sameVnode(oldStartVnode, newStartVnode)) {
        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);
        oldStartVnode = oldCh[++oldStartIdx];
        newStartVnode = newCh[++newStartIdx];
      } else if (sameVnode(oldEndVnode, newEndVnode)) {
        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);
        oldEndVnode = oldCh[--oldEndIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldStartVnode, newEndVnode)) {
        // Vnode moved right
        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);
        canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));
        oldStartVnode = oldCh[++oldStartIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldEndVnode, newStartVnode)) {
        // Vnode moved left
        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);
        canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
        oldEndVnode = oldCh[--oldEndIdx];
        newStartVnode = newCh[++newStartIdx];
      } else {
        if (isUndef(oldKeyToIdx)) {
          oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);
        }
        idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);
        if (isUndef(idxInOld)) {
          // New element
          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);
        } else {
          elmToMove = oldCh[idxInOld];
          /* istanbul ignore if */
          if (false) {
            warn('It seems there are duplicate keys that is causing an update error. ' + 'Make sure each v-for item has a unique key.');
          }
          if (sameVnode(elmToMove, newStartVnode)) {
            patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);
            oldCh[idxInOld] = undefined;
            canMove && nodeOps.insertBefore(parentElm, elmToMove.elm, oldStartVnode.elm);
          } else {
            // same key but different element. treat as new element
            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);
          }
        }
        newStartVnode = newCh[++newStartIdx];
      }
    }
    if (oldStartIdx > oldEndIdx) {
      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;
      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);
    } else if (newStartIdx > newEndIdx) {
      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);
    }
  }

  function findIdxInOld(node, oldCh, start, end) {
    for (var i = start; i < end; i++) {
      var c = oldCh[i];
      if (isDef(c) && sameVnode(node, c)) {
        return i;
      }
    }
  }

  function patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly) {
    if (oldVnode === vnode) {
      return;
    }

    var elm = vnode.elm = oldVnode.elm;

    if (isTrue(oldVnode.isAsyncPlaceholder)) {
      if (isDef(vnode.asyncFactory.resolved)) {
        hydrate(oldVnode.elm, vnode, insertedVnodeQueue);
      } else {
        vnode.isAsyncPlaceholder = true;
      }
      return;
    }

    // reuse element for static trees.
    // note we only do this if the vnode is cloned -
    // if the new node is not cloned it means the render functions have been
    // reset by the hot-reload-api and we need to do a proper re-render.
    if (isTrue(vnode.isStatic) && isTrue(oldVnode.isStatic) && vnode.key === oldVnode.key && (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))) {
      vnode.componentInstance = oldVnode.componentInstance;
      return;
    }

    var i;
    var data = vnode.data;
    if (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) {
      i(oldVnode, vnode);
    }

    var oldCh = oldVnode.children;
    var ch = vnode.children;
    if (isDef(data) && isPatchable(vnode)) {
      for (i = 0; i < cbs.update.length; ++i) {
        cbs.update[i](oldVnode, vnode);
      }
      if (isDef(i = data.hook) && isDef(i = i.update)) {
        i(oldVnode, vnode);
      }
    }
    if (isUndef(vnode.text)) {
      if (isDef(oldCh) && isDef(ch)) {
        if (oldCh !== ch) {
          updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly);
        }
      } else if (isDef(ch)) {
        if (isDef(oldVnode.text)) {
          nodeOps.setTextContent(elm, '');
        }
        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);
      } else if (isDef(oldCh)) {
        removeVnodes(elm, oldCh, 0, oldCh.length - 1);
      } else if (isDef(oldVnode.text)) {
        nodeOps.setTextContent(elm, '');
      }
    } else if (oldVnode.text !== vnode.text) {
      nodeOps.setTextContent(elm, vnode.text);
    }
    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.postpatch)) {
        i(oldVnode, vnode);
      }
    }
  }

  function invokeInsertHook(vnode, queue, initial) {
    // delay insert hooks for component root nodes, invoke them after the
    // element is really inserted
    if (isTrue(initial) && isDef(vnode.parent)) {
      vnode.parent.data.pendingInsert = queue;
    } else {
      for (var i = 0; i < queue.length; ++i) {
        queue[i].data.hook.insert(queue[i]);
      }
    }
  }

  var bailed = false;
  // list of modules that can skip create hook during hydration because they
  // are already rendered on the client or has no need for initialization
  var isRenderedModule = makeMap('attrs,style,class,staticClass,staticStyle,key');

  // Note: this is a browser-only function so we can assume elms are DOM nodes.
  function hydrate(elm, vnode, insertedVnodeQueue) {
    if (isTrue(vnode.isComment) && isDef(vnode.asyncFactory)) {
      vnode.elm = elm;
      vnode.isAsyncPlaceholder = true;
      return true;
    }
    if (false) {
      if (!assertNodeMatch(elm, vnode)) {
        return false;
      }
    }
    vnode.elm = elm;
    var tag = vnode.tag;
    var data = vnode.data;
    var children = vnode.children;
    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.init)) {
        i(vnode, true /* hydrating */);
      }
      if (isDef(i = vnode.componentInstance)) {
        // child component. it should have hydrated its own tree.
        initComponent(vnode, insertedVnodeQueue);
        return true;
      }
    }
    if (isDef(tag)) {
      if (isDef(children)) {
        // empty element, allow client to pick up and populate children
        if (!elm.hasChildNodes()) {
          createChildren(vnode, children, insertedVnodeQueue);
        } else {
          // v-html and domProps: innerHTML
          if (isDef(i = data) && isDef(i = i.domProps) && isDef(i = i.innerHTML)) {
            if (i !== elm.innerHTML) {
              /* istanbul ignore if */
              if (false) {
                bailed = true;
                console.warn('Parent: ', elm);
                console.warn('server innerHTML: ', i);
                console.warn('client innerHTML: ', elm.innerHTML);
              }
              return false;
            }
          } else {
            // iterate and compare children lists
            var childrenMatch = true;
            var childNode = elm.firstChild;
            for (var i$1 = 0; i$1 < children.length; i$1++) {
              if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue)) {
                childrenMatch = false;
                break;
              }
              childNode = childNode.nextSibling;
            }
            // if childNode is not null, it means the actual childNodes list is
            // longer than the virtual children list.
            if (!childrenMatch || childNode) {
              /* istanbul ignore if */
              if (false) {
                bailed = true;
                console.warn('Parent: ', elm);
                console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);
              }
              return false;
            }
          }
        }
      }
      if (isDef(data)) {
        for (var key in data) {
          if (!isRenderedModule(key)) {
            invokeCreateHooks(vnode, insertedVnodeQueue);
            break;
          }
        }
      }
    } else if (elm.data !== vnode.text) {
      elm.data = vnode.text;
    }
    return true;
  }

  function assertNodeMatch(node, vnode) {
    if (isDef(vnode.tag)) {
      return vnode.tag.indexOf('vue-component') === 0 || vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase());
    } else {
      return node.nodeType === (vnode.isComment ? 8 : 3);
    }
  }

  return function patch(oldVnode, vnode, hydrating, removeOnly, parentElm, refElm) {
    if (isUndef(vnode)) {
      if (isDef(oldVnode)) {
        invokeDestroyHook(oldVnode);
      }
      return;
    }

    var isInitialPatch = false;
    var insertedVnodeQueue = [];

    if (isUndef(oldVnode)) {
      // empty mount (likely as component), create new root element
      isInitialPatch = true;
      createElm(vnode, insertedVnodeQueue, parentElm, refElm);
    } else {
      var isRealElement = isDef(oldVnode.nodeType);
      if (!isRealElement && sameVnode(oldVnode, vnode)) {
        // patch existing root node
        patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly);
      } else {
        if (isRealElement) {
          // mounting to a real element
          // check if this is server-rendered content and if we can perform
          // a successful hydration.
          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {
            oldVnode.removeAttribute(SSR_ATTR);
            hydrating = true;
          }
          if (isTrue(hydrating)) {
            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {
              invokeInsertHook(vnode, insertedVnodeQueue, true);
              return oldVnode;
            } else if (false) {
              warn('The client-side rendered virtual DOM tree is not matching ' + 'server-rendered content. This is likely caused by incorrect ' + 'HTML markup, for example nesting block-level elements inside ' + '<p>, or missing <tbody>. Bailing hydration and performing ' + 'full client-side render.');
            }
          }
          // either not server-rendered, or hydration failed.
          // create an empty node and replace it
          oldVnode = emptyNodeAt(oldVnode);
        }
        // replacing existing element
        var oldElm = oldVnode.elm;
        var parentElm$1 = nodeOps.parentNode(oldElm);
        createElm(vnode, insertedVnodeQueue,
        // extremely rare edge case: do not insert if old element is in a
        // leaving transition. Only happens when combining transition +
        // keep-alive + HOCs. (#4590)
        oldElm._leaveCb ? null : parentElm$1, nodeOps.nextSibling(oldElm));

        if (isDef(vnode.parent)) {
          // component root element replaced.
          // update parent placeholder node element, recursively
          var ancestor = vnode.parent;
          var patchable = isPatchable(vnode);
          while (ancestor) {
            for (var i = 0; i < cbs.destroy.length; ++i) {
              cbs.destroy[i](ancestor);
            }
            ancestor.elm = vnode.elm;
            if (patchable) {
              for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
                cbs.create[i$1](emptyNode, ancestor);
              }
              // #6513
              // invoke insert hooks that may have been merged by create hooks.
              // e.g. for directives that uses the "inserted" hook.
              var insert = ancestor.data.hook.insert;
              if (insert.merged) {
                // start at index 1 to avoid re-invoking component mounted hook
                for (var i$2 = 1; i$2 < insert.fns.length; i$2++) {
                  insert.fns[i$2]();
                }
              }
            }
            ancestor = ancestor.parent;
          }
        }

        if (isDef(parentElm$1)) {
          removeVnodes(parentElm$1, [oldVnode], 0, 0);
        } else if (isDef(oldVnode.tag)) {
          invokeDestroyHook(oldVnode);
        }
      }
    }

    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);
    return vnode.elm;
  };
}

/*  */

var directives = {
  create: updateDirectives,
  update: updateDirectives,
  destroy: function unbindDirectives(vnode) {
    updateDirectives(vnode, emptyNode);
  }
};

function updateDirectives(oldVnode, vnode) {
  if (oldVnode.data.directives || vnode.data.directives) {
    _update(oldVnode, vnode);
  }
}

function _update(oldVnode, vnode) {
  var isCreate = oldVnode === emptyNode;
  var isDestroy = vnode === emptyNode;
  var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);
  var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);

  var dirsWithInsert = [];
  var dirsWithPostpatch = [];

  var key, oldDir, dir;
  for (key in newDirs) {
    oldDir = oldDirs[key];
    dir = newDirs[key];
    if (!oldDir) {
      // new directive, bind
      callHook$1(dir, 'bind', vnode, oldVnode);
      if (dir.def && dir.def.inserted) {
        dirsWithInsert.push(dir);
      }
    } else {
      // existing directive, update
      dir.oldValue = oldDir.value;
      callHook$1(dir, 'update', vnode, oldVnode);
      if (dir.def && dir.def.componentUpdated) {
        dirsWithPostpatch.push(dir);
      }
    }
  }

  if (dirsWithInsert.length) {
    var callInsert = function () {
      for (var i = 0; i < dirsWithInsert.length; i++) {
        callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);
      }
    };
    if (isCreate) {
      mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', callInsert);
    } else {
      callInsert();
    }
  }

  if (dirsWithPostpatch.length) {
    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'postpatch', function () {
      for (var i = 0; i < dirsWithPostpatch.length; i++) {
        callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);
      }
    });
  }

  if (!isCreate) {
    for (key in oldDirs) {
      if (!newDirs[key]) {
        // no longer present, unbind
        callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);
      }
    }
  }
}

var emptyModifiers = Object.create(null);

function normalizeDirectives$1(dirs, vm) {
  var res = Object.create(null);
  if (!dirs) {
    return res;
  }
  var i, dir;
  for (i = 0; i < dirs.length; i++) {
    dir = dirs[i];
    if (!dir.modifiers) {
      dir.modifiers = emptyModifiers;
    }
    res[getRawDirName(dir)] = dir;
    dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);
  }
  return res;
}

function getRawDirName(dir) {
  return dir.rawName || dir.name + "." + Object.keys(dir.modifiers || {}).join('.');
}

function callHook$1(dir, hook, vnode, oldVnode, isDestroy) {
  var fn = dir.def && dir.def[hook];
  if (fn) {
    try {
      fn(vnode.elm, dir, vnode, oldVnode, isDestroy);
    } catch (e) {
      handleError(e, vnode.context, "directive " + dir.name + " " + hook + " hook");
    }
  }
}

var baseModules = [ref, directives];

/*  */

function updateAttrs(oldVnode, vnode) {
  var opts = vnode.componentOptions;
  if (isDef(opts) && opts.Ctor.options.inheritAttrs === false) {
    return;
  }
  if (isUndef(oldVnode.data.attrs) && isUndef(vnode.data.attrs)) {
    return;
  }
  var key, cur, old;
  var elm = vnode.elm;
  var oldAttrs = oldVnode.data.attrs || {};
  var attrs = vnode.data.attrs || {};
  // clone observed objects, as the user probably wants to mutate it
  if (isDef(attrs.__ob__)) {
    attrs = vnode.data.attrs = extend({}, attrs);
  }

  for (key in attrs) {
    cur = attrs[key];
    old = oldAttrs[key];
    if (old !== cur) {
      setAttr(elm, key, cur);
    }
  }
  // #4391: in IE9, setting type can reset value for input[type=radio]
  /* istanbul ignore if */
  if (isIE9 && attrs.value !== oldAttrs.value) {
    setAttr(elm, 'value', attrs.value);
  }
  for (key in oldAttrs) {
    if (isUndef(attrs[key])) {
      if (isXlink(key)) {
        elm.removeAttributeNS(xlinkNS, getXlinkProp(key));
      } else if (!isEnumeratedAttr(key)) {
        elm.removeAttribute(key);
      }
    }
  }
}

function setAttr(el, key, value) {
  if (isBooleanAttr(key)) {
    // set attribute for blank value
    // e.g. <option disabled>Select one</option>
    if (isFalsyAttrValue(value)) {
      el.removeAttribute(key);
    } else {
      // technically allowfullscreen is a boolean attribute for <iframe>,
      // but Flash expects a value of "true" when used on <embed> tag
      value = key === 'allowfullscreen' && el.tagName === 'EMBED' ? 'true' : key;
      el.setAttribute(key, value);
    }
  } else if (isEnumeratedAttr(key)) {
    el.setAttribute(key, isFalsyAttrValue(value) || value === 'false' ? 'false' : 'true');
  } else if (isXlink(key)) {
    if (isFalsyAttrValue(value)) {
      el.removeAttributeNS(xlinkNS, getXlinkProp(key));
    } else {
      el.setAttributeNS(xlinkNS, key, value);
    }
  } else {
    if (isFalsyAttrValue(value)) {
      el.removeAttribute(key);
    } else {
      el.setAttribute(key, value);
    }
  }
}

var attrs = {
  create: updateAttrs,
  update: updateAttrs
};

/*  */

function updateClass(oldVnode, vnode) {
  var el = vnode.elm;
  var data = vnode.data;
  var oldData = oldVnode.data;
  if (isUndef(data.staticClass) && isUndef(data.class) && (isUndef(oldData) || isUndef(oldData.staticClass) && isUndef(oldData.class))) {
    return;
  }

  var cls = genClassForVnode(vnode);

  // handle transition classes
  var transitionClass = el._transitionClasses;
  if (isDef(transitionClass)) {
    cls = concat(cls, stringifyClass(transitionClass));
  }

  // set the class
  if (cls !== el._prevClass) {
    el.setAttribute('class', cls);
    el._prevClass = cls;
  }
}

var klass = {
  create: updateClass,
  update: updateClass
};

/*  */

var validDivisionCharRE = /[\w).+\-_$\]]/;

function parseFilters(exp) {
  var inSingle = false;
  var inDouble = false;
  var inTemplateString = false;
  var inRegex = false;
  var curly = 0;
  var square = 0;
  var paren = 0;
  var lastFilterIndex = 0;
  var c, prev, i, expression, filters;

  for (i = 0; i < exp.length; i++) {
    prev = c;
    c = exp.charCodeAt(i);
    if (inSingle) {
      if (c === 0x27 && prev !== 0x5C) {
        inSingle = false;
      }
    } else if (inDouble) {
      if (c === 0x22 && prev !== 0x5C) {
        inDouble = false;
      }
    } else if (inTemplateString) {
      if (c === 0x60 && prev !== 0x5C) {
        inTemplateString = false;
      }
    } else if (inRegex) {
      if (c === 0x2f && prev !== 0x5C) {
        inRegex = false;
      }
    } else if (c === 0x7C && // pipe
    exp.charCodeAt(i + 1) !== 0x7C && exp.charCodeAt(i - 1) !== 0x7C && !curly && !square && !paren) {
      if (expression === undefined) {
        // first filter, end of expression
        lastFilterIndex = i + 1;
        expression = exp.slice(0, i).trim();
      } else {
        pushFilter();
      }
    } else {
      switch (c) {
        case 0x22:
          inDouble = true;break; // "
        case 0x27:
          inSingle = true;break; // '
        case 0x60:
          inTemplateString = true;break; // `
        case 0x28:
          paren++;break; // (
        case 0x29:
          paren--;break; // )
        case 0x5B:
          square++;break; // [
        case 0x5D:
          square--;break; // ]
        case 0x7B:
          curly++;break; // {
        case 0x7D:
          curly--;break; // }
      }
      if (c === 0x2f) {
        // /
        var j = i - 1;
        var p = void 0;
        // find first non-whitespace prev char
        for (; j >= 0; j--) {
          p = exp.charAt(j);
          if (p !== ' ') {
            break;
          }
        }
        if (!p || !validDivisionCharRE.test(p)) {
          inRegex = true;
        }
      }
    }
  }

  if (expression === undefined) {
    expression = exp.slice(0, i).trim();
  } else if (lastFilterIndex !== 0) {
    pushFilter();
  }

  function pushFilter() {
    (filters || (filters = [])).push(exp.slice(lastFilterIndex, i).trim());
    lastFilterIndex = i + 1;
  }

  if (filters) {
    for (i = 0; i < filters.length; i++) {
      expression = wrapFilter(expression, filters[i]);
    }
  }

  return expression;
}

function wrapFilter(exp, filter) {
  var i = filter.indexOf('(');
  if (i < 0) {
    // _f: resolveFilter
    return "_f(\"" + filter + "\")(" + exp + ")";
  } else {
    var name = filter.slice(0, i);
    var args = filter.slice(i + 1);
    return "_f(\"" + name + "\")(" + exp + "," + args;
  }
}

/*  */

function baseWarn(msg) {
  console.error("[Vue compiler]: " + msg);
}

function pluckModuleFunction(modules, key) {
  return modules ? modules.map(function (m) {
    return m[key];
  }).filter(function (_) {
    return _;
  }) : [];
}

function addProp(el, name, value) {
  (el.props || (el.props = [])).push({ name: name, value: value });
}

function addAttr(el, name, value) {
  (el.attrs || (el.attrs = [])).push({ name: name, value: value });
}

function addDirective(el, name, rawName, value, arg, modifiers) {
  (el.directives || (el.directives = [])).push({ name: name, rawName: rawName, value: value, arg: arg, modifiers: modifiers });
}

function addHandler(el, name, value, modifiers, important, warn) {
  // warn prevent and passive modifier
  /* istanbul ignore if */
  if (false) {
    warn('passive and prevent can\'t be used together. ' + 'Passive handler can\'t prevent default event.');
  }
  // check capture modifier
  if (modifiers && modifiers.capture) {
    delete modifiers.capture;
    name = '!' + name; // mark the event as captured
  }
  if (modifiers && modifiers.once) {
    delete modifiers.once;
    name = '~' + name; // mark the event as once
  }
  /* istanbul ignore if */
  if (modifiers && modifiers.passive) {
    delete modifiers.passive;
    name = '&' + name; // mark the event as passive
  }
  var events;
  if (modifiers && modifiers.native) {
    delete modifiers.native;
    events = el.nativeEvents || (el.nativeEvents = {});
  } else {
    events = el.events || (el.events = {});
  }
  var newHandler = { value: value, modifiers: modifiers };
  var handlers = events[name];
  /* istanbul ignore if */
  if (Array.isArray(handlers)) {
    important ? handlers.unshift(newHandler) : handlers.push(newHandler);
  } else if (handlers) {
    events[name] = important ? [newHandler, handlers] : [handlers, newHandler];
  } else {
    events[name] = newHandler;
  }
}

function getBindingAttr(el, name, getStatic) {
  var dynamicValue = getAndRemoveAttr(el, ':' + name) || getAndRemoveAttr(el, 'v-bind:' + name);
  if (dynamicValue != null) {
    return parseFilters(dynamicValue);
  } else if (getStatic !== false) {
    var staticValue = getAndRemoveAttr(el, name);
    if (staticValue != null) {
      return JSON.stringify(staticValue);
    }
  }
}

function getAndRemoveAttr(el, name) {
  var val;
  if ((val = el.attrsMap[name]) != null) {
    var list = el.attrsList;
    for (var i = 0, l = list.length; i < l; i++) {
      if (list[i].name === name) {
        list.splice(i, 1);
        break;
      }
    }
  }
  return val;
}

/*  */

/**
 * Cross-platform code generation for component v-model
 */
function genComponentModel(el, value, modifiers) {
  var ref = modifiers || {};
  var number = ref.number;
  var trim = ref.trim;

  var baseValueExpression = '$$v';
  var valueExpression = baseValueExpression;
  if (trim) {
    valueExpression = "(typeof " + baseValueExpression + " === 'string'" + "? " + baseValueExpression + ".trim()" + ": " + baseValueExpression + ")";
  }
  if (number) {
    valueExpression = "_n(" + valueExpression + ")";
  }
  var assignment = genAssignmentCode(value, valueExpression);

  el.model = {
    value: "(" + value + ")",
    expression: "\"" + value + "\"",
    callback: "function (" + baseValueExpression + ") {" + assignment + "}"
  };
}

/**
 * Cross-platform codegen helper for generating v-model value assignment code.
 */
function genAssignmentCode(value, assignment) {
  var modelRs = parseModel(value);
  if (modelRs.idx === null) {
    return value + "=" + assignment;
  } else {
    return "$set(" + modelRs.exp + ", " + modelRs.idx + ", " + assignment + ")";
  }
}

/**
 * parse directive model to do the array update transform. a[idx] = val => $$a.splice($$idx, 1, val)
 *
 * for loop possible cases:
 *
 * - test
 * - test[idx]
 * - test[test1[idx]]
 * - test["a"][idx]
 * - xxx.test[a[a].test1[idx]]
 * - test.xxx.a["asa"][test1[idx]]
 *
 */

var len;
var str;
var chr;
var index$1;
var expressionPos;
var expressionEndPos;

function parseModel(val) {
  str = val;
  len = str.length;
  index$1 = expressionPos = expressionEndPos = 0;

  if (val.indexOf('[') < 0 || val.lastIndexOf(']') < len - 1) {
    return {
      exp: val,
      idx: null
    };
  }

  while (!eof()) {
    chr = next();
    /* istanbul ignore if */
    if (isStringStart(chr)) {
      parseString(chr);
    } else if (chr === 0x5B) {
      parseBracket(chr);
    }
  }

  return {
    exp: val.substring(0, expressionPos),
    idx: val.substring(expressionPos + 1, expressionEndPos)
  };
}

function next() {
  return str.charCodeAt(++index$1);
}

function eof() {
  return index$1 >= len;
}

function isStringStart(chr) {
  return chr === 0x22 || chr === 0x27;
}

function parseBracket(chr) {
  var inBracket = 1;
  expressionPos = index$1;
  while (!eof()) {
    chr = next();
    if (isStringStart(chr)) {
      parseString(chr);
      continue;
    }
    if (chr === 0x5B) {
      inBracket++;
    }
    if (chr === 0x5D) {
      inBracket--;
    }
    if (inBracket === 0) {
      expressionEndPos = index$1;
      break;
    }
  }
}

function parseString(chr) {
  var stringQuote = chr;
  while (!eof()) {
    chr = next();
    if (chr === stringQuote) {
      break;
    }
  }
}

/*  */

var warn$1;

// in some cases, the event used has to be determined at runtime
// so we used some reserved tokens during compile.
var RANGE_TOKEN = '__r';
var CHECKBOX_RADIO_TOKEN = '__c';

function model(el, dir, _warn) {
  warn$1 = _warn;
  var value = dir.value;
  var modifiers = dir.modifiers;
  var tag = el.tag;
  var type = el.attrsMap.type;

  if (false) {
    var dynamicType = el.attrsMap['v-bind:type'] || el.attrsMap[':type'];
    if (tag === 'input' && dynamicType) {
      warn$1("<input :type=\"" + dynamicType + "\" v-model=\"" + value + "\">:\n" + "v-model does not support dynamic input types. Use v-if branches instead.");
    }
    // inputs with type="file" are read only and setting the input's
    // value will throw an error.
    if (tag === 'input' && type === 'file') {
      warn$1("<" + el.tag + " v-model=\"" + value + "\" type=\"file\">:\n" + "File inputs are read only. Use a v-on:change listener instead.");
    }
  }

  if (el.component) {
    genComponentModel(el, value, modifiers);
    // component v-model doesn't need extra runtime
    return false;
  } else if (tag === 'select') {
    genSelect(el, value, modifiers);
  } else if (tag === 'input' && type === 'checkbox') {
    genCheckboxModel(el, value, modifiers);
  } else if (tag === 'input' && type === 'radio') {
    genRadioModel(el, value, modifiers);
  } else if (tag === 'input' || tag === 'textarea') {
    genDefaultModel(el, value, modifiers);
  } else if (!config.isReservedTag(tag)) {
    genComponentModel(el, value, modifiers);
    // component v-model doesn't need extra runtime
    return false;
  } else if (false) {
    warn$1("<" + el.tag + " v-model=\"" + value + "\">: " + "v-model is not supported on this element type. " + 'If you are working with contenteditable, it\'s recommended to ' + 'wrap a library dedicated for that purpose inside a custom component.');
  }

  // ensure runtime directive metadata
  return true;
}

function genCheckboxModel(el, value, modifiers) {
  var number = modifiers && modifiers.number;
  var valueBinding = getBindingAttr(el, 'value') || 'null';
  var trueValueBinding = getBindingAttr(el, 'true-value') || 'true';
  var falseValueBinding = getBindingAttr(el, 'false-value') || 'false';
  addProp(el, 'checked', "Array.isArray(" + value + ")" + "?_i(" + value + "," + valueBinding + ")>-1" + (trueValueBinding === 'true' ? ":(" + value + ")" : ":_q(" + value + "," + trueValueBinding + ")"));
  addHandler(el, CHECKBOX_RADIO_TOKEN, "var $$a=" + value + "," + '$$el=$event.target,' + "$$c=$$el.checked?(" + trueValueBinding + "):(" + falseValueBinding + ");" + 'if(Array.isArray($$a)){' + "var $$v=" + (number ? '_n(' + valueBinding + ')' : valueBinding) + "," + '$$i=_i($$a,$$v);' + "if($$el.checked){$$i<0&&(" + value + "=$$a.concat([$$v]))}" + "else{$$i>-1&&(" + value + "=$$a.slice(0,$$i).concat($$a.slice($$i+1)))}" + "}else{" + genAssignmentCode(value, '$$c') + "}", null, true);
}

function genRadioModel(el, value, modifiers) {
  var number = modifiers && modifiers.number;
  var valueBinding = getBindingAttr(el, 'value') || 'null';
  valueBinding = number ? "_n(" + valueBinding + ")" : valueBinding;
  addProp(el, 'checked', "_q(" + value + "," + valueBinding + ")");
  addHandler(el, CHECKBOX_RADIO_TOKEN, genAssignmentCode(value, valueBinding), null, true);
}

function genSelect(el, value, modifiers) {
  var number = modifiers && modifiers.number;
  var selectedVal = "Array.prototype.filter" + ".call($event.target.options,function(o){return o.selected})" + ".map(function(o){var val = \"_value\" in o ? o._value : o.value;" + "return " + (number ? '_n(val)' : 'val') + "})";

  var assignment = '$event.target.multiple ? $$selectedVal : $$selectedVal[0]';
  var code = "var $$selectedVal = " + selectedVal + ";";
  code = code + " " + genAssignmentCode(value, assignment);
  addHandler(el, 'change', code, null, true);
}

function genDefaultModel(el, value, modifiers) {
  var type = el.attrsMap.type;
  var ref = modifiers || {};
  var lazy = ref.lazy;
  var number = ref.number;
  var trim = ref.trim;
  var needCompositionGuard = !lazy && type !== 'range';
  var event = lazy ? 'change' : type === 'range' ? RANGE_TOKEN : 'input';

  var valueExpression = '$event.target.value';
  if (trim) {
    valueExpression = "$event.target.value.trim()";
  }
  if (number) {
    valueExpression = "_n(" + valueExpression + ")";
  }

  var code = genAssignmentCode(value, valueExpression);
  if (needCompositionGuard) {
    code = "if($event.target.composing)return;" + code;
  }

  addProp(el, 'value', "(" + value + ")");
  addHandler(el, event, code, null, true);
  if (trim || number) {
    addHandler(el, 'blur', '$forceUpdate()');
  }
}

/*  */

// normalize v-model event tokens that can only be determined at runtime.
// it's important to place the event as the first in the array because
// the whole point is ensuring the v-model callback gets called before
// user-attached handlers.
function normalizeEvents(on) {
  var event;
  /* istanbul ignore if */
  if (isDef(on[RANGE_TOKEN])) {
    // IE input[type=range] only supports `change` event
    event = isIE ? 'change' : 'input';
    on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);
    delete on[RANGE_TOKEN];
  }
  if (isDef(on[CHECKBOX_RADIO_TOKEN])) {
    // Chrome fires microtasks in between click/change, leads to #4521
    event = isChrome ? 'click' : 'change';
    on[event] = [].concat(on[CHECKBOX_RADIO_TOKEN], on[event] || []);
    delete on[CHECKBOX_RADIO_TOKEN];
  }
}

var target$1;

function add$1(event, handler, once$$1, capture, passive) {
  if (once$$1) {
    var oldHandler = handler;
    var _target = target$1; // save current target element in closure
    handler = function (ev) {
      var res = arguments.length === 1 ? oldHandler(ev) : oldHandler.apply(null, arguments);
      if (res !== null) {
        remove$2(event, handler, capture, _target);
      }
    };
  }
  target$1.addEventListener(event, handler, supportsPassive ? { capture: capture, passive: passive } : capture);
}

function remove$2(event, handler, capture, _target) {
  (_target || target$1).removeEventListener(event, handler, capture);
}

function updateDOMListeners(oldVnode, vnode) {
  if (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {
    return;
  }
  var on = vnode.data.on || {};
  var oldOn = oldVnode.data.on || {};
  target$1 = vnode.elm;
  normalizeEvents(on);
  updateListeners(on, oldOn, add$1, remove$2, vnode.context);
}

var events = {
  create: updateDOMListeners,
  update: updateDOMListeners
};

/*  */

function updateDOMProps(oldVnode, vnode) {
  if (isUndef(oldVnode.data.domProps) && isUndef(vnode.data.domProps)) {
    return;
  }
  var key, cur;
  var elm = vnode.elm;
  var oldProps = oldVnode.data.domProps || {};
  var props = vnode.data.domProps || {};
  // clone observed objects, as the user probably wants to mutate it
  if (isDef(props.__ob__)) {
    props = vnode.data.domProps = extend({}, props);
  }

  for (key in oldProps) {
    if (isUndef(props[key])) {
      elm[key] = '';
    }
  }
  for (key in props) {
    cur = props[key];
    // ignore children if the node has textContent or innerHTML,
    // as these will throw away existing DOM nodes and cause removal errors
    // on subsequent patches (#3360)
    if (key === 'textContent' || key === 'innerHTML') {
      if (vnode.children) {
        vnode.children.length = 0;
      }
      if (cur === oldProps[key]) {
        continue;
      }
    }

    if (key === 'value') {
      // store value as _value as well since
      // non-string values will be stringified
      elm._value = cur;
      // avoid resetting cursor position when value is the same
      var strCur = isUndef(cur) ? '' : String(cur);
      if (shouldUpdateValue(elm, vnode, strCur)) {
        elm.value = strCur;
      }
    } else {
      elm[key] = cur;
    }
  }
}

// check platforms/web/util/attrs.js acceptValue


function shouldUpdateValue(elm, vnode, checkVal) {
  return !elm.composing && (vnode.tag === 'option' || isDirty(elm, checkVal) || isInputChanged(elm, checkVal));
}

function isDirty(elm, checkVal) {
  // return true when textbox (.number and .trim) loses focus and its value is
  // not equal to the updated value
  var notInFocus = true;
  // #6157
  // work around IE bug when accessing document.activeElement in an iframe
  try {
    notInFocus = document.activeElement !== elm;
  } catch (e) {}
  return notInFocus && elm.value !== checkVal;
}

function isInputChanged(elm, newVal) {
  var value = elm.value;
  var modifiers = elm._vModifiers; // injected by v-model runtime
  if (isDef(modifiers) && modifiers.number) {
    return toNumber(value) !== toNumber(newVal);
  }
  if (isDef(modifiers) && modifiers.trim) {
    return value.trim() !== newVal.trim();
  }
  return value !== newVal;
}

var domProps = {
  create: updateDOMProps,
  update: updateDOMProps
};

/*  */

var parseStyleText = cached(function (cssText) {
  var res = {};
  var listDelimiter = /;(?![^(]*\))/g;
  var propertyDelimiter = /:(.+)/;
  cssText.split(listDelimiter).forEach(function (item) {
    if (item) {
      var tmp = item.split(propertyDelimiter);
      tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());
    }
  });
  return res;
});

// merge static and dynamic style data on the same vnode
function normalizeStyleData(data) {
  var style = normalizeStyleBinding(data.style);
  // static style is pre-processed into an object during compilation
  // and is always a fresh object, so it's safe to merge into it
  return data.staticStyle ? extend(data.staticStyle, style) : style;
}

// normalize possible array / string values into Object
function normalizeStyleBinding(bindingStyle) {
  if (Array.isArray(bindingStyle)) {
    return toObject(bindingStyle);
  }
  if (typeof bindingStyle === 'string') {
    return parseStyleText(bindingStyle);
  }
  return bindingStyle;
}

/**
 * parent component style should be after child's
 * so that parent component's style could override it
 */
function getStyle(vnode, checkChild) {
  var res = {};
  var styleData;

  if (checkChild) {
    var childNode = vnode;
    while (childNode.componentInstance) {
      childNode = childNode.componentInstance._vnode;
      if (childNode.data && (styleData = normalizeStyleData(childNode.data))) {
        extend(res, styleData);
      }
    }
  }

  if (styleData = normalizeStyleData(vnode.data)) {
    extend(res, styleData);
  }

  var parentNode = vnode;
  while (parentNode = parentNode.parent) {
    if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {
      extend(res, styleData);
    }
  }
  return res;
}

/*  */

var cssVarRE = /^--/;
var importantRE = /\s*!important$/;
var setProp = function (el, name, val) {
  /* istanbul ignore if */
  if (cssVarRE.test(name)) {
    el.style.setProperty(name, val);
  } else if (importantRE.test(val)) {
    el.style.setProperty(name, val.replace(importantRE, ''), 'important');
  } else {
    var normalizedName = normalize(name);
    if (Array.isArray(val)) {
      // Support values array created by autoprefixer, e.g.
      // {display: ["-webkit-box", "-ms-flexbox", "flex"]}
      // Set them one by one, and the browser will only set those it can recognize
      for (var i = 0, len = val.length; i < len; i++) {
        el.style[normalizedName] = val[i];
      }
    } else {
      el.style[normalizedName] = val;
    }
  }
};

var vendorNames = ['Webkit', 'Moz', 'ms'];

var emptyStyle;
var normalize = cached(function (prop) {
  emptyStyle = emptyStyle || document.createElement('div').style;
  prop = camelize(prop);
  if (prop !== 'filter' && prop in emptyStyle) {
    return prop;
  }
  var capName = prop.charAt(0).toUpperCase() + prop.slice(1);
  for (var i = 0; i < vendorNames.length; i++) {
    var name = vendorNames[i] + capName;
    if (name in emptyStyle) {
      return name;
    }
  }
});

function updateStyle(oldVnode, vnode) {
  var data = vnode.data;
  var oldData = oldVnode.data;

  if (isUndef(data.staticStyle) && isUndef(data.style) && isUndef(oldData.staticStyle) && isUndef(oldData.style)) {
    return;
  }

  var cur, name;
  var el = vnode.elm;
  var oldStaticStyle = oldData.staticStyle;
  var oldStyleBinding = oldData.normalizedStyle || oldData.style || {};

  // if static style exists, stylebinding already merged into it when doing normalizeStyleData
  var oldStyle = oldStaticStyle || oldStyleBinding;

  var style = normalizeStyleBinding(vnode.data.style) || {};

  // store normalized style under a different key for next diff
  // make sure to clone it if it's reactive, since the user likely wants
  // to mutate it.
  vnode.data.normalizedStyle = isDef(style.__ob__) ? extend({}, style) : style;

  var newStyle = getStyle(vnode, true);

  for (name in oldStyle) {
    if (isUndef(newStyle[name])) {
      setProp(el, name, '');
    }
  }
  for (name in newStyle) {
    cur = newStyle[name];
    if (cur !== oldStyle[name]) {
      // ie9 setting to null has no effect, must use empty string
      setProp(el, name, cur == null ? '' : cur);
    }
  }
}

var style = {
  create: updateStyle,
  update: updateStyle
};

/*  */

/**
 * Add class with compatibility for SVG since classList is not supported on
 * SVG elements in IE
 */
function addClass(el, cls) {
  /* istanbul ignore if */
  if (!cls || !(cls = cls.trim())) {
    return;
  }

  /* istanbul ignore else */
  if (el.classList) {
    if (cls.indexOf(' ') > -1) {
      cls.split(/\s+/).forEach(function (c) {
        return el.classList.add(c);
      });
    } else {
      el.classList.add(cls);
    }
  } else {
    var cur = " " + (el.getAttribute('class') || '') + " ";
    if (cur.indexOf(' ' + cls + ' ') < 0) {
      el.setAttribute('class', (cur + cls).trim());
    }
  }
}

/**
 * Remove class with compatibility for SVG since classList is not supported on
 * SVG elements in IE
 */
function removeClass(el, cls) {
  /* istanbul ignore if */
  if (!cls || !(cls = cls.trim())) {
    return;
  }

  /* istanbul ignore else */
  if (el.classList) {
    if (cls.indexOf(' ') > -1) {
      cls.split(/\s+/).forEach(function (c) {
        return el.classList.remove(c);
      });
    } else {
      el.classList.remove(cls);
    }
    if (!el.classList.length) {
      el.removeAttribute('class');
    }
  } else {
    var cur = " " + (el.getAttribute('class') || '') + " ";
    var tar = ' ' + cls + ' ';
    while (cur.indexOf(tar) >= 0) {
      cur = cur.replace(tar, ' ');
    }
    cur = cur.trim();
    if (cur) {
      el.setAttribute('class', cur);
    } else {
      el.removeAttribute('class');
    }
  }
}

/*  */

function resolveTransition(def$$1) {
  if (!def$$1) {
    return;
  }
  /* istanbul ignore else */
  if (typeof def$$1 === 'object') {
    var res = {};
    if (def$$1.css !== false) {
      extend(res, autoCssTransition(def$$1.name || 'v'));
    }
    extend(res, def$$1);
    return res;
  } else if (typeof def$$1 === 'string') {
    return autoCssTransition(def$$1);
  }
}

var autoCssTransition = cached(function (name) {
  return {
    enterClass: name + "-enter",
    enterToClass: name + "-enter-to",
    enterActiveClass: name + "-enter-active",
    leaveClass: name + "-leave",
    leaveToClass: name + "-leave-to",
    leaveActiveClass: name + "-leave-active"
  };
});

var hasTransition = inBrowser && !isIE9;
var TRANSITION = 'transition';
var ANIMATION = 'animation';

// Transition property/event sniffing
var transitionProp = 'transition';
var transitionEndEvent = 'transitionend';
var animationProp = 'animation';
var animationEndEvent = 'animationend';
if (hasTransition) {
  /* istanbul ignore if */
  if (window.ontransitionend === undefined && window.onwebkittransitionend !== undefined) {
    transitionProp = 'WebkitTransition';
    transitionEndEvent = 'webkitTransitionEnd';
  }
  if (window.onanimationend === undefined && window.onwebkitanimationend !== undefined) {
    animationProp = 'WebkitAnimation';
    animationEndEvent = 'webkitAnimationEnd';
  }
}

// binding to window is necessary to make hot reload work in IE in strict mode
var raf = inBrowser && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : setTimeout;

function nextFrame(fn) {
  raf(function () {
    raf(fn);
  });
}

function addTransitionClass(el, cls) {
  var transitionClasses = el._transitionClasses || (el._transitionClasses = []);
  if (transitionClasses.indexOf(cls) < 0) {
    transitionClasses.push(cls);
    addClass(el, cls);
  }
}

function removeTransitionClass(el, cls) {
  if (el._transitionClasses) {
    remove(el._transitionClasses, cls);
  }
  removeClass(el, cls);
}

function whenTransitionEnds(el, expectedType, cb) {
  var ref = getTransitionInfo(el, expectedType);
  var type = ref.type;
  var timeout = ref.timeout;
  var propCount = ref.propCount;
  if (!type) {
    return cb();
  }
  var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;
  var ended = 0;
  var end = function () {
    el.removeEventListener(event, onEnd);
    cb();
  };
  var onEnd = function (e) {
    if (e.target === el) {
      if (++ended >= propCount) {
        end();
      }
    }
  };
  setTimeout(function () {
    if (ended < propCount) {
      end();
    }
  }, timeout + 1);
  el.addEventListener(event, onEnd);
}

var transformRE = /\b(transform|all)(,|$)/;

function getTransitionInfo(el, expectedType) {
  var styles = window.getComputedStyle(el);
  var transitionDelays = styles[transitionProp + 'Delay'].split(', ');
  var transitionDurations = styles[transitionProp + 'Duration'].split(', ');
  var transitionTimeout = getTimeout(transitionDelays, transitionDurations);
  var animationDelays = styles[animationProp + 'Delay'].split(', ');
  var animationDurations = styles[animationProp + 'Duration'].split(', ');
  var animationTimeout = getTimeout(animationDelays, animationDurations);

  var type;
  var timeout = 0;
  var propCount = 0;
  /* istanbul ignore if */
  if (expectedType === TRANSITION) {
    if (transitionTimeout > 0) {
      type = TRANSITION;
      timeout = transitionTimeout;
      propCount = transitionDurations.length;
    }
  } else if (expectedType === ANIMATION) {
    if (animationTimeout > 0) {
      type = ANIMATION;
      timeout = animationTimeout;
      propCount = animationDurations.length;
    }
  } else {
    timeout = Math.max(transitionTimeout, animationTimeout);
    type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
    propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
  }
  var hasTransform = type === TRANSITION && transformRE.test(styles[transitionProp + 'Property']);
  return {
    type: type,
    timeout: timeout,
    propCount: propCount,
    hasTransform: hasTransform
  };
}

function getTimeout(delays, durations) {
  /* istanbul ignore next */
  while (delays.length < durations.length) {
    delays = delays.concat(delays);
  }

  return Math.max.apply(null, durations.map(function (d, i) {
    return toMs(d) + toMs(delays[i]);
  }));
}

function toMs(s) {
  return Number(s.slice(0, -1)) * 1000;
}

/*  */

function enter(vnode, toggleDisplay) {
  var el = vnode.elm;

  // call leave callback now
  if (isDef(el._leaveCb)) {
    el._leaveCb.cancelled = true;
    el._leaveCb();
  }

  var data = resolveTransition(vnode.data.transition);
  if (isUndef(data)) {
    return;
  }

  /* istanbul ignore if */
  if (isDef(el._enterCb) || el.nodeType !== 1) {
    return;
  }

  var css = data.css;
  var type = data.type;
  var enterClass = data.enterClass;
  var enterToClass = data.enterToClass;
  var enterActiveClass = data.enterActiveClass;
  var appearClass = data.appearClass;
  var appearToClass = data.appearToClass;
  var appearActiveClass = data.appearActiveClass;
  var beforeEnter = data.beforeEnter;
  var enter = data.enter;
  var afterEnter = data.afterEnter;
  var enterCancelled = data.enterCancelled;
  var beforeAppear = data.beforeAppear;
  var appear = data.appear;
  var afterAppear = data.afterAppear;
  var appearCancelled = data.appearCancelled;
  var duration = data.duration;

  // activeInstance will always be the <transition> component managing this
  // transition. One edge case to check is when the <transition> is placed
  // as the root node of a child component. In that case we need to check
  // <transition>'s parent for appear check.
  var context = activeInstance;
  var transitionNode = activeInstance.$vnode;
  while (transitionNode && transitionNode.parent) {
    transitionNode = transitionNode.parent;
    context = transitionNode.context;
  }

  var isAppear = !context._isMounted || !vnode.isRootInsert;

  if (isAppear && !appear && appear !== '') {
    return;
  }

  var startClass = isAppear && appearClass ? appearClass : enterClass;
  var activeClass = isAppear && appearActiveClass ? appearActiveClass : enterActiveClass;
  var toClass = isAppear && appearToClass ? appearToClass : enterToClass;

  var beforeEnterHook = isAppear ? beforeAppear || beforeEnter : beforeEnter;
  var enterHook = isAppear ? typeof appear === 'function' ? appear : enter : enter;
  var afterEnterHook = isAppear ? afterAppear || afterEnter : afterEnter;
  var enterCancelledHook = isAppear ? appearCancelled || enterCancelled : enterCancelled;

  var explicitEnterDuration = toNumber(isObject(duration) ? duration.enter : duration);

  if (false) {
    checkDuration(explicitEnterDuration, 'enter', vnode);
  }

  var expectsCSS = css !== false && !isIE9;
  var userWantsControl = getHookArgumentsLength(enterHook);

  var cb = el._enterCb = once(function () {
    if (expectsCSS) {
      removeTransitionClass(el, toClass);
      removeTransitionClass(el, activeClass);
    }
    if (cb.cancelled) {
      if (expectsCSS) {
        removeTransitionClass(el, startClass);
      }
      enterCancelledHook && enterCancelledHook(el);
    } else {
      afterEnterHook && afterEnterHook(el);
    }
    el._enterCb = null;
  });

  if (!vnode.data.show) {
    // remove pending leave element on enter by injecting an insert hook
    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', function () {
      var parent = el.parentNode;
      var pendingNode = parent && parent._pending && parent._pending[vnode.key];
      if (pendingNode && pendingNode.tag === vnode.tag && pendingNode.elm._leaveCb) {
        pendingNode.elm._leaveCb();
      }
      enterHook && enterHook(el, cb);
    });
  }

  // start enter transition
  beforeEnterHook && beforeEnterHook(el);
  if (expectsCSS) {
    addTransitionClass(el, startClass);
    addTransitionClass(el, activeClass);
    nextFrame(function () {
      addTransitionClass(el, toClass);
      removeTransitionClass(el, startClass);
      if (!cb.cancelled && !userWantsControl) {
        if (isValidDuration(explicitEnterDuration)) {
          setTimeout(cb, explicitEnterDuration);
        } else {
          whenTransitionEnds(el, type, cb);
        }
      }
    });
  }

  if (vnode.data.show) {
    toggleDisplay && toggleDisplay();
    enterHook && enterHook(el, cb);
  }

  if (!expectsCSS && !userWantsControl) {
    cb();
  }
}

function leave(vnode, rm) {
  var el = vnode.elm;

  // call enter callback now
  if (isDef(el._enterCb)) {
    el._enterCb.cancelled = true;
    el._enterCb();
  }

  var data = resolveTransition(vnode.data.transition);
  if (isUndef(data)) {
    return rm();
  }

  /* istanbul ignore if */
  if (isDef(el._leaveCb) || el.nodeType !== 1) {
    return;
  }

  var css = data.css;
  var type = data.type;
  var leaveClass = data.leaveClass;
  var leaveToClass = data.leaveToClass;
  var leaveActiveClass = data.leaveActiveClass;
  var beforeLeave = data.beforeLeave;
  var leave = data.leave;
  var afterLeave = data.afterLeave;
  var leaveCancelled = data.leaveCancelled;
  var delayLeave = data.delayLeave;
  var duration = data.duration;

  var expectsCSS = css !== false && !isIE9;
  var userWantsControl = getHookArgumentsLength(leave);

  var explicitLeaveDuration = toNumber(isObject(duration) ? duration.leave : duration);

  if (false) {
    checkDuration(explicitLeaveDuration, 'leave', vnode);
  }

  var cb = el._leaveCb = once(function () {
    if (el.parentNode && el.parentNode._pending) {
      el.parentNode._pending[vnode.key] = null;
    }
    if (expectsCSS) {
      removeTransitionClass(el, leaveToClass);
      removeTransitionClass(el, leaveActiveClass);
    }
    if (cb.cancelled) {
      if (expectsCSS) {
        removeTransitionClass(el, leaveClass);
      }
      leaveCancelled && leaveCancelled(el);
    } else {
      rm();
      afterLeave && afterLeave(el);
    }
    el._leaveCb = null;
  });

  if (delayLeave) {
    delayLeave(performLeave);
  } else {
    performLeave();
  }

  function performLeave() {
    // the delayed leave may have already been cancelled
    if (cb.cancelled) {
      return;
    }
    // record leaving element
    if (!vnode.data.show) {
      (el.parentNode._pending || (el.parentNode._pending = {}))[vnode.key] = vnode;
    }
    beforeLeave && beforeLeave(el);
    if (expectsCSS) {
      addTransitionClass(el, leaveClass);
      addTransitionClass(el, leaveActiveClass);
      nextFrame(function () {
        addTransitionClass(el, leaveToClass);
        removeTransitionClass(el, leaveClass);
        if (!cb.cancelled && !userWantsControl) {
          if (isValidDuration(explicitLeaveDuration)) {
            setTimeout(cb, explicitLeaveDuration);
          } else {
            whenTransitionEnds(el, type, cb);
          }
        }
      });
    }
    leave && leave(el, cb);
    if (!expectsCSS && !userWantsControl) {
      cb();
    }
  }
}

// only used in dev mode
function checkDuration(val, name, vnode) {
  if (typeof val !== 'number') {
    warn("<transition> explicit " + name + " duration is not a valid number - " + "got " + JSON.stringify(val) + ".", vnode.context);
  } else if (isNaN(val)) {
    warn("<transition> explicit " + name + " duration is NaN - " + 'the duration expression might be incorrect.', vnode.context);
  }
}

function isValidDuration(val) {
  return typeof val === 'number' && !isNaN(val);
}

/**
 * Normalize a transition hook's argument length. The hook may be:
 * - a merged hook (invoker) with the original in .fns
 * - a wrapped component method (check ._length)
 * - a plain function (.length)
 */
function getHookArgumentsLength(fn) {
  if (isUndef(fn)) {
    return false;
  }
  var invokerFns = fn.fns;
  if (isDef(invokerFns)) {
    // invoker
    return getHookArgumentsLength(Array.isArray(invokerFns) ? invokerFns[0] : invokerFns);
  } else {
    return (fn._length || fn.length) > 1;
  }
}

function _enter(_, vnode) {
  if (vnode.data.show !== true) {
    enter(vnode);
  }
}

var transition = inBrowser ? {
  create: _enter,
  activate: _enter,
  remove: function remove$$1(vnode, rm) {
    /* istanbul ignore else */
    if (vnode.data.show !== true) {
      leave(vnode, rm);
    } else {
      rm();
    }
  }
} : {};

var platformModules = [attrs, klass, events, domProps, style, transition];

/*  */

// the directive module should be applied last, after all
// built-in modules have been applied.
var modules = platformModules.concat(baseModules);

var patch = createPatchFunction({ nodeOps: nodeOps, modules: modules });

/**
 * Not type checking this file because flow doesn't like attaching
 * properties to Elements.
 */

/* istanbul ignore if */
if (isIE9) {
  // http://www.matts411.com/post/internet-explorer-9-oninput/
  document.addEventListener('selectionchange', function () {
    var el = document.activeElement;
    if (el && el.vmodel) {
      trigger(el, 'input');
    }
  });
}

var model$1 = {
  inserted: function inserted(el, binding, vnode) {
    if (vnode.tag === 'select') {
      setSelected(el, binding, vnode.context);
      el._vOptions = [].map.call(el.options, getValue);
    } else if (vnode.tag === 'textarea' || isTextInputType(el.type)) {
      el._vModifiers = binding.modifiers;
      if (!binding.modifiers.lazy) {
        // Safari < 10.2 & UIWebView doesn't fire compositionend when
        // switching focus before confirming composition choice
        // this also fixes the issue where some browsers e.g. iOS Chrome
        // fires "change" instead of "input" on autocomplete.
        el.addEventListener('change', onCompositionEnd);
        if (!isAndroid) {
          el.addEventListener('compositionstart', onCompositionStart);
          el.addEventListener('compositionend', onCompositionEnd);
        }
        /* istanbul ignore if */
        if (isIE9) {
          el.vmodel = true;
        }
      }
    }
  },
  componentUpdated: function componentUpdated(el, binding, vnode) {
    if (vnode.tag === 'select') {
      setSelected(el, binding, vnode.context);
      // in case the options rendered by v-for have changed,
      // it's possible that the value is out-of-sync with the rendered options.
      // detect such cases and filter out values that no longer has a matching
      // option in the DOM.
      var prevOptions = el._vOptions;
      var curOptions = el._vOptions = [].map.call(el.options, getValue);
      if (curOptions.some(function (o, i) {
        return !looseEqual(o, prevOptions[i]);
      })) {
        // trigger change event if
        // no matching option found for at least one value
        var needReset = el.multiple ? binding.value.some(function (v) {
          return hasNoMatchingOption(v, curOptions);
        }) : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, curOptions);
        if (needReset) {
          trigger(el, 'change');
        }
      }
    }
  }
};

function setSelected(el, binding, vm) {
  actuallySetSelected(el, binding, vm);
  /* istanbul ignore if */
  if (isIE || isEdge) {
    setTimeout(function () {
      actuallySetSelected(el, binding, vm);
    }, 0);
  }
}

function actuallySetSelected(el, binding, vm) {
  var value = binding.value;
  var isMultiple = el.multiple;
  if (isMultiple && !Array.isArray(value)) {
    "production" !== 'production' && warn("<select multiple v-model=\"" + binding.expression + "\"> " + "expects an Array value for its binding, but got " + Object.prototype.toString.call(value).slice(8, -1), vm);
    return;
  }
  var selected, option;
  for (var i = 0, l = el.options.length; i < l; i++) {
    option = el.options[i];
    if (isMultiple) {
      selected = looseIndexOf(value, getValue(option)) > -1;
      if (option.selected !== selected) {
        option.selected = selected;
      }
    } else {
      if (looseEqual(getValue(option), value)) {
        if (el.selectedIndex !== i) {
          el.selectedIndex = i;
        }
        return;
      }
    }
  }
  if (!isMultiple) {
    el.selectedIndex = -1;
  }
}

function hasNoMatchingOption(value, options) {
  return options.every(function (o) {
    return !looseEqual(o, value);
  });
}

function getValue(option) {
  return '_value' in option ? option._value : option.value;
}

function onCompositionStart(e) {
  e.target.composing = true;
}

function onCompositionEnd(e) {
  // prevent triggering an input event for no reason
  if (!e.target.composing) {
    return;
  }
  e.target.composing = false;
  trigger(e.target, 'input');
}

function trigger(el, type) {
  var e = document.createEvent('HTMLEvents');
  e.initEvent(type, true, true);
  el.dispatchEvent(e);
}

/*  */

// recursively search for possible transition defined inside the component root
function locateNode(vnode) {
  return vnode.componentInstance && (!vnode.data || !vnode.data.transition) ? locateNode(vnode.componentInstance._vnode) : vnode;
}

var show = {
  bind: function bind(el, ref, vnode) {
    var value = ref.value;

    vnode = locateNode(vnode);
    var transition$$1 = vnode.data && vnode.data.transition;
    var originalDisplay = el.__vOriginalDisplay = el.style.display === 'none' ? '' : el.style.display;
    if (value && transition$$1) {
      vnode.data.show = true;
      enter(vnode, function () {
        el.style.display = originalDisplay;
      });
    } else {
      el.style.display = value ? originalDisplay : 'none';
    }
  },

  update: function update(el, ref, vnode) {
    var value = ref.value;
    var oldValue = ref.oldValue;

    /* istanbul ignore if */
    if (value === oldValue) {
      return;
    }
    vnode = locateNode(vnode);
    var transition$$1 = vnode.data && vnode.data.transition;
    if (transition$$1) {
      vnode.data.show = true;
      if (value) {
        enter(vnode, function () {
          el.style.display = el.__vOriginalDisplay;
        });
      } else {
        leave(vnode, function () {
          el.style.display = 'none';
        });
      }
    } else {
      el.style.display = value ? el.__vOriginalDisplay : 'none';
    }
  },

  unbind: function unbind(el, binding, vnode, oldVnode, isDestroy) {
    if (!isDestroy) {
      el.style.display = el.__vOriginalDisplay;
    }
  }
};

var platformDirectives = {
  model: model$1,
  show: show
};

/*  */

// Provides transition support for a single element/component.
// supports transition mode (out-in / in-out)

var transitionProps = {
  name: String,
  appear: Boolean,
  css: Boolean,
  mode: String,
  type: String,
  enterClass: String,
  leaveClass: String,
  enterToClass: String,
  leaveToClass: String,
  enterActiveClass: String,
  leaveActiveClass: String,
  appearClass: String,
  appearActiveClass: String,
  appearToClass: String,
  duration: [Number, String, Object]
};

// in case the child is also an abstract component, e.g. <keep-alive>
// we want to recursively retrieve the real component to be rendered
function getRealChild(vnode) {
  var compOptions = vnode && vnode.componentOptions;
  if (compOptions && compOptions.Ctor.options.abstract) {
    return getRealChild(getFirstComponentChild(compOptions.children));
  } else {
    return vnode;
  }
}

function extractTransitionData(comp) {
  var data = {};
  var options = comp.$options;
  // props
  for (var key in options.propsData) {
    data[key] = comp[key];
  }
  // events.
  // extract listeners and pass them directly to the transition methods
  var listeners = options._parentListeners;
  for (var key$1 in listeners) {
    data[camelize(key$1)] = listeners[key$1];
  }
  return data;
}

function placeholder(h, rawChild) {
  if (/\d-keep-alive$/.test(rawChild.tag)) {
    return h('keep-alive', {
      props: rawChild.componentOptions.propsData
    });
  }
}

function hasParentTransition(vnode) {
  while (vnode = vnode.parent) {
    if (vnode.data.transition) {
      return true;
    }
  }
}

function isSameChild(child, oldChild) {
  return oldChild.key === child.key && oldChild.tag === child.tag;
}

var Transition = {
  name: 'transition',
  props: transitionProps,
  abstract: true,

  render: function render(h) {
    var this$1 = this;

    var children = this.$options._renderChildren;
    if (!children) {
      return;
    }

    // filter out text nodes (possible whitespaces)
    children = children.filter(function (c) {
      return c.tag || isAsyncPlaceholder(c);
    });
    /* istanbul ignore if */
    if (!children.length) {
      return;
    }

    // warn multiple elements
    if (false) {
      warn('<transition> can only be used on a single element. Use ' + '<transition-group> for lists.', this.$parent);
    }

    var mode = this.mode;

    // warn invalid mode
    if (false) {
      warn('invalid <transition> mode: ' + mode, this.$parent);
    }

    var rawChild = children[0];

    // if this is a component root node and the component's
    // parent container node also has transition, skip.
    if (hasParentTransition(this.$vnode)) {
      return rawChild;
    }

    // apply transition data to child
    // use getRealChild() to ignore abstract components e.g. keep-alive
    var child = getRealChild(rawChild);
    /* istanbul ignore if */
    if (!child) {
      return rawChild;
    }

    if (this._leaving) {
      return placeholder(h, rawChild);
    }

    // ensure a key that is unique to the vnode type and to this transition
    // component instance. This key will be used to remove pending leaving nodes
    // during entering.
    var id = "__transition-" + this._uid + "-";
    child.key = child.key == null ? child.isComment ? id + 'comment' : id + child.tag : isPrimitive(child.key) ? String(child.key).indexOf(id) === 0 ? child.key : id + child.key : child.key;

    var data = (child.data || (child.data = {})).transition = extractTransitionData(this);
    var oldRawChild = this._vnode;
    var oldChild = getRealChild(oldRawChild);

    // mark v-show
    // so that the transition module can hand over the control to the directive
    if (child.data.directives && child.data.directives.some(function (d) {
      return d.name === 'show';
    })) {
      child.data.show = true;
    }

    if (oldChild && oldChild.data && !isSameChild(child, oldChild) && !isAsyncPlaceholder(oldChild)) {
      // replace old child transition data with fresh one
      // important for dynamic transitions!
      var oldData = oldChild && (oldChild.data.transition = extend({}, data));
      // handle transition mode
      if (mode === 'out-in') {
        // return placeholder node and queue update when leave finishes
        this._leaving = true;
        mergeVNodeHook(oldData, 'afterLeave', function () {
          this$1._leaving = false;
          this$1.$forceUpdate();
        });
        return placeholder(h, rawChild);
      } else if (mode === 'in-out') {
        if (isAsyncPlaceholder(child)) {
          return oldRawChild;
        }
        var delayedLeave;
        var performLeave = function () {
          delayedLeave();
        };
        mergeVNodeHook(data, 'afterEnter', performLeave);
        mergeVNodeHook(data, 'enterCancelled', performLeave);
        mergeVNodeHook(oldData, 'delayLeave', function (leave) {
          delayedLeave = leave;
        });
      }
    }

    return rawChild;
  }
};

/*  */

// Provides transition support for list items.
// supports move transitions using the FLIP technique.

// Because the vdom's children update algorithm is "unstable" - i.e.
// it doesn't guarantee the relative positioning of removed elements,
// we force transition-group to update its children into two passes:
// in the first pass, we remove all nodes that need to be removed,
// triggering their leaving transition; in the second pass, we insert/move
// into the final desired state. This way in the second pass removed
// nodes will remain where they should be.

var props = extend({
  tag: String,
  moveClass: String
}, transitionProps);

delete props.mode;

var TransitionGroup = {
  props: props,

  render: function render(h) {
    var tag = this.tag || this.$vnode.data.tag || 'span';
    var map = Object.create(null);
    var prevChildren = this.prevChildren = this.children;
    var rawChildren = this.$slots.default || [];
    var children = this.children = [];
    var transitionData = extractTransitionData(this);

    for (var i = 0; i < rawChildren.length; i++) {
      var c = rawChildren[i];
      if (c.tag) {
        if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {
          children.push(c);
          map[c.key] = c;(c.data || (c.data = {})).transition = transitionData;
        } else if (false) {
          var opts = c.componentOptions;
          var name = opts ? opts.Ctor.options.name || opts.tag || '' : c.tag;
          warn("<transition-group> children must be keyed: <" + name + ">");
        }
      }
    }

    if (prevChildren) {
      var kept = [];
      var removed = [];
      for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {
        var c$1 = prevChildren[i$1];
        c$1.data.transition = transitionData;
        c$1.data.pos = c$1.elm.getBoundingClientRect();
        if (map[c$1.key]) {
          kept.push(c$1);
        } else {
          removed.push(c$1);
        }
      }
      this.kept = h(tag, null, kept);
      this.removed = removed;
    }

    return h(tag, null, children);
  },

  beforeUpdate: function beforeUpdate() {
    // force removing pass
    this.__patch__(this._vnode, this.kept, false, // hydrating
    true // removeOnly (!important, avoids unnecessary moves)
    );
    this._vnode = this.kept;
  },

  updated: function updated() {
    var children = this.prevChildren;
    var moveClass = this.moveClass || (this.name || 'v') + '-move';
    if (!children.length || !this.hasMove(children[0].elm, moveClass)) {
      return;
    }

    // we divide the work into three loops to avoid mixing DOM reads and writes
    // in each iteration - which helps prevent layout thrashing.
    children.forEach(callPendingCbs);
    children.forEach(recordPosition);
    children.forEach(applyTranslation);

    // force reflow to put everything in position
    var body = document.body;
    var f = body.offsetHeight; // eslint-disable-line

    children.forEach(function (c) {
      if (c.data.moved) {
        var el = c.elm;
        var s = el.style;
        addTransitionClass(el, moveClass);
        s.transform = s.WebkitTransform = s.transitionDuration = '';
        el.addEventListener(transitionEndEvent, el._moveCb = function cb(e) {
          if (!e || /transform$/.test(e.propertyName)) {
            el.removeEventListener(transitionEndEvent, cb);
            el._moveCb = null;
            removeTransitionClass(el, moveClass);
          }
        });
      }
    });
  },

  methods: {
    hasMove: function hasMove(el, moveClass) {
      /* istanbul ignore if */
      if (!hasTransition) {
        return false;
      }
      /* istanbul ignore if */
      if (this._hasMove) {
        return this._hasMove;
      }
      // Detect whether an element with the move class applied has
      // CSS transitions. Since the element may be inside an entering
      // transition at this very moment, we make a clone of it and remove
      // all other transition classes applied to ensure only the move class
      // is applied.
      var clone = el.cloneNode();
      if (el._transitionClasses) {
        el._transitionClasses.forEach(function (cls) {
          removeClass(clone, cls);
        });
      }
      addClass(clone, moveClass);
      clone.style.display = 'none';
      this.$el.appendChild(clone);
      var info = getTransitionInfo(clone);
      this.$el.removeChild(clone);
      return this._hasMove = info.hasTransform;
    }
  }
};

function callPendingCbs(c) {
  /* istanbul ignore if */
  if (c.elm._moveCb) {
    c.elm._moveCb();
  }
  /* istanbul ignore if */
  if (c.elm._enterCb) {
    c.elm._enterCb();
  }
}

function recordPosition(c) {
  c.data.newPos = c.elm.getBoundingClientRect();
}

function applyTranslation(c) {
  var oldPos = c.data.pos;
  var newPos = c.data.newPos;
  var dx = oldPos.left - newPos.left;
  var dy = oldPos.top - newPos.top;
  if (dx || dy) {
    c.data.moved = true;
    var s = c.elm.style;
    s.transform = s.WebkitTransform = "translate(" + dx + "px," + dy + "px)";
    s.transitionDuration = '0s';
  }
}

var platformComponents = {
  Transition: Transition,
  TransitionGroup: TransitionGroup
};

/*  */

// install platform specific utils
Vue$3.config.mustUseProp = mustUseProp;
Vue$3.config.isReservedTag = isReservedTag;
Vue$3.config.isReservedAttr = isReservedAttr;
Vue$3.config.getTagNamespace = getTagNamespace;
Vue$3.config.isUnknownElement = isUnknownElement;

// install platform runtime directives & components
extend(Vue$3.options.directives, platformDirectives);
extend(Vue$3.options.components, platformComponents);

// install platform patch function
Vue$3.prototype.__patch__ = inBrowser ? patch : noop;

// public mount method
Vue$3.prototype.$mount = function (el, hydrating) {
  el = el && inBrowser ? query(el) : undefined;
  return mountComponent(this, el, hydrating);
};

// devtools global hook
/* istanbul ignore next */
setTimeout(function () {
  if (config.devtools) {
    if (devtools) {
      devtools.emit('init', Vue$3);
    } else if (false) {
      console[console.info ? 'info' : 'log']('Download the Vue Devtools extension for a better development experience:\n' + 'https://github.com/vuejs/vue-devtools');
    }
  }
  if (false) {
    console[console.info ? 'info' : 'log']("You are running Vue in development mode.\n" + "Make sure to turn on production mode when deploying for production.\n" + "See more tips at https://vuejs.org/guide/deployment.html");
  }
}, 0);

/*  */

// check whether current browser encodes a char inside attribute values
function shouldDecode(content, encoded) {
  var div = document.createElement('div');
  div.innerHTML = "<div a=\"" + content + "\"/>";
  return div.innerHTML.indexOf(encoded) > 0;
}

// #3663
// IE encodes newlines inside attribute values while other browsers don't
var shouldDecodeNewlines = inBrowser ? shouldDecode('\n', '&#10;') : false;

/*  */

var defaultTagRE = /\{\{((?:.|\n)+?)\}\}/g;
var regexEscapeRE = /[-.*+?^${}()|[\]\/\\]/g;

var buildRegex = cached(function (delimiters) {
  var open = delimiters[0].replace(regexEscapeRE, '\\$&');
  var close = delimiters[1].replace(regexEscapeRE, '\\$&');
  return new RegExp(open + '((?:.|\\n)+?)' + close, 'g');
});

function parseText(text, delimiters) {
  var tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE;
  if (!tagRE.test(text)) {
    return;
  }
  var tokens = [];
  var lastIndex = tagRE.lastIndex = 0;
  var match, index;
  while (match = tagRE.exec(text)) {
    index = match.index;
    // push text token
    if (index > lastIndex) {
      tokens.push(JSON.stringify(text.slice(lastIndex, index)));
    }
    // tag token
    var exp = parseFilters(match[1].trim());
    tokens.push("_s(" + exp + ")");
    lastIndex = index + match[0].length;
  }
  if (lastIndex < text.length) {
    tokens.push(JSON.stringify(text.slice(lastIndex)));
  }
  return tokens.join('+');
}

/*  */

function transformNode(el, options) {
  var warn = options.warn || baseWarn;
  var staticClass = getAndRemoveAttr(el, 'class');
  if (false) {
    var expression = parseText(staticClass, options.delimiters);
    if (expression) {
      warn("class=\"" + staticClass + "\": " + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div class="{{ val }}">, use <div :class="val">.');
    }
  }
  if (staticClass) {
    el.staticClass = JSON.stringify(staticClass);
  }
  var classBinding = getBindingAttr(el, 'class', false /* getStatic */);
  if (classBinding) {
    el.classBinding = classBinding;
  }
}

function genData(el) {
  var data = '';
  if (el.staticClass) {
    data += "staticClass:" + el.staticClass + ",";
  }
  if (el.classBinding) {
    data += "class:" + el.classBinding + ",";
  }
  return data;
}

var klass$1 = {
  staticKeys: ['staticClass'],
  transformNode: transformNode,
  genData: genData
};

/*  */

function transformNode$1(el, options) {
  var warn = options.warn || baseWarn;
  var staticStyle = getAndRemoveAttr(el, 'style');
  if (staticStyle) {
    /* istanbul ignore if */
    if (false) {
      var expression = parseText(staticStyle, options.delimiters);
      if (expression) {
        warn("style=\"" + staticStyle + "\": " + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div style="{{ val }}">, use <div :style="val">.');
      }
    }
    el.staticStyle = JSON.stringify(parseStyleText(staticStyle));
  }

  var styleBinding = getBindingAttr(el, 'style', false /* getStatic */);
  if (styleBinding) {
    el.styleBinding = styleBinding;
  }
}

function genData$1(el) {
  var data = '';
  if (el.staticStyle) {
    data += "staticStyle:" + el.staticStyle + ",";
  }
  if (el.styleBinding) {
    data += "style:(" + el.styleBinding + "),";
  }
  return data;
}

var style$1 = {
  staticKeys: ['staticStyle'],
  transformNode: transformNode$1,
  genData: genData$1
};

var modules$1 = [klass$1, style$1];

/*  */

function text(el, dir) {
  if (dir.value) {
    addProp(el, 'textContent', "_s(" + dir.value + ")");
  }
}

/*  */

function html(el, dir) {
  if (dir.value) {
    addProp(el, 'innerHTML', "_s(" + dir.value + ")");
  }
}

var directives$1 = {
  model: model,
  text: text,
  html: html
};

/*  */

var isUnaryTag = makeMap('area,base,br,col,embed,frame,hr,img,input,isindex,keygen,' + 'link,meta,param,source,track,wbr');

// Elements that you can, intentionally, leave open
// (and which close themselves)
var canBeLeftOpenTag = makeMap('colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source');

// HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3
// Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content
var isNonPhrasingTag = makeMap('address,article,aside,base,blockquote,body,caption,col,colgroup,dd,' + 'details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,' + 'h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,' + 'optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,' + 'title,tr,track');

/*  */

var baseOptions = {
  expectHTML: true,
  modules: modules$1,
  directives: directives$1,
  isPreTag: isPreTag,
  isUnaryTag: isUnaryTag,
  mustUseProp: mustUseProp,
  canBeLeftOpenTag: canBeLeftOpenTag,
  isReservedTag: isReservedTag,
  getTagNamespace: getTagNamespace,
  staticKeys: genStaticKeys(modules$1)
};

/*  */

var decoder;

var he = {
  decode: function decode(html) {
    decoder = decoder || document.createElement('div');
    decoder.innerHTML = html;
    return decoder.textContent;
  }
};

/**
 * Not type-checking this file because it's mostly vendor code.
 */

/*!
 * HTML Parser By John Resig (ejohn.org)
 * Modified by Juriy "kangax" Zaytsev
 * Original code by Erik Arvidsson, Mozilla Public License
 * http://erik.eae.net/simplehtmlparser/simplehtmlparser.js
 */

// Regular Expressions for parsing tags and attributes
var attribute = /^\s*([^\s"'<>\/=]+)(?:\s*(=)\s*(?:"([^"]*)"+|'([^']*)'+|([^\s"'=<>`]+)))?/;
// could use https://www.w3.org/TR/1999/REC-xml-names-19990114/#NT-QName
// but for Vue templates we can enforce a simple charset
var ncname = '[a-zA-Z_][\\w\\-\\.]*';
var qnameCapture = "((?:" + ncname + "\\:)?" + ncname + ")";
var startTagOpen = new RegExp("^<" + qnameCapture);
var startTagClose = /^\s*(\/?)>/;
var endTag = new RegExp("^<\\/" + qnameCapture + "[^>]*>");
var doctype = /^<!DOCTYPE [^>]+>/i;
var comment = /^<!--/;
var conditionalComment = /^<!\[/;

var IS_REGEX_CAPTURING_BROKEN = false;
'x'.replace(/x(.)?/g, function (m, g) {
  IS_REGEX_CAPTURING_BROKEN = g === '';
});

// Special Elements (can contain anything)
var isPlainTextElement = makeMap('script,style,textarea', true);
var reCache = {};

var decodingMap = {
  '&lt;': '<',
  '&gt;': '>',
  '&quot;': '"',
  '&amp;': '&',
  '&#10;': '\n'
};
var encodedAttr = /&(?:lt|gt|quot|amp);/g;
var encodedAttrWithNewLines = /&(?:lt|gt|quot|amp|#10);/g;

// #5992
var isIgnoreNewlineTag = makeMap('pre,textarea', true);
var shouldIgnoreFirstNewline = function (tag, html) {
  return tag && isIgnoreNewlineTag(tag) && html[0] === '\n';
};

function decodeAttr(value, shouldDecodeNewlines) {
  var re = shouldDecodeNewlines ? encodedAttrWithNewLines : encodedAttr;
  return value.replace(re, function (match) {
    return decodingMap[match];
  });
}

function parseHTML(html, options) {
  var stack = [];
  var expectHTML = options.expectHTML;
  var isUnaryTag$$1 = options.isUnaryTag || no;
  var canBeLeftOpenTag$$1 = options.canBeLeftOpenTag || no;
  var index = 0;
  var last, lastTag;
  while (html) {
    last = html;
    // Make sure we're not in a plaintext content element like script/style
    if (!lastTag || !isPlainTextElement(lastTag)) {
      var textEnd = html.indexOf('<');
      if (textEnd === 0) {
        // Comment:
        if (comment.test(html)) {
          var commentEnd = html.indexOf('-->');

          if (commentEnd >= 0) {
            if (options.shouldKeepComment) {
              options.comment(html.substring(4, commentEnd));
            }
            advance(commentEnd + 3);
            continue;
          }
        }

        // http://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment
        if (conditionalComment.test(html)) {
          var conditionalEnd = html.indexOf(']>');

          if (conditionalEnd >= 0) {
            advance(conditionalEnd + 2);
            continue;
          }
        }

        // Doctype:
        var doctypeMatch = html.match(doctype);
        if (doctypeMatch) {
          advance(doctypeMatch[0].length);
          continue;
        }

        // End tag:
        var endTagMatch = html.match(endTag);
        if (endTagMatch) {
          var curIndex = index;
          advance(endTagMatch[0].length);
          parseEndTag(endTagMatch[1], curIndex, index);
          continue;
        }

        // Start tag:
        var startTagMatch = parseStartTag();
        if (startTagMatch) {
          handleStartTag(startTagMatch);
          if (shouldIgnoreFirstNewline(lastTag, html)) {
            advance(1);
          }
          continue;
        }
      }

      var text = void 0,
          rest = void 0,
          next = void 0;
      if (textEnd >= 0) {
        rest = html.slice(textEnd);
        while (!endTag.test(rest) && !startTagOpen.test(rest) && !comment.test(rest) && !conditionalComment.test(rest)) {
          // < in plain text, be forgiving and treat it as text
          next = rest.indexOf('<', 1);
          if (next < 0) {
            break;
          }
          textEnd += next;
          rest = html.slice(textEnd);
        }
        text = html.substring(0, textEnd);
        advance(textEnd);
      }

      if (textEnd < 0) {
        text = html;
        html = '';
      }

      if (options.chars && text) {
        options.chars(text);
      }
    } else {
      var endTagLength = 0;
      var stackedTag = lastTag.toLowerCase();
      var reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp('([\\s\\S]*?)(</' + stackedTag + '[^>]*>)', 'i'));
      var rest$1 = html.replace(reStackedTag, function (all, text, endTag) {
        endTagLength = endTag.length;
        if (!isPlainTextElement(stackedTag) && stackedTag !== 'noscript') {
          text = text.replace(/<!--([\s\S]*?)-->/g, '$1').replace(/<!\[CDATA\[([\s\S]*?)]]>/g, '$1');
        }
        if (shouldIgnoreFirstNewline(stackedTag, text)) {
          text = text.slice(1);
        }
        if (options.chars) {
          options.chars(text);
        }
        return '';
      });
      index += html.length - rest$1.length;
      html = rest$1;
      parseEndTag(stackedTag, index - endTagLength, index);
    }

    if (html === last) {
      options.chars && options.chars(html);
      if (false) {
        options.warn("Mal-formatted tag at end of template: \"" + html + "\"");
      }
      break;
    }
  }

  // Clean up any remaining tags
  parseEndTag();

  function advance(n) {
    index += n;
    html = html.substring(n);
  }

  function parseStartTag() {
    var start = html.match(startTagOpen);
    if (start) {
      var match = {
        tagName: start[1],
        attrs: [],
        start: index
      };
      advance(start[0].length);
      var end, attr;
      while (!(end = html.match(startTagClose)) && (attr = html.match(attribute))) {
        advance(attr[0].length);
        match.attrs.push(attr);
      }
      if (end) {
        match.unarySlash = end[1];
        advance(end[0].length);
        match.end = index;
        return match;
      }
    }
  }

  function handleStartTag(match) {
    var tagName = match.tagName;
    var unarySlash = match.unarySlash;

    if (expectHTML) {
      if (lastTag === 'p' && isNonPhrasingTag(tagName)) {
        parseEndTag(lastTag);
      }
      if (canBeLeftOpenTag$$1(tagName) && lastTag === tagName) {
        parseEndTag(tagName);
      }
    }

    var unary = isUnaryTag$$1(tagName) || !!unarySlash;

    var l = match.attrs.length;
    var attrs = new Array(l);
    for (var i = 0; i < l; i++) {
      var args = match.attrs[i];
      // hackish work around FF bug https://bugzilla.mozilla.org/show_bug.cgi?id=369778
      if (IS_REGEX_CAPTURING_BROKEN && args[0].indexOf('""') === -1) {
        if (args[3] === '') {
          delete args[3];
        }
        if (args[4] === '') {
          delete args[4];
        }
        if (args[5] === '') {
          delete args[5];
        }
      }
      var value = args[3] || args[4] || args[5] || '';
      attrs[i] = {
        name: args[1],
        value: decodeAttr(value, options.shouldDecodeNewlines)
      };
    }

    if (!unary) {
      stack.push({ tag: tagName, lowerCasedTag: tagName.toLowerCase(), attrs: attrs });
      lastTag = tagName;
    }

    if (options.start) {
      options.start(tagName, attrs, unary, match.start, match.end);
    }
  }

  function parseEndTag(tagName, start, end) {
    var pos, lowerCasedTagName;
    if (start == null) {
      start = index;
    }
    if (end == null) {
      end = index;
    }

    if (tagName) {
      lowerCasedTagName = tagName.toLowerCase();
    }

    // Find the closest opened tag of the same type
    if (tagName) {
      for (pos = stack.length - 1; pos >= 0; pos--) {
        if (stack[pos].lowerCasedTag === lowerCasedTagName) {
          break;
        }
      }
    } else {
      // If no tag name is provided, clean shop
      pos = 0;
    }

    if (pos >= 0) {
      // Close all the open elements, up the stack
      for (var i = stack.length - 1; i >= pos; i--) {
        if (false) {
          options.warn("tag <" + stack[i].tag + "> has no matching end tag.");
        }
        if (options.end) {
          options.end(stack[i].tag, start, end);
        }
      }

      // Remove the open elements from the stack
      stack.length = pos;
      lastTag = pos && stack[pos - 1].tag;
    } else if (lowerCasedTagName === 'br') {
      if (options.start) {
        options.start(tagName, [], true, start, end);
      }
    } else if (lowerCasedTagName === 'p') {
      if (options.start) {
        options.start(tagName, [], false, start, end);
      }
      if (options.end) {
        options.end(tagName, start, end);
      }
    }
  }
}

/*  */

var onRE = /^@|^v-on:/;
var dirRE = /^v-|^@|^:/;
var forAliasRE = /(.*?)\s+(?:in|of)\s+(.*)/;
var forIteratorRE = /\((\{[^}]*\}|[^,]*),([^,]*)(?:,([^,]*))?\)/;

var argRE = /:(.*)$/;
var bindRE = /^:|^v-bind:/;
var modifierRE = /\.[^.]+/g;

var decodeHTMLCached = cached(he.decode);

// configurable state
var warn$2;
var delimiters;
var transforms;
var preTransforms;
var postTransforms;
var platformIsPreTag;
var platformMustUseProp;
var platformGetTagNamespace;

/**
 * Convert HTML string to AST.
 */
function parse(template, options) {
  warn$2 = options.warn || baseWarn;

  platformIsPreTag = options.isPreTag || no;
  platformMustUseProp = options.mustUseProp || no;
  platformGetTagNamespace = options.getTagNamespace || no;

  transforms = pluckModuleFunction(options.modules, 'transformNode');
  preTransforms = pluckModuleFunction(options.modules, 'preTransformNode');
  postTransforms = pluckModuleFunction(options.modules, 'postTransformNode');

  delimiters = options.delimiters;

  var stack = [];
  var preserveWhitespace = options.preserveWhitespace !== false;
  var root;
  var currentParent;
  var inVPre = false;
  var inPre = false;
  var warned = false;

  function warnOnce(msg) {
    if (!warned) {
      warned = true;
      warn$2(msg);
    }
  }

  function endPre(element) {
    // check pre state
    if (element.pre) {
      inVPre = false;
    }
    if (platformIsPreTag(element.tag)) {
      inPre = false;
    }
  }

  parseHTML(template, {
    warn: warn$2,
    expectHTML: options.expectHTML,
    isUnaryTag: options.isUnaryTag,
    canBeLeftOpenTag: options.canBeLeftOpenTag,
    shouldDecodeNewlines: options.shouldDecodeNewlines,
    shouldKeepComment: options.comments,
    start: function start(tag, attrs, unary) {
      // check namespace.
      // inherit parent ns if there is one
      var ns = currentParent && currentParent.ns || platformGetTagNamespace(tag);

      // handle IE svg bug
      /* istanbul ignore if */
      if (isIE && ns === 'svg') {
        attrs = guardIESVGBug(attrs);
      }

      var element = {
        type: 1,
        tag: tag,
        attrsList: attrs,
        attrsMap: makeAttrsMap(attrs),
        parent: currentParent,
        children: []
      };
      if (ns) {
        element.ns = ns;
      }

      if (isForbiddenTag(element) && !isServerRendering()) {
        element.forbidden = true;
        "production" !== 'production' && warn$2('Templates should only be responsible for mapping the state to the ' + 'UI. Avoid placing tags with side-effects in your templates, such as ' + "<" + tag + ">" + ', as they will not be parsed.');
      }

      // apply pre-transforms
      for (var i = 0; i < preTransforms.length; i++) {
        preTransforms[i](element, options);
      }

      if (!inVPre) {
        processPre(element);
        if (element.pre) {
          inVPre = true;
        }
      }
      if (platformIsPreTag(element.tag)) {
        inPre = true;
      }
      if (inVPre) {
        processRawAttrs(element);
      } else {
        processFor(element);
        processIf(element);
        processOnce(element);
        processKey(element);

        // determine whether this is a plain element after
        // removing structural attributes
        element.plain = !element.key && !attrs.length;

        processRef(element);
        processSlot(element);
        processComponent(element);
        for (var i$1 = 0; i$1 < transforms.length; i$1++) {
          transforms[i$1](element, options);
        }
        processAttrs(element);
      }

      function checkRootConstraints(el) {
        if (false) {
          if (el.tag === 'slot' || el.tag === 'template') {
            warnOnce("Cannot use <" + el.tag + "> as component root element because it may " + 'contain multiple nodes.');
          }
          if (el.attrsMap.hasOwnProperty('v-for')) {
            warnOnce('Cannot use v-for on stateful component root element because ' + 'it renders multiple elements.');
          }
        }
      }

      // tree management
      if (!root) {
        root = element;
        checkRootConstraints(root);
      } else if (!stack.length) {
        // allow root elements with v-if, v-else-if and v-else
        if (root.if && (element.elseif || element.else)) {
          checkRootConstraints(element);
          addIfCondition(root, {
            exp: element.elseif,
            block: element
          });
        } else if (false) {
          warnOnce("Component template should contain exactly one root element. " + "If you are using v-if on multiple elements, " + "use v-else-if to chain them instead.");
        }
      }
      if (currentParent && !element.forbidden) {
        if (element.elseif || element.else) {
          processIfConditions(element, currentParent);
        } else if (element.slotScope) {
          // scoped slot
          currentParent.plain = false;
          var name = element.slotTarget || '"default"';(currentParent.scopedSlots || (currentParent.scopedSlots = {}))[name] = element;
        } else {
          currentParent.children.push(element);
          element.parent = currentParent;
        }
      }
      if (!unary) {
        currentParent = element;
        stack.push(element);
      } else {
        endPre(element);
      }
      // apply post-transforms
      for (var i$2 = 0; i$2 < postTransforms.length; i$2++) {
        postTransforms[i$2](element, options);
      }
    },

    end: function end() {
      // remove trailing whitespace
      var element = stack[stack.length - 1];
      var lastNode = element.children[element.children.length - 1];
      if (lastNode && lastNode.type === 3 && lastNode.text === ' ' && !inPre) {
        element.children.pop();
      }
      // pop stack
      stack.length -= 1;
      currentParent = stack[stack.length - 1];
      endPre(element);
    },

    chars: function chars(text) {
      if (!currentParent) {
        if (false) {
          if (text === template) {
            warnOnce('Component template requires a root element, rather than just text.');
          } else if (text = text.trim()) {
            warnOnce("text \"" + text + "\" outside root element will be ignored.");
          }
        }
        return;
      }
      // IE textarea placeholder bug
      /* istanbul ignore if */
      if (isIE && currentParent.tag === 'textarea' && currentParent.attrsMap.placeholder === text) {
        return;
      }
      var children = currentParent.children;
      text = inPre || text.trim() ? isTextTag(currentParent) ? text : decodeHTMLCached(text)
      // only preserve whitespace if its not right after a starting tag
      : preserveWhitespace && children.length ? ' ' : '';
      if (text) {
        var expression;
        if (!inVPre && text !== ' ' && (expression = parseText(text, delimiters))) {
          children.push({
            type: 2,
            expression: expression,
            text: text
          });
        } else if (text !== ' ' || !children.length || children[children.length - 1].text !== ' ') {
          children.push({
            type: 3,
            text: text
          });
        }
      }
    },
    comment: function comment(text) {
      currentParent.children.push({
        type: 3,
        text: text,
        isComment: true
      });
    }
  });
  return root;
}

function processPre(el) {
  if (getAndRemoveAttr(el, 'v-pre') != null) {
    el.pre = true;
  }
}

function processRawAttrs(el) {
  var l = el.attrsList.length;
  if (l) {
    var attrs = el.attrs = new Array(l);
    for (var i = 0; i < l; i++) {
      attrs[i] = {
        name: el.attrsList[i].name,
        value: JSON.stringify(el.attrsList[i].value)
      };
    }
  } else if (!el.pre) {
    // non root node in pre blocks with no attributes
    el.plain = true;
  }
}

function processKey(el) {
  var exp = getBindingAttr(el, 'key');
  if (exp) {
    if (false) {
      warn$2("<template> cannot be keyed. Place the key on real elements instead.");
    }
    el.key = exp;
  }
}

function processRef(el) {
  var ref = getBindingAttr(el, 'ref');
  if (ref) {
    el.ref = ref;
    el.refInFor = checkInFor(el);
  }
}

function processFor(el) {
  var exp;
  if (exp = getAndRemoveAttr(el, 'v-for')) {
    var inMatch = exp.match(forAliasRE);
    if (!inMatch) {
      "production" !== 'production' && warn$2("Invalid v-for expression: " + exp);
      return;
    }
    el.for = inMatch[2].trim();
    var alias = inMatch[1].trim();
    var iteratorMatch = alias.match(forIteratorRE);
    if (iteratorMatch) {
      el.alias = iteratorMatch[1].trim();
      el.iterator1 = iteratorMatch[2].trim();
      if (iteratorMatch[3]) {
        el.iterator2 = iteratorMatch[3].trim();
      }
    } else {
      el.alias = alias;
    }
  }
}

function processIf(el) {
  var exp = getAndRemoveAttr(el, 'v-if');
  if (exp) {
    el.if = exp;
    addIfCondition(el, {
      exp: exp,
      block: el
    });
  } else {
    if (getAndRemoveAttr(el, 'v-else') != null) {
      el.else = true;
    }
    var elseif = getAndRemoveAttr(el, 'v-else-if');
    if (elseif) {
      el.elseif = elseif;
    }
  }
}

function processIfConditions(el, parent) {
  var prev = findPrevElement(parent.children);
  if (prev && prev.if) {
    addIfCondition(prev, {
      exp: el.elseif,
      block: el
    });
  } else if (false) {
    warn$2("v-" + (el.elseif ? 'else-if="' + el.elseif + '"' : 'else') + " " + "used on element <" + el.tag + "> without corresponding v-if.");
  }
}

function findPrevElement(children) {
  var i = children.length;
  while (i--) {
    if (children[i].type === 1) {
      return children[i];
    } else {
      if (false) {
        warn$2("text \"" + children[i].text.trim() + "\" between v-if and v-else(-if) " + "will be ignored.");
      }
      children.pop();
    }
  }
}

function addIfCondition(el, condition) {
  if (!el.ifConditions) {
    el.ifConditions = [];
  }
  el.ifConditions.push(condition);
}

function processOnce(el) {
  var once$$1 = getAndRemoveAttr(el, 'v-once');
  if (once$$1 != null) {
    el.once = true;
  }
}

function processSlot(el) {
  if (el.tag === 'slot') {
    el.slotName = getBindingAttr(el, 'name');
    if (false) {
      warn$2("`key` does not work on <slot> because slots are abstract outlets " + "and can possibly expand into multiple elements. " + "Use the key on a wrapping element instead.");
    }
  } else {
    var slotTarget = getBindingAttr(el, 'slot');
    if (slotTarget) {
      el.slotTarget = slotTarget === '""' ? '"default"' : slotTarget;
      // preserve slot as an attribute for native shadow DOM compat
      addAttr(el, 'slot', slotTarget);
    }
    if (el.tag === 'template') {
      el.slotScope = getAndRemoveAttr(el, 'scope');
    }
  }
}

function processComponent(el) {
  var binding;
  if (binding = getBindingAttr(el, 'is')) {
    el.component = binding;
  }
  if (getAndRemoveAttr(el, 'inline-template') != null) {
    el.inlineTemplate = true;
  }
}

function processAttrs(el) {
  var list = el.attrsList;
  var i, l, name, rawName, value, modifiers, isProp;
  for (i = 0, l = list.length; i < l; i++) {
    name = rawName = list[i].name;
    value = list[i].value;
    if (dirRE.test(name)) {
      // mark element as dynamic
      el.hasBindings = true;
      // modifiers
      modifiers = parseModifiers(name);
      if (modifiers) {
        name = name.replace(modifierRE, '');
      }
      if (bindRE.test(name)) {
        // v-bind
        name = name.replace(bindRE, '');
        value = parseFilters(value);
        isProp = false;
        if (modifiers) {
          if (modifiers.prop) {
            isProp = true;
            name = camelize(name);
            if (name === 'innerHtml') {
              name = 'innerHTML';
            }
          }
          if (modifiers.camel) {
            name = camelize(name);
          }
          if (modifiers.sync) {
            addHandler(el, "update:" + camelize(name), genAssignmentCode(value, "$event"));
          }
        }
        if (isProp || !el.component && platformMustUseProp(el.tag, el.attrsMap.type, name)) {
          addProp(el, name, value);
        } else {
          addAttr(el, name, value);
        }
      } else if (onRE.test(name)) {
        // v-on
        name = name.replace(onRE, '');
        addHandler(el, name, value, modifiers, false, warn$2);
      } else {
        // normal directives
        name = name.replace(dirRE, '');
        // parse arg
        var argMatch = name.match(argRE);
        var arg = argMatch && argMatch[1];
        if (arg) {
          name = name.slice(0, -(arg.length + 1));
        }
        addDirective(el, name, rawName, value, arg, modifiers);
        if (false) {
          checkForAliasModel(el, value);
        }
      }
    } else {
      // literal attribute
      if (false) {
        var expression = parseText(value, delimiters);
        if (expression) {
          warn$2(name + "=\"" + value + "\": " + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div id="{{ val }}">, use <div :id="val">.');
        }
      }
      addAttr(el, name, JSON.stringify(value));
    }
  }
}

function checkInFor(el) {
  var parent = el;
  while (parent) {
    if (parent.for !== undefined) {
      return true;
    }
    parent = parent.parent;
  }
  return false;
}

function parseModifiers(name) {
  var match = name.match(modifierRE);
  if (match) {
    var ret = {};
    match.forEach(function (m) {
      ret[m.slice(1)] = true;
    });
    return ret;
  }
}

function makeAttrsMap(attrs) {
  var map = {};
  for (var i = 0, l = attrs.length; i < l; i++) {
    if (false) {
      warn$2('duplicate attribute: ' + attrs[i].name);
    }
    map[attrs[i].name] = attrs[i].value;
  }
  return map;
}

// for script (e.g. type="x/template") or style, do not decode content
function isTextTag(el) {
  return el.tag === 'script' || el.tag === 'style';
}

function isForbiddenTag(el) {
  return el.tag === 'style' || el.tag === 'script' && (!el.attrsMap.type || el.attrsMap.type === 'text/javascript');
}

var ieNSBug = /^xmlns:NS\d+/;
var ieNSPrefix = /^NS\d+:/;

/* istanbul ignore next */
function guardIESVGBug(attrs) {
  var res = [];
  for (var i = 0; i < attrs.length; i++) {
    var attr = attrs[i];
    if (!ieNSBug.test(attr.name)) {
      attr.name = attr.name.replace(ieNSPrefix, '');
      res.push(attr);
    }
  }
  return res;
}

function checkForAliasModel(el, value) {
  var _el = el;
  while (_el) {
    if (_el.for && _el.alias === value) {
      warn$2("<" + el.tag + " v-model=\"" + value + "\">: " + "You are binding v-model directly to a v-for iteration alias. " + "This will not be able to modify the v-for source array because " + "writing to the alias is like modifying a function local variable. " + "Consider using an array of objects and use v-model on an object property instead.");
    }
    _el = _el.parent;
  }
}

/*  */

var isStaticKey;
var isPlatformReservedTag;

var genStaticKeysCached = cached(genStaticKeys$1);

/**
 * Goal of the optimizer: walk the generated template AST tree
 * and detect sub-trees that are purely static, i.e. parts of
 * the DOM that never needs to change.
 *
 * Once we detect these sub-trees, we can:
 *
 * 1. Hoist them into constants, so that we no longer need to
 *    create fresh nodes for them on each re-render;
 * 2. Completely skip them in the patching process.
 */
function optimize(root, options) {
  if (!root) {
    return;
  }
  isStaticKey = genStaticKeysCached(options.staticKeys || '');
  isPlatformReservedTag = options.isReservedTag || no;
  // first pass: mark all non-static nodes.
  markStatic$1(root);
  // second pass: mark static roots.
  markStaticRoots(root, false);
}

function genStaticKeys$1(keys) {
  return makeMap('type,tag,attrsList,attrsMap,plain,parent,children,attrs' + (keys ? ',' + keys : ''));
}

function markStatic$1(node) {
  node.static = isStatic(node);
  if (node.type === 1) {
    // do not make component slot content static. this avoids
    // 1. components not able to mutate slot nodes
    // 2. static slot content fails for hot-reloading
    if (!isPlatformReservedTag(node.tag) && node.tag !== 'slot' && node.attrsMap['inline-template'] == null) {
      return;
    }
    for (var i = 0, l = node.children.length; i < l; i++) {
      var child = node.children[i];
      markStatic$1(child);
      if (!child.static) {
        node.static = false;
      }
    }
    if (node.ifConditions) {
      for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {
        var block = node.ifConditions[i$1].block;
        markStatic$1(block);
        if (!block.static) {
          node.static = false;
        }
      }
    }
  }
}

function markStaticRoots(node, isInFor) {
  if (node.type === 1) {
    if (node.static || node.once) {
      node.staticInFor = isInFor;
    }
    // For a node to qualify as a static root, it should have children that
    // are not just static text. Otherwise the cost of hoisting out will
    // outweigh the benefits and it's better off to just always render it fresh.
    if (node.static && node.children.length && !(node.children.length === 1 && node.children[0].type === 3)) {
      node.staticRoot = true;
      return;
    } else {
      node.staticRoot = false;
    }
    if (node.children) {
      for (var i = 0, l = node.children.length; i < l; i++) {
        markStaticRoots(node.children[i], isInFor || !!node.for);
      }
    }
    if (node.ifConditions) {
      for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {
        markStaticRoots(node.ifConditions[i$1].block, isInFor);
      }
    }
  }
}

function isStatic(node) {
  if (node.type === 2) {
    // expression
    return false;
  }
  if (node.type === 3) {
    // text
    return true;
  }
  return !!(node.pre || !node.hasBindings && // no dynamic bindings
  !node.if && !node.for && // not v-if or v-for or v-else
  !isBuiltInTag(node.tag) && // not a built-in
  isPlatformReservedTag(node.tag) && // not a component
  !isDirectChildOfTemplateFor(node) && Object.keys(node).every(isStaticKey));
}

function isDirectChildOfTemplateFor(node) {
  while (node.parent) {
    node = node.parent;
    if (node.tag !== 'template') {
      return false;
    }
    if (node.for) {
      return true;
    }
  }
  return false;
}

/*  */

var fnExpRE = /^\s*([\w$_]+|\([^)]*?\))\s*=>|^function\s*\(/;
var simplePathRE = /^\s*[A-Za-z_$][\w$]*(?:\.[A-Za-z_$][\w$]*|\['.*?']|\[".*?"]|\[\d+]|\[[A-Za-z_$][\w$]*])*\s*$/;

// keyCode aliases
var keyCodes = {
  esc: 27,
  tab: 9,
  enter: 13,
  space: 32,
  up: 38,
  left: 37,
  right: 39,
  down: 40,
  'delete': [8, 46]
};

// #4868: modifiers that prevent the execution of the listener
// need to explicitly return null so that we can determine whether to remove
// the listener for .once
var genGuard = function (condition) {
  return "if(" + condition + ")return null;";
};

var modifierCode = {
  stop: '$event.stopPropagation();',
  prevent: '$event.preventDefault();',
  self: genGuard("$event.target !== $event.currentTarget"),
  ctrl: genGuard("!$event.ctrlKey"),
  shift: genGuard("!$event.shiftKey"),
  alt: genGuard("!$event.altKey"),
  meta: genGuard("!$event.metaKey"),
  left: genGuard("'button' in $event && $event.button !== 0"),
  middle: genGuard("'button' in $event && $event.button !== 1"),
  right: genGuard("'button' in $event && $event.button !== 2")
};

function genHandlers(events, isNative, warn) {
  var res = isNative ? 'nativeOn:{' : 'on:{';
  for (var name in events) {
    var handler = events[name];
    // #5330: warn click.right, since right clicks do not actually fire click events.
    if (false) {
      warn("Use \"contextmenu\" instead of \"click.right\" since right clicks " + "do not actually fire \"click\" events.");
    }
    res += "\"" + name + "\":" + genHandler(name, handler) + ",";
  }
  return res.slice(0, -1) + '}';
}

function genHandler(name, handler) {
  if (!handler) {
    return 'function(){}';
  }

  if (Array.isArray(handler)) {
    return "[" + handler.map(function (handler) {
      return genHandler(name, handler);
    }).join(',') + "]";
  }

  var isMethodPath = simplePathRE.test(handler.value);
  var isFunctionExpression = fnExpRE.test(handler.value);

  if (!handler.modifiers) {
    return isMethodPath || isFunctionExpression ? handler.value : "function($event){" + handler.value + "}"; // inline statement
  } else {
    var code = '';
    var genModifierCode = '';
    var keys = [];
    for (var key in handler.modifiers) {
      if (modifierCode[key]) {
        genModifierCode += modifierCode[key];
        // left/right
        if (keyCodes[key]) {
          keys.push(key);
        }
      } else {
        keys.push(key);
      }
    }
    if (keys.length) {
      code += genKeyFilter(keys);
    }
    // Make sure modifiers like prevent and stop get executed after key filtering
    if (genModifierCode) {
      code += genModifierCode;
    }
    var handlerCode = isMethodPath ? handler.value + '($event)' : isFunctionExpression ? "(" + handler.value + ")($event)" : handler.value;
    return "function($event){" + code + handlerCode + "}";
  }
}

function genKeyFilter(keys) {
  return "if(!('button' in $event)&&" + keys.map(genFilterCode).join('&&') + ")return null;";
}

function genFilterCode(key) {
  var keyVal = parseInt(key, 10);
  if (keyVal) {
    return "$event.keyCode!==" + keyVal;
  }
  var alias = keyCodes[key];
  return "_k($event.keyCode," + JSON.stringify(key) + (alias ? ',' + JSON.stringify(alias) : '') + ")";
}

/*  */

function on(el, dir) {
  if (false) {
    warn("v-on without argument does not support modifiers.");
  }
  el.wrapListeners = function (code) {
    return "_g(" + code + "," + dir.value + ")";
  };
}

/*  */

function bind$1(el, dir) {
  el.wrapData = function (code) {
    return "_b(" + code + ",'" + el.tag + "'," + dir.value + "," + (dir.modifiers && dir.modifiers.prop ? 'true' : 'false') + (dir.modifiers && dir.modifiers.sync ? ',true' : '') + ")";
  };
}

/*  */

var baseDirectives = {
  on: on,
  bind: bind$1,
  cloak: noop
};

/*  */

var CodegenState = function CodegenState(options) {
  this.options = options;
  this.warn = options.warn || baseWarn;
  this.transforms = pluckModuleFunction(options.modules, 'transformCode');
  this.dataGenFns = pluckModuleFunction(options.modules, 'genData');
  this.directives = extend(extend({}, baseDirectives), options.directives);
  var isReservedTag = options.isReservedTag || no;
  this.maybeComponent = function (el) {
    return !isReservedTag(el.tag);
  };
  this.onceId = 0;
  this.staticRenderFns = [];
};

function generate(ast, options) {
  var state = new CodegenState(options);
  var code = ast ? genElement(ast, state) : '_c("div")';
  return {
    render: "with(this){return " + code + "}",
    staticRenderFns: state.staticRenderFns
  };
}

function genElement(el, state) {
  if (el.staticRoot && !el.staticProcessed) {
    return genStatic(el, state);
  } else if (el.once && !el.onceProcessed) {
    return genOnce(el, state);
  } else if (el.for && !el.forProcessed) {
    return genFor(el, state);
  } else if (el.if && !el.ifProcessed) {
    return genIf(el, state);
  } else if (el.tag === 'template' && !el.slotTarget) {
    return genChildren(el, state) || 'void 0';
  } else if (el.tag === 'slot') {
    return genSlot(el, state);
  } else {
    // component or element
    var code;
    if (el.component) {
      code = genComponent(el.component, el, state);
    } else {
      var data = el.plain ? undefined : genData$2(el, state);

      var children = el.inlineTemplate ? null : genChildren(el, state, true);
      code = "_c('" + el.tag + "'" + (data ? "," + data : '') + (children ? "," + children : '') + ")";
    }
    // module transforms
    for (var i = 0; i < state.transforms.length; i++) {
      code = state.transforms[i](el, code);
    }
    return code;
  }
}

// hoist static sub-trees out
function genStatic(el, state) {
  el.staticProcessed = true;
  state.staticRenderFns.push("with(this){return " + genElement(el, state) + "}");
  return "_m(" + (state.staticRenderFns.length - 1) + (el.staticInFor ? ',true' : '') + ")";
}

// v-once
function genOnce(el, state) {
  el.onceProcessed = true;
  if (el.if && !el.ifProcessed) {
    return genIf(el, state);
  } else if (el.staticInFor) {
    var key = '';
    var parent = el.parent;
    while (parent) {
      if (parent.for) {
        key = parent.key;
        break;
      }
      parent = parent.parent;
    }
    if (!key) {
      "production" !== 'production' && state.warn("v-once can only be used inside v-for that is keyed. ");
      return genElement(el, state);
    }
    return "_o(" + genElement(el, state) + "," + state.onceId++ + "," + key + ")";
  } else {
    return genStatic(el, state);
  }
}

function genIf(el, state, altGen, altEmpty) {
  el.ifProcessed = true; // avoid recursion
  return genIfConditions(el.ifConditions.slice(), state, altGen, altEmpty);
}

function genIfConditions(conditions, state, altGen, altEmpty) {
  if (!conditions.length) {
    return altEmpty || '_e()';
  }

  var condition = conditions.shift();
  if (condition.exp) {
    return "(" + condition.exp + ")?" + genTernaryExp(condition.block) + ":" + genIfConditions(conditions, state, altGen, altEmpty);
  } else {
    return "" + genTernaryExp(condition.block);
  }

  // v-if with v-once should generate code like (a)?_m(0):_m(1)
  function genTernaryExp(el) {
    return altGen ? altGen(el, state) : el.once ? genOnce(el, state) : genElement(el, state);
  }
}

function genFor(el, state, altGen, altHelper) {
  var exp = el.for;
  var alias = el.alias;
  var iterator1 = el.iterator1 ? "," + el.iterator1 : '';
  var iterator2 = el.iterator2 ? "," + el.iterator2 : '';

  if (false) {
    state.warn("<" + el.tag + " v-for=\"" + alias + " in " + exp + "\">: component lists rendered with " + "v-for should have explicit keys. " + "See https://vuejs.org/guide/list.html#key for more info.", true /* tip */
    );
  }

  el.forProcessed = true; // avoid recursion
  return (altHelper || '_l') + "((" + exp + ")," + "function(" + alias + iterator1 + iterator2 + "){" + "return " + (altGen || genElement)(el, state) + '})';
}

function genData$2(el, state) {
  var data = '{';

  // directives first.
  // directives may mutate the el's other properties before they are generated.
  var dirs = genDirectives(el, state);
  if (dirs) {
    data += dirs + ',';
  }

  // key
  if (el.key) {
    data += "key:" + el.key + ",";
  }
  // ref
  if (el.ref) {
    data += "ref:" + el.ref + ",";
  }
  if (el.refInFor) {
    data += "refInFor:true,";
  }
  // pre
  if (el.pre) {
    data += "pre:true,";
  }
  // record original tag name for components using "is" attribute
  if (el.component) {
    data += "tag:\"" + el.tag + "\",";
  }
  // module data generation functions
  for (var i = 0; i < state.dataGenFns.length; i++) {
    data += state.dataGenFns[i](el);
  }
  // attributes
  if (el.attrs) {
    data += "attrs:{" + genProps(el.attrs) + "},";
  }
  // DOM props
  if (el.props) {
    data += "domProps:{" + genProps(el.props) + "},";
  }
  // event handlers
  if (el.events) {
    data += genHandlers(el.events, false, state.warn) + ",";
  }
  if (el.nativeEvents) {
    data += genHandlers(el.nativeEvents, true, state.warn) + ",";
  }
  // slot target
  if (el.slotTarget) {
    data += "slot:" + el.slotTarget + ",";
  }
  // scoped slots
  if (el.scopedSlots) {
    data += genScopedSlots(el.scopedSlots, state) + ",";
  }
  // component v-model
  if (el.model) {
    data += "model:{value:" + el.model.value + ",callback:" + el.model.callback + ",expression:" + el.model.expression + "},";
  }
  // inline-template
  if (el.inlineTemplate) {
    var inlineTemplate = genInlineTemplate(el, state);
    if (inlineTemplate) {
      data += inlineTemplate + ",";
    }
  }
  data = data.replace(/,$/, '') + '}';
  // v-bind data wrap
  if (el.wrapData) {
    data = el.wrapData(data);
  }
  // v-on data wrap
  if (el.wrapListeners) {
    data = el.wrapListeners(data);
  }
  return data;
}

function genDirectives(el, state) {
  var dirs = el.directives;
  if (!dirs) {
    return;
  }
  var res = 'directives:[';
  var hasRuntime = false;
  var i, l, dir, needRuntime;
  for (i = 0, l = dirs.length; i < l; i++) {
    dir = dirs[i];
    needRuntime = true;
    var gen = state.directives[dir.name];
    if (gen) {
      // compile-time directive that manipulates AST.
      // returns true if it also needs a runtime counterpart.
      needRuntime = !!gen(el, dir, state.warn);
    }
    if (needRuntime) {
      hasRuntime = true;
      res += "{name:\"" + dir.name + "\",rawName:\"" + dir.rawName + "\"" + (dir.value ? ",value:(" + dir.value + "),expression:" + JSON.stringify(dir.value) : '') + (dir.arg ? ",arg:\"" + dir.arg + "\"" : '') + (dir.modifiers ? ",modifiers:" + JSON.stringify(dir.modifiers) : '') + "},";
    }
  }
  if (hasRuntime) {
    return res.slice(0, -1) + ']';
  }
}

function genInlineTemplate(el, state) {
  var ast = el.children[0];
  if (false) {
    state.warn('Inline-template components must have exactly one child element.');
  }
  if (ast.type === 1) {
    var inlineRenderFns = generate(ast, state.options);
    return "inlineTemplate:{render:function(){" + inlineRenderFns.render + "},staticRenderFns:[" + inlineRenderFns.staticRenderFns.map(function (code) {
      return "function(){" + code + "}";
    }).join(',') + "]}";
  }
}

function genScopedSlots(slots, state) {
  return "scopedSlots:_u([" + Object.keys(slots).map(function (key) {
    return genScopedSlot(key, slots[key], state);
  }).join(',') + "])";
}

function genScopedSlot(key, el, state) {
  if (el.for && !el.forProcessed) {
    return genForScopedSlot(key, el, state);
  }
  return "{key:" + key + ",fn:function(" + String(el.attrsMap.scope) + "){" + "return " + (el.tag === 'template' ? genChildren(el, state) || 'void 0' : genElement(el, state)) + "}}";
}

function genForScopedSlot(key, el, state) {
  var exp = el.for;
  var alias = el.alias;
  var iterator1 = el.iterator1 ? "," + el.iterator1 : '';
  var iterator2 = el.iterator2 ? "," + el.iterator2 : '';
  el.forProcessed = true; // avoid recursion
  return "_l((" + exp + ")," + "function(" + alias + iterator1 + iterator2 + "){" + "return " + genScopedSlot(key, el, state) + '})';
}

function genChildren(el, state, checkSkip, altGenElement, altGenNode) {
  var children = el.children;
  if (children.length) {
    var el$1 = children[0];
    // optimize single v-for
    if (children.length === 1 && el$1.for && el$1.tag !== 'template' && el$1.tag !== 'slot') {
      return (altGenElement || genElement)(el$1, state);
    }
    var normalizationType = checkSkip ? getNormalizationType(children, state.maybeComponent) : 0;
    var gen = altGenNode || genNode;
    return "[" + children.map(function (c) {
      return gen(c, state);
    }).join(',') + "]" + (normalizationType ? "," + normalizationType : '');
  }
}

// determine the normalization needed for the children array.
// 0: no normalization needed
// 1: simple normalization needed (possible 1-level deep nested array)
// 2: full normalization needed
function getNormalizationType(children, maybeComponent) {
  var res = 0;
  for (var i = 0; i < children.length; i++) {
    var el = children[i];
    if (el.type !== 1) {
      continue;
    }
    if (needsNormalization(el) || el.ifConditions && el.ifConditions.some(function (c) {
      return needsNormalization(c.block);
    })) {
      res = 2;
      break;
    }
    if (maybeComponent(el) || el.ifConditions && el.ifConditions.some(function (c) {
      return maybeComponent(c.block);
    })) {
      res = 1;
    }
  }
  return res;
}

function needsNormalization(el) {
  return el.for !== undefined || el.tag === 'template' || el.tag === 'slot';
}

function genNode(node, state) {
  if (node.type === 1) {
    return genElement(node, state);
  }if (node.type === 3 && node.isComment) {
    return genComment(node);
  } else {
    return genText(node);
  }
}

function genText(text) {
  return "_v(" + (text.type === 2 ? text.expression // no need for () because already wrapped in _s()
  : transformSpecialNewlines(JSON.stringify(text.text))) + ")";
}

function genComment(comment) {
  return "_e(" + JSON.stringify(comment.text) + ")";
}

function genSlot(el, state) {
  var slotName = el.slotName || '"default"';
  var children = genChildren(el, state);
  var res = "_t(" + slotName + (children ? "," + children : '');
  var attrs = el.attrs && "{" + el.attrs.map(function (a) {
    return camelize(a.name) + ":" + a.value;
  }).join(',') + "}";
  var bind$$1 = el.attrsMap['v-bind'];
  if ((attrs || bind$$1) && !children) {
    res += ",null";
  }
  if (attrs) {
    res += "," + attrs;
  }
  if (bind$$1) {
    res += (attrs ? '' : ',null') + "," + bind$$1;
  }
  return res + ')';
}

// componentName is el.component, take it as argument to shun flow's pessimistic refinement
function genComponent(componentName, el, state) {
  var children = el.inlineTemplate ? null : genChildren(el, state, true);
  return "_c(" + componentName + "," + genData$2(el, state) + (children ? "," + children : '') + ")";
}

function genProps(props) {
  var res = '';
  for (var i = 0; i < props.length; i++) {
    var prop = props[i];
    res += "\"" + prop.name + "\":" + transformSpecialNewlines(prop.value) + ",";
  }
  return res.slice(0, -1);
}

// #3895, #4268
function transformSpecialNewlines(text) {
  return text.replace(/\u2028/g, '\\u2028').replace(/\u2029/g, '\\u2029');
}

/*  */

// these keywords should not appear inside expressions, but operators like
// typeof, instanceof and in are allowed
var prohibitedKeywordRE = new RegExp('\\b' + ('do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' + 'super,throw,while,yield,delete,export,import,return,switch,default,' + 'extends,finally,continue,debugger,function,arguments').split(',').join('\\b|\\b') + '\\b');

// these unary operators should not be used as property/method names
var unaryOperatorsRE = new RegExp('\\b' + 'delete,typeof,void'.split(',').join('\\s*\\([^\\)]*\\)|\\b') + '\\s*\\([^\\)]*\\)');

// check valid identifier for v-for
var identRE = /[A-Za-z_$][\w$]*/;

// strip strings in expressions
var stripStringRE = /'(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*"|`(?:[^`\\]|\\.)*\$\{|\}(?:[^`\\]|\\.)*`|`(?:[^`\\]|\\.)*`/g;

// detect problematic expressions in a template
function detectErrors(ast) {
  var errors = [];
  if (ast) {
    checkNode(ast, errors);
  }
  return errors;
}

function checkNode(node, errors) {
  if (node.type === 1) {
    for (var name in node.attrsMap) {
      if (dirRE.test(name)) {
        var value = node.attrsMap[name];
        if (value) {
          if (name === 'v-for') {
            checkFor(node, "v-for=\"" + value + "\"", errors);
          } else if (onRE.test(name)) {
            checkEvent(value, name + "=\"" + value + "\"", errors);
          } else {
            checkExpression(value, name + "=\"" + value + "\"", errors);
          }
        }
      }
    }
    if (node.children) {
      for (var i = 0; i < node.children.length; i++) {
        checkNode(node.children[i], errors);
      }
    }
  } else if (node.type === 2) {
    checkExpression(node.expression, node.text, errors);
  }
}

function checkEvent(exp, text, errors) {
  var stipped = exp.replace(stripStringRE, '');
  var keywordMatch = stipped.match(unaryOperatorsRE);
  if (keywordMatch && stipped.charAt(keywordMatch.index - 1) !== '$') {
    errors.push("avoid using JavaScript unary operator as property name: " + "\"" + keywordMatch[0] + "\" in expression " + text.trim());
  }
  checkExpression(exp, text, errors);
}

function checkFor(node, text, errors) {
  checkExpression(node.for || '', text, errors);
  checkIdentifier(node.alias, 'v-for alias', text, errors);
  checkIdentifier(node.iterator1, 'v-for iterator', text, errors);
  checkIdentifier(node.iterator2, 'v-for iterator', text, errors);
}

function checkIdentifier(ident, type, text, errors) {
  if (typeof ident === 'string' && !identRE.test(ident)) {
    errors.push("invalid " + type + " \"" + ident + "\" in expression: " + text.trim());
  }
}

function checkExpression(exp, text, errors) {
  try {
    new Function("return " + exp);
  } catch (e) {
    var keywordMatch = exp.replace(stripStringRE, '').match(prohibitedKeywordRE);
    if (keywordMatch) {
      errors.push("avoid using JavaScript keyword as property name: " + "\"" + keywordMatch[0] + "\" in expression " + text.trim());
    } else {
      errors.push("invalid expression: " + text.trim());
    }
  }
}

/*  */

function createFunction(code, errors) {
  try {
    return new Function(code);
  } catch (err) {
    errors.push({ err: err, code: code });
    return noop;
  }
}

function createCompileToFunctionFn(compile) {
  var cache = Object.create(null);

  return function compileToFunctions(template, options, vm) {
    options = options || {};

    /* istanbul ignore if */
    if (false) {
      // detect possible CSP restriction
      try {
        new Function('return 1');
      } catch (e) {
        if (e.toString().match(/unsafe-eval|CSP/)) {
          warn('It seems you are using the standalone build of Vue.js in an ' + 'environment with Content Security Policy that prohibits unsafe-eval. ' + 'The template compiler cannot work in this environment. Consider ' + 'relaxing the policy to allow unsafe-eval or pre-compiling your ' + 'templates into render functions.');
        }
      }
    }

    // check cache
    var key = options.delimiters ? String(options.delimiters) + template : template;
    if (cache[key]) {
      return cache[key];
    }

    // compile
    var compiled = compile(template, options);

    // check compilation errors/tips
    if (false) {
      if (compiled.errors && compiled.errors.length) {
        warn("Error compiling template:\n\n" + template + "\n\n" + compiled.errors.map(function (e) {
          return "- " + e;
        }).join('\n') + '\n', vm);
      }
      if (compiled.tips && compiled.tips.length) {
        compiled.tips.forEach(function (msg) {
          return tip(msg, vm);
        });
      }
    }

    // turn code into functions
    var res = {};
    var fnGenErrors = [];
    res.render = createFunction(compiled.render, fnGenErrors);
    res.staticRenderFns = compiled.staticRenderFns.map(function (code) {
      return createFunction(code, fnGenErrors);
    });

    // check function generation errors.
    // this should only happen if there is a bug in the compiler itself.
    // mostly for codegen development use
    /* istanbul ignore if */
    if (false) {
      if ((!compiled.errors || !compiled.errors.length) && fnGenErrors.length) {
        warn("Failed to generate render function:\n\n" + fnGenErrors.map(function (ref) {
          var err = ref.err;
          var code = ref.code;

          return err.toString() + " in\n\n" + code + "\n";
        }).join('\n'), vm);
      }
    }

    return cache[key] = res;
  };
}

/*  */

function createCompilerCreator(baseCompile) {
  return function createCompiler(baseOptions) {
    function compile(template, options) {
      var finalOptions = Object.create(baseOptions);
      var errors = [];
      var tips = [];
      finalOptions.warn = function (msg, tip) {
        (tip ? tips : errors).push(msg);
      };

      if (options) {
        // merge custom modules
        if (options.modules) {
          finalOptions.modules = (baseOptions.modules || []).concat(options.modules);
        }
        // merge custom directives
        if (options.directives) {
          finalOptions.directives = extend(Object.create(baseOptions.directives), options.directives);
        }
        // copy other options
        for (var key in options) {
          if (key !== 'modules' && key !== 'directives') {
            finalOptions[key] = options[key];
          }
        }
      }

      var compiled = baseCompile(template, finalOptions);
      if (false) {
        errors.push.apply(errors, detectErrors(compiled.ast));
      }
      compiled.errors = errors;
      compiled.tips = tips;
      return compiled;
    }

    return {
      compile: compile,
      compileToFunctions: createCompileToFunctionFn(compile)
    };
  };
}

/*  */

// `createCompilerCreator` allows creating compilers that use alternative
// parser/optimizer/codegen, e.g the SSR optimizing compiler.
// Here we just export a default compiler using the default parts.
var createCompiler = createCompilerCreator(function baseCompile(template, options) {
  var ast = parse(template.trim(), options);
  optimize(ast, options);
  var code = generate(ast, options);
  return {
    ast: ast,
    render: code.render,
    staticRenderFns: code.staticRenderFns
  };
});

/*  */

var ref$1 = createCompiler(baseOptions);
var compileToFunctions = ref$1.compileToFunctions;

/*  */

var idToTemplate = cached(function (id) {
  var el = query(id);
  return el && el.innerHTML;
});

var mount = Vue$3.prototype.$mount;
Vue$3.prototype.$mount = function (el, hydrating) {
  el = el && query(el);

  /* istanbul ignore if */
  if (el === document.body || el === document.documentElement) {
    "production" !== 'production' && warn("Do not mount Vue to <html> or <body> - mount to normal elements instead.");
    return this;
  }

  var options = this.$options;
  // resolve template/el and convert to render function
  if (!options.render) {
    var template = options.template;
    if (template) {
      if (typeof template === 'string') {
        if (template.charAt(0) === '#') {
          template = idToTemplate(template);
          /* istanbul ignore if */
          if (false) {
            warn("Template element not found or is empty: " + options.template, this);
          }
        }
      } else if (template.nodeType) {
        template = template.innerHTML;
      } else {
        if (false) {
          warn('invalid template option:' + template, this);
        }
        return this;
      }
    } else if (el) {
      template = getOuterHTML(el);
    }
    if (template) {
      /* istanbul ignore if */
      if (false) {
        mark('compile');
      }

      var ref = compileToFunctions(template, {
        shouldDecodeNewlines: shouldDecodeNewlines,
        delimiters: options.delimiters,
        comments: options.comments
      }, this);
      var render = ref.render;
      var staticRenderFns = ref.staticRenderFns;
      options.render = render;
      options.staticRenderFns = staticRenderFns;

      /* istanbul ignore if */
      if (false) {
        mark('compile end');
        measure(this._name + " compile", 'compile', 'compile end');
      }
    }
  }
  return mount.call(this, el, hydrating);
};

/**
 * Get outerHTML of elements, taking care
 * of SVG elements in IE as well.
 */
function getOuterHTML(el) {
  if (el.outerHTML) {
    return el.outerHTML;
  } else {
    var container = document.createElement('div');
    container.appendChild(el.cloneNode(true));
    return container.innerHTML;
  }
}

Vue$3.compile = compileToFunctions;

module.exports = Vue$3;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 6 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
  * vue-custom-element v1.3.0
  * (c) 2017 Karol Fabjaczuk
  * @license MIT
  */
/**
 * ES6 Object.getPrototypeOf Polyfill
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf
 */

Object.setPrototypeOf = Object.setPrototypeOf || setPrototypeOf;

function setPrototypeOf(obj, proto) {
  obj.__proto__ = proto;
  return obj;
}

var index = setPrototypeOf.bind(Object);

function isES2015() {
  if (typeof Symbol === 'undefined' || typeof Reflect === 'undefined') return false;

  return true;
}

var isES2015$1 = isES2015();

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && (typeof call === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

function _CustomElement() {
  return Reflect.construct(HTMLElement, [], this.__proto__.constructor);
}

Object.setPrototypeOf(_CustomElement.prototype, HTMLElement.prototype);
Object.setPrototypeOf(_CustomElement, HTMLElement);
function registerCustomElement(tag) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (typeof customElements === 'undefined') {
    return;
  }

  function constructorCallback() {
    if (options.shadow === true && HTMLElement.prototype.attachShadow) {
      this.attachShadow({ mode: 'open' });
    }
    typeof options.constructorCallback === 'function' && options.constructorCallback.call(this);
  }
  function connectedCallback() {
    typeof options.connectedCallback === 'function' && options.connectedCallback.call(this);
  }

  function disconnectedCallback() {
    typeof options.disconnectedCallback === 'function' && options.disconnectedCallback.call(this);
  }

  function attributeChangedCallback(name, oldValue, value) {
    typeof options.attributeChangedCallback === 'function' && options.attributeChangedCallback.call(this, name, oldValue, value);
  }

  if (isES2015$1) {
    var CustomElement = function (_CustomElement2) {
      _inherits(CustomElement, _CustomElement2);

      function CustomElement(self) {
        var _ret;

        _classCallCheck(this, CustomElement);

        var _this = _possibleConstructorReturn(this, (CustomElement.__proto__ || Object.getPrototypeOf(CustomElement)).call(this));

        var me = self ? HTMLElement.call(self) : _this;

        constructorCallback.call(me);
        return _ret = me, _possibleConstructorReturn(_this, _ret);
      }

      _createClass(CustomElement, null, [{
        key: 'observedAttributes',
        get: function get() {
          return options.observedAttributes || [];
        }
      }]);

      return CustomElement;
    }(_CustomElement);

    CustomElement.prototype.connectedCallback = connectedCallback;
    CustomElement.prototype.disconnectedCallback = disconnectedCallback;
    CustomElement.prototype.attributeChangedCallback = attributeChangedCallback;

    customElements.define(tag, CustomElement);
    return CustomElement;
  } else {
    var _CustomElement3 = function _CustomElement3(self) {
      var me = self ? HTMLElement.call(self) : this;

      constructorCallback.call(me);
      return me;
    };

    _CustomElement3.observedAttributes = options.observedAttributes || [];

    _CustomElement3.prototype = Object.create(HTMLElement.prototype, {
      constructor: {
        configurable: true,
        writable: true,
        value: _CustomElement3
      }
    });

    _CustomElement3.prototype.connectedCallback = connectedCallback;
    _CustomElement3.prototype.disconnectedCallback = disconnectedCallback;
    _CustomElement3.prototype.attributeChangedCallback = attributeChangedCallback;

    customElements.define(tag, _CustomElement3);
    return _CustomElement3;
  }
}

var camelizeRE = /-(\w)/g;
var camelize = function camelize(str) {
  return str.replace(camelizeRE, function (_, c) {
    return c ? c.toUpperCase() : '';
  });
};
var hyphenateRE = /([^-])([A-Z])/g;
var hyphenate = function hyphenate(str) {
  return str.replace(hyphenateRE, '$1-$2').replace(hyphenateRE, '$1-$2').toLowerCase();
};

function toArray(list) {
  var start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

  var i = list.length - start;
  var ret = new Array(i);
  while (i--) {
    ret[i] = list[i + start];
  }
  return ret;
}

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};

function convertAttributeValue(value) {
  var propsValue = value;
  var isBoolean = ['true', 'false'].indexOf(value) > -1;
  var valueParsed = parseFloat(propsValue, 10);
  var isNumber = !isNaN(valueParsed) && isFinite(propsValue);

  if (isBoolean) {
    propsValue = propsValue === 'true';
  } else if (isNumber) {
    propsValue = valueParsed;
  }

  return propsValue;
}

function extractProps(collection, props) {
  if (collection && collection.length) {
    collection.forEach(function (prop) {
      var camelCaseProp = camelize(prop);
      props.camelCase.indexOf(camelCaseProp) === -1 && props.camelCase.push(camelCaseProp);
    });
  } else if (collection && (typeof collection === 'undefined' ? 'undefined' : _typeof(collection)) === 'object') {
    for (var prop in collection) {
      var camelCaseProp = camelize(prop);
      props.camelCase.indexOf(camelCaseProp) === -1 && props.camelCase.push(camelCaseProp);
    }
  }
}

function getProps() {
  var componentDefinition = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var props = {
    camelCase: [],
    hyphenate: []
  };

  if (componentDefinition.mixins) {
    componentDefinition.mixins.forEach(function (mixin) {
      extractProps(mixin.props, props);
    });
  }

  if (componentDefinition.extends && componentDefinition.extends.props) {
    var parentProps = componentDefinition.extends.props;

    extractProps(parentProps, props);
  }

  extractProps(componentDefinition.props, props);

  props.camelCase.forEach(function (prop) {
    props.hyphenate.push(hyphenate(prop));
  });

  return props;
}

function reactiveProps(element, props) {
  props.camelCase.forEach(function (name, index) {
    Object.defineProperty(element, name, {
      get: function get() {
        return this.__vue_custom_element__[name];
      },
      set: function set(value) {
        if (((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' || typeof value === 'function') && this.__vue_custom_element__) {
          var propName = props.camelCase[index];
          this.__vue_custom_element__[propName] = value;
        } else {
          this.setAttribute(props.hyphenate[index], convertAttributeValue(value));
        }
      }
    });
  });
}

function getPropsData(element, componentDefinition, props) {
  var propsData = componentDefinition.propsData || {};

  props.hyphenate.forEach(function (name, index) {
    var value = element.attributes[name] && element.attributes[name].nodeValue;

    if (value !== undefined && value !== '') {
      propsData[props.camelCase[index]] = convertAttributeValue(value);
    }
  });

  return propsData;
}

function getAttributes(children) {
  var attributes = {};

  toArray(children.attributes).forEach(function (attribute) {
    attributes[attribute.nodeName === 'vue-slot' ? 'slot' : attribute.nodeName] = attribute.nodeValue;
  });

  return attributes;
}

function getSlots() {
  var children = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var createElement = arguments[1];

  var slots = [];
  toArray(children).forEach(function (child) {
    if (child.nodeName === '#text') {
      if (child.nodeValue.trim()) {
        slots.push(createElement('span', child.nodeValue));
      }
    } else {
      var attributes = getAttributes(child);
      var elementOptions = {
        attrs: attributes,
        domProps: {
          innerHTML: child.innerHTML
        }
      };

      if (attributes.slot) {
        elementOptions.slot = attributes.slot;
        attributes.slot = undefined;
      }

      slots.push(createElement(child.tagName, elementOptions));
    }
  });

  return slots;
}

function customEvent(eventName, detail) {
  var params = { bubbles: false, cancelable: false, detail: detail };
  var event = void 0;
  if (typeof window.CustomEvent === 'function') {
    event = new CustomEvent(eventName, params);
  } else {
    event = document.createEvent('CustomEvent');
    event.initCustomEvent(eventName, params.bubbles, params.cancelable, params.detail);
  }
  return event;
}

function customEmit(element, eventName) {
  for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    args[_key - 2] = arguments[_key];
  }

  var event = customEvent(eventName, [].concat(args));
  element.dispatchEvent(event);
}

function createVueInstance(element, Vue, componentDefinition, props, options) {
  if (!element.__vue_custom_element__) {
    var ComponentDefinition = Vue.util.extend({}, componentDefinition);
    var propsData = getPropsData(element, ComponentDefinition, props);
    var vueVersion = Vue.version && parseInt(Vue.version.split('.')[0], 10) || 0;

    var ctorOptions = {};
    if (ComponentDefinition._Ctor) {
      ctorOptions = ComponentDefinition._Ctor[0].options;
    }
    ComponentDefinition.methods = ctorOptions.methods = ComponentDefinition.methods || {};
    ComponentDefinition.methods.$emit = ctorOptions.methods.$emit = function emit() {
      var _proto__$$emit;

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      customEmit.apply(undefined, [element].concat(args));
      this.__proto__ && (_proto__$$emit = this.__proto__.$emit).call.apply(_proto__$$emit, [this].concat(args));
    };

    var rootElement = void 0;

    if (vueVersion >= 2) {
      var elementOriginalChildren = element.cloneNode(true).childNodes;
      rootElement = {
        propsData: propsData,
        props: props.camelCase,
        computed: {
          reactiveProps: function reactiveProps$$1() {
            var _this = this;

            var reactivePropsList = {};
            props.camelCase.forEach(function (prop) {
              reactivePropsList[prop] = _this[prop];
            });

            return reactivePropsList;
          }
        },
        render: function render(createElement) {
          var data = {
            props: this.reactiveProps
          };

          return createElement(ComponentDefinition, data, getSlots(elementOriginalChildren, createElement));
        }
      };
    } else if (vueVersion === 1) {
      rootElement = ComponentDefinition;
      rootElement.propsData = propsData;
    } else {
      rootElement = ComponentDefinition;
      var propsWithDefault = {};
      Object.keys(propsData).forEach(function (prop) {
        propsWithDefault[prop] = { default: propsData[prop] };
      });
      rootElement.props = propsWithDefault;
    }

    var elementInnerHtml = vueVersion >= 2 ? '<div></div>' : ('<div>' + element.innerHTML + '</div>').replace(/vue-slot=/g, 'slot=');
    if (options.shadow && element.shadowRoot) {
      element.shadowRoot.innerHTML = elementInnerHtml;
      rootElement.el = element.shadowRoot.children[0];
    } else {
      element.innerHTML = elementInnerHtml;
      rootElement.el = element.children[0];
    }

    reactiveProps(element, props);

    element.__vue_custom_element__ = new Vue(rootElement);
    if (options.shadow && options.shadowCss && element.shadowRoot) {
      var style = document.createElement('style');
      style.type = 'text/css';
      style.appendChild(document.createTextNode(options.shadowCss));

      element.shadowRoot.appendChild(style);
    }
    element.removeAttribute('vce-cloak');
    element.setAttribute('vce-ready', '');
    customEmit(element, 'vce-ready');
  }
}

function install(Vue) {
  Vue.customElement = function vueCustomElement(tag, componentDefinition) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    var isAsyncComponent = typeof componentDefinition === 'function';
    var optionsProps = isAsyncComponent && { props: options.props || [] };
    var props = getProps(isAsyncComponent ? optionsProps : componentDefinition);

    var CustomElement = registerCustomElement(tag, {
      constructorCallback: function constructorCallback() {
        typeof options.constructorCallback === 'function' && options.constructorCallback.call(this);
      },
      connectedCallback: function connectedCallback() {
        var _this = this;

        var asyncComponentPromise = isAsyncComponent && componentDefinition();
        var isAsyncComponentPromise = asyncComponentPromise && asyncComponentPromise.then && typeof asyncComponentPromise.then === 'function';

        if (isAsyncComponent && !isAsyncComponentPromise) {
          throw new Error('Async component ' + tag + ' do not returns Promise');
        }
        if (!this.__detached__) {
          if (isAsyncComponentPromise) {
            asyncComponentPromise.then(function (lazyLoadedComponent) {
              var lazyLoadedComponentProps = getProps(lazyLoadedComponent);
              createVueInstance(_this, Vue, lazyLoadedComponent, lazyLoadedComponentProps, options);
            });
          } else {
            createVueInstance(this, Vue, componentDefinition, props, options);
          }
        }

        this.__detached__ = false;
      },
      disconnectedCallback: function disconnectedCallback() {
        var _this2 = this;

        this.__detached__ = true;
        typeof options.disconnectedCallback === 'function' && options.disconnectedCallback.call(this);

        setTimeout(function () {
          if (_this2.__detached__ && _this2.__vue_custom_element__) {
            _this2.__vue_custom_element__.$destroy(true);
          }
        }, options.destroyTimeout || 3000);
      },
      attributeChangedCallback: function attributeChangedCallback(name, oldValue, value) {
        if (this.__vue_custom_element__ && typeof value !== 'undefined') {
          var nameCamelCase = camelize(name);
          typeof options.attributeChangedCallback === 'function' && options.attributeChangedCallback.call(this, name, oldValue, value);
          this.__vue_custom_element__[nameCamelCase] = convertAttributeValue(value);
        }
      },

      observedAttributes: props.hyphenate,

      shadow: !!options.shadow && !!HTMLElement.prototype.attachShadow
    });

    return CustomElement;
  };
}

if (typeof window !== 'undefined' && window.Vue) {
  window.Vue.use(install);
  if (install.installed) {
    install.installed = false;
  }
}

/* harmony default export */ __webpack_exports__["a"] = (install);

/***/ }),
/* 7 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_App_vue__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_65f85edc_hasScoped_false_node_modules_vue_loader_lib_selector_type_template_index_0_App_vue__ = __webpack_require__(33);
function injectStyle (ssrContext) {
  __webpack_require__(8)
}
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* styles */
var __vue_styles__ = injectStyle
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_App_vue__["a" /* default */],
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_65f85edc_hasScoped_false_node_modules_vue_loader_lib_selector_type_template_index_0_App_vue__["a" /* default */],
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)

/* harmony default export */ __webpack_exports__["a"] = (Component.exports);


/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(9);
if(typeof content === 'string') content = [[module.i, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var update = __webpack_require__(2)("32e0e988", content, true);

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(1)(undefined);
// imports


// module
exports.push([module.i, "[v-cloak]{display:none}*{box-sizing:border-box}#app{font-family:Oswald;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}.accordion,.house{display:none}@media (min-width:768px){.house{min-width:767px;max-width:1200px;margin:auto;display:block}}@media (max-width:767px){.accordion{display:block}}", ""]);

// exports


/***/ }),
/* 10 */
/***/ (function(module, exports) {

/**
 * Translates the list format produced by css-loader into something
 * easier to manipulate.
 */
module.exports = function listToStyles(parentId, list) {
  var styles = [];
  var newStyles = {};
  for (var i = 0; i < list.length; i++) {
    var item = list[i];
    var id = item[0];
    var css = item[1];
    var media = item[2];
    var sourceMap = item[3];
    var part = {
      id: parentId + ':' + i,
      css: css,
      media: media,
      sourceMap: sourceMap
    };
    if (!newStyles[id]) {
      styles.push(newStyles[id] = { id: id, parts: [part] });
    } else {
      newStyles[id].parts.push(part);
    }
  }
  return styles;
};

/***/ }),
/* 11 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__components_House__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__components_Accordion__ = __webpack_require__(25);
//
//
//
//
//
//
//
//




/* harmony default export */ __webpack_exports__["a"] = ({
    name: 'app',
    components: {
        House: __WEBPACK_IMPORTED_MODULE_0__components_House__["a" /* default */],
        Accordion: __WEBPACK_IMPORTED_MODULE_1__components_Accordion__["a" /* default */]
    },
    data() {
        return {
            callouts: [{
                title: 'Kitchen',
                slug: 'kitchen',
                text: 'Lorem ipsum dolor sit amet, consectetur adipisicing elit. Facere asperiores vitae obcaecati, adipisci minima natus nulla aliquid atque necessitatibus inventore!',
                show: false,
                position: {
                    top: '21%',
                    left: '53%'
                }
            }, {
                title: 'Bathroom',
                slug: 'bathroom',
                text: 'Lorem ipsum dolor sit amet, consectetur adipisicing elit. Facere asperiores vitae obcaecati, adipisci minima natus nulla aliquid atque necessitatibus inventore!',
                show: false,
                position: {
                    top: '15%',
                    left: '25%'
                }
            }, {
                title: 'Water Softener',
                slug: 'water-softener',
                text: 'Lorem ipsum dolor sit amet, consectetur adipisicing elit. Facere asperiores vitae obcaecati, adipisci minima natus nulla aliquid atque necessitatibus inventore!',
                show: false,
                position: {
                    top: '15%',
                    left: '10%'
                }
            }, {
                title: 'Laundry',
                slug: 'laundry',
                text: 'Lorem ipsum dolor sit amet, consectetur adipisicing elit. Facere asperiores vitae obcaecati, adipisci minima natus nulla aliquid atque necessitatibus inventore!',
                show: false,
                position: {
                    top: '20%',
                    left: '10%'
                }
            }, {
                title: 'Foundation',
                slug: 'foundation',
                text: 'Lorem ipsum dolor sit amet, consectetur adipisicing elit. Facere asperiores vitae obcaecati, adipisci minima natus nulla aliquid atque necessitatibus inventore!',
                show: false,
                position: {
                    top: '45%',
                    left: '10%'
                }
            }, {
                title: 'Service Line',
                slug: 'service-line',
                text: 'Lorem ipsum dolor sit amet, consectetur adipisicing elit. Facere asperiores vitae obcaecati, adipisci minima natus nulla aliquid atque necessitatibus inventore!',
                show: false,
                position: {
                    top: '40%',
                    left: '50%'
                }
            }, {
                title: 'Irrigation',
                slug: 'irrigation',
                text: 'Lorem ipsum dolor sit amet, consectetur adipisicing elit. Facere asperiores vitae obcaecati, adipisci minima natus nulla aliquid atque necessitatibus inventore!',
                show: false,
                position: {
                    top: '30%',
                    left: '60%'
                }
            }, {
                title: 'Pool',
                slug: 'pool',
                text: 'Lorem ipsum dolor sit amet, consectetur adipisicing elit. Facere asperiores vitae obcaecati, adipisci minima natus nulla aliquid atque necessitatibus inventore!',
                show: false,
                position: {
                    top: '47%',
                    left: '73%'
                }
            }]
        };
    }
});

/***/ }),
/* 12 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_House_vue__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_1bcc93f4_hasScoped_true_node_modules_vue_loader_lib_selector_type_template_index_0_House_vue__ = __webpack_require__(23);
function injectStyle (ssrContext) {
  __webpack_require__(13)
}
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* styles */
var __vue_styles__ = injectStyle
/* scopeId */
var __vue_scopeId__ = "data-v-1bcc93f4"
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_House_vue__["a" /* default */],
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_1bcc93f4_hasScoped_true_node_modules_vue_loader_lib_selector_type_template_index_0_House_vue__["a" /* default */],
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)

/* harmony default export */ __webpack_exports__["a"] = (Component.exports);


/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(14);
if(typeof content === 'string') content = [[module.i, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var update = __webpack_require__(2)("dce71fe0", content, true);

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(1)(undefined);
// imports


// module
exports.push([module.i, ".house-wrapper[data-v-1bcc93f4],.house[data-v-1bcc93f4]{position:relative}img[data-v-1bcc93f4]{max-width:100%;z-index:0}.callout[data-v-1bcc93f4]{position:absolute;z-index:2}.fade-enter-active[data-v-1bcc93f4],.fade-leave-active[data-v-1bcc93f4]{transition:opacity .3s}.fade-enter[data-v-1bcc93f4],.fade-leave-to[data-v-1bcc93f4]{opacity:0}.hotspot[data-v-1bcc93f4]{position:absolute;z-index:1;background-color:transparent;border:3px dashed transparent;transition:background-color .3s,border-color .3s}.hotspot[data-v-1bcc93f4]:hover{border-color:#0078ae;background-color:rgba(0,120,174,.3)}.water-softener[data-v-1bcc93f4]{height:25%;width:15.11%;top:50.2%;left:14.1%}.kitchen[data-v-1bcc93f4]{height:22%;top:51%;width:16.7%;left:57.1%}.laundry[data-v-1bcc93f4]{height:22%;width:9.8%;top:51.4%;left:30.2%}.bathroom[data-v-1bcc93f4]{top:28.5%;left:53%;width:20.8%;height:20.7%}.pool[data-v-1bcc93f4]{left:88.6%;top:78.7%;width:11.3%;height:13.5%}.foundation[data-v-1bcc93f4]{left:3%;top:75.2%;height:6.6%;width:74%}.service-line[data-v-1bcc93f4]{left:62%;top:81.9%;width:15%;height:12%}.irrigation[data-v-1bcc93f4]{left:77%;width:11.5%;height:20%;top:65%}", ""]);

// exports


/***/ }),
/* 15 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Callout__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_lodash__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_lodash__);
//
//
//
//
//
//
//
//
//
//
//
//

// import house from '../assets/house.png'


/* harmony default export */ __webpack_exports__["a"] = ({
    name: 'house',
    props: ['callouts'],
    components: {
        Callout: __WEBPACK_IMPORTED_MODULE_0__Callout__["a" /* default */]
    },
    methods: {
        showCallout(title) {
            let id = Object(__WEBPACK_IMPORTED_MODULE_1_lodash__["findIndex"])(this.callouts, o => o.title === title);
            this.callouts[id].show = true;
        },
        hideCallout(title) {
            let id = Object(__WEBPACK_IMPORTED_MODULE_1_lodash__["findIndex"])(this.callouts, o => o.title === title);
            this.callouts[id].show = false;
        }
    }
});

/***/ }),
/* 16 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_Callout_vue__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_0a62bb96_hasScoped_true_node_modules_vue_loader_lib_selector_type_template_index_0_Callout_vue__ = __webpack_require__(20);
function injectStyle (ssrContext) {
  __webpack_require__(17)
}
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* styles */
var __vue_styles__ = injectStyle
/* scopeId */
var __vue_scopeId__ = "data-v-0a62bb96"
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_Callout_vue__["a" /* default */],
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_0a62bb96_hasScoped_true_node_modules_vue_loader_lib_selector_type_template_index_0_Callout_vue__["a" /* default */],
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)

/* harmony default export */ __webpack_exports__["a"] = (Component.exports);


/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(18);
if(typeof content === 'string') content = [[module.i, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var update = __webpack_require__(2)("3d926b9e", content, true);

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(1)(undefined);
// imports


// module
exports.push([module.i, ".callout[data-v-0a62bb96]{background-color:#da690b;padding:10px 15px;color:#fff;max-width:315px}h3[data-v-0a62bb96],p[data-v-0a62bb96]{padding:0 0 5px;margin:0}h3[data-v-0a62bb96]{font-size:18px;font-weight:500}p[data-v-0a62bb96]{font-size:16px;font-weight:300}@media (max-width:994px){.callout[data-v-0a62bb96]{max-width:200px;padding:5px 10px}h3[data-v-0a62bb96]{font-size:14px}p[data-v-0a62bb96]{font-size:13px}}", ""]);

// exports


/***/ }),
/* 19 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
//
//
//
//
//
//
//

/* harmony default export */ __webpack_exports__["a"] = ({
    name: 'callout',
    props: ['content', 'title']
});

/***/ }),
/* 20 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"callout",on:{"mouseenter":function($event){$event.stopPropagation();$event.preventDefault();},"mouseleave":function($event){$event.stopPropagation();$event.preventDefault();}}},[_c('h3',[_vm._v(_vm._s(_vm.title))]),_vm._v(" "),_c('p',[_vm._v(_vm._s(_vm.content))])])}
var staticRenderFns = []
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, module) {var __WEBPACK_AMD_DEFINE_RESULT__;/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright JS Foundation and other contributors <https://js.foundation/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */;(function(){/** Used as a safe reference for `undefined` in pre-ES5 environments. */var undefined;/** Used as the semantic version number. */var VERSION='4.17.4';/** Used as the size to enable large array optimizations. */var LARGE_ARRAY_SIZE=200;/** Error message constants. */var CORE_ERROR_TEXT='Unsupported core-js use. Try https://npms.io/search?q=ponyfill.',FUNC_ERROR_TEXT='Expected a function';/** Used to stand-in for `undefined` hash values. */var HASH_UNDEFINED='__lodash_hash_undefined__';/** Used as the maximum memoize cache size. */var MAX_MEMOIZE_SIZE=500;/** Used as the internal argument placeholder. */var PLACEHOLDER='__lodash_placeholder__';/** Used to compose bitmasks for cloning. */var CLONE_DEEP_FLAG=1,CLONE_FLAT_FLAG=2,CLONE_SYMBOLS_FLAG=4;/** Used to compose bitmasks for value comparisons. */var COMPARE_PARTIAL_FLAG=1,COMPARE_UNORDERED_FLAG=2;/** Used to compose bitmasks for function metadata. */var WRAP_BIND_FLAG=1,WRAP_BIND_KEY_FLAG=2,WRAP_CURRY_BOUND_FLAG=4,WRAP_CURRY_FLAG=8,WRAP_CURRY_RIGHT_FLAG=16,WRAP_PARTIAL_FLAG=32,WRAP_PARTIAL_RIGHT_FLAG=64,WRAP_ARY_FLAG=128,WRAP_REARG_FLAG=256,WRAP_FLIP_FLAG=512;/** Used as default options for `_.truncate`. */var DEFAULT_TRUNC_LENGTH=30,DEFAULT_TRUNC_OMISSION='...';/** Used to detect hot functions by number of calls within a span of milliseconds. */var HOT_COUNT=800,HOT_SPAN=16;/** Used to indicate the type of lazy iteratees. */var LAZY_FILTER_FLAG=1,LAZY_MAP_FLAG=2,LAZY_WHILE_FLAG=3;/** Used as references for various `Number` constants. */var INFINITY=1/0,MAX_SAFE_INTEGER=9007199254740991,MAX_INTEGER=1.7976931348623157e+308,NAN=0/0;/** Used as references for the maximum length and index of an array. */var MAX_ARRAY_LENGTH=4294967295,MAX_ARRAY_INDEX=MAX_ARRAY_LENGTH-1,HALF_MAX_ARRAY_LENGTH=MAX_ARRAY_LENGTH>>>1;/** Used to associate wrap methods with their bit flags. */var wrapFlags=[['ary',WRAP_ARY_FLAG],['bind',WRAP_BIND_FLAG],['bindKey',WRAP_BIND_KEY_FLAG],['curry',WRAP_CURRY_FLAG],['curryRight',WRAP_CURRY_RIGHT_FLAG],['flip',WRAP_FLIP_FLAG],['partial',WRAP_PARTIAL_FLAG],['partialRight',WRAP_PARTIAL_RIGHT_FLAG],['rearg',WRAP_REARG_FLAG]];/** `Object#toString` result references. */var argsTag='[object Arguments]',arrayTag='[object Array]',asyncTag='[object AsyncFunction]',boolTag='[object Boolean]',dateTag='[object Date]',domExcTag='[object DOMException]',errorTag='[object Error]',funcTag='[object Function]',genTag='[object GeneratorFunction]',mapTag='[object Map]',numberTag='[object Number]',nullTag='[object Null]',objectTag='[object Object]',promiseTag='[object Promise]',proxyTag='[object Proxy]',regexpTag='[object RegExp]',setTag='[object Set]',stringTag='[object String]',symbolTag='[object Symbol]',undefinedTag='[object Undefined]',weakMapTag='[object WeakMap]',weakSetTag='[object WeakSet]';var arrayBufferTag='[object ArrayBuffer]',dataViewTag='[object DataView]',float32Tag='[object Float32Array]',float64Tag='[object Float64Array]',int8Tag='[object Int8Array]',int16Tag='[object Int16Array]',int32Tag='[object Int32Array]',uint8Tag='[object Uint8Array]',uint8ClampedTag='[object Uint8ClampedArray]',uint16Tag='[object Uint16Array]',uint32Tag='[object Uint32Array]';/** Used to match empty string literals in compiled template source. */var reEmptyStringLeading=/\b__p \+= '';/g,reEmptyStringMiddle=/\b(__p \+=) '' \+/g,reEmptyStringTrailing=/(__e\(.*?\)|\b__t\)) \+\n'';/g;/** Used to match HTML entities and HTML characters. */var reEscapedHtml=/&(?:amp|lt|gt|quot|#39);/g,reUnescapedHtml=/[&<>"']/g,reHasEscapedHtml=RegExp(reEscapedHtml.source),reHasUnescapedHtml=RegExp(reUnescapedHtml.source);/** Used to match template delimiters. */var reEscape=/<%-([\s\S]+?)%>/g,reEvaluate=/<%([\s\S]+?)%>/g,reInterpolate=/<%=([\s\S]+?)%>/g;/** Used to match property names within property paths. */var reIsDeepProp=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,reIsPlainProp=/^\w*$/,reLeadingDot=/^\./,rePropName=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;/**
   * Used to match `RegExp`
   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
   */var reRegExpChar=/[\\^$.*+?()[\]{}|]/g,reHasRegExpChar=RegExp(reRegExpChar.source);/** Used to match leading and trailing whitespace. */var reTrim=/^\s+|\s+$/g,reTrimStart=/^\s+/,reTrimEnd=/\s+$/;/** Used to match wrap detail comments. */var reWrapComment=/\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,reWrapDetails=/\{\n\/\* \[wrapped with (.+)\] \*/,reSplitDetails=/,? & /;/** Used to match words composed of alphanumeric characters. */var reAsciiWord=/[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;/** Used to match backslashes in property paths. */var reEscapeChar=/\\(\\)?/g;/**
   * Used to match
   * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components).
   */var reEsTemplate=/\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;/** Used to match `RegExp` flags from their coerced string values. */var reFlags=/\w*$/;/** Used to detect bad signed hexadecimal string values. */var reIsBadHex=/^[-+]0x[0-9a-f]+$/i;/** Used to detect binary string values. */var reIsBinary=/^0b[01]+$/i;/** Used to detect host constructors (Safari). */var reIsHostCtor=/^\[object .+?Constructor\]$/;/** Used to detect octal string values. */var reIsOctal=/^0o[0-7]+$/i;/** Used to detect unsigned integer values. */var reIsUint=/^(?:0|[1-9]\d*)$/;/** Used to match Latin Unicode letters (excluding mathematical operators). */var reLatin=/[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;/** Used to ensure capturing order of template delimiters. */var reNoMatch=/($^)/;/** Used to match unescaped characters in compiled string literals. */var reUnescapedString=/['\n\r\u2028\u2029\\]/g;/** Used to compose unicode character classes. */var rsAstralRange='\\ud800-\\udfff',rsComboMarksRange='\\u0300-\\u036f',reComboHalfMarksRange='\\ufe20-\\ufe2f',rsComboSymbolsRange='\\u20d0-\\u20ff',rsComboRange=rsComboMarksRange+reComboHalfMarksRange+rsComboSymbolsRange,rsDingbatRange='\\u2700-\\u27bf',rsLowerRange='a-z\\xdf-\\xf6\\xf8-\\xff',rsMathOpRange='\\xac\\xb1\\xd7\\xf7',rsNonCharRange='\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',rsPunctuationRange='\\u2000-\\u206f',rsSpaceRange=' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000',rsUpperRange='A-Z\\xc0-\\xd6\\xd8-\\xde',rsVarRange='\\ufe0e\\ufe0f',rsBreakRange=rsMathOpRange+rsNonCharRange+rsPunctuationRange+rsSpaceRange;/** Used to compose unicode capture groups. */var rsApos="['\u2019]",rsAstral='['+rsAstralRange+']',rsBreak='['+rsBreakRange+']',rsCombo='['+rsComboRange+']',rsDigits='\\d+',rsDingbat='['+rsDingbatRange+']',rsLower='['+rsLowerRange+']',rsMisc='[^'+rsAstralRange+rsBreakRange+rsDigits+rsDingbatRange+rsLowerRange+rsUpperRange+']',rsFitz='\\ud83c[\\udffb-\\udfff]',rsModifier='(?:'+rsCombo+'|'+rsFitz+')',rsNonAstral='[^'+rsAstralRange+']',rsRegional='(?:\\ud83c[\\udde6-\\uddff]){2}',rsSurrPair='[\\ud800-\\udbff][\\udc00-\\udfff]',rsUpper='['+rsUpperRange+']',rsZWJ='\\u200d';/** Used to compose unicode regexes. */var rsMiscLower='(?:'+rsLower+'|'+rsMisc+')',rsMiscUpper='(?:'+rsUpper+'|'+rsMisc+')',rsOptContrLower='(?:'+rsApos+'(?:d|ll|m|re|s|t|ve))?',rsOptContrUpper='(?:'+rsApos+'(?:D|LL|M|RE|S|T|VE))?',reOptMod=rsModifier+'?',rsOptVar='['+rsVarRange+']?',rsOptJoin='(?:'+rsZWJ+'(?:'+[rsNonAstral,rsRegional,rsSurrPair].join('|')+')'+rsOptVar+reOptMod+')*',rsOrdLower='\\d*(?:(?:1st|2nd|3rd|(?![123])\\dth)\\b)',rsOrdUpper='\\d*(?:(?:1ST|2ND|3RD|(?![123])\\dTH)\\b)',rsSeq=rsOptVar+reOptMod+rsOptJoin,rsEmoji='(?:'+[rsDingbat,rsRegional,rsSurrPair].join('|')+')'+rsSeq,rsSymbol='(?:'+[rsNonAstral+rsCombo+'?',rsCombo,rsRegional,rsSurrPair,rsAstral].join('|')+')';/** Used to match apostrophes. */var reApos=RegExp(rsApos,'g');/**
   * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
   * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
   */var reComboMark=RegExp(rsCombo,'g');/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */var reUnicode=RegExp(rsFitz+'(?='+rsFitz+')|'+rsSymbol+rsSeq,'g');/** Used to match complex or compound words. */var reUnicodeWord=RegExp([rsUpper+'?'+rsLower+'+'+rsOptContrLower+'(?='+[rsBreak,rsUpper,'$'].join('|')+')',rsMiscUpper+'+'+rsOptContrUpper+'(?='+[rsBreak,rsUpper+rsMiscLower,'$'].join('|')+')',rsUpper+'?'+rsMiscLower+'+'+rsOptContrLower,rsUpper+'+'+rsOptContrUpper,rsOrdUpper,rsOrdLower,rsDigits,rsEmoji].join('|'),'g');/** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */var reHasUnicode=RegExp('['+rsZWJ+rsAstralRange+rsComboRange+rsVarRange+']');/** Used to detect strings that need a more robust regexp to match words. */var reHasUnicodeWord=/[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;/** Used to assign default `context` object properties. */var contextProps=['Array','Buffer','DataView','Date','Error','Float32Array','Float64Array','Function','Int8Array','Int16Array','Int32Array','Map','Math','Object','Promise','RegExp','Set','String','Symbol','TypeError','Uint8Array','Uint8ClampedArray','Uint16Array','Uint32Array','WeakMap','_','clearTimeout','isFinite','parseInt','setTimeout'];/** Used to make template sourceURLs easier to identify. */var templateCounter=-1;/** Used to identify `toStringTag` values of typed arrays. */var typedArrayTags={};typedArrayTags[float32Tag]=typedArrayTags[float64Tag]=typedArrayTags[int8Tag]=typedArrayTags[int16Tag]=typedArrayTags[int32Tag]=typedArrayTags[uint8Tag]=typedArrayTags[uint8ClampedTag]=typedArrayTags[uint16Tag]=typedArrayTags[uint32Tag]=true;typedArrayTags[argsTag]=typedArrayTags[arrayTag]=typedArrayTags[arrayBufferTag]=typedArrayTags[boolTag]=typedArrayTags[dataViewTag]=typedArrayTags[dateTag]=typedArrayTags[errorTag]=typedArrayTags[funcTag]=typedArrayTags[mapTag]=typedArrayTags[numberTag]=typedArrayTags[objectTag]=typedArrayTags[regexpTag]=typedArrayTags[setTag]=typedArrayTags[stringTag]=typedArrayTags[weakMapTag]=false;/** Used to identify `toStringTag` values supported by `_.clone`. */var cloneableTags={};cloneableTags[argsTag]=cloneableTags[arrayTag]=cloneableTags[arrayBufferTag]=cloneableTags[dataViewTag]=cloneableTags[boolTag]=cloneableTags[dateTag]=cloneableTags[float32Tag]=cloneableTags[float64Tag]=cloneableTags[int8Tag]=cloneableTags[int16Tag]=cloneableTags[int32Tag]=cloneableTags[mapTag]=cloneableTags[numberTag]=cloneableTags[objectTag]=cloneableTags[regexpTag]=cloneableTags[setTag]=cloneableTags[stringTag]=cloneableTags[symbolTag]=cloneableTags[uint8Tag]=cloneableTags[uint8ClampedTag]=cloneableTags[uint16Tag]=cloneableTags[uint32Tag]=true;cloneableTags[errorTag]=cloneableTags[funcTag]=cloneableTags[weakMapTag]=false;/** Used to map Latin Unicode letters to basic Latin letters. */var deburredLetters={// Latin-1 Supplement block.
'\xc0':'A','\xc1':'A','\xc2':'A','\xc3':'A','\xc4':'A','\xc5':'A','\xe0':'a','\xe1':'a','\xe2':'a','\xe3':'a','\xe4':'a','\xe5':'a','\xc7':'C','\xe7':'c','\xd0':'D','\xf0':'d','\xc8':'E','\xc9':'E','\xca':'E','\xcb':'E','\xe8':'e','\xe9':'e','\xea':'e','\xeb':'e','\xcc':'I','\xcd':'I','\xce':'I','\xcf':'I','\xec':'i','\xed':'i','\xee':'i','\xef':'i','\xd1':'N','\xf1':'n','\xd2':'O','\xd3':'O','\xd4':'O','\xd5':'O','\xd6':'O','\xd8':'O','\xf2':'o','\xf3':'o','\xf4':'o','\xf5':'o','\xf6':'o','\xf8':'o','\xd9':'U','\xda':'U','\xdb':'U','\xdc':'U','\xf9':'u','\xfa':'u','\xfb':'u','\xfc':'u','\xdd':'Y','\xfd':'y','\xff':'y','\xc6':'Ae','\xe6':'ae','\xde':'Th','\xfe':'th','\xdf':'ss',// Latin Extended-A block.
'\u0100':'A','\u0102':'A','\u0104':'A','\u0101':'a','\u0103':'a','\u0105':'a','\u0106':'C','\u0108':'C','\u010a':'C','\u010c':'C','\u0107':'c','\u0109':'c','\u010b':'c','\u010d':'c','\u010e':'D','\u0110':'D','\u010f':'d','\u0111':'d','\u0112':'E','\u0114':'E','\u0116':'E','\u0118':'E','\u011a':'E','\u0113':'e','\u0115':'e','\u0117':'e','\u0119':'e','\u011b':'e','\u011c':'G','\u011e':'G','\u0120':'G','\u0122':'G','\u011d':'g','\u011f':'g','\u0121':'g','\u0123':'g','\u0124':'H','\u0126':'H','\u0125':'h','\u0127':'h','\u0128':'I','\u012a':'I','\u012c':'I','\u012e':'I','\u0130':'I','\u0129':'i','\u012b':'i','\u012d':'i','\u012f':'i','\u0131':'i','\u0134':'J','\u0135':'j','\u0136':'K','\u0137':'k','\u0138':'k','\u0139':'L','\u013b':'L','\u013d':'L','\u013f':'L','\u0141':'L','\u013a':'l','\u013c':'l','\u013e':'l','\u0140':'l','\u0142':'l','\u0143':'N','\u0145':'N','\u0147':'N','\u014a':'N','\u0144':'n','\u0146':'n','\u0148':'n','\u014b':'n','\u014c':'O','\u014e':'O','\u0150':'O','\u014d':'o','\u014f':'o','\u0151':'o','\u0154':'R','\u0156':'R','\u0158':'R','\u0155':'r','\u0157':'r','\u0159':'r','\u015a':'S','\u015c':'S','\u015e':'S','\u0160':'S','\u015b':'s','\u015d':'s','\u015f':'s','\u0161':'s','\u0162':'T','\u0164':'T','\u0166':'T','\u0163':'t','\u0165':'t','\u0167':'t','\u0168':'U','\u016a':'U','\u016c':'U','\u016e':'U','\u0170':'U','\u0172':'U','\u0169':'u','\u016b':'u','\u016d':'u','\u016f':'u','\u0171':'u','\u0173':'u','\u0174':'W','\u0175':'w','\u0176':'Y','\u0177':'y','\u0178':'Y','\u0179':'Z','\u017b':'Z','\u017d':'Z','\u017a':'z','\u017c':'z','\u017e':'z','\u0132':'IJ','\u0133':'ij','\u0152':'Oe','\u0153':'oe','\u0149':"'n",'\u017f':'s'};/** Used to map characters to HTML entities. */var htmlEscapes={'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'};/** Used to map HTML entities to characters. */var htmlUnescapes={'&amp;':'&','&lt;':'<','&gt;':'>','&quot;':'"','&#39;':"'"};/** Used to escape characters for inclusion in compiled string literals. */var stringEscapes={'\\':'\\',"'":"'",'\n':'n','\r':'r','\u2028':'u2028','\u2029':'u2029'};/** Built-in method references without a dependency on `root`. */var freeParseFloat=parseFloat,freeParseInt=parseInt;/** Detect free variable `global` from Node.js. */var freeGlobal=typeof global=='object'&&global&&global.Object===Object&&global;/** Detect free variable `self`. */var freeSelf=typeof self=='object'&&self&&self.Object===Object&&self;/** Used as a reference to the global object. */var root=freeGlobal||freeSelf||Function('return this')();/** Detect free variable `exports`. */var freeExports=typeof exports=='object'&&exports&&!exports.nodeType&&exports;/** Detect free variable `module`. */var freeModule=freeExports&&typeof module=='object'&&module&&!module.nodeType&&module;/** Detect the popular CommonJS extension `module.exports`. */var moduleExports=freeModule&&freeModule.exports===freeExports;/** Detect free variable `process` from Node.js. */var freeProcess=moduleExports&&freeGlobal.process;/** Used to access faster Node.js helpers. */var nodeUtil=function(){try{return freeProcess&&freeProcess.binding&&freeProcess.binding('util');}catch(e){}}();/* Node.js helper references. */var nodeIsArrayBuffer=nodeUtil&&nodeUtil.isArrayBuffer,nodeIsDate=nodeUtil&&nodeUtil.isDate,nodeIsMap=nodeUtil&&nodeUtil.isMap,nodeIsRegExp=nodeUtil&&nodeUtil.isRegExp,nodeIsSet=nodeUtil&&nodeUtil.isSet,nodeIsTypedArray=nodeUtil&&nodeUtil.isTypedArray;/*--------------------------------------------------------------------------*//**
   * Adds the key-value `pair` to `map`.
   *
   * @private
   * @param {Object} map The map to modify.
   * @param {Array} pair The key-value pair to add.
   * @returns {Object} Returns `map`.
   */function addMapEntry(map,pair){// Don't return `map.set` because it's not chainable in IE 11.
map.set(pair[0],pair[1]);return map;}/**
   * Adds `value` to `set`.
   *
   * @private
   * @param {Object} set The set to modify.
   * @param {*} value The value to add.
   * @returns {Object} Returns `set`.
   */function addSetEntry(set,value){// Don't return `set.add` because it's not chainable in IE 11.
set.add(value);return set;}/**
   * A faster alternative to `Function#apply`, this function invokes `func`
   * with the `this` binding of `thisArg` and the arguments of `args`.
   *
   * @private
   * @param {Function} func The function to invoke.
   * @param {*} thisArg The `this` binding of `func`.
   * @param {Array} args The arguments to invoke `func` with.
   * @returns {*} Returns the result of `func`.
   */function apply(func,thisArg,args){switch(args.length){case 0:return func.call(thisArg);case 1:return func.call(thisArg,args[0]);case 2:return func.call(thisArg,args[0],args[1]);case 3:return func.call(thisArg,args[0],args[1],args[2]);}return func.apply(thisArg,args);}/**
   * A specialized version of `baseAggregator` for arrays.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} setter The function to set `accumulator` values.
   * @param {Function} iteratee The iteratee to transform keys.
   * @param {Object} accumulator The initial aggregated object.
   * @returns {Function} Returns `accumulator`.
   */function arrayAggregator(array,setter,iteratee,accumulator){var index=-1,length=array==null?0:array.length;while(++index<length){var value=array[index];setter(accumulator,value,iteratee(value),array);}return accumulator;}/**
   * A specialized version of `_.forEach` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns `array`.
   */function arrayEach(array,iteratee){var index=-1,length=array==null?0:array.length;while(++index<length){if(iteratee(array[index],index,array)===false){break;}}return array;}/**
   * A specialized version of `_.forEachRight` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns `array`.
   */function arrayEachRight(array,iteratee){var length=array==null?0:array.length;while(length--){if(iteratee(array[length],length,array)===false){break;}}return array;}/**
   * A specialized version of `_.every` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {boolean} Returns `true` if all elements pass the predicate check,
   *  else `false`.
   */function arrayEvery(array,predicate){var index=-1,length=array==null?0:array.length;while(++index<length){if(!predicate(array[index],index,array)){return false;}}return true;}/**
   * A specialized version of `_.filter` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {Array} Returns the new filtered array.
   */function arrayFilter(array,predicate){var index=-1,length=array==null?0:array.length,resIndex=0,result=[];while(++index<length){var value=array[index];if(predicate(value,index,array)){result[resIndex++]=value;}}return result;}/**
   * A specialized version of `_.includes` for arrays without support for
   * specifying an index to search from.
   *
   * @private
   * @param {Array} [array] The array to inspect.
   * @param {*} target The value to search for.
   * @returns {boolean} Returns `true` if `target` is found, else `false`.
   */function arrayIncludes(array,value){var length=array==null?0:array.length;return!!length&&baseIndexOf(array,value,0)>-1;}/**
   * This function is like `arrayIncludes` except that it accepts a comparator.
   *
   * @private
   * @param {Array} [array] The array to inspect.
   * @param {*} target The value to search for.
   * @param {Function} comparator The comparator invoked per element.
   * @returns {boolean} Returns `true` if `target` is found, else `false`.
   */function arrayIncludesWith(array,value,comparator){var index=-1,length=array==null?0:array.length;while(++index<length){if(comparator(value,array[index])){return true;}}return false;}/**
   * A specialized version of `_.map` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the new mapped array.
   */function arrayMap(array,iteratee){var index=-1,length=array==null?0:array.length,result=Array(length);while(++index<length){result[index]=iteratee(array[index],index,array);}return result;}/**
   * Appends the elements of `values` to `array`.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {Array} values The values to append.
   * @returns {Array} Returns `array`.
   */function arrayPush(array,values){var index=-1,length=values.length,offset=array.length;while(++index<length){array[offset+index]=values[index];}return array;}/**
   * A specialized version of `_.reduce` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} [accumulator] The initial value.
   * @param {boolean} [initAccum] Specify using the first element of `array` as
   *  the initial value.
   * @returns {*} Returns the accumulated value.
   */function arrayReduce(array,iteratee,accumulator,initAccum){var index=-1,length=array==null?0:array.length;if(initAccum&&length){accumulator=array[++index];}while(++index<length){accumulator=iteratee(accumulator,array[index],index,array);}return accumulator;}/**
   * A specialized version of `_.reduceRight` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} [accumulator] The initial value.
   * @param {boolean} [initAccum] Specify using the last element of `array` as
   *  the initial value.
   * @returns {*} Returns the accumulated value.
   */function arrayReduceRight(array,iteratee,accumulator,initAccum){var length=array==null?0:array.length;if(initAccum&&length){accumulator=array[--length];}while(length--){accumulator=iteratee(accumulator,array[length],length,array);}return accumulator;}/**
   * A specialized version of `_.some` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {boolean} Returns `true` if any element passes the predicate check,
   *  else `false`.
   */function arraySome(array,predicate){var index=-1,length=array==null?0:array.length;while(++index<length){if(predicate(array[index],index,array)){return true;}}return false;}/**
   * Gets the size of an ASCII `string`.
   *
   * @private
   * @param {string} string The string inspect.
   * @returns {number} Returns the string size.
   */var asciiSize=baseProperty('length');/**
   * Converts an ASCII `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */function asciiToArray(string){return string.split('');}/**
   * Splits an ASCII `string` into an array of its words.
   *
   * @private
   * @param {string} The string to inspect.
   * @returns {Array} Returns the words of `string`.
   */function asciiWords(string){return string.match(reAsciiWord)||[];}/**
   * The base implementation of methods like `_.findKey` and `_.findLastKey`,
   * without support for iteratee shorthands, which iterates over `collection`
   * using `eachFunc`.
   *
   * @private
   * @param {Array|Object} collection The collection to inspect.
   * @param {Function} predicate The function invoked per iteration.
   * @param {Function} eachFunc The function to iterate over `collection`.
   * @returns {*} Returns the found element or its key, else `undefined`.
   */function baseFindKey(collection,predicate,eachFunc){var result;eachFunc(collection,function(value,key,collection){if(predicate(value,key,collection)){result=key;return false;}});return result;}/**
   * The base implementation of `_.findIndex` and `_.findLastIndex` without
   * support for iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {Function} predicate The function invoked per iteration.
   * @param {number} fromIndex The index to search from.
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */function baseFindIndex(array,predicate,fromIndex,fromRight){var length=array.length,index=fromIndex+(fromRight?1:-1);while(fromRight?index--:++index<length){if(predicate(array[index],index,array)){return index;}}return-1;}/**
   * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */function baseIndexOf(array,value,fromIndex){return value===value?strictIndexOf(array,value,fromIndex):baseFindIndex(array,baseIsNaN,fromIndex);}/**
   * This function is like `baseIndexOf` except that it accepts a comparator.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @param {Function} comparator The comparator invoked per element.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */function baseIndexOfWith(array,value,fromIndex,comparator){var index=fromIndex-1,length=array.length;while(++index<length){if(comparator(array[index],value)){return index;}}return-1;}/**
   * The base implementation of `_.isNaN` without support for number objects.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
   */function baseIsNaN(value){return value!==value;}/**
   * The base implementation of `_.mean` and `_.meanBy` without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {number} Returns the mean.
   */function baseMean(array,iteratee){var length=array==null?0:array.length;return length?baseSum(array,iteratee)/length:NAN;}/**
   * The base implementation of `_.property` without support for deep paths.
   *
   * @private
   * @param {string} key The key of the property to get.
   * @returns {Function} Returns the new accessor function.
   */function baseProperty(key){return function(object){return object==null?undefined:object[key];};}/**
   * The base implementation of `_.propertyOf` without support for deep paths.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Function} Returns the new accessor function.
   */function basePropertyOf(object){return function(key){return object==null?undefined:object[key];};}/**
   * The base implementation of `_.reduce` and `_.reduceRight`, without support
   * for iteratee shorthands, which iterates over `collection` using `eachFunc`.
   *
   * @private
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} accumulator The initial value.
   * @param {boolean} initAccum Specify using the first or last element of
   *  `collection` as the initial value.
   * @param {Function} eachFunc The function to iterate over `collection`.
   * @returns {*} Returns the accumulated value.
   */function baseReduce(collection,iteratee,accumulator,initAccum,eachFunc){eachFunc(collection,function(value,index,collection){accumulator=initAccum?(initAccum=false,value):iteratee(accumulator,value,index,collection);});return accumulator;}/**
   * The base implementation of `_.sortBy` which uses `comparer` to define the
   * sort order of `array` and replaces criteria objects with their corresponding
   * values.
   *
   * @private
   * @param {Array} array The array to sort.
   * @param {Function} comparer The function to define sort order.
   * @returns {Array} Returns `array`.
   */function baseSortBy(array,comparer){var length=array.length;array.sort(comparer);while(length--){array[length]=array[length].value;}return array;}/**
   * The base implementation of `_.sum` and `_.sumBy` without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {number} Returns the sum.
   */function baseSum(array,iteratee){var result,index=-1,length=array.length;while(++index<length){var current=iteratee(array[index]);if(current!==undefined){result=result===undefined?current:result+current;}}return result;}/**
   * The base implementation of `_.times` without support for iteratee shorthands
   * or max array length checks.
   *
   * @private
   * @param {number} n The number of times to invoke `iteratee`.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the array of results.
   */function baseTimes(n,iteratee){var index=-1,result=Array(n);while(++index<n){result[index]=iteratee(index);}return result;}/**
   * The base implementation of `_.toPairs` and `_.toPairsIn` which creates an array
   * of key-value pairs for `object` corresponding to the property names of `props`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array} props The property names to get values for.
   * @returns {Object} Returns the key-value pairs.
   */function baseToPairs(object,props){return arrayMap(props,function(key){return[key,object[key]];});}/**
   * The base implementation of `_.unary` without support for storing metadata.
   *
   * @private
   * @param {Function} func The function to cap arguments for.
   * @returns {Function} Returns the new capped function.
   */function baseUnary(func){return function(value){return func(value);};}/**
   * The base implementation of `_.values` and `_.valuesIn` which creates an
   * array of `object` property values corresponding to the property names
   * of `props`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array} props The property names to get values for.
   * @returns {Object} Returns the array of property values.
   */function baseValues(object,props){return arrayMap(props,function(key){return object[key];});}/**
   * Checks if a `cache` value for `key` exists.
   *
   * @private
   * @param {Object} cache The cache to query.
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */function cacheHas(cache,key){return cache.has(key);}/**
   * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol
   * that is not found in the character symbols.
   *
   * @private
   * @param {Array} strSymbols The string symbols to inspect.
   * @param {Array} chrSymbols The character symbols to find.
   * @returns {number} Returns the index of the first unmatched string symbol.
   */function charsStartIndex(strSymbols,chrSymbols){var index=-1,length=strSymbols.length;while(++index<length&&baseIndexOf(chrSymbols,strSymbols[index],0)>-1){}return index;}/**
   * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol
   * that is not found in the character symbols.
   *
   * @private
   * @param {Array} strSymbols The string symbols to inspect.
   * @param {Array} chrSymbols The character symbols to find.
   * @returns {number} Returns the index of the last unmatched string symbol.
   */function charsEndIndex(strSymbols,chrSymbols){var index=strSymbols.length;while(index--&&baseIndexOf(chrSymbols,strSymbols[index],0)>-1){}return index;}/**
   * Gets the number of `placeholder` occurrences in `array`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} placeholder The placeholder to search for.
   * @returns {number} Returns the placeholder count.
   */function countHolders(array,placeholder){var length=array.length,result=0;while(length--){if(array[length]===placeholder){++result;}}return result;}/**
   * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A
   * letters to basic Latin letters.
   *
   * @private
   * @param {string} letter The matched letter to deburr.
   * @returns {string} Returns the deburred letter.
   */var deburrLetter=basePropertyOf(deburredLetters);/**
   * Used by `_.escape` to convert characters to HTML entities.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @returns {string} Returns the escaped character.
   */var escapeHtmlChar=basePropertyOf(htmlEscapes);/**
   * Used by `_.template` to escape characters for inclusion in compiled string literals.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @returns {string} Returns the escaped character.
   */function escapeStringChar(chr){return'\\'+stringEscapes[chr];}/**
   * Gets the value at `key` of `object`.
   *
   * @private
   * @param {Object} [object] The object to query.
   * @param {string} key The key of the property to get.
   * @returns {*} Returns the property value.
   */function getValue(object,key){return object==null?undefined:object[key];}/**
   * Checks if `string` contains Unicode symbols.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {boolean} Returns `true` if a symbol is found, else `false`.
   */function hasUnicode(string){return reHasUnicode.test(string);}/**
   * Checks if `string` contains a word composed of Unicode symbols.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {boolean} Returns `true` if a word is found, else `false`.
   */function hasUnicodeWord(string){return reHasUnicodeWord.test(string);}/**
   * Converts `iterator` to an array.
   *
   * @private
   * @param {Object} iterator The iterator to convert.
   * @returns {Array} Returns the converted array.
   */function iteratorToArray(iterator){var data,result=[];while(!(data=iterator.next()).done){result.push(data.value);}return result;}/**
   * Converts `map` to its key-value pairs.
   *
   * @private
   * @param {Object} map The map to convert.
   * @returns {Array} Returns the key-value pairs.
   */function mapToArray(map){var index=-1,result=Array(map.size);map.forEach(function(value,key){result[++index]=[key,value];});return result;}/**
   * Creates a unary function that invokes `func` with its argument transformed.
   *
   * @private
   * @param {Function} func The function to wrap.
   * @param {Function} transform The argument transform.
   * @returns {Function} Returns the new function.
   */function overArg(func,transform){return function(arg){return func(transform(arg));};}/**
   * Replaces all `placeholder` elements in `array` with an internal placeholder
   * and returns an array of their indexes.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {*} placeholder The placeholder to replace.
   * @returns {Array} Returns the new array of placeholder indexes.
   */function replaceHolders(array,placeholder){var index=-1,length=array.length,resIndex=0,result=[];while(++index<length){var value=array[index];if(value===placeholder||value===PLACEHOLDER){array[index]=PLACEHOLDER;result[resIndex++]=index;}}return result;}/**
   * Converts `set` to an array of its values.
   *
   * @private
   * @param {Object} set The set to convert.
   * @returns {Array} Returns the values.
   */function setToArray(set){var index=-1,result=Array(set.size);set.forEach(function(value){result[++index]=value;});return result;}/**
   * Converts `set` to its value-value pairs.
   *
   * @private
   * @param {Object} set The set to convert.
   * @returns {Array} Returns the value-value pairs.
   */function setToPairs(set){var index=-1,result=Array(set.size);set.forEach(function(value){result[++index]=[value,value];});return result;}/**
   * A specialized version of `_.indexOf` which performs strict equality
   * comparisons of values, i.e. `===`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */function strictIndexOf(array,value,fromIndex){var index=fromIndex-1,length=array.length;while(++index<length){if(array[index]===value){return index;}}return-1;}/**
   * A specialized version of `_.lastIndexOf` which performs strict equality
   * comparisons of values, i.e. `===`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */function strictLastIndexOf(array,value,fromIndex){var index=fromIndex+1;while(index--){if(array[index]===value){return index;}}return index;}/**
   * Gets the number of symbols in `string`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {number} Returns the string size.
   */function stringSize(string){return hasUnicode(string)?unicodeSize(string):asciiSize(string);}/**
   * Converts `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */function stringToArray(string){return hasUnicode(string)?unicodeToArray(string):asciiToArray(string);}/**
   * Used by `_.unescape` to convert HTML entities to characters.
   *
   * @private
   * @param {string} chr The matched character to unescape.
   * @returns {string} Returns the unescaped character.
   */var unescapeHtmlChar=basePropertyOf(htmlUnescapes);/**
   * Gets the size of a Unicode `string`.
   *
   * @private
   * @param {string} string The string inspect.
   * @returns {number} Returns the string size.
   */function unicodeSize(string){var result=reUnicode.lastIndex=0;while(reUnicode.test(string)){++result;}return result;}/**
   * Converts a Unicode `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */function unicodeToArray(string){return string.match(reUnicode)||[];}/**
   * Splits a Unicode `string` into an array of its words.
   *
   * @private
   * @param {string} The string to inspect.
   * @returns {Array} Returns the words of `string`.
   */function unicodeWords(string){return string.match(reUnicodeWord)||[];}/*--------------------------------------------------------------------------*//**
   * Create a new pristine `lodash` function using the `context` object.
   *
   * @static
   * @memberOf _
   * @since 1.1.0
   * @category Util
   * @param {Object} [context=root] The context object.
   * @returns {Function} Returns a new `lodash` function.
   * @example
   *
   * _.mixin({ 'foo': _.constant('foo') });
   *
   * var lodash = _.runInContext();
   * lodash.mixin({ 'bar': lodash.constant('bar') });
   *
   * _.isFunction(_.foo);
   * // => true
   * _.isFunction(_.bar);
   * // => false
   *
   * lodash.isFunction(lodash.foo);
   * // => false
   * lodash.isFunction(lodash.bar);
   * // => true
   *
   * // Create a suped-up `defer` in Node.js.
   * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;
   */var runInContext=function runInContext(context){context=context==null?root:_.defaults(root.Object(),context,_.pick(root,contextProps));/** Built-in constructor references. */var Array=context.Array,Date=context.Date,Error=context.Error,Function=context.Function,Math=context.Math,Object=context.Object,RegExp=context.RegExp,String=context.String,TypeError=context.TypeError;/** Used for built-in method references. */var arrayProto=Array.prototype,funcProto=Function.prototype,objectProto=Object.prototype;/** Used to detect overreaching core-js shims. */var coreJsData=context['__core-js_shared__'];/** Used to resolve the decompiled source of functions. */var funcToString=funcProto.toString;/** Used to check objects for own properties. */var hasOwnProperty=objectProto.hasOwnProperty;/** Used to generate unique IDs. */var idCounter=0;/** Used to detect methods masquerading as native. */var maskSrcKey=function(){var uid=/[^.]+$/.exec(coreJsData&&coreJsData.keys&&coreJsData.keys.IE_PROTO||'');return uid?'Symbol(src)_1.'+uid:'';}();/**
     * Used to resolve the
     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
     * of values.
     */var nativeObjectToString=objectProto.toString;/** Used to infer the `Object` constructor. */var objectCtorString=funcToString.call(Object);/** Used to restore the original `_` reference in `_.noConflict`. */var oldDash=root._;/** Used to detect if a method is native. */var reIsNative=RegExp('^'+funcToString.call(hasOwnProperty).replace(reRegExpChar,'\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,'$1.*?')+'$');/** Built-in value references. */var Buffer=moduleExports?context.Buffer:undefined,Symbol=context.Symbol,Uint8Array=context.Uint8Array,allocUnsafe=Buffer?Buffer.allocUnsafe:undefined,getPrototype=overArg(Object.getPrototypeOf,Object),objectCreate=Object.create,propertyIsEnumerable=objectProto.propertyIsEnumerable,splice=arrayProto.splice,spreadableSymbol=Symbol?Symbol.isConcatSpreadable:undefined,symIterator=Symbol?Symbol.iterator:undefined,symToStringTag=Symbol?Symbol.toStringTag:undefined;var defineProperty=function(){try{var func=getNative(Object,'defineProperty');func({},'',{});return func;}catch(e){}}();/** Mocked built-ins. */var ctxClearTimeout=context.clearTimeout!==root.clearTimeout&&context.clearTimeout,ctxNow=Date&&Date.now!==root.Date.now&&Date.now,ctxSetTimeout=context.setTimeout!==root.setTimeout&&context.setTimeout;/* Built-in method references for those with the same name as other `lodash` methods. */var nativeCeil=Math.ceil,nativeFloor=Math.floor,nativeGetSymbols=Object.getOwnPropertySymbols,nativeIsBuffer=Buffer?Buffer.isBuffer:undefined,nativeIsFinite=context.isFinite,nativeJoin=arrayProto.join,nativeKeys=overArg(Object.keys,Object),nativeMax=Math.max,nativeMin=Math.min,nativeNow=Date.now,nativeParseInt=context.parseInt,nativeRandom=Math.random,nativeReverse=arrayProto.reverse;/* Built-in method references that are verified to be native. */var DataView=getNative(context,'DataView'),Map=getNative(context,'Map'),Promise=getNative(context,'Promise'),Set=getNative(context,'Set'),WeakMap=getNative(context,'WeakMap'),nativeCreate=getNative(Object,'create');/** Used to store function metadata. */var metaMap=WeakMap&&new WeakMap();/** Used to lookup unminified function names. */var realNames={};/** Used to detect maps, sets, and weakmaps. */var dataViewCtorString=toSource(DataView),mapCtorString=toSource(Map),promiseCtorString=toSource(Promise),setCtorString=toSource(Set),weakMapCtorString=toSource(WeakMap);/** Used to convert symbols to primitives and strings. */var symbolProto=Symbol?Symbol.prototype:undefined,symbolValueOf=symbolProto?symbolProto.valueOf:undefined,symbolToString=symbolProto?symbolProto.toString:undefined;/*------------------------------------------------------------------------*//**
     * Creates a `lodash` object which wraps `value` to enable implicit method
     * chain sequences. Methods that operate on and return arrays, collections,
     * and functions can be chained together. Methods that retrieve a single value
     * or may return a primitive value will automatically end the chain sequence
     * and return the unwrapped value. Otherwise, the value must be unwrapped
     * with `_#value`.
     *
     * Explicit chain sequences, which must be unwrapped with `_#value`, may be
     * enabled using `_.chain`.
     *
     * The execution of chained methods is lazy, that is, it's deferred until
     * `_#value` is implicitly or explicitly called.
     *
     * Lazy evaluation allows several methods to support shortcut fusion.
     * Shortcut fusion is an optimization to merge iteratee calls; this avoids
     * the creation of intermediate arrays and can greatly reduce the number of
     * iteratee executions. Sections of a chain sequence qualify for shortcut
     * fusion if the section is applied to an array and iteratees accept only
     * one argument. The heuristic for whether a section qualifies for shortcut
     * fusion is subject to change.
     *
     * Chaining is supported in custom builds as long as the `_#value` method is
     * directly or indirectly included in the build.
     *
     * In addition to lodash methods, wrappers have `Array` and `String` methods.
     *
     * The wrapper `Array` methods are:
     * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`
     *
     * The wrapper `String` methods are:
     * `replace` and `split`
     *
     * The wrapper methods that support shortcut fusion are:
     * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,
     * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,
     * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`
     *
     * The chainable wrapper methods are:
     * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,
     * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,
     * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,
     * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,
     * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,
     * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,
     * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,
     * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,
     * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,
     * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,
     * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,
     * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,
     * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,
     * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,
     * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,
     * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,
     * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,
     * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,
     * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,
     * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,
     * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,
     * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,
     * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,
     * `zipObject`, `zipObjectDeep`, and `zipWith`
     *
     * The wrapper methods that are **not** chainable by default are:
     * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,
     * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `conformsTo`, `deburr`,
     * `defaultTo`, `divide`, `each`, `eachRight`, `endsWith`, `eq`, `escape`,
     * `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`, `findLast`,
     * `findLastIndex`, `findLastKey`, `first`, `floor`, `forEach`, `forEachRight`,
     * `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `get`, `gt`, `gte`, `has`,
     * `hasIn`, `head`, `identity`, `includes`, `indexOf`, `inRange`, `invoke`,
     * `isArguments`, `isArray`, `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`,
     * `isBoolean`, `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`,
     * `isEqualWith`, `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`,
     * `isMap`, `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,
     * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,
     * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,
     * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,
     * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,
     * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,
     * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,
     * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,
     * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,
     * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,
     * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,
     * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,
     * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,
     * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,
     * `upperFirst`, `value`, and `words`
     *
     * @name _
     * @constructor
     * @category Seq
     * @param {*} value The value to wrap in a `lodash` instance.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var wrapped = _([1, 2, 3]);
     *
     * // Returns an unwrapped value.
     * wrapped.reduce(_.add);
     * // => 6
     *
     * // Returns a wrapped value.
     * var squares = wrapped.map(square);
     *
     * _.isArray(squares);
     * // => false
     *
     * _.isArray(squares.value());
     * // => true
     */function lodash(value){if(isObjectLike(value)&&!isArray(value)&&!(value instanceof LazyWrapper)){if(value instanceof LodashWrapper){return value;}if(hasOwnProperty.call(value,'__wrapped__')){return wrapperClone(value);}}return new LodashWrapper(value);}/**
     * The base implementation of `_.create` without support for assigning
     * properties to the created object.
     *
     * @private
     * @param {Object} proto The object to inherit from.
     * @returns {Object} Returns the new object.
     */var baseCreate=function(){function object(){}return function(proto){if(!isObject(proto)){return{};}if(objectCreate){return objectCreate(proto);}object.prototype=proto;var result=new object();object.prototype=undefined;return result;};}();/**
     * The function whose prototype chain sequence wrappers inherit from.
     *
     * @private
     */function baseLodash(){}// No operation performed.
/**
     * The base constructor for creating `lodash` wrapper objects.
     *
     * @private
     * @param {*} value The value to wrap.
     * @param {boolean} [chainAll] Enable explicit method chain sequences.
     */function LodashWrapper(value,chainAll){this.__wrapped__=value;this.__actions__=[];this.__chain__=!!chainAll;this.__index__=0;this.__values__=undefined;}/**
     * By default, the template delimiters used by lodash are like those in
     * embedded Ruby (ERB) as well as ES2015 template strings. Change the
     * following template settings to use alternative delimiters.
     *
     * @static
     * @memberOf _
     * @type {Object}
     */lodash.templateSettings={/**
       * Used to detect `data` property values to be HTML-escaped.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */'escape':reEscape,/**
       * Used to detect code to be evaluated.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */'evaluate':reEvaluate,/**
       * Used to detect `data` property values to inject.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */'interpolate':reInterpolate,/**
       * Used to reference the data object in the template text.
       *
       * @memberOf _.templateSettings
       * @type {string}
       */'variable':'',/**
       * Used to import variables into the compiled template.
       *
       * @memberOf _.templateSettings
       * @type {Object}
       */'imports':{/**
         * A reference to the `lodash` function.
         *
         * @memberOf _.templateSettings.imports
         * @type {Function}
         */'_':lodash}};// Ensure wrappers are instances of `baseLodash`.
lodash.prototype=baseLodash.prototype;lodash.prototype.constructor=lodash;LodashWrapper.prototype=baseCreate(baseLodash.prototype);LodashWrapper.prototype.constructor=LodashWrapper;/*------------------------------------------------------------------------*//**
     * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
     *
     * @private
     * @constructor
     * @param {*} value The value to wrap.
     */function LazyWrapper(value){this.__wrapped__=value;this.__actions__=[];this.__dir__=1;this.__filtered__=false;this.__iteratees__=[];this.__takeCount__=MAX_ARRAY_LENGTH;this.__views__=[];}/**
     * Creates a clone of the lazy wrapper object.
     *
     * @private
     * @name clone
     * @memberOf LazyWrapper
     * @returns {Object} Returns the cloned `LazyWrapper` object.
     */function lazyClone(){var result=new LazyWrapper(this.__wrapped__);result.__actions__=copyArray(this.__actions__);result.__dir__=this.__dir__;result.__filtered__=this.__filtered__;result.__iteratees__=copyArray(this.__iteratees__);result.__takeCount__=this.__takeCount__;result.__views__=copyArray(this.__views__);return result;}/**
     * Reverses the direction of lazy iteration.
     *
     * @private
     * @name reverse
     * @memberOf LazyWrapper
     * @returns {Object} Returns the new reversed `LazyWrapper` object.
     */function lazyReverse(){if(this.__filtered__){var result=new LazyWrapper(this);result.__dir__=-1;result.__filtered__=true;}else{result=this.clone();result.__dir__*=-1;}return result;}/**
     * Extracts the unwrapped value from its lazy wrapper.
     *
     * @private
     * @name value
     * @memberOf LazyWrapper
     * @returns {*} Returns the unwrapped value.
     */function lazyValue(){var array=this.__wrapped__.value(),dir=this.__dir__,isArr=isArray(array),isRight=dir<0,arrLength=isArr?array.length:0,view=getView(0,arrLength,this.__views__),start=view.start,end=view.end,length=end-start,index=isRight?end:start-1,iteratees=this.__iteratees__,iterLength=iteratees.length,resIndex=0,takeCount=nativeMin(length,this.__takeCount__);if(!isArr||!isRight&&arrLength==length&&takeCount==length){return baseWrapperValue(array,this.__actions__);}var result=[];outer:while(length--&&resIndex<takeCount){index+=dir;var iterIndex=-1,value=array[index];while(++iterIndex<iterLength){var data=iteratees[iterIndex],iteratee=data.iteratee,type=data.type,computed=iteratee(value);if(type==LAZY_MAP_FLAG){value=computed;}else if(!computed){if(type==LAZY_FILTER_FLAG){continue outer;}else{break outer;}}}result[resIndex++]=value;}return result;}// Ensure `LazyWrapper` is an instance of `baseLodash`.
LazyWrapper.prototype=baseCreate(baseLodash.prototype);LazyWrapper.prototype.constructor=LazyWrapper;/*------------------------------------------------------------------------*//**
     * Creates a hash object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */function Hash(entries){var index=-1,length=entries==null?0:entries.length;this.clear();while(++index<length){var entry=entries[index];this.set(entry[0],entry[1]);}}/**
     * Removes all key-value entries from the hash.
     *
     * @private
     * @name clear
     * @memberOf Hash
     */function hashClear(){this.__data__=nativeCreate?nativeCreate(null):{};this.size=0;}/**
     * Removes `key` and its value from the hash.
     *
     * @private
     * @name delete
     * @memberOf Hash
     * @param {Object} hash The hash to modify.
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */function hashDelete(key){var result=this.has(key)&&delete this.__data__[key];this.size-=result?1:0;return result;}/**
     * Gets the hash value for `key`.
     *
     * @private
     * @name get
     * @memberOf Hash
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */function hashGet(key){var data=this.__data__;if(nativeCreate){var result=data[key];return result===HASH_UNDEFINED?undefined:result;}return hasOwnProperty.call(data,key)?data[key]:undefined;}/**
     * Checks if a hash value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Hash
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */function hashHas(key){var data=this.__data__;return nativeCreate?data[key]!==undefined:hasOwnProperty.call(data,key);}/**
     * Sets the hash `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Hash
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the hash instance.
     */function hashSet(key,value){var data=this.__data__;this.size+=this.has(key)?0:1;data[key]=nativeCreate&&value===undefined?HASH_UNDEFINED:value;return this;}// Add methods to `Hash`.
Hash.prototype.clear=hashClear;Hash.prototype['delete']=hashDelete;Hash.prototype.get=hashGet;Hash.prototype.has=hashHas;Hash.prototype.set=hashSet;/*------------------------------------------------------------------------*//**
     * Creates an list cache object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */function ListCache(entries){var index=-1,length=entries==null?0:entries.length;this.clear();while(++index<length){var entry=entries[index];this.set(entry[0],entry[1]);}}/**
     * Removes all key-value entries from the list cache.
     *
     * @private
     * @name clear
     * @memberOf ListCache
     */function listCacheClear(){this.__data__=[];this.size=0;}/**
     * Removes `key` and its value from the list cache.
     *
     * @private
     * @name delete
     * @memberOf ListCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */function listCacheDelete(key){var data=this.__data__,index=assocIndexOf(data,key);if(index<0){return false;}var lastIndex=data.length-1;if(index==lastIndex){data.pop();}else{splice.call(data,index,1);}--this.size;return true;}/**
     * Gets the list cache value for `key`.
     *
     * @private
     * @name get
     * @memberOf ListCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */function listCacheGet(key){var data=this.__data__,index=assocIndexOf(data,key);return index<0?undefined:data[index][1];}/**
     * Checks if a list cache value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf ListCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */function listCacheHas(key){return assocIndexOf(this.__data__,key)>-1;}/**
     * Sets the list cache `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf ListCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the list cache instance.
     */function listCacheSet(key,value){var data=this.__data__,index=assocIndexOf(data,key);if(index<0){++this.size;data.push([key,value]);}else{data[index][1]=value;}return this;}// Add methods to `ListCache`.
ListCache.prototype.clear=listCacheClear;ListCache.prototype['delete']=listCacheDelete;ListCache.prototype.get=listCacheGet;ListCache.prototype.has=listCacheHas;ListCache.prototype.set=listCacheSet;/*------------------------------------------------------------------------*//**
     * Creates a map cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */function MapCache(entries){var index=-1,length=entries==null?0:entries.length;this.clear();while(++index<length){var entry=entries[index];this.set(entry[0],entry[1]);}}/**
     * Removes all key-value entries from the map.
     *
     * @private
     * @name clear
     * @memberOf MapCache
     */function mapCacheClear(){this.size=0;this.__data__={'hash':new Hash(),'map':new(Map||ListCache)(),'string':new Hash()};}/**
     * Removes `key` and its value from the map.
     *
     * @private
     * @name delete
     * @memberOf MapCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */function mapCacheDelete(key){var result=getMapData(this,key)['delete'](key);this.size-=result?1:0;return result;}/**
     * Gets the map value for `key`.
     *
     * @private
     * @name get
     * @memberOf MapCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */function mapCacheGet(key){return getMapData(this,key).get(key);}/**
     * Checks if a map value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf MapCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */function mapCacheHas(key){return getMapData(this,key).has(key);}/**
     * Sets the map `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf MapCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the map cache instance.
     */function mapCacheSet(key,value){var data=getMapData(this,key),size=data.size;data.set(key,value);this.size+=data.size==size?0:1;return this;}// Add methods to `MapCache`.
MapCache.prototype.clear=mapCacheClear;MapCache.prototype['delete']=mapCacheDelete;MapCache.prototype.get=mapCacheGet;MapCache.prototype.has=mapCacheHas;MapCache.prototype.set=mapCacheSet;/*------------------------------------------------------------------------*//**
     *
     * Creates an array cache object to store unique values.
     *
     * @private
     * @constructor
     * @param {Array} [values] The values to cache.
     */function SetCache(values){var index=-1,length=values==null?0:values.length;this.__data__=new MapCache();while(++index<length){this.add(values[index]);}}/**
     * Adds `value` to the array cache.
     *
     * @private
     * @name add
     * @memberOf SetCache
     * @alias push
     * @param {*} value The value to cache.
     * @returns {Object} Returns the cache instance.
     */function setCacheAdd(value){this.__data__.set(value,HASH_UNDEFINED);return this;}/**
     * Checks if `value` is in the array cache.
     *
     * @private
     * @name has
     * @memberOf SetCache
     * @param {*} value The value to search for.
     * @returns {number} Returns `true` if `value` is found, else `false`.
     */function setCacheHas(value){return this.__data__.has(value);}// Add methods to `SetCache`.
SetCache.prototype.add=SetCache.prototype.push=setCacheAdd;SetCache.prototype.has=setCacheHas;/*------------------------------------------------------------------------*//**
     * Creates a stack cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */function Stack(entries){var data=this.__data__=new ListCache(entries);this.size=data.size;}/**
     * Removes all key-value entries from the stack.
     *
     * @private
     * @name clear
     * @memberOf Stack
     */function stackClear(){this.__data__=new ListCache();this.size=0;}/**
     * Removes `key` and its value from the stack.
     *
     * @private
     * @name delete
     * @memberOf Stack
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */function stackDelete(key){var data=this.__data__,result=data['delete'](key);this.size=data.size;return result;}/**
     * Gets the stack value for `key`.
     *
     * @private
     * @name get
     * @memberOf Stack
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */function stackGet(key){return this.__data__.get(key);}/**
     * Checks if a stack value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Stack
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */function stackHas(key){return this.__data__.has(key);}/**
     * Sets the stack `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Stack
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the stack cache instance.
     */function stackSet(key,value){var data=this.__data__;if(data instanceof ListCache){var pairs=data.__data__;if(!Map||pairs.length<LARGE_ARRAY_SIZE-1){pairs.push([key,value]);this.size=++data.size;return this;}data=this.__data__=new MapCache(pairs);}data.set(key,value);this.size=data.size;return this;}// Add methods to `Stack`.
Stack.prototype.clear=stackClear;Stack.prototype['delete']=stackDelete;Stack.prototype.get=stackGet;Stack.prototype.has=stackHas;Stack.prototype.set=stackSet;/*------------------------------------------------------------------------*//**
     * Creates an array of the enumerable property names of the array-like `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @param {boolean} inherited Specify returning inherited property names.
     * @returns {Array} Returns the array of property names.
     */function arrayLikeKeys(value,inherited){var isArr=isArray(value),isArg=!isArr&&isArguments(value),isBuff=!isArr&&!isArg&&isBuffer(value),isType=!isArr&&!isArg&&!isBuff&&isTypedArray(value),skipIndexes=isArr||isArg||isBuff||isType,result=skipIndexes?baseTimes(value.length,String):[],length=result.length;for(var key in value){if((inherited||hasOwnProperty.call(value,key))&&!(skipIndexes&&(// Safari 9 has enumerable `arguments.length` in strict mode.
key=='length'||// Node.js 0.10 has enumerable non-index properties on buffers.
isBuff&&(key=='offset'||key=='parent')||// PhantomJS 2 has enumerable non-index properties on typed arrays.
isType&&(key=='buffer'||key=='byteLength'||key=='byteOffset')||// Skip index properties.
isIndex(key,length)))){result.push(key);}}return result;}/**
     * A specialized version of `_.sample` for arrays.
     *
     * @private
     * @param {Array} array The array to sample.
     * @returns {*} Returns the random element.
     */function arraySample(array){var length=array.length;return length?array[baseRandom(0,length-1)]:undefined;}/**
     * A specialized version of `_.sampleSize` for arrays.
     *
     * @private
     * @param {Array} array The array to sample.
     * @param {number} n The number of elements to sample.
     * @returns {Array} Returns the random elements.
     */function arraySampleSize(array,n){return shuffleSelf(copyArray(array),baseClamp(n,0,array.length));}/**
     * A specialized version of `_.shuffle` for arrays.
     *
     * @private
     * @param {Array} array The array to shuffle.
     * @returns {Array} Returns the new shuffled array.
     */function arrayShuffle(array){return shuffleSelf(copyArray(array));}/**
     * This function is like `assignValue` except that it doesn't assign
     * `undefined` values.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */function assignMergeValue(object,key,value){if(value!==undefined&&!eq(object[key],value)||value===undefined&&!(key in object)){baseAssignValue(object,key,value);}}/**
     * Assigns `value` to `key` of `object` if the existing value is not equivalent
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */function assignValue(object,key,value){var objValue=object[key];if(!(hasOwnProperty.call(object,key)&&eq(objValue,value))||value===undefined&&!(key in object)){baseAssignValue(object,key,value);}}/**
     * Gets the index at which the `key` is found in `array` of key-value pairs.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {*} key The key to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */function assocIndexOf(array,key){var length=array.length;while(length--){if(eq(array[length][0],key)){return length;}}return-1;}/**
     * Aggregates elements of `collection` on `accumulator` with keys transformed
     * by `iteratee` and values set by `setter`.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} setter The function to set `accumulator` values.
     * @param {Function} iteratee The iteratee to transform keys.
     * @param {Object} accumulator The initial aggregated object.
     * @returns {Function} Returns `accumulator`.
     */function baseAggregator(collection,setter,iteratee,accumulator){baseEach(collection,function(value,key,collection){setter(accumulator,value,iteratee(value),collection);});return accumulator;}/**
     * The base implementation of `_.assign` without support for multiple sources
     * or `customizer` functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @returns {Object} Returns `object`.
     */function baseAssign(object,source){return object&&copyObject(source,keys(source),object);}/**
     * The base implementation of `_.assignIn` without support for multiple sources
     * or `customizer` functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @returns {Object} Returns `object`.
     */function baseAssignIn(object,source){return object&&copyObject(source,keysIn(source),object);}/**
     * The base implementation of `assignValue` and `assignMergeValue` without
     * value checks.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */function baseAssignValue(object,key,value){if(key=='__proto__'&&defineProperty){defineProperty(object,key,{'configurable':true,'enumerable':true,'value':value,'writable':true});}else{object[key]=value;}}/**
     * The base implementation of `_.at` without support for individual paths.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {string[]} paths The property paths to pick.
     * @returns {Array} Returns the picked elements.
     */function baseAt(object,paths){var index=-1,length=paths.length,result=Array(length),skip=object==null;while(++index<length){result[index]=skip?undefined:get(object,paths[index]);}return result;}/**
     * The base implementation of `_.clamp` which doesn't coerce arguments.
     *
     * @private
     * @param {number} number The number to clamp.
     * @param {number} [lower] The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the clamped number.
     */function baseClamp(number,lower,upper){if(number===number){if(upper!==undefined){number=number<=upper?number:upper;}if(lower!==undefined){number=number>=lower?number:lower;}}return number;}/**
     * The base implementation of `_.clone` and `_.cloneDeep` which tracks
     * traversed objects.
     *
     * @private
     * @param {*} value The value to clone.
     * @param {boolean} bitmask The bitmask flags.
     *  1 - Deep clone
     *  2 - Flatten inherited properties
     *  4 - Clone symbols
     * @param {Function} [customizer] The function to customize cloning.
     * @param {string} [key] The key of `value`.
     * @param {Object} [object] The parent object of `value`.
     * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
     * @returns {*} Returns the cloned value.
     */function baseClone(value,bitmask,customizer,key,object,stack){var result,isDeep=bitmask&CLONE_DEEP_FLAG,isFlat=bitmask&CLONE_FLAT_FLAG,isFull=bitmask&CLONE_SYMBOLS_FLAG;if(customizer){result=object?customizer(value,key,object,stack):customizer(value);}if(result!==undefined){return result;}if(!isObject(value)){return value;}var isArr=isArray(value);if(isArr){result=initCloneArray(value);if(!isDeep){return copyArray(value,result);}}else{var tag=getTag(value),isFunc=tag==funcTag||tag==genTag;if(isBuffer(value)){return cloneBuffer(value,isDeep);}if(tag==objectTag||tag==argsTag||isFunc&&!object){result=isFlat||isFunc?{}:initCloneObject(value);if(!isDeep){return isFlat?copySymbolsIn(value,baseAssignIn(result,value)):copySymbols(value,baseAssign(result,value));}}else{if(!cloneableTags[tag]){return object?value:{};}result=initCloneByTag(value,tag,baseClone,isDeep);}}// Check for circular references and return its corresponding clone.
stack||(stack=new Stack());var stacked=stack.get(value);if(stacked){return stacked;}stack.set(value,result);var keysFunc=isFull?isFlat?getAllKeysIn:getAllKeys:isFlat?keysIn:keys;var props=isArr?undefined:keysFunc(value);arrayEach(props||value,function(subValue,key){if(props){key=subValue;subValue=value[key];}// Recursively populate clone (susceptible to call stack limits).
assignValue(result,key,baseClone(subValue,bitmask,customizer,key,value,stack));});return result;}/**
     * The base implementation of `_.conforms` which doesn't clone `source`.
     *
     * @private
     * @param {Object} source The object of property predicates to conform to.
     * @returns {Function} Returns the new spec function.
     */function baseConforms(source){var props=keys(source);return function(object){return baseConformsTo(object,source,props);};}/**
     * The base implementation of `_.conformsTo` which accepts `props` to check.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property predicates to conform to.
     * @returns {boolean} Returns `true` if `object` conforms, else `false`.
     */function baseConformsTo(object,source,props){var length=props.length;if(object==null){return!length;}object=Object(object);while(length--){var key=props[length],predicate=source[key],value=object[key];if(value===undefined&&!(key in object)||!predicate(value)){return false;}}return true;}/**
     * The base implementation of `_.delay` and `_.defer` which accepts `args`
     * to provide to `func`.
     *
     * @private
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @param {Array} args The arguments to provide to `func`.
     * @returns {number|Object} Returns the timer id or timeout object.
     */function baseDelay(func,wait,args){if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}return setTimeout(function(){func.apply(undefined,args);},wait);}/**
     * The base implementation of methods like `_.difference` without support
     * for excluding multiple arrays or iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Array} values The values to exclude.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     */function baseDifference(array,values,iteratee,comparator){var index=-1,includes=arrayIncludes,isCommon=true,length=array.length,result=[],valuesLength=values.length;if(!length){return result;}if(iteratee){values=arrayMap(values,baseUnary(iteratee));}if(comparator){includes=arrayIncludesWith;isCommon=false;}else if(values.length>=LARGE_ARRAY_SIZE){includes=cacheHas;isCommon=false;values=new SetCache(values);}outer:while(++index<length){var value=array[index],computed=iteratee==null?value:iteratee(value);value=comparator||value!==0?value:0;if(isCommon&&computed===computed){var valuesIndex=valuesLength;while(valuesIndex--){if(values[valuesIndex]===computed){continue outer;}}result.push(value);}else if(!includes(values,computed,comparator)){result.push(value);}}return result;}/**
     * The base implementation of `_.forEach` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     */var baseEach=createBaseEach(baseForOwn);/**
     * The base implementation of `_.forEachRight` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     */var baseEachRight=createBaseEach(baseForOwnRight,true);/**
     * The base implementation of `_.every` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`
     */function baseEvery(collection,predicate){var result=true;baseEach(collection,function(value,index,collection){result=!!predicate(value,index,collection);return result;});return result;}/**
     * The base implementation of methods like `_.max` and `_.min` which accepts a
     * `comparator` to determine the extremum value.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The iteratee invoked per iteration.
     * @param {Function} comparator The comparator used to compare values.
     * @returns {*} Returns the extremum value.
     */function baseExtremum(array,iteratee,comparator){var index=-1,length=array.length;while(++index<length){var value=array[index],current=iteratee(value);if(current!=null&&(computed===undefined?current===current&&!isSymbol(current):comparator(current,computed))){var computed=current,result=value;}}return result;}/**
     * The base implementation of `_.fill` without an iteratee call guard.
     *
     * @private
     * @param {Array} array The array to fill.
     * @param {*} value The value to fill `array` with.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns `array`.
     */function baseFill(array,value,start,end){var length=array.length;start=toInteger(start);if(start<0){start=-start>length?0:length+start;}end=end===undefined||end>length?length:toInteger(end);if(end<0){end+=length;}end=start>end?0:toLength(end);while(start<end){array[start++]=value;}return array;}/**
     * The base implementation of `_.filter` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     */function baseFilter(collection,predicate){var result=[];baseEach(collection,function(value,index,collection){if(predicate(value,index,collection)){result.push(value);}});return result;}/**
     * The base implementation of `_.flatten` with support for restricting flattening.
     *
     * @private
     * @param {Array} array The array to flatten.
     * @param {number} depth The maximum recursion depth.
     * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
     * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
     * @param {Array} [result=[]] The initial result value.
     * @returns {Array} Returns the new flattened array.
     */function baseFlatten(array,depth,predicate,isStrict,result){var index=-1,length=array.length;predicate||(predicate=isFlattenable);result||(result=[]);while(++index<length){var value=array[index];if(depth>0&&predicate(value)){if(depth>1){// Recursively flatten arrays (susceptible to call stack limits).
baseFlatten(value,depth-1,predicate,isStrict,result);}else{arrayPush(result,value);}}else if(!isStrict){result[result.length]=value;}}return result;}/**
     * The base implementation of `baseForOwn` which iterates over `object`
     * properties returned by `keysFunc` and invokes `iteratee` for each property.
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @returns {Object} Returns `object`.
     */var baseFor=createBaseFor();/**
     * This function is like `baseFor` except that it iterates over properties
     * in the opposite order.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @returns {Object} Returns `object`.
     */var baseForRight=createBaseFor(true);/**
     * The base implementation of `_.forOwn` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */function baseForOwn(object,iteratee){return object&&baseFor(object,iteratee,keys);}/**
     * The base implementation of `_.forOwnRight` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */function baseForOwnRight(object,iteratee){return object&&baseForRight(object,iteratee,keys);}/**
     * The base implementation of `_.functions` which creates an array of
     * `object` function property names filtered from `props`.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Array} props The property names to filter.
     * @returns {Array} Returns the function names.
     */function baseFunctions(object,props){return arrayFilter(props,function(key){return isFunction(object[key]);});}/**
     * The base implementation of `_.get` without support for default values.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @returns {*} Returns the resolved value.
     */function baseGet(object,path){path=castPath(path,object);var index=0,length=path.length;while(object!=null&&index<length){object=object[toKey(path[index++])];}return index&&index==length?object:undefined;}/**
     * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
     * `keysFunc` and `symbolsFunc` to get the enumerable property names and
     * symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @param {Function} symbolsFunc The function to get the symbols of `object`.
     * @returns {Array} Returns the array of property names and symbols.
     */function baseGetAllKeys(object,keysFunc,symbolsFunc){var result=keysFunc(object);return isArray(object)?result:arrayPush(result,symbolsFunc(object));}/**
     * The base implementation of `getTag` without fallbacks for buggy environments.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */function baseGetTag(value){if(value==null){return value===undefined?undefinedTag:nullTag;}return symToStringTag&&symToStringTag in Object(value)?getRawTag(value):objectToString(value);}/**
     * The base implementation of `_.gt` which doesn't coerce arguments.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than `other`,
     *  else `false`.
     */function baseGt(value,other){return value>other;}/**
     * The base implementation of `_.has` without support for deep paths.
     *
     * @private
     * @param {Object} [object] The object to query.
     * @param {Array|string} key The key to check.
     * @returns {boolean} Returns `true` if `key` exists, else `false`.
     */function baseHas(object,key){return object!=null&&hasOwnProperty.call(object,key);}/**
     * The base implementation of `_.hasIn` without support for deep paths.
     *
     * @private
     * @param {Object} [object] The object to query.
     * @param {Array|string} key The key to check.
     * @returns {boolean} Returns `true` if `key` exists, else `false`.
     */function baseHasIn(object,key){return object!=null&&key in Object(object);}/**
     * The base implementation of `_.inRange` which doesn't coerce arguments.
     *
     * @private
     * @param {number} number The number to check.
     * @param {number} start The start of the range.
     * @param {number} end The end of the range.
     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
     */function baseInRange(number,start,end){return number>=nativeMin(start,end)&&number<nativeMax(start,end);}/**
     * The base implementation of methods like `_.intersection`, without support
     * for iteratee shorthands, that accepts an array of arrays to inspect.
     *
     * @private
     * @param {Array} arrays The arrays to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of shared values.
     */function baseIntersection(arrays,iteratee,comparator){var includes=comparator?arrayIncludesWith:arrayIncludes,length=arrays[0].length,othLength=arrays.length,othIndex=othLength,caches=Array(othLength),maxLength=Infinity,result=[];while(othIndex--){var array=arrays[othIndex];if(othIndex&&iteratee){array=arrayMap(array,baseUnary(iteratee));}maxLength=nativeMin(array.length,maxLength);caches[othIndex]=!comparator&&(iteratee||length>=120&&array.length>=120)?new SetCache(othIndex&&array):undefined;}array=arrays[0];var index=-1,seen=caches[0];outer:while(++index<length&&result.length<maxLength){var value=array[index],computed=iteratee?iteratee(value):value;value=comparator||value!==0?value:0;if(!(seen?cacheHas(seen,computed):includes(result,computed,comparator))){othIndex=othLength;while(--othIndex){var cache=caches[othIndex];if(!(cache?cacheHas(cache,computed):includes(arrays[othIndex],computed,comparator))){continue outer;}}if(seen){seen.push(computed);}result.push(value);}}return result;}/**
     * The base implementation of `_.invert` and `_.invertBy` which inverts
     * `object` with values transformed by `iteratee` and set by `setter`.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} setter The function to set `accumulator` values.
     * @param {Function} iteratee The iteratee to transform values.
     * @param {Object} accumulator The initial inverted object.
     * @returns {Function} Returns `accumulator`.
     */function baseInverter(object,setter,iteratee,accumulator){baseForOwn(object,function(value,key,object){setter(accumulator,iteratee(value),key,object);});return accumulator;}/**
     * The base implementation of `_.invoke` without support for individual
     * method arguments.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the method to invoke.
     * @param {Array} args The arguments to invoke the method with.
     * @returns {*} Returns the result of the invoked method.
     */function baseInvoke(object,path,args){path=castPath(path,object);object=parent(object,path);var func=object==null?object:object[toKey(last(path))];return func==null?undefined:apply(func,object,args);}/**
     * The base implementation of `_.isArguments`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     */function baseIsArguments(value){return isObjectLike(value)&&baseGetTag(value)==argsTag;}/**
     * The base implementation of `_.isArrayBuffer` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
     */function baseIsArrayBuffer(value){return isObjectLike(value)&&baseGetTag(value)==arrayBufferTag;}/**
     * The base implementation of `_.isDate` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
     */function baseIsDate(value){return isObjectLike(value)&&baseGetTag(value)==dateTag;}/**
     * The base implementation of `_.isEqual` which supports partial comparisons
     * and tracks traversed objects.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {boolean} bitmask The bitmask flags.
     *  1 - Unordered comparison
     *  2 - Partial comparison
     * @param {Function} [customizer] The function to customize comparisons.
     * @param {Object} [stack] Tracks traversed `value` and `other` objects.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     */function baseIsEqual(value,other,bitmask,customizer,stack){if(value===other){return true;}if(value==null||other==null||!isObjectLike(value)&&!isObjectLike(other)){return value!==value&&other!==other;}return baseIsEqualDeep(value,other,bitmask,customizer,baseIsEqual,stack);}/**
     * A specialized version of `baseIsEqual` for arrays and objects which performs
     * deep comparisons and tracks traversed objects enabling objects with circular
     * references to be compared.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} [stack] Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */function baseIsEqualDeep(object,other,bitmask,customizer,equalFunc,stack){var objIsArr=isArray(object),othIsArr=isArray(other),objTag=objIsArr?arrayTag:getTag(object),othTag=othIsArr?arrayTag:getTag(other);objTag=objTag==argsTag?objectTag:objTag;othTag=othTag==argsTag?objectTag:othTag;var objIsObj=objTag==objectTag,othIsObj=othTag==objectTag,isSameTag=objTag==othTag;if(isSameTag&&isBuffer(object)){if(!isBuffer(other)){return false;}objIsArr=true;objIsObj=false;}if(isSameTag&&!objIsObj){stack||(stack=new Stack());return objIsArr||isTypedArray(object)?equalArrays(object,other,bitmask,customizer,equalFunc,stack):equalByTag(object,other,objTag,bitmask,customizer,equalFunc,stack);}if(!(bitmask&COMPARE_PARTIAL_FLAG)){var objIsWrapped=objIsObj&&hasOwnProperty.call(object,'__wrapped__'),othIsWrapped=othIsObj&&hasOwnProperty.call(other,'__wrapped__');if(objIsWrapped||othIsWrapped){var objUnwrapped=objIsWrapped?object.value():object,othUnwrapped=othIsWrapped?other.value():other;stack||(stack=new Stack());return equalFunc(objUnwrapped,othUnwrapped,bitmask,customizer,stack);}}if(!isSameTag){return false;}stack||(stack=new Stack());return equalObjects(object,other,bitmask,customizer,equalFunc,stack);}/**
     * The base implementation of `_.isMap` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
     */function baseIsMap(value){return isObjectLike(value)&&getTag(value)==mapTag;}/**
     * The base implementation of `_.isMatch` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @param {Array} matchData The property names, values, and compare flags to match.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     */function baseIsMatch(object,source,matchData,customizer){var index=matchData.length,length=index,noCustomizer=!customizer;if(object==null){return!length;}object=Object(object);while(index--){var data=matchData[index];if(noCustomizer&&data[2]?data[1]!==object[data[0]]:!(data[0]in object)){return false;}}while(++index<length){data=matchData[index];var key=data[0],objValue=object[key],srcValue=data[1];if(noCustomizer&&data[2]){if(objValue===undefined&&!(key in object)){return false;}}else{var stack=new Stack();if(customizer){var result=customizer(objValue,srcValue,key,object,source,stack);}if(!(result===undefined?baseIsEqual(srcValue,objValue,COMPARE_PARTIAL_FLAG|COMPARE_UNORDERED_FLAG,customizer,stack):result)){return false;}}}return true;}/**
     * The base implementation of `_.isNative` without bad shim checks.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function,
     *  else `false`.
     */function baseIsNative(value){if(!isObject(value)||isMasked(value)){return false;}var pattern=isFunction(value)?reIsNative:reIsHostCtor;return pattern.test(toSource(value));}/**
     * The base implementation of `_.isRegExp` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
     */function baseIsRegExp(value){return isObjectLike(value)&&baseGetTag(value)==regexpTag;}/**
     * The base implementation of `_.isSet` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
     */function baseIsSet(value){return isObjectLike(value)&&getTag(value)==setTag;}/**
     * The base implementation of `_.isTypedArray` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     */function baseIsTypedArray(value){return isObjectLike(value)&&isLength(value.length)&&!!typedArrayTags[baseGetTag(value)];}/**
     * The base implementation of `_.iteratee`.
     *
     * @private
     * @param {*} [value=_.identity] The value to convert to an iteratee.
     * @returns {Function} Returns the iteratee.
     */function baseIteratee(value){// Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
// See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
if(typeof value=='function'){return value;}if(value==null){return identity;}if(typeof value=='object'){return isArray(value)?baseMatchesProperty(value[0],value[1]):baseMatches(value);}return property(value);}/**
     * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */function baseKeys(object){if(!isPrototype(object)){return nativeKeys(object);}var result=[];for(var key in Object(object)){if(hasOwnProperty.call(object,key)&&key!='constructor'){result.push(key);}}return result;}/**
     * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */function baseKeysIn(object){if(!isObject(object)){return nativeKeysIn(object);}var isProto=isPrototype(object),result=[];for(var key in object){if(!(key=='constructor'&&(isProto||!hasOwnProperty.call(object,key)))){result.push(key);}}return result;}/**
     * The base implementation of `_.lt` which doesn't coerce arguments.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than `other`,
     *  else `false`.
     */function baseLt(value,other){return value<other;}/**
     * The base implementation of `_.map` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     */function baseMap(collection,iteratee){var index=-1,result=isArrayLike(collection)?Array(collection.length):[];baseEach(collection,function(value,key,collection){result[++index]=iteratee(value,key,collection);});return result;}/**
     * The base implementation of `_.matches` which doesn't clone `source`.
     *
     * @private
     * @param {Object} source The object of property values to match.
     * @returns {Function} Returns the new spec function.
     */function baseMatches(source){var matchData=getMatchData(source);if(matchData.length==1&&matchData[0][2]){return matchesStrictComparable(matchData[0][0],matchData[0][1]);}return function(object){return object===source||baseIsMatch(object,source,matchData);};}/**
     * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
     *
     * @private
     * @param {string} path The path of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     */function baseMatchesProperty(path,srcValue){if(isKey(path)&&isStrictComparable(srcValue)){return matchesStrictComparable(toKey(path),srcValue);}return function(object){var objValue=get(object,path);return objValue===undefined&&objValue===srcValue?hasIn(object,path):baseIsEqual(srcValue,objValue,COMPARE_PARTIAL_FLAG|COMPARE_UNORDERED_FLAG);};}/**
     * The base implementation of `_.merge` without support for multiple sources.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {number} srcIndex The index of `source`.
     * @param {Function} [customizer] The function to customize merged values.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     */function baseMerge(object,source,srcIndex,customizer,stack){if(object===source){return;}baseFor(source,function(srcValue,key){if(isObject(srcValue)){stack||(stack=new Stack());baseMergeDeep(object,source,key,srcIndex,baseMerge,customizer,stack);}else{var newValue=customizer?customizer(object[key],srcValue,key+'',object,source,stack):undefined;if(newValue===undefined){newValue=srcValue;}assignMergeValue(object,key,newValue);}},keysIn);}/**
     * A specialized version of `baseMerge` for arrays and objects which performs
     * deep merges and tracks traversed objects enabling objects with circular
     * references to be merged.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {string} key The key of the value to merge.
     * @param {number} srcIndex The index of `source`.
     * @param {Function} mergeFunc The function to merge values.
     * @param {Function} [customizer] The function to customize assigned values.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     */function baseMergeDeep(object,source,key,srcIndex,mergeFunc,customizer,stack){var objValue=object[key],srcValue=source[key],stacked=stack.get(srcValue);if(stacked){assignMergeValue(object,key,stacked);return;}var newValue=customizer?customizer(objValue,srcValue,key+'',object,source,stack):undefined;var isCommon=newValue===undefined;if(isCommon){var isArr=isArray(srcValue),isBuff=!isArr&&isBuffer(srcValue),isTyped=!isArr&&!isBuff&&isTypedArray(srcValue);newValue=srcValue;if(isArr||isBuff||isTyped){if(isArray(objValue)){newValue=objValue;}else if(isArrayLikeObject(objValue)){newValue=copyArray(objValue);}else if(isBuff){isCommon=false;newValue=cloneBuffer(srcValue,true);}else if(isTyped){isCommon=false;newValue=cloneTypedArray(srcValue,true);}else{newValue=[];}}else if(isPlainObject(srcValue)||isArguments(srcValue)){newValue=objValue;if(isArguments(objValue)){newValue=toPlainObject(objValue);}else if(!isObject(objValue)||srcIndex&&isFunction(objValue)){newValue=initCloneObject(srcValue);}}else{isCommon=false;}}if(isCommon){// Recursively merge objects and arrays (susceptible to call stack limits).
stack.set(srcValue,newValue);mergeFunc(newValue,srcValue,srcIndex,customizer,stack);stack['delete'](srcValue);}assignMergeValue(object,key,newValue);}/**
     * The base implementation of `_.nth` which doesn't coerce arguments.
     *
     * @private
     * @param {Array} array The array to query.
     * @param {number} n The index of the element to return.
     * @returns {*} Returns the nth element of `array`.
     */function baseNth(array,n){var length=array.length;if(!length){return;}n+=n<0?length:0;return isIndex(n,length)?array[n]:undefined;}/**
     * The base implementation of `_.orderBy` without param guards.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
     * @param {string[]} orders The sort orders of `iteratees`.
     * @returns {Array} Returns the new sorted array.
     */function baseOrderBy(collection,iteratees,orders){var index=-1;iteratees=arrayMap(iteratees.length?iteratees:[identity],baseUnary(getIteratee()));var result=baseMap(collection,function(value,key,collection){var criteria=arrayMap(iteratees,function(iteratee){return iteratee(value);});return{'criteria':criteria,'index':++index,'value':value};});return baseSortBy(result,function(object,other){return compareMultiple(object,other,orders);});}/**
     * The base implementation of `_.pick` without support for individual
     * property identifiers.
     *
     * @private
     * @param {Object} object The source object.
     * @param {string[]} paths The property paths to pick.
     * @returns {Object} Returns the new object.
     */function basePick(object,paths){return basePickBy(object,paths,function(value,path){return hasIn(object,path);});}/**
     * The base implementation of  `_.pickBy` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The source object.
     * @param {string[]} paths The property paths to pick.
     * @param {Function} predicate The function invoked per property.
     * @returns {Object} Returns the new object.
     */function basePickBy(object,paths,predicate){var index=-1,length=paths.length,result={};while(++index<length){var path=paths[index],value=baseGet(object,path);if(predicate(value,path)){baseSet(result,castPath(path,object),value);}}return result;}/**
     * A specialized version of `baseProperty` which supports deep paths.
     *
     * @private
     * @param {Array|string} path The path of the property to get.
     * @returns {Function} Returns the new accessor function.
     */function basePropertyDeep(path){return function(object){return baseGet(object,path);};}/**
     * The base implementation of `_.pullAllBy` without support for iteratee
     * shorthands.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns `array`.
     */function basePullAll(array,values,iteratee,comparator){var indexOf=comparator?baseIndexOfWith:baseIndexOf,index=-1,length=values.length,seen=array;if(array===values){values=copyArray(values);}if(iteratee){seen=arrayMap(array,baseUnary(iteratee));}while(++index<length){var fromIndex=0,value=values[index],computed=iteratee?iteratee(value):value;while((fromIndex=indexOf(seen,computed,fromIndex,comparator))>-1){if(seen!==array){splice.call(seen,fromIndex,1);}splice.call(array,fromIndex,1);}}return array;}/**
     * The base implementation of `_.pullAt` without support for individual
     * indexes or capturing the removed elements.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {number[]} indexes The indexes of elements to remove.
     * @returns {Array} Returns `array`.
     */function basePullAt(array,indexes){var length=array?indexes.length:0,lastIndex=length-1;while(length--){var index=indexes[length];if(length==lastIndex||index!==previous){var previous=index;if(isIndex(index)){splice.call(array,index,1);}else{baseUnset(array,index);}}}return array;}/**
     * The base implementation of `_.random` without support for returning
     * floating-point numbers.
     *
     * @private
     * @param {number} lower The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the random number.
     */function baseRandom(lower,upper){return lower+nativeFloor(nativeRandom()*(upper-lower+1));}/**
     * The base implementation of `_.range` and `_.rangeRight` which doesn't
     * coerce arguments.
     *
     * @private
     * @param {number} start The start of the range.
     * @param {number} end The end of the range.
     * @param {number} step The value to increment or decrement by.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Array} Returns the range of numbers.
     */function baseRange(start,end,step,fromRight){var index=-1,length=nativeMax(nativeCeil((end-start)/(step||1)),0),result=Array(length);while(length--){result[fromRight?length:++index]=start;start+=step;}return result;}/**
     * The base implementation of `_.repeat` which doesn't coerce arguments.
     *
     * @private
     * @param {string} string The string to repeat.
     * @param {number} n The number of times to repeat the string.
     * @returns {string} Returns the repeated string.
     */function baseRepeat(string,n){var result='';if(!string||n<1||n>MAX_SAFE_INTEGER){return result;}// Leverage the exponentiation by squaring algorithm for a faster repeat.
// See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
do{if(n%2){result+=string;}n=nativeFloor(n/2);if(n){string+=string;}}while(n);return result;}/**
     * The base implementation of `_.rest` which doesn't validate or coerce arguments.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @returns {Function} Returns the new function.
     */function baseRest(func,start){return setToString(overRest(func,start,identity),func+'');}/**
     * The base implementation of `_.sample`.
     *
     * @private
     * @param {Array|Object} collection The collection to sample.
     * @returns {*} Returns the random element.
     */function baseSample(collection){return arraySample(values(collection));}/**
     * The base implementation of `_.sampleSize` without param guards.
     *
     * @private
     * @param {Array|Object} collection The collection to sample.
     * @param {number} n The number of elements to sample.
     * @returns {Array} Returns the random elements.
     */function baseSampleSize(collection,n){var array=values(collection);return shuffleSelf(array,baseClamp(n,0,array.length));}/**
     * The base implementation of `_.set`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @param {Function} [customizer] The function to customize path creation.
     * @returns {Object} Returns `object`.
     */function baseSet(object,path,value,customizer){if(!isObject(object)){return object;}path=castPath(path,object);var index=-1,length=path.length,lastIndex=length-1,nested=object;while(nested!=null&&++index<length){var key=toKey(path[index]),newValue=value;if(index!=lastIndex){var objValue=nested[key];newValue=customizer?customizer(objValue,key,nested):undefined;if(newValue===undefined){newValue=isObject(objValue)?objValue:isIndex(path[index+1])?[]:{};}}assignValue(nested,key,newValue);nested=nested[key];}return object;}/**
     * The base implementation of `setData` without support for hot loop shorting.
     *
     * @private
     * @param {Function} func The function to associate metadata with.
     * @param {*} data The metadata.
     * @returns {Function} Returns `func`.
     */var baseSetData=!metaMap?identity:function(func,data){metaMap.set(func,data);return func;};/**
     * The base implementation of `setToString` without support for hot loop shorting.
     *
     * @private
     * @param {Function} func The function to modify.
     * @param {Function} string The `toString` result.
     * @returns {Function} Returns `func`.
     */var baseSetToString=!defineProperty?identity:function(func,string){return defineProperty(func,'toString',{'configurable':true,'enumerable':false,'value':constant(string),'writable':true});};/**
     * The base implementation of `_.shuffle`.
     *
     * @private
     * @param {Array|Object} collection The collection to shuffle.
     * @returns {Array} Returns the new shuffled array.
     */function baseShuffle(collection){return shuffleSelf(values(collection));}/**
     * The base implementation of `_.slice` without an iteratee call guard.
     *
     * @private
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the slice of `array`.
     */function baseSlice(array,start,end){var index=-1,length=array.length;if(start<0){start=-start>length?0:length+start;}end=end>length?length:end;if(end<0){end+=length;}length=start>end?0:end-start>>>0;start>>>=0;var result=Array(length);while(++index<length){result[index]=array[index+start];}return result;}/**
     * The base implementation of `_.some` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     */function baseSome(collection,predicate){var result;baseEach(collection,function(value,index,collection){result=predicate(value,index,collection);return!result;});return!!result;}/**
     * The base implementation of `_.sortedIndex` and `_.sortedLastIndex` which
     * performs a binary search of `array` to determine the index at which `value`
     * should be inserted into `array` in order to maintain its sort order.
     *
     * @private
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {boolean} [retHighest] Specify returning the highest qualified index.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     */function baseSortedIndex(array,value,retHighest){var low=0,high=array==null?low:array.length;if(typeof value=='number'&&value===value&&high<=HALF_MAX_ARRAY_LENGTH){while(low<high){var mid=low+high>>>1,computed=array[mid];if(computed!==null&&!isSymbol(computed)&&(retHighest?computed<=value:computed<value)){low=mid+1;}else{high=mid;}}return high;}return baseSortedIndexBy(array,value,identity,retHighest);}/**
     * The base implementation of `_.sortedIndexBy` and `_.sortedLastIndexBy`
     * which invokes `iteratee` for `value` and each element of `array` to compute
     * their sort ranking. The iteratee is invoked with one argument; (value).
     *
     * @private
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} iteratee The iteratee invoked per element.
     * @param {boolean} [retHighest] Specify returning the highest qualified index.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     */function baseSortedIndexBy(array,value,iteratee,retHighest){value=iteratee(value);var low=0,high=array==null?0:array.length,valIsNaN=value!==value,valIsNull=value===null,valIsSymbol=isSymbol(value),valIsUndefined=value===undefined;while(low<high){var mid=nativeFloor((low+high)/2),computed=iteratee(array[mid]),othIsDefined=computed!==undefined,othIsNull=computed===null,othIsReflexive=computed===computed,othIsSymbol=isSymbol(computed);if(valIsNaN){var setLow=retHighest||othIsReflexive;}else if(valIsUndefined){setLow=othIsReflexive&&(retHighest||othIsDefined);}else if(valIsNull){setLow=othIsReflexive&&othIsDefined&&(retHighest||!othIsNull);}else if(valIsSymbol){setLow=othIsReflexive&&othIsDefined&&!othIsNull&&(retHighest||!othIsSymbol);}else if(othIsNull||othIsSymbol){setLow=false;}else{setLow=retHighest?computed<=value:computed<value;}if(setLow){low=mid+1;}else{high=mid;}}return nativeMin(high,MAX_ARRAY_INDEX);}/**
     * The base implementation of `_.sortedUniq` and `_.sortedUniqBy` without
     * support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     */function baseSortedUniq(array,iteratee){var index=-1,length=array.length,resIndex=0,result=[];while(++index<length){var value=array[index],computed=iteratee?iteratee(value):value;if(!index||!eq(computed,seen)){var seen=computed;result[resIndex++]=value===0?0:value;}}return result;}/**
     * The base implementation of `_.toNumber` which doesn't ensure correct
     * conversions of binary, hexadecimal, or octal string values.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {number} Returns the number.
     */function baseToNumber(value){if(typeof value=='number'){return value;}if(isSymbol(value)){return NAN;}return+value;}/**
     * The base implementation of `_.toString` which doesn't convert nullish
     * values to empty strings.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {string} Returns the string.
     */function baseToString(value){// Exit early for strings to avoid a performance hit in some environments.
if(typeof value=='string'){return value;}if(isArray(value)){// Recursively convert values (susceptible to call stack limits).
return arrayMap(value,baseToString)+'';}if(isSymbol(value)){return symbolToString?symbolToString.call(value):'';}var result=value+'';return result=='0'&&1/value==-INFINITY?'-0':result;}/**
     * The base implementation of `_.uniqBy` without support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     */function baseUniq(array,iteratee,comparator){var index=-1,includes=arrayIncludes,length=array.length,isCommon=true,result=[],seen=result;if(comparator){isCommon=false;includes=arrayIncludesWith;}else if(length>=LARGE_ARRAY_SIZE){var set=iteratee?null:createSet(array);if(set){return setToArray(set);}isCommon=false;includes=cacheHas;seen=new SetCache();}else{seen=iteratee?[]:result;}outer:while(++index<length){var value=array[index],computed=iteratee?iteratee(value):value;value=comparator||value!==0?value:0;if(isCommon&&computed===computed){var seenIndex=seen.length;while(seenIndex--){if(seen[seenIndex]===computed){continue outer;}}if(iteratee){seen.push(computed);}result.push(value);}else if(!includes(seen,computed,comparator)){if(seen!==result){seen.push(computed);}result.push(value);}}return result;}/**
     * The base implementation of `_.unset`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The property path to unset.
     * @returns {boolean} Returns `true` if the property is deleted, else `false`.
     */function baseUnset(object,path){path=castPath(path,object);object=parent(object,path);return object==null||delete object[toKey(last(path))];}/**
     * The base implementation of `_.update`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to update.
     * @param {Function} updater The function to produce the updated value.
     * @param {Function} [customizer] The function to customize path creation.
     * @returns {Object} Returns `object`.
     */function baseUpdate(object,path,updater,customizer){return baseSet(object,path,updater(baseGet(object,path)),customizer);}/**
     * The base implementation of methods like `_.dropWhile` and `_.takeWhile`
     * without support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to query.
     * @param {Function} predicate The function invoked per iteration.
     * @param {boolean} [isDrop] Specify dropping elements instead of taking them.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Array} Returns the slice of `array`.
     */function baseWhile(array,predicate,isDrop,fromRight){var length=array.length,index=fromRight?length:-1;while((fromRight?index--:++index<length)&&predicate(array[index],index,array)){}return isDrop?baseSlice(array,fromRight?0:index,fromRight?index+1:length):baseSlice(array,fromRight?index+1:0,fromRight?length:index);}/**
     * The base implementation of `wrapperValue` which returns the result of
     * performing a sequence of actions on the unwrapped `value`, where each
     * successive action is supplied the return value of the previous.
     *
     * @private
     * @param {*} value The unwrapped value.
     * @param {Array} actions Actions to perform to resolve the unwrapped value.
     * @returns {*} Returns the resolved value.
     */function baseWrapperValue(value,actions){var result=value;if(result instanceof LazyWrapper){result=result.value();}return arrayReduce(actions,function(result,action){return action.func.apply(action.thisArg,arrayPush([result],action.args));},result);}/**
     * The base implementation of methods like `_.xor`, without support for
     * iteratee shorthands, that accepts an array of arrays to inspect.
     *
     * @private
     * @param {Array} arrays The arrays to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of values.
     */function baseXor(arrays,iteratee,comparator){var length=arrays.length;if(length<2){return length?baseUniq(arrays[0]):[];}var index=-1,result=Array(length);while(++index<length){var array=arrays[index],othIndex=-1;while(++othIndex<length){if(othIndex!=index){result[index]=baseDifference(result[index]||array,arrays[othIndex],iteratee,comparator);}}}return baseUniq(baseFlatten(result,1),iteratee,comparator);}/**
     * This base implementation of `_.zipObject` which assigns values using `assignFunc`.
     *
     * @private
     * @param {Array} props The property identifiers.
     * @param {Array} values The property values.
     * @param {Function} assignFunc The function to assign values.
     * @returns {Object} Returns the new object.
     */function baseZipObject(props,values,assignFunc){var index=-1,length=props.length,valsLength=values.length,result={};while(++index<length){var value=index<valsLength?values[index]:undefined;assignFunc(result,props[index],value);}return result;}/**
     * Casts `value` to an empty array if it's not an array like object.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {Array|Object} Returns the cast array-like object.
     */function castArrayLikeObject(value){return isArrayLikeObject(value)?value:[];}/**
     * Casts `value` to `identity` if it's not a function.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {Function} Returns cast function.
     */function castFunction(value){return typeof value=='function'?value:identity;}/**
     * Casts `value` to a path array if it's not one.
     *
     * @private
     * @param {*} value The value to inspect.
     * @param {Object} [object] The object to query keys on.
     * @returns {Array} Returns the cast property path array.
     */function castPath(value,object){if(isArray(value)){return value;}return isKey(value,object)?[value]:stringToPath(toString(value));}/**
     * A `baseRest` alias which can be replaced with `identity` by module
     * replacement plugins.
     *
     * @private
     * @type {Function}
     * @param {Function} func The function to apply a rest parameter to.
     * @returns {Function} Returns the new function.
     */var castRest=baseRest;/**
     * Casts `array` to a slice if it's needed.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {number} start The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the cast slice.
     */function castSlice(array,start,end){var length=array.length;end=end===undefined?length:end;return!start&&end>=length?array:baseSlice(array,start,end);}/**
     * A simple wrapper around the global [`clearTimeout`](https://mdn.io/clearTimeout).
     *
     * @private
     * @param {number|Object} id The timer id or timeout object of the timer to clear.
     */var clearTimeout=ctxClearTimeout||function(id){return root.clearTimeout(id);};/**
     * Creates a clone of  `buffer`.
     *
     * @private
     * @param {Buffer} buffer The buffer to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Buffer} Returns the cloned buffer.
     */function cloneBuffer(buffer,isDeep){if(isDeep){return buffer.slice();}var length=buffer.length,result=allocUnsafe?allocUnsafe(length):new buffer.constructor(length);buffer.copy(result);return result;}/**
     * Creates a clone of `arrayBuffer`.
     *
     * @private
     * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
     * @returns {ArrayBuffer} Returns the cloned array buffer.
     */function cloneArrayBuffer(arrayBuffer){var result=new arrayBuffer.constructor(arrayBuffer.byteLength);new Uint8Array(result).set(new Uint8Array(arrayBuffer));return result;}/**
     * Creates a clone of `dataView`.
     *
     * @private
     * @param {Object} dataView The data view to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the cloned data view.
     */function cloneDataView(dataView,isDeep){var buffer=isDeep?cloneArrayBuffer(dataView.buffer):dataView.buffer;return new dataView.constructor(buffer,dataView.byteOffset,dataView.byteLength);}/**
     * Creates a clone of `map`.
     *
     * @private
     * @param {Object} map The map to clone.
     * @param {Function} cloneFunc The function to clone values.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the cloned map.
     */function cloneMap(map,isDeep,cloneFunc){var array=isDeep?cloneFunc(mapToArray(map),CLONE_DEEP_FLAG):mapToArray(map);return arrayReduce(array,addMapEntry,new map.constructor());}/**
     * Creates a clone of `regexp`.
     *
     * @private
     * @param {Object} regexp The regexp to clone.
     * @returns {Object} Returns the cloned regexp.
     */function cloneRegExp(regexp){var result=new regexp.constructor(regexp.source,reFlags.exec(regexp));result.lastIndex=regexp.lastIndex;return result;}/**
     * Creates a clone of `set`.
     *
     * @private
     * @param {Object} set The set to clone.
     * @param {Function} cloneFunc The function to clone values.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the cloned set.
     */function cloneSet(set,isDeep,cloneFunc){var array=isDeep?cloneFunc(setToArray(set),CLONE_DEEP_FLAG):setToArray(set);return arrayReduce(array,addSetEntry,new set.constructor());}/**
     * Creates a clone of the `symbol` object.
     *
     * @private
     * @param {Object} symbol The symbol object to clone.
     * @returns {Object} Returns the cloned symbol object.
     */function cloneSymbol(symbol){return symbolValueOf?Object(symbolValueOf.call(symbol)):{};}/**
     * Creates a clone of `typedArray`.
     *
     * @private
     * @param {Object} typedArray The typed array to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the cloned typed array.
     */function cloneTypedArray(typedArray,isDeep){var buffer=isDeep?cloneArrayBuffer(typedArray.buffer):typedArray.buffer;return new typedArray.constructor(buffer,typedArray.byteOffset,typedArray.length);}/**
     * Compares values to sort them in ascending order.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {number} Returns the sort order indicator for `value`.
     */function compareAscending(value,other){if(value!==other){var valIsDefined=value!==undefined,valIsNull=value===null,valIsReflexive=value===value,valIsSymbol=isSymbol(value);var othIsDefined=other!==undefined,othIsNull=other===null,othIsReflexive=other===other,othIsSymbol=isSymbol(other);if(!othIsNull&&!othIsSymbol&&!valIsSymbol&&value>other||valIsSymbol&&othIsDefined&&othIsReflexive&&!othIsNull&&!othIsSymbol||valIsNull&&othIsDefined&&othIsReflexive||!valIsDefined&&othIsReflexive||!valIsReflexive){return 1;}if(!valIsNull&&!valIsSymbol&&!othIsSymbol&&value<other||othIsSymbol&&valIsDefined&&valIsReflexive&&!valIsNull&&!valIsSymbol||othIsNull&&valIsDefined&&valIsReflexive||!othIsDefined&&valIsReflexive||!othIsReflexive){return-1;}}return 0;}/**
     * Used by `_.orderBy` to compare multiple properties of a value to another
     * and stable sort them.
     *
     * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
     * specify an order of "desc" for descending or "asc" for ascending sort order
     * of corresponding values.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {boolean[]|string[]} orders The order to sort by for each property.
     * @returns {number} Returns the sort order indicator for `object`.
     */function compareMultiple(object,other,orders){var index=-1,objCriteria=object.criteria,othCriteria=other.criteria,length=objCriteria.length,ordersLength=orders.length;while(++index<length){var result=compareAscending(objCriteria[index],othCriteria[index]);if(result){if(index>=ordersLength){return result;}var order=orders[index];return result*(order=='desc'?-1:1);}}// Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
// that causes it, under certain circumstances, to provide the same value for
// `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
// for more details.
//
// This also ensures a stable sort in V8 and other engines.
// See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.
return object.index-other.index;}/**
     * Creates an array that is the composition of partially applied arguments,
     * placeholders, and provided arguments into a single array of arguments.
     *
     * @private
     * @param {Array} args The provided arguments.
     * @param {Array} partials The arguments to prepend to those provided.
     * @param {Array} holders The `partials` placeholder indexes.
     * @params {boolean} [isCurried] Specify composing for a curried function.
     * @returns {Array} Returns the new array of composed arguments.
     */function composeArgs(args,partials,holders,isCurried){var argsIndex=-1,argsLength=args.length,holdersLength=holders.length,leftIndex=-1,leftLength=partials.length,rangeLength=nativeMax(argsLength-holdersLength,0),result=Array(leftLength+rangeLength),isUncurried=!isCurried;while(++leftIndex<leftLength){result[leftIndex]=partials[leftIndex];}while(++argsIndex<holdersLength){if(isUncurried||argsIndex<argsLength){result[holders[argsIndex]]=args[argsIndex];}}while(rangeLength--){result[leftIndex++]=args[argsIndex++];}return result;}/**
     * This function is like `composeArgs` except that the arguments composition
     * is tailored for `_.partialRight`.
     *
     * @private
     * @param {Array} args The provided arguments.
     * @param {Array} partials The arguments to append to those provided.
     * @param {Array} holders The `partials` placeholder indexes.
     * @params {boolean} [isCurried] Specify composing for a curried function.
     * @returns {Array} Returns the new array of composed arguments.
     */function composeArgsRight(args,partials,holders,isCurried){var argsIndex=-1,argsLength=args.length,holdersIndex=-1,holdersLength=holders.length,rightIndex=-1,rightLength=partials.length,rangeLength=nativeMax(argsLength-holdersLength,0),result=Array(rangeLength+rightLength),isUncurried=!isCurried;while(++argsIndex<rangeLength){result[argsIndex]=args[argsIndex];}var offset=argsIndex;while(++rightIndex<rightLength){result[offset+rightIndex]=partials[rightIndex];}while(++holdersIndex<holdersLength){if(isUncurried||argsIndex<argsLength){result[offset+holders[holdersIndex]]=args[argsIndex++];}}return result;}/**
     * Copies the values of `source` to `array`.
     *
     * @private
     * @param {Array} source The array to copy values from.
     * @param {Array} [array=[]] The array to copy values to.
     * @returns {Array} Returns `array`.
     */function copyArray(source,array){var index=-1,length=source.length;array||(array=Array(length));while(++index<length){array[index]=source[index];}return array;}/**
     * Copies properties of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy properties from.
     * @param {Array} props The property identifiers to copy.
     * @param {Object} [object={}] The object to copy properties to.
     * @param {Function} [customizer] The function to customize copied values.
     * @returns {Object} Returns `object`.
     */function copyObject(source,props,object,customizer){var isNew=!object;object||(object={});var index=-1,length=props.length;while(++index<length){var key=props[index];var newValue=customizer?customizer(object[key],source[key],key,object,source):undefined;if(newValue===undefined){newValue=source[key];}if(isNew){baseAssignValue(object,key,newValue);}else{assignValue(object,key,newValue);}}return object;}/**
     * Copies own symbols of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy symbols from.
     * @param {Object} [object={}] The object to copy symbols to.
     * @returns {Object} Returns `object`.
     */function copySymbols(source,object){return copyObject(source,getSymbols(source),object);}/**
     * Copies own and inherited symbols of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy symbols from.
     * @param {Object} [object={}] The object to copy symbols to.
     * @returns {Object} Returns `object`.
     */function copySymbolsIn(source,object){return copyObject(source,getSymbolsIn(source),object);}/**
     * Creates a function like `_.groupBy`.
     *
     * @private
     * @param {Function} setter The function to set accumulator values.
     * @param {Function} [initializer] The accumulator object initializer.
     * @returns {Function} Returns the new aggregator function.
     */function createAggregator(setter,initializer){return function(collection,iteratee){var func=isArray(collection)?arrayAggregator:baseAggregator,accumulator=initializer?initializer():{};return func(collection,setter,getIteratee(iteratee,2),accumulator);};}/**
     * Creates a function like `_.assign`.
     *
     * @private
     * @param {Function} assigner The function to assign values.
     * @returns {Function} Returns the new assigner function.
     */function createAssigner(assigner){return baseRest(function(object,sources){var index=-1,length=sources.length,customizer=length>1?sources[length-1]:undefined,guard=length>2?sources[2]:undefined;customizer=assigner.length>3&&typeof customizer=='function'?(length--,customizer):undefined;if(guard&&isIterateeCall(sources[0],sources[1],guard)){customizer=length<3?undefined:customizer;length=1;}object=Object(object);while(++index<length){var source=sources[index];if(source){assigner(object,source,index,customizer);}}return object;});}/**
     * Creates a `baseEach` or `baseEachRight` function.
     *
     * @private
     * @param {Function} eachFunc The function to iterate over a collection.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new base function.
     */function createBaseEach(eachFunc,fromRight){return function(collection,iteratee){if(collection==null){return collection;}if(!isArrayLike(collection)){return eachFunc(collection,iteratee);}var length=collection.length,index=fromRight?length:-1,iterable=Object(collection);while(fromRight?index--:++index<length){if(iteratee(iterable[index],index,iterable)===false){break;}}return collection;};}/**
     * Creates a base function for methods like `_.forIn` and `_.forOwn`.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new base function.
     */function createBaseFor(fromRight){return function(object,iteratee,keysFunc){var index=-1,iterable=Object(object),props=keysFunc(object),length=props.length;while(length--){var key=props[fromRight?length:++index];if(iteratee(iterable[key],key,iterable)===false){break;}}return object;};}/**
     * Creates a function that wraps `func` to invoke it with the optional `this`
     * binding of `thisArg`.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @returns {Function} Returns the new wrapped function.
     */function createBind(func,bitmask,thisArg){var isBind=bitmask&WRAP_BIND_FLAG,Ctor=createCtor(func);function wrapper(){var fn=this&&this!==root&&this instanceof wrapper?Ctor:func;return fn.apply(isBind?thisArg:this,arguments);}return wrapper;}/**
     * Creates a function like `_.lowerFirst`.
     *
     * @private
     * @param {string} methodName The name of the `String` case method to use.
     * @returns {Function} Returns the new case function.
     */function createCaseFirst(methodName){return function(string){string=toString(string);var strSymbols=hasUnicode(string)?stringToArray(string):undefined;var chr=strSymbols?strSymbols[0]:string.charAt(0);var trailing=strSymbols?castSlice(strSymbols,1).join(''):string.slice(1);return chr[methodName]()+trailing;};}/**
     * Creates a function like `_.camelCase`.
     *
     * @private
     * @param {Function} callback The function to combine each word.
     * @returns {Function} Returns the new compounder function.
     */function createCompounder(callback){return function(string){return arrayReduce(words(deburr(string).replace(reApos,'')),callback,'');};}/**
     * Creates a function that produces an instance of `Ctor` regardless of
     * whether it was invoked as part of a `new` expression or by `call` or `apply`.
     *
     * @private
     * @param {Function} Ctor The constructor to wrap.
     * @returns {Function} Returns the new wrapped function.
     */function createCtor(Ctor){return function(){// Use a `switch` statement to work with class constructors. See
// http://ecma-international.org/ecma-262/7.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
// for more details.
var args=arguments;switch(args.length){case 0:return new Ctor();case 1:return new Ctor(args[0]);case 2:return new Ctor(args[0],args[1]);case 3:return new Ctor(args[0],args[1],args[2]);case 4:return new Ctor(args[0],args[1],args[2],args[3]);case 5:return new Ctor(args[0],args[1],args[2],args[3],args[4]);case 6:return new Ctor(args[0],args[1],args[2],args[3],args[4],args[5]);case 7:return new Ctor(args[0],args[1],args[2],args[3],args[4],args[5],args[6]);}var thisBinding=baseCreate(Ctor.prototype),result=Ctor.apply(thisBinding,args);// Mimic the constructor's `return` behavior.
// See https://es5.github.io/#x13.2.2 for more details.
return isObject(result)?result:thisBinding;};}/**
     * Creates a function that wraps `func` to enable currying.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {number} arity The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */function createCurry(func,bitmask,arity){var Ctor=createCtor(func);function wrapper(){var length=arguments.length,args=Array(length),index=length,placeholder=getHolder(wrapper);while(index--){args[index]=arguments[index];}var holders=length<3&&args[0]!==placeholder&&args[length-1]!==placeholder?[]:replaceHolders(args,placeholder);length-=holders.length;if(length<arity){return createRecurry(func,bitmask,createHybrid,wrapper.placeholder,undefined,args,holders,undefined,undefined,arity-length);}var fn=this&&this!==root&&this instanceof wrapper?Ctor:func;return apply(fn,this,args);}return wrapper;}/**
     * Creates a `_.find` or `_.findLast` function.
     *
     * @private
     * @param {Function} findIndexFunc The function to find the collection index.
     * @returns {Function} Returns the new find function.
     */function createFind(findIndexFunc){return function(collection,predicate,fromIndex){var iterable=Object(collection);if(!isArrayLike(collection)){var iteratee=getIteratee(predicate,3);collection=keys(collection);predicate=function(key){return iteratee(iterable[key],key,iterable);};}var index=findIndexFunc(collection,predicate,fromIndex);return index>-1?iterable[iteratee?collection[index]:index]:undefined;};}/**
     * Creates a `_.flow` or `_.flowRight` function.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new flow function.
     */function createFlow(fromRight){return flatRest(function(funcs){var length=funcs.length,index=length,prereq=LodashWrapper.prototype.thru;if(fromRight){funcs.reverse();}while(index--){var func=funcs[index];if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}if(prereq&&!wrapper&&getFuncName(func)=='wrapper'){var wrapper=new LodashWrapper([],true);}}index=wrapper?index:length;while(++index<length){func=funcs[index];var funcName=getFuncName(func),data=funcName=='wrapper'?getData(func):undefined;if(data&&isLaziable(data[0])&&data[1]==(WRAP_ARY_FLAG|WRAP_CURRY_FLAG|WRAP_PARTIAL_FLAG|WRAP_REARG_FLAG)&&!data[4].length&&data[9]==1){wrapper=wrapper[getFuncName(data[0])].apply(wrapper,data[3]);}else{wrapper=func.length==1&&isLaziable(func)?wrapper[funcName]():wrapper.thru(func);}}return function(){var args=arguments,value=args[0];if(wrapper&&args.length==1&&isArray(value)){return wrapper.plant(value).value();}var index=0,result=length?funcs[index].apply(this,args):value;while(++index<length){result=funcs[index].call(this,result);}return result;};});}/**
     * Creates a function that wraps `func` to invoke it with optional `this`
     * binding of `thisArg`, partial application, and currying.
     *
     * @private
     * @param {Function|string} func The function or method name to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to prepend to those provided to
     *  the new function.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [partialsRight] The arguments to append to those provided
     *  to the new function.
     * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */function createHybrid(func,bitmask,thisArg,partials,holders,partialsRight,holdersRight,argPos,ary,arity){var isAry=bitmask&WRAP_ARY_FLAG,isBind=bitmask&WRAP_BIND_FLAG,isBindKey=bitmask&WRAP_BIND_KEY_FLAG,isCurried=bitmask&(WRAP_CURRY_FLAG|WRAP_CURRY_RIGHT_FLAG),isFlip=bitmask&WRAP_FLIP_FLAG,Ctor=isBindKey?undefined:createCtor(func);function wrapper(){var length=arguments.length,args=Array(length),index=length;while(index--){args[index]=arguments[index];}if(isCurried){var placeholder=getHolder(wrapper),holdersCount=countHolders(args,placeholder);}if(partials){args=composeArgs(args,partials,holders,isCurried);}if(partialsRight){args=composeArgsRight(args,partialsRight,holdersRight,isCurried);}length-=holdersCount;if(isCurried&&length<arity){var newHolders=replaceHolders(args,placeholder);return createRecurry(func,bitmask,createHybrid,wrapper.placeholder,thisArg,args,newHolders,argPos,ary,arity-length);}var thisBinding=isBind?thisArg:this,fn=isBindKey?thisBinding[func]:func;length=args.length;if(argPos){args=reorder(args,argPos);}else if(isFlip&&length>1){args.reverse();}if(isAry&&ary<length){args.length=ary;}if(this&&this!==root&&this instanceof wrapper){fn=Ctor||createCtor(fn);}return fn.apply(thisBinding,args);}return wrapper;}/**
     * Creates a function like `_.invertBy`.
     *
     * @private
     * @param {Function} setter The function to set accumulator values.
     * @param {Function} toIteratee The function to resolve iteratees.
     * @returns {Function} Returns the new inverter function.
     */function createInverter(setter,toIteratee){return function(object,iteratee){return baseInverter(object,setter,toIteratee(iteratee),{});};}/**
     * Creates a function that performs a mathematical operation on two values.
     *
     * @private
     * @param {Function} operator The function to perform the operation.
     * @param {number} [defaultValue] The value used for `undefined` arguments.
     * @returns {Function} Returns the new mathematical operation function.
     */function createMathOperation(operator,defaultValue){return function(value,other){var result;if(value===undefined&&other===undefined){return defaultValue;}if(value!==undefined){result=value;}if(other!==undefined){if(result===undefined){return other;}if(typeof value=='string'||typeof other=='string'){value=baseToString(value);other=baseToString(other);}else{value=baseToNumber(value);other=baseToNumber(other);}result=operator(value,other);}return result;};}/**
     * Creates a function like `_.over`.
     *
     * @private
     * @param {Function} arrayFunc The function to iterate over iteratees.
     * @returns {Function} Returns the new over function.
     */function createOver(arrayFunc){return flatRest(function(iteratees){iteratees=arrayMap(iteratees,baseUnary(getIteratee()));return baseRest(function(args){var thisArg=this;return arrayFunc(iteratees,function(iteratee){return apply(iteratee,thisArg,args);});});});}/**
     * Creates the padding for `string` based on `length`. The `chars` string
     * is truncated if the number of characters exceeds `length`.
     *
     * @private
     * @param {number} length The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padding for `string`.
     */function createPadding(length,chars){chars=chars===undefined?' ':baseToString(chars);var charsLength=chars.length;if(charsLength<2){return charsLength?baseRepeat(chars,length):chars;}var result=baseRepeat(chars,nativeCeil(length/stringSize(chars)));return hasUnicode(chars)?castSlice(stringToArray(result),0,length).join(''):result.slice(0,length);}/**
     * Creates a function that wraps `func` to invoke it with the `this` binding
     * of `thisArg` and `partials` prepended to the arguments it receives.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {Array} partials The arguments to prepend to those provided to
     *  the new function.
     * @returns {Function} Returns the new wrapped function.
     */function createPartial(func,bitmask,thisArg,partials){var isBind=bitmask&WRAP_BIND_FLAG,Ctor=createCtor(func);function wrapper(){var argsIndex=-1,argsLength=arguments.length,leftIndex=-1,leftLength=partials.length,args=Array(leftLength+argsLength),fn=this&&this!==root&&this instanceof wrapper?Ctor:func;while(++leftIndex<leftLength){args[leftIndex]=partials[leftIndex];}while(argsLength--){args[leftIndex++]=arguments[++argsIndex];}return apply(fn,isBind?thisArg:this,args);}return wrapper;}/**
     * Creates a `_.range` or `_.rangeRight` function.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new range function.
     */function createRange(fromRight){return function(start,end,step){if(step&&typeof step!='number'&&isIterateeCall(start,end,step)){end=step=undefined;}// Ensure the sign of `-0` is preserved.
start=toFinite(start);if(end===undefined){end=start;start=0;}else{end=toFinite(end);}step=step===undefined?start<end?1:-1:toFinite(step);return baseRange(start,end,step,fromRight);};}/**
     * Creates a function that performs a relational operation on two values.
     *
     * @private
     * @param {Function} operator The function to perform the operation.
     * @returns {Function} Returns the new relational operation function.
     */function createRelationalOperation(operator){return function(value,other){if(!(typeof value=='string'&&typeof other=='string')){value=toNumber(value);other=toNumber(other);}return operator(value,other);};}/**
     * Creates a function that wraps `func` to continue currying.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {Function} wrapFunc The function to create the `func` wrapper.
     * @param {*} placeholder The placeholder value.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to prepend to those provided to
     *  the new function.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */function createRecurry(func,bitmask,wrapFunc,placeholder,thisArg,partials,holders,argPos,ary,arity){var isCurry=bitmask&WRAP_CURRY_FLAG,newHolders=isCurry?holders:undefined,newHoldersRight=isCurry?undefined:holders,newPartials=isCurry?partials:undefined,newPartialsRight=isCurry?undefined:partials;bitmask|=isCurry?WRAP_PARTIAL_FLAG:WRAP_PARTIAL_RIGHT_FLAG;bitmask&=~(isCurry?WRAP_PARTIAL_RIGHT_FLAG:WRAP_PARTIAL_FLAG);if(!(bitmask&WRAP_CURRY_BOUND_FLAG)){bitmask&=~(WRAP_BIND_FLAG|WRAP_BIND_KEY_FLAG);}var newData=[func,bitmask,thisArg,newPartials,newHolders,newPartialsRight,newHoldersRight,argPos,ary,arity];var result=wrapFunc.apply(undefined,newData);if(isLaziable(func)){setData(result,newData);}result.placeholder=placeholder;return setWrapToString(result,func,bitmask);}/**
     * Creates a function like `_.round`.
     *
     * @private
     * @param {string} methodName The name of the `Math` method to use when rounding.
     * @returns {Function} Returns the new round function.
     */function createRound(methodName){var func=Math[methodName];return function(number,precision){number=toNumber(number);precision=precision==null?0:nativeMin(toInteger(precision),292);if(precision){// Shift with exponential notation to avoid floating-point issues.
// See [MDN](https://mdn.io/round#Examples) for more details.
var pair=(toString(number)+'e').split('e'),value=func(pair[0]+'e'+(+pair[1]+precision));pair=(toString(value)+'e').split('e');return+(pair[0]+'e'+(+pair[1]-precision));}return func(number);};}/**
     * Creates a set object of `values`.
     *
     * @private
     * @param {Array} values The values to add to the set.
     * @returns {Object} Returns the new set.
     */var createSet=!(Set&&1/setToArray(new Set([,-0]))[1]==INFINITY)?noop:function(values){return new Set(values);};/**
     * Creates a `_.toPairs` or `_.toPairsIn` function.
     *
     * @private
     * @param {Function} keysFunc The function to get the keys of a given object.
     * @returns {Function} Returns the new pairs function.
     */function createToPairs(keysFunc){return function(object){var tag=getTag(object);if(tag==mapTag){return mapToArray(object);}if(tag==setTag){return setToPairs(object);}return baseToPairs(object,keysFunc(object));};}/**
     * Creates a function that either curries or invokes `func` with optional
     * `this` binding and partially applied arguments.
     *
     * @private
     * @param {Function|string} func The function or method name to wrap.
     * @param {number} bitmask The bitmask flags.
     *    1 - `_.bind`
     *    2 - `_.bindKey`
     *    4 - `_.curry` or `_.curryRight` of a bound function
     *    8 - `_.curry`
     *   16 - `_.curryRight`
     *   32 - `_.partial`
     *   64 - `_.partialRight`
     *  128 - `_.rearg`
     *  256 - `_.ary`
     *  512 - `_.flip`
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to be partially applied.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */function createWrap(func,bitmask,thisArg,partials,holders,argPos,ary,arity){var isBindKey=bitmask&WRAP_BIND_KEY_FLAG;if(!isBindKey&&typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}var length=partials?partials.length:0;if(!length){bitmask&=~(WRAP_PARTIAL_FLAG|WRAP_PARTIAL_RIGHT_FLAG);partials=holders=undefined;}ary=ary===undefined?ary:nativeMax(toInteger(ary),0);arity=arity===undefined?arity:toInteger(arity);length-=holders?holders.length:0;if(bitmask&WRAP_PARTIAL_RIGHT_FLAG){var partialsRight=partials,holdersRight=holders;partials=holders=undefined;}var data=isBindKey?undefined:getData(func);var newData=[func,bitmask,thisArg,partials,holders,partialsRight,holdersRight,argPos,ary,arity];if(data){mergeData(newData,data);}func=newData[0];bitmask=newData[1];thisArg=newData[2];partials=newData[3];holders=newData[4];arity=newData[9]=newData[9]===undefined?isBindKey?0:func.length:nativeMax(newData[9]-length,0);if(!arity&&bitmask&(WRAP_CURRY_FLAG|WRAP_CURRY_RIGHT_FLAG)){bitmask&=~(WRAP_CURRY_FLAG|WRAP_CURRY_RIGHT_FLAG);}if(!bitmask||bitmask==WRAP_BIND_FLAG){var result=createBind(func,bitmask,thisArg);}else if(bitmask==WRAP_CURRY_FLAG||bitmask==WRAP_CURRY_RIGHT_FLAG){result=createCurry(func,bitmask,arity);}else if((bitmask==WRAP_PARTIAL_FLAG||bitmask==(WRAP_BIND_FLAG|WRAP_PARTIAL_FLAG))&&!holders.length){result=createPartial(func,bitmask,thisArg,partials);}else{result=createHybrid.apply(undefined,newData);}var setter=data?baseSetData:setData;return setWrapToString(setter(result,newData),func,bitmask);}/**
     * Used by `_.defaults` to customize its `_.assignIn` use to assign properties
     * of source objects to the destination object for all destination properties
     * that resolve to `undefined`.
     *
     * @private
     * @param {*} objValue The destination value.
     * @param {*} srcValue The source value.
     * @param {string} key The key of the property to assign.
     * @param {Object} object The parent object of `objValue`.
     * @returns {*} Returns the value to assign.
     */function customDefaultsAssignIn(objValue,srcValue,key,object){if(objValue===undefined||eq(objValue,objectProto[key])&&!hasOwnProperty.call(object,key)){return srcValue;}return objValue;}/**
     * Used by `_.defaultsDeep` to customize its `_.merge` use to merge source
     * objects into destination objects that are passed thru.
     *
     * @private
     * @param {*} objValue The destination value.
     * @param {*} srcValue The source value.
     * @param {string} key The key of the property to merge.
     * @param {Object} object The parent object of `objValue`.
     * @param {Object} source The parent object of `srcValue`.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     * @returns {*} Returns the value to assign.
     */function customDefaultsMerge(objValue,srcValue,key,object,source,stack){if(isObject(objValue)&&isObject(srcValue)){// Recursively merge objects and arrays (susceptible to call stack limits).
stack.set(srcValue,objValue);baseMerge(objValue,srcValue,undefined,customDefaultsMerge,stack);stack['delete'](srcValue);}return objValue;}/**
     * Used by `_.omit` to customize its `_.cloneDeep` use to only clone plain
     * objects.
     *
     * @private
     * @param {*} value The value to inspect.
     * @param {string} key The key of the property to inspect.
     * @returns {*} Returns the uncloned value or `undefined` to defer cloning to `_.cloneDeep`.
     */function customOmitClone(value){return isPlainObject(value)?undefined:value;}/**
     * A specialized version of `baseIsEqualDeep` for arrays with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Array} array The array to compare.
     * @param {Array} other The other array to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `array` and `other` objects.
     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
     */function equalArrays(array,other,bitmask,customizer,equalFunc,stack){var isPartial=bitmask&COMPARE_PARTIAL_FLAG,arrLength=array.length,othLength=other.length;if(arrLength!=othLength&&!(isPartial&&othLength>arrLength)){return false;}// Assume cyclic values are equal.
var stacked=stack.get(array);if(stacked&&stack.get(other)){return stacked==other;}var index=-1,result=true,seen=bitmask&COMPARE_UNORDERED_FLAG?new SetCache():undefined;stack.set(array,other);stack.set(other,array);// Ignore non-index properties.
while(++index<arrLength){var arrValue=array[index],othValue=other[index];if(customizer){var compared=isPartial?customizer(othValue,arrValue,index,other,array,stack):customizer(arrValue,othValue,index,array,other,stack);}if(compared!==undefined){if(compared){continue;}result=false;break;}// Recursively compare arrays (susceptible to call stack limits).
if(seen){if(!arraySome(other,function(othValue,othIndex){if(!cacheHas(seen,othIndex)&&(arrValue===othValue||equalFunc(arrValue,othValue,bitmask,customizer,stack))){return seen.push(othIndex);}})){result=false;break;}}else if(!(arrValue===othValue||equalFunc(arrValue,othValue,bitmask,customizer,stack))){result=false;break;}}stack['delete'](array);stack['delete'](other);return result;}/**
     * A specialized version of `baseIsEqualDeep` for comparing objects of
     * the same `toStringTag`.
     *
     * **Note:** This function only supports comparing values with tags of
     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {string} tag The `toStringTag` of the objects to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */function equalByTag(object,other,tag,bitmask,customizer,equalFunc,stack){switch(tag){case dataViewTag:if(object.byteLength!=other.byteLength||object.byteOffset!=other.byteOffset){return false;}object=object.buffer;other=other.buffer;case arrayBufferTag:if(object.byteLength!=other.byteLength||!equalFunc(new Uint8Array(object),new Uint8Array(other))){return false;}return true;case boolTag:case dateTag:case numberTag:// Coerce booleans to `1` or `0` and dates to milliseconds.
// Invalid dates are coerced to `NaN`.
return eq(+object,+other);case errorTag:return object.name==other.name&&object.message==other.message;case regexpTag:case stringTag:// Coerce regexes to strings and treat strings, primitives and objects,
// as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
// for more details.
return object==other+'';case mapTag:var convert=mapToArray;case setTag:var isPartial=bitmask&COMPARE_PARTIAL_FLAG;convert||(convert=setToArray);if(object.size!=other.size&&!isPartial){return false;}// Assume cyclic values are equal.
var stacked=stack.get(object);if(stacked){return stacked==other;}bitmask|=COMPARE_UNORDERED_FLAG;// Recursively compare objects (susceptible to call stack limits).
stack.set(object,other);var result=equalArrays(convert(object),convert(other),bitmask,customizer,equalFunc,stack);stack['delete'](object);return result;case symbolTag:if(symbolValueOf){return symbolValueOf.call(object)==symbolValueOf.call(other);}}return false;}/**
     * A specialized version of `baseIsEqualDeep` for objects with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */function equalObjects(object,other,bitmask,customizer,equalFunc,stack){var isPartial=bitmask&COMPARE_PARTIAL_FLAG,objProps=getAllKeys(object),objLength=objProps.length,othProps=getAllKeys(other),othLength=othProps.length;if(objLength!=othLength&&!isPartial){return false;}var index=objLength;while(index--){var key=objProps[index];if(!(isPartial?key in other:hasOwnProperty.call(other,key))){return false;}}// Assume cyclic values are equal.
var stacked=stack.get(object);if(stacked&&stack.get(other)){return stacked==other;}var result=true;stack.set(object,other);stack.set(other,object);var skipCtor=isPartial;while(++index<objLength){key=objProps[index];var objValue=object[key],othValue=other[key];if(customizer){var compared=isPartial?customizer(othValue,objValue,key,other,object,stack):customizer(objValue,othValue,key,object,other,stack);}// Recursively compare objects (susceptible to call stack limits).
if(!(compared===undefined?objValue===othValue||equalFunc(objValue,othValue,bitmask,customizer,stack):compared)){result=false;break;}skipCtor||(skipCtor=key=='constructor');}if(result&&!skipCtor){var objCtor=object.constructor,othCtor=other.constructor;// Non `Object` object instances with different constructors are not equal.
if(objCtor!=othCtor&&'constructor'in object&&'constructor'in other&&!(typeof objCtor=='function'&&objCtor instanceof objCtor&&typeof othCtor=='function'&&othCtor instanceof othCtor)){result=false;}}stack['delete'](object);stack['delete'](other);return result;}/**
     * A specialized version of `baseRest` which flattens the rest array.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @returns {Function} Returns the new function.
     */function flatRest(func){return setToString(overRest(func,undefined,flatten),func+'');}/**
     * Creates an array of own enumerable property names and symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names and symbols.
     */function getAllKeys(object){return baseGetAllKeys(object,keys,getSymbols);}/**
     * Creates an array of own and inherited enumerable property names and
     * symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names and symbols.
     */function getAllKeysIn(object){return baseGetAllKeys(object,keysIn,getSymbolsIn);}/**
     * Gets metadata for `func`.
     *
     * @private
     * @param {Function} func The function to query.
     * @returns {*} Returns the metadata for `func`.
     */var getData=!metaMap?noop:function(func){return metaMap.get(func);};/**
     * Gets the name of `func`.
     *
     * @private
     * @param {Function} func The function to query.
     * @returns {string} Returns the function name.
     */function getFuncName(func){var result=func.name+'',array=realNames[result],length=hasOwnProperty.call(realNames,result)?array.length:0;while(length--){var data=array[length],otherFunc=data.func;if(otherFunc==null||otherFunc==func){return data.name;}}return result;}/**
     * Gets the argument placeholder value for `func`.
     *
     * @private
     * @param {Function} func The function to inspect.
     * @returns {*} Returns the placeholder value.
     */function getHolder(func){var object=hasOwnProperty.call(lodash,'placeholder')?lodash:func;return object.placeholder;}/**
     * Gets the appropriate "iteratee" function. If `_.iteratee` is customized,
     * this function returns the custom method, otherwise it returns `baseIteratee`.
     * If arguments are provided, the chosen function is invoked with them and
     * its result is returned.
     *
     * @private
     * @param {*} [value] The value to convert to an iteratee.
     * @param {number} [arity] The arity of the created iteratee.
     * @returns {Function} Returns the chosen function or its result.
     */function getIteratee(){var result=lodash.iteratee||iteratee;result=result===iteratee?baseIteratee:result;return arguments.length?result(arguments[0],arguments[1]):result;}/**
     * Gets the data for `map`.
     *
     * @private
     * @param {Object} map The map to query.
     * @param {string} key The reference key.
     * @returns {*} Returns the map data.
     */function getMapData(map,key){var data=map.__data__;return isKeyable(key)?data[typeof key=='string'?'string':'hash']:data.map;}/**
     * Gets the property names, values, and compare flags of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the match data of `object`.
     */function getMatchData(object){var result=keys(object),length=result.length;while(length--){var key=result[length],value=object[key];result[length]=[key,value,isStrictComparable(value)];}return result;}/**
     * Gets the native function at `key` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {string} key The key of the method to get.
     * @returns {*} Returns the function if it's native, else `undefined`.
     */function getNative(object,key){var value=getValue(object,key);return baseIsNative(value)?value:undefined;}/**
     * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the raw `toStringTag`.
     */function getRawTag(value){var isOwn=hasOwnProperty.call(value,symToStringTag),tag=value[symToStringTag];try{value[symToStringTag]=undefined;var unmasked=true;}catch(e){}var result=nativeObjectToString.call(value);if(unmasked){if(isOwn){value[symToStringTag]=tag;}else{delete value[symToStringTag];}}return result;}/**
     * Creates an array of the own enumerable symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of symbols.
     */var getSymbols=!nativeGetSymbols?stubArray:function(object){if(object==null){return[];}object=Object(object);return arrayFilter(nativeGetSymbols(object),function(symbol){return propertyIsEnumerable.call(object,symbol);});};/**
     * Creates an array of the own and inherited enumerable symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of symbols.
     */var getSymbolsIn=!nativeGetSymbols?stubArray:function(object){var result=[];while(object){arrayPush(result,getSymbols(object));object=getPrototype(object);}return result;};/**
     * Gets the `toStringTag` of `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */var getTag=baseGetTag;// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
if(DataView&&getTag(new DataView(new ArrayBuffer(1)))!=dataViewTag||Map&&getTag(new Map())!=mapTag||Promise&&getTag(Promise.resolve())!=promiseTag||Set&&getTag(new Set())!=setTag||WeakMap&&getTag(new WeakMap())!=weakMapTag){getTag=function(value){var result=baseGetTag(value),Ctor=result==objectTag?value.constructor:undefined,ctorString=Ctor?toSource(Ctor):'';if(ctorString){switch(ctorString){case dataViewCtorString:return dataViewTag;case mapCtorString:return mapTag;case promiseCtorString:return promiseTag;case setCtorString:return setTag;case weakMapCtorString:return weakMapTag;}}return result;};}/**
     * Gets the view, applying any `transforms` to the `start` and `end` positions.
     *
     * @private
     * @param {number} start The start of the view.
     * @param {number} end The end of the view.
     * @param {Array} transforms The transformations to apply to the view.
     * @returns {Object} Returns an object containing the `start` and `end`
     *  positions of the view.
     */function getView(start,end,transforms){var index=-1,length=transforms.length;while(++index<length){var data=transforms[index],size=data.size;switch(data.type){case'drop':start+=size;break;case'dropRight':end-=size;break;case'take':end=nativeMin(end,start+size);break;case'takeRight':start=nativeMax(start,end-size);break;}}return{'start':start,'end':end};}/**
     * Extracts wrapper details from the `source` body comment.
     *
     * @private
     * @param {string} source The source to inspect.
     * @returns {Array} Returns the wrapper details.
     */function getWrapDetails(source){var match=source.match(reWrapDetails);return match?match[1].split(reSplitDetails):[];}/**
     * Checks if `path` exists on `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @param {Function} hasFunc The function to check properties.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     */function hasPath(object,path,hasFunc){path=castPath(path,object);var index=-1,length=path.length,result=false;while(++index<length){var key=toKey(path[index]);if(!(result=object!=null&&hasFunc(object,key))){break;}object=object[key];}if(result||++index!=length){return result;}length=object==null?0:object.length;return!!length&&isLength(length)&&isIndex(key,length)&&(isArray(object)||isArguments(object));}/**
     * Initializes an array clone.
     *
     * @private
     * @param {Array} array The array to clone.
     * @returns {Array} Returns the initialized clone.
     */function initCloneArray(array){var length=array.length,result=array.constructor(length);// Add properties assigned by `RegExp#exec`.
if(length&&typeof array[0]=='string'&&hasOwnProperty.call(array,'index')){result.index=array.index;result.input=array.input;}return result;}/**
     * Initializes an object clone.
     *
     * @private
     * @param {Object} object The object to clone.
     * @returns {Object} Returns the initialized clone.
     */function initCloneObject(object){return typeof object.constructor=='function'&&!isPrototype(object)?baseCreate(getPrototype(object)):{};}/**
     * Initializes an object clone based on its `toStringTag`.
     *
     * **Note:** This function only supports cloning values with tags of
     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
     *
     * @private
     * @param {Object} object The object to clone.
     * @param {string} tag The `toStringTag` of the object to clone.
     * @param {Function} cloneFunc The function to clone values.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the initialized clone.
     */function initCloneByTag(object,tag,cloneFunc,isDeep){var Ctor=object.constructor;switch(tag){case arrayBufferTag:return cloneArrayBuffer(object);case boolTag:case dateTag:return new Ctor(+object);case dataViewTag:return cloneDataView(object,isDeep);case float32Tag:case float64Tag:case int8Tag:case int16Tag:case int32Tag:case uint8Tag:case uint8ClampedTag:case uint16Tag:case uint32Tag:return cloneTypedArray(object,isDeep);case mapTag:return cloneMap(object,isDeep,cloneFunc);case numberTag:case stringTag:return new Ctor(object);case regexpTag:return cloneRegExp(object);case setTag:return cloneSet(object,isDeep,cloneFunc);case symbolTag:return cloneSymbol(object);}}/**
     * Inserts wrapper `details` in a comment at the top of the `source` body.
     *
     * @private
     * @param {string} source The source to modify.
     * @returns {Array} details The details to insert.
     * @returns {string} Returns the modified source.
     */function insertWrapDetails(source,details){var length=details.length;if(!length){return source;}var lastIndex=length-1;details[lastIndex]=(length>1?'& ':'')+details[lastIndex];details=details.join(length>2?', ':' ');return source.replace(reWrapComment,'{\n/* [wrapped with '+details+'] */\n');}/**
     * Checks if `value` is a flattenable `arguments` object or array.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
     */function isFlattenable(value){return isArray(value)||isArguments(value)||!!(spreadableSymbol&&value&&value[spreadableSymbol]);}/**
     * Checks if `value` is a valid array-like index.
     *
     * @private
     * @param {*} value The value to check.
     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
     */function isIndex(value,length){length=length==null?MAX_SAFE_INTEGER:length;return!!length&&(typeof value=='number'||reIsUint.test(value))&&value>-1&&value%1==0&&value<length;}/**
     * Checks if the given arguments are from an iteratee call.
     *
     * @private
     * @param {*} value The potential iteratee value argument.
     * @param {*} index The potential iteratee index or key argument.
     * @param {*} object The potential iteratee object argument.
     * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
     *  else `false`.
     */function isIterateeCall(value,index,object){if(!isObject(object)){return false;}var type=typeof index;if(type=='number'?isArrayLike(object)&&isIndex(index,object.length):type=='string'&&index in object){return eq(object[index],value);}return false;}/**
     * Checks if `value` is a property name and not a property path.
     *
     * @private
     * @param {*} value The value to check.
     * @param {Object} [object] The object to query keys on.
     * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
     */function isKey(value,object){if(isArray(value)){return false;}var type=typeof value;if(type=='number'||type=='symbol'||type=='boolean'||value==null||isSymbol(value)){return true;}return reIsPlainProp.test(value)||!reIsDeepProp.test(value)||object!=null&&value in Object(object);}/**
     * Checks if `value` is suitable for use as unique object key.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
     */function isKeyable(value){var type=typeof value;return type=='string'||type=='number'||type=='symbol'||type=='boolean'?value!=='__proto__':value===null;}/**
     * Checks if `func` has a lazy counterpart.
     *
     * @private
     * @param {Function} func The function to check.
     * @returns {boolean} Returns `true` if `func` has a lazy counterpart,
     *  else `false`.
     */function isLaziable(func){var funcName=getFuncName(func),other=lodash[funcName];if(typeof other!='function'||!(funcName in LazyWrapper.prototype)){return false;}if(func===other){return true;}var data=getData(other);return!!data&&func===data[0];}/**
     * Checks if `func` has its source masked.
     *
     * @private
     * @param {Function} func The function to check.
     * @returns {boolean} Returns `true` if `func` is masked, else `false`.
     */function isMasked(func){return!!maskSrcKey&&maskSrcKey in func;}/**
     * Checks if `func` is capable of being masked.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `func` is maskable, else `false`.
     */var isMaskable=coreJsData?isFunction:stubFalse;/**
     * Checks if `value` is likely a prototype object.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
     */function isPrototype(value){var Ctor=value&&value.constructor,proto=typeof Ctor=='function'&&Ctor.prototype||objectProto;return value===proto;}/**
     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` if suitable for strict
     *  equality comparisons, else `false`.
     */function isStrictComparable(value){return value===value&&!isObject(value);}/**
     * A specialized version of `matchesProperty` for source values suitable
     * for strict equality comparisons, i.e. `===`.
     *
     * @private
     * @param {string} key The key of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     */function matchesStrictComparable(key,srcValue){return function(object){if(object==null){return false;}return object[key]===srcValue&&(srcValue!==undefined||key in Object(object));};}/**
     * A specialized version of `_.memoize` which clears the memoized function's
     * cache when it exceeds `MAX_MEMOIZE_SIZE`.
     *
     * @private
     * @param {Function} func The function to have its output memoized.
     * @returns {Function} Returns the new memoized function.
     */function memoizeCapped(func){var result=memoize(func,function(key){if(cache.size===MAX_MEMOIZE_SIZE){cache.clear();}return key;});var cache=result.cache;return result;}/**
     * Merges the function metadata of `source` into `data`.
     *
     * Merging metadata reduces the number of wrappers used to invoke a function.
     * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
     * may be applied regardless of execution order. Methods like `_.ary` and
     * `_.rearg` modify function arguments, making the order in which they are
     * executed important, preventing the merging of metadata. However, we make
     * an exception for a safe combined case where curried functions have `_.ary`
     * and or `_.rearg` applied.
     *
     * @private
     * @param {Array} data The destination metadata.
     * @param {Array} source The source metadata.
     * @returns {Array} Returns `data`.
     */function mergeData(data,source){var bitmask=data[1],srcBitmask=source[1],newBitmask=bitmask|srcBitmask,isCommon=newBitmask<(WRAP_BIND_FLAG|WRAP_BIND_KEY_FLAG|WRAP_ARY_FLAG);var isCombo=srcBitmask==WRAP_ARY_FLAG&&bitmask==WRAP_CURRY_FLAG||srcBitmask==WRAP_ARY_FLAG&&bitmask==WRAP_REARG_FLAG&&data[7].length<=source[8]||srcBitmask==(WRAP_ARY_FLAG|WRAP_REARG_FLAG)&&source[7].length<=source[8]&&bitmask==WRAP_CURRY_FLAG;// Exit early if metadata can't be merged.
if(!(isCommon||isCombo)){return data;}// Use source `thisArg` if available.
if(srcBitmask&WRAP_BIND_FLAG){data[2]=source[2];// Set when currying a bound function.
newBitmask|=bitmask&WRAP_BIND_FLAG?0:WRAP_CURRY_BOUND_FLAG;}// Compose partial arguments.
var value=source[3];if(value){var partials=data[3];data[3]=partials?composeArgs(partials,value,source[4]):value;data[4]=partials?replaceHolders(data[3],PLACEHOLDER):source[4];}// Compose partial right arguments.
value=source[5];if(value){partials=data[5];data[5]=partials?composeArgsRight(partials,value,source[6]):value;data[6]=partials?replaceHolders(data[5],PLACEHOLDER):source[6];}// Use source `argPos` if available.
value=source[7];if(value){data[7]=value;}// Use source `ary` if it's smaller.
if(srcBitmask&WRAP_ARY_FLAG){data[8]=data[8]==null?source[8]:nativeMin(data[8],source[8]);}// Use source `arity` if one is not provided.
if(data[9]==null){data[9]=source[9];}// Use source `func` and merge bitmasks.
data[0]=source[0];data[1]=newBitmask;return data;}/**
     * This function is like
     * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
     * except that it includes inherited enumerable properties.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */function nativeKeysIn(object){var result=[];if(object!=null){for(var key in Object(object)){result.push(key);}}return result;}/**
     * Converts `value` to a string using `Object.prototype.toString`.
     *
     * @private
     * @param {*} value The value to convert.
     * @returns {string} Returns the converted string.
     */function objectToString(value){return nativeObjectToString.call(value);}/**
     * A specialized version of `baseRest` which transforms the rest array.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @param {Function} transform The rest array transform.
     * @returns {Function} Returns the new function.
     */function overRest(func,start,transform){start=nativeMax(start===undefined?func.length-1:start,0);return function(){var args=arguments,index=-1,length=nativeMax(args.length-start,0),array=Array(length);while(++index<length){array[index]=args[start+index];}index=-1;var otherArgs=Array(start+1);while(++index<start){otherArgs[index]=args[index];}otherArgs[start]=transform(array);return apply(func,this,otherArgs);};}/**
     * Gets the parent value at `path` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array} path The path to get the parent value of.
     * @returns {*} Returns the parent value.
     */function parent(object,path){return path.length<2?object:baseGet(object,baseSlice(path,0,-1));}/**
     * Reorder `array` according to the specified indexes where the element at
     * the first index is assigned as the first element, the element at
     * the second index is assigned as the second element, and so on.
     *
     * @private
     * @param {Array} array The array to reorder.
     * @param {Array} indexes The arranged array indexes.
     * @returns {Array} Returns `array`.
     */function reorder(array,indexes){var arrLength=array.length,length=nativeMin(indexes.length,arrLength),oldArray=copyArray(array);while(length--){var index=indexes[length];array[length]=isIndex(index,arrLength)?oldArray[index]:undefined;}return array;}/**
     * Sets metadata for `func`.
     *
     * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
     * period of time, it will trip its breaker and transition to an identity
     * function to avoid garbage collection pauses in V8. See
     * [V8 issue 2070](https://bugs.chromium.org/p/v8/issues/detail?id=2070)
     * for more details.
     *
     * @private
     * @param {Function} func The function to associate metadata with.
     * @param {*} data The metadata.
     * @returns {Function} Returns `func`.
     */var setData=shortOut(baseSetData);/**
     * A simple wrapper around the global [`setTimeout`](https://mdn.io/setTimeout).
     *
     * @private
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @returns {number|Object} Returns the timer id or timeout object.
     */var setTimeout=ctxSetTimeout||function(func,wait){return root.setTimeout(func,wait);};/**
     * Sets the `toString` method of `func` to return `string`.
     *
     * @private
     * @param {Function} func The function to modify.
     * @param {Function} string The `toString` result.
     * @returns {Function} Returns `func`.
     */var setToString=shortOut(baseSetToString);/**
     * Sets the `toString` method of `wrapper` to mimic the source of `reference`
     * with wrapper details in a comment at the top of the source body.
     *
     * @private
     * @param {Function} wrapper The function to modify.
     * @param {Function} reference The reference function.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @returns {Function} Returns `wrapper`.
     */function setWrapToString(wrapper,reference,bitmask){var source=reference+'';return setToString(wrapper,insertWrapDetails(source,updateWrapDetails(getWrapDetails(source),bitmask)));}/**
     * Creates a function that'll short out and invoke `identity` instead
     * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
     * milliseconds.
     *
     * @private
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new shortable function.
     */function shortOut(func){var count=0,lastCalled=0;return function(){var stamp=nativeNow(),remaining=HOT_SPAN-(stamp-lastCalled);lastCalled=stamp;if(remaining>0){if(++count>=HOT_COUNT){return arguments[0];}}else{count=0;}return func.apply(undefined,arguments);};}/**
     * A specialized version of `_.shuffle` which mutates and sets the size of `array`.
     *
     * @private
     * @param {Array} array The array to shuffle.
     * @param {number} [size=array.length] The size of `array`.
     * @returns {Array} Returns `array`.
     */function shuffleSelf(array,size){var index=-1,length=array.length,lastIndex=length-1;size=size===undefined?length:size;while(++index<size){var rand=baseRandom(index,lastIndex),value=array[rand];array[rand]=array[index];array[index]=value;}array.length=size;return array;}/**
     * Converts `string` to a property path array.
     *
     * @private
     * @param {string} string The string to convert.
     * @returns {Array} Returns the property path array.
     */var stringToPath=memoizeCapped(function(string){var result=[];if(reLeadingDot.test(string)){result.push('');}string.replace(rePropName,function(match,number,quote,string){result.push(quote?string.replace(reEscapeChar,'$1'):number||match);});return result;});/**
     * Converts `value` to a string key if it's not a string or symbol.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {string|symbol} Returns the key.
     */function toKey(value){if(typeof value=='string'||isSymbol(value)){return value;}var result=value+'';return result=='0'&&1/value==-INFINITY?'-0':result;}/**
     * Converts `func` to its source code.
     *
     * @private
     * @param {Function} func The function to convert.
     * @returns {string} Returns the source code.
     */function toSource(func){if(func!=null){try{return funcToString.call(func);}catch(e){}try{return func+'';}catch(e){}}return'';}/**
     * Updates wrapper `details` based on `bitmask` flags.
     *
     * @private
     * @returns {Array} details The details to modify.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @returns {Array} Returns `details`.
     */function updateWrapDetails(details,bitmask){arrayEach(wrapFlags,function(pair){var value='_.'+pair[0];if(bitmask&pair[1]&&!arrayIncludes(details,value)){details.push(value);}});return details.sort();}/**
     * Creates a clone of `wrapper`.
     *
     * @private
     * @param {Object} wrapper The wrapper to clone.
     * @returns {Object} Returns the cloned wrapper.
     */function wrapperClone(wrapper){if(wrapper instanceof LazyWrapper){return wrapper.clone();}var result=new LodashWrapper(wrapper.__wrapped__,wrapper.__chain__);result.__actions__=copyArray(wrapper.__actions__);result.__index__=wrapper.__index__;result.__values__=wrapper.__values__;return result;}/*------------------------------------------------------------------------*//**
     * Creates an array of elements split into groups the length of `size`.
     * If `array` can't be split evenly, the final chunk will be the remaining
     * elements.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to process.
     * @param {number} [size=1] The length of each chunk
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the new array of chunks.
     * @example
     *
     * _.chunk(['a', 'b', 'c', 'd'], 2);
     * // => [['a', 'b'], ['c', 'd']]
     *
     * _.chunk(['a', 'b', 'c', 'd'], 3);
     * // => [['a', 'b', 'c'], ['d']]
     */function chunk(array,size,guard){if(guard?isIterateeCall(array,size,guard):size===undefined){size=1;}else{size=nativeMax(toInteger(size),0);}var length=array==null?0:array.length;if(!length||size<1){return[];}var index=0,resIndex=0,result=Array(nativeCeil(length/size));while(index<length){result[resIndex++]=baseSlice(array,index,index+=size);}return result;}/**
     * Creates an array with all falsey values removed. The values `false`, `null`,
     * `0`, `""`, `undefined`, and `NaN` are falsey.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to compact.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.compact([0, 1, false, 2, '', 3]);
     * // => [1, 2, 3]
     */function compact(array){var index=-1,length=array==null?0:array.length,resIndex=0,result=[];while(++index<length){var value=array[index];if(value){result[resIndex++]=value;}}return result;}/**
     * Creates a new array concatenating `array` with any additional arrays
     * and/or values.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to concatenate.
     * @param {...*} [values] The values to concatenate.
     * @returns {Array} Returns the new concatenated array.
     * @example
     *
     * var array = [1];
     * var other = _.concat(array, 2, [3], [[4]]);
     *
     * console.log(other);
     * // => [1, 2, 3, [4]]
     *
     * console.log(array);
     * // => [1]
     */function concat(){var length=arguments.length;if(!length){return[];}var args=Array(length-1),array=arguments[0],index=length;while(index--){args[index-1]=arguments[index];}return arrayPush(isArray(array)?copyArray(array):[array],baseFlatten(args,1));}/**
     * Creates an array of `array` values not included in the other given arrays
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons. The order and references of result values are
     * determined by the first array.
     *
     * **Note:** Unlike `_.pullAll`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.without, _.xor
     * @example
     *
     * _.difference([2, 1], [2, 3]);
     * // => [1]
     */var difference=baseRest(function(array,values){return isArrayLikeObject(array)?baseDifference(array,baseFlatten(values,1,isArrayLikeObject,true)):[];});/**
     * This method is like `_.difference` except that it accepts `iteratee` which
     * is invoked for each element of `array` and `values` to generate the criterion
     * by which they're compared. The order and references of result values are
     * determined by the first array. The iteratee is invoked with one argument:
     * (value).
     *
     * **Note:** Unlike `_.pullAllBy`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.differenceBy([2.1, 1.2], [2.3, 3.4], Math.floor);
     * // => [1.2]
     *
     * // The `_.property` iteratee shorthand.
     * _.differenceBy([{ 'x': 2 }, { 'x': 1 }], [{ 'x': 1 }], 'x');
     * // => [{ 'x': 2 }]
     */var differenceBy=baseRest(function(array,values){var iteratee=last(values);if(isArrayLikeObject(iteratee)){iteratee=undefined;}return isArrayLikeObject(array)?baseDifference(array,baseFlatten(values,1,isArrayLikeObject,true),getIteratee(iteratee,2)):[];});/**
     * This method is like `_.difference` except that it accepts `comparator`
     * which is invoked to compare elements of `array` to `values`. The order and
     * references of result values are determined by the first array. The comparator
     * is invoked with two arguments: (arrVal, othVal).
     *
     * **Note:** Unlike `_.pullAllWith`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     *
     * _.differenceWith(objects, [{ 'x': 1, 'y': 2 }], _.isEqual);
     * // => [{ 'x': 2, 'y': 1 }]
     */var differenceWith=baseRest(function(array,values){var comparator=last(values);if(isArrayLikeObject(comparator)){comparator=undefined;}return isArrayLikeObject(array)?baseDifference(array,baseFlatten(values,1,isArrayLikeObject,true),undefined,comparator):[];});/**
     * Creates a slice of `array` with `n` elements dropped from the beginning.
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to drop.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.drop([1, 2, 3]);
     * // => [2, 3]
     *
     * _.drop([1, 2, 3], 2);
     * // => [3]
     *
     * _.drop([1, 2, 3], 5);
     * // => []
     *
     * _.drop([1, 2, 3], 0);
     * // => [1, 2, 3]
     */function drop(array,n,guard){var length=array==null?0:array.length;if(!length){return[];}n=guard||n===undefined?1:toInteger(n);return baseSlice(array,n<0?0:n,length);}/**
     * Creates a slice of `array` with `n` elements dropped from the end.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to drop.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.dropRight([1, 2, 3]);
     * // => [1, 2]
     *
     * _.dropRight([1, 2, 3], 2);
     * // => [1]
     *
     * _.dropRight([1, 2, 3], 5);
     * // => []
     *
     * _.dropRight([1, 2, 3], 0);
     * // => [1, 2, 3]
     */function dropRight(array,n,guard){var length=array==null?0:array.length;if(!length){return[];}n=guard||n===undefined?1:toInteger(n);n=length-n;return baseSlice(array,0,n<0?0:n);}/**
     * Creates a slice of `array` excluding elements dropped from the end.
     * Elements are dropped until `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.dropRightWhile(users, function(o) { return !o.active; });
     * // => objects for ['barney']
     *
     * // The `_.matches` iteratee shorthand.
     * _.dropRightWhile(users, { 'user': 'pebbles', 'active': false });
     * // => objects for ['barney', 'fred']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.dropRightWhile(users, ['active', false]);
     * // => objects for ['barney']
     *
     * // The `_.property` iteratee shorthand.
     * _.dropRightWhile(users, 'active');
     * // => objects for ['barney', 'fred', 'pebbles']
     */function dropRightWhile(array,predicate){return array&&array.length?baseWhile(array,getIteratee(predicate,3),true,true):[];}/**
     * Creates a slice of `array` excluding elements dropped from the beginning.
     * Elements are dropped until `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.dropWhile(users, function(o) { return !o.active; });
     * // => objects for ['pebbles']
     *
     * // The `_.matches` iteratee shorthand.
     * _.dropWhile(users, { 'user': 'barney', 'active': false });
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.dropWhile(users, ['active', false]);
     * // => objects for ['pebbles']
     *
     * // The `_.property` iteratee shorthand.
     * _.dropWhile(users, 'active');
     * // => objects for ['barney', 'fred', 'pebbles']
     */function dropWhile(array,predicate){return array&&array.length?baseWhile(array,getIteratee(predicate,3),true):[];}/**
     * Fills elements of `array` with `value` from `start` up to, but not
     * including, `end`.
     *
     * **Note:** This method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 3.2.0
     * @category Array
     * @param {Array} array The array to fill.
     * @param {*} value The value to fill `array` with.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _.fill(array, 'a');
     * console.log(array);
     * // => ['a', 'a', 'a']
     *
     * _.fill(Array(3), 2);
     * // => [2, 2, 2]
     *
     * _.fill([4, 6, 8, 10], '*', 1, 3);
     * // => [4, '*', '*', 10]
     */function fill(array,value,start,end){var length=array==null?0:array.length;if(!length){return[];}if(start&&typeof start!='number'&&isIterateeCall(array,value,start)){start=0;end=length;}return baseFill(array,value,start,end);}/**
     * This method is like `_.find` except that it returns the index of the first
     * element `predicate` returns truthy for instead of the element itself.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.findIndex(users, function(o) { return o.user == 'barney'; });
     * // => 0
     *
     * // The `_.matches` iteratee shorthand.
     * _.findIndex(users, { 'user': 'fred', 'active': false });
     * // => 1
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findIndex(users, ['active', false]);
     * // => 0
     *
     * // The `_.property` iteratee shorthand.
     * _.findIndex(users, 'active');
     * // => 2
     */function findIndex(array,predicate,fromIndex){var length=array==null?0:array.length;if(!length){return-1;}var index=fromIndex==null?0:toInteger(fromIndex);if(index<0){index=nativeMax(length+index,0);}return baseFindIndex(array,getIteratee(predicate,3),index);}/**
     * This method is like `_.findIndex` except that it iterates over elements
     * of `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=array.length-1] The index to search from.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.findLastIndex(users, function(o) { return o.user == 'pebbles'; });
     * // => 2
     *
     * // The `_.matches` iteratee shorthand.
     * _.findLastIndex(users, { 'user': 'barney', 'active': true });
     * // => 0
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findLastIndex(users, ['active', false]);
     * // => 2
     *
     * // The `_.property` iteratee shorthand.
     * _.findLastIndex(users, 'active');
     * // => 0
     */function findLastIndex(array,predicate,fromIndex){var length=array==null?0:array.length;if(!length){return-1;}var index=length-1;if(fromIndex!==undefined){index=toInteger(fromIndex);index=fromIndex<0?nativeMax(length+index,0):nativeMin(index,length-1);}return baseFindIndex(array,getIteratee(predicate,3),index,true);}/**
     * Flattens `array` a single level deep.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * _.flatten([1, [2, [3, [4]], 5]]);
     * // => [1, 2, [3, [4]], 5]
     */function flatten(array){var length=array==null?0:array.length;return length?baseFlatten(array,1):[];}/**
     * Recursively flattens `array`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * _.flattenDeep([1, [2, [3, [4]], 5]]);
     * // => [1, 2, 3, 4, 5]
     */function flattenDeep(array){var length=array==null?0:array.length;return length?baseFlatten(array,INFINITY):[];}/**
     * Recursively flatten `array` up to `depth` times.
     *
     * @static
     * @memberOf _
     * @since 4.4.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @param {number} [depth=1] The maximum recursion depth.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * var array = [1, [2, [3, [4]], 5]];
     *
     * _.flattenDepth(array, 1);
     * // => [1, 2, [3, [4]], 5]
     *
     * _.flattenDepth(array, 2);
     * // => [1, 2, 3, [4], 5]
     */function flattenDepth(array,depth){var length=array==null?0:array.length;if(!length){return[];}depth=depth===undefined?1:toInteger(depth);return baseFlatten(array,depth);}/**
     * The inverse of `_.toPairs`; this method returns an object composed
     * from key-value `pairs`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} pairs The key-value pairs.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.fromPairs([['a', 1], ['b', 2]]);
     * // => { 'a': 1, 'b': 2 }
     */function fromPairs(pairs){var index=-1,length=pairs==null?0:pairs.length,result={};while(++index<length){var pair=pairs[index];result[pair[0]]=pair[1];}return result;}/**
     * Gets the first element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @alias first
     * @category Array
     * @param {Array} array The array to query.
     * @returns {*} Returns the first element of `array`.
     * @example
     *
     * _.head([1, 2, 3]);
     * // => 1
     *
     * _.head([]);
     * // => undefined
     */function head(array){return array&&array.length?array[0]:undefined;}/**
     * Gets the index at which the first occurrence of `value` is found in `array`
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons. If `fromIndex` is negative, it's used as the
     * offset from the end of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.indexOf([1, 2, 1, 2], 2);
     * // => 1
     *
     * // Search from the `fromIndex`.
     * _.indexOf([1, 2, 1, 2], 2, 2);
     * // => 3
     */function indexOf(array,value,fromIndex){var length=array==null?0:array.length;if(!length){return-1;}var index=fromIndex==null?0:toInteger(fromIndex);if(index<0){index=nativeMax(length+index,0);}return baseIndexOf(array,value,index);}/**
     * Gets all but the last element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.initial([1, 2, 3]);
     * // => [1, 2]
     */function initial(array){var length=array==null?0:array.length;return length?baseSlice(array,0,-1):[];}/**
     * Creates an array of unique values that are included in all given arrays
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons. The order and references of result values are
     * determined by the first array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * _.intersection([2, 1], [2, 3]);
     * // => [2]
     */var intersection=baseRest(function(arrays){var mapped=arrayMap(arrays,castArrayLikeObject);return mapped.length&&mapped[0]===arrays[0]?baseIntersection(mapped):[];});/**
     * This method is like `_.intersection` except that it accepts `iteratee`
     * which is invoked for each element of each `arrays` to generate the criterion
     * by which they're compared. The order and references of result values are
     * determined by the first array. The iteratee is invoked with one argument:
     * (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * _.intersectionBy([2.1, 1.2], [2.3, 3.4], Math.floor);
     * // => [2.1]
     *
     * // The `_.property` iteratee shorthand.
     * _.intersectionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }]
     */var intersectionBy=baseRest(function(arrays){var iteratee=last(arrays),mapped=arrayMap(arrays,castArrayLikeObject);if(iteratee===last(mapped)){iteratee=undefined;}else{mapped.pop();}return mapped.length&&mapped[0]===arrays[0]?baseIntersection(mapped,getIteratee(iteratee,2)):[];});/**
     * This method is like `_.intersection` except that it accepts `comparator`
     * which is invoked to compare elements of `arrays`. The order and references
     * of result values are determined by the first array. The comparator is
     * invoked with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.intersectionWith(objects, others, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }]
     */var intersectionWith=baseRest(function(arrays){var comparator=last(arrays),mapped=arrayMap(arrays,castArrayLikeObject);comparator=typeof comparator=='function'?comparator:undefined;if(comparator){mapped.pop();}return mapped.length&&mapped[0]===arrays[0]?baseIntersection(mapped,undefined,comparator):[];});/**
     * Converts all elements in `array` into a string separated by `separator`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to convert.
     * @param {string} [separator=','] The element separator.
     * @returns {string} Returns the joined string.
     * @example
     *
     * _.join(['a', 'b', 'c'], '~');
     * // => 'a~b~c'
     */function join(array,separator){return array==null?'':nativeJoin.call(array,separator);}/**
     * Gets the last element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {*} Returns the last element of `array`.
     * @example
     *
     * _.last([1, 2, 3]);
     * // => 3
     */function last(array){var length=array==null?0:array.length;return length?array[length-1]:undefined;}/**
     * This method is like `_.indexOf` except that it iterates over elements of
     * `array` from right to left.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=array.length-1] The index to search from.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.lastIndexOf([1, 2, 1, 2], 2);
     * // => 3
     *
     * // Search from the `fromIndex`.
     * _.lastIndexOf([1, 2, 1, 2], 2, 2);
     * // => 1
     */function lastIndexOf(array,value,fromIndex){var length=array==null?0:array.length;if(!length){return-1;}var index=length;if(fromIndex!==undefined){index=toInteger(fromIndex);index=index<0?nativeMax(length+index,0):nativeMin(index,length-1);}return value===value?strictLastIndexOf(array,value,index):baseFindIndex(array,baseIsNaN,index,true);}/**
     * Gets the element at index `n` of `array`. If `n` is negative, the nth
     * element from the end is returned.
     *
     * @static
     * @memberOf _
     * @since 4.11.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=0] The index of the element to return.
     * @returns {*} Returns the nth element of `array`.
     * @example
     *
     * var array = ['a', 'b', 'c', 'd'];
     *
     * _.nth(array, 1);
     * // => 'b'
     *
     * _.nth(array, -2);
     * // => 'c';
     */function nth(array,n){return array&&array.length?baseNth(array,toInteger(n)):undefined;}/**
     * Removes all given values from `array` using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * **Note:** Unlike `_.without`, this method mutates `array`. Use `_.remove`
     * to remove elements from an array by predicate.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {...*} [values] The values to remove.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
     *
     * _.pull(array, 'a', 'c');
     * console.log(array);
     * // => ['b', 'b']
     */var pull=baseRest(pullAll);/**
     * This method is like `_.pull` except that it accepts an array of values to remove.
     *
     * **Note:** Unlike `_.difference`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
     *
     * _.pullAll(array, ['a', 'c']);
     * console.log(array);
     * // => ['b', 'b']
     */function pullAll(array,values){return array&&array.length&&values&&values.length?basePullAll(array,values):array;}/**
     * This method is like `_.pullAll` except that it accepts `iteratee` which is
     * invoked for each element of `array` and `values` to generate the criterion
     * by which they're compared. The iteratee is invoked with one argument: (value).
     *
     * **Note:** Unlike `_.differenceBy`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [{ 'x': 1 }, { 'x': 2 }, { 'x': 3 }, { 'x': 1 }];
     *
     * _.pullAllBy(array, [{ 'x': 1 }, { 'x': 3 }], 'x');
     * console.log(array);
     * // => [{ 'x': 2 }]
     */function pullAllBy(array,values,iteratee){return array&&array.length&&values&&values.length?basePullAll(array,values,getIteratee(iteratee,2)):array;}/**
     * This method is like `_.pullAll` except that it accepts `comparator` which
     * is invoked to compare elements of `array` to `values`. The comparator is
     * invoked with two arguments: (arrVal, othVal).
     *
     * **Note:** Unlike `_.differenceWith`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.6.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [{ 'x': 1, 'y': 2 }, { 'x': 3, 'y': 4 }, { 'x': 5, 'y': 6 }];
     *
     * _.pullAllWith(array, [{ 'x': 3, 'y': 4 }], _.isEqual);
     * console.log(array);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 5, 'y': 6 }]
     */function pullAllWith(array,values,comparator){return array&&array.length&&values&&values.length?basePullAll(array,values,undefined,comparator):array;}/**
     * Removes elements from `array` corresponding to `indexes` and returns an
     * array of removed elements.
     *
     * **Note:** Unlike `_.at`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {...(number|number[])} [indexes] The indexes of elements to remove.
     * @returns {Array} Returns the new array of removed elements.
     * @example
     *
     * var array = ['a', 'b', 'c', 'd'];
     * var pulled = _.pullAt(array, [1, 3]);
     *
     * console.log(array);
     * // => ['a', 'c']
     *
     * console.log(pulled);
     * // => ['b', 'd']
     */var pullAt=flatRest(function(array,indexes){var length=array==null?0:array.length,result=baseAt(array,indexes);basePullAt(array,arrayMap(indexes,function(index){return isIndex(index,length)?+index:index;}).sort(compareAscending));return result;});/**
     * Removes all elements from `array` that `predicate` returns truthy for
     * and returns an array of the removed elements. The predicate is invoked
     * with three arguments: (value, index, array).
     *
     * **Note:** Unlike `_.filter`, this method mutates `array`. Use `_.pull`
     * to pull elements from an array by value.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new array of removed elements.
     * @example
     *
     * var array = [1, 2, 3, 4];
     * var evens = _.remove(array, function(n) {
     *   return n % 2 == 0;
     * });
     *
     * console.log(array);
     * // => [1, 3]
     *
     * console.log(evens);
     * // => [2, 4]
     */function remove(array,predicate){var result=[];if(!(array&&array.length)){return result;}var index=-1,indexes=[],length=array.length;predicate=getIteratee(predicate,3);while(++index<length){var value=array[index];if(predicate(value,index,array)){result.push(value);indexes.push(index);}}basePullAt(array,indexes);return result;}/**
     * Reverses `array` so that the first element becomes the last, the second
     * element becomes the second to last, and so on.
     *
     * **Note:** This method mutates `array` and is based on
     * [`Array#reverse`](https://mdn.io/Array/reverse).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _.reverse(array);
     * // => [3, 2, 1]
     *
     * console.log(array);
     * // => [3, 2, 1]
     */function reverse(array){return array==null?array:nativeReverse.call(array);}/**
     * Creates a slice of `array` from `start` up to, but not including, `end`.
     *
     * **Note:** This method is used instead of
     * [`Array#slice`](https://mdn.io/Array/slice) to ensure dense arrays are
     * returned.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the slice of `array`.
     */function slice(array,start,end){var length=array==null?0:array.length;if(!length){return[];}if(end&&typeof end!='number'&&isIterateeCall(array,start,end)){start=0;end=length;}else{start=start==null?0:toInteger(start);end=end===undefined?length:toInteger(end);}return baseSlice(array,start,end);}/**
     * Uses a binary search to determine the lowest index at which `value`
     * should be inserted into `array` in order to maintain its sort order.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedIndex([30, 50], 40);
     * // => 1
     */function sortedIndex(array,value){return baseSortedIndex(array,value);}/**
     * This method is like `_.sortedIndex` except that it accepts `iteratee`
     * which is invoked for `value` and each element of `array` to compute their
     * sort ranking. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * var objects = [{ 'x': 4 }, { 'x': 5 }];
     *
     * _.sortedIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
     * // => 0
     *
     * // The `_.property` iteratee shorthand.
     * _.sortedIndexBy(objects, { 'x': 4 }, 'x');
     * // => 0
     */function sortedIndexBy(array,value,iteratee){return baseSortedIndexBy(array,value,getIteratee(iteratee,2));}/**
     * This method is like `_.indexOf` except that it performs a binary
     * search on a sorted `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.sortedIndexOf([4, 5, 5, 5, 6], 5);
     * // => 1
     */function sortedIndexOf(array,value){var length=array==null?0:array.length;if(length){var index=baseSortedIndex(array,value);if(index<length&&eq(array[index],value)){return index;}}return-1;}/**
     * This method is like `_.sortedIndex` except that it returns the highest
     * index at which `value` should be inserted into `array` in order to
     * maintain its sort order.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedLastIndex([4, 5, 5, 5, 6], 5);
     * // => 4
     */function sortedLastIndex(array,value){return baseSortedIndex(array,value,true);}/**
     * This method is like `_.sortedLastIndex` except that it accepts `iteratee`
     * which is invoked for `value` and each element of `array` to compute their
     * sort ranking. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * var objects = [{ 'x': 4 }, { 'x': 5 }];
     *
     * _.sortedLastIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
     * // => 1
     *
     * // The `_.property` iteratee shorthand.
     * _.sortedLastIndexBy(objects, { 'x': 4 }, 'x');
     * // => 1
     */function sortedLastIndexBy(array,value,iteratee){return baseSortedIndexBy(array,value,getIteratee(iteratee,2),true);}/**
     * This method is like `_.lastIndexOf` except that it performs a binary
     * search on a sorted `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.sortedLastIndexOf([4, 5, 5, 5, 6], 5);
     * // => 3
     */function sortedLastIndexOf(array,value){var length=array==null?0:array.length;if(length){var index=baseSortedIndex(array,value,true)-1;if(eq(array[index],value)){return index;}}return-1;}/**
     * This method is like `_.uniq` except that it's designed and optimized
     * for sorted arrays.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.sortedUniq([1, 1, 2]);
     * // => [1, 2]
     */function sortedUniq(array){return array&&array.length?baseSortedUniq(array):[];}/**
     * This method is like `_.uniqBy` except that it's designed and optimized
     * for sorted arrays.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.sortedUniqBy([1.1, 1.2, 2.3, 2.4], Math.floor);
     * // => [1.1, 2.3]
     */function sortedUniqBy(array,iteratee){return array&&array.length?baseSortedUniq(array,getIteratee(iteratee,2)):[];}/**
     * Gets all but the first element of `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.tail([1, 2, 3]);
     * // => [2, 3]
     */function tail(array){var length=array==null?0:array.length;return length?baseSlice(array,1,length):[];}/**
     * Creates a slice of `array` with `n` elements taken from the beginning.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to take.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.take([1, 2, 3]);
     * // => [1]
     *
     * _.take([1, 2, 3], 2);
     * // => [1, 2]
     *
     * _.take([1, 2, 3], 5);
     * // => [1, 2, 3]
     *
     * _.take([1, 2, 3], 0);
     * // => []
     */function take(array,n,guard){if(!(array&&array.length)){return[];}n=guard||n===undefined?1:toInteger(n);return baseSlice(array,0,n<0?0:n);}/**
     * Creates a slice of `array` with `n` elements taken from the end.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to take.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.takeRight([1, 2, 3]);
     * // => [3]
     *
     * _.takeRight([1, 2, 3], 2);
     * // => [2, 3]
     *
     * _.takeRight([1, 2, 3], 5);
     * // => [1, 2, 3]
     *
     * _.takeRight([1, 2, 3], 0);
     * // => []
     */function takeRight(array,n,guard){var length=array==null?0:array.length;if(!length){return[];}n=guard||n===undefined?1:toInteger(n);n=length-n;return baseSlice(array,n<0?0:n,length);}/**
     * Creates a slice of `array` with elements taken from the end. Elements are
     * taken until `predicate` returns falsey. The predicate is invoked with
     * three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.takeRightWhile(users, function(o) { return !o.active; });
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.matches` iteratee shorthand.
     * _.takeRightWhile(users, { 'user': 'pebbles', 'active': false });
     * // => objects for ['pebbles']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.takeRightWhile(users, ['active', false]);
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.property` iteratee shorthand.
     * _.takeRightWhile(users, 'active');
     * // => []
     */function takeRightWhile(array,predicate){return array&&array.length?baseWhile(array,getIteratee(predicate,3),false,true):[];}/**
     * Creates a slice of `array` with elements taken from the beginning. Elements
     * are taken until `predicate` returns falsey. The predicate is invoked with
     * three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.takeWhile(users, function(o) { return !o.active; });
     * // => objects for ['barney', 'fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.takeWhile(users, { 'user': 'barney', 'active': false });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.takeWhile(users, ['active', false]);
     * // => objects for ['barney', 'fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.takeWhile(users, 'active');
     * // => []
     */function takeWhile(array,predicate){return array&&array.length?baseWhile(array,getIteratee(predicate,3)):[];}/**
     * Creates an array of unique values, in order, from all given arrays using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * _.union([2], [1, 2]);
     * // => [2, 1]
     */var union=baseRest(function(arrays){return baseUniq(baseFlatten(arrays,1,isArrayLikeObject,true));});/**
     * This method is like `_.union` except that it accepts `iteratee` which is
     * invoked for each element of each `arrays` to generate the criterion by
     * which uniqueness is computed. Result values are chosen from the first
     * array in which the value occurs. The iteratee is invoked with one argument:
     * (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * _.unionBy([2.1], [1.2, 2.3], Math.floor);
     * // => [2.1, 1.2]
     *
     * // The `_.property` iteratee shorthand.
     * _.unionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }, { 'x': 2 }]
     */var unionBy=baseRest(function(arrays){var iteratee=last(arrays);if(isArrayLikeObject(iteratee)){iteratee=undefined;}return baseUniq(baseFlatten(arrays,1,isArrayLikeObject,true),getIteratee(iteratee,2));});/**
     * This method is like `_.union` except that it accepts `comparator` which
     * is invoked to compare elements of `arrays`. Result values are chosen from
     * the first array in which the value occurs. The comparator is invoked
     * with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.unionWith(objects, others, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
     */var unionWith=baseRest(function(arrays){var comparator=last(arrays);comparator=typeof comparator=='function'?comparator:undefined;return baseUniq(baseFlatten(arrays,1,isArrayLikeObject,true),undefined,comparator);});/**
     * Creates a duplicate-free version of an array, using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons, in which only the first occurrence of each element
     * is kept. The order of result values is determined by the order they occur
     * in the array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.uniq([2, 1, 2]);
     * // => [2, 1]
     */function uniq(array){return array&&array.length?baseUniq(array):[];}/**
     * This method is like `_.uniq` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the criterion by which
     * uniqueness is computed. The order of result values is determined by the
     * order they occur in the array. The iteratee is invoked with one argument:
     * (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.uniqBy([2.1, 1.2, 2.3], Math.floor);
     * // => [2.1, 1.2]
     *
     * // The `_.property` iteratee shorthand.
     * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }, { 'x': 2 }]
     */function uniqBy(array,iteratee){return array&&array.length?baseUniq(array,getIteratee(iteratee,2)):[];}/**
     * This method is like `_.uniq` except that it accepts `comparator` which
     * is invoked to compare elements of `array`. The order of result values is
     * determined by the order they occur in the array.The comparator is invoked
     * with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.uniqWith(objects, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]
     */function uniqWith(array,comparator){comparator=typeof comparator=='function'?comparator:undefined;return array&&array.length?baseUniq(array,undefined,comparator):[];}/**
     * This method is like `_.zip` except that it accepts an array of grouped
     * elements and creates an array regrouping the elements to their pre-zip
     * configuration.
     *
     * @static
     * @memberOf _
     * @since 1.2.0
     * @category Array
     * @param {Array} array The array of grouped elements to process.
     * @returns {Array} Returns the new array of regrouped elements.
     * @example
     *
     * var zipped = _.zip(['a', 'b'], [1, 2], [true, false]);
     * // => [['a', 1, true], ['b', 2, false]]
     *
     * _.unzip(zipped);
     * // => [['a', 'b'], [1, 2], [true, false]]
     */function unzip(array){if(!(array&&array.length)){return[];}var length=0;array=arrayFilter(array,function(group){if(isArrayLikeObject(group)){length=nativeMax(group.length,length);return true;}});return baseTimes(length,function(index){return arrayMap(array,baseProperty(index));});}/**
     * This method is like `_.unzip` except that it accepts `iteratee` to specify
     * how regrouped values should be combined. The iteratee is invoked with the
     * elements of each group: (...group).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Array
     * @param {Array} array The array of grouped elements to process.
     * @param {Function} [iteratee=_.identity] The function to combine
     *  regrouped values.
     * @returns {Array} Returns the new array of regrouped elements.
     * @example
     *
     * var zipped = _.zip([1, 2], [10, 20], [100, 200]);
     * // => [[1, 10, 100], [2, 20, 200]]
     *
     * _.unzipWith(zipped, _.add);
     * // => [3, 30, 300]
     */function unzipWith(array,iteratee){if(!(array&&array.length)){return[];}var result=unzip(array);if(iteratee==null){return result;}return arrayMap(result,function(group){return apply(iteratee,undefined,group);});}/**
     * Creates an array excluding all given values using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * **Note:** Unlike `_.pull`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...*} [values] The values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.difference, _.xor
     * @example
     *
     * _.without([2, 1, 2, 3], 1, 2);
     * // => [3]
     */var without=baseRest(function(array,values){return isArrayLikeObject(array)?baseDifference(array,values):[];});/**
     * Creates an array of unique values that is the
     * [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)
     * of the given arrays. The order of result values is determined by the order
     * they occur in the arrays.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.difference, _.without
     * @example
     *
     * _.xor([2, 1], [2, 3]);
     * // => [1, 3]
     */var xor=baseRest(function(arrays){return baseXor(arrayFilter(arrays,isArrayLikeObject));});/**
     * This method is like `_.xor` except that it accepts `iteratee` which is
     * invoked for each element of each `arrays` to generate the criterion by
     * which by which they're compared. The order of result values is determined
     * by the order they occur in the arrays. The iteratee is invoked with one
     * argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.xorBy([2.1, 1.2], [2.3, 3.4], Math.floor);
     * // => [1.2, 3.4]
     *
     * // The `_.property` iteratee shorthand.
     * _.xorBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 2 }]
     */var xorBy=baseRest(function(arrays){var iteratee=last(arrays);if(isArrayLikeObject(iteratee)){iteratee=undefined;}return baseXor(arrayFilter(arrays,isArrayLikeObject),getIteratee(iteratee,2));});/**
     * This method is like `_.xor` except that it accepts `comparator` which is
     * invoked to compare elements of `arrays`. The order of result values is
     * determined by the order they occur in the arrays. The comparator is invoked
     * with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.xorWith(objects, others, _.isEqual);
     * // => [{ 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
     */var xorWith=baseRest(function(arrays){var comparator=last(arrays);comparator=typeof comparator=='function'?comparator:undefined;return baseXor(arrayFilter(arrays,isArrayLikeObject),undefined,comparator);});/**
     * Creates an array of grouped elements, the first of which contains the
     * first elements of the given arrays, the second of which contains the
     * second elements of the given arrays, and so on.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to process.
     * @returns {Array} Returns the new array of grouped elements.
     * @example
     *
     * _.zip(['a', 'b'], [1, 2], [true, false]);
     * // => [['a', 1, true], ['b', 2, false]]
     */var zip=baseRest(unzip);/**
     * This method is like `_.fromPairs` except that it accepts two arrays,
     * one of property identifiers and one of corresponding values.
     *
     * @static
     * @memberOf _
     * @since 0.4.0
     * @category Array
     * @param {Array} [props=[]] The property identifiers.
     * @param {Array} [values=[]] The property values.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.zipObject(['a', 'b'], [1, 2]);
     * // => { 'a': 1, 'b': 2 }
     */function zipObject(props,values){return baseZipObject(props||[],values||[],assignValue);}/**
     * This method is like `_.zipObject` except that it supports property paths.
     *
     * @static
     * @memberOf _
     * @since 4.1.0
     * @category Array
     * @param {Array} [props=[]] The property identifiers.
     * @param {Array} [values=[]] The property values.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.zipObjectDeep(['a.b[0].c', 'a.b[1].d'], [1, 2]);
     * // => { 'a': { 'b': [{ 'c': 1 }, { 'd': 2 }] } }
     */function zipObjectDeep(props,values){return baseZipObject(props||[],values||[],baseSet);}/**
     * This method is like `_.zip` except that it accepts `iteratee` to specify
     * how grouped values should be combined. The iteratee is invoked with the
     * elements of each group: (...group).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Array
     * @param {...Array} [arrays] The arrays to process.
     * @param {Function} [iteratee=_.identity] The function to combine
     *  grouped values.
     * @returns {Array} Returns the new array of grouped elements.
     * @example
     *
     * _.zipWith([1, 2], [10, 20], [100, 200], function(a, b, c) {
     *   return a + b + c;
     * });
     * // => [111, 222]
     */var zipWith=baseRest(function(arrays){var length=arrays.length,iteratee=length>1?arrays[length-1]:undefined;iteratee=typeof iteratee=='function'?(arrays.pop(),iteratee):undefined;return unzipWith(arrays,iteratee);});/*------------------------------------------------------------------------*//**
     * Creates a `lodash` wrapper instance that wraps `value` with explicit method
     * chain sequences enabled. The result of such sequences must be unwrapped
     * with `_#value`.
     *
     * @static
     * @memberOf _
     * @since 1.3.0
     * @category Seq
     * @param {*} value The value to wrap.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36 },
     *   { 'user': 'fred',    'age': 40 },
     *   { 'user': 'pebbles', 'age': 1 }
     * ];
     *
     * var youngest = _
     *   .chain(users)
     *   .sortBy('age')
     *   .map(function(o) {
     *     return o.user + ' is ' + o.age;
     *   })
     *   .head()
     *   .value();
     * // => 'pebbles is 1'
     */function chain(value){var result=lodash(value);result.__chain__=true;return result;}/**
     * This method invokes `interceptor` and returns `value`. The interceptor
     * is invoked with one argument; (value). The purpose of this method is to
     * "tap into" a method chain sequence in order to modify intermediate results.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Seq
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @returns {*} Returns `value`.
     * @example
     *
     * _([1, 2, 3])
     *  .tap(function(array) {
     *    // Mutate input array.
     *    array.pop();
     *  })
     *  .reverse()
     *  .value();
     * // => [2, 1]
     */function tap(value,interceptor){interceptor(value);return value;}/**
     * This method is like `_.tap` except that it returns the result of `interceptor`.
     * The purpose of this method is to "pass thru" values replacing intermediate
     * results in a method chain sequence.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Seq
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @returns {*} Returns the result of `interceptor`.
     * @example
     *
     * _('  abc  ')
     *  .chain()
     *  .trim()
     *  .thru(function(value) {
     *    return [value];
     *  })
     *  .value();
     * // => ['abc']
     */function thru(value,interceptor){return interceptor(value);}/**
     * This method is the wrapper version of `_.at`.
     *
     * @name at
     * @memberOf _
     * @since 1.0.0
     * @category Seq
     * @param {...(string|string[])} [paths] The property paths to pick.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
     *
     * _(object).at(['a[0].b.c', 'a[1]']).value();
     * // => [3, 4]
     */var wrapperAt=flatRest(function(paths){var length=paths.length,start=length?paths[0]:0,value=this.__wrapped__,interceptor=function(object){return baseAt(object,paths);};if(length>1||this.__actions__.length||!(value instanceof LazyWrapper)||!isIndex(start)){return this.thru(interceptor);}value=value.slice(start,+start+(length?1:0));value.__actions__.push({'func':thru,'args':[interceptor],'thisArg':undefined});return new LodashWrapper(value,this.__chain__).thru(function(array){if(length&&!array.length){array.push(undefined);}return array;});});/**
     * Creates a `lodash` wrapper instance with explicit method chain sequences enabled.
     *
     * @name chain
     * @memberOf _
     * @since 0.1.0
     * @category Seq
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 }
     * ];
     *
     * // A sequence without explicit chaining.
     * _(users).head();
     * // => { 'user': 'barney', 'age': 36 }
     *
     * // A sequence with explicit chaining.
     * _(users)
     *   .chain()
     *   .head()
     *   .pick('user')
     *   .value();
     * // => { 'user': 'barney' }
     */function wrapperChain(){return chain(this);}/**
     * Executes the chain sequence and returns the wrapped result.
     *
     * @name commit
     * @memberOf _
     * @since 3.2.0
     * @category Seq
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var array = [1, 2];
     * var wrapped = _(array).push(3);
     *
     * console.log(array);
     * // => [1, 2]
     *
     * wrapped = wrapped.commit();
     * console.log(array);
     * // => [1, 2, 3]
     *
     * wrapped.last();
     * // => 3
     *
     * console.log(array);
     * // => [1, 2, 3]
     */function wrapperCommit(){return new LodashWrapper(this.value(),this.__chain__);}/**
     * Gets the next value on a wrapped object following the
     * [iterator protocol](https://mdn.io/iteration_protocols#iterator).
     *
     * @name next
     * @memberOf _
     * @since 4.0.0
     * @category Seq
     * @returns {Object} Returns the next iterator value.
     * @example
     *
     * var wrapped = _([1, 2]);
     *
     * wrapped.next();
     * // => { 'done': false, 'value': 1 }
     *
     * wrapped.next();
     * // => { 'done': false, 'value': 2 }
     *
     * wrapped.next();
     * // => { 'done': true, 'value': undefined }
     */function wrapperNext(){if(this.__values__===undefined){this.__values__=toArray(this.value());}var done=this.__index__>=this.__values__.length,value=done?undefined:this.__values__[this.__index__++];return{'done':done,'value':value};}/**
     * Enables the wrapper to be iterable.
     *
     * @name Symbol.iterator
     * @memberOf _
     * @since 4.0.0
     * @category Seq
     * @returns {Object} Returns the wrapper object.
     * @example
     *
     * var wrapped = _([1, 2]);
     *
     * wrapped[Symbol.iterator]() === wrapped;
     * // => true
     *
     * Array.from(wrapped);
     * // => [1, 2]
     */function wrapperToIterator(){return this;}/**
     * Creates a clone of the chain sequence planting `value` as the wrapped value.
     *
     * @name plant
     * @memberOf _
     * @since 3.2.0
     * @category Seq
     * @param {*} value The value to plant.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var wrapped = _([1, 2]).map(square);
     * var other = wrapped.plant([3, 4]);
     *
     * other.value();
     * // => [9, 16]
     *
     * wrapped.value();
     * // => [1, 4]
     */function wrapperPlant(value){var result,parent=this;while(parent instanceof baseLodash){var clone=wrapperClone(parent);clone.__index__=0;clone.__values__=undefined;if(result){previous.__wrapped__=clone;}else{result=clone;}var previous=clone;parent=parent.__wrapped__;}previous.__wrapped__=value;return result;}/**
     * This method is the wrapper version of `_.reverse`.
     *
     * **Note:** This method mutates the wrapped array.
     *
     * @name reverse
     * @memberOf _
     * @since 0.1.0
     * @category Seq
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _(array).reverse().value()
     * // => [3, 2, 1]
     *
     * console.log(array);
     * // => [3, 2, 1]
     */function wrapperReverse(){var value=this.__wrapped__;if(value instanceof LazyWrapper){var wrapped=value;if(this.__actions__.length){wrapped=new LazyWrapper(this);}wrapped=wrapped.reverse();wrapped.__actions__.push({'func':thru,'args':[reverse],'thisArg':undefined});return new LodashWrapper(wrapped,this.__chain__);}return this.thru(reverse);}/**
     * Executes the chain sequence to resolve the unwrapped value.
     *
     * @name value
     * @memberOf _
     * @since 0.1.0
     * @alias toJSON, valueOf
     * @category Seq
     * @returns {*} Returns the resolved unwrapped value.
     * @example
     *
     * _([1, 2, 3]).value();
     * // => [1, 2, 3]
     */function wrapperValue(){return baseWrapperValue(this.__wrapped__,this.__actions__);}/*------------------------------------------------------------------------*//**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` thru `iteratee`. The corresponding value of
     * each key is the number of times the key was returned by `iteratee`. The
     * iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.countBy([6.1, 4.2, 6.3], Math.floor);
     * // => { '4': 1, '6': 2 }
     *
     * // The `_.property` iteratee shorthand.
     * _.countBy(['one', 'two', 'three'], 'length');
     * // => { '3': 2, '5': 1 }
     */var countBy=createAggregator(function(result,value,key){if(hasOwnProperty.call(result,key)){++result[key];}else{baseAssignValue(result,key,1);}});/**
     * Checks if `predicate` returns truthy for **all** elements of `collection`.
     * Iteration is stopped once `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index|key, collection).
     *
     * **Note:** This method returns `true` for
     * [empty collections](https://en.wikipedia.org/wiki/Empty_set) because
     * [everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of
     * elements of empty collections.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`.
     * @example
     *
     * _.every([true, 1, null, 'yes'], Boolean);
     * // => false
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': false },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * // The `_.matches` iteratee shorthand.
     * _.every(users, { 'user': 'barney', 'active': false });
     * // => false
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.every(users, ['active', false]);
     * // => true
     *
     * // The `_.property` iteratee shorthand.
     * _.every(users, 'active');
     * // => false
     */function every(collection,predicate,guard){var func=isArray(collection)?arrayEvery:baseEvery;if(guard&&isIterateeCall(collection,predicate,guard)){predicate=undefined;}return func(collection,getIteratee(predicate,3));}/**
     * Iterates over elements of `collection`, returning an array of all elements
     * `predicate` returns truthy for. The predicate is invoked with three
     * arguments: (value, index|key, collection).
     *
     * **Note:** Unlike `_.remove`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     * @see _.reject
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * _.filter(users, function(o) { return !o.active; });
     * // => objects for ['fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.filter(users, { 'age': 36, 'active': true });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.filter(users, ['active', false]);
     * // => objects for ['fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.filter(users, 'active');
     * // => objects for ['barney']
     */function filter(collection,predicate){var func=isArray(collection)?arrayFilter:baseFilter;return func(collection,getIteratee(predicate,3));}/**
     * Iterates over elements of `collection`, returning the first element
     * `predicate` returns truthy for. The predicate is invoked with three
     * arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36, 'active': true },
     *   { 'user': 'fred',    'age': 40, 'active': false },
     *   { 'user': 'pebbles', 'age': 1,  'active': true }
     * ];
     *
     * _.find(users, function(o) { return o.age < 40; });
     * // => object for 'barney'
     *
     * // The `_.matches` iteratee shorthand.
     * _.find(users, { 'age': 1, 'active': true });
     * // => object for 'pebbles'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.find(users, ['active', false]);
     * // => object for 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.find(users, 'active');
     * // => object for 'barney'
     */var find=createFind(findIndex);/**
     * This method is like `_.find` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=collection.length-1] The index to search from.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * _.findLast([1, 2, 3, 4], function(n) {
     *   return n % 2 == 1;
     * });
     * // => 3
     */var findLast=createFind(findLastIndex);/**
     * Creates a flattened array of values by running each element in `collection`
     * thru `iteratee` and flattening the mapped results. The iteratee is invoked
     * with three arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * function duplicate(n) {
     *   return [n, n];
     * }
     *
     * _.flatMap([1, 2], duplicate);
     * // => [1, 1, 2, 2]
     */function flatMap(collection,iteratee){return baseFlatten(map(collection,iteratee),1);}/**
     * This method is like `_.flatMap` except that it recursively flattens the
     * mapped results.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * function duplicate(n) {
     *   return [[[n, n]]];
     * }
     *
     * _.flatMapDeep([1, 2], duplicate);
     * // => [1, 1, 2, 2]
     */function flatMapDeep(collection,iteratee){return baseFlatten(map(collection,iteratee),INFINITY);}/**
     * This method is like `_.flatMap` except that it recursively flattens the
     * mapped results up to `depth` times.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {number} [depth=1] The maximum recursion depth.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * function duplicate(n) {
     *   return [[[n, n]]];
     * }
     *
     * _.flatMapDepth([1, 2], duplicate, 2);
     * // => [[1, 1], [2, 2]]
     */function flatMapDepth(collection,iteratee,depth){depth=depth===undefined?1:toInteger(depth);return baseFlatten(map(collection,iteratee),depth);}/**
     * Iterates over elements of `collection` and invokes `iteratee` for each element.
     * The iteratee is invoked with three arguments: (value, index|key, collection).
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * **Note:** As with other "Collections" methods, objects with a "length"
     * property are iterated like arrays. To avoid this behavior use `_.forIn`
     * or `_.forOwn` for object iteration.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @alias each
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     * @see _.forEachRight
     * @example
     *
     * _.forEach([1, 2], function(value) {
     *   console.log(value);
     * });
     * // => Logs `1` then `2`.
     *
     * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a' then 'b' (iteration order is not guaranteed).
     */function forEach(collection,iteratee){var func=isArray(collection)?arrayEach:baseEach;return func(collection,getIteratee(iteratee,3));}/**
     * This method is like `_.forEach` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @alias eachRight
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     * @see _.forEach
     * @example
     *
     * _.forEachRight([1, 2], function(value) {
     *   console.log(value);
     * });
     * // => Logs `2` then `1`.
     */function forEachRight(collection,iteratee){var func=isArray(collection)?arrayEachRight:baseEachRight;return func(collection,getIteratee(iteratee,3));}/**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` thru `iteratee`. The order of grouped values
     * is determined by the order they occur in `collection`. The corresponding
     * value of each key is an array of elements responsible for generating the
     * key. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.groupBy([6.1, 4.2, 6.3], Math.floor);
     * // => { '4': [4.2], '6': [6.1, 6.3] }
     *
     * // The `_.property` iteratee shorthand.
     * _.groupBy(['one', 'two', 'three'], 'length');
     * // => { '3': ['one', 'two'], '5': ['three'] }
     */var groupBy=createAggregator(function(result,value,key){if(hasOwnProperty.call(result,key)){result[key].push(value);}else{baseAssignValue(result,key,[value]);}});/**
     * Checks if `value` is in `collection`. If `collection` is a string, it's
     * checked for a substring of `value`, otherwise
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * is used for equality comparisons. If `fromIndex` is negative, it's used as
     * the offset from the end of `collection`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object|string} collection The collection to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=0] The index to search from.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
     * @returns {boolean} Returns `true` if `value` is found, else `false`.
     * @example
     *
     * _.includes([1, 2, 3], 1);
     * // => true
     *
     * _.includes([1, 2, 3], 1, 2);
     * // => false
     *
     * _.includes({ 'a': 1, 'b': 2 }, 1);
     * // => true
     *
     * _.includes('abcd', 'bc');
     * // => true
     */function includes(collection,value,fromIndex,guard){collection=isArrayLike(collection)?collection:values(collection);fromIndex=fromIndex&&!guard?toInteger(fromIndex):0;var length=collection.length;if(fromIndex<0){fromIndex=nativeMax(length+fromIndex,0);}return isString(collection)?fromIndex<=length&&collection.indexOf(value,fromIndex)>-1:!!length&&baseIndexOf(collection,value,fromIndex)>-1;}/**
     * Invokes the method at `path` of each element in `collection`, returning
     * an array of the results of each invoked method. Any additional arguments
     * are provided to each invoked method. If `path` is a function, it's invoked
     * for, and `this` bound to, each element in `collection`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Array|Function|string} path The path of the method to invoke or
     *  the function invoked per iteration.
     * @param {...*} [args] The arguments to invoke each method with.
     * @returns {Array} Returns the array of results.
     * @example
     *
     * _.invokeMap([[5, 1, 7], [3, 2, 1]], 'sort');
     * // => [[1, 5, 7], [1, 2, 3]]
     *
     * _.invokeMap([123, 456], String.prototype.split, '');
     * // => [['1', '2', '3'], ['4', '5', '6']]
     */var invokeMap=baseRest(function(collection,path,args){var index=-1,isFunc=typeof path=='function',result=isArrayLike(collection)?Array(collection.length):[];baseEach(collection,function(value){result[++index]=isFunc?apply(path,value,args):baseInvoke(value,path,args);});return result;});/**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` thru `iteratee`. The corresponding value of
     * each key is the last element responsible for generating the key. The
     * iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * var array = [
     *   { 'dir': 'left', 'code': 97 },
     *   { 'dir': 'right', 'code': 100 }
     * ];
     *
     * _.keyBy(array, function(o) {
     *   return String.fromCharCode(o.code);
     * });
     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
     *
     * _.keyBy(array, 'dir');
     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
     */var keyBy=createAggregator(function(result,value,key){baseAssignValue(result,key,value);});/**
     * Creates an array of values by running each element in `collection` thru
     * `iteratee`. The iteratee is invoked with three arguments:
     * (value, index|key, collection).
     *
     * Many lodash methods are guarded to work as iteratees for methods like
     * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
     *
     * The guarded methods are:
     * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
     * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
     * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
     * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * _.map([4, 8], square);
     * // => [16, 64]
     *
     * _.map({ 'a': 4, 'b': 8 }, square);
     * // => [16, 64] (iteration order is not guaranteed)
     *
     * var users = [
     *   { 'user': 'barney' },
     *   { 'user': 'fred' }
     * ];
     *
     * // The `_.property` iteratee shorthand.
     * _.map(users, 'user');
     * // => ['barney', 'fred']
     */function map(collection,iteratee){var func=isArray(collection)?arrayMap:baseMap;return func(collection,getIteratee(iteratee,3));}/**
     * This method is like `_.sortBy` except that it allows specifying the sort
     * orders of the iteratees to sort by. If `orders` is unspecified, all values
     * are sorted in ascending order. Otherwise, specify an order of "desc" for
     * descending or "asc" for ascending sort order of corresponding values.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Array[]|Function[]|Object[]|string[]} [iteratees=[_.identity]]
     *  The iteratees to sort by.
     * @param {string[]} [orders] The sort orders of `iteratees`.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
     * @returns {Array} Returns the new sorted array.
     * @example
     *
     * var users = [
     *   { 'user': 'fred',   'age': 48 },
     *   { 'user': 'barney', 'age': 34 },
     *   { 'user': 'fred',   'age': 40 },
     *   { 'user': 'barney', 'age': 36 }
     * ];
     *
     * // Sort by `user` in ascending order and by `age` in descending order.
     * _.orderBy(users, ['user', 'age'], ['asc', 'desc']);
     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
     */function orderBy(collection,iteratees,orders,guard){if(collection==null){return[];}if(!isArray(iteratees)){iteratees=iteratees==null?[]:[iteratees];}orders=guard?undefined:orders;if(!isArray(orders)){orders=orders==null?[]:[orders];}return baseOrderBy(collection,iteratees,orders);}/**
     * Creates an array of elements split into two groups, the first of which
     * contains elements `predicate` returns truthy for, the second of which
     * contains elements `predicate` returns falsey for. The predicate is
     * invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the array of grouped elements.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36, 'active': false },
     *   { 'user': 'fred',    'age': 40, 'active': true },
     *   { 'user': 'pebbles', 'age': 1,  'active': false }
     * ];
     *
     * _.partition(users, function(o) { return o.active; });
     * // => objects for [['fred'], ['barney', 'pebbles']]
     *
     * // The `_.matches` iteratee shorthand.
     * _.partition(users, { 'age': 1, 'active': false });
     * // => objects for [['pebbles'], ['barney', 'fred']]
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.partition(users, ['active', false]);
     * // => objects for [['barney', 'pebbles'], ['fred']]
     *
     * // The `_.property` iteratee shorthand.
     * _.partition(users, 'active');
     * // => objects for [['fred'], ['barney', 'pebbles']]
     */var partition=createAggregator(function(result,value,key){result[key?0:1].push(value);},function(){return[[],[]];});/**
     * Reduces `collection` to a value which is the accumulated result of running
     * each element in `collection` thru `iteratee`, where each successive
     * invocation is supplied the return value of the previous. If `accumulator`
     * is not given, the first element of `collection` is used as the initial
     * value. The iteratee is invoked with four arguments:
     * (accumulator, value, index|key, collection).
     *
     * Many lodash methods are guarded to work as iteratees for methods like
     * `_.reduce`, `_.reduceRight`, and `_.transform`.
     *
     * The guarded methods are:
     * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,
     * and `sortBy`
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @returns {*} Returns the accumulated value.
     * @see _.reduceRight
     * @example
     *
     * _.reduce([1, 2], function(sum, n) {
     *   return sum + n;
     * }, 0);
     * // => 3
     *
     * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
     *   (result[value] || (result[value] = [])).push(key);
     *   return result;
     * }, {});
     * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)
     */function reduce(collection,iteratee,accumulator){var func=isArray(collection)?arrayReduce:baseReduce,initAccum=arguments.length<3;return func(collection,getIteratee(iteratee,4),accumulator,initAccum,baseEach);}/**
     * This method is like `_.reduce` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @returns {*} Returns the accumulated value.
     * @see _.reduce
     * @example
     *
     * var array = [[0, 1], [2, 3], [4, 5]];
     *
     * _.reduceRight(array, function(flattened, other) {
     *   return flattened.concat(other);
     * }, []);
     * // => [4, 5, 2, 3, 0, 1]
     */function reduceRight(collection,iteratee,accumulator){var func=isArray(collection)?arrayReduceRight:baseReduce,initAccum=arguments.length<3;return func(collection,getIteratee(iteratee,4),accumulator,initAccum,baseEachRight);}/**
     * The opposite of `_.filter`; this method returns the elements of `collection`
     * that `predicate` does **not** return truthy for.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     * @see _.filter
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': false },
     *   { 'user': 'fred',   'age': 40, 'active': true }
     * ];
     *
     * _.reject(users, function(o) { return !o.active; });
     * // => objects for ['fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.reject(users, { 'age': 40, 'active': true });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.reject(users, ['active', false]);
     * // => objects for ['fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.reject(users, 'active');
     * // => objects for ['barney']
     */function reject(collection,predicate){var func=isArray(collection)?arrayFilter:baseFilter;return func(collection,negate(getIteratee(predicate,3)));}/**
     * Gets a random element from `collection`.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to sample.
     * @returns {*} Returns the random element.
     * @example
     *
     * _.sample([1, 2, 3, 4]);
     * // => 2
     */function sample(collection){var func=isArray(collection)?arraySample:baseSample;return func(collection);}/**
     * Gets `n` random elements at unique keys from `collection` up to the
     * size of `collection`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to sample.
     * @param {number} [n=1] The number of elements to sample.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the random elements.
     * @example
     *
     * _.sampleSize([1, 2, 3], 2);
     * // => [3, 1]
     *
     * _.sampleSize([1, 2, 3], 4);
     * // => [2, 3, 1]
     */function sampleSize(collection,n,guard){if(guard?isIterateeCall(collection,n,guard):n===undefined){n=1;}else{n=toInteger(n);}var func=isArray(collection)?arraySampleSize:baseSampleSize;return func(collection,n);}/**
     * Creates an array of shuffled values, using a version of the
     * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to shuffle.
     * @returns {Array} Returns the new shuffled array.
     * @example
     *
     * _.shuffle([1, 2, 3, 4]);
     * // => [4, 1, 3, 2]
     */function shuffle(collection){var func=isArray(collection)?arrayShuffle:baseShuffle;return func(collection);}/**
     * Gets the size of `collection` by returning its length for array-like
     * values or the number of own enumerable string keyed properties for objects.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object|string} collection The collection to inspect.
     * @returns {number} Returns the collection size.
     * @example
     *
     * _.size([1, 2, 3]);
     * // => 3
     *
     * _.size({ 'a': 1, 'b': 2 });
     * // => 2
     *
     * _.size('pebbles');
     * // => 7
     */function size(collection){if(collection==null){return 0;}if(isArrayLike(collection)){return isString(collection)?stringSize(collection):collection.length;}var tag=getTag(collection);if(tag==mapTag||tag==setTag){return collection.size;}return baseKeys(collection).length;}/**
     * Checks if `predicate` returns truthy for **any** element of `collection`.
     * Iteration is stopped once `predicate` returns truthy. The predicate is
     * invoked with three arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     * @example
     *
     * _.some([null, 0, 'yes', false], Boolean);
     * // => true
     *
     * var users = [
     *   { 'user': 'barney', 'active': true },
     *   { 'user': 'fred',   'active': false }
     * ];
     *
     * // The `_.matches` iteratee shorthand.
     * _.some(users, { 'user': 'barney', 'active': false });
     * // => false
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.some(users, ['active', false]);
     * // => true
     *
     * // The `_.property` iteratee shorthand.
     * _.some(users, 'active');
     * // => true
     */function some(collection,predicate,guard){var func=isArray(collection)?arraySome:baseSome;if(guard&&isIterateeCall(collection,predicate,guard)){predicate=undefined;}return func(collection,getIteratee(predicate,3));}/**
     * Creates an array of elements, sorted in ascending order by the results of
     * running each element in a collection thru each iteratee. This method
     * performs a stable sort, that is, it preserves the original sort order of
     * equal elements. The iteratees are invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {...(Function|Function[])} [iteratees=[_.identity]]
     *  The iteratees to sort by.
     * @returns {Array} Returns the new sorted array.
     * @example
     *
     * var users = [
     *   { 'user': 'fred',   'age': 48 },
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 },
     *   { 'user': 'barney', 'age': 34 }
     * ];
     *
     * _.sortBy(users, [function(o) { return o.user; }]);
     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
     *
     * _.sortBy(users, ['user', 'age']);
     * // => objects for [['barney', 34], ['barney', 36], ['fred', 40], ['fred', 48]]
     */var sortBy=baseRest(function(collection,iteratees){if(collection==null){return[];}var length=iteratees.length;if(length>1&&isIterateeCall(collection,iteratees[0],iteratees[1])){iteratees=[];}else if(length>2&&isIterateeCall(iteratees[0],iteratees[1],iteratees[2])){iteratees=[iteratees[0]];}return baseOrderBy(collection,baseFlatten(iteratees,1),[]);});/*------------------------------------------------------------------------*//**
     * Gets the timestamp of the number of milliseconds that have elapsed since
     * the Unix epoch (1 January 1970 00:00:00 UTC).
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Date
     * @returns {number} Returns the timestamp.
     * @example
     *
     * _.defer(function(stamp) {
     *   console.log(_.now() - stamp);
     * }, _.now());
     * // => Logs the number of milliseconds it took for the deferred invocation.
     */var now=ctxNow||function(){return root.Date.now();};/*------------------------------------------------------------------------*//**
     * The opposite of `_.before`; this method creates a function that invokes
     * `func` once it's called `n` or more times.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {number} n The number of calls before `func` is invoked.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var saves = ['profile', 'settings'];
     *
     * var done = _.after(saves.length, function() {
     *   console.log('done saving!');
     * });
     *
     * _.forEach(saves, function(type) {
     *   asyncSave({ 'type': type, 'complete': done });
     * });
     * // => Logs 'done saving!' after the two async saves have completed.
     */function after(n,func){if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}n=toInteger(n);return function(){if(--n<1){return func.apply(this,arguments);}};}/**
     * Creates a function that invokes `func`, with up to `n` arguments,
     * ignoring any additional arguments.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} func The function to cap arguments for.
     * @param {number} [n=func.length] The arity cap.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the new capped function.
     * @example
     *
     * _.map(['6', '8', '10'], _.ary(parseInt, 1));
     * // => [6, 8, 10]
     */function ary(func,n,guard){n=guard?undefined:n;n=func&&n==null?func.length:n;return createWrap(func,WRAP_ARY_FLAG,undefined,undefined,undefined,undefined,n);}/**
     * Creates a function that invokes `func`, with the `this` binding and arguments
     * of the created function, while it's called less than `n` times. Subsequent
     * calls to the created function return the result of the last `func` invocation.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {number} n The number of calls at which `func` is no longer invoked.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * jQuery(element).on('click', _.before(5, addContactToList));
     * // => Allows adding up to 4 contacts to the list.
     */function before(n,func){var result;if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}n=toInteger(n);return function(){if(--n>0){result=func.apply(this,arguments);}if(n<=1){func=undefined;}return result;};}/**
     * Creates a function that invokes `func` with the `this` binding of `thisArg`
     * and `partials` prepended to the arguments it receives.
     *
     * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
     * may be used as a placeholder for partially applied arguments.
     *
     * **Note:** Unlike native `Function#bind`, this method doesn't set the "length"
     * property of bound functions.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to bind.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * function greet(greeting, punctuation) {
     *   return greeting + ' ' + this.user + punctuation;
     * }
     *
     * var object = { 'user': 'fred' };
     *
     * var bound = _.bind(greet, object, 'hi');
     * bound('!');
     * // => 'hi fred!'
     *
     * // Bound with placeholders.
     * var bound = _.bind(greet, object, _, '!');
     * bound('hi');
     * // => 'hi fred!'
     */var bind=baseRest(function(func,thisArg,partials){var bitmask=WRAP_BIND_FLAG;if(partials.length){var holders=replaceHolders(partials,getHolder(bind));bitmask|=WRAP_PARTIAL_FLAG;}return createWrap(func,bitmask,thisArg,partials,holders);});/**
     * Creates a function that invokes the method at `object[key]` with `partials`
     * prepended to the arguments it receives.
     *
     * This method differs from `_.bind` by allowing bound functions to reference
     * methods that may be redefined or don't yet exist. See
     * [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)
     * for more details.
     *
     * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * @static
     * @memberOf _
     * @since 0.10.0
     * @category Function
     * @param {Object} object The object to invoke the method on.
     * @param {string} key The key of the method.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * var object = {
     *   'user': 'fred',
     *   'greet': function(greeting, punctuation) {
     *     return greeting + ' ' + this.user + punctuation;
     *   }
     * };
     *
     * var bound = _.bindKey(object, 'greet', 'hi');
     * bound('!');
     * // => 'hi fred!'
     *
     * object.greet = function(greeting, punctuation) {
     *   return greeting + 'ya ' + this.user + punctuation;
     * };
     *
     * bound('!');
     * // => 'hiya fred!'
     *
     * // Bound with placeholders.
     * var bound = _.bindKey(object, 'greet', _, '!');
     * bound('hi');
     * // => 'hiya fred!'
     */var bindKey=baseRest(function(object,key,partials){var bitmask=WRAP_BIND_FLAG|WRAP_BIND_KEY_FLAG;if(partials.length){var holders=replaceHolders(partials,getHolder(bindKey));bitmask|=WRAP_PARTIAL_FLAG;}return createWrap(key,bitmask,object,partials,holders);});/**
     * Creates a function that accepts arguments of `func` and either invokes
     * `func` returning its result, if at least `arity` number of arguments have
     * been provided, or returns a function that accepts the remaining `func`
     * arguments, and so on. The arity of `func` may be specified if `func.length`
     * is not sufficient.
     *
     * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,
     * may be used as a placeholder for provided arguments.
     *
     * **Note:** This method doesn't set the "length" property of curried functions.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Function
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var abc = function(a, b, c) {
     *   return [a, b, c];
     * };
     *
     * var curried = _.curry(abc);
     *
     * curried(1)(2)(3);
     * // => [1, 2, 3]
     *
     * curried(1, 2)(3);
     * // => [1, 2, 3]
     *
     * curried(1, 2, 3);
     * // => [1, 2, 3]
     *
     * // Curried with placeholders.
     * curried(1)(_, 3)(2);
     * // => [1, 2, 3]
     */function curry(func,arity,guard){arity=guard?undefined:arity;var result=createWrap(func,WRAP_CURRY_FLAG,undefined,undefined,undefined,undefined,undefined,arity);result.placeholder=curry.placeholder;return result;}/**
     * This method is like `_.curry` except that arguments are applied to `func`
     * in the manner of `_.partialRight` instead of `_.partial`.
     *
     * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for provided arguments.
     *
     * **Note:** This method doesn't set the "length" property of curried functions.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var abc = function(a, b, c) {
     *   return [a, b, c];
     * };
     *
     * var curried = _.curryRight(abc);
     *
     * curried(3)(2)(1);
     * // => [1, 2, 3]
     *
     * curried(2, 3)(1);
     * // => [1, 2, 3]
     *
     * curried(1, 2, 3);
     * // => [1, 2, 3]
     *
     * // Curried with placeholders.
     * curried(3)(1, _)(2);
     * // => [1, 2, 3]
     */function curryRight(func,arity,guard){arity=guard?undefined:arity;var result=createWrap(func,WRAP_CURRY_RIGHT_FLAG,undefined,undefined,undefined,undefined,undefined,arity);result.placeholder=curryRight.placeholder;return result;}/**
     * Creates a debounced function that delays invoking `func` until after `wait`
     * milliseconds have elapsed since the last time the debounced function was
     * invoked. The debounced function comes with a `cancel` method to cancel
     * delayed `func` invocations and a `flush` method to immediately invoke them.
     * Provide `options` to indicate whether `func` should be invoked on the
     * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
     * with the last arguments provided to the debounced function. Subsequent
     * calls to the debounced function return the result of the last `func`
     * invocation.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is
     * invoked on the trailing edge of the timeout only if the debounced function
     * is invoked more than once during the `wait` timeout.
     *
     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
     *
     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
     * for details over the differences between `_.debounce` and `_.throttle`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to debounce.
     * @param {number} [wait=0] The number of milliseconds to delay.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.leading=false]
     *  Specify invoking on the leading edge of the timeout.
     * @param {number} [options.maxWait]
     *  The maximum time `func` is allowed to be delayed before it's invoked.
     * @param {boolean} [options.trailing=true]
     *  Specify invoking on the trailing edge of the timeout.
     * @returns {Function} Returns the new debounced function.
     * @example
     *
     * // Avoid costly calculations while the window size is in flux.
     * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
     *
     * // Invoke `sendMail` when clicked, debouncing subsequent calls.
     * jQuery(element).on('click', _.debounce(sendMail, 300, {
     *   'leading': true,
     *   'trailing': false
     * }));
     *
     * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
     * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
     * var source = new EventSource('/stream');
     * jQuery(source).on('message', debounced);
     *
     * // Cancel the trailing debounced invocation.
     * jQuery(window).on('popstate', debounced.cancel);
     */function debounce(func,wait,options){var lastArgs,lastThis,maxWait,result,timerId,lastCallTime,lastInvokeTime=0,leading=false,maxing=false,trailing=true;if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}wait=toNumber(wait)||0;if(isObject(options)){leading=!!options.leading;maxing='maxWait'in options;maxWait=maxing?nativeMax(toNumber(options.maxWait)||0,wait):maxWait;trailing='trailing'in options?!!options.trailing:trailing;}function invokeFunc(time){var args=lastArgs,thisArg=lastThis;lastArgs=lastThis=undefined;lastInvokeTime=time;result=func.apply(thisArg,args);return result;}function leadingEdge(time){// Reset any `maxWait` timer.
lastInvokeTime=time;// Start the timer for the trailing edge.
timerId=setTimeout(timerExpired,wait);// Invoke the leading edge.
return leading?invokeFunc(time):result;}function remainingWait(time){var timeSinceLastCall=time-lastCallTime,timeSinceLastInvoke=time-lastInvokeTime,result=wait-timeSinceLastCall;return maxing?nativeMin(result,maxWait-timeSinceLastInvoke):result;}function shouldInvoke(time){var timeSinceLastCall=time-lastCallTime,timeSinceLastInvoke=time-lastInvokeTime;// Either this is the first call, activity has stopped and we're at the
// trailing edge, the system time has gone backwards and we're treating
// it as the trailing edge, or we've hit the `maxWait` limit.
return lastCallTime===undefined||timeSinceLastCall>=wait||timeSinceLastCall<0||maxing&&timeSinceLastInvoke>=maxWait;}function timerExpired(){var time=now();if(shouldInvoke(time)){return trailingEdge(time);}// Restart the timer.
timerId=setTimeout(timerExpired,remainingWait(time));}function trailingEdge(time){timerId=undefined;// Only invoke if we have `lastArgs` which means `func` has been
// debounced at least once.
if(trailing&&lastArgs){return invokeFunc(time);}lastArgs=lastThis=undefined;return result;}function cancel(){if(timerId!==undefined){clearTimeout(timerId);}lastInvokeTime=0;lastArgs=lastCallTime=lastThis=timerId=undefined;}function flush(){return timerId===undefined?result:trailingEdge(now());}function debounced(){var time=now(),isInvoking=shouldInvoke(time);lastArgs=arguments;lastThis=this;lastCallTime=time;if(isInvoking){if(timerId===undefined){return leadingEdge(lastCallTime);}if(maxing){// Handle invocations in a tight loop.
timerId=setTimeout(timerExpired,wait);return invokeFunc(lastCallTime);}}if(timerId===undefined){timerId=setTimeout(timerExpired,wait);}return result;}debounced.cancel=cancel;debounced.flush=flush;return debounced;}/**
     * Defers invoking the `func` until the current call stack has cleared. Any
     * additional arguments are provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to defer.
     * @param {...*} [args] The arguments to invoke `func` with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.defer(function(text) {
     *   console.log(text);
     * }, 'deferred');
     * // => Logs 'deferred' after one millisecond.
     */var defer=baseRest(function(func,args){return baseDelay(func,1,args);});/**
     * Invokes `func` after `wait` milliseconds. Any additional arguments are
     * provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @param {...*} [args] The arguments to invoke `func` with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.delay(function(text) {
     *   console.log(text);
     * }, 1000, 'later');
     * // => Logs 'later' after one second.
     */var delay=baseRest(function(func,wait,args){return baseDelay(func,toNumber(wait)||0,args);});/**
     * Creates a function that invokes `func` with arguments reversed.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Function
     * @param {Function} func The function to flip arguments for.
     * @returns {Function} Returns the new flipped function.
     * @example
     *
     * var flipped = _.flip(function() {
     *   return _.toArray(arguments);
     * });
     *
     * flipped('a', 'b', 'c', 'd');
     * // => ['d', 'c', 'b', 'a']
     */function flip(func){return createWrap(func,WRAP_FLIP_FLAG);}/**
     * Creates a function that memoizes the result of `func`. If `resolver` is
     * provided, it determines the cache key for storing the result based on the
     * arguments provided to the memoized function. By default, the first argument
     * provided to the memoized function is used as the map cache key. The `func`
     * is invoked with the `this` binding of the memoized function.
     *
     * **Note:** The cache is exposed as the `cache` property on the memoized
     * function. Its creation may be customized by replacing the `_.memoize.Cache`
     * constructor with one whose instances implement the
     * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
     * method interface of `clear`, `delete`, `get`, `has`, and `set`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to have its output memoized.
     * @param {Function} [resolver] The function to resolve the cache key.
     * @returns {Function} Returns the new memoized function.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     * var other = { 'c': 3, 'd': 4 };
     *
     * var values = _.memoize(_.values);
     * values(object);
     * // => [1, 2]
     *
     * values(other);
     * // => [3, 4]
     *
     * object.a = 2;
     * values(object);
     * // => [1, 2]
     *
     * // Modify the result cache.
     * values.cache.set(object, ['a', 'b']);
     * values(object);
     * // => ['a', 'b']
     *
     * // Replace `_.memoize.Cache`.
     * _.memoize.Cache = WeakMap;
     */function memoize(func,resolver){if(typeof func!='function'||resolver!=null&&typeof resolver!='function'){throw new TypeError(FUNC_ERROR_TEXT);}var memoized=function(){var args=arguments,key=resolver?resolver.apply(this,args):args[0],cache=memoized.cache;if(cache.has(key)){return cache.get(key);}var result=func.apply(this,args);memoized.cache=cache.set(key,result)||cache;return result;};memoized.cache=new(memoize.Cache||MapCache)();return memoized;}// Expose `MapCache`.
memoize.Cache=MapCache;/**
     * Creates a function that negates the result of the predicate `func`. The
     * `func` predicate is invoked with the `this` binding and arguments of the
     * created function.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} predicate The predicate to negate.
     * @returns {Function} Returns the new negated function.
     * @example
     *
     * function isEven(n) {
     *   return n % 2 == 0;
     * }
     *
     * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
     * // => [1, 3, 5]
     */function negate(predicate){if(typeof predicate!='function'){throw new TypeError(FUNC_ERROR_TEXT);}return function(){var args=arguments;switch(args.length){case 0:return!predicate.call(this);case 1:return!predicate.call(this,args[0]);case 2:return!predicate.call(this,args[0],args[1]);case 3:return!predicate.call(this,args[0],args[1],args[2]);}return!predicate.apply(this,args);};}/**
     * Creates a function that is restricted to invoking `func` once. Repeat calls
     * to the function return the value of the first invocation. The `func` is
     * invoked with the `this` binding and arguments of the created function.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var initialize = _.once(createApplication);
     * initialize();
     * initialize();
     * // => `createApplication` is invoked once
     */function once(func){return before(2,func);}/**
     * Creates a function that invokes `func` with its arguments transformed.
     *
     * @static
     * @since 4.0.0
     * @memberOf _
     * @category Function
     * @param {Function} func The function to wrap.
     * @param {...(Function|Function[])} [transforms=[_.identity]]
     *  The argument transforms.
     * @returns {Function} Returns the new function.
     * @example
     *
     * function doubled(n) {
     *   return n * 2;
     * }
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var func = _.overArgs(function(x, y) {
     *   return [x, y];
     * }, [square, doubled]);
     *
     * func(9, 3);
     * // => [81, 6]
     *
     * func(10, 5);
     * // => [100, 10]
     */var overArgs=castRest(function(func,transforms){transforms=transforms.length==1&&isArray(transforms[0])?arrayMap(transforms[0],baseUnary(getIteratee())):arrayMap(baseFlatten(transforms,1),baseUnary(getIteratee()));var funcsLength=transforms.length;return baseRest(function(args){var index=-1,length=nativeMin(args.length,funcsLength);while(++index<length){args[index]=transforms[index].call(this,args[index]);}return apply(func,this,args);});});/**
     * Creates a function that invokes `func` with `partials` prepended to the
     * arguments it receives. This method is like `_.bind` except it does **not**
     * alter the `this` binding.
     *
     * The `_.partial.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * **Note:** This method doesn't set the "length" property of partially
     * applied functions.
     *
     * @static
     * @memberOf _
     * @since 0.2.0
     * @category Function
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * function greet(greeting, name) {
     *   return greeting + ' ' + name;
     * }
     *
     * var sayHelloTo = _.partial(greet, 'hello');
     * sayHelloTo('fred');
     * // => 'hello fred'
     *
     * // Partially applied with placeholders.
     * var greetFred = _.partial(greet, _, 'fred');
     * greetFred('hi');
     * // => 'hi fred'
     */var partial=baseRest(function(func,partials){var holders=replaceHolders(partials,getHolder(partial));return createWrap(func,WRAP_PARTIAL_FLAG,undefined,partials,holders);});/**
     * This method is like `_.partial` except that partially applied arguments
     * are appended to the arguments it receives.
     *
     * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * **Note:** This method doesn't set the "length" property of partially
     * applied functions.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Function
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * function greet(greeting, name) {
     *   return greeting + ' ' + name;
     * }
     *
     * var greetFred = _.partialRight(greet, 'fred');
     * greetFred('hi');
     * // => 'hi fred'
     *
     * // Partially applied with placeholders.
     * var sayHelloTo = _.partialRight(greet, 'hello', _);
     * sayHelloTo('fred');
     * // => 'hello fred'
     */var partialRight=baseRest(function(func,partials){var holders=replaceHolders(partials,getHolder(partialRight));return createWrap(func,WRAP_PARTIAL_RIGHT_FLAG,undefined,partials,holders);});/**
     * Creates a function that invokes `func` with arguments arranged according
     * to the specified `indexes` where the argument value at the first index is
     * provided as the first argument, the argument value at the second index is
     * provided as the second argument, and so on.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} func The function to rearrange arguments for.
     * @param {...(number|number[])} indexes The arranged argument indexes.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var rearged = _.rearg(function(a, b, c) {
     *   return [a, b, c];
     * }, [2, 0, 1]);
     *
     * rearged('b', 'c', 'a')
     * // => ['a', 'b', 'c']
     */var rearg=flatRest(function(func,indexes){return createWrap(func,WRAP_REARG_FLAG,undefined,undefined,undefined,indexes);});/**
     * Creates a function that invokes `func` with the `this` binding of the
     * created function and arguments from `start` and beyond provided as
     * an array.
     *
     * **Note:** This method is based on the
     * [rest parameter](https://mdn.io/rest_parameters).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Function
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var say = _.rest(function(what, names) {
     *   return what + ' ' + _.initial(names).join(', ') +
     *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
     * });
     *
     * say('hello', 'fred', 'barney', 'pebbles');
     * // => 'hello fred, barney, & pebbles'
     */function rest(func,start){if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}start=start===undefined?start:toInteger(start);return baseRest(func,start);}/**
     * Creates a function that invokes `func` with the `this` binding of the
     * create function and an array of arguments much like
     * [`Function#apply`](http://www.ecma-international.org/ecma-262/7.0/#sec-function.prototype.apply).
     *
     * **Note:** This method is based on the
     * [spread operator](https://mdn.io/spread_operator).
     *
     * @static
     * @memberOf _
     * @since 3.2.0
     * @category Function
     * @param {Function} func The function to spread arguments over.
     * @param {number} [start=0] The start position of the spread.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var say = _.spread(function(who, what) {
     *   return who + ' says ' + what;
     * });
     *
     * say(['fred', 'hello']);
     * // => 'fred says hello'
     *
     * var numbers = Promise.all([
     *   Promise.resolve(40),
     *   Promise.resolve(36)
     * ]);
     *
     * numbers.then(_.spread(function(x, y) {
     *   return x + y;
     * }));
     * // => a Promise of 76
     */function spread(func,start){if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}start=start==null?0:nativeMax(toInteger(start),0);return baseRest(function(args){var array=args[start],otherArgs=castSlice(args,0,start);if(array){arrayPush(otherArgs,array);}return apply(func,this,otherArgs);});}/**
     * Creates a throttled function that only invokes `func` at most once per
     * every `wait` milliseconds. The throttled function comes with a `cancel`
     * method to cancel delayed `func` invocations and a `flush` method to
     * immediately invoke them. Provide `options` to indicate whether `func`
     * should be invoked on the leading and/or trailing edge of the `wait`
     * timeout. The `func` is invoked with the last arguments provided to the
     * throttled function. Subsequent calls to the throttled function return the
     * result of the last `func` invocation.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is
     * invoked on the trailing edge of the timeout only if the throttled function
     * is invoked more than once during the `wait` timeout.
     *
     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
     *
     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
     * for details over the differences between `_.throttle` and `_.debounce`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to throttle.
     * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.leading=true]
     *  Specify invoking on the leading edge of the timeout.
     * @param {boolean} [options.trailing=true]
     *  Specify invoking on the trailing edge of the timeout.
     * @returns {Function} Returns the new throttled function.
     * @example
     *
     * // Avoid excessively updating the position while scrolling.
     * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
     *
     * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
     * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
     * jQuery(element).on('click', throttled);
     *
     * // Cancel the trailing throttled invocation.
     * jQuery(window).on('popstate', throttled.cancel);
     */function throttle(func,wait,options){var leading=true,trailing=true;if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}if(isObject(options)){leading='leading'in options?!!options.leading:leading;trailing='trailing'in options?!!options.trailing:trailing;}return debounce(func,wait,{'leading':leading,'maxWait':wait,'trailing':trailing});}/**
     * Creates a function that accepts up to one argument, ignoring any
     * additional arguments.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Function
     * @param {Function} func The function to cap arguments for.
     * @returns {Function} Returns the new capped function.
     * @example
     *
     * _.map(['6', '8', '10'], _.unary(parseInt));
     * // => [6, 8, 10]
     */function unary(func){return ary(func,1);}/**
     * Creates a function that provides `value` to `wrapper` as its first
     * argument. Any additional arguments provided to the function are appended
     * to those provided to the `wrapper`. The wrapper is invoked with the `this`
     * binding of the created function.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {*} value The value to wrap.
     * @param {Function} [wrapper=identity] The wrapper function.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var p = _.wrap(_.escape, function(func, text) {
     *   return '<p>' + func(text) + '</p>';
     * });
     *
     * p('fred, barney, & pebbles');
     * // => '<p>fred, barney, &amp; pebbles</p>'
     */function wrap(value,wrapper){return partial(castFunction(wrapper),value);}/*------------------------------------------------------------------------*//**
     * Casts `value` as an array if it's not one.
     *
     * @static
     * @memberOf _
     * @since 4.4.0
     * @category Lang
     * @param {*} value The value to inspect.
     * @returns {Array} Returns the cast array.
     * @example
     *
     * _.castArray(1);
     * // => [1]
     *
     * _.castArray({ 'a': 1 });
     * // => [{ 'a': 1 }]
     *
     * _.castArray('abc');
     * // => ['abc']
     *
     * _.castArray(null);
     * // => [null]
     *
     * _.castArray(undefined);
     * // => [undefined]
     *
     * _.castArray();
     * // => []
     *
     * var array = [1, 2, 3];
     * console.log(_.castArray(array) === array);
     * // => true
     */function castArray(){if(!arguments.length){return[];}var value=arguments[0];return isArray(value)?value:[value];}/**
     * Creates a shallow clone of `value`.
     *
     * **Note:** This method is loosely based on the
     * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
     * and supports cloning arrays, array buffers, booleans, date objects, maps,
     * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
     * arrays. The own enumerable properties of `arguments` objects are cloned
     * as plain objects. An empty object is returned for uncloneable values such
     * as error objects, functions, DOM nodes, and WeakMaps.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to clone.
     * @returns {*} Returns the cloned value.
     * @see _.cloneDeep
     * @example
     *
     * var objects = [{ 'a': 1 }, { 'b': 2 }];
     *
     * var shallow = _.clone(objects);
     * console.log(shallow[0] === objects[0]);
     * // => true
     */function clone(value){return baseClone(value,CLONE_SYMBOLS_FLAG);}/**
     * This method is like `_.clone` except that it accepts `customizer` which
     * is invoked to produce the cloned value. If `customizer` returns `undefined`,
     * cloning is handled by the method instead. The `customizer` is invoked with
     * up to four arguments; (value [, index|key, object, stack]).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to clone.
     * @param {Function} [customizer] The function to customize cloning.
     * @returns {*} Returns the cloned value.
     * @see _.cloneDeepWith
     * @example
     *
     * function customizer(value) {
     *   if (_.isElement(value)) {
     *     return value.cloneNode(false);
     *   }
     * }
     *
     * var el = _.cloneWith(document.body, customizer);
     *
     * console.log(el === document.body);
     * // => false
     * console.log(el.nodeName);
     * // => 'BODY'
     * console.log(el.childNodes.length);
     * // => 0
     */function cloneWith(value,customizer){customizer=typeof customizer=='function'?customizer:undefined;return baseClone(value,CLONE_SYMBOLS_FLAG,customizer);}/**
     * This method is like `_.clone` except that it recursively clones `value`.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Lang
     * @param {*} value The value to recursively clone.
     * @returns {*} Returns the deep cloned value.
     * @see _.clone
     * @example
     *
     * var objects = [{ 'a': 1 }, { 'b': 2 }];
     *
     * var deep = _.cloneDeep(objects);
     * console.log(deep[0] === objects[0]);
     * // => false
     */function cloneDeep(value){return baseClone(value,CLONE_DEEP_FLAG|CLONE_SYMBOLS_FLAG);}/**
     * This method is like `_.cloneWith` except that it recursively clones `value`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to recursively clone.
     * @param {Function} [customizer] The function to customize cloning.
     * @returns {*} Returns the deep cloned value.
     * @see _.cloneWith
     * @example
     *
     * function customizer(value) {
     *   if (_.isElement(value)) {
     *     return value.cloneNode(true);
     *   }
     * }
     *
     * var el = _.cloneDeepWith(document.body, customizer);
     *
     * console.log(el === document.body);
     * // => false
     * console.log(el.nodeName);
     * // => 'BODY'
     * console.log(el.childNodes.length);
     * // => 20
     */function cloneDeepWith(value,customizer){customizer=typeof customizer=='function'?customizer:undefined;return baseClone(value,CLONE_DEEP_FLAG|CLONE_SYMBOLS_FLAG,customizer);}/**
     * Checks if `object` conforms to `source` by invoking the predicate
     * properties of `source` with the corresponding property values of `object`.
     *
     * **Note:** This method is equivalent to `_.conforms` when `source` is
     * partially applied.
     *
     * @static
     * @memberOf _
     * @since 4.14.0
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property predicates to conform to.
     * @returns {boolean} Returns `true` if `object` conforms, else `false`.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     *
     * _.conformsTo(object, { 'b': function(n) { return n > 1; } });
     * // => true
     *
     * _.conformsTo(object, { 'b': function(n) { return n > 2; } });
     * // => false
     */function conformsTo(object,source){return source==null||baseConformsTo(object,source,keys(source));}/**
     * Performs a
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * comparison between two values to determine if they are equivalent.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'a': 1 };
     * var other = { 'a': 1 };
     *
     * _.eq(object, object);
     * // => true
     *
     * _.eq(object, other);
     * // => false
     *
     * _.eq('a', 'a');
     * // => true
     *
     * _.eq('a', Object('a'));
     * // => false
     *
     * _.eq(NaN, NaN);
     * // => true
     */function eq(value,other){return value===other||value!==value&&other!==other;}/**
     * Checks if `value` is greater than `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than `other`,
     *  else `false`.
     * @see _.lt
     * @example
     *
     * _.gt(3, 1);
     * // => true
     *
     * _.gt(3, 3);
     * // => false
     *
     * _.gt(1, 3);
     * // => false
     */var gt=createRelationalOperation(baseGt);/**
     * Checks if `value` is greater than or equal to `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than or equal to
     *  `other`, else `false`.
     * @see _.lte
     * @example
     *
     * _.gte(3, 1);
     * // => true
     *
     * _.gte(3, 3);
     * // => true
     *
     * _.gte(1, 3);
     * // => false
     */var gte=createRelationalOperation(function(value,other){return value>=other;});/**
     * Checks if `value` is likely an `arguments` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     *  else `false`.
     * @example
     *
     * _.isArguments(function() { return arguments; }());
     * // => true
     *
     * _.isArguments([1, 2, 3]);
     * // => false
     */var isArguments=baseIsArguments(function(){return arguments;}())?baseIsArguments:function(value){return isObjectLike(value)&&hasOwnProperty.call(value,'callee')&&!propertyIsEnumerable.call(value,'callee');};/**
     * Checks if `value` is classified as an `Array` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array, else `false`.
     * @example
     *
     * _.isArray([1, 2, 3]);
     * // => true
     *
     * _.isArray(document.body.children);
     * // => false
     *
     * _.isArray('abc');
     * // => false
     *
     * _.isArray(_.noop);
     * // => false
     */var isArray=Array.isArray;/**
     * Checks if `value` is classified as an `ArrayBuffer` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
     * @example
     *
     * _.isArrayBuffer(new ArrayBuffer(2));
     * // => true
     *
     * _.isArrayBuffer(new Array(2));
     * // => false
     */var isArrayBuffer=nodeIsArrayBuffer?baseUnary(nodeIsArrayBuffer):baseIsArrayBuffer;/**
     * Checks if `value` is array-like. A value is considered array-like if it's
     * not a function and has a `value.length` that's an integer greater than or
     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
     * @example
     *
     * _.isArrayLike([1, 2, 3]);
     * // => true
     *
     * _.isArrayLike(document.body.children);
     * // => true
     *
     * _.isArrayLike('abc');
     * // => true
     *
     * _.isArrayLike(_.noop);
     * // => false
     */function isArrayLike(value){return value!=null&&isLength(value.length)&&!isFunction(value);}/**
     * This method is like `_.isArrayLike` except that it also checks if `value`
     * is an object.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array-like object,
     *  else `false`.
     * @example
     *
     * _.isArrayLikeObject([1, 2, 3]);
     * // => true
     *
     * _.isArrayLikeObject(document.body.children);
     * // => true
     *
     * _.isArrayLikeObject('abc');
     * // => false
     *
     * _.isArrayLikeObject(_.noop);
     * // => false
     */function isArrayLikeObject(value){return isObjectLike(value)&&isArrayLike(value);}/**
     * Checks if `value` is classified as a boolean primitive or object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a boolean, else `false`.
     * @example
     *
     * _.isBoolean(false);
     * // => true
     *
     * _.isBoolean(null);
     * // => false
     */function isBoolean(value){return value===true||value===false||isObjectLike(value)&&baseGetTag(value)==boolTag;}/**
     * Checks if `value` is a buffer.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
     * @example
     *
     * _.isBuffer(new Buffer(2));
     * // => true
     *
     * _.isBuffer(new Uint8Array(2));
     * // => false
     */var isBuffer=nativeIsBuffer||stubFalse;/**
     * Checks if `value` is classified as a `Date` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
     * @example
     *
     * _.isDate(new Date);
     * // => true
     *
     * _.isDate('Mon April 23 2012');
     * // => false
     */var isDate=nodeIsDate?baseUnary(nodeIsDate):baseIsDate;/**
     * Checks if `value` is likely a DOM element.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.
     * @example
     *
     * _.isElement(document.body);
     * // => true
     *
     * _.isElement('<body>');
     * // => false
     */function isElement(value){return isObjectLike(value)&&value.nodeType===1&&!isPlainObject(value);}/**
     * Checks if `value` is an empty object, collection, map, or set.
     *
     * Objects are considered empty if they have no own enumerable string keyed
     * properties.
     *
     * Array-like values such as `arguments` objects, arrays, buffers, strings, or
     * jQuery-like collections are considered empty if they have a `length` of `0`.
     * Similarly, maps and sets are considered empty if they have a `size` of `0`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is empty, else `false`.
     * @example
     *
     * _.isEmpty(null);
     * // => true
     *
     * _.isEmpty(true);
     * // => true
     *
     * _.isEmpty(1);
     * // => true
     *
     * _.isEmpty([1, 2, 3]);
     * // => false
     *
     * _.isEmpty({ 'a': 1 });
     * // => false
     */function isEmpty(value){if(value==null){return true;}if(isArrayLike(value)&&(isArray(value)||typeof value=='string'||typeof value.splice=='function'||isBuffer(value)||isTypedArray(value)||isArguments(value))){return!value.length;}var tag=getTag(value);if(tag==mapTag||tag==setTag){return!value.size;}if(isPrototype(value)){return!baseKeys(value).length;}for(var key in value){if(hasOwnProperty.call(value,key)){return false;}}return true;}/**
     * Performs a deep comparison between two values to determine if they are
     * equivalent.
     *
     * **Note:** This method supports comparing arrays, array buffers, booleans,
     * date objects, error objects, maps, numbers, `Object` objects, regexes,
     * sets, strings, symbols, and typed arrays. `Object` objects are compared
     * by their own, not inherited, enumerable properties. Functions and DOM
     * nodes are compared by strict equality, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'a': 1 };
     * var other = { 'a': 1 };
     *
     * _.isEqual(object, other);
     * // => true
     *
     * object === other;
     * // => false
     */function isEqual(value,other){return baseIsEqual(value,other);}/**
     * This method is like `_.isEqual` except that it accepts `customizer` which
     * is invoked to compare values. If `customizer` returns `undefined`, comparisons
     * are handled by the method instead. The `customizer` is invoked with up to
     * six arguments: (objValue, othValue [, index|key, object, other, stack]).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * function isGreeting(value) {
     *   return /^h(?:i|ello)$/.test(value);
     * }
     *
     * function customizer(objValue, othValue) {
     *   if (isGreeting(objValue) && isGreeting(othValue)) {
     *     return true;
     *   }
     * }
     *
     * var array = ['hello', 'goodbye'];
     * var other = ['hi', 'goodbye'];
     *
     * _.isEqualWith(array, other, customizer);
     * // => true
     */function isEqualWith(value,other,customizer){customizer=typeof customizer=='function'?customizer:undefined;var result=customizer?customizer(value,other):undefined;return result===undefined?baseIsEqual(value,other,undefined,customizer):!!result;}/**
     * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
     * `SyntaxError`, `TypeError`, or `URIError` object.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
     * @example
     *
     * _.isError(new Error);
     * // => true
     *
     * _.isError(Error);
     * // => false
     */function isError(value){if(!isObjectLike(value)){return false;}var tag=baseGetTag(value);return tag==errorTag||tag==domExcTag||typeof value.message=='string'&&typeof value.name=='string'&&!isPlainObject(value);}/**
     * Checks if `value` is a finite primitive number.
     *
     * **Note:** This method is based on
     * [`Number.isFinite`](https://mdn.io/Number/isFinite).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.
     * @example
     *
     * _.isFinite(3);
     * // => true
     *
     * _.isFinite(Number.MIN_VALUE);
     * // => true
     *
     * _.isFinite(Infinity);
     * // => false
     *
     * _.isFinite('3');
     * // => false
     */function isFinite(value){return typeof value=='number'&&nativeIsFinite(value);}/**
     * Checks if `value` is classified as a `Function` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a function, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     *
     * _.isFunction(/abc/);
     * // => false
     */function isFunction(value){if(!isObject(value)){return false;}// The use of `Object#toString` avoids issues with the `typeof` operator
// in Safari 9 which returns 'object' for typed arrays and other constructors.
var tag=baseGetTag(value);return tag==funcTag||tag==genTag||tag==asyncTag||tag==proxyTag;}/**
     * Checks if `value` is an integer.
     *
     * **Note:** This method is based on
     * [`Number.isInteger`](https://mdn.io/Number/isInteger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an integer, else `false`.
     * @example
     *
     * _.isInteger(3);
     * // => true
     *
     * _.isInteger(Number.MIN_VALUE);
     * // => false
     *
     * _.isInteger(Infinity);
     * // => false
     *
     * _.isInteger('3');
     * // => false
     */function isInteger(value){return typeof value=='number'&&value==toInteger(value);}/**
     * Checks if `value` is a valid array-like length.
     *
     * **Note:** This method is loosely based on
     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
     * @example
     *
     * _.isLength(3);
     * // => true
     *
     * _.isLength(Number.MIN_VALUE);
     * // => false
     *
     * _.isLength(Infinity);
     * // => false
     *
     * _.isLength('3');
     * // => false
     */function isLength(value){return typeof value=='number'&&value>-1&&value%1==0&&value<=MAX_SAFE_INTEGER;}/**
     * Checks if `value` is the
     * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
     * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(_.noop);
     * // => true
     *
     * _.isObject(null);
     * // => false
     */function isObject(value){var type=typeof value;return value!=null&&(type=='object'||type=='function');}/**
     * Checks if `value` is object-like. A value is object-like if it's not `null`
     * and has a `typeof` result of "object".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
     * @example
     *
     * _.isObjectLike({});
     * // => true
     *
     * _.isObjectLike([1, 2, 3]);
     * // => true
     *
     * _.isObjectLike(_.noop);
     * // => false
     *
     * _.isObjectLike(null);
     * // => false
     */function isObjectLike(value){return value!=null&&typeof value=='object';}/**
     * Checks if `value` is classified as a `Map` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
     * @example
     *
     * _.isMap(new Map);
     * // => true
     *
     * _.isMap(new WeakMap);
     * // => false
     */var isMap=nodeIsMap?baseUnary(nodeIsMap):baseIsMap;/**
     * Performs a partial deep comparison between `object` and `source` to
     * determine if `object` contains equivalent property values.
     *
     * **Note:** This method is equivalent to `_.matches` when `source` is
     * partially applied.
     *
     * Partial comparisons will match empty array and empty object `source`
     * values against any array or object value, respectively. See `_.isEqual`
     * for a list of supported value comparisons.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     *
     * _.isMatch(object, { 'b': 2 });
     * // => true
     *
     * _.isMatch(object, { 'b': 1 });
     * // => false
     */function isMatch(object,source){return object===source||baseIsMatch(object,source,getMatchData(source));}/**
     * This method is like `_.isMatch` except that it accepts `customizer` which
     * is invoked to compare values. If `customizer` returns `undefined`, comparisons
     * are handled by the method instead. The `customizer` is invoked with five
     * arguments: (objValue, srcValue, index|key, object, source).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     * @example
     *
     * function isGreeting(value) {
     *   return /^h(?:i|ello)$/.test(value);
     * }
     *
     * function customizer(objValue, srcValue) {
     *   if (isGreeting(objValue) && isGreeting(srcValue)) {
     *     return true;
     *   }
     * }
     *
     * var object = { 'greeting': 'hello' };
     * var source = { 'greeting': 'hi' };
     *
     * _.isMatchWith(object, source, customizer);
     * // => true
     */function isMatchWith(object,source,customizer){customizer=typeof customizer=='function'?customizer:undefined;return baseIsMatch(object,source,getMatchData(source),customizer);}/**
     * Checks if `value` is `NaN`.
     *
     * **Note:** This method is based on
     * [`Number.isNaN`](https://mdn.io/Number/isNaN) and is not the same as
     * global [`isNaN`](https://mdn.io/isNaN) which returns `true` for
     * `undefined` and other non-number values.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
     * @example
     *
     * _.isNaN(NaN);
     * // => true
     *
     * _.isNaN(new Number(NaN));
     * // => true
     *
     * isNaN(undefined);
     * // => true
     *
     * _.isNaN(undefined);
     * // => false
     */function isNaN(value){// An `NaN` primitive is the only value that is not equal to itself.
// Perform the `toStringTag` check first to avoid errors with some
// ActiveX objects in IE.
return isNumber(value)&&value!=+value;}/**
     * Checks if `value` is a pristine native function.
     *
     * **Note:** This method can't reliably detect native functions in the presence
     * of the core-js package because core-js circumvents this kind of detection.
     * Despite multiple requests, the core-js maintainer has made it clear: any
     * attempt to fix the detection will be obstructed. As a result, we're left
     * with little choice but to throw an error. Unfortunately, this also affects
     * packages, like [babel-polyfill](https://www.npmjs.com/package/babel-polyfill),
     * which rely on core-js.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function,
     *  else `false`.
     * @example
     *
     * _.isNative(Array.prototype.push);
     * // => true
     *
     * _.isNative(_);
     * // => false
     */function isNative(value){if(isMaskable(value)){throw new Error(CORE_ERROR_TEXT);}return baseIsNative(value);}/**
     * Checks if `value` is `null`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
     * @example
     *
     * _.isNull(null);
     * // => true
     *
     * _.isNull(void 0);
     * // => false
     */function isNull(value){return value===null;}/**
     * Checks if `value` is `null` or `undefined`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is nullish, else `false`.
     * @example
     *
     * _.isNil(null);
     * // => true
     *
     * _.isNil(void 0);
     * // => true
     *
     * _.isNil(NaN);
     * // => false
     */function isNil(value){return value==null;}/**
     * Checks if `value` is classified as a `Number` primitive or object.
     *
     * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are
     * classified as numbers, use the `_.isFinite` method.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a number, else `false`.
     * @example
     *
     * _.isNumber(3);
     * // => true
     *
     * _.isNumber(Number.MIN_VALUE);
     * // => true
     *
     * _.isNumber(Infinity);
     * // => true
     *
     * _.isNumber('3');
     * // => false
     */function isNumber(value){return typeof value=='number'||isObjectLike(value)&&baseGetTag(value)==numberTag;}/**
     * Checks if `value` is a plain object, that is, an object created by the
     * `Object` constructor or one with a `[[Prototype]]` of `null`.
     *
     * @static
     * @memberOf _
     * @since 0.8.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * _.isPlainObject(new Foo);
     * // => false
     *
     * _.isPlainObject([1, 2, 3]);
     * // => false
     *
     * _.isPlainObject({ 'x': 0, 'y': 0 });
     * // => true
     *
     * _.isPlainObject(Object.create(null));
     * // => true
     */function isPlainObject(value){if(!isObjectLike(value)||baseGetTag(value)!=objectTag){return false;}var proto=getPrototype(value);if(proto===null){return true;}var Ctor=hasOwnProperty.call(proto,'constructor')&&proto.constructor;return typeof Ctor=='function'&&Ctor instanceof Ctor&&funcToString.call(Ctor)==objectCtorString;}/**
     * Checks if `value` is classified as a `RegExp` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
     * @example
     *
     * _.isRegExp(/abc/);
     * // => true
     *
     * _.isRegExp('/abc/');
     * // => false
     */var isRegExp=nodeIsRegExp?baseUnary(nodeIsRegExp):baseIsRegExp;/**
     * Checks if `value` is a safe integer. An integer is safe if it's an IEEE-754
     * double precision number which isn't the result of a rounded unsafe integer.
     *
     * **Note:** This method is based on
     * [`Number.isSafeInteger`](https://mdn.io/Number/isSafeInteger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a safe integer, else `false`.
     * @example
     *
     * _.isSafeInteger(3);
     * // => true
     *
     * _.isSafeInteger(Number.MIN_VALUE);
     * // => false
     *
     * _.isSafeInteger(Infinity);
     * // => false
     *
     * _.isSafeInteger('3');
     * // => false
     */function isSafeInteger(value){return isInteger(value)&&value>=-MAX_SAFE_INTEGER&&value<=MAX_SAFE_INTEGER;}/**
     * Checks if `value` is classified as a `Set` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
     * @example
     *
     * _.isSet(new Set);
     * // => true
     *
     * _.isSet(new WeakSet);
     * // => false
     */var isSet=nodeIsSet?baseUnary(nodeIsSet):baseIsSet;/**
     * Checks if `value` is classified as a `String` primitive or object.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a string, else `false`.
     * @example
     *
     * _.isString('abc');
     * // => true
     *
     * _.isString(1);
     * // => false
     */function isString(value){return typeof value=='string'||!isArray(value)&&isObjectLike(value)&&baseGetTag(value)==stringTag;}/**
     * Checks if `value` is classified as a `Symbol` primitive or object.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
     * @example
     *
     * _.isSymbol(Symbol.iterator);
     * // => true
     *
     * _.isSymbol('abc');
     * // => false
     */function isSymbol(value){return typeof value=='symbol'||isObjectLike(value)&&baseGetTag(value)==symbolTag;}/**
     * Checks if `value` is classified as a typed array.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     * @example
     *
     * _.isTypedArray(new Uint8Array);
     * // => true
     *
     * _.isTypedArray([]);
     * // => false
     */var isTypedArray=nodeIsTypedArray?baseUnary(nodeIsTypedArray):baseIsTypedArray;/**
     * Checks if `value` is `undefined`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
     * @example
     *
     * _.isUndefined(void 0);
     * // => true
     *
     * _.isUndefined(null);
     * // => false
     */function isUndefined(value){return value===undefined;}/**
     * Checks if `value` is classified as a `WeakMap` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a weak map, else `false`.
     * @example
     *
     * _.isWeakMap(new WeakMap);
     * // => true
     *
     * _.isWeakMap(new Map);
     * // => false
     */function isWeakMap(value){return isObjectLike(value)&&getTag(value)==weakMapTag;}/**
     * Checks if `value` is classified as a `WeakSet` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a weak set, else `false`.
     * @example
     *
     * _.isWeakSet(new WeakSet);
     * // => true
     *
     * _.isWeakSet(new Set);
     * // => false
     */function isWeakSet(value){return isObjectLike(value)&&baseGetTag(value)==weakSetTag;}/**
     * Checks if `value` is less than `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than `other`,
     *  else `false`.
     * @see _.gt
     * @example
     *
     * _.lt(1, 3);
     * // => true
     *
     * _.lt(3, 3);
     * // => false
     *
     * _.lt(3, 1);
     * // => false
     */var lt=createRelationalOperation(baseLt);/**
     * Checks if `value` is less than or equal to `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than or equal to
     *  `other`, else `false`.
     * @see _.gte
     * @example
     *
     * _.lte(1, 3);
     * // => true
     *
     * _.lte(3, 3);
     * // => true
     *
     * _.lte(3, 1);
     * // => false
     */var lte=createRelationalOperation(function(value,other){return value<=other;});/**
     * Converts `value` to an array.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {Array} Returns the converted array.
     * @example
     *
     * _.toArray({ 'a': 1, 'b': 2 });
     * // => [1, 2]
     *
     * _.toArray('abc');
     * // => ['a', 'b', 'c']
     *
     * _.toArray(1);
     * // => []
     *
     * _.toArray(null);
     * // => []
     */function toArray(value){if(!value){return[];}if(isArrayLike(value)){return isString(value)?stringToArray(value):copyArray(value);}if(symIterator&&value[symIterator]){return iteratorToArray(value[symIterator]());}var tag=getTag(value),func=tag==mapTag?mapToArray:tag==setTag?setToArray:values;return func(value);}/**
     * Converts `value` to a finite number.
     *
     * @static
     * @memberOf _
     * @since 4.12.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted number.
     * @example
     *
     * _.toFinite(3.2);
     * // => 3.2
     *
     * _.toFinite(Number.MIN_VALUE);
     * // => 5e-324
     *
     * _.toFinite(Infinity);
     * // => 1.7976931348623157e+308
     *
     * _.toFinite('3.2');
     * // => 3.2
     */function toFinite(value){if(!value){return value===0?value:0;}value=toNumber(value);if(value===INFINITY||value===-INFINITY){var sign=value<0?-1:1;return sign*MAX_INTEGER;}return value===value?value:0;}/**
     * Converts `value` to an integer.
     *
     * **Note:** This method is loosely based on
     * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toInteger(3.2);
     * // => 3
     *
     * _.toInteger(Number.MIN_VALUE);
     * // => 0
     *
     * _.toInteger(Infinity);
     * // => 1.7976931348623157e+308
     *
     * _.toInteger('3.2');
     * // => 3
     */function toInteger(value){var result=toFinite(value),remainder=result%1;return result===result?remainder?result-remainder:result:0;}/**
     * Converts `value` to an integer suitable for use as the length of an
     * array-like object.
     *
     * **Note:** This method is based on
     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toLength(3.2);
     * // => 3
     *
     * _.toLength(Number.MIN_VALUE);
     * // => 0
     *
     * _.toLength(Infinity);
     * // => 4294967295
     *
     * _.toLength('3.2');
     * // => 3
     */function toLength(value){return value?baseClamp(toInteger(value),0,MAX_ARRAY_LENGTH):0;}/**
     * Converts `value` to a number.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to process.
     * @returns {number} Returns the number.
     * @example
     *
     * _.toNumber(3.2);
     * // => 3.2
     *
     * _.toNumber(Number.MIN_VALUE);
     * // => 5e-324
     *
     * _.toNumber(Infinity);
     * // => Infinity
     *
     * _.toNumber('3.2');
     * // => 3.2
     */function toNumber(value){if(typeof value=='number'){return value;}if(isSymbol(value)){return NAN;}if(isObject(value)){var other=typeof value.valueOf=='function'?value.valueOf():value;value=isObject(other)?other+'':other;}if(typeof value!='string'){return value===0?value:+value;}value=value.replace(reTrim,'');var isBinary=reIsBinary.test(value);return isBinary||reIsOctal.test(value)?freeParseInt(value.slice(2),isBinary?2:8):reIsBadHex.test(value)?NAN:+value;}/**
     * Converts `value` to a plain object flattening inherited enumerable string
     * keyed properties of `value` to own properties of the plain object.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {Object} Returns the converted plain object.
     * @example
     *
     * function Foo() {
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.assign({ 'a': 1 }, new Foo);
     * // => { 'a': 1, 'b': 2 }
     *
     * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
     * // => { 'a': 1, 'b': 2, 'c': 3 }
     */function toPlainObject(value){return copyObject(value,keysIn(value));}/**
     * Converts `value` to a safe integer. A safe integer can be compared and
     * represented correctly.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toSafeInteger(3.2);
     * // => 3
     *
     * _.toSafeInteger(Number.MIN_VALUE);
     * // => 0
     *
     * _.toSafeInteger(Infinity);
     * // => 9007199254740991
     *
     * _.toSafeInteger('3.2');
     * // => 3
     */function toSafeInteger(value){return value?baseClamp(toInteger(value),-MAX_SAFE_INTEGER,MAX_SAFE_INTEGER):value===0?value:0;}/**
     * Converts `value` to a string. An empty string is returned for `null`
     * and `undefined` values. The sign of `-0` is preserved.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.toString(null);
     * // => ''
     *
     * _.toString(-0);
     * // => '-0'
     *
     * _.toString([1, 2, 3]);
     * // => '1,2,3'
     */function toString(value){return value==null?'':baseToString(value);}/*------------------------------------------------------------------------*//**
     * Assigns own enumerable string keyed properties of source objects to the
     * destination object. Source objects are applied from left to right.
     * Subsequent sources overwrite property assignments of previous sources.
     *
     * **Note:** This method mutates `object` and is loosely based on
     * [`Object.assign`](https://mdn.io/Object/assign).
     *
     * @static
     * @memberOf _
     * @since 0.10.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.assignIn
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * function Bar() {
     *   this.c = 3;
     * }
     *
     * Foo.prototype.b = 2;
     * Bar.prototype.d = 4;
     *
     * _.assign({ 'a': 0 }, new Foo, new Bar);
     * // => { 'a': 1, 'c': 3 }
     */var assign=createAssigner(function(object,source){if(isPrototype(source)||isArrayLike(source)){copyObject(source,keys(source),object);return;}for(var key in source){if(hasOwnProperty.call(source,key)){assignValue(object,key,source[key]);}}});/**
     * This method is like `_.assign` except that it iterates over own and
     * inherited source properties.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias extend
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.assign
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * function Bar() {
     *   this.c = 3;
     * }
     *
     * Foo.prototype.b = 2;
     * Bar.prototype.d = 4;
     *
     * _.assignIn({ 'a': 0 }, new Foo, new Bar);
     * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4 }
     */var assignIn=createAssigner(function(object,source){copyObject(source,keysIn(source),object);});/**
     * This method is like `_.assignIn` except that it accepts `customizer`
     * which is invoked to produce the assigned values. If `customizer` returns
     * `undefined`, assignment is handled by the method instead. The `customizer`
     * is invoked with five arguments: (objValue, srcValue, key, object, source).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias extendWith
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @see _.assignWith
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   return _.isUndefined(objValue) ? srcValue : objValue;
     * }
     *
     * var defaults = _.partialRight(_.assignInWith, customizer);
     *
     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
     * // => { 'a': 1, 'b': 2 }
     */var assignInWith=createAssigner(function(object,source,srcIndex,customizer){copyObject(source,keysIn(source),object,customizer);});/**
     * This method is like `_.assign` except that it accepts `customizer`
     * which is invoked to produce the assigned values. If `customizer` returns
     * `undefined`, assignment is handled by the method instead. The `customizer`
     * is invoked with five arguments: (objValue, srcValue, key, object, source).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @see _.assignInWith
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   return _.isUndefined(objValue) ? srcValue : objValue;
     * }
     *
     * var defaults = _.partialRight(_.assignWith, customizer);
     *
     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
     * // => { 'a': 1, 'b': 2 }
     */var assignWith=createAssigner(function(object,source,srcIndex,customizer){copyObject(source,keys(source),object,customizer);});/**
     * Creates an array of values corresponding to `paths` of `object`.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {...(string|string[])} [paths] The property paths to pick.
     * @returns {Array} Returns the picked values.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
     *
     * _.at(object, ['a[0].b.c', 'a[1]']);
     * // => [3, 4]
     */var at=flatRest(baseAt);/**
     * Creates an object that inherits from the `prototype` object. If a
     * `properties` object is given, its own enumerable string keyed properties
     * are assigned to the created object.
     *
     * @static
     * @memberOf _
     * @since 2.3.0
     * @category Object
     * @param {Object} prototype The object to inherit from.
     * @param {Object} [properties] The properties to assign to the object.
     * @returns {Object} Returns the new object.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * function Circle() {
     *   Shape.call(this);
     * }
     *
     * Circle.prototype = _.create(Shape.prototype, {
     *   'constructor': Circle
     * });
     *
     * var circle = new Circle;
     * circle instanceof Circle;
     * // => true
     *
     * circle instanceof Shape;
     * // => true
     */function create(prototype,properties){var result=baseCreate(prototype);return properties==null?result:baseAssign(result,properties);}/**
     * Assigns own and inherited enumerable string keyed properties of source
     * objects to the destination object for all destination properties that
     * resolve to `undefined`. Source objects are applied from left to right.
     * Once a property is set, additional values of the same property are ignored.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.defaultsDeep
     * @example
     *
     * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
     * // => { 'a': 1, 'b': 2 }
     */var defaults=baseRest(function(args){args.push(undefined,customDefaultsAssignIn);return apply(assignInWith,undefined,args);});/**
     * This method is like `_.defaults` except that it recursively assigns
     * default properties.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.defaults
     * @example
     *
     * _.defaultsDeep({ 'a': { 'b': 2 } }, { 'a': { 'b': 1, 'c': 3 } });
     * // => { 'a': { 'b': 2, 'c': 3 } }
     */var defaultsDeep=baseRest(function(args){args.push(undefined,customDefaultsMerge);return apply(mergeWith,undefined,args);});/**
     * This method is like `_.find` except that it returns the key of the first
     * element `predicate` returns truthy for instead of the element itself.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category Object
     * @param {Object} object The object to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {string|undefined} Returns the key of the matched element,
     *  else `undefined`.
     * @example
     *
     * var users = {
     *   'barney':  { 'age': 36, 'active': true },
     *   'fred':    { 'age': 40, 'active': false },
     *   'pebbles': { 'age': 1,  'active': true }
     * };
     *
     * _.findKey(users, function(o) { return o.age < 40; });
     * // => 'barney' (iteration order is not guaranteed)
     *
     * // The `_.matches` iteratee shorthand.
     * _.findKey(users, { 'age': 1, 'active': true });
     * // => 'pebbles'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findKey(users, ['active', false]);
     * // => 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.findKey(users, 'active');
     * // => 'barney'
     */function findKey(object,predicate){return baseFindKey(object,getIteratee(predicate,3),baseForOwn);}/**
     * This method is like `_.findKey` except that it iterates over elements of
     * a collection in the opposite order.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Object
     * @param {Object} object The object to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {string|undefined} Returns the key of the matched element,
     *  else `undefined`.
     * @example
     *
     * var users = {
     *   'barney':  { 'age': 36, 'active': true },
     *   'fred':    { 'age': 40, 'active': false },
     *   'pebbles': { 'age': 1,  'active': true }
     * };
     *
     * _.findLastKey(users, function(o) { return o.age < 40; });
     * // => returns 'pebbles' assuming `_.findKey` returns 'barney'
     *
     * // The `_.matches` iteratee shorthand.
     * _.findLastKey(users, { 'age': 36, 'active': true });
     * // => 'barney'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findLastKey(users, ['active', false]);
     * // => 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.findLastKey(users, 'active');
     * // => 'pebbles'
     */function findLastKey(object,predicate){return baseFindKey(object,getIteratee(predicate,3),baseForOwnRight);}/**
     * Iterates over own and inherited enumerable string keyed properties of an
     * object and invokes `iteratee` for each property. The iteratee is invoked
     * with three arguments: (value, key, object). Iteratee functions may exit
     * iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @since 0.3.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forInRight
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forIn(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a', 'b', then 'c' (iteration order is not guaranteed).
     */function forIn(object,iteratee){return object==null?object:baseFor(object,getIteratee(iteratee,3),keysIn);}/**
     * This method is like `_.forIn` except that it iterates over properties of
     * `object` in the opposite order.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forIn
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forInRight(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'c', 'b', then 'a' assuming `_.forIn` logs 'a', 'b', then 'c'.
     */function forInRight(object,iteratee){return object==null?object:baseForRight(object,getIteratee(iteratee,3),keysIn);}/**
     * Iterates over own enumerable string keyed properties of an object and
     * invokes `iteratee` for each property. The iteratee is invoked with three
     * arguments: (value, key, object). Iteratee functions may exit iteration
     * early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @since 0.3.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forOwnRight
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forOwn(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a' then 'b' (iteration order is not guaranteed).
     */function forOwn(object,iteratee){return object&&baseForOwn(object,getIteratee(iteratee,3));}/**
     * This method is like `_.forOwn` except that it iterates over properties of
     * `object` in the opposite order.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forOwn
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forOwnRight(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'b' then 'a' assuming `_.forOwn` logs 'a' then 'b'.
     */function forOwnRight(object,iteratee){return object&&baseForOwnRight(object,getIteratee(iteratee,3));}/**
     * Creates an array of function property names from own enumerable properties
     * of `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns the function names.
     * @see _.functionsIn
     * @example
     *
     * function Foo() {
     *   this.a = _.constant('a');
     *   this.b = _.constant('b');
     * }
     *
     * Foo.prototype.c = _.constant('c');
     *
     * _.functions(new Foo);
     * // => ['a', 'b']
     */function functions(object){return object==null?[]:baseFunctions(object,keys(object));}/**
     * Creates an array of function property names from own and inherited
     * enumerable properties of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns the function names.
     * @see _.functions
     * @example
     *
     * function Foo() {
     *   this.a = _.constant('a');
     *   this.b = _.constant('b');
     * }
     *
     * Foo.prototype.c = _.constant('c');
     *
     * _.functionsIn(new Foo);
     * // => ['a', 'b', 'c']
     */function functionsIn(object){return object==null?[]:baseFunctions(object,keysIn(object));}/**
     * Gets the value at `path` of `object`. If the resolved value is
     * `undefined`, the `defaultValue` is returned in its place.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.get(object, 'a[0].b.c');
     * // => 3
     *
     * _.get(object, ['a', '0', 'b', 'c']);
     * // => 3
     *
     * _.get(object, 'a.b.c', 'default');
     * // => 'default'
     */function get(object,path,defaultValue){var result=object==null?undefined:baseGet(object,path);return result===undefined?defaultValue:result;}/**
     * Checks if `path` is a direct property of `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     * @example
     *
     * var object = { 'a': { 'b': 2 } };
     * var other = _.create({ 'a': _.create({ 'b': 2 }) });
     *
     * _.has(object, 'a');
     * // => true
     *
     * _.has(object, 'a.b');
     * // => true
     *
     * _.has(object, ['a', 'b']);
     * // => true
     *
     * _.has(other, 'a');
     * // => false
     */function has(object,path){return object!=null&&hasPath(object,path,baseHas);}/**
     * Checks if `path` is a direct or inherited property of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     * @example
     *
     * var object = _.create({ 'a': _.create({ 'b': 2 }) });
     *
     * _.hasIn(object, 'a');
     * // => true
     *
     * _.hasIn(object, 'a.b');
     * // => true
     *
     * _.hasIn(object, ['a', 'b']);
     * // => true
     *
     * _.hasIn(object, 'b');
     * // => false
     */function hasIn(object,path){return object!=null&&hasPath(object,path,baseHasIn);}/**
     * Creates an object composed of the inverted keys and values of `object`.
     * If `object` contains duplicate values, subsequent values overwrite
     * property assignments of previous values.
     *
     * @static
     * @memberOf _
     * @since 0.7.0
     * @category Object
     * @param {Object} object The object to invert.
     * @returns {Object} Returns the new inverted object.
     * @example
     *
     * var object = { 'a': 1, 'b': 2, 'c': 1 };
     *
     * _.invert(object);
     * // => { '1': 'c', '2': 'b' }
     */var invert=createInverter(function(result,value,key){result[value]=key;},constant(identity));/**
     * This method is like `_.invert` except that the inverted object is generated
     * from the results of running each element of `object` thru `iteratee`. The
     * corresponding inverted value of each inverted key is an array of keys
     * responsible for generating the inverted value. The iteratee is invoked
     * with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.1.0
     * @category Object
     * @param {Object} object The object to invert.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Object} Returns the new inverted object.
     * @example
     *
     * var object = { 'a': 1, 'b': 2, 'c': 1 };
     *
     * _.invertBy(object);
     * // => { '1': ['a', 'c'], '2': ['b'] }
     *
     * _.invertBy(object, function(value) {
     *   return 'group' + value;
     * });
     * // => { 'group1': ['a', 'c'], 'group2': ['b'] }
     */var invertBy=createInverter(function(result,value,key){if(hasOwnProperty.call(result,value)){result[value].push(key);}else{result[value]=[key];}},getIteratee);/**
     * Invokes the method at `path` of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the method to invoke.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {*} Returns the result of the invoked method.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': [1, 2, 3, 4] } }] };
     *
     * _.invoke(object, 'a[0].b.c.slice', 1, 3);
     * // => [2, 3]
     */var invoke=baseRest(baseInvoke);/**
     * Creates an array of the own enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects. See the
     * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
     * for more details.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keys(new Foo);
     * // => ['a', 'b'] (iteration order is not guaranteed)
     *
     * _.keys('hi');
     * // => ['0', '1']
     */function keys(object){return isArrayLike(object)?arrayLikeKeys(object):baseKeys(object);}/**
     * Creates an array of the own and inherited enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keysIn(new Foo);
     * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
     */function keysIn(object){return isArrayLike(object)?arrayLikeKeys(object,true):baseKeysIn(object);}/**
     * The opposite of `_.mapValues`; this method creates an object with the
     * same values as `object` and keys generated by running each own enumerable
     * string keyed property of `object` thru `iteratee`. The iteratee is invoked
     * with three arguments: (value, key, object).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns the new mapped object.
     * @see _.mapValues
     * @example
     *
     * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {
     *   return key + value;
     * });
     * // => { 'a1': 1, 'b2': 2 }
     */function mapKeys(object,iteratee){var result={};iteratee=getIteratee(iteratee,3);baseForOwn(object,function(value,key,object){baseAssignValue(result,iteratee(value,key,object),value);});return result;}/**
     * Creates an object with the same keys as `object` and values generated
     * by running each own enumerable string keyed property of `object` thru
     * `iteratee`. The iteratee is invoked with three arguments:
     * (value, key, object).
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns the new mapped object.
     * @see _.mapKeys
     * @example
     *
     * var users = {
     *   'fred':    { 'user': 'fred',    'age': 40 },
     *   'pebbles': { 'user': 'pebbles', 'age': 1 }
     * };
     *
     * _.mapValues(users, function(o) { return o.age; });
     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
     *
     * // The `_.property` iteratee shorthand.
     * _.mapValues(users, 'age');
     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
     */function mapValues(object,iteratee){var result={};iteratee=getIteratee(iteratee,3);baseForOwn(object,function(value,key,object){baseAssignValue(result,key,iteratee(value,key,object));});return result;}/**
     * This method is like `_.assign` except that it recursively merges own and
     * inherited enumerable string keyed properties of source objects into the
     * destination object. Source properties that resolve to `undefined` are
     * skipped if a destination value exists. Array and plain object properties
     * are merged recursively. Other objects and value types are overridden by
     * assignment. Source objects are applied from left to right. Subsequent
     * sources overwrite property assignments of previous sources.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {
     *   'a': [{ 'b': 2 }, { 'd': 4 }]
     * };
     *
     * var other = {
     *   'a': [{ 'c': 3 }, { 'e': 5 }]
     * };
     *
     * _.merge(object, other);
     * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
     */var merge=createAssigner(function(object,source,srcIndex){baseMerge(object,source,srcIndex);});/**
     * This method is like `_.merge` except that it accepts `customizer` which
     * is invoked to produce the merged values of the destination and source
     * properties. If `customizer` returns `undefined`, merging is handled by the
     * method instead. The `customizer` is invoked with six arguments:
     * (objValue, srcValue, key, object, source, stack).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} customizer The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   if (_.isArray(objValue)) {
     *     return objValue.concat(srcValue);
     *   }
     * }
     *
     * var object = { 'a': [1], 'b': [2] };
     * var other = { 'a': [3], 'b': [4] };
     *
     * _.mergeWith(object, other, customizer);
     * // => { 'a': [1, 3], 'b': [2, 4] }
     */var mergeWith=createAssigner(function(object,source,srcIndex,customizer){baseMerge(object,source,srcIndex,customizer);});/**
     * The opposite of `_.pick`; this method creates an object composed of the
     * own and inherited enumerable property paths of `object` that are not omitted.
     *
     * **Note:** This method is considerably slower than `_.pick`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The source object.
     * @param {...(string|string[])} [paths] The property paths to omit.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.omit(object, ['a', 'c']);
     * // => { 'b': '2' }
     */var omit=flatRest(function(object,paths){var result={};if(object==null){return result;}var isDeep=false;paths=arrayMap(paths,function(path){path=castPath(path,object);isDeep||(isDeep=path.length>1);return path;});copyObject(object,getAllKeysIn(object),result);if(isDeep){result=baseClone(result,CLONE_DEEP_FLAG|CLONE_FLAT_FLAG|CLONE_SYMBOLS_FLAG,customOmitClone);}var length=paths.length;while(length--){baseUnset(result,paths[length]);}return result;});/**
     * The opposite of `_.pickBy`; this method creates an object composed of
     * the own and inherited enumerable string keyed properties of `object` that
     * `predicate` doesn't return truthy for. The predicate is invoked with two
     * arguments: (value, key).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The source object.
     * @param {Function} [predicate=_.identity] The function invoked per property.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.omitBy(object, _.isNumber);
     * // => { 'b': '2' }
     */function omitBy(object,predicate){return pickBy(object,negate(getIteratee(predicate)));}/**
     * Creates an object composed of the picked `object` properties.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The source object.
     * @param {...(string|string[])} [paths] The property paths to pick.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.pick(object, ['a', 'c']);
     * // => { 'a': 1, 'c': 3 }
     */var pick=flatRest(function(object,paths){return object==null?{}:basePick(object,paths);});/**
     * Creates an object composed of the `object` properties `predicate` returns
     * truthy for. The predicate is invoked with two arguments: (value, key).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The source object.
     * @param {Function} [predicate=_.identity] The function invoked per property.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.pickBy(object, _.isNumber);
     * // => { 'a': 1, 'c': 3 }
     */function pickBy(object,predicate){if(object==null){return{};}var props=arrayMap(getAllKeysIn(object),function(prop){return[prop];});predicate=getIteratee(predicate);return basePickBy(object,props,function(value,path){return predicate(value,path[0]);});}/**
     * This method is like `_.get` except that if the resolved value is a
     * function it's invoked with the `this` binding of its parent object and
     * its result is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to resolve.
     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };
     *
     * _.result(object, 'a[0].b.c1');
     * // => 3
     *
     * _.result(object, 'a[0].b.c2');
     * // => 4
     *
     * _.result(object, 'a[0].b.c3', 'default');
     * // => 'default'
     *
     * _.result(object, 'a[0].b.c3', _.constant('default'));
     * // => 'default'
     */function result(object,path,defaultValue){path=castPath(path,object);var index=-1,length=path.length;// Ensure the loop is entered when path is empty.
if(!length){length=1;object=undefined;}while(++index<length){var value=object==null?undefined:object[toKey(path[index])];if(value===undefined){index=length;value=defaultValue;}object=isFunction(value)?value.call(object):value;}return object;}/**
     * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
     * it's created. Arrays are created for missing index properties while objects
     * are created for all other missing properties. Use `_.setWith` to customize
     * `path` creation.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.set(object, 'a[0].b.c', 4);
     * console.log(object.a[0].b.c);
     * // => 4
     *
     * _.set(object, ['x', '0', 'y', 'z'], 5);
     * console.log(object.x[0].y.z);
     * // => 5
     */function set(object,path,value){return object==null?object:baseSet(object,path,value);}/**
     * This method is like `_.set` except that it accepts `customizer` which is
     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
     * path creation is handled by the method instead. The `customizer` is invoked
     * with three arguments: (nsValue, key, nsObject).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {};
     *
     * _.setWith(object, '[0][1]', 'a', Object);
     * // => { '0': { '1': 'a' } }
     */function setWith(object,path,value,customizer){customizer=typeof customizer=='function'?customizer:undefined;return object==null?object:baseSet(object,path,value,customizer);}/**
     * Creates an array of own enumerable string keyed-value pairs for `object`
     * which can be consumed by `_.fromPairs`. If `object` is a map or set, its
     * entries are returned.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias entries
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the key-value pairs.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.toPairs(new Foo);
     * // => [['a', 1], ['b', 2]] (iteration order is not guaranteed)
     */var toPairs=createToPairs(keys);/**
     * Creates an array of own and inherited enumerable string keyed-value pairs
     * for `object` which can be consumed by `_.fromPairs`. If `object` is a map
     * or set, its entries are returned.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias entriesIn
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the key-value pairs.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.toPairsIn(new Foo);
     * // => [['a', 1], ['b', 2], ['c', 3]] (iteration order is not guaranteed)
     */var toPairsIn=createToPairs(keysIn);/**
     * An alternative to `_.reduce`; this method transforms `object` to a new
     * `accumulator` object which is the result of running each of its own
     * enumerable string keyed properties thru `iteratee`, with each invocation
     * potentially mutating the `accumulator` object. If `accumulator` is not
     * provided, a new object with the same `[[Prototype]]` will be used. The
     * iteratee is invoked with four arguments: (accumulator, value, key, object).
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @since 1.3.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The custom accumulator value.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * _.transform([2, 3, 4], function(result, n) {
     *   result.push(n *= n);
     *   return n % 2 == 0;
     * }, []);
     * // => [4, 9]
     *
     * _.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
     *   (result[value] || (result[value] = [])).push(key);
     * }, {});
     * // => { '1': ['a', 'c'], '2': ['b'] }
     */function transform(object,iteratee,accumulator){var isArr=isArray(object),isArrLike=isArr||isBuffer(object)||isTypedArray(object);iteratee=getIteratee(iteratee,4);if(accumulator==null){var Ctor=object&&object.constructor;if(isArrLike){accumulator=isArr?new Ctor():[];}else if(isObject(object)){accumulator=isFunction(Ctor)?baseCreate(getPrototype(object)):{};}else{accumulator={};}}(isArrLike?arrayEach:baseForOwn)(object,function(value,index,object){return iteratee(accumulator,value,index,object);});return accumulator;}/**
     * Removes the property at `path` of `object`.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to unset.
     * @returns {boolean} Returns `true` if the property is deleted, else `false`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 7 } }] };
     * _.unset(object, 'a[0].b.c');
     * // => true
     *
     * console.log(object);
     * // => { 'a': [{ 'b': {} }] };
     *
     * _.unset(object, ['a', '0', 'b', 'c']);
     * // => true
     *
     * console.log(object);
     * // => { 'a': [{ 'b': {} }] };
     */function unset(object,path){return object==null?true:baseUnset(object,path);}/**
     * This method is like `_.set` except that accepts `updater` to produce the
     * value to set. Use `_.updateWith` to customize `path` creation. The `updater`
     * is invoked with one argument: (value).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.6.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {Function} updater The function to produce the updated value.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.update(object, 'a[0].b.c', function(n) { return n * n; });
     * console.log(object.a[0].b.c);
     * // => 9
     *
     * _.update(object, 'x[0].y.z', function(n) { return n ? n + 1 : 0; });
     * console.log(object.x[0].y.z);
     * // => 0
     */function update(object,path,updater){return object==null?object:baseUpdate(object,path,castFunction(updater));}/**
     * This method is like `_.update` except that it accepts `customizer` which is
     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
     * path creation is handled by the method instead. The `customizer` is invoked
     * with three arguments: (nsValue, key, nsObject).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.6.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {Function} updater The function to produce the updated value.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {};
     *
     * _.updateWith(object, '[0][1]', _.constant('a'), Object);
     * // => { '0': { '1': 'a' } }
     */function updateWith(object,path,updater,customizer){customizer=typeof customizer=='function'?customizer:undefined;return object==null?object:baseUpdate(object,path,castFunction(updater),customizer);}/**
     * Creates an array of the own enumerable string keyed property values of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property values.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.values(new Foo);
     * // => [1, 2] (iteration order is not guaranteed)
     *
     * _.values('hi');
     * // => ['h', 'i']
     */function values(object){return object==null?[]:baseValues(object,keys(object));}/**
     * Creates an array of the own and inherited enumerable string keyed property
     * values of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property values.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.valuesIn(new Foo);
     * // => [1, 2, 3] (iteration order is not guaranteed)
     */function valuesIn(object){return object==null?[]:baseValues(object,keysIn(object));}/*------------------------------------------------------------------------*//**
     * Clamps `number` within the inclusive `lower` and `upper` bounds.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Number
     * @param {number} number The number to clamp.
     * @param {number} [lower] The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the clamped number.
     * @example
     *
     * _.clamp(-10, -5, 5);
     * // => -5
     *
     * _.clamp(10, -5, 5);
     * // => 5
     */function clamp(number,lower,upper){if(upper===undefined){upper=lower;lower=undefined;}if(upper!==undefined){upper=toNumber(upper);upper=upper===upper?upper:0;}if(lower!==undefined){lower=toNumber(lower);lower=lower===lower?lower:0;}return baseClamp(toNumber(number),lower,upper);}/**
     * Checks if `n` is between `start` and up to, but not including, `end`. If
     * `end` is not specified, it's set to `start` with `start` then set to `0`.
     * If `start` is greater than `end` the params are swapped to support
     * negative ranges.
     *
     * @static
     * @memberOf _
     * @since 3.3.0
     * @category Number
     * @param {number} number The number to check.
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
     * @see _.range, _.rangeRight
     * @example
     *
     * _.inRange(3, 2, 4);
     * // => true
     *
     * _.inRange(4, 8);
     * // => true
     *
     * _.inRange(4, 2);
     * // => false
     *
     * _.inRange(2, 2);
     * // => false
     *
     * _.inRange(1.2, 2);
     * // => true
     *
     * _.inRange(5.2, 4);
     * // => false
     *
     * _.inRange(-3, -2, -6);
     * // => true
     */function inRange(number,start,end){start=toFinite(start);if(end===undefined){end=start;start=0;}else{end=toFinite(end);}number=toNumber(number);return baseInRange(number,start,end);}/**
     * Produces a random number between the inclusive `lower` and `upper` bounds.
     * If only one argument is provided a number between `0` and the given number
     * is returned. If `floating` is `true`, or either `lower` or `upper` are
     * floats, a floating-point number is returned instead of an integer.
     *
     * **Note:** JavaScript follows the IEEE-754 standard for resolving
     * floating-point values which can produce unexpected results.
     *
     * @static
     * @memberOf _
     * @since 0.7.0
     * @category Number
     * @param {number} [lower=0] The lower bound.
     * @param {number} [upper=1] The upper bound.
     * @param {boolean} [floating] Specify returning a floating-point number.
     * @returns {number} Returns the random number.
     * @example
     *
     * _.random(0, 5);
     * // => an integer between 0 and 5
     *
     * _.random(5);
     * // => also an integer between 0 and 5
     *
     * _.random(5, true);
     * // => a floating-point number between 0 and 5
     *
     * _.random(1.2, 5.2);
     * // => a floating-point number between 1.2 and 5.2
     */function random(lower,upper,floating){if(floating&&typeof floating!='boolean'&&isIterateeCall(lower,upper,floating)){upper=floating=undefined;}if(floating===undefined){if(typeof upper=='boolean'){floating=upper;upper=undefined;}else if(typeof lower=='boolean'){floating=lower;lower=undefined;}}if(lower===undefined&&upper===undefined){lower=0;upper=1;}else{lower=toFinite(lower);if(upper===undefined){upper=lower;lower=0;}else{upper=toFinite(upper);}}if(lower>upper){var temp=lower;lower=upper;upper=temp;}if(floating||lower%1||upper%1){var rand=nativeRandom();return nativeMin(lower+rand*(upper-lower+freeParseFloat('1e-'+((rand+'').length-1))),upper);}return baseRandom(lower,upper);}/*------------------------------------------------------------------------*//**
     * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the camel cased string.
     * @example
     *
     * _.camelCase('Foo Bar');
     * // => 'fooBar'
     *
     * _.camelCase('--foo-bar--');
     * // => 'fooBar'
     *
     * _.camelCase('__FOO_BAR__');
     * // => 'fooBar'
     */var camelCase=createCompounder(function(result,word,index){word=word.toLowerCase();return result+(index?capitalize(word):word);});/**
     * Converts the first character of `string` to upper case and the remaining
     * to lower case.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to capitalize.
     * @returns {string} Returns the capitalized string.
     * @example
     *
     * _.capitalize('FRED');
     * // => 'Fred'
     */function capitalize(string){return upperFirst(toString(string).toLowerCase());}/**
     * Deburrs `string` by converting
     * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
     * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)
     * letters to basic Latin letters and removing
     * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to deburr.
     * @returns {string} Returns the deburred string.
     * @example
     *
     * _.deburr('dj vu');
     * // => 'deja vu'
     */function deburr(string){string=toString(string);return string&&string.replace(reLatin,deburrLetter).replace(reComboMark,'');}/**
     * Checks if `string` ends with the given target string.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {string} [target] The string to search for.
     * @param {number} [position=string.length] The position to search up to.
     * @returns {boolean} Returns `true` if `string` ends with `target`,
     *  else `false`.
     * @example
     *
     * _.endsWith('abc', 'c');
     * // => true
     *
     * _.endsWith('abc', 'b');
     * // => false
     *
     * _.endsWith('abc', 'b', 2);
     * // => true
     */function endsWith(string,target,position){string=toString(string);target=baseToString(target);var length=string.length;position=position===undefined?length:baseClamp(toInteger(position),0,length);var end=position;position-=target.length;return position>=0&&string.slice(position,end)==target;}/**
     * Converts the characters "&", "<", ">", '"', and "'" in `string` to their
     * corresponding HTML entities.
     *
     * **Note:** No other characters are escaped. To escape additional
     * characters use a third-party library like [_he_](https://mths.be/he).
     *
     * Though the ">" character is escaped for symmetry, characters like
     * ">" and "/" don't need escaping in HTML and have no special meaning
     * unless they're part of a tag or unquoted attribute value. See
     * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
     * (under "semi-related fun fact") for more details.
     *
     * When working with HTML you should always
     * [quote attribute values](http://wonko.com/post/html-escaping) to reduce
     * XSS vectors.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escape('fred, barney, & pebbles');
     * // => 'fred, barney, &amp; pebbles'
     */function escape(string){string=toString(string);return string&&reHasUnescapedHtml.test(string)?string.replace(reUnescapedHtml,escapeHtmlChar):string;}/**
     * Escapes the `RegExp` special characters "^", "$", "\", ".", "*", "+",
     * "?", "(", ")", "[", "]", "{", "}", and "|" in `string`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escapeRegExp('[lodash](https://lodash.com/)');
     * // => '\[lodash\]\(https://lodash\.com/\)'
     */function escapeRegExp(string){string=toString(string);return string&&reHasRegExpChar.test(string)?string.replace(reRegExpChar,'\\$&'):string;}/**
     * Converts `string` to
     * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the kebab cased string.
     * @example
     *
     * _.kebabCase('Foo Bar');
     * // => 'foo-bar'
     *
     * _.kebabCase('fooBar');
     * // => 'foo-bar'
     *
     * _.kebabCase('__FOO_BAR__');
     * // => 'foo-bar'
     */var kebabCase=createCompounder(function(result,word,index){return result+(index?'-':'')+word.toLowerCase();});/**
     * Converts `string`, as space separated words, to lower case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the lower cased string.
     * @example
     *
     * _.lowerCase('--Foo-Bar--');
     * // => 'foo bar'
     *
     * _.lowerCase('fooBar');
     * // => 'foo bar'
     *
     * _.lowerCase('__FOO_BAR__');
     * // => 'foo bar'
     */var lowerCase=createCompounder(function(result,word,index){return result+(index?' ':'')+word.toLowerCase();});/**
     * Converts the first character of `string` to lower case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.lowerFirst('Fred');
     * // => 'fred'
     *
     * _.lowerFirst('FRED');
     * // => 'fRED'
     */var lowerFirst=createCaseFirst('toLowerCase');/**
     * Pads `string` on the left and right sides if it's shorter than `length`.
     * Padding characters are truncated if they can't be evenly divided by `length`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.pad('abc', 8);
     * // => '  abc   '
     *
     * _.pad('abc', 8, '_-');
     * // => '_-abc_-_'
     *
     * _.pad('abc', 3);
     * // => 'abc'
     */function pad(string,length,chars){string=toString(string);length=toInteger(length);var strLength=length?stringSize(string):0;if(!length||strLength>=length){return string;}var mid=(length-strLength)/2;return createPadding(nativeFloor(mid),chars)+string+createPadding(nativeCeil(mid),chars);}/**
     * Pads `string` on the right side if it's shorter than `length`. Padding
     * characters are truncated if they exceed `length`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.padEnd('abc', 6);
     * // => 'abc   '
     *
     * _.padEnd('abc', 6, '_-');
     * // => 'abc_-_'
     *
     * _.padEnd('abc', 3);
     * // => 'abc'
     */function padEnd(string,length,chars){string=toString(string);length=toInteger(length);var strLength=length?stringSize(string):0;return length&&strLength<length?string+createPadding(length-strLength,chars):string;}/**
     * Pads `string` on the left side if it's shorter than `length`. Padding
     * characters are truncated if they exceed `length`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.padStart('abc', 6);
     * // => '   abc'
     *
     * _.padStart('abc', 6, '_-');
     * // => '_-_abc'
     *
     * _.padStart('abc', 3);
     * // => 'abc'
     */function padStart(string,length,chars){string=toString(string);length=toInteger(length);var strLength=length?stringSize(string):0;return length&&strLength<length?createPadding(length-strLength,chars)+string:string;}/**
     * Converts `string` to an integer of the specified radix. If `radix` is
     * `undefined` or `0`, a `radix` of `10` is used unless `value` is a
     * hexadecimal, in which case a `radix` of `16` is used.
     *
     * **Note:** This method aligns with the
     * [ES5 implementation](https://es5.github.io/#x15.1.2.2) of `parseInt`.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category String
     * @param {string} string The string to convert.
     * @param {number} [radix=10] The radix to interpret `value` by.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.parseInt('08');
     * // => 8
     *
     * _.map(['6', '08', '10'], _.parseInt);
     * // => [6, 8, 10]
     */function parseInt(string,radix,guard){if(guard||radix==null){radix=0;}else if(radix){radix=+radix;}return nativeParseInt(toString(string).replace(reTrimStart,''),radix||0);}/**
     * Repeats the given string `n` times.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to repeat.
     * @param {number} [n=1] The number of times to repeat the string.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the repeated string.
     * @example
     *
     * _.repeat('*', 3);
     * // => '***'
     *
     * _.repeat('abc', 2);
     * // => 'abcabc'
     *
     * _.repeat('abc', 0);
     * // => ''
     */function repeat(string,n,guard){if(guard?isIterateeCall(string,n,guard):n===undefined){n=1;}else{n=toInteger(n);}return baseRepeat(toString(string),n);}/**
     * Replaces matches for `pattern` in `string` with `replacement`.
     *
     * **Note:** This method is based on
     * [`String#replace`](https://mdn.io/String/replace).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to modify.
     * @param {RegExp|string} pattern The pattern to replace.
     * @param {Function|string} replacement The match replacement.
     * @returns {string} Returns the modified string.
     * @example
     *
     * _.replace('Hi Fred', 'Fred', 'Barney');
     * // => 'Hi Barney'
     */function replace(){var args=arguments,string=toString(args[0]);return args.length<3?string:string.replace(args[1],args[2]);}/**
     * Converts `string` to
     * [snake case](https://en.wikipedia.org/wiki/Snake_case).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the snake cased string.
     * @example
     *
     * _.snakeCase('Foo Bar');
     * // => 'foo_bar'
     *
     * _.snakeCase('fooBar');
     * // => 'foo_bar'
     *
     * _.snakeCase('--FOO-BAR--');
     * // => 'foo_bar'
     */var snakeCase=createCompounder(function(result,word,index){return result+(index?'_':'')+word.toLowerCase();});/**
     * Splits `string` by `separator`.
     *
     * **Note:** This method is based on
     * [`String#split`](https://mdn.io/String/split).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to split.
     * @param {RegExp|string} separator The separator pattern to split by.
     * @param {number} [limit] The length to truncate results to.
     * @returns {Array} Returns the string segments.
     * @example
     *
     * _.split('a-b-c', '-', 2);
     * // => ['a', 'b']
     */function split(string,separator,limit){if(limit&&typeof limit!='number'&&isIterateeCall(string,separator,limit)){separator=limit=undefined;}limit=limit===undefined?MAX_ARRAY_LENGTH:limit>>>0;if(!limit){return[];}string=toString(string);if(string&&(typeof separator=='string'||separator!=null&&!isRegExp(separator))){separator=baseToString(separator);if(!separator&&hasUnicode(string)){return castSlice(stringToArray(string),0,limit);}}return string.split(separator,limit);}/**
     * Converts `string` to
     * [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).
     *
     * @static
     * @memberOf _
     * @since 3.1.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the start cased string.
     * @example
     *
     * _.startCase('--foo-bar--');
     * // => 'Foo Bar'
     *
     * _.startCase('fooBar');
     * // => 'Foo Bar'
     *
     * _.startCase('__FOO_BAR__');
     * // => 'FOO BAR'
     */var startCase=createCompounder(function(result,word,index){return result+(index?' ':'')+upperFirst(word);});/**
     * Checks if `string` starts with the given target string.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {string} [target] The string to search for.
     * @param {number} [position=0] The position to search from.
     * @returns {boolean} Returns `true` if `string` starts with `target`,
     *  else `false`.
     * @example
     *
     * _.startsWith('abc', 'a');
     * // => true
     *
     * _.startsWith('abc', 'b');
     * // => false
     *
     * _.startsWith('abc', 'b', 1);
     * // => true
     */function startsWith(string,target,position){string=toString(string);position=position==null?0:baseClamp(toInteger(position),0,string.length);target=baseToString(target);return string.slice(position,position+target.length)==target;}/**
     * Creates a compiled template function that can interpolate data properties
     * in "interpolate" delimiters, HTML-escape interpolated data properties in
     * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
     * properties may be accessed as free variables in the template. If a setting
     * object is given, it takes precedence over `_.templateSettings` values.
     *
     * **Note:** In the development build `_.template` utilizes
     * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
     * for easier debugging.
     *
     * For more information on precompiling templates see
     * [lodash's custom builds documentation](https://lodash.com/custom-builds).
     *
     * For more information on Chrome extension sandboxes see
     * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category String
     * @param {string} [string=''] The template string.
     * @param {Object} [options={}] The options object.
     * @param {RegExp} [options.escape=_.templateSettings.escape]
     *  The HTML "escape" delimiter.
     * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]
     *  The "evaluate" delimiter.
     * @param {Object} [options.imports=_.templateSettings.imports]
     *  An object to import into the template as free variables.
     * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]
     *  The "interpolate" delimiter.
     * @param {string} [options.sourceURL='lodash.templateSources[n]']
     *  The sourceURL of the compiled template.
     * @param {string} [options.variable='obj']
     *  The data object variable name.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the compiled template function.
     * @example
     *
     * // Use the "interpolate" delimiter to create a compiled template.
     * var compiled = _.template('hello <%= user %>!');
     * compiled({ 'user': 'fred' });
     * // => 'hello fred!'
     *
     * // Use the HTML "escape" delimiter to escape data property values.
     * var compiled = _.template('<b><%- value %></b>');
     * compiled({ 'value': '<script>' });
     * // => '<b>&lt;script&gt;</b>'
     *
     * // Use the "evaluate" delimiter to execute JavaScript and generate HTML.
     * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
     * compiled({ 'users': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // Use the internal `print` function in "evaluate" delimiters.
     * var compiled = _.template('<% print("hello " + user); %>!');
     * compiled({ 'user': 'barney' });
     * // => 'hello barney!'
     *
     * // Use the ES template literal delimiter as an "interpolate" delimiter.
     * // Disable support by replacing the "interpolate" delimiter.
     * var compiled = _.template('hello ${ user }!');
     * compiled({ 'user': 'pebbles' });
     * // => 'hello pebbles!'
     *
     * // Use backslashes to treat delimiters as plain text.
     * var compiled = _.template('<%= "\\<%- value %\\>" %>');
     * compiled({ 'value': 'ignored' });
     * // => '<%- value %>'
     *
     * // Use the `imports` option to import `jQuery` as `jq`.
     * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
     * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
     * compiled({ 'users': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // Use the `sourceURL` option to specify a custom sourceURL for the template.
     * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
     * compiled(data);
     * // => Find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector.
     *
     * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.
     * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
     * compiled.source;
     * // => function(data) {
     * //   var __t, __p = '';
     * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
     * //   return __p;
     * // }
     *
     * // Use custom template delimiters.
     * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
     * var compiled = _.template('hello {{ user }}!');
     * compiled({ 'user': 'mustache' });
     * // => 'hello mustache!'
     *
     * // Use the `source` property to inline compiled templates for meaningful
     * // line numbers in error messages and stack traces.
     * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\
     *   var JST = {\
     *     "main": ' + _.template(mainText).source + '\
     *   };\
     * ');
     */function template(string,options,guard){// Based on John Resig's `tmpl` implementation
// (http://ejohn.org/blog/javascript-micro-templating/)
// and Laura Doktorova's doT.js (https://github.com/olado/doT).
var settings=lodash.templateSettings;if(guard&&isIterateeCall(string,options,guard)){options=undefined;}string=toString(string);options=assignInWith({},options,settings,customDefaultsAssignIn);var imports=assignInWith({},options.imports,settings.imports,customDefaultsAssignIn),importsKeys=keys(imports),importsValues=baseValues(imports,importsKeys);var isEscaping,isEvaluating,index=0,interpolate=options.interpolate||reNoMatch,source="__p += '";// Compile the regexp to match each delimiter.
var reDelimiters=RegExp((options.escape||reNoMatch).source+'|'+interpolate.source+'|'+(interpolate===reInterpolate?reEsTemplate:reNoMatch).source+'|'+(options.evaluate||reNoMatch).source+'|$','g');// Use a sourceURL for easier debugging.
var sourceURL='//# sourceURL='+('sourceURL'in options?options.sourceURL:'lodash.templateSources['+ ++templateCounter+']')+'\n';string.replace(reDelimiters,function(match,escapeValue,interpolateValue,esTemplateValue,evaluateValue,offset){interpolateValue||(interpolateValue=esTemplateValue);// Escape characters that can't be included in string literals.
source+=string.slice(index,offset).replace(reUnescapedString,escapeStringChar);// Replace delimiters with snippets.
if(escapeValue){isEscaping=true;source+="' +\n__e("+escapeValue+") +\n'";}if(evaluateValue){isEvaluating=true;source+="';\n"+evaluateValue+";\n__p += '";}if(interpolateValue){source+="' +\n((__t = ("+interpolateValue+")) == null ? '' : __t) +\n'";}index=offset+match.length;// The JS engine embedded in Adobe products needs `match` returned in
// order to produce the correct `offset` value.
return match;});source+="';\n";// If `variable` is not specified wrap a with-statement around the generated
// code to add the data object to the top of the scope chain.
var variable=options.variable;if(!variable){source='with (obj) {\n'+source+'\n}\n';}// Cleanup code by stripping empty strings.
source=(isEvaluating?source.replace(reEmptyStringLeading,''):source).replace(reEmptyStringMiddle,'$1').replace(reEmptyStringTrailing,'$1;');// Frame code as the function body.
source='function('+(variable||'obj')+') {\n'+(variable?'':'obj || (obj = {});\n')+"var __t, __p = ''"+(isEscaping?', __e = _.escape':'')+(isEvaluating?', __j = Array.prototype.join;\n'+"function print() { __p += __j.call(arguments, '') }\n":';\n')+source+'return __p\n}';var result=attempt(function(){return Function(importsKeys,sourceURL+'return '+source).apply(undefined,importsValues);});// Provide the compiled function's source by its `toString` method or
// the `source` property as a convenience for inlining compiled templates.
result.source=source;if(isError(result)){throw result;}return result;}/**
     * Converts `string`, as a whole, to lower case just like
     * [String#toLowerCase](https://mdn.io/toLowerCase).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the lower cased string.
     * @example
     *
     * _.toLower('--Foo-Bar--');
     * // => '--foo-bar--'
     *
     * _.toLower('fooBar');
     * // => 'foobar'
     *
     * _.toLower('__FOO_BAR__');
     * // => '__foo_bar__'
     */function toLower(value){return toString(value).toLowerCase();}/**
     * Converts `string`, as a whole, to upper case just like
     * [String#toUpperCase](https://mdn.io/toUpperCase).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the upper cased string.
     * @example
     *
     * _.toUpper('--foo-bar--');
     * // => '--FOO-BAR--'
     *
     * _.toUpper('fooBar');
     * // => 'FOOBAR'
     *
     * _.toUpper('__foo_bar__');
     * // => '__FOO_BAR__'
     */function toUpper(value){return toString(value).toUpperCase();}/**
     * Removes leading and trailing whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trim('  abc  ');
     * // => 'abc'
     *
     * _.trim('-_-abc-_-', '_-');
     * // => 'abc'
     *
     * _.map(['  foo  ', '  bar  '], _.trim);
     * // => ['foo', 'bar']
     */function trim(string,chars,guard){string=toString(string);if(string&&(guard||chars===undefined)){return string.replace(reTrim,'');}if(!string||!(chars=baseToString(chars))){return string;}var strSymbols=stringToArray(string),chrSymbols=stringToArray(chars),start=charsStartIndex(strSymbols,chrSymbols),end=charsEndIndex(strSymbols,chrSymbols)+1;return castSlice(strSymbols,start,end).join('');}/**
     * Removes trailing whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trimEnd('  abc  ');
     * // => '  abc'
     *
     * _.trimEnd('-_-abc-_-', '_-');
     * // => '-_-abc'
     */function trimEnd(string,chars,guard){string=toString(string);if(string&&(guard||chars===undefined)){return string.replace(reTrimEnd,'');}if(!string||!(chars=baseToString(chars))){return string;}var strSymbols=stringToArray(string),end=charsEndIndex(strSymbols,stringToArray(chars))+1;return castSlice(strSymbols,0,end).join('');}/**
     * Removes leading whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trimStart('  abc  ');
     * // => 'abc  '
     *
     * _.trimStart('-_-abc-_-', '_-');
     * // => 'abc-_-'
     */function trimStart(string,chars,guard){string=toString(string);if(string&&(guard||chars===undefined)){return string.replace(reTrimStart,'');}if(!string||!(chars=baseToString(chars))){return string;}var strSymbols=stringToArray(string),start=charsStartIndex(strSymbols,stringToArray(chars));return castSlice(strSymbols,start).join('');}/**
     * Truncates `string` if it's longer than the given maximum string length.
     * The last characters of the truncated string are replaced with the omission
     * string which defaults to "...".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to truncate.
     * @param {Object} [options={}] The options object.
     * @param {number} [options.length=30] The maximum string length.
     * @param {string} [options.omission='...'] The string to indicate text is omitted.
     * @param {RegExp|string} [options.separator] The separator pattern to truncate to.
     * @returns {string} Returns the truncated string.
     * @example
     *
     * _.truncate('hi-diddly-ho there, neighborino');
     * // => 'hi-diddly-ho there, neighbo...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'length': 24,
     *   'separator': ' '
     * });
     * // => 'hi-diddly-ho there,...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'length': 24,
     *   'separator': /,? +/
     * });
     * // => 'hi-diddly-ho there...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'omission': ' [...]'
     * });
     * // => 'hi-diddly-ho there, neig [...]'
     */function truncate(string,options){var length=DEFAULT_TRUNC_LENGTH,omission=DEFAULT_TRUNC_OMISSION;if(isObject(options)){var separator='separator'in options?options.separator:separator;length='length'in options?toInteger(options.length):length;omission='omission'in options?baseToString(options.omission):omission;}string=toString(string);var strLength=string.length;if(hasUnicode(string)){var strSymbols=stringToArray(string);strLength=strSymbols.length;}if(length>=strLength){return string;}var end=length-stringSize(omission);if(end<1){return omission;}var result=strSymbols?castSlice(strSymbols,0,end).join(''):string.slice(0,end);if(separator===undefined){return result+omission;}if(strSymbols){end+=result.length-end;}if(isRegExp(separator)){if(string.slice(end).search(separator)){var match,substring=result;if(!separator.global){separator=RegExp(separator.source,toString(reFlags.exec(separator))+'g');}separator.lastIndex=0;while(match=separator.exec(substring)){var newEnd=match.index;}result=result.slice(0,newEnd===undefined?end:newEnd);}}else if(string.indexOf(baseToString(separator),end)!=end){var index=result.lastIndexOf(separator);if(index>-1){result=result.slice(0,index);}}return result+omission;}/**
     * The inverse of `_.escape`; this method converts the HTML entities
     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to
     * their corresponding characters.
     *
     * **Note:** No other HTML entities are unescaped. To unescape additional
     * HTML entities use a third-party library like [_he_](https://mths.be/he).
     *
     * @static
     * @memberOf _
     * @since 0.6.0
     * @category String
     * @param {string} [string=''] The string to unescape.
     * @returns {string} Returns the unescaped string.
     * @example
     *
     * _.unescape('fred, barney, &amp; pebbles');
     * // => 'fred, barney, & pebbles'
     */function unescape(string){string=toString(string);return string&&reHasEscapedHtml.test(string)?string.replace(reEscapedHtml,unescapeHtmlChar):string;}/**
     * Converts `string`, as space separated words, to upper case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the upper cased string.
     * @example
     *
     * _.upperCase('--foo-bar');
     * // => 'FOO BAR'
     *
     * _.upperCase('fooBar');
     * // => 'FOO BAR'
     *
     * _.upperCase('__foo_bar__');
     * // => 'FOO BAR'
     */var upperCase=createCompounder(function(result,word,index){return result+(index?' ':'')+word.toUpperCase();});/**
     * Converts the first character of `string` to upper case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.upperFirst('fred');
     * // => 'Fred'
     *
     * _.upperFirst('FRED');
     * // => 'FRED'
     */var upperFirst=createCaseFirst('toUpperCase');/**
     * Splits `string` into an array of its words.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {RegExp|string} [pattern] The pattern to match words.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the words of `string`.
     * @example
     *
     * _.words('fred, barney, & pebbles');
     * // => ['fred', 'barney', 'pebbles']
     *
     * _.words('fred, barney, & pebbles', /[^, ]+/g);
     * // => ['fred', 'barney', '&', 'pebbles']
     */function words(string,pattern,guard){string=toString(string);pattern=guard?undefined:pattern;if(pattern===undefined){return hasUnicodeWord(string)?unicodeWords(string):asciiWords(string);}return string.match(pattern)||[];}/*------------------------------------------------------------------------*//**
     * Attempts to invoke `func`, returning either the result or the caught error
     * object. Any additional arguments are provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {Function} func The function to attempt.
     * @param {...*} [args] The arguments to invoke `func` with.
     * @returns {*} Returns the `func` result or error object.
     * @example
     *
     * // Avoid throwing errors for invalid selectors.
     * var elements = _.attempt(function(selector) {
     *   return document.querySelectorAll(selector);
     * }, '>_>');
     *
     * if (_.isError(elements)) {
     *   elements = [];
     * }
     */var attempt=baseRest(function(func,args){try{return apply(func,undefined,args);}catch(e){return isError(e)?e:new Error(e);}});/**
     * Binds methods of an object to the object itself, overwriting the existing
     * method.
     *
     * **Note:** This method doesn't set the "length" property of bound functions.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {Object} object The object to bind and assign the bound methods to.
     * @param {...(string|string[])} methodNames The object method names to bind.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var view = {
     *   'label': 'docs',
     *   'click': function() {
     *     console.log('clicked ' + this.label);
     *   }
     * };
     *
     * _.bindAll(view, ['click']);
     * jQuery(element).on('click', view.click);
     * // => Logs 'clicked docs' when clicked.
     */var bindAll=flatRest(function(object,methodNames){arrayEach(methodNames,function(key){key=toKey(key);baseAssignValue(object,key,bind(object[key],object));});return object;});/**
     * Creates a function that iterates over `pairs` and invokes the corresponding
     * function of the first predicate to return truthy. The predicate-function
     * pairs are invoked with the `this` binding and arguments of the created
     * function.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {Array} pairs The predicate-function pairs.
     * @returns {Function} Returns the new composite function.
     * @example
     *
     * var func = _.cond([
     *   [_.matches({ 'a': 1 }),           _.constant('matches A')],
     *   [_.conforms({ 'b': _.isNumber }), _.constant('matches B')],
     *   [_.stubTrue,                      _.constant('no match')]
     * ]);
     *
     * func({ 'a': 1, 'b': 2 });
     * // => 'matches A'
     *
     * func({ 'a': 0, 'b': 1 });
     * // => 'matches B'
     *
     * func({ 'a': '1', 'b': '2' });
     * // => 'no match'
     */function cond(pairs){var length=pairs==null?0:pairs.length,toIteratee=getIteratee();pairs=!length?[]:arrayMap(pairs,function(pair){if(typeof pair[1]!='function'){throw new TypeError(FUNC_ERROR_TEXT);}return[toIteratee(pair[0]),pair[1]];});return baseRest(function(args){var index=-1;while(++index<length){var pair=pairs[index];if(apply(pair[0],this,args)){return apply(pair[1],this,args);}}});}/**
     * Creates a function that invokes the predicate properties of `source` with
     * the corresponding property values of a given object, returning `true` if
     * all predicates return truthy, else `false`.
     *
     * **Note:** The created function is equivalent to `_.conformsTo` with
     * `source` partially applied.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {Object} source The object of property predicates to conform to.
     * @returns {Function} Returns the new spec function.
     * @example
     *
     * var objects = [
     *   { 'a': 2, 'b': 1 },
     *   { 'a': 1, 'b': 2 }
     * ];
     *
     * _.filter(objects, _.conforms({ 'b': function(n) { return n > 1; } }));
     * // => [{ 'a': 1, 'b': 2 }]
     */function conforms(source){return baseConforms(baseClone(source,CLONE_DEEP_FLAG));}/**
     * Creates a function that returns `value`.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Util
     * @param {*} value The value to return from the new function.
     * @returns {Function} Returns the new constant function.
     * @example
     *
     * var objects = _.times(2, _.constant({ 'a': 1 }));
     *
     * console.log(objects);
     * // => [{ 'a': 1 }, { 'a': 1 }]
     *
     * console.log(objects[0] === objects[1]);
     * // => true
     */function constant(value){return function(){return value;};}/**
     * Checks `value` to determine whether a default value should be returned in
     * its place. The `defaultValue` is returned if `value` is `NaN`, `null`,
     * or `undefined`.
     *
     * @static
     * @memberOf _
     * @since 4.14.0
     * @category Util
     * @param {*} value The value to check.
     * @param {*} defaultValue The default value.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * _.defaultTo(1, 10);
     * // => 1
     *
     * _.defaultTo(undefined, 10);
     * // => 10
     */function defaultTo(value,defaultValue){return value==null||value!==value?defaultValue:value;}/**
     * Creates a function that returns the result of invoking the given functions
     * with the `this` binding of the created function, where each successive
     * invocation is supplied the return value of the previous.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {...(Function|Function[])} [funcs] The functions to invoke.
     * @returns {Function} Returns the new composite function.
     * @see _.flowRight
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var addSquare = _.flow([_.add, square]);
     * addSquare(1, 2);
     * // => 9
     */var flow=createFlow();/**
     * This method is like `_.flow` except that it creates a function that
     * invokes the given functions from right to left.
     *
     * @static
     * @since 3.0.0
     * @memberOf _
     * @category Util
     * @param {...(Function|Function[])} [funcs] The functions to invoke.
     * @returns {Function} Returns the new composite function.
     * @see _.flow
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var addSquare = _.flowRight([square, _.add]);
     * addSquare(1, 2);
     * // => 9
     */var flowRight=createFlow(true);/**
     * This method returns the first argument it receives.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {*} value Any value.
     * @returns {*} Returns `value`.
     * @example
     *
     * var object = { 'a': 1 };
     *
     * console.log(_.identity(object) === object);
     * // => true
     */function identity(value){return value;}/**
     * Creates a function that invokes `func` with the arguments of the created
     * function. If `func` is a property name, the created function returns the
     * property value for a given element. If `func` is an array or object, the
     * created function returns `true` for elements that contain the equivalent
     * source properties, otherwise it returns `false`.
     *
     * @static
     * @since 4.0.0
     * @memberOf _
     * @category Util
     * @param {*} [func=_.identity] The value to convert to a callback.
     * @returns {Function} Returns the callback.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * // The `_.matches` iteratee shorthand.
     * _.filter(users, _.iteratee({ 'user': 'barney', 'active': true }));
     * // => [{ 'user': 'barney', 'age': 36, 'active': true }]
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.filter(users, _.iteratee(['user', 'fred']));
     * // => [{ 'user': 'fred', 'age': 40 }]
     *
     * // The `_.property` iteratee shorthand.
     * _.map(users, _.iteratee('user'));
     * // => ['barney', 'fred']
     *
     * // Create custom iteratee shorthands.
     * _.iteratee = _.wrap(_.iteratee, function(iteratee, func) {
     *   return !_.isRegExp(func) ? iteratee(func) : function(string) {
     *     return func.test(string);
     *   };
     * });
     *
     * _.filter(['abc', 'def'], /ef/);
     * // => ['def']
     */function iteratee(func){return baseIteratee(typeof func=='function'?func:baseClone(func,CLONE_DEEP_FLAG));}/**
     * Creates a function that performs a partial deep comparison between a given
     * object and `source`, returning `true` if the given object has equivalent
     * property values, else `false`.
     *
     * **Note:** The created function is equivalent to `_.isMatch` with `source`
     * partially applied.
     *
     * Partial comparisons will match empty array and empty object `source`
     * values against any array or object value, respectively. See `_.isEqual`
     * for a list of supported value comparisons.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {Object} source The object of property values to match.
     * @returns {Function} Returns the new spec function.
     * @example
     *
     * var objects = [
     *   { 'a': 1, 'b': 2, 'c': 3 },
     *   { 'a': 4, 'b': 5, 'c': 6 }
     * ];
     *
     * _.filter(objects, _.matches({ 'a': 4, 'c': 6 }));
     * // => [{ 'a': 4, 'b': 5, 'c': 6 }]
     */function matches(source){return baseMatches(baseClone(source,CLONE_DEEP_FLAG));}/**
     * Creates a function that performs a partial deep comparison between the
     * value at `path` of a given object to `srcValue`, returning `true` if the
     * object value is equivalent, else `false`.
     *
     * **Note:** Partial comparisons will match empty array and empty object
     * `srcValue` values against any array or object value, respectively. See
     * `_.isEqual` for a list of supported value comparisons.
     *
     * @static
     * @memberOf _
     * @since 3.2.0
     * @category Util
     * @param {Array|string} path The path of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     * @example
     *
     * var objects = [
     *   { 'a': 1, 'b': 2, 'c': 3 },
     *   { 'a': 4, 'b': 5, 'c': 6 }
     * ];
     *
     * _.find(objects, _.matchesProperty('a', 4));
     * // => { 'a': 4, 'b': 5, 'c': 6 }
     */function matchesProperty(path,srcValue){return baseMatchesProperty(path,baseClone(srcValue,CLONE_DEEP_FLAG));}/**
     * Creates a function that invokes the method at `path` of a given object.
     * Any additional arguments are provided to the invoked method.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Util
     * @param {Array|string} path The path of the method to invoke.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {Function} Returns the new invoker function.
     * @example
     *
     * var objects = [
     *   { 'a': { 'b': _.constant(2) } },
     *   { 'a': { 'b': _.constant(1) } }
     * ];
     *
     * _.map(objects, _.method('a.b'));
     * // => [2, 1]
     *
     * _.map(objects, _.method(['a', 'b']));
     * // => [2, 1]
     */var method=baseRest(function(path,args){return function(object){return baseInvoke(object,path,args);};});/**
     * The opposite of `_.method`; this method creates a function that invokes
     * the method at a given path of `object`. Any additional arguments are
     * provided to the invoked method.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Util
     * @param {Object} object The object to query.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {Function} Returns the new invoker function.
     * @example
     *
     * var array = _.times(3, _.constant),
     *     object = { 'a': array, 'b': array, 'c': array };
     *
     * _.map(['a[2]', 'c[0]'], _.methodOf(object));
     * // => [2, 0]
     *
     * _.map([['a', '2'], ['c', '0']], _.methodOf(object));
     * // => [2, 0]
     */var methodOf=baseRest(function(object,args){return function(path){return baseInvoke(object,path,args);};});/**
     * Adds all own enumerable string keyed function properties of a source
     * object to the destination object. If `object` is a function, then methods
     * are added to its prototype as well.
     *
     * **Note:** Use `_.runInContext` to create a pristine `lodash` function to
     * avoid conflicts caused by modifying the original.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {Function|Object} [object=lodash] The destination object.
     * @param {Object} source The object of functions to add.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.chain=true] Specify whether mixins are chainable.
     * @returns {Function|Object} Returns `object`.
     * @example
     *
     * function vowels(string) {
     *   return _.filter(string, function(v) {
     *     return /[aeiou]/i.test(v);
     *   });
     * }
     *
     * _.mixin({ 'vowels': vowels });
     * _.vowels('fred');
     * // => ['e']
     *
     * _('fred').vowels().value();
     * // => ['e']
     *
     * _.mixin({ 'vowels': vowels }, { 'chain': false });
     * _('fred').vowels();
     * // => ['e']
     */function mixin(object,source,options){var props=keys(source),methodNames=baseFunctions(source,props);if(options==null&&!(isObject(source)&&(methodNames.length||!props.length))){options=source;source=object;object=this;methodNames=baseFunctions(source,keys(source));}var chain=!(isObject(options)&&'chain'in options)||!!options.chain,isFunc=isFunction(object);arrayEach(methodNames,function(methodName){var func=source[methodName];object[methodName]=func;if(isFunc){object.prototype[methodName]=function(){var chainAll=this.__chain__;if(chain||chainAll){var result=object(this.__wrapped__),actions=result.__actions__=copyArray(this.__actions__);actions.push({'func':func,'args':arguments,'thisArg':object});result.__chain__=chainAll;return result;}return func.apply(object,arrayPush([this.value()],arguments));};}});return object;}/**
     * Reverts the `_` variable to its previous value and returns a reference to
     * the `lodash` function.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @returns {Function} Returns the `lodash` function.
     * @example
     *
     * var lodash = _.noConflict();
     */function noConflict(){if(root._===this){root._=oldDash;}return this;}/**
     * This method returns `undefined`.
     *
     * @static
     * @memberOf _
     * @since 2.3.0
     * @category Util
     * @example
     *
     * _.times(2, _.noop);
     * // => [undefined, undefined]
     */function noop(){}// No operation performed.
/**
     * Creates a function that gets the argument at index `n`. If `n` is negative,
     * the nth argument from the end is returned.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {number} [n=0] The index of the argument to return.
     * @returns {Function} Returns the new pass-thru function.
     * @example
     *
     * var func = _.nthArg(1);
     * func('a', 'b', 'c', 'd');
     * // => 'b'
     *
     * var func = _.nthArg(-2);
     * func('a', 'b', 'c', 'd');
     * // => 'c'
     */function nthArg(n){n=toInteger(n);return baseRest(function(args){return baseNth(args,n);});}/**
     * Creates a function that invokes `iteratees` with the arguments it receives
     * and returns their results.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {...(Function|Function[])} [iteratees=[_.identity]]
     *  The iteratees to invoke.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var func = _.over([Math.max, Math.min]);
     *
     * func(1, 2, 3, 4);
     * // => [4, 1]
     */var over=createOver(arrayMap);/**
     * Creates a function that checks if **all** of the `predicates` return
     * truthy when invoked with the arguments it receives.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {...(Function|Function[])} [predicates=[_.identity]]
     *  The predicates to check.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var func = _.overEvery([Boolean, isFinite]);
     *
     * func('1');
     * // => true
     *
     * func(null);
     * // => false
     *
     * func(NaN);
     * // => false
     */var overEvery=createOver(arrayEvery);/**
     * Creates a function that checks if **any** of the `predicates` return
     * truthy when invoked with the arguments it receives.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {...(Function|Function[])} [predicates=[_.identity]]
     *  The predicates to check.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var func = _.overSome([Boolean, isFinite]);
     *
     * func('1');
     * // => true
     *
     * func(null);
     * // => true
     *
     * func(NaN);
     * // => false
     */var overSome=createOver(arraySome);/**
     * Creates a function that returns the value at `path` of a given object.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Util
     * @param {Array|string} path The path of the property to get.
     * @returns {Function} Returns the new accessor function.
     * @example
     *
     * var objects = [
     *   { 'a': { 'b': 2 } },
     *   { 'a': { 'b': 1 } }
     * ];
     *
     * _.map(objects, _.property('a.b'));
     * // => [2, 1]
     *
     * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
     * // => [1, 2]
     */function property(path){return isKey(path)?baseProperty(toKey(path)):basePropertyDeep(path);}/**
     * The opposite of `_.property`; this method creates a function that returns
     * the value at a given path of `object`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {Object} object The object to query.
     * @returns {Function} Returns the new accessor function.
     * @example
     *
     * var array = [0, 1, 2],
     *     object = { 'a': array, 'b': array, 'c': array };
     *
     * _.map(['a[2]', 'c[0]'], _.propertyOf(object));
     * // => [2, 0]
     *
     * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));
     * // => [2, 0]
     */function propertyOf(object){return function(path){return object==null?undefined:baseGet(object,path);};}/**
     * Creates an array of numbers (positive and/or negative) progressing from
     * `start` up to, but not including, `end`. A step of `-1` is used if a negative
     * `start` is specified without an `end` or `step`. If `end` is not specified,
     * it's set to `start` with `start` then set to `0`.
     *
     * **Note:** JavaScript follows the IEEE-754 standard for resolving
     * floating-point values which can produce unexpected results.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @param {number} [step=1] The value to increment or decrement by.
     * @returns {Array} Returns the range of numbers.
     * @see _.inRange, _.rangeRight
     * @example
     *
     * _.range(4);
     * // => [0, 1, 2, 3]
     *
     * _.range(-4);
     * // => [0, -1, -2, -3]
     *
     * _.range(1, 5);
     * // => [1, 2, 3, 4]
     *
     * _.range(0, 20, 5);
     * // => [0, 5, 10, 15]
     *
     * _.range(0, -4, -1);
     * // => [0, -1, -2, -3]
     *
     * _.range(1, 4, 0);
     * // => [1, 1, 1]
     *
     * _.range(0);
     * // => []
     */var range=createRange();/**
     * This method is like `_.range` except that it populates values in
     * descending order.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @param {number} [step=1] The value to increment or decrement by.
     * @returns {Array} Returns the range of numbers.
     * @see _.inRange, _.range
     * @example
     *
     * _.rangeRight(4);
     * // => [3, 2, 1, 0]
     *
     * _.rangeRight(-4);
     * // => [-3, -2, -1, 0]
     *
     * _.rangeRight(1, 5);
     * // => [4, 3, 2, 1]
     *
     * _.rangeRight(0, 20, 5);
     * // => [15, 10, 5, 0]
     *
     * _.rangeRight(0, -4, -1);
     * // => [-3, -2, -1, 0]
     *
     * _.rangeRight(1, 4, 0);
     * // => [1, 1, 1]
     *
     * _.rangeRight(0);
     * // => []
     */var rangeRight=createRange(true);/**
     * This method returns a new empty array.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {Array} Returns the new empty array.
     * @example
     *
     * var arrays = _.times(2, _.stubArray);
     *
     * console.log(arrays);
     * // => [[], []]
     *
     * console.log(arrays[0] === arrays[1]);
     * // => false
     */function stubArray(){return[];}/**
     * This method returns `false`.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {boolean} Returns `false`.
     * @example
     *
     * _.times(2, _.stubFalse);
     * // => [false, false]
     */function stubFalse(){return false;}/**
     * This method returns a new empty object.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {Object} Returns the new empty object.
     * @example
     *
     * var objects = _.times(2, _.stubObject);
     *
     * console.log(objects);
     * // => [{}, {}]
     *
     * console.log(objects[0] === objects[1]);
     * // => false
     */function stubObject(){return{};}/**
     * This method returns an empty string.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {string} Returns the empty string.
     * @example
     *
     * _.times(2, _.stubString);
     * // => ['', '']
     */function stubString(){return'';}/**
     * This method returns `true`.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {boolean} Returns `true`.
     * @example
     *
     * _.times(2, _.stubTrue);
     * // => [true, true]
     */function stubTrue(){return true;}/**
     * Invokes the iteratee `n` times, returning an array of the results of
     * each invocation. The iteratee is invoked with one argument; (index).
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {number} n The number of times to invoke `iteratee`.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the array of results.
     * @example
     *
     * _.times(3, String);
     * // => ['0', '1', '2']
     *
     *  _.times(4, _.constant(0));
     * // => [0, 0, 0, 0]
     */function times(n,iteratee){n=toInteger(n);if(n<1||n>MAX_SAFE_INTEGER){return[];}var index=MAX_ARRAY_LENGTH,length=nativeMin(n,MAX_ARRAY_LENGTH);iteratee=getIteratee(iteratee);n-=MAX_ARRAY_LENGTH;var result=baseTimes(length,iteratee);while(++index<n){iteratee(index);}return result;}/**
     * Converts `value` to a property path array.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {*} value The value to convert.
     * @returns {Array} Returns the new property path array.
     * @example
     *
     * _.toPath('a.b.c');
     * // => ['a', 'b', 'c']
     *
     * _.toPath('a[0].b.c');
     * // => ['a', '0', 'b', 'c']
     */function toPath(value){if(isArray(value)){return arrayMap(value,toKey);}return isSymbol(value)?[value]:copyArray(stringToPath(toString(value)));}/**
     * Generates a unique ID. If `prefix` is given, the ID is appended to it.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {string} [prefix=''] The value to prefix the ID with.
     * @returns {string} Returns the unique ID.
     * @example
     *
     * _.uniqueId('contact_');
     * // => 'contact_104'
     *
     * _.uniqueId();
     * // => '105'
     */function uniqueId(prefix){var id=++idCounter;return toString(prefix)+id;}/*------------------------------------------------------------------------*//**
     * Adds two numbers.
     *
     * @static
     * @memberOf _
     * @since 3.4.0
     * @category Math
     * @param {number} augend The first number in an addition.
     * @param {number} addend The second number in an addition.
     * @returns {number} Returns the total.
     * @example
     *
     * _.add(6, 4);
     * // => 10
     */var add=createMathOperation(function(augend,addend){return augend+addend;},0);/**
     * Computes `number` rounded up to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round up.
     * @param {number} [precision=0] The precision to round up to.
     * @returns {number} Returns the rounded up number.
     * @example
     *
     * _.ceil(4.006);
     * // => 5
     *
     * _.ceil(6.004, 2);
     * // => 6.01
     *
     * _.ceil(6040, -2);
     * // => 6100
     */var ceil=createRound('ceil');/**
     * Divide two numbers.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Math
     * @param {number} dividend The first number in a division.
     * @param {number} divisor The second number in a division.
     * @returns {number} Returns the quotient.
     * @example
     *
     * _.divide(6, 4);
     * // => 1.5
     */var divide=createMathOperation(function(dividend,divisor){return dividend/divisor;},1);/**
     * Computes `number` rounded down to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round down.
     * @param {number} [precision=0] The precision to round down to.
     * @returns {number} Returns the rounded down number.
     * @example
     *
     * _.floor(4.006);
     * // => 4
     *
     * _.floor(0.046, 2);
     * // => 0.04
     *
     * _.floor(4060, -2);
     * // => 4000
     */var floor=createRound('floor');/**
     * Computes the maximum value of `array`. If `array` is empty or falsey,
     * `undefined` is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {*} Returns the maximum value.
     * @example
     *
     * _.max([4, 2, 8, 6]);
     * // => 8
     *
     * _.max([]);
     * // => undefined
     */function max(array){return array&&array.length?baseExtremum(array,identity,baseGt):undefined;}/**
     * This method is like `_.max` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the criterion by which
     * the value is ranked. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {*} Returns the maximum value.
     * @example
     *
     * var objects = [{ 'n': 1 }, { 'n': 2 }];
     *
     * _.maxBy(objects, function(o) { return o.n; });
     * // => { 'n': 2 }
     *
     * // The `_.property` iteratee shorthand.
     * _.maxBy(objects, 'n');
     * // => { 'n': 2 }
     */function maxBy(array,iteratee){return array&&array.length?baseExtremum(array,getIteratee(iteratee,2),baseGt):undefined;}/**
     * Computes the mean of the values in `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {number} Returns the mean.
     * @example
     *
     * _.mean([4, 2, 8, 6]);
     * // => 5
     */function mean(array){return baseMean(array,identity);}/**
     * This method is like `_.mean` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the value to be averaged.
     * The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the mean.
     * @example
     *
     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
     *
     * _.meanBy(objects, function(o) { return o.n; });
     * // => 5
     *
     * // The `_.property` iteratee shorthand.
     * _.meanBy(objects, 'n');
     * // => 5
     */function meanBy(array,iteratee){return baseMean(array,getIteratee(iteratee,2));}/**
     * Computes the minimum value of `array`. If `array` is empty or falsey,
     * `undefined` is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {*} Returns the minimum value.
     * @example
     *
     * _.min([4, 2, 8, 6]);
     * // => 2
     *
     * _.min([]);
     * // => undefined
     */function min(array){return array&&array.length?baseExtremum(array,identity,baseLt):undefined;}/**
     * This method is like `_.min` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the criterion by which
     * the value is ranked. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {*} Returns the minimum value.
     * @example
     *
     * var objects = [{ 'n': 1 }, { 'n': 2 }];
     *
     * _.minBy(objects, function(o) { return o.n; });
     * // => { 'n': 1 }
     *
     * // The `_.property` iteratee shorthand.
     * _.minBy(objects, 'n');
     * // => { 'n': 1 }
     */function minBy(array,iteratee){return array&&array.length?baseExtremum(array,getIteratee(iteratee,2),baseLt):undefined;}/**
     * Multiply two numbers.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Math
     * @param {number} multiplier The first number in a multiplication.
     * @param {number} multiplicand The second number in a multiplication.
     * @returns {number} Returns the product.
     * @example
     *
     * _.multiply(6, 4);
     * // => 24
     */var multiply=createMathOperation(function(multiplier,multiplicand){return multiplier*multiplicand;},1);/**
     * Computes `number` rounded to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round.
     * @param {number} [precision=0] The precision to round to.
     * @returns {number} Returns the rounded number.
     * @example
     *
     * _.round(4.006);
     * // => 4
     *
     * _.round(4.006, 2);
     * // => 4.01
     *
     * _.round(4060, -2);
     * // => 4100
     */var round=createRound('round');/**
     * Subtract two numbers.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {number} minuend The first number in a subtraction.
     * @param {number} subtrahend The second number in a subtraction.
     * @returns {number} Returns the difference.
     * @example
     *
     * _.subtract(6, 4);
     * // => 2
     */var subtract=createMathOperation(function(minuend,subtrahend){return minuend-subtrahend;},0);/**
     * Computes the sum of the values in `array`.
     *
     * @static
     * @memberOf _
     * @since 3.4.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {number} Returns the sum.
     * @example
     *
     * _.sum([4, 2, 8, 6]);
     * // => 20
     */function sum(array){return array&&array.length?baseSum(array,identity):0;}/**
     * This method is like `_.sum` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the value to be summed.
     * The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the sum.
     * @example
     *
     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
     *
     * _.sumBy(objects, function(o) { return o.n; });
     * // => 20
     *
     * // The `_.property` iteratee shorthand.
     * _.sumBy(objects, 'n');
     * // => 20
     */function sumBy(array,iteratee){return array&&array.length?baseSum(array,getIteratee(iteratee,2)):0;}/*------------------------------------------------------------------------*/// Add methods that return wrapped values in chain sequences.
lodash.after=after;lodash.ary=ary;lodash.assign=assign;lodash.assignIn=assignIn;lodash.assignInWith=assignInWith;lodash.assignWith=assignWith;lodash.at=at;lodash.before=before;lodash.bind=bind;lodash.bindAll=bindAll;lodash.bindKey=bindKey;lodash.castArray=castArray;lodash.chain=chain;lodash.chunk=chunk;lodash.compact=compact;lodash.concat=concat;lodash.cond=cond;lodash.conforms=conforms;lodash.constant=constant;lodash.countBy=countBy;lodash.create=create;lodash.curry=curry;lodash.curryRight=curryRight;lodash.debounce=debounce;lodash.defaults=defaults;lodash.defaultsDeep=defaultsDeep;lodash.defer=defer;lodash.delay=delay;lodash.difference=difference;lodash.differenceBy=differenceBy;lodash.differenceWith=differenceWith;lodash.drop=drop;lodash.dropRight=dropRight;lodash.dropRightWhile=dropRightWhile;lodash.dropWhile=dropWhile;lodash.fill=fill;lodash.filter=filter;lodash.flatMap=flatMap;lodash.flatMapDeep=flatMapDeep;lodash.flatMapDepth=flatMapDepth;lodash.flatten=flatten;lodash.flattenDeep=flattenDeep;lodash.flattenDepth=flattenDepth;lodash.flip=flip;lodash.flow=flow;lodash.flowRight=flowRight;lodash.fromPairs=fromPairs;lodash.functions=functions;lodash.functionsIn=functionsIn;lodash.groupBy=groupBy;lodash.initial=initial;lodash.intersection=intersection;lodash.intersectionBy=intersectionBy;lodash.intersectionWith=intersectionWith;lodash.invert=invert;lodash.invertBy=invertBy;lodash.invokeMap=invokeMap;lodash.iteratee=iteratee;lodash.keyBy=keyBy;lodash.keys=keys;lodash.keysIn=keysIn;lodash.map=map;lodash.mapKeys=mapKeys;lodash.mapValues=mapValues;lodash.matches=matches;lodash.matchesProperty=matchesProperty;lodash.memoize=memoize;lodash.merge=merge;lodash.mergeWith=mergeWith;lodash.method=method;lodash.methodOf=methodOf;lodash.mixin=mixin;lodash.negate=negate;lodash.nthArg=nthArg;lodash.omit=omit;lodash.omitBy=omitBy;lodash.once=once;lodash.orderBy=orderBy;lodash.over=over;lodash.overArgs=overArgs;lodash.overEvery=overEvery;lodash.overSome=overSome;lodash.partial=partial;lodash.partialRight=partialRight;lodash.partition=partition;lodash.pick=pick;lodash.pickBy=pickBy;lodash.property=property;lodash.propertyOf=propertyOf;lodash.pull=pull;lodash.pullAll=pullAll;lodash.pullAllBy=pullAllBy;lodash.pullAllWith=pullAllWith;lodash.pullAt=pullAt;lodash.range=range;lodash.rangeRight=rangeRight;lodash.rearg=rearg;lodash.reject=reject;lodash.remove=remove;lodash.rest=rest;lodash.reverse=reverse;lodash.sampleSize=sampleSize;lodash.set=set;lodash.setWith=setWith;lodash.shuffle=shuffle;lodash.slice=slice;lodash.sortBy=sortBy;lodash.sortedUniq=sortedUniq;lodash.sortedUniqBy=sortedUniqBy;lodash.split=split;lodash.spread=spread;lodash.tail=tail;lodash.take=take;lodash.takeRight=takeRight;lodash.takeRightWhile=takeRightWhile;lodash.takeWhile=takeWhile;lodash.tap=tap;lodash.throttle=throttle;lodash.thru=thru;lodash.toArray=toArray;lodash.toPairs=toPairs;lodash.toPairsIn=toPairsIn;lodash.toPath=toPath;lodash.toPlainObject=toPlainObject;lodash.transform=transform;lodash.unary=unary;lodash.union=union;lodash.unionBy=unionBy;lodash.unionWith=unionWith;lodash.uniq=uniq;lodash.uniqBy=uniqBy;lodash.uniqWith=uniqWith;lodash.unset=unset;lodash.unzip=unzip;lodash.unzipWith=unzipWith;lodash.update=update;lodash.updateWith=updateWith;lodash.values=values;lodash.valuesIn=valuesIn;lodash.without=without;lodash.words=words;lodash.wrap=wrap;lodash.xor=xor;lodash.xorBy=xorBy;lodash.xorWith=xorWith;lodash.zip=zip;lodash.zipObject=zipObject;lodash.zipObjectDeep=zipObjectDeep;lodash.zipWith=zipWith;// Add aliases.
lodash.entries=toPairs;lodash.entriesIn=toPairsIn;lodash.extend=assignIn;lodash.extendWith=assignInWith;// Add methods to `lodash.prototype`.
mixin(lodash,lodash);/*------------------------------------------------------------------------*/// Add methods that return unwrapped values in chain sequences.
lodash.add=add;lodash.attempt=attempt;lodash.camelCase=camelCase;lodash.capitalize=capitalize;lodash.ceil=ceil;lodash.clamp=clamp;lodash.clone=clone;lodash.cloneDeep=cloneDeep;lodash.cloneDeepWith=cloneDeepWith;lodash.cloneWith=cloneWith;lodash.conformsTo=conformsTo;lodash.deburr=deburr;lodash.defaultTo=defaultTo;lodash.divide=divide;lodash.endsWith=endsWith;lodash.eq=eq;lodash.escape=escape;lodash.escapeRegExp=escapeRegExp;lodash.every=every;lodash.find=find;lodash.findIndex=findIndex;lodash.findKey=findKey;lodash.findLast=findLast;lodash.findLastIndex=findLastIndex;lodash.findLastKey=findLastKey;lodash.floor=floor;lodash.forEach=forEach;lodash.forEachRight=forEachRight;lodash.forIn=forIn;lodash.forInRight=forInRight;lodash.forOwn=forOwn;lodash.forOwnRight=forOwnRight;lodash.get=get;lodash.gt=gt;lodash.gte=gte;lodash.has=has;lodash.hasIn=hasIn;lodash.head=head;lodash.identity=identity;lodash.includes=includes;lodash.indexOf=indexOf;lodash.inRange=inRange;lodash.invoke=invoke;lodash.isArguments=isArguments;lodash.isArray=isArray;lodash.isArrayBuffer=isArrayBuffer;lodash.isArrayLike=isArrayLike;lodash.isArrayLikeObject=isArrayLikeObject;lodash.isBoolean=isBoolean;lodash.isBuffer=isBuffer;lodash.isDate=isDate;lodash.isElement=isElement;lodash.isEmpty=isEmpty;lodash.isEqual=isEqual;lodash.isEqualWith=isEqualWith;lodash.isError=isError;lodash.isFinite=isFinite;lodash.isFunction=isFunction;lodash.isInteger=isInteger;lodash.isLength=isLength;lodash.isMap=isMap;lodash.isMatch=isMatch;lodash.isMatchWith=isMatchWith;lodash.isNaN=isNaN;lodash.isNative=isNative;lodash.isNil=isNil;lodash.isNull=isNull;lodash.isNumber=isNumber;lodash.isObject=isObject;lodash.isObjectLike=isObjectLike;lodash.isPlainObject=isPlainObject;lodash.isRegExp=isRegExp;lodash.isSafeInteger=isSafeInteger;lodash.isSet=isSet;lodash.isString=isString;lodash.isSymbol=isSymbol;lodash.isTypedArray=isTypedArray;lodash.isUndefined=isUndefined;lodash.isWeakMap=isWeakMap;lodash.isWeakSet=isWeakSet;lodash.join=join;lodash.kebabCase=kebabCase;lodash.last=last;lodash.lastIndexOf=lastIndexOf;lodash.lowerCase=lowerCase;lodash.lowerFirst=lowerFirst;lodash.lt=lt;lodash.lte=lte;lodash.max=max;lodash.maxBy=maxBy;lodash.mean=mean;lodash.meanBy=meanBy;lodash.min=min;lodash.minBy=minBy;lodash.stubArray=stubArray;lodash.stubFalse=stubFalse;lodash.stubObject=stubObject;lodash.stubString=stubString;lodash.stubTrue=stubTrue;lodash.multiply=multiply;lodash.nth=nth;lodash.noConflict=noConflict;lodash.noop=noop;lodash.now=now;lodash.pad=pad;lodash.padEnd=padEnd;lodash.padStart=padStart;lodash.parseInt=parseInt;lodash.random=random;lodash.reduce=reduce;lodash.reduceRight=reduceRight;lodash.repeat=repeat;lodash.replace=replace;lodash.result=result;lodash.round=round;lodash.runInContext=runInContext;lodash.sample=sample;lodash.size=size;lodash.snakeCase=snakeCase;lodash.some=some;lodash.sortedIndex=sortedIndex;lodash.sortedIndexBy=sortedIndexBy;lodash.sortedIndexOf=sortedIndexOf;lodash.sortedLastIndex=sortedLastIndex;lodash.sortedLastIndexBy=sortedLastIndexBy;lodash.sortedLastIndexOf=sortedLastIndexOf;lodash.startCase=startCase;lodash.startsWith=startsWith;lodash.subtract=subtract;lodash.sum=sum;lodash.sumBy=sumBy;lodash.template=template;lodash.times=times;lodash.toFinite=toFinite;lodash.toInteger=toInteger;lodash.toLength=toLength;lodash.toLower=toLower;lodash.toNumber=toNumber;lodash.toSafeInteger=toSafeInteger;lodash.toString=toString;lodash.toUpper=toUpper;lodash.trim=trim;lodash.trimEnd=trimEnd;lodash.trimStart=trimStart;lodash.truncate=truncate;lodash.unescape=unescape;lodash.uniqueId=uniqueId;lodash.upperCase=upperCase;lodash.upperFirst=upperFirst;// Add aliases.
lodash.each=forEach;lodash.eachRight=forEachRight;lodash.first=head;mixin(lodash,function(){var source={};baseForOwn(lodash,function(func,methodName){if(!hasOwnProperty.call(lodash.prototype,methodName)){source[methodName]=func;}});return source;}(),{'chain':false});/*------------------------------------------------------------------------*//**
     * The semantic version number.
     *
     * @static
     * @memberOf _
     * @type {string}
     */lodash.VERSION=VERSION;// Assign default placeholders.
arrayEach(['bind','bindKey','curry','curryRight','partial','partialRight'],function(methodName){lodash[methodName].placeholder=lodash;});// Add `LazyWrapper` methods for `_.drop` and `_.take` variants.
arrayEach(['drop','take'],function(methodName,index){LazyWrapper.prototype[methodName]=function(n){n=n===undefined?1:nativeMax(toInteger(n),0);var result=this.__filtered__&&!index?new LazyWrapper(this):this.clone();if(result.__filtered__){result.__takeCount__=nativeMin(n,result.__takeCount__);}else{result.__views__.push({'size':nativeMin(n,MAX_ARRAY_LENGTH),'type':methodName+(result.__dir__<0?'Right':'')});}return result;};LazyWrapper.prototype[methodName+'Right']=function(n){return this.reverse()[methodName](n).reverse();};});// Add `LazyWrapper` methods that accept an `iteratee` value.
arrayEach(['filter','map','takeWhile'],function(methodName,index){var type=index+1,isFilter=type==LAZY_FILTER_FLAG||type==LAZY_WHILE_FLAG;LazyWrapper.prototype[methodName]=function(iteratee){var result=this.clone();result.__iteratees__.push({'iteratee':getIteratee(iteratee,3),'type':type});result.__filtered__=result.__filtered__||isFilter;return result;};});// Add `LazyWrapper` methods for `_.head` and `_.last`.
arrayEach(['head','last'],function(methodName,index){var takeName='take'+(index?'Right':'');LazyWrapper.prototype[methodName]=function(){return this[takeName](1).value()[0];};});// Add `LazyWrapper` methods for `_.initial` and `_.tail`.
arrayEach(['initial','tail'],function(methodName,index){var dropName='drop'+(index?'':'Right');LazyWrapper.prototype[methodName]=function(){return this.__filtered__?new LazyWrapper(this):this[dropName](1);};});LazyWrapper.prototype.compact=function(){return this.filter(identity);};LazyWrapper.prototype.find=function(predicate){return this.filter(predicate).head();};LazyWrapper.prototype.findLast=function(predicate){return this.reverse().find(predicate);};LazyWrapper.prototype.invokeMap=baseRest(function(path,args){if(typeof path=='function'){return new LazyWrapper(this);}return this.map(function(value){return baseInvoke(value,path,args);});});LazyWrapper.prototype.reject=function(predicate){return this.filter(negate(getIteratee(predicate)));};LazyWrapper.prototype.slice=function(start,end){start=toInteger(start);var result=this;if(result.__filtered__&&(start>0||end<0)){return new LazyWrapper(result);}if(start<0){result=result.takeRight(-start);}else if(start){result=result.drop(start);}if(end!==undefined){end=toInteger(end);result=end<0?result.dropRight(-end):result.take(end-start);}return result;};LazyWrapper.prototype.takeRightWhile=function(predicate){return this.reverse().takeWhile(predicate).reverse();};LazyWrapper.prototype.toArray=function(){return this.take(MAX_ARRAY_LENGTH);};// Add `LazyWrapper` methods to `lodash.prototype`.
baseForOwn(LazyWrapper.prototype,function(func,methodName){var checkIteratee=/^(?:filter|find|map|reject)|While$/.test(methodName),isTaker=/^(?:head|last)$/.test(methodName),lodashFunc=lodash[isTaker?'take'+(methodName=='last'?'Right':''):methodName],retUnwrapped=isTaker||/^find/.test(methodName);if(!lodashFunc){return;}lodash.prototype[methodName]=function(){var value=this.__wrapped__,args=isTaker?[1]:arguments,isLazy=value instanceof LazyWrapper,iteratee=args[0],useLazy=isLazy||isArray(value);var interceptor=function(value){var result=lodashFunc.apply(lodash,arrayPush([value],args));return isTaker&&chainAll?result[0]:result;};if(useLazy&&checkIteratee&&typeof iteratee=='function'&&iteratee.length!=1){// Avoid lazy use if the iteratee has a "length" value other than `1`.
isLazy=useLazy=false;}var chainAll=this.__chain__,isHybrid=!!this.__actions__.length,isUnwrapped=retUnwrapped&&!chainAll,onlyLazy=isLazy&&!isHybrid;if(!retUnwrapped&&useLazy){value=onlyLazy?value:new LazyWrapper(this);var result=func.apply(value,args);result.__actions__.push({'func':thru,'args':[interceptor],'thisArg':undefined});return new LodashWrapper(result,chainAll);}if(isUnwrapped&&onlyLazy){return func.apply(this,args);}result=this.thru(interceptor);return isUnwrapped?isTaker?result.value()[0]:result.value():result;};});// Add `Array` methods to `lodash.prototype`.
arrayEach(['pop','push','shift','sort','splice','unshift'],function(methodName){var func=arrayProto[methodName],chainName=/^(?:push|sort|unshift)$/.test(methodName)?'tap':'thru',retUnwrapped=/^(?:pop|shift)$/.test(methodName);lodash.prototype[methodName]=function(){var args=arguments;if(retUnwrapped&&!this.__chain__){var value=this.value();return func.apply(isArray(value)?value:[],args);}return this[chainName](function(value){return func.apply(isArray(value)?value:[],args);});};});// Map minified method names to their real names.
baseForOwn(LazyWrapper.prototype,function(func,methodName){var lodashFunc=lodash[methodName];if(lodashFunc){var key=lodashFunc.name+'',names=realNames[key]||(realNames[key]=[]);names.push({'name':methodName,'func':lodashFunc});}});realNames[createHybrid(undefined,WRAP_BIND_KEY_FLAG).name]=[{'name':'wrapper','func':undefined}];// Add methods to `LazyWrapper`.
LazyWrapper.prototype.clone=lazyClone;LazyWrapper.prototype.reverse=lazyReverse;LazyWrapper.prototype.value=lazyValue;// Add chain sequence methods to the `lodash` wrapper.
lodash.prototype.at=wrapperAt;lodash.prototype.chain=wrapperChain;lodash.prototype.commit=wrapperCommit;lodash.prototype.next=wrapperNext;lodash.prototype.plant=wrapperPlant;lodash.prototype.reverse=wrapperReverse;lodash.prototype.toJSON=lodash.prototype.valueOf=lodash.prototype.value=wrapperValue;// Add lazy aliases.
lodash.prototype.first=lodash.prototype.head;if(symIterator){lodash.prototype[symIterator]=wrapperToIterator;}return lodash;};/*--------------------------------------------------------------------------*/// Export lodash.
var _=runInContext();// Some AMD build optimizers, like r.js, check for condition patterns like:
if(true){// Expose Lodash on the global object to prevent errors when Lodash is
// loaded by a script tag in the presence of an AMD loader.
// See http://requirejs.org/docs/errors.html#mismatch for more details.
// Use `_.noConflict` to remove Lodash from the global object.
root._=_;// Define as an anonymous module so, through path mapping, it can be
// referenced as the "underscore" module.
!(__WEBPACK_AMD_DEFINE_RESULT__ = function(){return _;}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));}// Check for `exports` after `define` in case a build optimizer adds it.
else if(freeModule){// Export for Node.js.
(freeModule.exports=_)._=_;// Export for CommonJS support.
freeExports._=_;}else{// Export to the global object.
root._=_;}}).call(this);
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3), __webpack_require__(22)(module)))

/***/ }),
/* 22 */
/***/ (function(module, exports) {

module.exports = function (module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function () {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function () {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function () {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};

/***/ }),
/* 23 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"house"},[_c('transition-group',{attrs:{"name":"fade"}},_vm._l((_vm.callouts),function(callout){return _c('callout',{directives:[{name:"show",rawName:"v-show",value:(callout.show),expression:"callout.show"}],key:callout.slug,style:(("top: " + (callout.position.top) + "; left: " + (callout.position.left) + ";")),attrs:{"title":callout.title,"content":callout.text}})})),_vm._v(" "),_c('div',{staticClass:"house-wrapper"},[_c('img',{attrs:{"src":__webpack_require__(24)}}),_vm._v(" "),_vm._l((_vm.callouts),function(callout){return _c('div',{class:("hotspot " + (callout.slug)),on:{"mouseenter":function($event){$event.stopPropagation();_vm.showCallout(callout.title)},"mouseleave":function($event){$event.stopPropagation();_vm.hideCallout(callout.title)}}})})],2)],1)}
var staticRenderFns = []
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);

/***/ }),
/* 24 */
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,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AAB0SIARAAAAAAAAAAAAAAAAAAAAAADQMQFGAAAAAAAAAAAAAAAAAAAAAABAxwQYAQAAAAAAAAAAAAAAAAAAAAAAHRNgBAAAAAAAAAAAAAAAAAAAAAAAdEyAEQAAAAAAAAAAAAAAAAAAAAAA0DEBRgAAAAAAAAAAAAAAAAAAAAAAQMcEGAEAAAAAAAAAAAAAAAAAAAAAAB0TYAQAAAAAAAAAAAAAAAAAAAAAAHRMgBEAAAAAAAAAAAAAAAAAAAAAANAxAUYAAAAAAAAAAAAAAAAAAAAAAEDHBBgBAAAAAAAAAAAAAAAAAAAAAAAdE2AEAAAAAAAAAAAAAAAAAAAAAAB0TIARAAAAAAAAAAAAAAAAAAAAAADQMQFGAAAAAAAAAAAAAAAAAAAAAABAxwQYAQAAAAAAAAAAAAAAAAAAAAAAHRNgBAAAAAAAAAAAAAAAAAAAAAAAdEyAEQAAAAAAAAAAAAAAAAAAAAAA0DEBRgAAAAAAAAAAAAAAAAAAAAAAQMcEGAEAAAAAAAAAAAAAAAAAAAAAAB0TYAQAAAAAAAAAAAAAAAAAAAAAAHRMgBEAAAAAAAAAAAAAAAAAAAAAANAxAUYAAAAAAAAAAAAAAAAAAAAAAEDHBBgBAAAAAAAAAAAAAAAAAAAAAAAdE2AEAAAAAAAAAAAAAAAAAAAAAAB0TIARAAAAAAAAAAAAAAAAAAAAAADQMQFGAAAAAAAAAAAAAAAAAAAAAABAxwQYAQAAAAAAAAAAAAAAAAAAAAAAHRNgBAAAAAAAAAAAAAAAAAAAAAAAdEyAEQAAAAAAAAAAAAAAAAAAAAAA0DEBRgAAAAAAAAAAAAAAAAAAAAAAQMcEGAEAAAAAAAAAAAAAAAAAAAAAAB0TYAQAAAAAAAAAAAAAAAAAAAAAAHRMgBEAAAAAAAAAAAAAAAAAAAAAANAxAUYAAAAAAAAAAAAAAAAAAAAAAEDHBBgBAAAAAAAAAAAAAAAAAAAAAAAdE2AEAAAAAAAAAAAAAAAAAAAAAAB0TIARAAAAAAAAAAAAAAAAAAAAAADQMQFGAAAAAAAAAAAAAAAAAAAAAABAxwQYAQAAAAAAAAAAAAAAAAAAAAAAHRNgBAAAAAAAAAAAAAAAAAAAAAAAdEyAEQAAAAAAAAAAAAAAAAAAAAAA0DEBRgAAAAAAAAAAAAAAAAAAAAAAQMcEGAEA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s13WSqWiarWqyclJlUql5PmO5+fDz09HR0cSEuSXaZpvdOMf39nZmawTf58f90FFfp78/f55h4aGkmWdDnzyj/PL4Z97OrzIL/fJ/N/6+fN/55/Lm173/u/83/vx6Wkna25u1tjY2LFtcPx8+f3Nryv/HAAAAAAAAAAAAACAhataK6kWueKGZXd+uFpoPXINvA8wqlWEWWICKQhks01SJqepqCIbVxS49e6lUzkBc224VFW5FrkSJxfqH9+GZraljrYJas2llQkDZVI0PccPTbdh8m2RfFss327Jt3tyxe2W1lzIfRMvyzcey7mt0FksFvvd7Um3PUp33nnnqFA3kY18g8GCTCgAs8V/F738940hMAz1Yo1vhN5sVMsKAAAAAESAERaLSO9PmdTqOIrfmYxT+VI3JnAnagoN6u7p1saNG5OL4puamgQAAJaer33ta/rKV76SBPtM8w05brjhBl1//fV661vfOuPf+SCb2267TX//93+vxx57LPn745/j61//ulauXKmf/dmf1Wy4//77j4UUdXd36yd+4ie0atUqrV69Wn19fWprazuj5/nyl7+shx9+eMblfdOb3qS3vOUtM/6df83jl3dwcPCE0KK77747ecyZLq8PF/Lr6KGHHtKDDz54yv1+vftl+uAHP3ja53jd616ngwcP6td+7deSoCI/X0cb4Oh//+//rXvuuUejo6PHGolNz9+GDRt08803z/icPrzom9/8pp555hnt2bPn2HQffOSDnX7u537O92CWrLOXmi/vj/7oj5LwIv88fuhDjR599NFkXfntt2IFPdMDAAAAAAAAAAAAwEJUqZX01J6HNFke09DEAZnePpl/9Wsq7HpCqalR5QeeVECI0ayoFZpVbe3RZN8lqrT16vmUkQ5v0wqVlUlltXH5NQLm0vBUVZ/+5+3atn9M/7j9gEpHg4wulBXNOXU2ZPX+G9erpzGrWzZ0C5g23XnbK1/5yozvXM0NdeDAgfjrX/t6NDExEbhCSksdmCM94zVZ2eustdcq1q/Z2P4vN/l7d/zHO75453+5c0CoDxOuk4Lr3XbpNKSpALMicG+lbMj7CfOYMevcd/Ivur30e27sXwQAAABgySPACAtSsVj03bqk3MmA64I4aHA/dq90461CXfkeJvzJmuXLl6utvU35fP7YyRsAALB0lEqlJKxmfHw8CeKJ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k4EOMAqlqPruwWownxvITjOfAu05V7MT7nc7YSVErAXTsomIiIiI+t2dwUNr4SBeGPKgOxH1l3KlqHbCL/zb/27RPffeO2g2V/DOW2+gsbSEa1cvI8syaL2xOOVypYwgCPH4Ex9CrTaGFz/+yeJ+rV4HERERERERERERERERERERERENptxErmz/HMiVbAyJjkEP509B9WefjsWy7DplAzR6uc16xkwZ8EqYRERERERERPtlKAJfpEBJueqFSiCS3FiVGgbZjBpXvRS5IkFEREREREREtAtqtTqiKEJ64hQ6sy3MHjiAbqeLNMtgTA5r13+fD2jzQUWVSsV1Axw8dNj1Jy6KlDxfhoiIiIiIiIiIiIiIiIiIiIiIgEBkCF2hzSkpEUkBleTCuLvW/VOggpSmYqSsgIiIiIiIiGgPDEXQT6hELZDWTJbFcjsVcZoYBhiNGCFQFbAgIiIiIiIiItoNswcOFt2jx47ffqyxvIRup4MkTWCMWfd9PvioXh8rwo+k4rkxRERERERERERERERERERERER0v7LqoeQKbU41kuWq6zYSmxjj84sYYLTGCjHpOisgIiIiIiIi2gPDE/QjIEpKVm1okWiR5gYqM5YVDnvAVexk1tdpACH8lNiPYbBoWwg/vUsgIiIiIiKiDcnzHO12u+hqrUH9oVRa3bUNggBC7MtuNm1QuVJBFMUwRsPY9YOVwyBEGIYQUoKIiIiIiIiIiIiIiIiIiIiIiIZLLWxBCItA5DBWwGwxP2csbKAatEGbI/0pdtaNv1jYTAusJHYD7xJ3lCFmMe1myOZqs7/9IjYyQYiIiIiIiGgIDE2AkXBVPaFCrA3yWInMYBs1PrQ5Vhj317jahHC/ajOsReqKn58ZYERERERERLRBxhikaYosyxhg1Ef89FCKVRqDwIcXIQIREREREREREREREREREREREY2okuohNwFk0bxKFg2stqLs+lMJuqDNEbf+xEq6aeBGfrLRd41AgBFkRQKV06f354u6zx3+8CJrh30mGiyCgVkFzpf9g/MkERERjZihCTBaEyqBybK0smeQa1tU+nALb3flxrRTLdJYitBtUO/LPKWt7bkJzSaDREREREREm2CtLUKMdJ4XoTlEREREREREREREREREREREREREO8VqC9sxsG3TQtu2rLAxlAjUkaAqQikxBEKRoay6eG7i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ILHkvkQn1+m/mc+XG6D+cfq0eeE0Vv5QfEGFygYyxUEDHMQgk0ILWCMh3mnqpHnkteudV175ogENjm73uqmmsUxKB62KS9bYAxhg0s2T0DrNRHq9E4Tv9q4yUIuIiIhoJ4xUgJGXWysHMOp4cK0FhmditXRcSW/dJiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIaeELYHNCuZHL1eu/pioBwt8O6RREMtMXMG5sbaxJr4Dr3PamgbOz6HGwgIsm/24f65G7o8jva17UsrHElNQahcD0Sg93wyw29RPE9rJ8q7rup4u4W+ZwL6UZcKBPEslcEGJli9PX/aPJBS9YWU1W5caGKecAnyVjZE8Is66DSefW/+rkOqK+cPn3afPH0n01WsNKxvjWmm3iQUmFAubWLb9abao1Mad195pmz9pVXhAUNjDOnP59/4e9+VYk8bltjhJ8n3brFrVnkYKS53Uek7mev636ve713S71X/8FLOX4TRERERLRNIxVgZNxeTpLbaqrtyAU37RsfVpS4ct6N8nm3L9ITq4FGRERERERERERERERERERERERERERERERERERDJu8KV4Ab31HwkSMHP60RVoB4YmuNqsyKjeyN3EeA3BdgImMRBsfDw6K+wQyJ/P5hsF0zgdwY/U7alFMqxCNRBQPMxwop96ekxIovKcSUtraKbZpVNzAul/FT81GsmEn4WKN+DzGyVgojlDJWhQK2BClyFHOB/sNur/e9M19+uY2/AepDr5z+SMt13vmFv/UtIY2ouYk4BWFjDCBhcA1CXGhU9fVv/pXPd8+ABtHXfuMX0y+e/smPV4LeNEQ2LQXKwpoIA0k0MiW+nZTizqu/+bGM4UVEREREO2PkgnxyYwPjs6Vpd/m6LJ/I7Src0HSlI1bvExERERERERERERERERERERERERERERERERENO1P8R9oQ0D2L0EfoCEButEWftbCuB0Jbaa0IBOz915UXroeh7ym2zXaMQEUKa6zrrej3bJ4P5L5CECjEubVK70C7NuGmpkKOkuy6vyHapg43adDP3JR0s5EQqwVu4tqO+7uktWwljTk96NN4FAQWXQ295CbmuJ+pDUx/z3R3UFZobW0Cq7oisJ25YNmABtoc5kwtR5bGlWW3dnFrEFt26xZhhRmYtYkUctnNl+1WgmzhGudJIiIiop00UgFGroJGJhp1Y7eWVk2b4Ct1Om5f+IoCLqvV+5Y1GkREREREREREREREREREREREREREREREREQ0/HS62p3/gURQsYgnDGRgEY1t7P02d39SC5uaMnKDdVvEBYCcVIDCttgMIr+Uhe6mkiciWGUh1GC3BYuUqI5Fsqq1QYbttycMRV6UI+ElJLaEs70XoPu8eaaBEAYqcHNeKARiQFyAMd8tC3Hp9/7Ol7qgvld79OK11vXanOlOzsCImjQqtEXCWP9za6+GlfZ6juzqv/rrP3sZNOjsmdOfz1/6te81Dj+JH2Wp/rCbE6chEAgbDESwlhvenvtpfTPP89a3v/IzKyAiIiKiHTUyAUauiqFnrHB1NbbE/KJd5Metrxzz4UU+uKghV6PCGcdMRERERERERERERERERERERERE/zN7fwJlyXWYd57fvRFvzbUya68CCjtBLCQBLgAXUKQ2UzIly2NLmu7x2JTb1kjyMt0947YtqU+X+3i0eOZYc9qnNW1129b49DndIkVZ1mJaFBeQokWAEkgQBEASW+2oyqzKPfOtEff2vZFVhcrKrKrMqsysl5n/H3Ar3ouIF+++iBtvicj7BQAAAAAAO4zPpbxtNPO6UalPGrrPyyaSuVHoUOZzP5t3fMeXdXVEkZEzVTunqk3DlL71yDMxTqlrO++nsqbpS0rqN1u672EaV0lilFp1w83ce1XCervlFVW386r4lgbsjFq+pjk3pF7lwsv1MbLDqBNe/ynr/Ul5f3w2ay8IW8KnXn7Z//hDD2Xzr+855Vw+5+UfDBu1rB7mjffW2IasmXJGJ5S1Z4Rt47mD784/Pv9cQ1UzGdrkm6nsHu/9KqP5bh+b+mmTmYVM/lwndR0BAABg3e2cACNn2uFLcAybrgobKwvHcWL+cgwwiuFFjvAiAAAAAAAAAAAAAAAAAAAAAAAAADuPdzHASJp53ao66jVwZxhR9kpuEGDkOz5z03lLbWd1VYCRMcaZup21dVsxienTrYsdwEqm7dtuMm/ZxMj02y3d9zCxplhpYT13w82uky8XYT63qM/OF8OBZEaJyzXrdqlX+cUAIyvvO2GLnvJeJz/zix88IWwdR4+6T4XBDx79T2eUli4Y5W+T9TeKP7u9vMnDP23nNZ3WJk/275/PhO3jqHF/IDX+wj/98qRRqSLjBsNnUm+3SRV9zOd96me/8A/fPyYAAABsiB0TYNRxue+GXzzYQOFnZZFHfSw0q87F+57wIgAAAAAAAAAAAAAAAAAAAAAAAAA7mJdcJnWmpclvG/Xtl2oHimgZWXuNh3Rc7qZcy3d8ZdlEK2P2pv3qW0PIUHyespFJrt3fy7d87s5nbfXbktX2UE2s9WWfzrRd8cJTGa1H0sYd6Qk1fV3ns31yYYldX1YPMjWzUHeys5Nen5Upnxe2pKGHPjDdfPm51Ff9MZf7AVl/r3qQ8bGHqcvSTC/akpn63cmvdfX3j9Kxdxuanbh7enDoVNtX/LD3piTv9xprevGjIwvt0ufGfsd3NSsAAABsmB0TYJSFnziZEzZSDCvKQpkIvzEyEV4EAAAAAAAAAAAAAAAAAAAAAAAAAJGT8q7UOGdU6vOq7dNiqNC15Mb7BZf5TMvCP7yVtf22amp29WERJvxfMsXwWnyon5v3ue34bdMTr5TIehk/2wmvL6zJmN+0HgkbQ+mEyq4ZlpcXAVVevZjb4cMm75a9kfvMLzz5srBlfeonTGjB6nzsl7826a3JrfHrkcO17rxcZqzNwq032y3T1D85Sq/ebeqrv3ZHMwyaH/vv/9OcScyCMzLG2J5rl96HzzPjnc1b4xqbJ8AIAABgA+2YAKPZlhvsOoJaN9Rr4bdFIxzBmSO4CAAAAAAAAAAAAAAAAAAAAAAAAACu5DOjzozX3AmjbsNo6G6v6ug1+ry18pqbyg4UcUVXpQ6Z1Bh7IK2uJTPHpGFJMb3nevESuS+5hWzYdUol6UavJdS745Wfz+bUcK1Qp5I33qT3VYfUQ6qhXtVEpemWFrpObtRqUOukYlt6vPanms5261vt98jHpKAeCTKyxqliWtnjta+ezpRcELYF07frhXTy9EBerd6dh+ZtnNmtHmJkv2jlO493nzz/3x2VN/9E2OZm+s2Lmp1+fSgdGAkNYMB5s27vsevB2/wrplOauHC6NP3cv3wq078QAAAANkgvxvpuiPCl18YibJyuWSz+YgEAAAAAAAAAAAAAAAAAAAAAAAAAXOadkctCacfhdeaLfeGcUrmV+8TFECOTmNV34gqzGmuK4TVn8TIKz2ucbrxcf7Hkcr7lne+4XN1Q4x5jwwu2pnjRLtTXx1W2ltV2I1XbUjmUS4pV2APlkppdyPrtTCZsC5/5+/e356VW2E9zG8vibt0zxZi8lZmsdfSoceGOF7a9znfKWUWVhk2sC1vc91qbtC7teuMbAwfnwlsjbRIAAGAjpdrmuk6TzvtuK/e7M+cTYf1NhmNgnXBQ41yyOAQAAAAAAAAAAAAAAAAAAAAAAAAArKg9ZUKRTMko70h9B7zsxZ5+vu3kzufyk/mKj7W7krPqT7wpm4NaZ15KTQxNuk7Eg286l7+ZtfPzWeKOd8ph1NDFUkjurSjm58TX1kt215KSl1/X8IqYMDVop5Wkmd5efV6T2W6d7N6rXvBo+c/Ulyz4EXuhFV51R9g2nj76kYUf/+df/d/muqU75fL/S9xvrfxt7SvsnY55o8Z//PkPfEPYUZ77jfd0w6D7vf+vr/5+kuZJySX/pXqBMa/L+Des637nP/63T00JAAAAG277BxjlrpSHX9jOeyusr0uHa5pmsfRcPjYAAAAAAAAAAAAAAAAAAAAAAAAA9CbXltozUm23ZOxi8U7et33Hd13sD1e6+jG+bFNbtTedDhSeI5M1WXiWsryW9LmLAT9hwT4M4/KXPUeolULd5GZD3Rpuxf56PvM9GWCUWFkvs64BRpeXrVx1M6+mqausdriXKrtNeTJl2y6Claq2qappCNvU7GBu+zst5/JzRn5X2DN36TYwxuRyxnnrpo0z08KOVer6bmZKmTFuInyIlLzxw7oNjE9yKe94n8xb4yaT+HkHAACATbHtA4zmOn6gnXttyJGFnS4GFrlwIOl0Ik2H4015bx1UAgAAAAAAAAAAAAAAAAAAAAAAAIBeNXfKypyRBg7lMolXUg4jM3Xc+eyCn/P1cG9ZKEmyPx0wfVY3rWqnTd0s+Ib2yfvqlZNCbXJv1THGxOCkpeFJsY/edC43ldv8u63KNZc/70IljVRTT6mldrHOudZdDAu6q/yaymppOh8tSkcV3Q5DZqqoz8HSqWJIx8rtyPhPHVXn/f/8T8dHE/vHeab3hXH7dBs47xesUdv65Lm+Wn5K2LH+6OgHJuPwY7/81WeNN7vDzQ/rNvBes96Y8075a5/5x+9/TgAAANg02zbAKHzJzMKhjizzvpI5b/ihvQFa4UBSI5TMLB7IYB0DAAAAAAAAAAAAAAAAAAAAAAAAwKp4tzhsTRklTan/oJfJnHHzLlXHrZxSVDWJqd38hehtyZi8aoyaq+8M5p2X73qfn8ucb+Xxya+doJRcLDtQ1ba0J3lTbV9VO68o83FF3Py2WgtrXNgoTqPpmPrtnFLTjc9tvfH98qoK205ltt3t9I3MyDYmrXPjxpjh8J6yqdFh1piz3mui2+m0Do/WMmHHc96fi59e5dzPeGvK3of3oM1ibWiD+bzx5tWO8RMCAADAptq2AUa5Vyd3vtEJv/I7+VVpz1gfc+FXxFg4iNIMB1HyzTmQAgAAAAAAAAAAAAAAAAAAAAAAAADbglsMMZo/ZWRTo/6DebxvNJOXw3DFvn/JcFIy/VY3y5eNtf1J4uac8fkK01dK3Inztb2y77S6PmaWSOVrLd9U7WZl9vScoWRK9WpDjeagFvyAsjwNm3hz0pxSdVWyme4oH9Pe9NziSB/zZbRbxg8L287TRz8aA4PG/8KvfO1k2M6D4V3k7WFbD2oT5TZ93WfuhdLE1PhvHH2qK+x4n/35D3znB371K7PhI+wheT9ijN2lTeB9/PhS5mzyZrmVfGnuTdEeAQAANtl2DDDKw/fMrNlVstB1/bk3tjhsgvWTXywL4UjSZFi95OICAAAAAAAAAAAAAAAAAAAAAAAAwE1pnpdMInUnnfy0T5X7uvzS5BtTUsNbOV9SX5j3piOCTN3W7UhS8eezxLeX9rvz8ol1Rr7pEjeby/TZUC8jN95t+gUX4yEqN3zistmxAUZh86hk2tpXPqWqbeiV9sNquH7luvnAqRs/pw+r22t/6U2NJOdVNa3L07wx1ng/6r3Z1FAbbK6F6fE3+4cOLXjf7Dfe9jtpl7Eb2OgU3yvMWGh3b/jcnyhndqL21A9l+hcCCt1mdzKX+0o5rbzNW7dXxlR0neC79RDe7Zq5y79ou/7MH7z0vrY+FSMCAQAAsJm2Y4BRDHnOuy4vLXR9KXeEF22IPBxFaofS2KFHkwAAAAAAAAAAAAAAAAAAAAAAAABgHWQX+2i5puRbMt6pcvU8PjFdY03XWlMPw5sPMCqHZdetlK60CGN87HMYL37fCreqYRhjlGZd183HZKOloUorLr+0c/ubxbWXhJW3y06qWmrrZOceNdWvjUx0ir0nY4jRUDKlfaU3VbHNt+ojb8M//aFeNWHb+sqvfHwqDKb+4q9+dco537KL+/EN99VbEd6BQkMzJ3yaTP7BLzzeEHCFp/WRzsf13Gu57Q6EtpKFdlmTNRvaJuVdXkrMd7NaeVqfMrkAAACw6bZdgFE395rrOC10ffhW60V80QaYDwdMTpakGcKLAAAAAAAAAAAAAAAAAAAAAAAAAGA9TH9bnaTrbd8K/f6S0dSoz1qVdEtMDC8q67o9C93ZbtaZyTMznLRMyTh/Nktdx9nrLresedkiNGJIPSi+5M3qDddn51TTgu4svaFdyaS+035EG2UgmdWh9KT2p6c0koyH5tERdibbsd/wtvuGt+nfMPK7tBhBtr6MXfDenXLefqek6tdarUfnBFztqHF/cNS3Pt75yqmsVvlDY9wH5f1D2iBO9unQJueSpj1x4XV1BQAAgNti2wUY5U7q5DKZF+FFG6UTDtUsmMUhAAAAAAAAAAAAAAAAAAAAAAAAAOCWdWeNl5dbcWLFGFszt96hKzUyMYroOnFEvuW9OrlTrq7KJncLriTnr/vc3prcWNOzwRGJNi/AqHRxNfQl83JmY5+5rHZ4njlVTSs0kbawc5m57gU/5OZVvIUUbc5qnYWlhjcHsyCXz/7hL7xjSsC1HDVu/ugXZyu+cs44l8mYdW+Pl4R2OWHkFv7g6PsaAgAAwG2zbQKMvPduvuumFzqqTLddn7D+YiJUK3yVnwu/EyY27LcCAAAAAAAAAAAAAAAAAAAAAAAAAOw48/OlStkY1dO2jLwS81aWUbIvHbC7U5nk1vp1mXQxTMfUkklT813fdPtWmK0kp5Kfyeteq5McLFk7YBP1qJo32uwecfdXXiqGp7t3KfeJxrKDWi9l09Lu9LzuKL2hx2rPCPi9f/ahuTCY+6Ff/rN/K5tX5PwvaF2Zccm/5tLarw8dSXo2rAy94+mjH50Og+kf+tVnBow3x53c9xqvfVovXmfDv63/+PNPfEoAAAC47bZFCk0ML3JeeZ7LrvaACG5S1+gaGd4AAAAAAAAAAAAAAAAAAAAAAAAAgFsQ+8c5b+Qv3/dexjtZIxmtG5PKm0S33B2vqKqVM2VrVdoe/RXXW9U0VLXNIpQqlrjSb6UYOZVNt1huqhvnyHhjzNGjR21sScL25/K2XNIO+2bDyWRx+69TmQ7vRK25ZMHpZQGr5ozv5N4vqGiP6t5qW4zL9Iv/zyi0SwEAAKAnpNoGOrkms3AI5lzDjQgbJ4YXHQtNpsFxCgAAAAAAAAAAAAAAAAAAAAAAAABYb85bzbmaKqar/qQlk9iGseqYmhkwdbtu/QHNQOKMU675jm6F7U/mQ93ayV2lITuc9AnLfKjvc1pwA3qzc2dY4TE16tY2Y8U0tSs5Xyw3MTcOMDJeyfcceXrw6d/8SEt6uiVsa5/5hSeLeKGP/fIzX7JOu8P7x1NaBz7Jfj0zvvnV//pDTQFr8Ef/zfu/HgZf/6Ffefagl7nPev8O3QLnTVtGuZX9vcS5VwQAAICesKUDjLxXJxQ/13FVR/rvxnKh5KE0QuEQBQAAAAAAAAAAAAAAAAAAAAAAAACsOyejrrdKw9CH+7YSBiXrZbW+yqasqr35PnmJnK2YrtmTJGYwqZrU0L/vGhJ1i9Chg+lJzfsBjWcHdDOM8cVwf3paQ3ayWG5SdPq7Pi9fzprZSFWaEr0Ddwwj8x1v3Z3hZsMYmzjn67oJ4V3iRGh5nbyhuXJl8MaJWcA12Nx/J5ed88Y/Gu/7m+zjbq05nee6kJfTGTffJVALAACgR2zpACMn33JSNtVyI17YUHk4ftQNZTIRAAAAAAAAAAAAAAAAAAAAAAAAAGD9eRm1fUmJyYvb6ku8HbBOJbOuXehMzVatVL5x/M3KivCi0XQhvbvcZ/ekNxWMslNUbFuJz/VQ7Rs61blbY9kh3QyjPLYIvb36zSIQKS53VY/zpqxS9c75LHNaDDHCDvCZf/zEFz7+S3/6YG7MR5zcgDFmWDfD2m/IufnPHv3guIBbMHnh5DOVoT1JrVz9awoNMryflXUTcm++Hd7Yvp7l/sTn/smTswIAAEBP2JIBRpl3HZcrn++6UvjJXHKkF2282fBToE0INgAAAAAAAAAAuLH+/n4lSaJ6vaaN0mq11O1majabyvOb/ZNabCcHDuxfNo52AgAAAAAAAAAAgK3KeauOS1Wp2Uq6yyYmNVbryJSUKL+JZSZyts+2zUii5FCpZus2EW7IymkomdRCMqA96TktuP5QBta0jD3JmBKTFctJlQm4kUbdTJUa7vPGmwe8MXtkTGK8X90+691MaLmNPHPfstZNC7hFlaE93XGdz+8yd34+tMW69/6H1vJ4LzMV2uWZ8PH4hjPJiVJ9qCUAAAD0jC0ZYNTN1c2cb8+2/WDXKSW/aBPMhmNRXQEAAAAAAAAAANzQwMCAyuWyRnePaKNMT8+o2Wiq0+kQTIPCgYMHlo2jnQAAAAAAAAAAAGCrcjLq+FSVuinbIVtWss4Xp09Naipas/Co3AwlzWR3WknuKPcJq2KN03AypWbapz35OfnsgObd4JqWsTs5p4ptF8sBVuPc9MDUodr05xOvrvH+w+GNxYa3ltJqHuutnQ/NdiIz5oXP/+MPTAi4RU8f/WiRvHb3Lz/zBef9aLj5o2t5vDGalzffUat77HNHP3hSAAAA6ClbKsAoy33WyNSa77i0lfuBcD+JB2KwCc4mEn/TDQAAAAAAAAAAVuEd73pUu3fv1lMf/pA2yje+8byOHzuuP3v2zzU5OSngp3/mby8bRzsBAAAAAAAAAADAVpX7xDfz1NerxphhY9a7J6AZsDElaS28qZpZM5wm6aPVAVuxVltIqt7oTDmcTOix2lf17dY71HB9arp+ZT657mMqpqmy7eiB6ovqt7MCVuvl/+7hrv7JSxcODyx827bcbxtr3u2ld1/vMUa+K+8z6/Ul+fzLn/v5D06anxewbhba/d8tp41daer+g/fukFfy3us/wrfDp+B4aLsvOtf+rWRkYVwAAADoOVsqwCiXcV3n8k7uy508prwSXrRpWmFdewEAAAAAAAAAANzQ8PCwdu/ZrXvuvUcb5fSpM5qemlaaJgKildob7QQAAAAAAAAAAABbVcwWymXlYy+68vr3ozPpGpdpjJM1XVOR7GBS0haTXCy3W802VVNTfXZBqcm02Gnv+tsisXkx71AypX47J2DVjPEvS52Dv/LnU9bqdBjzgNENErO8yYrepCY5kyb56wLW2dNHH5n/0V/9isl8ei400uEbtUm/+E9bxk1+9he/55QAAADQk3o+wMjJzLbCt9DpZl7vOlfq5D513pBctFkWzOLRrpYAAAAAAAAAAAAAbEO7du3ST//s3142/qUXX9b8/LyefeZZNRtNAQAAAAAAAAAAYPN4GWVKTXfBqT0tlfq97G3sDWgqJik9Vh0xpa3Zta/iwzpU77iv8m3tL53SF+Z+RBeyfXIxrOqqICNzcey7ql/TneXXVLfzAm7G1Bs6q4PJH42WO956a43175fs0IozG33eJfpMp9N56fP/6IPzxhgvYJ393j/80NyP/upX/m0rTz6UJvagvN8fGtr+q+fzcg1j9F2f6FfTtp8QAAAAelbPBRj58C2zGPrFUMyu88q99x3nlDuZnPCizdW9GGDkWe0AAAAAAAAAAODWzc2tzx9UNltNdbtdATtFDBmKyuXy5XF5nhcl7g+t5q1dkWTfvn3Lxp06eTqct+VvUQEAAAAAAAAAAG6PxdQQlxvlHa/SOp+28W4NCzTehSJTS2zv9UhcHXux9Iqyaavfeg0m02r4Ps3lQ8sCjMqmq4ptqW7nwrxzumlGaZ75qnFbdevhVj33G++Jf2DR/eF/+p8mlfqzYW9ohneB/nA6+K0T0N60wn7eDu1l0uTJ2VrSnSW8CBsphhh9/J/+2USeZ+PhI29A8d3KLH2rDu9boc0m8+HtcryWWq68BAAA0MN68AenDT+EfD7T8l0n78838iHh9jlvF0OMAAAAAAAAAAAA1sGXv/RlnTt7Trdq7NyYZmdn1Wjwt0nYGX78J/+q7rn3Hj3+7scuj5ubm9Orr7ymz332c/rcH39eN6tcKeuRRx9eNv7EiRPK80zG9NKfcgMAAAAAAAAAAOws7WmjeLqmVPeyJa0bv+CkbHXzmsTOmYqV3Z3Q12+dlEynKO+qPqOWr+tz839JDde3ZJ67yq/pbZVvaU96Vn325i8W5KX+JEmeVGLiVVFeE3YsPzbzrEZGnjcVv9vLPxLKA+F8cPHO4uXGjTefzHP3p5/9xSe/IWAzZObFPE1+KbH5Xw+fNkfCmLqu6PtujP/lvJtN/tEvfuDW/9gIAAAAG+q2BxiFHzg+/hMjmL3zPg+3c+9tJ3eJL34b47bKDQFGAAAAAAAAAABg3UxPTWt8bFy3anJySs1mQ3meCwAAAAAAAAAAAAC2K59JWVuxA946L9d7dYv+eze8mkWY0yo8f+z8Z2JXM3vj/mbeXewduNIp3SSUsAhj6bdWsWHjhnVbMwvyYUvEEKPE5KqYVjGuahoqma6A9TDe3usOGGXOd854Y6th1GHv/WDYG+eNMVN57k8Zl84I2CQTM2/4gaFDbaV2PHxmvBbKg+G9sGy8nwi327nTZO7MnAAAANDzbnuAkZHJvVG33fV5M/P5fCerdXKVw7GMinD7zYaDQG0OBAEAAAAAAAAAgPXxja8/rxe++YIAAAAAAAAAAAAAADfWnpGyllF+j9ZXUx3fdDEWqXbDeZ0vFYFELV+E7JjaDfqbxeCiLAw6PibyLJtsBsNCErOK6KTtb3c6VgwPl45p1g3rjc6DKpuW7gj3D5VPhHJSwHp57jfeE9Owuj/4/372t9M873fevifsiaUw7lVj9MJnf/H9vyVgE331136iGQbNH/6lZ78Uhme99b9gvHYbmS96Y+b+6Bef+JoAAACwJaS5Vzh84RNrTEmbJHd+wXuZzKmchWMWmfNJ13nTyb3Nnaz3wu3mLpYs/PzsCAAAAAAAAAAAAAAAAAAAAAAAAACwyVx2cdg1oXjZNNxZj+vVL4Slzee5VhNg5JWo7ZWf6krW5OpT2ybGq2rf6gnY9SYGF/mWDzX0xrd9WbHz4Ap908y0iQFG3u5OOqZkElMvXtWOti89o343q6l8j/rttA6VjmvQTgnYCHlXs1m13im3m98I+21d1n4z7L7nBNwmLV+fSTRzOnHl54zN55w33zTeLQgAAABbRuq8nzcyJWs0pE3ScX4yfHm0c2030s590szCwQj0lnhgKw8HgpqhtNbjiBYAAAAAAAAAAAAAAAAAAAAAAAAAYC1cx4Qi5a1Q2kYm8TLr0N3LTeUdN5F1w83V9CssqevVfb4pJcpMXzKlmvHJUJJfmsE3vVHujTuf9cvL+hv0GTRl+fTt1YbqNk2PlAe0wz1ce15NV9eMG9Gu5ILeVfuagI3y+Z9/YiIOf/hXv/pJ460ttcrPTms6E3CbfOEXHh0Lg7Ef+mfP/J6c3V9ulz5nZRoCAADAlpGOL+T9YWhSG8OPjZJw8CJNbCM1vlGyJv4nK5+YSBq80QIz5y9cvGly523mje06Xwu3y908hi37MI8Z8XIm3C95763Qe9oXg4u8AAAAAAAAAAAAAGxjnXZHX3r6y8vGnzxxUpOTk3IuFwAAAAAAAAAAAG6v7oKRLXslNelW8ovcTJ77pnNu1vX5hnNaK6dSeNwuteXzhr/c+8zn3sh5mdynfhVV9M74fDxv2l2+ok3QF0pZvaPlUrV9os/MPqTJrK7MW2WhhuNZv1JT0Z/Of1g2rGxrvJ7oO6H7Kuc1kHRiX08BN+2//eSj6iSPhl10f7hX/tLMhf1GuW3k7gn5sD//w9/phr3zW1L+Lc1pUr/+E/MCNtI/+uR98sn7QrsbkuzQl2fG96Uy/U2X3Z853w1tshPa5pnw4fIldTSvX/uJSQEAAKAnpXMdX403YnBRLJXUKHWuU07MgjE+SXLFBKMkfMFLU3vjQxu510L8CRyDifLw+7jjfNrKXDkLhzJamY/HIOLUPqG3ZWYxxIjjGQAAAAAAAAAAAMC21ul09Nqrry0bPz42rmazKZev/e/WAQAAAAAAAAAAsL5cR8rjBetjB71ENy2GF/lpl/tWVvZdb7VWXlaZrysLN9v5CpNXKZf3c3lXVbP2OtyEsoyq6h1ZWI0tX9a3mgf0WnuPOj4J6+5S/81Y04GwmZ1S43S4PFOUft+5tfQqoJscCm3ofWHvu0/G9C+47uL42K7MxcblY2fj0hlVuoQXYeMlpRHl7n0XQ7X2L+TZpSn3X/F+91qY71sqF+2VACMAAIAelV66kft4cMAr7/r4O6M/fK+rWmOKnxwm/OIIN8xqft2G5ey7dDsmJXvvTTikUQpLkCcMZ+tohDJjYyI2AAAAAAAAAAAAgG0sBhh98fNfXDa+1W4X4UVxOgAAAAAAAAAAAG6v9qwJ5268+g+FOyWtme96+ZZT/mbXu7OZ883be+n72HHR9NmyKuYmXs3Wd6ozrO+29ulcd1CzeUVuhb6bF/t2hvn2yHmj7xt8RQOmrbUy3veHFvAuZ+x3hJ3pE/+mqj19w2HHe5ec+VhoD7tC0yqvOK8xXs7tV7n8yXDvTwVshKNfTNWZfkRZ/iEZ+1cutsdrtcldyv3H5JOXw72TAgAAQE9Kr7zjLh1y8MX4dHne8aqOSawQRGwkwou2ltxKGXHMAAAAAAAAAAAAwHbX7XY1Pn5eAAAAAAAAAAAA6F0+k1znFvp7xQvdh2X4hpNfcLf9wvfeyNjUWCVmR3Zia7qyJvI+tXwaNkty3Xln8lox700zSsMKHzbOV4Wdqd6Xypaq8n5Yxu8PY2KDSleeOU43MzKO9oINdDxVPjwsa/fI67Cu/0kwf7HdEl4EAADQw1IBK1kI3/YnrJQTYgQAAAAAAAAAAAAAAAAAAAAAAAAAt1Nr0sgmksuNEvlVP843ncvfzNr5+SxxxzvlMOpS2ThGzqRmRla5KrZt+o2z/cnlyKTkQHpIZZva0WSfNon3/mJmU2/0l3u8froo766f0nRe0zde9Gp3ls5z+EAsRg9WxrS/NCfgpv36T8wrhsD8l//uV1TR//TBsS/901T5I6nrvl0X3w8yk7x2rn7of2wnpeeP777veanbELBRjv5UK/z7tP6rT76gWum3Hh//2o8NZPM/lrjsXiPff2m20313/le586df+5e/8NsCAABATyPACEv5K4a3OUUbAAAAAAAAAAAAAAAAAAAAAAAAAKCir5e/mL3jvWRWkcPjnZfPvFw7PDLXuvDx2ePzFylKxsmGmthQHRv+jRKzmBGUxjHGm7ISVa1VxbzVW82GGaw2mb/Yc870RoLRRVXTDSVV4sJqvKo/Xyms4qqJq5KOflgn+YKTr2Wp67pEziUuv9ylNLHK0yzreOMy+TDf2YXVJ6UBN2shfDpVTSfxWZa4zFmfy/i3ml7RJhO7Tp9gAAAA2EgEGGGpeCwjHOxQ+2IBAAAAAAAAAAAAAAAAAAAAAAAAANxWeWdx6MLQlaWkdOPH+BknN5nZ/IVmVevExCSgxLRNybRMfzJvRpKqrZvUDCYDYVxq9xZdFmM80ZB6SO6UxViMULOyesiD1fFieDKra/6q/nwPmI4e6+sKWDf/4q/Nhn9nD/74j03GoRZ7lF7S3Ns497IynX7l139xVsBm+I2fmAn/ztz74z/2PhPbpA8t8Iq3wtHW+ZfzTNOvCAAAAL2OACMsFX9udrT0ZycAAAAAAAAAAAAAAAAAAAAAAAAA4LaLQUa2c/0AI+98MXTjWcsvuCTcXEXc0XWUTMOkxpgBW1McVk1iyrZkKqauukq2bBNTtfKJeo4Pq8Irrg9j5LyRNdp5jA1roexNL24hAAAAAMB2QIARluqGAzCtUHIBAAAAAAAAAAAAAAAAAAAAAAAAAHpI1ohxNEalPn/tmWLfsDA5+257Xq4ILxrSLbD9dkZV69N7yzVVjEn2pOUwOpb+K+frxWigPMYXhXVhZdIdmV0UeW+NMXXjzK0FWQEAAAAAcA0EGGGpLByFaZjFIQAAAAAAAAAAAAAAAAAAAAAAAACgZ+QtI5v6687j3uw2fea97/q6nKzWqmw6tmI7ZjSpmbJJzFDSr9TIDIZFJVur31kn961OrqxqfV/dmJ3Zac7YcmgV+4xdGjgFAAAAAMB6IcAIS3VDaVoCjAAAAAAAAAAAAAAAAAAAAAAAAACgx2RtyZRi369rhxhlb2ZNNZ1T1+/WTSjCiwbtQnJ3qWz7k8TU7MBNxCD1hHau9kLHt2o1U+szJtGO5MteZr/zngAjAAAAAMCGIMAIS+Xh4FU7FCcAAAAAAAAAAIAtKUkSlctl7du/ryiDA4MqldLidqlUKuZpt9s6P35ezWZTjVCOvXFc42NjglSr1VQP5dDhQxrdPao9e/eoUqkU4/M81xuvv6GZ6RmdOH6iWHdxHa6Xu+6+q9hOe/fE5yxrZHRUzjtNT06p2Wjq1OnTGjs3prGxcW2mq9fJ4OBA0ZZi/bz3arVaRf0mJiZC/cZDOaeZuTll3a52sq2yL/bV66pWq7r3vnvV19+nw3ccVrz2brVa0/z8vM6+eZbtCgAAAAAAAAAAekbeluw1egX6OZe5psv8RNbvW34tV7j3pmpmzaAtJYfKddNva7bfllUzJSVhMVswvMj5xYinTubqza6v5VUlWssaAQAAAAAAq0aAEZZyIrwIAAAAAAAAAABsacYaJWmivr4+jY6OamRkpAjDuevuu4vwlKjRaChNU83NzRcBJWdOnxEWFaEzlYpGRke0d9/eIrSnXq+rv79fnU6nWF/O+2Kedri/ngYHB4ttduDggfCcNe0/cKAITToftuXc3JzmwnPH8KTNdvU6udSmYv1iwFJjoaGZmZmi3cUgnqmpKdlQ151uq+yLaalUbN9do7s0PDysI3cdkTGmqHcMpYptkO0KAAAAAAAAAAB6hc8Xy0pc1zm1vfNdX1G2hgAjY5ys6Zp6mthdiUyfTWLRNpB5lXIvAAAAAACwgQgwwlLx4FUrlEwAAAAAAAAAAABbSrVa0Tve+Q7dd9+9+sj3fkS1Wk21eq0IIrHWFiEpV3rs8XfJOSfvfRFSMj83r3/7//9fi4Cc48eO62b85b/yl/V/+is/tmz8b/3vn9T42Li+9uyfaS0+9NQH9cFQDh8+VASrXPLiiy/pjdfe0Kc++dvXfXy5XNb9D9ynhx95SD/yoz+ybPq//P/9hsbGxvTqK69p/4H9+vD3PKW3Pfig3v72txXrK4bPJDaRTWyxHqO4rDzLlWWZnnvuG3ruz58rytzsnNYqBgPF7fbQw6F+f+njOnDgoHaNDIftFZ4zht8ki38THQNkohigdOHCBV04f0FfevpP9Pprr+v06TPKul1thD179+iJJ9+nRx59RO94x6OX10lsT3F9XKpfbEMud8pdfnndfPlLf6LJyUn9hz/8TNG2VuPjP/oXdWD/AX34I08tm1YN7TmuqysNDAwU2+Pe0Ob/xk/99RWX+cbrb+iTv/WpImDp9KmVw4H27d+n/88//2fLxv/xZz9XvIYvfP5pNRYWtFq3c1+MQVtH7rpTTz31oWLfudqv/NKvFkFJJ46f1JEjd+qJ9z+hd7/n3brjjsOXt2+pVCrmjfWNbe/JMM+l7frvf/f3i33m2WeeVbPRFAAAAAAAAAAAwGbrzIbzU1ddwN7HhJ4wzh3vyJ3uGt/2Wm16UbK/dF4Vk6QPVUZUCqdIKlZaffRRz2rnvtXM1A6neWrhblkAAAAAAGDDEGCEpeLBqzwcYSJVGgAAAAAAAAAAbCGVSiWUqvbv36d9+/Zpz549RXhPqVwqQlGiGH5zSQyeidOjGFIS5+nr69P+8NhatVqE4kRrDcbp7+8rwmCuFpcdy1pVQ1127dql3bt3a3T36OXxZ868qV0ju1a1jLhuhoaGVqxXrVYtnmN0dCTMM1jMs3fvHu3es/u6y7skzhvXeX94be1We8k6Xo1ypazB8Lyjo6PFdhvdPVIE0FxLvV4vtlUMVdq7b6/mZmeLMJmNMDg4UJRinYTnunKdxCCb6FKwUgy+sWVbhPNccujwoaL9DQ4MyIY2NruKgKfYRur99RW31bUstv1Ksf1WsrCwUEy/FLZ0LSs9Z2xj7XZba7ER+6IL6zkGHK2lDoMX2/PVqqHNx+01PzoftumeYp49N2jzV7rjzsOKWV6xzjHUaK1tHgAAAAAAAAAA4Fb5LJxTya4eF06ydLx3TSfX8nZVC0q0eAKmz8pUjEw9XsUjnLNJtkF6URCvn5GHk0y5p6fcJeF8nDl69COp9BF39OjR1Z+AAwBsWf7oXdUwqGqj7FkovpWYv3N+dVf3AgAA2xYBRliqHQ4wzYWSCwAAAAAAAAAAYMt44sn3aWh4SH/3//53l01rNVtF0Mwbbxy7HDxTq9V0xx2HixCSGKITA36i/8d/818Xw7/zM39P3W5Xx48d13YW18Phw4f1Mz/3f1u8HdbJWjz2+LuKEoOe4vp98VsvrSnQJQYn/dUf/ytFHe6+5+5VPSYGOsVy4OCB8LyZfuWXflVTU9NaT4ODg/qbf+sTGgn1e/L9Ty6bfu7sOTWbTc3NzRehOzG4amBwQPv37788T2yTUZw2dm5M//p/+U3tBBuxLzYaDZ25GCp2q/rqfUVg0U//zN9ets1W4wf/wg8Uw/Pj4xobGy/aPAAAAAAAAAAAwGbKmkYmWZrJ485mzfyNTsPPuH45VVcTQZSMJvOq2Kz83toebUNt58x0y1nnfYxlEooAo8EnjlQPzzWevhDuEjQBADtBvf6gcv2YNsps/ZxifOJR/bY5SogRAAA7GQFGWMpfLAAAAAAAAAAAAFuAjRcBNUaHDx8qQlOuFANmmo2m3nzzzXC7pdOnThfhKVG1UtX8/Lz27t2jvfv2qpSWlJbeOnV25Mid6mbbP8BoeHg4/pVqESITX//c3JwWFhpqLCwUQUTt9lthRAMD/cXwyF1HinUe1/0lMRCm3e3o1VdeW3WAUQysqVXrRUhQDJK50tzsXBEgdSpss0ussSqV06KusZRKJVWr1SKAJgYOrZe+vr4iRCfW6+rlzs7Majaso9dffz20n4WifcV6VWoVjYyMFLf7+vuKZVwSX1u30y2WF19TfG3XMj42rizL9c3nX1g27eDBA6rWqmE7vLWu4rzNZqMIcJqanFpxmbH9x+3aCHXdSBu5L05NTa1bgFFsq6Ojo4ttPl3a5huhnnn21pVeYpuPbWzf/n2XX9/l5ezZG+pZIsAIAAAAAAAAAABsOu9CyS/d9uGkURh2vfUdXwr3kxsuwMrJKFefTWyf1Ua6VL9lYi1jrJBd/2Ah72P3OC/nwjoJz2TjqU1PhFHB+9R2XLVUp18pAOwYnU5VSekubRgX/6CiocE9Zem8AADAzsUPTSwVw4tyDscAAAAAAAAAAICtoVKpKEkT/dWf+KtLwkWiGJLy6iuv6g//4D/o7NlzWphfkPeLV3JIkkS1ek3f/wPfpx/4we8vAkoGS2+F1fxfP/HXdOH8BX3pi1/WdvbBpz64GDpzx+EiyCUGEL304ktFOXH8hCYmJi/P+/i7HyuCaf7e3/+7RfBLDNO55MMf+XARXPTVr3w1LGd1zx1DZA7fcUhPvv/JZdNeeuklTYbn/v/+8//h8rgYeBQfc/8D94Vyv973xPt09z279BP/2Y9fDsNZDw8/8lDRHlaq1zPPPKuXX/q2nvnqM0X9rnT//feH9fBUePzDeuTRhy+Pf8973qPZ2Vm9/PJ3wvqc0LNfffaaz/3FLzxdDD/9qU8vm/bTP/O3dc+99xTb4ZIYXhS32ec++zl97o8/r9tpI/fFb4d199yff13r4Xu/76NFeFFs83F7xPX3tWe/VoSVvfLdV4swpSi2t7gd3/HOd+hH/9KPFPfLlfLl5Xz8L/1FjZ0b0x995rMCAAAAAAAAAADYTHlbsqWLd2J40XQuP5lXw7C6msebil0wFdNOH6gM2V1pSRupE+o3u/xcnhm04USRiWFK6y6GF3XCU2bOlJ335cFw7qoanmtjo5q2hrDG+611+8sNTQsAsDMk6YPhA+BvaKN4+3z46J0J30l+UwAAYEcjwAiL4t8HxzRrR3gRAAAAAAAAAADYOmLYSV9fXxEucik0xTmnrJsVoSlff+4bmpqcUqfdWfK4OE8c98brx/Tlp/+kCJ4ZHHwrNKW/v1/dbrcIypmdmdHY2Li2o+Fdw8XrfPFbL10O1xkfP6/z4+NqNJtL5j375lnNz83rxRdf0p49u3XvffdenhYDYeI22DU6oizPNT114793jUFEhw8fXjKu1WoV9fnWCy/q1MlTS6bFkKIYsnTi+MkwnFee5WGek3rgwQeK514vDz/6sPbt27dk3PT0jGamp/X6a68XQTzNRnPZ4yYnJ4r21j/QryN33al6vV6E80SltFS83tqpqp7V9rSR++JoaFfrtS+OhGXF54tt/vTp03rh+Rd05vSZsI2nixCuS2J7i20+1iW2+cOHDxWhR5fE7TswMFAsrxte49zsrAAAAAAAAAAAADaND+dZOl5+IXfuZLfjZ/LYTzC9/kO8D+dxcrsvLdmRJDFVu66ZPn7OZT7z3k/mbeNl8pbrUzc8a8cvm9dUwvmk1PjkUCkzaajVgF23fo7OK2/nvpk5H08ilm04dxUX3mu95nJnQl2Nzs3U1O6msuHcYqWytJYz7bJeG3Ma7W+pv9pVap0M3f9wC37u5/6L+5Sn97Wa8/eGvXNfOGGbXN5DjR0ppeWPGatnfu7nPtGqVHbN/Nqv/VpTwAb6mZ/564esrz3abi+8yzm3z3tX1hUfG6VS9WPhnf10aJPnsqzc/I3f+I0ZAQAAoCcRYIRFLpTMLA4BAAAAAAAAAAC2iBiaMjo6qnLlrQCbGGwTg0hOnz6jr3/9G0XYTAwjuZL3vpjnjdff0Pnx80UITgxIuSQGk8R54rgYcrJdA4x27dqlhYUFvfTi00VYy+f++PPXnPfs2XOanZ0L876k+++/f0mAUQxziUZHRtTtdFcZYHS/9uzds2RcDDBqNpv61gvf0ne+/d0l0+I2nJ+fL8qJEyfUCPWO2/++++9Tpa+i9fLIIw8Xy71SDC86ceKkXn/tjSLAaCUTE5NFieFF8+9+rAjyuRRglJZSPXBF+9qONnJfHN29e932xVjH8bCM2I7jtvzyl/5kxfmKAKPQ5ivVWjFv3J5XBhjFYKV2u10sr9FoEGAEAAAAAAAAAAA2lw//d0KZl8tPdNp+8RTMdfsKGmOcjDKzOykld5aT9e5Z6OZc7pvO5a+0F+R8Eu73XfcBZSNTs1koNlnPACP5vJ35hXwxAKMcz9ilPZj6E8OLurnV6cl+zTQqMiWnSrJ0ntmW0WtjRon1qpTyYmjkBdy0PL3PGn2sXK3cF07V7g8nbC+3uvAeMZJY+7HQNFvh3vHZ2dl4BRgCjLDB6oes8R8rV6rvdM7tN96Xr3yXS5PkY+H+d0Kb/EpojpNhFAFGAAAAPYoAIyyK3+jboWQCAAAAAAAAAADYMo4cuVOHDh1aMm5ufl5vnnlTFy5MFIE4zl37Cg6tdmsxqOTNszp+7ITuuPPw5dCZOIxhNM1mQ9vVyy+9rKmpKX3p6S8XITI3EtfV8eMnNDIysuL0GPCSlkphXR6/4bLuuutIEQJzpbFzYzp79mzYbu0bPv7c2Jimp6f17z79u6rVa/qbf+undCviayqVUg0ND2twcHDJtNiWvvud72pm+sZ/BxfnORHaUnxtlcpisFJiE+3dt7dY18NDQ2qGdhnDb7aTjdwXa7Xquu2L33z+m6FOZ4s2H8OwbmR+fq5o83ffc/eyaUmSFvWKwVVnTp8RAAAAAAAAAADAZvG5fPtU3lYjsyb3NeOV3CjWxg4k3u5PXLIrzJoWYSW6pTo4H9OC5MaylpvMMzeVV9T2iW+4QR9zdm7AOO/zk52uGU2T5GC6blcs8d74VjjxlHk59bBGO9VMs6R2J1U3s7Jxe1wVYBRXYzeTZhulcM6xokO7wvmy3stiwhbwiU98olput/sT6x8Mu+5T1ia7vff1uMNc8V5QMzJ3ePknbGho1cT9Xhg3KWADHP3IR9ILDzxwX/hAe0/4QPoBa238Q5R6aI32yvlimwxNNP65wYesrbwcRp0UAAAAehIBRlgUj1DlRgQwAwAAAAAAAACArWR4eFj79u9bMq7b6WhyclIL8/PKute/ekMWpscSQ2fiYw4ePLAkwGh0dFQD/QParsbGxorQoNdefW1V8+d5psmJySKYZiVDw0NFUM1qjIyOqFarLRk3HbbD2LnxVS0jbrMYJ/TCN18oQpNuNcAohiDV63X19dVVrVaXTIttKa6n1dSr2WwWbenKQCibWA0NDWlgcDA8T11Znm+7AKOtsi/GoKHTp06vus23O+2izcfterVL9cqzXAAAAAAAAAAAAJvKyWeTLjct71On2mq6hJmKkd1TkqlaGbtOKTgxwGgi77o3u203l1eUF/0VV9Vn0cdTLJPhxFlq1jWSx4eVkTnjne/tjnKdzGq+VVYnt3I+bJtrbJOYE9XspiqFeZ1rKrF0AMTa1RcW0vLoaH/m3QEZ3W9lazL+6n01nqAdsd7cZZxvhxPdXxawQY7fdVfab+3+8C53R2iTD8V3wMTalWYdkVcjfHLd540lUAsAAKCHEWAEAAAAAAAAAACATXPvvXcXIThrcX7svNqdjmZmZlZY3j166JGHloybn5/XsTeOaWpqWqt1+vQZVWtV3f/A/SpXysW4crmshx9+SBMXtu/fP73w/As6d25s1fN3u5mOHTterPdbddfddy0bNzc7p/Hx88q6Xa3WqbDt1kN8TTFUqVxefnHXWKcXX3xJC/MLN1xObHdvhHX0rscfWzatEtrUnr175FxetNPtZCP3xYGBgXXbF5999muaD+1stRbmFnSscVzTa3gNAAAAAAAAAAAAG813vc3OdOtJTBC6kUQdW7czdjSt2APpgBLdkvDc8g0ndyHr5q92mr7pKr7r+rw365tEdJOc95WO8/u899aoF2q0spH+tobrHeUa1Fynok5WltfS8I7UdpXYXEdGp7S7PqtSuortfT3GHJY3T6aV8oVw75ywY+x9+OHG008/ffr973zn72SJOZmWSv/PsHfctXQuP++9TnZd9r83GnP/W6ORXxCwQX7zN3+z9YlPfOKZ0cHanDHl6bSUfL9Nku+/er7wXv6yd/6581PT//3g4GBTAAAA6FkEGAEAAAAAAAAAAGDTJEmiSqWytsekqZI8X3GaXWF5zjllWVYMVysPy+90OsvGx2WnyS3+BW8Pa7Vaarfba3pMDBday7q9llKptGyc867YFmu5Gupawo6u53pt81L7yFfxuov2182KkKKVpGkiu/JVA7e0rbIvtltttdbQ5mPdLxUAAAAAAAAAAIBeYrKL6TyrOfVkjVMqb9J1yhhyRZCR9wvhzF7ujZyxPRUV5JX2cnhRlFhflDQJJay9LJwL835pneN5xdQ6lcJ8txxepCIIJA0tp2qcp1/pDnP06NHYgNwH3vOehVKiCWtNQyvsI6GNdEtK58rl/ML58wsNARsohhj9g3/wD2YT5yZsmjSsWblNhqba+Vf/6l9t36uPAQAAbBP80AQAAAAAAAAAAMCm+emf/Wmt1b/6n/+1xsfG9cUvPH153L79+zQ4OKh6vbZs/tmZWb36yquanJjQrYh/DNo/0K9KbW2BS7i+Rx55WOVKecVpM9PTOnf2rDrtjjbb6OiIDhzYv2JITgzUmZ+bX9Vy5ufmrvkaarW67n/gfrXDtLNnt8cFTTdjX4zhUuyLAAAAAAAAAAAAN8cOJOXS47V9pnprgT4xsCh/vdPWQu67r3e8vJJQhnSzSsak76xVTW19rv4Rr5HSzLza2dLxaXjZlR7OMqqGyuU2lE4pvIalq6KSeFXSXEna22FM2DrK/Uk48Z2ekzedFUK+YizadNiVpn/5n/3mtIBN0NenufBO+Jq8nVzxna5ok351f7ABAACA24oAIyyKF7GNB2ccBzMAAAAAAAAAAEDvi1ddi6EmWqcLhHazrhqNhpxbftXKIjylv1+dbue2BOtsNzaxi9tuBd1uds3tsNFmZ+c0MTGhEydPqlwqLZk2NTW16uXEumdZHq8CqJ2AfREAAAAAAAAAAOD28BfLdSXqKDVWJZPqJkJwfOYXn6ThMt/yuZvLrVrhRJg3ofhEN6tmvK0neRFeVNG6dWhz3rvc+7i8y8uMlYxn/9YlJQkAAAAAAKyIACMsysMxmUY4DNMVAAAAAAAAAABAzyuXy6rXa0rW52KcmrwwUfwFq3P5smnDQ0N64G336+ybZ3X27Dnh1lSr1aKsZGJiUqdPn1G73dZme+mll3Xs2HG9+MKLMle1q7jtV6ubZWo2m7clhOl2uB374onjJzTRnhQAAAAAAAAAAMBOtRheZIpyPbY/mbKDtmR3JSO6medphnNeWTgH9o3mtMJtN+d2ax2kD1Tbps8qOZhWtU5iolLm1c4Xs4oql8bXrdGuxK7X9TgAAAAAAMAKCDDCW+LfUO+MC8ECAAAAAAAAAIDb5MTxk+p0Omt6zMzMTBEIc6UkTZSmqcwKf5DrvAvPke2YAJmtJoYX1eq1FafleaZupyvvN/+k1cLCgrJuV+12S+aqv15uXNX+rqfdams2tNl8h7Q/9kUAAAAAAAAAAIDbwYRzMWbZea2r2b1J1fQniVbLefl4nYm26/qGz/KprKpueLKmL2ttp3mvrm4eix1NSyqFWg/axFbW5wIZVzyJC+enmuEUVVlXBBjhCkb93vn9puTXLTgKALaL7//w9z/qfFIzSXZToX+96ndOzD7yxJ7WvG5ROfGdoZJbSIzqifWjb03xJ8MXkvNKb+mbAgAA2AYIMMKi+DfgeThg5YiSBgAAAAAAAAAAG+fFF1/UubPn1vSY8bFxzc3NLRlXSktFEI5Nlv9Ra567IoSmm2VC7xkcGlRfX9+K07JuFrZdW7fD9NS01kMMQoolBhntBOyLAAAAAAAAAAAAt0em5IYXs0/uqQytpQdhEV7U8XJjeTt/s7uQX8gStX0MBBrUrTCma8KS0nvK1gwnqR2yJdl17sfmve/mmsu9j+FF/cIyxmu3jB40uR8WAGAJkyR/OXyyjoRPz3dpG/mT8b5+azWhW9SfuoXHRtuv1xN/uHZlgJHRy+Ez+LuavUCAEQAAO1zaX17vpGJsRa4bDlolMcZaygUAAAAAAAAAALAxXvrWS3rttdfX9JjZmVnl+dIzGLV6TUPDQ0rS5RcLbTYaOnfunDpt/i4G2GjsiwAAAAAAAAAAALeBDf8PJDIlKekvLZtshhInY7yp2zDTKpbnvXezLlPXyzec8V1Xtn3hsUkpUe510xKTm5LJVDfW9Nma2ZVYU7Ux0EjrzhhTTUw9t0r9FS/aJkbtcCprPIwqmVt4LRukEcq1zqbFy4TEVzIlr9Y61N2FFuES7T7vzZN/99/8YFXYcebm39hru/W9fbMH++WvSjczvpzb7u6sOvt4aB/rcwUg4AZmW68OJ82hw9XGnjvTbm3Z9Nx2dvuk/UBokz+mDXbsd/L3+lxDnWZyv7aRE3Np+tm8/5bf88v1Ut8zpUH/YG1+6D2Vycvj/+e5+596sTt03yvdoUfv/Ln0qo80Jxu+jyQmc1bOLZnkjcmV2pZKpZarVAQAa2DCF9s4nPWDtxa0CmA9PZ9W0w34sY8tJ4+/NW38vkeAEQAAAAAAAAAA2Djj4+d1/Nhx3apyuaJ6va4kWR6a0s0yzc3OCcDGY18EAAAAAAAAAAC4DUz4v2Zky1Z21/LzNGZ/6k1ivKmsru+gj5ECLe9cyxkthDteicqmbMu31vfQpMaranIzlJTsYFKK/de0Qd0ZjbxJE1MOz5gsSWmwRnkoc+F5e7ErZes6/fliZFEMMVoI83TXoe55DKiR+hes7rNyws7jSt1ho86wt3m/yZcGGHn58Ibi+l3avjO0j3cJ2AQ+zfp9qbPb2+6ItDzAKLZJn2Qjm9EmbcXc7drqD2+3+7WNzGeJXptNdKuSrFI+vXvUySTVe0rNy+Nf6g7f+c3OyJ5w8x3L8wnDp7LxMVcwfowt+eDx4WtKmFIyTvHbSp8AYA3MxWSM8AazWwB6g9GRdKjcg7+6sem68atf+P7pwrfDrgAAAAAAAAAAAHCJTaxqtZrStCTgRtJSSaU0VZJYYX1d2heTNBUAAAAAAAAAAMCOFgOMhhPZPqvkyArnpSpmTSer4txmly1ZF244Ly9jivScW62mlfXGVEwaarzRp8+MMdXE93lZU0veqrwN66odhmfNOrygDRDPQtuL5eqennkMLgrDhbAx8nXYIGEJ/d6o2vH6qIz/oLDjONtNTZKkzuYjdllyliuH6fvypB3ahnungE2QKw9tspO6pNO/0vSiTZY6u8KtfdpgpXqyvxs/NOaFFbRNOZ3WnuFhlyavdN4KMDrVHd07no1eI4vPF8XELxe6+oO4+NSzLnxb8DL8kQ2AtfEiJAXoQWkpYd+EiiMxSSiW5gAAAAAAAAAAALBEYhMlSSLLiRSsgjXhvFsar1xHe1lvl/ZFw7oFAAAAAAAAAAA7XTh3acqxhLNSfSv2+V/bCRUTTnKVjbm5B1/Xpp1ljZlOiTXp5XtXcKE01Jv6QlVToxXznWK9XZjWikFG67Mi06IYHeR85s5kzMUMkRUCvXyMGTO+6q2repndAjbBpTYZ2t01ZghtUkWbHNQGM0l4LyZG55qcN7bly+V5X1Ysl4Rxla7nQlQAAGDxBycAAAAAAAAAAACAa6hUK9qzd48unL8g4GoxUGd0ZET7DuzX2x96UHffc4/uvfduje4eFdbXpX3xxPGTAgAAAAAAAAAAAAAAAAAAQG8gwAgAAAAAAAAAAAC4Dmut0jSV4TJr6yIG/sSylV2qf19fvbi9b/8+7du3rxju3j2qoaEh1Wt1YX29tS9yNVgAAAAAAAAAAAAAAIDN4mWUeaO2TzTnSgIAALgaAUYAAAAAAAAAAAAANs3o6IgGBwe1lQ0PDalcqegn/7MfV61W00e/76OXp51986yOHTuu+x+4TwMDAwIAAAAAAAAAAAAAAAC2so4SvZn3a86Vw7Dv8vg3sz4BAABEBBhhkQn/J4tDAAAAAAAAAACAnaabZWo0GsrzXNhYaVpSuVzWVmKMkbW2CCuq1Wu6++671NfXp5HRkWJcbDfdTldT09M6efKUToVyxx2HCTC6CeyLAAAAAAAAAAAAq2NLPhQBAABsOB9K5o06sppzb30ByemYDgAALiLACAVjQ2OoiYNWAAAAAAAAAABgR5qYmNTs7Kxc7oSNtWtkl3bt2qWtpFQqqVwp6x3vfEcRTPTDH/8hHThwoJjmnFNjoaFjx47pa8/+mV781kt66cWXdP8D92vP3j3C2rAvAgAAAAAAAAAA3JhNvKojYVj2AgAA2GjOGzV8qSjnXV0AAABXI8AIBWMupm4nJF0CAAAAAAAAAAAAUQwtGh0Z0ZG7jujOu+7UkSNHNDo6qv7+/mL6xMSEWq2WvvbMn2ns3Ji++91XdH58XAAAAAAAAAAAAACwGtMTF+Tmp9WZdPL50mlpn1FSNyqVmrI1Abcs72bKWk3NvHkstLtkyTSTeiV9Xun+ltJ+AZvCZbnazabmL5xT99zEsunpkJPtz1QeEQAAAHocAUZYZMOPy7KRSWLqNiFGAAAAAAAAAAAAQLlU1oGDB/TYux/Tk+9/QkNDQ6rX37qK3OTEpGZnZ/W5P/68ZmdmNDZGeBEAAAAAAAAAAACA1YsBRu1Jp8lT03KZWzKtPlxTfVdNu/aU1EdXUKyDLMuUNbs6++ZZtaa6S6YlJRvaXFVD/RUNqSJgM+R5rm4z09T5CU2dWFg2fWBPXZWRRPvu7xMAAAB6G79aAQAAAAAAAAAAsOMNDg5ocGhANrHCxmq322q1WuplpVKqtz/8kPbv26+Pfu/3aM/ePUV4UaWy+EeaJ46fDK+hqd/+1KeL13Lu3Dll3Uy4deyLAAAAAAAAAAAA2EmarQU1F7pqN5vKrwowMhUnX+5qIBsUXUGxHpzLleW5mrNNNabaS6Yl1XCOtpSr3o3nagkwwubw3oU2manVbGlhanmAUVL3MvXYHgkwAgAA6HX8agUAAAAAAAAAAMCOV6/VNDQ4pCRJhI1VXNEx6+2wnzQt6fDhw6Ec0rvf++5l06enpzUzM6Pn/vzrcs6psdAQ1gf7IgAAAAAAAAAAAHaSrNtVp9NSt9uRy/ySaZ2OZDtOLie4A+vDh/+cz9UNjavT7CyZljir8oBV3uPn87G9XGqTWae7rE1G3U4a3h+NAAAA0PsIMAIAAAAAAAAAAACwaU6fOqOpySl9+HueUi964v1PaN++ffrrn/hry6a9/NLLGhsb07/79L/XubNntTC/IAAAAAAAAAAAAAAAAAAAAGAnI8AIAAAAAAAAAAAAwKbJsm4ovXvFxnqtrnq9rsHBwWXTsm6mZqOp+fk5TU/PCAAAAAAAAAAAAAAAAAAAANjpCDBCwYaWUBnxSt40AgAAAAAAAAAAwFtiYM3ZN89qfm5O2L4OHT5UBBf99M/+LY2Oji6ZNjExocmJSX3qU5/Ws199Vrg9Lu2LcQgAAAAAAAAAALCTmUSq7/cCAAAAAADoBQQY4S1kFwEAAAAAAAAAACzjvFOe58UQ29euXbs0ODSocrm8bNr09IxOHD+hmTDE7XNpX/TsiwAAAAAAAAAAAAAAAAAAAD2DACMUjJWSUGwiAAAAAAAAAAAAXCHPcjWbTWXdTNi+Hnv8XTpy1xGVSqVl0154/gX97u/8e01PTwu3z6V9MYYYAQAAAAAAAAAAAAAAAAAAoDdYAVcKLcLEWCsjAAAAAAAAAACAntXptNVoNOSdXzatXC5rZGREtXpNwGqNjo5q3769StO3rgHTarU0dm5M01PTRXsjOGc59kUAAAAAAAAAAIDNZUpetiQAAAAAAICeQYARlrCJlFbCgaxEAAAAAAAAAAAAPavZaGpmekbdbnfZtIH+ft119xENDw0JWK1Dhw/pbQ++bVmA0Xe/+4rOnDmjmZkZdTodYSn2RQAAAAAAAAAAgM1Vqksp148AAAAAAAA9JBVwBZt6JVUvl0l5ZgQAAAAAAAAAANCLulm3CJdxzglby+zMrLqd7orT0lKqSqVSBAV577UZ+vr61N/fp1Jp+anTdrujsXNjWlhYEFbGvggAAAAAAAAAALC54oXrLb0CAQAAAABAD+FQBZYwdvEAliG7CAAAAAAAAAAA9LA8y5Vl2aaF3GD9xLCba0mSVKVyqdi2eZ5rM1SqFQ0ODalUKi2b5nKn2dnZUOe2sDL2RQAAAAAAAAAAgM0V+3/FAgAAAAAA0Cs4VIElbEUqDXqZsgAAAAAAAAAAAHpWp9tVo9FU7paH3NjEqlarKU1Lq17e8K5dOnT40IqPmZuf1yvffVUTE5PCrWu32mo2mytO27VrSIfvOFSECm2WUpqqHtqLtctPnbY7LZ0+dboIMcLKbse+OD09IwAAAAAAAAAAgJ2qMuRVHubiEgAAAAAAoHekAq4Q07dtaBXGCAAAAAAAAAAAoGc555TnubTC3+UmNlGSJLJ29Sc8KpWK6vX6itM6nY7m5+eF9RG3W7HtVlBsh1pddhMvGRuDi5I0CefHlrcXl7sibCnrdoWVsS8CAAAAAAAAAABsrqQcznGt/voRAAAAAAAAG44AIywRD2CV+hdDjAAAAAAAAAAAAHrV2LmxojQazWXTavWaDhw8oImJSa1WpVpRf3//kqCVGMzSWGio3WzrVt3/wP0ql8uC9OKLL11z2tDwsPYfOKDjx09IWzSnZmR0RKOjo6qHdrgTbMa+GAOSmmH567EvAgAAAAAAAAAAbHVpXSrVBQAAAAAA0DM279Kl2BLihWWN9TKrvwgqAAAAAAAAAADAbZNl3VCyJeOSJCnCgtIwXK1Lj7lau91WludarSzLFx+TLX2MCSdf1nL6xVqrtFQKJVWapkX9tpu43WJI1JWssWt+rTEkp3YLYUHe+2X1uORSu1hNnYptHEoM4BkcHNBOs5H7YgwwWuu+CAAAAAAAAAAAsG3FE4/GCwAAAAAAoFcQYIQlkqpXZSg0DC4ADAAAAAAAAAAAtoBz58Z07I1jS8YNDQ/p4Uce1p69e1a7GN1xxyE98ujDqlQql8d1Oh299NLLOnP69KqXc358XC+9+LJmpqeXjO/r61O1tvqQnRiCc/fdd4Vyt+6552719/dru4nb7c0zby4ZNzA4oL1hu60UJnUtTz75pD76vR/Vzep0u1pYaBQhOVerhW222Jb23nA5SZqor79PTzzxPv3Nv/VTOnT4kHaSjdwXG43GmvdFAAAAAAAAAACA7Sqt+VAEAAAAAADQMwgwwhImlZJwEMtsv4v4AgAAAAAAAACAbWjiwgWdO3duybgYfjMyMqLBwcEigMYYc83H1+q1Yt6h4eEiPMfat06fxUCbyYlJzc3PabXa7bZmZmaUZdmS8fE5hoeGivpcL5wnPv/A0IAO7N+vd7zzUR08eFBpmspYo+1mYmJC83PzS8bF9RSDf2q1qtJSet3Hj4wuzvu2tz+ghx5+u25Wu9XWbNhm7XZH3W5X3r91tdrYPuJz7BoZLuqzUluK4+J23bdvn979nsd19z13FW3JO79seUlqF9vADV7bSubn54u2daVyuVKss77+/mvWb7Ns5L4Yw8TWui8CAAAAAAAAAABsV0klFi8AAAAAAIBesfa/jMW2llYXS7L6i9oCAAAAAAAAAADcNmdOv6luN9NTH37q8riBgYGi7Nu/T8PDw0VQTgxAWUkMFTpw8IAOHTqo/fv3L5kWA4yOHz8RHj+p1ZqfX9D42LjuuuuuJePvuvuImq1mUZ9Go3HN+iSJ1f59+3Xkrjv1oz/2I+rv71e1VtV2dOL4STX2NvXgQw9eHnfHnYd14MB+/Yc//IzOn7+g+e78NR9/+PBhHb7jsL7/B75fg4MDulkLCwtFiWFKMcwo7X/rFGq9Xte73vVOHXvjmKrVqlphetbtLnl8DNqJ2/WRRx4J2+zjRbDS6Oiomo3msuWlSRrmHVKluvZtOj01XYQAXalSKRdta/fu0WvWb7Ns5L7Y6XTXvC8CAAAAAAAAAABsV+VBqdQvAAAAAACAnkGAEVZkS15JVXJtI08gNwAAAAAAAAAA6FGnT5/W9MyMOu2OjDEqlUuXpx2564g+/D1P6U/+5Cu6cP6Cut1uOO+xeOIjSZIiDCbO8/AjDxeBM1eam5vT9PS0Xn3lVc2G5a/W/Py8zp49q2azuWza8NBwUZ9Y528+/4Ja7cWwmViPWJ9YlxhC874n3quh4SGVy+UiRCnWJc6Tptvr1F5ct3G7XSm+Rmus3va2B1QPr/mZrz5bbLO47dJSqsHBQe3duzeUPXrokYd08OBBNRoLYXpn2TZcq2PHjklGeuyxd6lSrRTjYpuK2+HBtz+oH/74D+nk8ZNFiE7cbs45jYTnjNMfefThoi4xvCgGF7068erl5d59z92Xt51NbBFKFR+zVrOzsypXVn7cpbZ+4sRJTV6YWDIttqFGqFNch+3Q5jbKRu6LExcurHlfBAAAAAAAAAAA2G6Sqg/nm1Sc0wIAAAAAAOglBBhhRbYUGkctXs003CHACAAAAAAAAAAA9KjTp84oSZNwTmOl0JQ7NTDQr29/+9tF+EsMTbkkhqYMDAzoyJEjevzdjxXBM1eKQUQz0zNFaMpazM/N6dzZc2o2G8umDe8a0oc/8pReeP4FvfH6sSJYJgbhxKCecqVShOD09fXpB37w+y8/pt1pF2FIsb7bL8DoteJ1Xal4jeH/tz34gPbs2a2vf/0bRVBQ3HalUqkIt4lhQnFdxZCjffv36dgbxzSXzd1ygNHxY8fVaDSKEJ1LAUbW2iI06MG3v02H7zikZ5/5WpjvhJphvrj97n/g/iJ853u/76NF3au1ahFeFNtNEUwVxt1x5x2Xt118vf2h3d1sgFGsz0qOHLmzWObXng31Kx9fMq3d7mhyYrJ4bRsaYLSB+2IMjVrrvggAAAAAAAAAALDdxL5eSTjNZCydvQAAAAAAQG8hwAgrSvu8qiNSd97IOwEAAAAAAAAAAPSkGMhiOka//cnfLgJjfvI//8nL0wYHB4txP/t3frYIAXrj9TeKcJWo3lfX3XffreHhIQ2FUq1Wlyz3tz/5ac3NzWmtYtDK3Ny8nv/G80VIyzvf+U7V6rViWqVc0aHDh9Tf36+HHnlYWdaVc16lUipjbFGXGPoS63z+/Hl96ekva8/ePdq7d6+qlarq9bq2k4mJCZ08cVJf+PwXtXffHj3yyCOXp739obeH9ZPpziNHJO+VO6ckhglVK0XIU1/YfuWwPpuNpv7oP35WU5NT+se/+I90K15++dt6/Y039L4n3luEIR08dPDytLjuY0DQBz7wfr3nve+Wy12oli+2VRq2XxzOLyzo5MlT+sqffKUo7373u7VrZJcee/wxXdW8bsrrof2mSarTp04XQUZX1m8k1Ld/oF979uwJ7a6z5HFnTp/R73z6d5WkVjMzM9ooG7kvTlyYEAAAAAAAAAAAwE6X1n0oMcBIAAAAAAAAPYUAI6zIhpZh137hVwAAAAAAAAAAgE3l3OKVGE6fPlOEn1ypVCoV5d777rk87lJoSgwReuBt919zuTH05dK8axEfE8vU5LQmJyaXTLOJLYJwYjlw8MB1l5Pluc6ePVeE5gwPD19+ndtJXE8LjYbOj58vQomuNDS0uC1jkNC1tFotZd2sCPSZmprWrZqdmVWykBQBO1dv+yRJirJ3395rPj4GUs3Pz+vC+QuhTmd0//33q1pbh+SiixbmF4phrF9s11eqVMpFGRgYWPGxcVqs/0bayH3xZsLEAAAAAAAAAAAAthuTLvb5AgAAAAAA6DUcssCKyoO+SOOePealrhEAAAAAAAAAAEAve/aZr6larSqe1bjzriN68v1PFEFBMRzlkvsfuO+aj5+ZmVG73danP/lpzc7O6sVvvaRb8aWnv6xnvvqMut2uBocG9dHv/egNH3PsjWPhuef06U99Wo1GU6+++qq+5yMf1pHwerarGF70B7//B3rkkUeKEKPDdxwqApuuZ3xsXOPhcV/64pf0+muvh/X0mvJ1CHiKgUjR//Q//kvtGtmln/ovfkoDA/03XP8LCwv6wue/qDdeP6Y//cqfFgFD1xIDqfbs3aN6X10361//L/9Gg4OD+j//5z+pWr2m/fv3q5f02r4IAAAAAAAAAACwXVTDabTykJfZ2OtWAAAAAAAArBkBRlhRPJBlS14AAAAAAAAAAABrFQNdpianNHZuTJslBp4YI50Lz1mpVovnHhwcUpZlSpLFU2LWLl60wbnFcyCdTlfe+3A/1+TEVKj3vM6NjWl2ZjZM6+hWxPrEEusRA22mpqbC8yeh2FBPU9Q1PHXx/FnWLR4zFp97drZ4DfGxzUZT83PzxWP7+urFa7kkjmtdJyjn6rrEUJiVtke73Smmr9X8/MKKy1sI42NZrfj642ucjO0lvP5avVqsp7iOoiu3WZ5noeQ6f/5CMe/42PkwHC/WSxy/Un0mpyaL9rjaukQTE5PF88XnaDQaGhoeulynS9vuUhtqt1vF643PPRHqFbfL5XWx0CieO05rXKxDN2zr6WLbtXSzYv263WxxfdVqKpVKoY0nl9t5dKlNOeeK9Ru3cVxH13PN7bmw+u0Z3e59MQ/LWGzzs9do8zdeFytZqc3Pzc0V6yfWHwAAAAAAAAAAYKPZ1NPfCwAAAAAA9CTz9/7N93HUAsu4TPJOOvb7ibIFIwAAAAAAAAAAgK3myJE7deSuIxoZHVGlUlG9XpcJ/y003gpkiQEkMeDlu995pQiE2SiPv/uxImzm8B2HlZZSVStVtVqtItTl9KnTRcjR15/7hna6d7zzHcU6iusqTRP19/eHc1a+2GZxW736ymuamJjQ5MSkNsPQ0JDe+a53qH+gXwMDA0U7ioFBcXvFEJwvP/0nxXB8fFy3Q60e2tThwzpwYL8OHDxwefzxN46pG9rWXGjbMYTpzOkzup16aV8EAAAAAAAAgNspBrzHY98xmD4eKwWuduHCRBH6f6sX28D2dOh7c9X3xhAjydDda9t444/HtDDe0tybTblsaVfPylBJ1VAOPzmqXff2C7hVrZmu2qG88blzWhhberGjpGLVv6+qvY8Oad87hgVshs5CpuZER2MvTGv8WzPLpg/dWVff3oru+YH92mhvftkqaxo1xviQXcl0bVTfOPxBAQAArMjo6VTAtYTv2Ek4oOXKXq7DF24AAAAAAAAAALC1tNotzUxPy3mvUpqqWqtKXkVw0CWNZlOtRqOYdyPFcJb4h+blcllJqEu5VFI73Hd5rpmZGbXbbSFuj0YRUBRDbhJrNTc7V/yRftxmMTQohvF0u11tlizPijYUt1Wz0VQpbL80ScL9dth2rthuMcDodol1iOtkZnqm6OxyyfTszMVpzZ5oW720LwIAAAAAAAAAAGw1JpwGsqlXOH1W9PeilxcAAAAAAOg1BBhhRfZiy6gMeyWVmBgqAAAAAAAAAACALWXs3HhResGrr7wm3NhrYT3F/3rFwvyCvvnNb6lXxXCiM6fPFKWX9dK+CAAAAAAAAAAAsNWUh7xKfVJa88XF6gEAAAAAAHoNAUa4rqQW/rFeZHMDAAAAAAAAAAAAAAAAAAAAAAAAwOZKyovhRbICAAAAAADoSRy2wHVVdknVUQEAAAAAAAAAAAAAAAAAAAAAAAAANllak8pDkk0FAAAAAADQkzhsgeuqDHu5XAAAAAAAAAAAAAAAAAAAAAAAAACATZb2eVVGPAFGAAAAAACgZ3HYAtdVqkneCwAAAAAAAAAAAAAAAAAAAAAAAACwyZKKVO6TDD0BAQAAAABAj+KwBa4rqS6mF9X2+CLIqHXBCAAAAAAAAAAAAAAAAAAAAAAAAACwcZKKV3lQqgx6pTUvWQEAAAAAAPQkAoxwXSZZHCZVyWUCAAAAAAAAAAAAAAAAAAAAAAAAAGyw2K8r9uky6Vt9vAAAAAAAAHoRuctYlYE7vfoPegEAAAAAAAAAAAAAAAAAAAAAAAAANlapb7FPVxwCAAAAAAD0MgKMsCom9UVat4wAAAAAAAAAAAAAAAAAAAAAAAAAABvFSDa52Kcr4aL0AAAAAACgtxFghFUZPOLVf9jJlrQYZAQAAAAAAAAAAAAAAAAAAAAAAAAAWF8xvKgklYcW+3SV+gQAAAAAANDTCDDCqpnQWipD4aBXndRuAAAAAAAAAAAAAAAAAAAAAAAAAFhvtuyLPlwJfbgAAAAAAMAWQYARVs0mUt9BX6R3AwAAAAAAAAAAAAAAAAAAAAAAAADWV5Iu9uGqDhFgBAAAAAAAtoZUwCqZRKru9nJZvG3kXRjJcTAAAAAAAAAAAAAAAAAAAAAAAAAAuGWx/1ZSXezDVarTcQsAAAAAAGwNBBhh9axU2+PVbS4eDIt8LgAAAAAAAAAAAAAAAAAAAAAAAADALYp9tmxlsQ+XsQIAAAAAANgSOIyBVTOh2FQq90uDdzqVh0jxBgAAAAAAAAAAAAAAAAAAAAAAAID1EPts9R3wRR+uSxegBwAAAAAA6HUEGGH1jIrk7qQspX1hWBIAAAAAAAAAAAAAAAAAAAAAAAAAYB3EPltpxRd9uIwRAAAAAADAlpAKWKPSgNfQfV4ut2pOGvksjPQCAAAAAAAAAAAAAAAAAAAAAAAAAKyRuXih+aH7XHERegAAgF6SuK4GW1PqVc4k6qZlOVl1k7IAAMDmI8AIa2aT8E/47mbLXkkoWcZRMQAAAAAAAAAAAAAAAAAAAAAAAAC4GbGPVmTL5BcBAIDek7pc1W5DvSq3JXlj1LUlAQCA24MAI6yZseGgWCj13eFO7jXzmtRd4NAYAAAAAAAAAAAAAAAAAAAAAAAAAKzV0L1eSUVK6HMPAAB6UK27oIfPPade1SzVdG7wTs1XBnUhPSAAALD5rICbZMtepT6/mOydehkyjAAAAAAAAAAAAAAAAAAAAAAAAABgVeKF5mO/rLQWSt0LAAAAAABgK0oF3KTqSCxejfF4cMyoMxMGHCcDAAAAAAAAAAAAAAAAAAAAAAAAgBtKql5JReq/w6tUFwAAAAAAwJZEgBFuWW1vTPiWphaMfEcAAAAAAAAAAAAAAAAAAAAAAAAAgBuojkqVXV4JvfwAAAAAAMAWZgXcovpeaeBOL5t6AQAAAAAAAAAAAAAAAAAAAAAAAABurDrii35ZhgAjAAAAAACwhXFoA7csrXl5J/WHg2XZgtf8KXKxAAAAAAAAAAAAAAAAAAAAAAAAAGAllWGv8i6v6m6vUh8XlQcAAAAAAFsbSTO4ZbYkJZWY+B0Onu0SAAAAAAAAAAAAAAAAAAAAAAAAAOAa0rpU2y2V+hb7ZRl6+QEAAAAAgC0sFbBOBo84ZS2pM2OUNaTmeSMAAAAAAAAAAAAAAAAAAAAAAAAAgJRUver7pP7DTgN3+jBCAAAAAAAAWx4BRlg3thSOmeVhmC7eBgAAAAAAAAAAAAAAAAAAAAAAAAC85VLfK/pfAQAAAACA7YIAI6wrW5H2vjdXa9Ioa9pQpLxlBAAAAAAAAAAAAAAAAAAAAAAAAAA7kbFSecirOup14ANOAAAAAAAA24kVsN6MlJSlyohXqc/LpL44yAYAAAAAAAAAAAAAAAAAAAAAAAAAO4lJFvtXxb5W5QEBAAAAAABsO6mAdWRieFFJssNe+97rNfOa0czrRt0FL98xAgAAAAAAAAAAAAAAAAAAAAAAAICdotQfSp+0772uuHA8AAAAAADAdkOAETZGPJhmpfKQ1HfIq3VB6i5I2YKRdwIAAAAAAAAAAAAAAAAAAAAAAACAbSute5lEqu/34baKvlbkFwEAAAAAgO2IACNsCBOOpiXp4gG22h6v2WO2CDGaPRkmEmAEAAAAAAAAAAAAAAAAAAAAAAAAYBurDEtpTRp5yCmpLva1AgAAAAAA2I447IENZeximFF9n1N1V7xvlWfS3DErAAAAAAAAAAAAAAAAAAAAAAAAANgWTPg/kcpDXuVBr4E7vEp1r6Qi2UQAAAAAAADbFgFG2FAxvCgefIuJ4VF7VnLdGGAkAAAAAAAAAAAAAAAAAAAAAAAAANgWYj+qeDH4Ul2q7Q5lj1epTwAAAAAAANseAUbYVH0HXTFMq15502j+TaOsKbWnjAAAAAAAAAAAAAAAAAAAAAAAAABgK4mhRfX9XuV+r9oBXwQYpX1eSVUAAAAAAAA7AgFG2FTxAFxhj9Sd92pNGbmuAAAAAAAAAAAAAAAAAAAAAAAAAGDLiQFGaU0qD0q1UcmWvZKyAAAAAAAAdgwCjHBbpHUfilQZzpV3jLKm1Bg36s5J7RhqlEmdGSMAAAAAAAAAAAAAAAAAAAAAAAAA6AVJbTGcqDwchiVp6F5fBBiVB8IwUVFElygAAAAAALDDpG7BCbhd4vG4xMcbpkjTcnEYDtq5MCXejvzFeb0AAAAAAAAAAAAAAAAAAAAAAAC2JiujaqWkUrmqgYEBAVebPD8u772s6Y3+Xt55OfmiTlczxoQ2bVV0/9nGgT3mqmEa1oe9NAwjU+PDOgglDyNz+kHhJoT9zOf+utN8x4l+oFgPvhHe1VvXaG9xdGxvbdobNs+lNumza7TL+P7Y8ZvSJn1uL74fk0QIAABwM9L2788K6AWVi+Wy0uIg80k40GnCMTy+9AMAAAAAAAAAAAAAAAAAAAAAgK2pUq3pXY8/qIHhET30+BMCrvY//MLfX7yRqCdMtZpaaHfV6mZyV4UY1StljfTXVDJWpcRquyou3m7ipdp9MYwhRWpeLEF+YnGYCbg53YmOXCdfbFtX8U0v183V+WpD7W8SKINb185CewrFTa3Q4MIbmZvIlT3fUvt1+h1jc3Ryp078njHXXXF60SbDtM3oC++yAXkfv9Ns3+81AAAAGykV0OPiAT5fpJPzpR8AAAAAAAAAAAAAAAAAAAAAAGxNVoshKFzeGddi5dVTvJNcHgb5sgCjON4UbTrWe/u26sV9drEAAAAAAABgZQQYoefFdPKkOI5JSjQAAAAAAAAAAAAAAAAAAAAAANiaSjZXYrysoX8EVla2mXqJcR25vK086yp3VwX4pD78X1LJJKHehPsAAAAAAADsZFYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABrRIARAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABYs1QAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOxA1jjJeJVyI2ysTEkx9GJdAwCwnRBgBAAAAAAAAAAAAAAAAAAAAAAAAAAAAADYkaxc8W9ivLCxch/DiwAAwHZDgBEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAYEcatK1i6K2wwc53h4q4qC4xBwAAbCt8sgMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAdiRrvLA5TFjXxhsBAIDthRxIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACwZgQYAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACANSPACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAArBkBRgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAYM0IMAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGtGgBEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFgzAowAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMCaEWAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADWjAAjAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACwZgQYAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACANSPACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAArBkBRgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAYM0IMAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGtGgBEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFgzAowAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMCaEWAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADWjAAjAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACwZgQYAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACANSPACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAArBkBRgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAYM0IMAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGuWCgAAAAAAAAAAAAAAAAAAAAAAAAAAAKvi/eLQGPW0op6m+B/bAO0OvcJfdb/Xt/VW2XcA9K4kvIHE95BauaTEbsybSXyrcrlTO8/VyZzQm4brlWtOm291lDkvYKciwAgAAAAAAAAAAAAAAAAAAAAAAAAAAGCVnEzRyTxVb3dQzkM9jfdKCO3YFmh3+D/Y+/MwOdLDvvP8ZUTknVVZd6FQAKrRDfTN7iZbJJuXSIrkkDpsP6Ike+3x2FqPxt6V9px5HvuPfXb3eTzP7jx+drXP7uzI6/X4GVmWZXN0j25RpCiSoki22GTf6AbQAApHHagz7zMiJt4XyEIVqgDUXVmF7wcORWVEZuSbEW9mdcGoL7tJuCpbFOvyOXlY3jsAulc64SnuOnp2fEAJz9VeaPuBSo2Wppcrmi5Uhe704sTwPfe9Mjmn5WpDwMOKgBEAAAAAAAAAAAAAAAAAAAAAAAAAAMADtMJbEYxmaMIdMSWCtrSDIEYYBtFyr32h3dcOQjX9QFsRyJEZYjtau9H40tEW0xqhJ3M47da8M2GEdhDc85Fmvvnh1ufbyuNtJCamVsyxoZh4NO9M4iHGxDty2tFcbEafL50PsHho5sx25qRv52Rwjw9CsznYwZzsfBbaqFb0x42+4rMQwHb0ZZJKxV19/OyY8umk9kIQ/TdfrdXWYqWhhXJNc+W6Ks22ppbKakWfg0SNusPnnj55z33vziwTMMJDjYARAAAAAAAAAAAAAAAAAAAAAAAAAADAAzQCV23FVA1uhTuygfkF5dAkMrQdt8IdGwdlzDazr9X21Wi1tRUNJ6nAhmQ8xWOBEm40xmi8hGQOp92ady3ftwGEMFj/uDD6Y+NF7WDL823l+DHPjqjmxJWM5l3O8RVG6/gOIl/oTo3QUSXwbofWbs3J2Dausx99Bjajzzg/2PixZk6a8NZ252QzllAQc+zcjN49SnrRJ2N0TJfPQgBbNNKTVn82qV/49HMa7c1oL5mIUb3l63tXbmpyoaQ/fuOKDRkRMOoO/9V/8v577vujNyZ1faks4GFFwAgAAAAAAAAAAAAAAAAAAAAAAAAAAOABgmhph7fiQibasVCpKzQRIn97cY1Gu23jHCZKczffhGai7cvVukr1prYi2ROXHEeOd2usvt0a23ZoCQdrt+adSWUFQWjDWev2BSZe1FaxFqrWbGk7EulcNM0cuWkz1pgdsxOtFWPeHTVBeOv6ymaLYrpZrNg5uVU2nBXNPRNq20jTfkb6mlne3hxKZvOSK/tZaAJu5llcMyf5LATQxRKuKyf60HpqbECPDPbo7Ehezei/C184OazJ+aL+6M1J+9+PZhsAdBMCRgAAAAAAAAAAAAAAAAAAAAAAAAAAAA8Q3I51mGhHEEqVRstGO1qtrQWGNsOGh6InMc+xVfl0INdzbsVjov8rgh2H2n7NOzPfas22atpekCsXz5h+kTK6HVti3h1pt66v7MdLOZqTfnt78+Z+zJz0o2dq1RrajlyyrXjMVdy+h4yYjSYBQDdznVi0uDrRn7W3z4722bWJGr09taivvnPd3iZgBKDbEDACAAAAAAAAAAAAAAAAAAAAAAAA9pAbT8hLJBVPpuV6CbWaTTmuKzda8PAKgkBhGNoIhVln8gN2XSsuqdv50Tgb7bZ9DSYuADwsWnLlmyBQ7PDMe/M+rQd+NPIgGjnv18PocM67UE2bnvGjPwQWjpqWqRbF+BV1AFjtWxenbWBoq2IxE1xLKJeK6/GRPg3mUna52wcmhnVmJG+DRq9em9evfvucbhZrWq7tfkgTALaD/zoEAAAAAAAAAAAAAAAAAAAAAAAA9pDjOIpFi4kWmbWJ1CgkIoFbgtvzwYsnFPi+DgPTLDJxCj8WygkIU+AhYgIyMR0q5rtN53MmJCRzOB3KeReuzD0/ZN4dNYGZj4dsTgLAXpsuVHR5vqitcmIx5TNJ9UXL8XxWPan4hvfrj/abyFFvOqFivRl9ndBCuS4A6BYEjAAAAAAAAAAAAAAAAAAAAAAAAIA9kEzn5Hqefvhv/2MpFlM8nrDbFxYW1t3XhI2MuHfn131i0WPMYsJHzu39q/cl4vF7Pnc8kbD3wfYEJsoThmq32/e8T7PVuhWjuutxZpsJEa3eZ7dF+/z7BIo++TP/hdrNhq6+85oqhUVdefOv1a2qjaZdgIdNrm8g+ixPRp+xSR0WzVZbC4WC/OjzzPfbwuFzOOedr1K9pmbDLMQVjppsb59yvYdnPgLAfvjjN67q3337He2UCRmZWNH/+lPP6pOPj+vZ8QElPNfui0d/L2D2febJEzoznNc//4OX9YevTwoAugEBIwAAAAAAAAAAAAAAAAAAAAAAAGAPeImEXNe9HRK6f0yoE7u5O3pjwkVhECi46/7mmDaycw8mvPOggNHdUaSHxUbneqP7dKJD92IjRXdvux0wCrX+Wm6Wl0jKcfm1LwAAAAB42ATRz46t6OfKYq2p2WJVZ0fz9ufL5O2IkeE6MSU8R9lEXL3phL0vABw0/iYLAAAAAAAAAAAAAAAAAAAAAAAA2AMDx04q09snL5548J1vB25arZY2q6Kd8TxvyxGjeDxu17EDjh/ZIFC0mFDTVuJAnSjRg+JEB8XEi049+bzmb0zq0mvfFgAAAADg4WFiRGb5f/3ZqzZa9Cv/6LMa7c3oAxPDK/fpyyTt8pMfeFQTgz360ssXdG2pLAA4SASMAAAAAAAAAAAAAAAAAAAAAAAAgD3gt1tqN5vqVtsJ+JjAUiwW00GzyaJtRIhMuGgrwaP9ZsZm5k3gtwUAAAAAeDi1/Vs/6/7g2pzyqeSagFHHyYGcmm1fqbgrADhoBIwAAAAAAAAAAAAAAAAAAAAAAACAPdBuNdRsVNWtTPxnOxEj7KEwVKteU7tZFwAAAADg4dT0A7v8xvcuKuG5+oUfed+6+zw7PqjHR/v1///6W7pwsyAAOEgEjAAAAAAAAAAAAAAAAAAAAAAAAIA9UC4sql4ta2FqUo7jqndwRLGYIzcet/vDMBTgOE40L2IqzM/Kb7c0d/2yKsUlHTQ3GpfnOkq4nnyH0BVgeNH7wonpUIlFA45H72U3+uPH+L5zGB3WeefauedGL8AVjhYzJwEA++NmsWp/NptertiQ0WAutbIvYf4bIR7TeH9Op4d6dXm+KAA4KASMAAAAAAAAAAAAAAAAAAAAAAAAgD1QLdyK0JiAkRdPKNvbJ8d1FU8mFQQEYXCLCRiZpby8oFajrhsX31K71dRB64QnAi9UEB6ycgawR9xYTE60mHfEYUkBmdHa93I0Yi9GSOYwOpzz7lYIL/o/cggYHTnuYStqAcAhdrNUt+vpQlW5ZHxNwCgefY81eeQT/VktVggYAThYBIwAAAAAAAAAAAAAAAAAAAAAAACAPXT1nVcVT6bUk+9Tuiev0fGTdnsY3skQ+L5vNqzZZiJHQWfb6vvejh8F5jF36YSRCCTtDs+7969fua6rmAlKxNb/Er8JVdlww2rR/exjbn99Z/OtY7zz8teia9pWvVpRGBx8oiKXSiqTjN+elwIQqcQSasuRHzs88Q7zi+19vRk50RvZZIxw+BzKeec6yqYTiqdMWCEpHC3VaE7WBADYT19/94ZODGT1+LG+dftO9OVUa7b11XPXBQAHhYARAAAAAAAAAAAAAAAAAAAAAAAAsIdqpYL8VlOtRk3JdFqJRGLdfdrttg0VhavCQyZeZMJG4V1hI93etlFVJqQ0s2tMVMi5O0K0ykrAaIP7mPDR3QEjc1832n6v6FFpcU7dJOGZ8TsCcEfDd6PP2Zj8Q/RR60SfN0nzmaRQXozvEYfRoZx30ffAeMxV0sw/h+8lR00rmpM1emgAsK/myjXlUvEN96UTnnpSCQHAQSJgBAAAAAAAAAAAAAAAAAAAAAAAABwwE8PZrPtGikzs6AH36QSRAt/XVpjHNFstdZO45903MrQRGw8yMaFNnPP7HTt254AC8PAxnyXpuKcgDJRwuqssE3djfDQdUd0975xofMSKHkZmToZu933oJBxXTmzVf7MBwCFWqDVVaW788/ijI3llknEBwEEiYAQAAAAAAAAAAAAAAAAAAAAAAAAcsNgWShOxHVYpgiCwMaKtHsU8xo0e200c15W71YDR7ft7Hr9aBWBrHIW3Yhj2MzS0wZZbX3XXZ6Mbi93+XnHrsz52e5Q4nA7LvPOicZlyVme+Me+OLnNdnVXXNum5CrtrOlqeY2KUtz4LHcWYjwAOtYbvq+1v/DmWiH7GNTE5ADhIfAoBAAAAAAAAAAAAAAAAAAAAAAAADxHndsDHdV1tVSKZFAA8rDKOb5MsNRPBiD5Kewey6kbt0JEfrWtBIE+BEjGiHYfZYZl3QTTGIBpiMbg15zJOQDDmiEpG19aJtVdup4d6tbWc5P5oh7cyWrXbAU4+CwEcZtcXyxrIbPzzeCYZV97vwpIcgIcKASMAAAAAAAAAAAAAAAAAAAAAAAAAAIAHiNn/G8qJvnDCbg5hhHasXrR2Y8Ihd5jmnRmtmXcmnCXiRUeWmZPOquvbrR8zh+e9AwAAcPgRMAIAAAAAAAAAAAAAAAAAAAAAAAAAAHgAN3YrgJGLtdXNvNvjTLjdPU5szmGZd45ZorH2Mu+OvHh0neOx7g8CHZb3DgAAwFFAwAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB4SDixmBKeo75MUsfzWWWScSWj2wPZVLR27X3CMFS97avWbGu52tByraGlSkMLlbqa7UB7qTO+4Z60hnPplfGNRLddx7H3CYJQDf/O+ObLNZXqrX0ZH4C1CBgBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwknJqXjnkZ70/rAxLANBfWkEjo7krdrIwhDFWpNLZTrmlwo6tJ8UZejxUSC9j5gdGt8J/tzevr4wMr4no2+TtwOLLX8QOVGa2V8b08vabpQ2ZfxAViLgBEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwEPjCs6d0rDejlx47pt50Qif6ckrFPXluTD3JxEogKIz+tHxfjXagcn3YxoJK9aZev76oYq2pP3z9sirRtmtLFe2WZPTcn35yfGV8Jlw0nEuvjK8vnZTrOBuO7zPVhmqt9sr4fuuVC/KDcFfHB2BjBIwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAh8D7xgd1ciCnL37gMSVcR9lkfEuPH8vntFxt6NVrc5otVnc3YBR314wvFd1Ox7eWRumM72vvXlez7RMwAvYBASMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACgCz1zfEATgz0b7nvj+ryuLpa1Gf/Hz72gwVxK//gTT9vb+XRCsdv7qs22Wn6gSzcLqrZ8u82JxdST8tSXTurEQG7lOM+fHFQ7uu/JgR/WdKGi/8OXvqlSvaXJhZJ2wozvkeh1/t0Pnb3n+M7PLqvZDuw2z4kpm7z3+H7lH33WBpbM+EzQ6DohI2DPEDACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAulDSc5Vw3Q33mahPvdXWZph40WA2pf5ouVsY/QnCUM1VxzMBo6TnyA/CNff1HMcuo70Z+5iEGZ/na6fM+AYeMD4zttUBo7h7//EZZnxudBvA3iFgBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHShR4fzGstnNtw3Xajo8nzxvo//0WdP6dnxQf2TTzytvrviQBdml/X181P6zVcu6vuTcyrVm2rfFQQyz/308QH91IuP6adfPKOeZFye6yifTiib8PSlf/x5vTJ5Uz//77+uWqutemtrMaO/88EzOjXQs+H4zJi+f3VuZXyFWtOGjDYa3//qU8/qk4+Pr4yvP5O0X5vx/eHrl/XPf/972xofgAcjEQYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB0oaGelPLp5Ib7So2WliqN+z7ehIZODuSUiHsr20wEyIR8TBDo0nxBi+W6Wn6gu9pAVtsP7XPMFqu6ulhaFwBKxV0bCjIhoVy03qqRnsw9xzdXqq0dn+4zvsK9x5dLJrY9PgAP5gkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABA1/nk4+PynNiG+y7MLOv7V+fu+/iPnhnT/+JDj9uQT0ezHWi6UNF3Lk3r33zjbVWaLbttI3Plml3M46uNtn7uE08rl8rbfZ7raCyfVb3Z1o8/94i+dXFa8+UZbcWPPHVCH4vGuNH4vn7+hv7NNzc3vtHX05pcKG04vvedGNr2+AA8GAEjAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAoItMDPYo4brR4si5K2A0V6rZqE+11Vaj7W/4+L50UvlMXL3phD3G6iOYx15ZKGqmULOPD4JQD7JQqevC7PKGIaFMMq6JgR69lV7UZnXGl0149xyfec7Njm+qUFXSczccXzbpbXl8ADaPgBEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADQRV567Jh6knFlo+VuVxZKmoyWmWJV1WZ7w8cf78/o6bEBnejPrTtGpdHS967M6b25wj0ffzfzfDeLNRsVulsm4emDp0f16vV5bVZnfKP5zD3HZ55zs+MzcaWr0f03Gt9wLr3l8QHYPAJGAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQBcYzCbVk4rrP3n6pAayqQ3vY8I+335vRuV6657HyaeTNl7Us0EAqd7y9fbUgqYKFW1W2w9VCVqaiR5zbbGk4305uU7M7kt4XvRcWRsKMjGjZttXOwjve7xcMqFHBnuUcN11+8zrOj+7pJulmjbLPKcfBHZ808sVjfVl7zxXdD7N+Iai8aWj8bU2MT4Am+cIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwIHLpRIayKX1odOj+tiZsQ3vM7lQ1FtTCyrdJ2BkQkIjvRklvPWBoHqrrelCVUuVpjarHQRq+oEWKw3Nleo2FtSR9Bz7XCa8lIyez7kdNrofc1/zOhOes+FzXVss3zfQtP4xoRrtW+Mzr201MyYzvt7oOVObHB+AzfMEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAYN+5sZjSCU+PDPZoYrBXn33mhN43PqjTQ71yYmtDO9cWS/rWxRn9+Ts39MrknMr1eweIBrIpnR3Jqy+TXLfPhH6mlitaqja0VdeXyupJJXR2tG9dHGkgFz3nsbyuzJV0s1S773E648sk4rrX+O73+h40vg9MDK9/zi2MD8DmETACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADoBpFMVdR73phMb6MnrqWL+eOzFkt90dMCrUmrq2VNZ8uablB8SHkp5rQz7uXccwgjBUveWr7Qfaqlr0uHKjde/nTEbP6cQeeJzNjK8VhNqq3RofgM0jYAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABswz/55DP6zFMntF39maSeHR+wwaK45yrleUon3DXxounlqr5x4Ya+e2lWv/qdd23c50GGe1J6Jjpubyqxbl+96evaYknb6ANptlCJxujK980Y4uuf8/iAppbLmi5UtZnxpZOu9mJ893zOTY4PwOYRMAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC2IZ9OamKwV9vVk4zr5EDPuu1BeKveU6w2tFip68pCSTOFqpaj25sRd12l454819lwf3s7daCIH42rHQQb7vMcR0nPlRtzHniclfHFunN8ADaPgBEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACwDU8c69MT2n2lestGjP4ff/oDXV0s6X/864tberwJ9eTTCXWrbh8fgM0jYAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABMparYDNdp+tPZVa7VVb/m6vlSxt0286Gaxpt3SDgL5YaBu1e3jA7AeASMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAJh40XShoqnlSrSu6u2pBbv+kzcmVWm2tVRtaDeV6i1Vo+N2IxNz6ubxAdgYASMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABgG/6nVy/ptWsL2q62H6jcaKlklnpT86WajfgUoq9b0b6tcmMxxT1HcdfZcP/0ckUL5bq2qxyNzUSVfG3P/cbnB+GujQ/A/iFgBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGzD7716Rf/u2++oW7hOTOm4Jy9ab2S6UNViZQeBoGZLy9WGgiDUdtxvfO0g2LXxAdg/BIwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAI6AnFdfJwZzymaT2Qq3pq9JoaXv5ov0bH4D94wgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADAoZfwXA1m08okPO2Fth+oGS1huL2E0X6ND8D+IWAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAYEeGe9J6ZnxQ+UxS3ajbxwccVgSMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOyI5zhKeq5cJ6Zu1O3jAw4rAkYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAdiQV99SfSdpIUDfq9vEBh5UnAAAAAAAAAAAAAAAAAAAAAAAAANiBWCxml87Xq9cbcZw7/7vsYRja5V46+1av73d/AAAAAAAAAPuHgBEAAAAAAAAAAAAAAAAAAAAAAACAbfM8zwaJzNpEi8zXZu267pqw0WqJRGLl6yAI1G63193HbDfMvk60yGzzfd9u6+wHAAAAAAAAcHAIGAEAAAAAAAAAAAAAAAAAAAAAAAC4LxMl6iyd20YnWGQWEyzqbOts79y+n9X3vXt7h4kXddYmXGRiSZ2okWGiRp3bnfsAAAAAAID95Uc/kzfavoLbP693m24fH3BYETACAAAAAAAAAAAAAAAAAAAAAAAAsKFOjCgej9vIUDKZtLdNrGh1tGinz2GCRPdinvte2u22DRY1m027brVaNl7U2R7yC4kAAAAAAOybVttXtdlWy+/OsHC3jw84rAgYAQAAAAAAAAAAAAAAAAAAAAAAALAhIRMl6iwmTmTiQZ2IUWe7YdZm20HrjCeRSNh1J3ZkIka+79ulEzPqrAEAAAAAwN5YrjV0Zb6ocr2lbtTt4wMOKwJGAAAAAAAAAAAAAAAAAAAAAAAAAFZCRZ7nrSwmDNSJBHWj1UGlu5lgkVnMazJBI/M1AAAAAADYO7VmW4uVupptX92o28cHHFYEjAAAAAAAAAAAAAAAAAAAAAAAAICHUCf6k8lk7NrEikzsx2zvxIzMcli5rmtfiwkxGel0WmEYqtFo2KBRs9m0t80CAAAAAMBRUWq0dH52WQvluvbCYC6pkd6MPHd7weP9Gh+A/UPACAAAAAAAAAAAAAAAAAAAAAAAAHhImUCRCfyYtQkYdbYdBZ0AUyfUZIJGJlbk+75dzD7iRQAAAACAo6bZ8lWut9Rs+9oLiejn63R8+7mSbh8fgK3jHQcAAAAAAAAAAAAAAAAAAAAAAAA8BDoxn1QqpXg8boNFJurzsOgEjbLZrL3d29urVquldrutWq1m1yZsBAAAAADAYdb0AzWrDdVaG/+M+5mnTsi7Hfvdjlwqrv5MUtv9G4X7jc+Eh3ZrfAD2DwEjAAAAAAAAAAAAAAAAAAAAAAAA4AjrhHs6ASOzmK9x59yYkFMQBArD0G43XwMAAAAAAAB4MAJGAAAAAAAAAAAAAAAAAAAAAAAAwBFlYkUmzpPNZuV5nuLxuHCHOSdmSaVS9naj0bDxomKxaG8TMgIAAAAAAADuj4ARAAAAAAAAAAAAAAAAAAAAAAAAcMSYaFEsFlMikViJGJk17q9z3kzQKAxDNZtNuyZkBAAAAAAAAGyMgBEAAAAAAAAAAAAAAAAAAAAAAABwxJhwkYnx5HI5e9tEefBgnnfr163i8biNFlUqFbVaLRsyAgAAAAAAALAe2XQAAAAAAAAAAAAAAAAAAAAAAADgkDOBIrMkk0ml02mlUin7NbZv9fk0i4kaEYICAAAAABwWy9WGLs0VVaq31u1Leo7G8hnl0wlt1WA2HT02K9ddnywxzzVdqKjWaj/wOJ3xbXTfzvhyqbi2qjO+jWxlfAA2j4ARAAAAAAAAAAAAAAAAAAAAAAAAcAQ4jmPDRZlMxoZ3EonEStgIW2POmTmf5jx2zqk5n2YbAAAAAACHwVK1ocvzRZXrzXX7EiYQ1JdVX2br8ePBnpR9rBNb/zNyuWECQVVVmw8OBHXGV2/6utf4epLbCBjdHt9GtjI+AJvH35gBAAAAAAAAAAAAAAAAAAAAAAAAh5QJ6piwTjabVT6ft8Edz/OIFu0icy7NOTURI3OO0+n0ShwKAAAAAIBuVao3NV2oqNpYH+tJeK7G8hn1byNgdLI/q8dHo7+DiLsbPufUckWVxoMDQZ3xNX3/nuPLpbYeMOqM717PudnxAdg8TwAAAAAAAAAAAAAAAAAAAAAAAAAOJRPRcV3XBnZMVKezDbvHnM/OYs51s9m021utlgAAAAAA6FbtIFS95StQuG6fE/2Mm4578lxHW5WOx9WTSmz8nP7t5wzDBx5nZXzBvccXP8DxAdg8AkYAAAAAAAAAAAAAAAAAAAAAAADAIeM4jnK5nA3qmHBRJ1rUbfGiIAjk+74qlcpK+OdBent7lUql1G3MuQ3D0J53szbRKPPaqtWqAAAAAADoNjeLVb1xY17PnRxct68/k9LHzowp4bn63pWbmzpebzphl5MDObt4zp2/gzBRoLlSVdcWS3YJNtEH6ozv00+O33N8pUZLb08taTMGsillkt7K+FarNFtaLNe3ND4Am0fACAAAAAAAAAAAAAAAAAAAAAAAADiETMSos3QzE/vphIw2w9y3W60ORZnzbl4bAAAAAADdyA9CNdvm5/GNf3ZNxT15W/g7BSf6WTge3d+7vdytHT1fZ9nS+IK9H1+wamxt6kXAriNgBAAAAAAAAAAAAAAAAAAAAAAAABwCJppjlv7+fruOx+M6SNVqVbVaTcvLy3a9tLRk40MLCwtqtVoqFUvaDQODA/I8T/l8XslkUrlczn6dyWTU29t7YOfBPL8JGJnnb7fbqlQq9jZRIwAAAABAN3h7elGX54v6oUdG9ORYv/LphI38GEO9Kf3Ui4/J3Pz91y6r0mzZmND9PB0d42NnxjTck1q3b3q5rP/+m2/rlcmb2ur4/tYLj0bHTG84vqnliv7q4vSmxvfBR4b17PjghuM7P1vQb71ycUvjA7B5BIwAAAAAAAAAAAAAAAAAAAAAAACAQ8BEfDoRo9jtX+jbLybQY8I8tWpNQRio2WiqVq/ZcFG5XLa3TdDIBIxMvMj3fe0Wc7wwCO3xzTgCP7DPY4JBjXrDnpdU6tYvJ6YzaXtuzLb94jiOXNe1z2le926+dgAAAAAAtiuIfpZuRT9DL1eburpY0tmRPmUSt35edqLFc2LKpxJ67sSg3T9dqNpIUHBXmDcZdzXSk9bEYI9OD/UqHV/7M3c7+hm92mxrermqUr2lzeqM72axes/xjeWzWxhf7z3HV2u2tjw+AJtHwAgAAAAAAAAAAAAAAAAAAAAAAADoYp1gUSaTUTwet8t+K5VKajQaunL5iur1umZmZtRsNu2y589dLNn10tLSun3pdNrGgx555BF5cU+nT59WMplULpfTfjDXJZFI2KCSCRiZoJNZTOwpvOsXKgEAAAAA2E9NP7DL19+9roVyTf/08+9fCQS5jqOeVEKffvKEHh3O6//3F2/o6+enNF2oqN5aG+Y9G+3/0fdN6DNPnYiWk2v2mZiQiQJdW6roD9+4olqrrc3qjO/Lb1/VOzNLG47vJ56b0IsTwyvju7ZYip5TG47vp198TB+YGNlwfO/OLm95fAA2j4ARAAAAAAAAAAAAAAAAAAAAAAAA0MVMsMhEesxigjn7wUSKTLDIhIt839fy0rKaraaNCJnbrVbLRnsOWrvdtuMw43Icxy7JRFK5npxSqZRdenp67Pa91IlMmYiRCSiZsJM5TwAAAAAAHLSri2WZ5s+7swUNZOs6O9q3si/hudG2lD5+9ni0Tuu9uYKqzZbd55iYciKu00M9+sCpYY3ls2uO24x+7jVxoK+eu65L0eMabV9+sPWY74VoXIVa047vWG9LE9HzdaQT3prxvTuzaKNHhuc6SkU/h3fG15dJrTmuGU+5cWt8r16b3/b4ADwYASMAAAAAAAAAAAAAAAAAAAAAAACgC3WiOCaIYxYTMNrrEE9HpVLRwsKCLl++bL82AaNuCBbdzYSUjBs3btj1tWvX7LnK5rIaGRmxiwlAZTIZ7aVOvMiszfMZJgDVjecMAAAAAPBweWtq0S4mAjSYTa0JGPWk4nZ5ZOhJe/uVyTktVxv2ay/6O4hTgznlov3DufS649aavuZKNf3il3+gUr2parOt7fj+1Tm7NuObGOhZEzDqyyTt0hnfty7OqN669TypuKfjfZl7js+MpzO+hXJ92+MD8GAEjAAAAAAAAAAAAAAAAAAAAAAAAIAu0wnhmBhPIpGw8SKzba/4vq+5uTmVy2UtzC+oXCmrWqnaeJGJBIVhqMPCjLdSrmi6Pa2lxSXNzMwomUjqxMkT9pyaqNFeMYGpTnTKBI3M+TPn7jCdPwAAAADA0fTr37uoTMJTXzqhkd60XpwYkec6Snruyn1OD/eq3vTt19Eue/+4uzamfGmuaCNCv/PqJc0UqroyX5K/CwFfM75jvRl5TmxlfOa5E6vG9/hIXq0g3NT4/sPL51WoNe34mr4vAHuHgBEAAAAAAAAAAAAAAAAAAAAAAADQZUwEx0SLTAjHrE0YZy8FQaBisaiFhQVNXplUs9m0y2FkXkuj0bBLoVCwr8ucw2w2q2wuq71krlsnPmUCRrVazY6HgBEAAAAA4KC9fm3erj9xZkwnB3J634khe3t1wGggk5Qy9z/OUrWh5Wj55vkpzRarWqzUtVvju5JO6PkTgyvjc5y1Mefh3vQDj9MZ35+9fU3Ntr9r4wNwbwSMAAAAAAAAAAAAAAAAAAAAAAAAgC5iYju5XM6uzWKCOHvBxH3a7bbeeustu16YX1gJFwVhoKPChIzMOTx37pyNCl27ds3GjB555BGl02llMhnttk5wyjyPiReZiBIAAAAA4PA5P7ssz3X09/77L9/zPq9fX9Bh8qWXL9hokVmP9mb07IkB5VNJZRJ3EiTH+7LR3w1IM4XKyrbJhZKuRMvkQlHVZluX5oryd/nvDxotf834Hh3u1elo2Wh8jbavhfKdONGFmwVNLVf2bHyf+cXfvee+wzYHgN1GwAgAAAAAAAAAAAAAAAAAAAAAAADoIiZ+E4/HbXSnE8LZCyZaZGJF8/PzCvzABo2OoiC49cuK5vWZ8xlGf8zrPn78uBKJhPZC57qZ62gCRgAAAACAw6ncaNn1N85P6ai4tlS264tzBU0M5uQ6MQ3l0upJxVfuY/5Ooh39XcHVxdLKtrenFvX29JKmCxXVW772gokSrR7fcq1hn2uj8dWabTuWjh9cnbORpb0a31GaA8BuI2AEAAAAAAAAAAAAAAAAAAAAAAAAdIm+vr6VgNFeee/ie5qbm9Ply5dVqVT0MDExo8WFRbtcuXxFIyMjdnnsscc0PDKs3da5jua6mmBUuVwWAAAAAADdYnKhbJdu9fbUkl0AdDcCRgAAAAAAAAAAAAAAAAAAAAAAAMABi8Via9a7KQxDu5iAjlnq9bparZYg+b5vz4U5J9VqValUym43EandZK5rZzHM9QAAAAAAAACOAgJGAAAAAAAAAAAAAAAAAAAAAAAAwAEz4RwTzekEdHaTifTUajW99957unTpkirlihqNhiAtLCzY5fr160qmknrxxRc1MDCgnp4e7SZzXTsBKbMQkAIAAAAAAMBRQcAIAAAAAAAAAAAAAAAAAAAAAAAAOCCxWMyu4/G4DRjtpjAMbaioUqloenpaiwuLatQbNmiEtVrtllSXpqamVCqVdObMGXttksmkdou5vuY6GyZiZK4PAAAAAAAAcNgRMAIAAAAAAAAAAAAAAAAAAAAAAAAOiInamCWdTu96wCgIAhsvWlhY0Pdf+b4NFxEv2liz0bTLu++8a6/D2NiYXe9mwMgEkTKZjOr1ug0YETECAAAAAADAUUDACAAAAAAAAAAAAAAAAAAAAAAAADggnucpHo9rty0tLanRaOjixYuqVWs2XBSEgXB/JvpkokLnz5+31+X06dM2YpTL5bRTJmBkju26rj2m+dpEjAAAAAAAAIDDjIARAAAAAAAAAAAAAAAAAAAAAAAAcEBMJCeVStm4zW4yAaNyuax3zr0jbJ4JGBkXzl+wkaHe3l677EbAyDDX2USrzLrVahEwAgAAAAAAwKFHwAgAAAAAAAAAAAAAAAAAAAAAAADYZyZiY+JFiURCruvuWsBobm5O9Xpdb735lsqVsrA9rXZLYRjqtVdf0/DwsI0NmZBRPp/XTplrba65CSQ5jqNGo7ESTgIAAAAAAAAOGwJGAAAAAAAAAAAAAAAAAAAAAAAAwD4z4RoTMTIhG/P1bjHxolqtpkKhYL/G9oRBqFbQsucxlUrZc5rJZLQbTMCoEzEykaRmsykAAAAAAADgsCJgBAAAAAAAAAAAAAAAAAAAAABdYnT8lLx4Qu/74MeidVzHTkzIcT0lkil7O55IqLi0KL/dUq1WVatR1+yNq1pemNO7r39f7VbTLgB2j3nf9eT7lUillevJr9t/8e3XBGxFLObYYFEymbRBHBOy2Q3lclnValWvvfaalpeWiRftooWFBb383Zd19vGz9tr19PTY+NROmTmQiD5jTMDIhIwAAAAAAACAw4iAEQAAAAAAAAAAAAAAAAAAAAAcEBNBcFxX8UTSLoOjxxWPxzU0OmaDRea267lKJFLyEgkbN0qmMmo1G6rVKmpH63a7ZcMqczNTqlfKqlVL0f4WISNgl7heXOlsTrnevPoGR9ftJ2CErTK9Ijf67LffA6Jlp4IgsGsTwTERI7MmXrS72u22XUwgypxjE57ajetn4lVmMfOhcx0BAAAAAACAw4aAEQAAAAAAAAAAAAAAAAAAAAAckJ6+AfUNDuvFT3xWj5x9Smeeed6GjO5ncOTYum2B7+sn/u4/0oW3XtXFt17TGy//pW5ceU8Adi6Tzel9H/q4Tp19Uh/8xOfW7f/u1/5YwFaYWE1vb69d7wYTLKpUKjp//rwunL+gVqsl7I0rl6/o2tVreukjL2lwcFD9/f27EqEyQaQwDAUAAAAAAAAcRgSMAAAAAAAAAAAAAAAAAAAAAGCfefG4sj19Gj1xSsfGT2n42LgyuR3ELGKSEz0215vXUHSsY6dOy4m5mr85pUa9ZgNHOByGx04olcqs2dZo1KLrWFejVlG9VhUeXhvNj7bfUrVcZn4cEl48Ic+LKxaLaTcEQWCDRcvLy6rVavY29o6JDJlzXCqV7PfsXC6nePQ9facRo858SKWzdl2P3s8AAAAAAADAYUHACAAAAAAAAAAAAAAAAAAAAAD2mYkXPf/SJ/Tchz+h56NlpxzHtdGDx5563i5nn3lBhcV5/dp/9y9UKiypWi4Kh8Pf+s/+iXr7B9dsm5q8pKmrl/Tu66+ofn1SeHh96id+WicffXzNttLykt594xVNXjhnF3QvE7zJDwwql8/b6M1OmZhOu93W3NycXnvtNdWqNXsbe8fEi8xy8eJFew0HBwdtvGinASPPu/UrXiZA2G41df3SeQEAAAAAAACHBQEjAAAAAAAAAAAAAAAAAQAAAMD+cD1Po8dPaWhs3MaLjo2fWrPfRAtMkOLCW6/K930t3ZxRs1FXtVJeuY/nxRVzHI1Gj02mM3rk7FM2ipHKZFfu09PXr3giqcefe9HGi1755leEw6F/ZFT9g6NrtpkIVXwmseNABg6//MCQho6Nr9nmRp8J8UQ0P6LPAXQ3x/U0ODKmdDan3WC+T1y7ds0GjEy8qNVuCfuj2WhG37Pbujl7U9lsVuMnxrUbHnniWdWrFQJGAAAAAAAAOFQIGAEAAAAAAAAAAAAAAAAAAADAPnFdT8cnHtXxU4/q+Q9/Yt3+VrNhA0bnfvCy/friW6+pXFjWws3plfuYaJE5zvs+9HH1DQxpZOyEjZesCRjl++3y5HMfUL1WJWB0iAwMj2lodGzNtrmZ6zZIRcAIfYPDGh67K5QSk50fLgGjrmciU4PR+9uLJ7Qb2u22rl+/rkKhoFqtJuyfRqNh17Ozs8rlcrsYMHpf9H1/Kfrq9wUAAAAAAAAcFgSMAAAAAAAAAAAAAAAAAAAAAGAfxJMpZXv79JHP/YTSq2JDRrm4rHq1qq/+T1+ywaHL77wh3/dVWl6S326tua8JG7VjLV1661Ulo+MUFhfUPzyiZz7wYQ2OHtfQseMr9330qefs40+ffVrVSlmzU1cFANh/Q8fGlesbULYnr1hs5zGy+fl51et1zczMqN1qCwdjenpa2WxWpx89rXg8br/eicHoe3gyk7Hzpdmoq7i0IAAAAAAAAKDbETACAAAAAAAAAAAAAAAAAAAAgH3gunFlsjmdefo5Oa67Zp+JF1VKBb35199WcXlB1XLxnscJfD/6v77mZqdsBGNxbtaGDoZGx5TKZNcEjDpfmyBCYnmJgBEAHJBcvl+5nj6l0hnthkq5olqtplKxJBycYrGoVqtlr4UJD+40YGTmSWddr1YIGAEAAAAAAOBQIGAEAAAAAAAAAAAAAAAAAAAAAPvg+Zc+psGR40pnc+v2ffsrv683v/dtzc9ek9/2N3tIhWGgWqWka++9o9/+5X+pj33ux+V5cfUPjyqT61m53xd+5h/q0rtv6t03XhEAYP+99Nm/KTce106ZWI7x/e9/X0EQCAev3qjrO9/5joaHhvXhlz4sx3Hk3hUq3IpkOqP3f/wzunnjqmauXRYAAAAAAADQ7QgYAQAAAAAAAAAAAAAAAAAAAMA+SKWzSmUyisWcdfsa9bpKhSUFQagwDLUVnftXSsuq16pqt1vRcdZGkDI9vWuCRgCA/ZXKZOXtQsDIMJ/7jUZjy98vsHca9Ybq0ffy3bomJmKUTKcFAAAAAAAAHAYEjAAAAAAAAAAAAAAAAAAAAABgH5x95gUNjh5fs21q8pKmrl7S5fNva276hnbq7R+8rLmZG/r8T/8DPfPiSyvbh8fGVS0XNXH2KZULy1q4OS10pz/59X+rdDa3ZtvywpwKi/MqFwvCw+0bf/TbevN7f7VmW71a0eyNq9E8mRe6Ty7fJy+e0MQTz2g3XL50WeVy2S7oDmEQrlyPN994U2NjYxo7PqbtiieSeuKFDyvb26e+b37FvsfNAgAAAAAAAHQrAkYAAAAAAAAAAAAAAAAAAAAAsA/iyZSS6fSabe12y0YJ2q2WdkOr2VClVLSxokqppHQmLce99c/GXddVJtcT3Wd3ngt7o7i8qFplbZikXFq217XVbAoPNzM/7tZs1G/Pj4bQfbK5XiUzWe1UGIZ2qdej610hZtONgiCw16YRvRfN17FYzC7b5Ubfv3O9fQp8n4ARAAAAAAAAuhoBIwAAAAAAAAAAAAAAAAAAAADYByNj4xocPb5mW7m4rNkbV9Wo7U6YoLA4b5fJC+/Y6MGZZ55fCRiZgMbE2ad04/JFTU1eFLrTD771NQH38s6rfy0cLhNPPKuBkTHtlO/7NoozNTWlmzdvCt2nVq/p8uXLymazOn78uDzP21HAKJ3t0ZlnP6Ar776p4tKCAAAAAAAAgG7lCAAAAAAAAAAAAAAAAAAAAACw51zPixZX+6FUWNTC7JT8dntlWzyRUN/AkDK5XgEA9kdPfkD5gWHtVKVS0dLiklqtlg0ZofuEYWivTbVWtdeq2WxqJxKptI1fpbM5AQAAAAAAAN2MgBEAAAAAAAAAAAAAAAAAAAAA7IN4Mq1EtOyHhdlpXT7/ttr+nYBRIp7U8YnH1De485AGAGBz+oePaSz67N2p5aVl3bhxw4aM2qvidOgioey1KSwXVq7VTiSSKZ06+/SuBLAAAAAAAACAveQJAAAAAAAAAAAAAAAAAAAAAHAgXNdTPJGU47raTdVKScsLc2rWa2olU5qbvqFKuaipyUvR9psCAOytZDqjeDyhVDZnv96pYrGomzdvqtVqCd3NhIvMtRodHdVOOI5j504m16tcb5/qtararaYAAAAAAACAbkPACAAAAAAAAAAAAAAAAAAAAAAOiOu6SpiAkeNoN1XLpeiY7q2AUTqjqauXbgWMrl6yYSMAwN5KRZ+96WxPtOSUymS1UwSMDg8TMKrX63bZCRM3NHMnnetRLt8v328TMAIAAAAAAEBXImAEAAAAAAAAAAAAAAAAAAAAAPtgevKS6pWyTjx6dmXb4OiYHMfThbdejW69o91SrVTUbrX07/7b/7vCIFClVFLg+2rUKqrVqgIA7K2B4WMaPn5KyXRGO1GtVrWwsKBCoaBWm3jRYRBE33eDMLDXLZFMaGxsTJ63/V/hyg8O69SZp3Tl3bZq0X9HAAAAAAAAAN2GgBEAAAAAAAAAAAAAAAAAAAAA7INquah0NrdmWyKZVk9fvzwvrt3kt1symYv33nxVQRgKALC/kpmsMj29cr2d/epOq9VSrVaT7/sKAz7PD4PQfN+N/l+j0bDXbqfiiaSdS47Lr4EBAAAAAACgOzkCAAAAAAAAAAAAAAAAAAAAAOy5KxfORcvba7ZlcjkNDI/qqfd/WB/61OeVSme0G1qNumqVEvEiADggA8NjOvHok0okUtoJE8C5cf2GqtWqcLgsLi7aa2ciVDvR2z9o51Im1yMAAAAAAACgG5HeBgAAAAAAAAAAAAAAAAAAAIB9UCosKpFMKbwdFYrFYtHiyPUcGyXoHxpRzHHs9nCH4aFwj8NFNrRkxy85jhe9hjv/NN1vt+06CG6t67ejG+E+x5Sc6Fw6rivXceV4rtrRuMzYAt/Xw8pcJ8/1FIvOi2POy+1z1GHOTxgE0bXzb5+vW9GNvbx2nWhXzIl17Vx6WNnPKMe5NW/skri1Pdpm30vRdem8r8y8YZ6s5cXjdtyr32Nb0Rm/id/U63V7rnG4mGtmrp25lmYx76nt8Lxbc8mLJwQAAAAAAAB0IwJGAAAAAAAAAAAAAAAAAAAAALAPXvvOtzQ4MqrP//Tft0GLVDq7su/JFz6o0088ozde/paWY/OqlovqZh/69Bduv4aM+gaGdHzisZV9ywtzajUbmpu5oXqtqpe/9qdqt5pqNuraT/FkSsdOTGjo2LiGx8Z15fxbWpid1sLNmYc2YpTJ9uiJ515UPrpmfYPDGhwdU663b2X/3PR1e81mb1yNztWULr/7dnTdatH1a2mvmLlkoh7pbO6ec2lhbiZ6T5TsXPKja9eoVYS9Z65JtqdXE48/raHR4xo/fcaGVLK5XlVKRU1ePGfnyZXzb6u0vGTnzl45jPOkf2RM4489ru0ywRsTwCmXyrpx44Zw+CwtLdnFRIxMBCyR2F6AqDea82ZJR+89AAAAAAAAoBsRMAIAAAAAAAAAAAAAAAAAAACAfRAEvo1qmIBOMpVeEzDyXFdBIqG+oRF5iaSuXuyugFE8Gls8kdLA0KjiyaRGx08pFo05EY21N9+nzKqognmdJngTRl+boMnpJ59VvVrR/MyUDYpsNXJiIkmO6+nEo2fX7SsuLUTLYnTMio0Sde5rxpeMvh4ZG1d+cNgGe+Znpu39Hcex950486S9r3k9HbVK2S6FxXkbRNkq1/NsJMhc34HRsXX7z7/+ygOPcfKxx5WOjrFarVRSpVxQLTqPZnxbYV6f67gaO/Wocj35W+vevF16+wfXzENzntK3X3cimZJijpbnZlVcXlS1UpLfbmunNpxLsZgS0Tm711yKReOo5sp2LjWi+TM3fWNbc+ko2Gh+mLlaWJh74Pww5zaZSmn4+Ml1++amrqlRr9t4Wjx6X5u50B99HpllbOJR9eT7lY/mi+Pciq+ZgJmJg3nxhL0+s9Hjl+fnVCkt70rw6jDPE/MZk0imo8/yuHbCBIxM+KbZbAqHWyuan41GY9sBow4zp8z7zwQBzbwHAAAAAAAAugUBIwAAAAAAAAAAAAAAAAAAAADYB816VYXFOb38F39qwx8jqyIimZ5eZaL1xz73Eza28av/7Tl1k6FjJ9Q3OKSf/NlfUK63T8Nj45t6XBgE+sTn/6YmL5zT9775Vbs2y1aYcJEJqvyX/82/XLfv21/5Q337q38YHfMdG14x9zURqC/+7P/GBlD6BodX7luvlG1cZW56yt7+z/73/ycbOTp2YmLlPm+8/Je6ceU9ff2PflvzMze0VSZe9MRzL+rxaPn03/iZdfv/iy/80AOP8fP/l1/U0F3xo7d/8F2d+8HLt8a3xYDRyNhJG6H5e7/wz9adk7tNnH1y5et2q2kjGd/68h/o0rnX9e7rr6hUWNJOdebS57749+253+pcMlGab/zx72xrLh0Ff+ef/Fd2jq02F83Vb0Rz9uJbr0bLaxs+zryHzPV95gMv6fM/8w/W7f83/+L/rIWbU/bxJl70yR/7os4883y0vKB7WT2Ob/3ZrXny+ne+oeXFee3UYZ4nmZ68/YxfHQfbDhO8mZmZUaFYEA63pcWl6Ht7XT09PdqJvsERHTt1WtcvvUvACAAAAAAAAF2FgBEAAAAAAAAAAAAAAAAAAAAA7JN2s2kjI+Xisp5+/4eV7elRJte7sn/8kTNqt1t66v0fUqvZuGeMZL+k0hkb+Xk6Gs/E2ads/CaRTNl9QRDIj8ZqIjfV8p2ojhePKxaL3QrlRGsTTjExkuc+/Al7PGP2+qQNNe2W0ROnFPi+PvTJz6u3fzA6pz1yXfe+j1lemFOuNx99dSdgZAJEJt5iXsN2OK5nnzuZSq17rlZ07fdTtidvX8dLn/lRey1WnxPfb9vzVS2XouvXWHmMCcaYa+fFE9Frce21e+ypZ20AqVIq2lDOdsJOhpk36WxuZS6ZgJcZkxGG4UowaaO5ZK5p7PZcMtdn9Vyan5mKxkbgZae8RMLGyX74R3/Snm8TLxoYPrbpx5969Kx9P5nr4UXX6WGeJ/Ho/ZPL99lx7IT5jC2VSmrUG8LhVqlUou/tbe2UiWKZuRVzHAEAAAAAAADdhIARAAAAAAAAAAAAAAAAAAAAAOyTVqtpo0T1avV24GN8bcDo9Bm7NnGjSrl44AEjEy8y8ZunovE8/9In1u4MQxtZqhSLWrg5veoxabmuZx/XiYkMj43bxTDhosLC3O4GjMYnlEgm9cFPf165nvymHlNYnF+3LZ3rseOOewlth+s6yvT0Kn5XwKiwuKBqdD33k4nJpDJZvfQjP27DRKuZeJG5dmZcq6MuJqhlwkU2YOS4chKuHn3quWiRLr3zphTTtsM0Zh5sdy6ZYIfnxVeOYeNYujWXzELAaOcS5prn+/XDP/ZF+74/dmJiS48/+dgTdnn3tVeiyxk81PPES8SjsfRvO4TWYYI35XJZtXpNONyq0ff8VqulnTLvTTO3nJgrAAAAAAAAoJsQMAIAAAAAAAAAAAAAAAAAAACAfWbiG1/7vd/Qsz/0EcVefEm5fF6pdHZl//s++DFVSkVdfudNLS/Ma/bGpA7C6cef1vMf+ZSOT5xes/3d176npYU5vfv6K2rWa6oU74RBTAAnFnP00md/TIlEUs+/9MMr+45PPBptS2jywjlVK2UbIwnDUNuVSKWiczcQna+PqCffr3g8uenHlgqL9vGrmdCPCUp5ye0FjMw1PH7qUfUPDK/Zvrw4p+LigvbTiz/8WQ0fO6HkqtfYbNRVXFrU+Td/oAvRUikuR9evvrI/25vX0LHjeuEjn1ZPX5+GRo+v7HvupU/YQM25H7ys7TDX/qOf+xsbzqVmo6Hv/9XX7jmXPvCJH7Fhqo3mkglRLc3N7nguPeyefOGDCgJfgyNjakbncmrykmanrurm9avR/J23QbWO8WiOD46O6X0f+rjc28GrDuZJ9LmUTCs/MBStM9oJ3/dtwKgRvW50n7YcmZlUCuLR1zEthne+/2RibWWirblonYr5Wi4sy/N2/itciWRKmWyPYk5MAAAAAAAAQDchYAQAAAAAAAAAAAAAAAAAAAAA+6xRr+ndN17RwMioJh5/SqlMRkrf2T9++ozKxYJGT0zY2wcVMBocPa4nnntRPfm+Ndtnb1zV3PQNff8v/1ztVtOGce52/JFHlcn1rImJ9A0MKRtty+X75cVvqG1iIto+E05JR+dudHxCw2PjSiQ3HzCq12rRdVg7bhMvyuSkeGLzx1nNhFT6BoftcVZrVCuqlAraTyak9OiT71sTaQqCwI7j6oVz9to1G7Xo+rXWPG4sepwJ0BirA0bHxk9pcPiYtssEpu41l0wc535zqX94xAZzNppLPX0Ddh602y2Fvi9sz2h0fRVT9N7sU7VU1Oz1SV1777wuvvWqjRmZAFDHU+//kJ1fT3/gw/a2F79zHOaJ5Hqe0tmeaO1qJ0xoycSL2q220H0Cu8RUkaeGHM2s+ibeFzYVxGJK6dZcM9exdddn7XZ48Xj0mZ5WLEbACAAAAAAAAN2FgBEAAAAAAAAAAAAAAAAAAAAA7LPA91WrlPTGy3+p6WtX9Jm/+bd19n3vVyqTWwkT5Hrz+smf/Xldfvct5QeGdOPKe9FyUfvBRHhOPvqEJh5/WgPDo3Jcx26v1yoKg0B//Ou/Er2Gtn0N9/L1P/xN9Q+O6EOf+oKSyZQNo5iAiAkwvO+DH9XwseP67tf+JDpGWds1cvxkdKyPK5Ptuf2cv6XC8qKuXTinWq2qhdnplfs2otsmHNVqNuzti2+9plajseFx832D9nUvzs1qK0z4yDzOXMfVikuLWpib0X4Yf+RMtDym8YnH7Fhc986vDUxPvqcv/atf1NL83D2vnYll/fYv/5Le/9FP6fQTT69szw8MRtc8iK7n56N5UNXr3/2mNsMEaR55/Bmdefr5NXOpUa/a94GdS0F437n08l/8ycpcSkTnuKevf2UuPR69bzzP0/e/9ef2PGN7TCzNvBe//ge/qbmZG/r2V/9I7WZTrVZT/l3BH/PeWbw5q97+AR2P5tkLH/nkyr7OPDHz0MSxNhtfO0rzJB5PRedmaNshtI5Ws6XlpWUbMsLBMWe/KUeFMKEbQUZzSmouTGkput2SK1+3vme3wztRITcW2q19aigd8/VjyzPKxXYeMOqNvjfFoj+rP9cBAAAAAACAbsDfWAEAAAAAAAAAAAAAAAAAAADAATBRikajrkqpYNcbRSpyvX3K5HqUymRthGO/uG5cyVRK8XhCrnfnn52beJEZZ7VcslGT+4U1apWKUumKjY907ncrzhSzURHzmnbK826NszNGM65auajlxXnVqyZgNHXPx5qQUSdmdLeYE1vzurfCcT05jrNmWxAG9jzsBzNP7HxJJDZ8DaXCko3C3O/aVYoFNev1NdtiMSc6nnPrusVi2gpzje4ej3n+zlzqzKt7WT2XfL99ezy35pKJxNjX6+3f++MoMvPGLLVqxYaMiksL97zvrfdO3d631W6u2deZJ9v5vDoq8yQ6BdFngGvPxU4F0WvGwTM5orYcNeSqGnoqhXEVo8UEjO7xAMtVYB/nB6H82M5DVLFoXrl81gEAAAAAAKALETACAAAAAAAAAAAAAAAAAAAAgANSWJy3y2/9D/9f/elv/qp+7p/+c/X2DyqT6125z2NPPWeX733jK3rlm1/Ru6+/YiM0e6lvcEhPvf9DGh4bX7P95a99WbVqWdVycVPHqdeq+sYf/7ZOnX1SH/zE51a2P3L2aY2MndBf/dkf2FjKdpnxmeVX/z//N01efEc3rlxUu9Xa1GMnL5xTMp3ZcN/o+ISNoMxN39BWxJPJdefMmL0+ace3H4aOjdtrl101hxr1mt74629pavLSA1+Ted3m+s5NX9O5H7yssVOP2vnQMXHmSZWLBW2WCXCZ8YyeOLVm++vf+aYW52a3PJfM6/vkj31xZfvxaHzmtb7119+2x8P2vPy1P9H87LR+59/+0qbuXymX7PwwYSB9Yv1+c83Ne9u8JzfjKM2TRDKtvqERJVIpbdf09LQWFheEg1EOPRse+gt/VM1ofS7o03YUlVAxlP48Ok5Cgf7uwoI8z1M+n9d2dEJcMWfncSwAAAAAAABgNxEwAgAAAAAAAAAAAAAAAAAAAIAD5rdaqlcrmrk+qcLSgs4+83673XHdlfvkevMaHT+l61cuqtVsqNmoKwgC7QXzvCYoYuMkq7TaLTWj594K87qa9bWPSaXTK8+zE/VaxQZLqpWyfR4T39mKwG+rUirJ9ZxoTNmV7V48Hr32hLbCRKdS9wgiNRsNO779kEil1ZPvj17T2l8XsNchmjOb5bfNuSnaubaaOXYstvl4hut6di6tPr9Gq7W9udRqrH2MuU7m3DseQY+dMO+h0vLipu8fBv7t9/bm59T9HKV5EovFovdfXI6zs8837J92GLPBooZdXC0FCbWir03IqKmdX8da6NoQUssPFHNCbZf5XI8nUwSMAAAAAAAA0HUIGAEAAAAAAAAAAAAAAAAAAADAAVtenLfr3/2Vf2XjOf/lf/NLNhKTzuZW7vPY08/p1JknVIjue+3yBd24cnHPAkYmUjNx9mkbFFmtuLSgSqmw6eO0Wy3N3riqodHja7aPnpiwa8/d2T9pn71+VZMXzunae+ft82xVvVrV1YvnlB8Y0vGJR1e2Z3vzyg8Oaysmzj5pA1MbWZyf3db4tmNodExPPPfimm3t9q3rsDQ3u9nDqFRc0mR0bobGxjWs8ZXtTzz/ohZvzmz6OMl0xs6lu+NOZh4Vbs/7zejMpbujWsNjJ24/T1bYvotvvaaFm1Obvr+JcpnrUSxsPnp0P0dpnnjRc+fyfcLhUVZcy2FC74U5zYUpXQ2yqu3ir1xdCW99Ly3Wm0qH0oC2pzOvnBgBIwAAAAAAAHQXAkYAAAAAAAAAAAAAAAAAAAAA0CWq5aIcx9Vbr3xHqUxW7/vgx1b2xRxHrhfXY888r97+AVVKRRv3qFXK2i2xWEyO6ymeTCqVTtuY0mrNRk21alW7JZXN2UjTdl9Ds1FXOToHQeBrO9rttsqFZSVTa6MpmWhMJmK0FSa8Ys7bauZ6NhtNBX5be81xXSUSCXlefN2+0A/s66zXNn/tgugx7VYzevDaSJaZg663uV9FMPftzKV4NLbVGvXdnUv2mvXktxTYQndgnqxXr9ej99/ef248rALFVA1d1eVqOYxrWQkbMDLxomJ02+zfCwuVuvLh3hwbAAAAAAAAOEgEjAAAAAAAAAAAAAAAAAAAAACgSyzN37TrP/3NX1V+YGhNwMiEaczyQz/8WQW+r2uXLmpxbkY3Khe1e2JKptJKZ3Lq6RtYt7dcKETLonbL4PCowiDY9muoVspamJ1Wq1HXdphAz8LNaaUyawNGvf2DNhi1FeZ8ZXO9a7YtL8yrsDivRrWmvZZIJKMx9EfXL7Vunwk8mddpolebZR7TbDTk+2vjUGZ+xJOpTR3D3NeEnTaaS7VKZVfnUm/0HEPHjhMwOoSYJ+tVotdd3cVwE9YyWbb5MGXjRa8GAzZeVFBCe+3yQkUjbelpAQAAAAAAAEcLASMAAAAAAAAAAAAAAAAAAAAA6DLzM1OqVyv6qz/7fY2OT+ixp59b2RdPJG3059N/46dt8OiPvvTLajbrKi0vaacc19HgyJhyvXnth3gyaZftatZr0eteXBfZ2ax2u6VSYVH12tia7SYeldhkpKcjl+9XOptbs61cXLbXstVuaq95iYQdw1bHfS+tRsOe21azsW6f63oaO/VodN6qWpqbuecxzFwyUaX9YOZRIrU7rx37i3myXrvVlh9s73MNG6uHjgI5uhjmVAs9XQh61I5um5BRS1sL1m3XZLmtWILrCgAAAAAAgKNnf/6GDQAAAAAAAAAAAAAAAAAAAACwaZVSQYXFeb137g3N3ri6Zp+Jx3jxhM4887wef9/7lcv3KZPt1W5wHDc6Xl6pdEb7wXXj8rzt/+/ytlstG9HZbsAoDMLo8TW1mmsDQ+b153r7tBXp6DHJu+JBjWhs5lqace41My/MuM3c2A3mnNpz2/Y3eC5XfYND6snf/xyZuZTJ9mg/OE70vvDiwuHDPFkvCAIFfiDsHhMrakbLVJDRZJjVe2FvtM6pIs9u3w+LjUDLzVAAAAAAAADAUbP9/58eAAAAAAAAAAAAAAAAAAAAAMCeMdGb17/zDc3PTqlcXNZjTz2nx55+bmV/IpVWLt+vz/3Uf6rZ61f15d/692q3W/L3IZazWb7f1uSFcxo5flLdqNmsR+duUoOjY2u253rzCoKtRSZGx09Fj+tfs61aLWt5cW5fAkb3E4ahjRG1Gg0dVp25FE8kBdzLQc4TEw/r7RvccvwMe6MdxlSXq5kwHS0pXQ1yqka3l8OkfMUEAAAAAAAAYPcQMAIAAAAAAAAAAAAAAAAAAACALmRiRMuL80pmMpq9cVWjJybW7HddT6l0VsfGJ2yYxtwOfF++uocZT7VcUrPZneEcMz4T9rk7MGRCJFuVymSVSK2NprRbbbWaTSkMdJBMwMi81iA42HHsRGcumesF3MtBzhPHcaLPgJRcj1/V6QaBYmrLUTn0NB+mNBVmVOHXqAAAAAAAAIA9wd+8AQAAAAAAAAAAAAAAAAAAAEAXm71+1S6TF87p9e9+U5/74n+qY7djRl48romzT9m40clHH9e3v/KH+vZX/0jNRm1dlGczXNfV8NgJ9fQNbLh/cW5Gyws3tVsGRo4pjP7ordd0EBq1qj2vo+OnVC0XlUil5Xnxlf1Pvf9DajUburiJ8U2cfVJOdP5WW5idssffj5hKLp+3cyE/OLRun4lhmXFsRWFx3i7nfvCytsvMpb7B4Xscf07zMze0W/qi192oV3c0XhyMozJPHMe1IbN4MqWd+r3p6JOx4cgPcsrFWhqKdWcErtsshwnVQ1ffCYa0GCZ1LcwKAAAAAAAAwN5zBAAAAAAAAAAAAAAAAAAAAADoeiZIVK9WVCkVVC4tr9nnOI4N76QzOfX2DdoQz3bFYrF77gsCX367rd1ixn2/59svQRDY8xv4/prt5py6q4JGGzHjX72sOa4fbCskdVTY83GP6xv47V2dS7FYd8wlbN1RmSdBGERjXf85sr1jhWrIVTn0VI2WWuiqFcZM7g2rmPMRROelevs8FcO4ioqrGTra+VUAAAAAAAAAsFmeAAAAAAAAAAAAAAAAAAAAAABd78aVi3ap16rqGxzWT/4vf0G5nrzdl0imNH76jLK9eb3w0U/q9/79v9br3/2mtirmOEpnc4qnkhvuLyzMa3FuVrsllU5HS0YHrVYpRef2PY2detSeyw5zTmuVst597Xv3fGwynZPjxKLz1rNu39L8rL1mDyszl5L3iGkVC8u7OpcSqZR9Phw+R2WetJsNzU1f12j0ObJTtUC66cf15/6EhmJ1PeaU9WSsoGOxmhIK5JAysmqhp2Z0Nl71+7UcnZnXggEBAAAAAAAA2H8EjAAAAAAAAAAAAAAAAAAAAADgEFmYnVajVtXVi++qb3BIx1fFMkycI9uT1/gjj6lSXNa1S+fVbDS0W0bGTyqZTm/5cYPDx9TNzDlaXpjT0LHxNdtdLx4t9/9n95lcTq679j6tZkOVUsmusbHR4yftHN2qgS6fS9hdh2mehGEov91W4PvaTQ25mgtTisvXYpDQcKwRfR1E65rd7+rh0Q5jqkevuCFHRSW0HCZUC13dVErlMC4AAAAAAAAAB4OAEQAAAAAAAAAAAAAAAAAAAAAcIjeuXLTrYycf0eDo2JqAUSbbY5dnXvyIhkaP67d/+Zd2NWD01AsfVKVc0lYdP/2Yulm1UtTU1Usam3hUw7oTMUql0vLbrfs+dmB4RPFEcs02Ey+ajo5XLRWFjU08/rSyvXlt1d2RKRxth2memICRiZaZiNFuKoVxu1xVRq5CPe0U1Btrqc9tKhbddhXoYdGWo/kwZYNO74U5TYdpFcOEAAAAAAAAABwsAkYAAAAAAAAAAAAAAAAAAAAAcAhdufC2lhduavLCOSXTGR07MbGyb3BkTKlo25lnnlOlVNTFt17TbnjsmRdsoGOr+gaGN9xerVRUq5R10Nqtlo0N3R0ryg8MyfXu/8/ue/oGlEyl12xrNerRtZnb1XjUUTNx9ikNj209MpPJ9W64vVGrEow6gh7WeTKaTaoVM2Gi5sq2wOaKpOkwpUUb7Qlt0GgsVlM65isf3TcRPSZxRIJG/u3Xuxgm7Wu/HmTUkGPjRdXQ1aKSakTrw8Rc14F0XAAAAAAAAMBRQ8AIAAAAAAAAAAAAAAAAAAAAAA6hyfPnNN+btwEjE9pZHTAaOnbcLmeefl6VcmnXAkZnn3lBu6leKdvloLWbbVWj89Rurg0Y9Q0Oy3Gc+z62t29A6WxuzbZmo67C4ryazZqwsUfOPqXdVK9W7TXE0fKwzpNjuaSqYVt3B4wULTNhxt6e8dM2VvS0W9CAGnJjoXJhy0aMjgLzKvzbwaJWtP5eMKhm6GhJSR1W5roSMAIAAAAAAMBRRMAIAAAAAAAAAAAAAAAAAAAAAA6pVqOhL//Wr2n89GMaPTGhXG8+WvpW9r/4ic/a9dvf/64atapmb1zVTvzpb/w7FZYWtFvOvfrXdlwHrV6raObGpGqVtWGTiTNPamn+5n0fm8v32/O+WqvZ0PLinBr1hrCxv/iD39DNqevaLRfefFWV4rJwtDys8ySX9JRuhPe9T1OOfMX0tp9XIubrVfUrHW1Jx9oaiTWUir4ei9WUjNYjTl3drh46uhmmVQjjKiiuhTCpkv06IXMmitHXoY04HV72uiZcbZffbsv32wrDUAAAAAAAAEA3IWAEAAAAAAAAAAAAAAAAAAAAAIdUs1HX7I1JpdIZGwIy69WGx07YdbanV7vh2qULKi7vXsCoWi7Z2M9B89ste/6CwF+zPROdt2q1fN/HJhJJu6w5XnScVrOpMAyEjd2cuqHrly9ot5iwVjfEsLC7HtZ54rmO3Jhz3/uYmE87WkqK7hfG7TYTKzLhIifanom11a/GoUn+BNFIq/JssGg+TGraxowSNtR02MNFHZu5rvcTBIHCgO8rAAAAAAAA6D4EjAAAAAAAAAAAAAAAAAAAAADgkJu6+p7+wy/9C730Iz+mlz7zo0ok03K9O/9c/As/8w81efGcrl58RzthjrEwO63d0m411Q0a9ZqaN5sqFZdVq5SUTGfkOK7d57qeBoZH1WjUVSkW1j22b3BYvX0Da7aZMNONyxdVKxeFjV2/fF4X33pNuyUMfPm+Lxwth3GemPf9jffOq3/kmI2gbcf7Tw7Jj1eir5a39DgT+2mGjs6FvTKfYG/G+uz2uB/YuNFQrKHeWFO9akfrlt2WjbWj+4YajtW112qhq1Y0xpthKhqrq+thWq1ovFfDnEyWxwSMglA2wWRum6jRUYkXGea6xt3tB4xKSwvR95eije4BAAAAAAAA3YSAEQAAAAAAAAAAAAAAAAAAAAAcAaXCkhr1qsIwlPmzWranV9nc9kIaq7WbTbWaDR019pz5bQV+cOvrcO35MzEop7lxdMJ13TWxKHu8wFe73ZLvB8LGTETmKM4l7K7DOE+C2+//INj++z8Zd+2yVZ3YTztat6N1I7zzuWViRalo8RQoEQuVDH050bpt7hPbn88qM77Ajs2xsaVq6NmgUSGM22BRS1t/zYeJuaY7CRiZOeW32wIAAAAAAAC6DQEjAAAAAAAAAAAAAAAAAAAAADjkWs2m5qZv6Hvf/KrmZqb00c/9hB576rmV/RNnn1Iyk9EP/9gXNXt9Uu++/oqw3tTkJb39g5f1xPteVE9fv93meXFNnHlKC9F5NZGouz32zAsaGh1bs61ULGjywjkBwHYM5dLqT7eUigXyw5hat8NEO9GQq8kwFy33vo+jUD2xlhIKlNGdUM6xWM2OZSvq0fM1Q0eLYeJWrEjeSrDoYZOMBfYKmuu6E61WXfVaeV1kDwAAAAAAADhoBIwAAAAAAAAAAAAAAAAAAAAA4IioVytaXphTtVRSs9FQPJFQLHYrfGFCPPmBIZWLy8LG2u2WPYdB4K/Zbs6jG4+v2eZFt805dZ07MY7Ab6tWralRrQrAwynw/ehzpBx9njS0E07MhG9CtRQtoav90g4dxaLnNAGijqLi0e2tBYya0eNNeKke3lq3bR7p4ZSKrqO78waV/HZbzXpNYbC1awEAAAAAAADsNQJGAAAAAAAAAAAAAAAAAAAAAHBEzN64apfHn32/jp18RAMjo3LdW/9sPNfbp+c//Akbpvj+X/65sF5hcc6evyeee3Flm+O5yg8Oq1wsrLmviUGZcxpz7kQ+6tWqrl58R4tzswLwcKqWS5q5dln5oRFpUNsWj4UaTQQq+DFVW9oXQfQdomJ/1WjtrxvNhmk9tPWhXXAiGSrh7PwElgvLWrw5oyAkYAQAAAAAAIDuQsAIAAAAAAAAAAAAAAAAAAAAAPaJ4zhKZ3uUSCaVyfXYKI5ZAr+tMNy9OsTy4rxmrk+qt39wJWDkeXFle/JKZXrkRl/v9nMeBfVaxQYiguBOHMJxXGV7zXnLrrlvPJFQKp2O9sdWtrXbbft4EzIC8HDyo8+BWqVk1zuRjD5bBlKOgmZMs/sUMMLe6I+uY9rVjjUbdTu3woCAEQAAAAAAALqLIwAAAAAAAAAAAAAAAAAAAADAvjAxnKFjx3Xs5Gm970Mf1/GJR5VMpeV6u/u/TTt7Y1Ln33hF7fad6oUXj9vn7h0Y3JPnPArKhaIWbk6r1WisbDPRqaHR4zZitFoqnVNPfkCx2J1/lt9uNe3jy6UlAXg4NRs1FRbn7XonEm5Mj+Q8Dab41Z/D7lRPQo/mk9opEy8ycysgYAQAAAAAAIAuw/+PEwAAAAAAAAAAAAAAAAAAAADsgx//u/+5cr15jRw/Icf1lMv3y4snVC4UtDg3o3aroN2yvDBvwzqB3163L5XKaHBkbNef8yioFAvROWmp1WqubDPRKXO+srm7A0YZew1j7qqAUbulUmFR9drOwiW7LRaLKZFM2ehFe9Vru594Iqlk9BoHj42pt7d/zT4/mldX3zsvPzpWrVoRgDuajboKC3Nq1uvaiXzK04vH++XP1fXdxapweJ0d7lF/Yuchqlq5bOdWGPoCAAAAAAAAugkBIwAAAAAAAAAAAAAAAAAAAADYB09/4MMaHD2uwZFjK9umJy8pl8+ruLyg3VQtF+U4jvz2+siBF4/vyXMeBfV61UaIzNLhuI5yvX1KZbJr7htPJqJtGRuK6gjCwMaL2s2Gukks+mNiWb7vbzpg5Lqu0tHrGz42rqFo3q7WqNc0N31dzYZLwAi4iwl81aplu96JePTZc6o/o0u2XUTA6DAbziY1nN75r3A1m3U7twI/FAAAAAAAANBNCBgBAAAAAAAAAAAAAAAAAAAAwD5o1us2/LJaNp/X6PgpLS/MqbA4r91SWl5UuVhYE+LZjMD3NXN9Un0DQxvuHxgdk+vFNXtjUlsxMDyqM8+8sG775fNvq1GtqBiNtxuY8JAJ/JSWFu016RsclhNzlI/OR7anZ819e/KD9tp50fnoaNUbmo3O3/LinPZbq9FUIRpzvVpbt89xXTtWExuauXZ5U8fzEgn7up/5wEf0xHMfWLPPBLKuvfdutC7fd96auWRCSBsxc2J0fGLLc6mnr19PvfChdduvXTofjae0q+8j7I+jNk/azZbKhSVVoqVcWFY6m4s+N7f+6zvZZFzPjA9oshZTLjanRhhTS45weCQVKB4L9fhIXsd7k9ou898PzUb99pxaUhD4AgAAAAAAALoJASMAAAAAAAAAAAAAAAAAAAAA2Ae+7yu8Kzpg4jepTFaOs7tRimajoe0IgkCNWlXt1sbho3Q6o0Ymo61K53IaGDm2bvuNKxflbzGytJfM6zdaraZazab9OhZdm0QyaSNAq5lt5tqtfbyvujl/zf1/TX7bt2MO/Pa6fWZ+paLr5m+w715c11M8kVT/0IiGx06s2VdcWrD7vPj955mZS/eai4lE0o5pq+LxxIZzaW7mho1P4fA5avPEfA6YxXyOms+3MAy0HV70vs2nk8rEHRvBaSomhcIh4kbXzVw7cx3Nsl1mPpm5ZObUvb4/AwAAAAAAAAeJgBEAAAAAAAAAAAAAAAAAAAAA7AMT62nUKhp/5MzKtr6BYU2cfUqX3nlTh0Eqk1OmufU40qkzT+mn/tH/dt32pbmbWrg5pcWbM+omkxfesVGV4bEvrmwz1+qp939Ic9M3ND9zQz35Pg0fG5fr3QkbmXjR5IVzOgjtdlOVclGt5vbiVfstmc4qk+vRVg2NndhwLv36v/5/6/rl8/b64Og4zPPEfE5cefcNPfbMB5TLJ7Rdw0lHHxly9XpRul4XDpEzPY5OpKJ57GpHlhduavbaZZWLSwIAAAAAAAC60e7+z3QAAAAAAAAAAAAAAAAAAAAAADbUbtbVaqyNy7iep2QqpXg8IcfdYeFgFcdx5MXj2o52qyXfD7RbYrGYzJ+NmNhOs9F9wZ3AN+egvWaba86pF7fn1t6Orpe53WGubXDXY/ZVGCoIgmgVbrjbcb2VsW+Gc/v1uvd4jJknYeDf9xjmPsED7rMVD5pLrS6cS3iwozpPzGsyr22nkp6j3pRn1zhcOtdup8z3llvfY3bvfQIAAAAAAADspp3/LRgAAAAAAAAAAAAAAAAAAAAA4IGuXHhX5WJRH9PfWtk2On7KLu++9opuTl3Vws2ZXQkU9A+PKtfbtyawsxkmtnHjynsaf+SMdkMs5iidzSmRTG24/+rFdzQ/O6VuUyosK37XmFO5Ho2fPqNatRxdq2vqGz5mb3dcfPs1Xbt0QQel3W6rXq1E17C5bp+JFw2OHLPRpc3K9Nx6veZ1r3uu2/PEf8BcNfcx1383dOZSMp3ecP/U1Uv2GuDwOarzZPHmtF1PPP6Mcvk+bdeZwaz+8x96RIuv3NR75ZJweHzy9JA+P9Gr3tT2goIdi9F/G7z39qsqLS8KAAAAAAAA6EYEjAAAAAAAAAAAAAAAAAAAAABgHywv3JTjOKpVq/I8V/FEcmXfwMgxjT/ymIpLi2r4Ne1UJter/MCQXG99sKbVbERjmY/WzQ0eGdo4TbvdsmvHdaIx3zlGuicn329rs8zjsz15pdKZNdsb9ZqCIFQQBupG1UpJicLagJETc6LzGVc622PPbSKxNkhRLiyrXqvqoPjRNTNjaDbq6/bFYrJj32g+3Ess5trHmDm72ur5ET7g+q2ZS07MhpQ6MrmcnRubtTKXUtk12818brd9hdF8wuF0VOdJtVSUG70Wf4dRunj0mvLppHq9mHrdQOXAEdO9uyVjoZJOqHwybq+dG9OONBu16PN9acNAHQAAAAAAANANCBgBAAAAAAAAAAAAAAAAAAAAwD64dum8ysVlGyGIJxLqGxxe2Tf+yBl5XlwX3nzNxn12qm9wSMcnHl0TAumolIuavnppw8eFYWhDCc1oDGZtIktO4k70ZnBoVKlURptl4kdDx8aU610bIKlVyjagFPjdGTAyISm/vTbU5Lpu9NrT6o+um4lIZHJrX9PCzWkVFuZ0UEw8ySzV6NyuE4spmUopHk9u+ngmBGNer3ndq62eHw+y+r4mhpRcNR97+gaiubH5ud6ZS/nBwTXbTRCsEb1uwh6H11GdJ4XFOfuZ36hVtBOZZNwuxzKujsV9XYteQi10hO6VcwMNeoHGsnGN9WW1U9VySfMzN2yICwAAAAAAAOhGBIwAAAAAAAAAAAAAAAAAAAAAYJ+0Wk1dfOtV9fYPrgkYDY6MKZXOaOLsU6qUCpq8cE7b4biuXNfT8LETmjjzlI0idZi4zez1SS3OTj3wOOa+c9M3lB8cUt/AnXHm+gbkJTYfwTHxm+Fj4+rp61+zfXlhXtVyUUHgqxsVFudtMGK1RDKl/MCQPTeVaJ8Xj6/Zb8JQZt9BM+fVXDsTsYrfvlZeNCeOn3pUsVhs08dJp7Maiq5dMr02vmGOvby4+VCTCVWZx2R780qm0ivbTdRqKzGOzlxa/b4xTBBseWFO7SYBo8PsKM4T3w8Uhs3oeW8q09MbvZ9OaCfO9CdVPN6jwlRTtXp3xt9wy4mepJ7vj74XZ+PaCTP3TQirUli28a2wS6N/AAAAAAAAAAEjAAAAAAAAAAAAAAAAAAAAANgnJp5x8e3XNDp+Ss+8+NLK9qFjx+2y04CRiReZaM3w8RP2WF78zj8Zr9cq9rjzM9MPPI4NGM3csMdaHTDK9w/Y0NJmmaDS8NgJ9eTXBoxMkMFEgvx2W93IjO1u8WTKRlFM2KhUWFoXMDLbuyJgVCpF1/iGMrnelYCR68V1fOLRLYVgktF1Hh4bj653es12My9Ky0ubPk6z0bCPCYJQQ6PHV7bnevsUhuGmj9OZS30DQ2u2m2thXm9zC68N3ecozpPAb8s02goLN22UaacBo8f60kqGvr6zsKxZAkZd7URPQh8Zz2oks/OA0UI0b8vFJbVbLQEAAAAAAADdioARAAAAAAAAAAAAAAAAAAAAAOwTEyB4/Tvf0PHTZ/TEcy8qPzBkozgdH/3cT9h1vVpRq9nUD/7qa5s6bsxxlEim9OwPfTRaPqKzz75gj22CRh2lpUW9/Bd/oqX5uQcer1ouavLCO8rkemz4puORs8/YtTm2H72Wcqlwz2OYAE62J6/nPvxx5Xr61uybvXFVs9cn1e7y6MxMNEbHcTVy/ET0Wno0ceZJNeo1LcxNy/XW/nN883oq5bIO2vzslN59/RUbcTFjNhzX0ej4hI1YmXW5tKxKceNrZ2JHud68BoZH7X0TqdSa/WZemPmxWY1a1T4mDAKdfuLple0nH3s8mkNtO5fMvuLy4j2PYeZ2Zy4lUmuDSgs3Z2yYqxG9NhxeR3me3Lh0QcXFBT3xwoe1E6eHenWyP6ffu1xStVbT9Sa/EtRtkrFQw3Ffzwxl9JFHj6k3ndBO1ColXXzj+1qcfXB4EAAAAAAAADhI/G0lAAAAAAAAAAAAAAAAAAAAAOyTdrul5cV55fL9qpZLyuR61+w/dmLCrgdGjqlW2XwMJxaL2VhR38CQTj76uI14JJLJtc/dampxblb1avWBx2s1GzZSYyJKq/X09du1OXbzAccw4zFBERNoMlGc1cwYzOvvdiaq4sVvjT2eSNrFBH1uhaFia+5bj+7batR10JrRGEqFJTvXOkyEKZXJKJXO2nX9PhEXx4nZ65tMpe1972bmhXmtm+X7/oZzKZO9FVcyz2Xucz+OG1+ZS47rrtlnrpGZSw86BrrbUZ4n5rPcROZ2Kn87hpPzYso4odB93Fhor01v0tNgLqWd8tttlYvL9nMdAAAAAAAA6GYEjAAAAAAAAAAAAAAAAAAAAABgn83emNRv//J/p49+5sf00md/XIlkWq535593f+Fn/qENDr3vgx/X8sJNXbt0XsXlBZWWllbuk0pnFE+kNHrilPoGh/TkCx+04aJcb9+6eMdv//IvqbA4r4WbswqDBwc8Fman9fLX/sTGQ06cPhsdM2+DNh1/7+f/ma5dPq8/+tK/le+314R7kqmMjXV84Wf+gQ3mpLM5dWI/JiBSq1b0zuvf09Xzb6vR5VGGG5cvKpnJaPyRMyvbHnn8aY0cP6lcdK7X3PfKRXWD2RtXVVxa0HMf+rgNLpm5cSu4pGiuTOgnf/bn9dp3v6HXvv0NlYuFNWGMVCZnA1g/9nd+Vv0jx9Yct1GvKvB9Oy+2orA4Zx/TqNX0xPM/tOFcMuP9j//qF+85lz7141/UwPCx23Ppls5ceu+t1/TGy39pH3tQfu6f/tfaTX/8678Svf9b9nPiYXGU58n1yxei96Brx29iYrl8n3bib54d0A+NpPTPXl4Sussj+bT+d8/16fGRXu2E+aw14aL5mRvR3H2VQBsAAAAAAAC6HgEjAAAAAAAAAAAAAAAAAAAAANhnQRDamEXBLIvzyuX7lc7kViJG2Z5eGzAZGh2T57mqVkpKJJLRcifoYQJGZpu5T7a3TwPDozZY48XjK/cpl5btemF2ysZqgk3GO8xzm6VSKthxxhOJNTGR/qERtVpNDR0bU7NeV71WXdmXyfXagNLgyDElozHGYo7CMLRLvVZRYWFe7Waz6+NFhn1dsbXbzDmP5WTPtdFqNOzanK9uYMZRq9a0ND+n3v5BGzDqcBxHfQPDGhga1eDoccWTSdUqlZX9Zh6acIy5vulMds1xi0uLNqqx+lpvlnlMtVS851wy8+V+c2lgZNTO743mUrlcPPC5ZM7lbjLnKObE9LA5qvPEfO6apVGtRuN0dhww6ksnouMFSjuhvV0LHr650o3M9Uh5jo7lUsolXO2UmS/me2Wr2RAAAAAAAADQ7QgYAQAAAAAAAAAAAAAAAAAAAMA+89stLc7N6i+//Pt685Xv6FM/8TN64rkXbYDDdW/9M28TIho/fcYuz/zQR7UdX/7NX7MRopf/4k+1Hede/WvNz07p8z/9D/TMiy+tbO+M6/0f/ZSWF+Y1ffXSyr7R8VNKZTI2KrL69TYbdf3gW1/Tt7/6R5q9PqnD4Mbke8r25tds8+IJu3RMXnynqwIT7VbTLt/8k9/R97/Vq5/7p/+1DRkZiWRq5dp94W//rKYmL9mAVsfE2SdtCCaVzq477td+/zd1/fJ5bdfVS+/qd/7tL91zLv1f/+V/vOdcSmd7FIvdirSEQWCjNJ25ND8zpYN25pnntZvS2dxDGy05yvPk7Ve+FY0zq8Fj49qJF07eipJ9+s0p1fzovbkgHLC0G12P6GP28WFXLz4yop0y3y/NfFleuCkAAAAAAADgMCBgBAAAAAAAAAAAAAAAAAAAAAAHxG+1VK9WtDA7pckLGfl+S4lESgMjx7QdJthRr1Xt0qhW7XHN19tlIiqVUtEe5/qlC+ofHlU8kVQimVy5jwnerI4VeYm43dbRbDRUq5Q0c/2KFm/O2NcbBL4OAzNW14vf9z7Nek2Nel3dpnH7uk9NXtbS/E2NnXo0ui6OvFWvJ55IrLl25ro5zq1rF4ahjcCUi8vRUlBxacHOhe3y/fauzKVGdE2mrl1amUsmjoWj4yjPk+LSfPRZUVPgR59/sVj0XnO0E6cHsjZg9M2FisLotq+YsP/c6OybX84y12OsJ62dMvPDLGa+mAAhAAAAAAAAcBgQMAIAAAAAAAAAAAAAAAAAAACAA1IuFezy5d/+NRuW+dRP/JTSmZy+8Lf/obZj9vpVTV44p3dff0WzN67qxpWLare2H+4oLM7b5Su/+yX1DX5FP/mzv6Bcb5+Gx8ZX7tPb12+XjZgYiXm8Gc9f/MFvaHlhzt4+LMw5zD8gADU3fUO1alndxozd+NK/+n+qf2hEf+8X/pkNFvUNDq/cZ3jsxD0fb4IvzUZd3/3an+rSudftNSwVlrRd5cKyXTpz6XNf/Ps6dmJiy3NpavKSfv/X/vWhm0vYnKM8T95+5dvq7R/UJ//G31HMcZRIprQTP/fhRzVTbup33ntbjTCmaugK+y/nBDqeidvrEXd3FqUyboUDC3a+HJbYHwAAAAAAAEDACAAAAAAAAAAAAAAAAAAAAAAOmInFhEGg82/+QPF4QmG0zfU8jY6fkuM49mvXNYurViu6bxjYx4VBqFqlbIMHy4vzWrw5o8W5GS3MTqtcXFbg7078oFRYtM/xzT/+HRvdOPPMC3I8V6l0ZuU+yWRaXjyueq0iP3reaqkUjbWpyfNvR+OZsiGRxgNiQBsxr8mJXvvv/ft/vW7f9UvnbUDIjG0vmDHXq5UNn7vjSvT62tHr3C1f+d3/oEy2Z822+eg1zs1cV2l56wGh4vKims26vvq7/1HJ6HqZGEwqk7Ffd5g5F4vFovs17LVrVKuqRPNn/ua0rr33rpbmbqpZr2k3dObSd//8j5Xrzdu5ZGIu6Wx25T6JRFLxaOnMpVq5bMdm5pKJKG13Lm1XrVLRxbdetddhevKy9tr/3M69xch1H/Yd/81178ubSJEySUe3ynZs15J8qx0jRizbBXp7cFvALw1SuH3oQ4EWyFv71rc+FgVaoE9BHlIgRZGoQQvYVZ04dmXHtqRYIkWJEikuyV0ud5d7n/tMZ0a1ZMNxrCMtV+Ty8yH+/M+cmZ05c85/ZoEF5jta071f8t793jefHsekftbu9uY4XLa2fOOXPuYo7DN63Jee+35areYv3H710qvZ3Ske4hq9B/+q98foeHXb7/59cTeuk19l9DnRau7m6vA9NTkzmw88+Gjei+l6NUemBvnSmdlc3unlhyvvPlbHu/f5U9N5YK4+Ph/lcinv1Wh9jAJGo/Uy+h0PAAAAAHeD0je++qS/ZgEAAAAAAAAAAAAA3EGmZ+dTn5zMxz/9G6lUa5kYXh6FOkbBjkZj560wUb/XHUdLdrY288bFl8fBj9sV8/lZn/zCU8P9qefQseNvbZs7dDiTUzNZX7s53If2OPYyit785V98N9wZpmfn8sFHP5xDR+/L4Z85d1PTc+Pwxs72ZjqtVjbWVrK6dD2XXj2X2220lkZhriMnTv7cfs4M3wM/XUujiFVzZ9tauocdlHUyOT2Tzz7194afnSfyic//Vt6r3XY3z7x8Nf93qZnfe3Ur7L9/96mjOT0/kS996HT2wp/+8R+Mw3nPfuvpAADAQXSjcyj9QSntVLNXGrWpLM2fzfbEfFZmTgUA2GelfHvvfrMDAAAAAAAAAAAAALAnWs1Get1OLrzww5TK5XG4ozwcpVI5/X4vg35/fL/R3Gq2xiGj0c+MbtsPly6cGwdvRpGlnxoFliqVatrtN/enuTt8Db1OuHM0G7u5/sbrWblxLfX62+euUqmNvmAwXnM/XVPtViP74a21dPni2/tTraVWq7+1ltrNZjqddrh3HZR10ut08tq553Lq7MP59U99fvy5PvrcfLdqlXI+cfq+tMsbubC6lau7ybVm2AdPHi1nrlLK46eP5cRMPe/V6PO3P/z8Ha2PbtvnHQAAAAB3FwEjAAAAAAAAAAAAAIA7zChkMBo3rl3JnWh1+Xq4+/R7vWysreROYi3xThyUddIdfq7fvH41E5PT4/fjKEqXSt61UcDo9NHZLG638uB0KTvdgYDRPnlgspQHpso5e2Q6h6f2IGDUezNOOFofg8EgAAAAAHA3ETACAAAAAAAAAAAAAACA22wUpmk1dnPz+kKe/dYf54N/49fza499LO/VR08dyiP3fSx/dG4xU+eXcm6nnJ1eKey9Byb6+cDEIL/zqUfy6LGZPYkXjbz4g+9ka311vD4AAAAA4G4jYAQAAAAAAAAAAAAAAAD7YBQxGo3m7k66nU72wlStOh5z9Uomy4NUtYtum9GxHR3jmVp5z+JFI91Oe7wmRmsDAAAAAO42AkYAAAAAAAAAAAAAAACwTzZvrebZbz6dbruTuUNHM3/0vkzNzOa9+trHz4zHv3j6xfx4cTNL3Wp6AzWjvTBf6edkrZd/8viZ/PYTZ7JXNlZX0tzdzgvf/T+5/sbFAAAAAMDdSMAIAAAAAAAAAAAAAAAA9tnu9mZWFq+mWq/vScDopx46MpVOr5/mSjtb7V7ag3J49+qlfg7XS/nI8dkcn6lnLzWGa2D1xvV02q0AAAAAwN1KwAgAAAAAAAAAAAAAAAD22ZVXz2VteTFf/Adfz7H7H8he+WdPnh4HjP7pH72UxeG81BUwercqGeR4tZcvnj2af/XZD2a6vrdfxTr/3LN55YW/yMbazQAAAADA3UrACAAAAAAAAAAAAAAAAPZZt91OY2crqzeuZ2nhUu47eTrVWi3vVb1aSaVUyufOHM6N7Vb+7NpOWv1ko1sK79yJ+iBz9Uq+9MGj+diJ2UyOjmt5b2JQzd2drK8uZ2t9dbwG+v1+AAAAAOBuJWAEAAAAAAAAAAAAAAAA+6zZ3B2PhYvn02k1c/ipE3sSMJqqVZPhw/zzJ09nZaeVG7fOZb1byk+2K+Gde2y6l+Mz1fzbLz6SvTaKF1147vtZfOP1bKytBAAAAADuZgJGAAAAAAAAAAAAAAAA8D5ZWbya5u5OPvTE59LtdDJ76HD2wlS9mmPD+WsfO51rW+00X13NaruUtU74azw4ncxU3zxu0/W9/erV6Pxub9zKzWtv5PKFF8eXAQAAAOBuJ2AEAAAAAAAAAAAAAAAA75OVpWvjsXVrJRn09y5gVKuOx9c+fiYXbm7lpeurw62DrHVK4Zd7cCY5MVEaH7e91u20s7F6M8vXFsYBIwAAAAA4CASMAAAAAAAAAAAAAAAA4H325//zD1MqlfP1f/lvUi6XU63Vs1fOHJ7Kv/7ND+elGxt5cWkzzy43c2G9k05KGeTeDhpVhkdgND5zYiIfOlzPU4+cyP1zE9lr7VYzN68v5Jn//vvZvLUaAAAAADgoBIwAAAAAAAAAAAAAAADgfba0cGkcMBr0++lnb03XqnnsxFxa7XZ2d3bzl2ullEtJaZAMcm8b5ZtGx+KB6Uoemqvm4WPTuX9+OnttdF7bzUaWr19Jr9sNAAAAABwUAkYAAAAAAAAAAAAAAADwPms3m+P5D//Tv8/Jsw/mC3/nH6VcrqRar2evfOjkkTx8fD5feKydzVYv/+F7r+eN9UbONe69rxjNlvs5O9HPVx49Phwncmy6lkMT1dQqleyldmt4XgeD8XkdXW41dgMAAAAAB4mAEQAAAAAAAAAAAAAAALzPBoPBeN5YW0l9ciq725uZmJze04BRvVoej9EzzdV7efTYVAb9Xq733nzuzXZ/fNsgpRxEb77y5MhEJXO1Ss7ODHJ6vp4PzNUzM1HLRHVv40Ujje2t4bntj89rt9N66zwDAAAAwEEhYAQAAAAAAAAAAAAAAAB3iJuLC2nsbOdPn/6vOfPIR/LEF57KXpudqCXD8bu/+dj4+u8/+0o22r3855fW0xqUsjvY+5DPnWCu3M+xiXJ+95PHcmxmMn/r4ZO53X7wzP/I7vbW+LwCAAAAwEEkYAQAAAAAAAAAAAAAAAB3kF6vk+2NW9m8tZKVxauZnpvP9Ox8bpf756cy2e7lUw/0s9UZ5NpWazi/ebmXUga5O5WHe14ezqNo0USllA/OT+TUTH0cL5qfqud22t3ezO7W5vAcrqa5uxMAAAAAOKgEjAAAAAAAAAAAAAAAAOAO0tjZzsUXn8vajaVsrC7n8d/4cs4+evsCRl/+yJnx/A8/kZxbupX//fK1/OhmKz9eaWerX0k3pdyN6qVBpkr9fOVUPadmqvntzz6W+cla9sPLz30/CxfP55UXfph2qxkAAAAAOKgEjAAAAAAAAAAAAAAAAOAO1NjdytKVS7l0/oXsbm/m7KMfzvTs7QsZjZyYncqnf+1Ezpzo5TM73Zxf3spmq5tX1hpp9ga52a3kTlUpJcervRyZrOSB2YmcPjSVD8xP5tHDtczVypmolnO7rSxdzcritSy8ej5LC5fS63UDAAAAAAeZgBEAAAAAAAAAAAAAAADcgRo72+NRn5zM+upy7jv5gdseMLpvdnI8fuqb5xZyY7ORVmM3t1qjgFHuWJUMcqrez6/N1fPpU5P5+Omjw3Es+2kUL7rw/Pdz5eL5rC0vBgAAAAAOOgEjAAAAAAAAAAAAAAAAuIOtLS9le309c0f+LIePHc8TX/hy9svHTh/LQ61Ozp44kt1uP9d3e7m128qFGxu51epmtdHNejvZ6SWNwSghdHtVh89QL/VzpJZMV5OzcxOpV0r57IMnUiuV8sBMJTO1co5P13JkZiL7ZWP1Zl4793wWXj2fK8OxvXkrAAAAAHAvEDACAAAAAAAAAAAAAACAO9j2xpsxnMXLr2br1sq+BoxOzk+P54ePJ73+ILd2m7mx1Ui9vZOFzV5qvUF6vaTbT5qDQQYp5XYqDx9+ojQYB4xG45G5Ug5NVPP3HzkyvK2UozOTeT902q0sXDyfpYVLWbu5GAAAAAC4VwgYAQAAAAAAAAAAAAAAwF3g0ss/SaVSzc7membnj+Rvf/0bKZcrqdbr2Q+VcilHpyfG48yRufT6/XQHyXBKbzhfWttKt9fL5dXtrDc7uXBz662fXdjpZaM9eEfPc3qmksP1t0NInzlzNFO1au6fn8zcZD0n56ZTGd5cLifV0mi/ypmtV7Lf2q1mttfX8r/+4L+k3Wxm8crr6fW6AQAAAIB7iYARAAAAAAAAAAAAAAAA3AV63e54bK3fymAweHPknUWB9kp5VA0amp8s/8JtjWYjnV45WzuVVAb9zFTfjhBNVZLd0jvb19FD/+zPHpusZKpWyf3TtRyaqufU/ETuCP//HIzOR3v42kdBIwAAAAC415S+8dUn9/evlAAAAAAAAAAAAAAAAMB7Uq5UMn/kWB587OP5zFN/NzPzhzN76HC4/daWl9JpNfP07/3HbK2vZfPWagAAgF/tRudQ+oNS2qlmrzRqU1maP5vtifmszJwKALDPSvn23v1mBwAAAAAAAAAAAAAAAPZNt9NOY2cz1y9fzJETJ9Pv9zI9dyjVqq8M3Q6txm5azUaWr14eHvftNLY3x+cAAAAAAO5l/hoJAAAAAAAAAAAAAAAAd5l+r5ftjfW8/PwPxuORjz4+HE/kw09+LvNHjoW9d3NxIddefyU/eOZPsra8FAAAAABAwAgAAAAAAAAAAAAAAADuelu31nLt0quZmJrO7KEjOXX24dQnJlObmAjvzmAwSKfVyu72ZlaWrubG1cu5sXA53U47AAAAAMCbBIwAAAAAAAAAAAAAAADgLnfj2hvjcfP6QianZ/KVf/w7mZ0/LGD0Hgz6/TR2trJw8Xx+/J1vZn1lOeurywEAAAAA3iZgBAAAAAAAAAAAAAAAAAfEKLBT3ajnO3/y3zIzN5eHP/pEZg8dzumHHgvv3MvPfT/dTisXf/JctjfWsrJ4Le12IwAAAADAzxMwAgAAAAAAAAAAAAAAgAOiubsz/H8nr59/LpNTs5k9dGS47YSAUUE3Fi6l1djNhRd+kF63m067FQAAAADgFwkYAQAAAAAAAAAAAAAAwAHTabXT723l+e8+k4mpqVx86cc5eebB4Xgoxx84nUNHj4e33VxcyMbqSi6++KNsb67n2muvpNftpN1sZjDoBwAAAAD4qwkYAQAAAAAAAAAAAAAAwAHT7/fSb/eyvtpMtVZLq9lIrVbP3KEjOXriZPh5jZ3t7Gzeyo2Fy8NjtjweAAAAAMCvJmAEAAAAAAAAAAAAAAAAB1i308n6ynKeX3kmz3/3mUzPzqc+OZlPfO63cvi+E/mbw/les72xntde+nEuX3hxPHa3NtNuNQMAAAAAFCNgBAAAAAAAAAAAAAAAAPeQQfrp93vZ3d5MfWIyG2s3x9tHl6vVeiq1WkrD66VyOQdBv98fz63GzngehYoa21tvRouazfGxGAz/AQAAd5/yoJ9qv5N6t5XJzm4AgP3VK1dT+sZXn/TXNQAAAAAAAAAAAAAAALhHTU7PjONFH/nk53L8gTN5+COPZ2Jqerz9INjeWE+v28lzf/6tbK2v5dyPvjeOFo3iRQAAwP650TmU/qCUdqoBAA6GQfJtv9kBAAAAAAAAAAAAAADgHtbrdtNOMzevLaTVaKS128jUzFymZmdz6Oh9qVRrmZ6dT6VWy+TUdO5U/X5/uP+76bRb2d3eTLOxM3wtu9m8tZJuu5OlK6+l1WyOX+9g0A8AAAAA8N4JGAEAAAAAAAAAAAAAAMA9bBT8GY3Xzj3/1rbZ+cOZPXQkj3z08fF8+qHHMjE5fUcHjAb9fjbXVrKxejOLV17LyuLVrCxdy9ryYtqtZgAAAACAvSdgBAAAAAAAAAAAAAAAAPycUfBne+NWrrx6PvXJySxfu5JqtZ65o0dTrdUyO39kuH0q9YnJTM/Oj+eJ4fVSuZzJ6ZnstX6vN96nXrc7ji3tbm+Orzd2tofbOllfXR7fZ+vWWpqN3eG+r43vs7u1Of4ZAAAAAOD2EDACAAAAAAAAAAAAAAAAfs4oDjSOGG2uv7WtVCplYmp6HCg6eebBzM4fzuyhI7nv5OnxPH/0WMrlyu0JGPX7aTV20242x2GilcWF8b6tLS+O9/PyhRczGAzG9wEAAAAA9o+AEQAAAAAAAAAAAAAAAPCrDTIOCHXb7VxpNlKp1lKpVFOfnByHi6q1+vhulVotteHlucNHU668vb2oxvZmev1etjfWh8/dT6/bS394vd/rpd1qDOd+up32eNtov0YBIwAAAABgfwkYAQAAAAAAAAAAAAAAAL/SYPSv/2ZEqLvd+WvvW5+YzNETp1KpVFIbXn43Nm+tjp9rfWU5AAAAAMCdScAIAAAAAAAAAAAAAAAA2FPtVjM3FxdSGl0plfJu9Hu9AAAAAAB3NgEjAAAAAAAAAAAAAAAAYM/1ut0AAAAAAAdbOQAAAAAAAAAAAAAAAAAAAAAAAAUJGAEAAAAAAAAAAAAAAAAAAAAAAIUJGAEAAAAAAAAAAAAAAAAAAAAAAIUJGAEAAAAAAAAAAAAAAAAAAAAAAIUJGAEAAAAAAAAAAAAAAAAAAAAAAIUJGAEAAAAAAAAAAAAAAAAAAAAAAIUJGAEAAAAAAAAAAAAAAAAAAAAAAIUJGAEAAAAAAAAAAAAAAAAAAAAAAIUJGAEAAAAAAAAAAAAAAAAAAAAAAIUJGAEAAAAAAAAAAAAAAAAAAAAAAIUJGAEAAAAAAAAAAAAAAAAAAAAAAIUJGAEAAAAAAAAAAAAAAAAAAAAAAIUJGAEAAAAAAAAAAAAAAAAAAAAAAIUJGAEAAAAAAAAAAAAAAAAAAAAAAIUJGAEAAAAAAAAAAAAAAAAAAAAAAIUJGAEAAAAAAAAAAAAAAAAAAAAAAIUJGAEAAAAAAAAAAAAAAAAAAAAAAIUJGAEAAAAAAAAAAAAAAAAAAAAAAIUJGAEAAAAAAAAAAAAAAAAAAAAAAIUJGAEAAAAAAAAAAAAAAAAAAAAAAIUJGAEAAAAAAAAAAAAAAAAAAAAAAIUJGAEAAAAAAAAAAAAAAAAAAAAAAIUJGAEAAAAAAAAAAAAAAAAAAAAAAIVVAwAAAAAAAAAAAAAAAAAAAHAbzZSbGaSUXsoBAA6KgYARAAAAAAAAAAAAAAAAAAAAcHvNVloBAA4eaUIAAAAAAAAAAAAAAAAAAAAAAKAwASMAAAAAAAAAAAAAAAAAAAAAAKAwASMAAAAAAAAAAAAAAAAAAAAAAKAwASMAAAAAAAAAAAAAAAAAAAAAAKAwASMAAAAAAAAAAAAAAAAAAAAAAKAwASMAAAAAAAAAAAAAAAAAAAAAAKAwASMAAAAAAAAAAAAAAAAAAAAAAKAwASMAAAAAAAAAAAAAAAAAAAAAAKAwASMAAAAAAAAAAAAAAAAAAAAAAKAwASMAAAAAAAAAAAAAAAAAAAAAAKAwASMAAAAAAAAAAAAAAAAAAAAAAKAwASMAAAAAAAAAAAAAAAAAAAAAAKAwASMAAAAAAAAAAAAAAAAAAAAAAKAwASMAAAAAAAAAAAAAAAAAAAAAAKAwASMAAAAAAAAAAAAAAAAAAAAAAKAwASMAAAAAAAAAAAAAAAAAAAAAAKAwASMAAAAAAAAAAAAAAAAAAAAAAKAwASMAAAAAAAAAAAAAAAAAAAAAAKAwASMAAAAAAAAAAAAAAAAAAAAAAKAwASMAAAAAAAAAAAAAAAAAAAAAAKAwASMAAAAAAAAAAAAAAAAAAAAAAKAwASMAAAAAAAAAAAAAAAAAAAAAAKAwASMAAAAAAAAAAAAAAAAAAAAAAKAwASMAAAAAAAAAAAAAAAAAAAAAAKAwASMAAAAAAAAAAAAAAAAAAAAAAKAwASMAAAAAAAAAAAAAAAAAAAAAAKAwASMAAAAAAAAAAAAAAAAAAAAAAKAwASMAAAAAAAAAAAAAAAAAAAAAAKAwASMAAAAAAAAAAAAAAAAAAAAAAKAwASMAAAAAAAAAAAAAAAAAAAAAAKAwASMAAAAAAAAAAAAAAAAAAAAAAKAwASMAAAAAAAAAAAAAAAAAAAAAAKAwASMAAAAAAAAAAAAAAAAAAAAAAKAwASMAAAAAAAAAAAAAAAAAAAAAAKAwASMAAAAAAAAAAAAAAAAAAAAAAKAwASMAAAAAAAAAAAAAAAAAAAAAAKAwASMAAAAAAAAAAAAAAAAAAAAAAKAwASMAAAAAAAAAAAAAAAAAAAAAAKAwASMAAAAAAAAAAAAAAAAAAAAAAKAwASMAAAAAAAAAAAAAAAAAAAAAAKAwASMAAAAAAAAAAAAAAAAAAAAAAKAwASMAAAAAAAAAAAAAAAAAAAAAAKAwASMAAAAAAAAAAAAAAAAAAAAAAKAwASMAAAAAAAAAAAAAAAAAAAAAAKAwASMAAAAAAAAAAAAAAAAAAAAAAKAwASMAAAAAAAAAAAAAAAAAAAAAAKAwASMAAAAAAAAAAAAAAAAAAAAAAKAwASMAAAAAAAAAAAAAAAAAAAAAAKAwASMAAAAAAAAAAAAAAAAAAAAAAKAwASMAAAAAAAAAAAAAAAAAAAAAAKAwASMAAAAAAAAAAAAAAAAAAAAAAKAwASMAAAAAAAAAAAAAAAAAAAAAAKAwASMAAAAAAAAAAAAAAAAAAAAAAKAwASMAAAAAAAAAAAAAAAAAAAAAAKAwASMAAAAAAAAAAAAAAAAAAAAAAKAwASMAAAAAAAAAAAAAAAAAAAAAAKAwASMAAAAAAAAAAAAAAAAAAAAAAKAwASMAAAAAAAAAAAAAAAAAAAAAAKAwASMAAAAAAAAAAAAAAAAAAAAAAKAwASMAAAAAAAAAAAAAAAAAAAAAAKAwASMAAAAAAAAAAAAAAAAAAAAAAKAwASMAAAAAAAAAAAAAAAAAAAAAAKAwASMAAAAAAAAAAAAAAAAAAAAAAKAwASMAAAAAAAAAAAAAAAAAAAAAAKAwASMAAAAAAAAAAAAAAAAAAAAAAKAwASMAAAAAAAAAAAAAAAAAAAAAAKAwASMAAAAAAAAAAAAAAAAAAAAAAKAwASMAAAAAAAAAAAAAAAAAAAAAAKAwASMAAAAAAAAAAAAAAAAAAAAAAKAwASMAAAAAAAAAAAAAAAAAAAAAAKAwASMAAAAAAAAAAAAAAAAAAAAAAKAwASMAAAAAAAAAAAAAAAAAAAAAAKAwASMAAAAAAAAAAAAAAAAAAAAAAKAwASMAAAAAAAAAAAAAAAAAAAAAAKAwASMAAAAAAAAAAAAAAAAAAAAAAKAwASMAAAAAAAAAAAAAAAAAAAAAAKAwASMAAAAAAAAAAAAAAAAAAAAAAKAwASMAAAAAAAAAAAAAAAAAAAAAAKAwASMAAAAAAAAAAAAAAAAAAAAAAKAwASMAAAAAAAAAAAAAAAAAAAAAAKAwASMAAAAAAAAAAAAAAAAAAAAAAKAwASMAAAAAAAAAAAAAAAAAAAAAAKAwASMAAAAAAAAAAAAAAAAAAAAAAKAwASMAAAAAAAAAAAAAAAAAAAAAAKAwASMAAAAAAAAAAAAAAAAAAAAAAKAwASMAAAAAAAAAAAAAAAAAAAAAAKAwASMAAAAAAAAAAAAAAAAAAAAAAKAwASMAAAAAAAAAAAAAAAAAAAAAAKAwASMAAAAAAAAAAAAAAAAAAAAAAKAwASMAAAAAAAAAAAAAAAAAAAAAAKAwASMAAAAAAAAAAAAAAAAAAAAAAKAwASMAAAAAAAAAAAAAAAAAAAAAAKAwASMAAAAAAAAAAAAAAAAAAAAAAKAwASMAAAAAAAAAAAAAAAAAAAAAAKAwASMAAAAAAAAAAAAAAAAAAAAAAKAwASMAAAAAAAAAAAAAAAAAAAAAAKAwASMAAAAAAAAAAAAAAAAAAAAAAKAwASMAAAAAAAAAAAAAAAAAAAAAAKAwASMAAAAAAAAAAAAAAAAAAAAAAKAwASMAAAAAAAAAAAAAAAAAAAAAAKAwASMAAAAAAAAAAAAAAAAAAAAAAKAwASMAAAAAAAAAAAAAAAAAAAAAAKAwASMAAAAAAAAAAAAAAAAAAAAAAKAwASMAAAAAAAAAAAAAAAAAAAAAAKAwASMAAAAAAAAAAAAAAAAAAAAAAKAwASMAAAAAAAAAAAAAAAAAAAAAAKAwASMAAAAAAAAAAAAAAAAAAAAAAKAwASMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOD2+3/lyrp5tF5jWQAAAABJRU5ErkJggg=="

/***/ }),
/* 25 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_Accordion_vue__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_61beeda4_hasScoped_false_node_modules_vue_loader_lib_selector_type_template_index_0_Accordion_vue__ = __webpack_require__(32);
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_Accordion_vue__["a" /* default */],
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_61beeda4_hasScoped_false_node_modules_vue_loader_lib_selector_type_template_index_0_Accordion_vue__["a" /* default */],
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)

/* harmony default export */ __webpack_exports__["a"] = (Component.exports);


/***/ }),
/* 26 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__AccordionGroup__ = __webpack_require__(27);
//
//
//
//
//
//


/* harmony default export */ __webpack_exports__["a"] = ({
    name: 'Accordion',
    props: ['callouts'],
    components: {
        AccordionGroup: __WEBPACK_IMPORTED_MODULE_0__AccordionGroup__["a" /* default */]
    }
});

/***/ }),
/* 27 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_AccordionGroup_vue__ = __webpack_require__(30);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_7a9f48a1_hasScoped_true_node_modules_vue_loader_lib_selector_type_template_index_0_AccordionGroup_vue__ = __webpack_require__(31);
function injectStyle (ssrContext) {
  __webpack_require__(28)
}
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* styles */
var __vue_styles__ = injectStyle
/* scopeId */
var __vue_scopeId__ = "data-v-7a9f48a1"
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_AccordionGroup_vue__["a" /* default */],
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_7a9f48a1_hasScoped_true_node_modules_vue_loader_lib_selector_type_template_index_0_AccordionGroup_vue__["a" /* default */],
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)

/* harmony default export */ __webpack_exports__["a"] = (Component.exports);


/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(29);
if(typeof content === 'string') content = [[module.i, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var update = __webpack_require__(2)("edccb50a", content, true);

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(1)(undefined);
// imports


// module
exports.push([module.i, ".accordion-title[data-v-7a9f48a1]{cursor:pointer;background-color:#0078ae;color:#fff;padding:5px 10px;margin:0;border-bottom:1px solid #fff}.accordion-content[data-v-7a9f48a1]{color:#0078ae;max-height:0;opacity:0;visibility:hidden;margin:0;padding:0;overflow:hidden;transition:opacity .3s ease-out,max-height .5s cubic-bezier(0,1.05,0,1),visibility .2s}.accordion-content.active[data-v-7a9f48a1]{max-height:1000px;overflow:hidden;opacity:1;visibility:visible;transition:opacity .3s ease-in,max-height .3s ease-in,visibility .2s}p[data-v-7a9f48a1]{margin:5px 0;padding:5px 10px}", ""]);

// exports


/***/ }),
/* 30 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
//
//
//
//
//
//
//
//
//

/* harmony default export */ __webpack_exports__["a"] = ({
    name: 'AccordionGroup',
    props: ['callout'],
    methods: {
        toggle() {
            this.callout.show = this.callout.show === false;
        }
    }
});

/***/ }),
/* 31 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"accordion-group"},[_c('h2',{staticClass:"accordion-title",on:{"click":_vm.toggle}},[_vm._v(_vm._s(_vm.callout.title))]),_vm._v(" "),_c('div',{staticClass:"accordion-content",class:{'active': _vm.callout.show}},[_c('p',[_vm._v(_vm._s(_vm.callout.text))])])])}
var staticRenderFns = []
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);

/***/ }),
/* 32 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"accordion"},_vm._l((_vm.callouts),function(callout){return _c('accordion-group',{key:callout.slug,attrs:{"callout":callout}})}))}
var staticRenderFns = []
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);

/***/ }),
/* 33 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{attrs:{"id":"app"}},[_c('link',{attrs:{"href":"https://fonts.googleapis.com/css?family=Oswald:300,500","rel":"stylesheet"}}),_vm._v(" "),_c('house',{attrs:{"callouts":_vm.callouts}}),_vm._v(" "),_c('accordion',{attrs:{"callouts":_vm.callouts}})],1)}
var staticRenderFns = []
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);

/***/ })
/******/ ]);
//# sourceMappingURL=saws-house.js.map
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm1haW4uanMiLCJzYXdzLWhvdXNlLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJtYWluLm1pbi5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuKGZ1bmN0aW9uICgkKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIGdvdG9TZWN0aW9uID0gZnVuY3Rpb24gZ290b1NlY3Rpb24oZSkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgdmFyICR0aGF0ID0gJCh0aGlzKTtcbiAgICAgICAgdmFyIHRhcmdldCA9ICR0aGF0LmF0dHIoJ2hyZWYnKTtcbiAgICAgICAgdmFyICRjb250ZW50ID0gJCgnYm9keSwgaHRtbCcpO1xuICAgICAgICB2YXIgJHRhcmdldCA9ICQodGFyZ2V0KTtcblxuICAgICAgICBjb25zb2xlLmxvZyh0YXJnZXQpO1xuXG4gICAgICAgICRjb250ZW50LnN0b3AoKS5hbmltYXRlKHtcbiAgICAgICAgICAgICdzY3JvbGxUb3AnOiAkdGFyZ2V0LnBvc2l0aW9uKCkudG9wIC0gNTBcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgICQoJy5zbW9vdGgtc2Nyb2xsIGEnKS5vbignY2xpY2snLCBnb3RvU2VjdGlvbik7XG59KShqUXVlcnkpOyIsIi8qKioqKiovIChmdW5jdGlvbihtb2R1bGVzKSB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbi8qKioqKiovIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0aTogbW9kdWxlSWQsXG4vKioqKioqLyBcdFx0XHRsOiBmYWxzZSxcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbi8qKioqKiovIFx0XHRtb2R1bGUubCA9IHRydWU7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG4vKioqKioqL1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4vKioqKioqLyBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuLyoqKioqKi8gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHtcbi8qKioqKiovIFx0XHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcbi8qKioqKiovIFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcbi8qKioqKiovIFx0XHRcdFx0Z2V0OiBnZXR0ZXJcbi8qKioqKiovIFx0XHRcdH0pO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuLyoqKioqKi8gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuLyoqKioqKi8gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuLyoqKioqKi8gXHRcdHJldHVybiBnZXR0ZXI7XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSA0KTtcbi8qKioqKiovIH0pXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gKFtcbi8qIDAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLyogZ2xvYmFscyBfX1ZVRV9TU1JfQ09OVEVYVF9fICovXG5cbi8vIHRoaXMgbW9kdWxlIGlzIGEgcnVudGltZSB1dGlsaXR5IGZvciBjbGVhbmVyIGNvbXBvbmVudCBtb2R1bGUgb3V0cHV0IGFuZCB3aWxsXG4vLyBiZSBpbmNsdWRlZCBpbiB0aGUgZmluYWwgd2VicGFjayB1c2VyIGJ1bmRsZVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIG5vcm1hbGl6ZUNvbXBvbmVudCAoXG4gIHJhd1NjcmlwdEV4cG9ydHMsXG4gIGNvbXBpbGVkVGVtcGxhdGUsXG4gIGluamVjdFN0eWxlcyxcbiAgc2NvcGVJZCxcbiAgbW9kdWxlSWRlbnRpZmllciAvKiBzZXJ2ZXIgb25seSAqL1xuKSB7XG4gIHZhciBlc01vZHVsZVxuICB2YXIgc2NyaXB0RXhwb3J0cyA9IHJhd1NjcmlwdEV4cG9ydHMgPSByYXdTY3JpcHRFeHBvcnRzIHx8IHt9XG5cbiAgLy8gRVM2IG1vZHVsZXMgaW50ZXJvcFxuICB2YXIgdHlwZSA9IHR5cGVvZiByYXdTY3JpcHRFeHBvcnRzLmRlZmF1bHRcbiAgaWYgKHR5cGUgPT09ICdvYmplY3QnIHx8IHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBlc01vZHVsZSA9IHJhd1NjcmlwdEV4cG9ydHNcbiAgICBzY3JpcHRFeHBvcnRzID0gcmF3U2NyaXB0RXhwb3J0cy5kZWZhdWx0XG4gIH1cblxuICAvLyBWdWUuZXh0ZW5kIGNvbnN0cnVjdG9yIGV4cG9ydCBpbnRlcm9wXG4gIHZhciBvcHRpb25zID0gdHlwZW9mIHNjcmlwdEV4cG9ydHMgPT09ICdmdW5jdGlvbidcbiAgICA/IHNjcmlwdEV4cG9ydHMub3B0aW9uc1xuICAgIDogc2NyaXB0RXhwb3J0c1xuXG4gIC8vIHJlbmRlciBmdW5jdGlvbnNcbiAgaWYgKGNvbXBpbGVkVGVtcGxhdGUpIHtcbiAgICBvcHRpb25zLnJlbmRlciA9IGNvbXBpbGVkVGVtcGxhdGUucmVuZGVyXG4gICAgb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnMgPSBjb21waWxlZFRlbXBsYXRlLnN0YXRpY1JlbmRlckZuc1xuICB9XG5cbiAgLy8gc2NvcGVkSWRcbiAgaWYgKHNjb3BlSWQpIHtcbiAgICBvcHRpb25zLl9zY29wZUlkID0gc2NvcGVJZFxuICB9XG5cbiAgdmFyIGhvb2tcbiAgaWYgKG1vZHVsZUlkZW50aWZpZXIpIHsgLy8gc2VydmVyIGJ1aWxkXG4gICAgaG9vayA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICAvLyAyLjMgaW5qZWN0aW9uXG4gICAgICBjb250ZXh0ID1cbiAgICAgICAgY29udGV4dCB8fCAvLyBjYWNoZWQgY2FsbFxuICAgICAgICAodGhpcy4kdm5vZGUgJiYgdGhpcy4kdm5vZGUuc3NyQ29udGV4dCkgfHwgLy8gc3RhdGVmdWxcbiAgICAgICAgKHRoaXMucGFyZW50ICYmIHRoaXMucGFyZW50LiR2bm9kZSAmJiB0aGlzLnBhcmVudC4kdm5vZGUuc3NyQ29udGV4dCkgLy8gZnVuY3Rpb25hbFxuICAgICAgLy8gMi4yIHdpdGggcnVuSW5OZXdDb250ZXh0OiB0cnVlXG4gICAgICBpZiAoIWNvbnRleHQgJiYgdHlwZW9mIF9fVlVFX1NTUl9DT05URVhUX18gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNvbnRleHQgPSBfX1ZVRV9TU1JfQ09OVEVYVF9fXG4gICAgICB9XG4gICAgICAvLyBpbmplY3QgY29tcG9uZW50IHN0eWxlc1xuICAgICAgaWYgKGluamVjdFN0eWxlcykge1xuICAgICAgICBpbmplY3RTdHlsZXMuY2FsbCh0aGlzLCBjb250ZXh0KVxuICAgICAgfVxuICAgICAgLy8gcmVnaXN0ZXIgY29tcG9uZW50IG1vZHVsZSBpZGVudGlmaWVyIGZvciBhc3luYyBjaHVuayBpbmZlcnJlbmNlXG4gICAgICBpZiAoY29udGV4dCAmJiBjb250ZXh0Ll9yZWdpc3RlcmVkQ29tcG9uZW50cykge1xuICAgICAgICBjb250ZXh0Ll9yZWdpc3RlcmVkQ29tcG9uZW50cy5hZGQobW9kdWxlSWRlbnRpZmllcilcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gdXNlZCBieSBzc3IgaW4gY2FzZSBjb21wb25lbnQgaXMgY2FjaGVkIGFuZCBiZWZvcmVDcmVhdGVcbiAgICAvLyBuZXZlciBnZXRzIGNhbGxlZFxuICAgIG9wdGlvbnMuX3NzclJlZ2lzdGVyID0gaG9va1xuICB9IGVsc2UgaWYgKGluamVjdFN0eWxlcykge1xuICAgIGhvb2sgPSBpbmplY3RTdHlsZXNcbiAgfVxuXG4gIGlmIChob29rKSB7XG4gICAgdmFyIGZ1bmN0aW9uYWwgPSBvcHRpb25zLmZ1bmN0aW9uYWxcbiAgICB2YXIgZXhpc3RpbmcgPSBmdW5jdGlvbmFsXG4gICAgICA/IG9wdGlvbnMucmVuZGVyXG4gICAgICA6IG9wdGlvbnMuYmVmb3JlQ3JlYXRlXG4gICAgaWYgKCFmdW5jdGlvbmFsKSB7XG4gICAgICAvLyBpbmplY3QgY29tcG9uZW50IHJlZ2lzdHJhdGlvbiBhcyBiZWZvcmVDcmVhdGUgaG9va1xuICAgICAgb3B0aW9ucy5iZWZvcmVDcmVhdGUgPSBleGlzdGluZ1xuICAgICAgICA/IFtdLmNvbmNhdChleGlzdGluZywgaG9vaylcbiAgICAgICAgOiBbaG9va11cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gcmVnaXN0ZXIgZm9yIGZ1bmN0aW9hbCBjb21wb25lbnQgaW4gdnVlIGZpbGVcbiAgICAgIG9wdGlvbnMucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyV2l0aFN0eWxlSW5qZWN0aW9uIChoLCBjb250ZXh0KSB7XG4gICAgICAgIGhvb2suY2FsbChjb250ZXh0KVxuICAgICAgICByZXR1cm4gZXhpc3RpbmcoaCwgY29udGV4dClcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGVzTW9kdWxlOiBlc01vZHVsZSxcbiAgICBleHBvcnRzOiBzY3JpcHRFeHBvcnRzLFxuICAgIG9wdGlvbnM6IG9wdGlvbnNcbiAgfVxufVxuXG5cbi8qKiovIH0pLFxuLyogMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vKlxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xuLy8gY3NzIGJhc2UgY29kZSwgaW5qZWN0ZWQgYnkgdGhlIGNzcy1sb2FkZXJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHVzZVNvdXJjZU1hcCkge1xuXHR2YXIgbGlzdCA9IFtdO1xuXG5cdC8vIHJldHVybiB0aGUgbGlzdCBvZiBtb2R1bGVzIGFzIGNzcyBzdHJpbmdcblx0bGlzdC50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuXHRcdHJldHVybiB0aGlzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuXHRcdFx0dmFyIGNvbnRlbnQgPSBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0sIHVzZVNvdXJjZU1hcCk7XG5cdFx0XHRpZiAoaXRlbVsyXSkge1xuXHRcdFx0XHRyZXR1cm4gXCJAbWVkaWEgXCIgKyBpdGVtWzJdICsgXCJ7XCIgKyBjb250ZW50ICsgXCJ9XCI7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gY29udGVudDtcblx0XHRcdH1cblx0XHR9KS5qb2luKFwiXCIpO1xuXHR9O1xuXG5cdC8vIGltcG9ydCBhIGxpc3Qgb2YgbW9kdWxlcyBpbnRvIHRoZSBsaXN0XG5cdGxpc3QuaSA9IGZ1bmN0aW9uIChtb2R1bGVzLCBtZWRpYVF1ZXJ5KSB7XG5cdFx0aWYgKHR5cGVvZiBtb2R1bGVzID09PSBcInN0cmluZ1wiKSBtb2R1bGVzID0gW1tudWxsLCBtb2R1bGVzLCBcIlwiXV07XG5cdFx0dmFyIGFscmVhZHlJbXBvcnRlZE1vZHVsZXMgPSB7fTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBpZCA9IHRoaXNbaV1bMF07XG5cdFx0XHRpZiAodHlwZW9mIGlkID09PSBcIm51bWJlclwiKSBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2lkXSA9IHRydWU7XG5cdFx0fVxuXHRcdGZvciAoaSA9IDA7IGkgPCBtb2R1bGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgaXRlbSA9IG1vZHVsZXNbaV07XG5cdFx0XHQvLyBza2lwIGFscmVhZHkgaW1wb3J0ZWQgbW9kdWxlXG5cdFx0XHQvLyB0aGlzIGltcGxlbWVudGF0aW9uIGlzIG5vdCAxMDAlIHBlcmZlY3QgZm9yIHdlaXJkIG1lZGlhIHF1ZXJ5IGNvbWJpbmF0aW9uc1xuXHRcdFx0Ly8gIHdoZW4gYSBtb2R1bGUgaXMgaW1wb3J0ZWQgbXVsdGlwbGUgdGltZXMgd2l0aCBkaWZmZXJlbnQgbWVkaWEgcXVlcmllcy5cblx0XHRcdC8vICBJIGhvcGUgdGhpcyB3aWxsIG5ldmVyIG9jY3VyIChIZXkgdGhpcyB3YXkgd2UgaGF2ZSBzbWFsbGVyIGJ1bmRsZXMpXG5cdFx0XHRpZiAodHlwZW9mIGl0ZW1bMF0gIT09IFwibnVtYmVyXCIgfHwgIWFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaXRlbVswXV0pIHtcblx0XHRcdFx0aWYgKG1lZGlhUXVlcnkgJiYgIWl0ZW1bMl0pIHtcblx0XHRcdFx0XHRpdGVtWzJdID0gbWVkaWFRdWVyeTtcblx0XHRcdFx0fSBlbHNlIGlmIChtZWRpYVF1ZXJ5KSB7XG5cdFx0XHRcdFx0aXRlbVsyXSA9IFwiKFwiICsgaXRlbVsyXSArIFwiKSBhbmQgKFwiICsgbWVkaWFRdWVyeSArIFwiKVwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGxpc3QucHVzaChpdGVtKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cdHJldHVybiBsaXN0O1xufTtcblxuZnVuY3Rpb24gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtLCB1c2VTb3VyY2VNYXApIHtcblx0dmFyIGNvbnRlbnQgPSBpdGVtWzFdIHx8ICcnO1xuXHR2YXIgY3NzTWFwcGluZyA9IGl0ZW1bM107XG5cdGlmICghY3NzTWFwcGluZykge1xuXHRcdHJldHVybiBjb250ZW50O1xuXHR9XG5cblx0aWYgKHVzZVNvdXJjZU1hcCAmJiB0eXBlb2YgYnRvYSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdHZhciBzb3VyY2VNYXBwaW5nID0gdG9Db21tZW50KGNzc01hcHBpbmcpO1xuXHRcdHZhciBzb3VyY2VVUkxzID0gY3NzTWFwcGluZy5zb3VyY2VzLm1hcChmdW5jdGlvbiAoc291cmNlKSB7XG5cdFx0XHRyZXR1cm4gJy8qIyBzb3VyY2VVUkw9JyArIGNzc01hcHBpbmcuc291cmNlUm9vdCArIHNvdXJjZSArICcgKi8nO1xuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIFtjb250ZW50XS5jb25jYXQoc291cmNlVVJMcykuY29uY2F0KFtzb3VyY2VNYXBwaW5nXSkuam9pbignXFxuJyk7XG5cdH1cblxuXHRyZXR1cm4gW2NvbnRlbnRdLmpvaW4oJ1xcbicpO1xufVxuXG4vLyBBZGFwdGVkIGZyb20gY29udmVydC1zb3VyY2UtbWFwIChNSVQpXG5mdW5jdGlvbiB0b0NvbW1lbnQoc291cmNlTWFwKSB7XG5cdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuXHR2YXIgYmFzZTY0ID0gYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKTtcblx0dmFyIGRhdGEgPSAnc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsJyArIGJhc2U2NDtcblxuXHRyZXR1cm4gJy8qIyAnICsgZGF0YSArICcgKi8nO1xufVxuXG4vKioqLyB9KSxcbi8qIDIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLypcbiAgTUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcbiAgQXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuICBNb2RpZmllZCBieSBFdmFuIFlvdSBAeXl4OTkwODAzXG4qL1xuXG52YXIgaGFzRG9jdW1lbnQgPSB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnXG5cbmlmICh0eXBlb2YgREVCVUcgIT09ICd1bmRlZmluZWQnICYmIERFQlVHKSB7XG4gIGlmICghaGFzRG9jdW1lbnQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgJ3Z1ZS1zdHlsZS1sb2FkZXIgY2Fubm90IGJlIHVzZWQgaW4gYSBub24tYnJvd3NlciBlbnZpcm9ubWVudC4gJyArXG4gICAgXCJVc2UgeyB0YXJnZXQ6ICdub2RlJyB9IGluIHlvdXIgV2VicGFjayBjb25maWcgdG8gaW5kaWNhdGUgYSBzZXJ2ZXItcmVuZGVyaW5nIGVudmlyb25tZW50LlwiXG4gICkgfVxufVxuXG52YXIgbGlzdFRvU3R5bGVzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMClcblxuLypcbnR5cGUgU3R5bGVPYmplY3QgPSB7XG4gIGlkOiBudW1iZXI7XG4gIHBhcnRzOiBBcnJheTxTdHlsZU9iamVjdFBhcnQ+XG59XG5cbnR5cGUgU3R5bGVPYmplY3RQYXJ0ID0ge1xuICBjc3M6IHN0cmluZztcbiAgbWVkaWE6IHN0cmluZztcbiAgc291cmNlTWFwOiA/c3RyaW5nXG59XG4qL1xuXG52YXIgc3R5bGVzSW5Eb20gPSB7LypcbiAgW2lkOiBudW1iZXJdOiB7XG4gICAgaWQ6IG51bWJlcixcbiAgICByZWZzOiBudW1iZXIsXG4gICAgcGFydHM6IEFycmF5PChvYmo/OiBTdHlsZU9iamVjdFBhcnQpID0+IHZvaWQ+XG4gIH1cbiovfVxuXG52YXIgaGVhZCA9IGhhc0RvY3VtZW50ICYmIChkb2N1bWVudC5oZWFkIHx8IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF0pXG52YXIgc2luZ2xldG9uRWxlbWVudCA9IG51bGxcbnZhciBzaW5nbGV0b25Db3VudGVyID0gMFxudmFyIGlzUHJvZHVjdGlvbiA9IGZhbHNlXG52YXIgbm9vcCA9IGZ1bmN0aW9uICgpIHt9XG5cbi8vIEZvcmNlIHNpbmdsZS10YWcgc29sdXRpb24gb24gSUU2LTksIHdoaWNoIGhhcyBhIGhhcmQgbGltaXQgb24gdGhlICMgb2YgPHN0eWxlPlxuLy8gdGFncyBpdCB3aWxsIGFsbG93IG9uIGEgcGFnZVxudmFyIGlzT2xkSUUgPSB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiAvbXNpZSBbNi05XVxcYi8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkpXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHBhcmVudElkLCBsaXN0LCBfaXNQcm9kdWN0aW9uKSB7XG4gIGlzUHJvZHVjdGlvbiA9IF9pc1Byb2R1Y3Rpb25cblxuICB2YXIgc3R5bGVzID0gbGlzdFRvU3R5bGVzKHBhcmVudElkLCBsaXN0KVxuICBhZGRTdHlsZXNUb0RvbShzdHlsZXMpXG5cbiAgcmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZSAobmV3TGlzdCkge1xuICAgIHZhciBtYXlSZW1vdmUgPSBbXVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaXRlbSA9IHN0eWxlc1tpXVxuICAgICAgdmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF1cbiAgICAgIGRvbVN0eWxlLnJlZnMtLVxuICAgICAgbWF5UmVtb3ZlLnB1c2goZG9tU3R5bGUpXG4gICAgfVxuICAgIGlmIChuZXdMaXN0KSB7XG4gICAgICBzdHlsZXMgPSBsaXN0VG9TdHlsZXMocGFyZW50SWQsIG5ld0xpc3QpXG4gICAgICBhZGRTdHlsZXNUb0RvbShzdHlsZXMpXG4gICAgfSBlbHNlIHtcbiAgICAgIHN0eWxlcyA9IFtdXG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWF5UmVtb3ZlLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZG9tU3R5bGUgPSBtYXlSZW1vdmVbaV1cbiAgICAgIGlmIChkb21TdHlsZS5yZWZzID09PSAwKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZG9tU3R5bGUucGFydHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBkb21TdHlsZS5wYXJ0c1tqXSgpXG4gICAgICAgIH1cbiAgICAgICAgZGVsZXRlIHN0eWxlc0luRG9tW2RvbVN0eWxlLmlkXVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhZGRTdHlsZXNUb0RvbSAoc3R5bGVzIC8qIEFycmF5PFN0eWxlT2JqZWN0PiAqLykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBpdGVtID0gc3R5bGVzW2ldXG4gICAgdmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF1cbiAgICBpZiAoZG9tU3R5bGUpIHtcbiAgICAgIGRvbVN0eWxlLnJlZnMrK1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKykge1xuICAgICAgICBkb21TdHlsZS5wYXJ0c1tqXShpdGVtLnBhcnRzW2pdKVxuICAgICAgfVxuICAgICAgZm9yICg7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGRvbVN0eWxlLnBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSkpXG4gICAgICB9XG4gICAgICBpZiAoZG9tU3R5bGUucGFydHMubGVuZ3RoID4gaXRlbS5wYXJ0cy5sZW5ndGgpIHtcbiAgICAgICAgZG9tU3R5bGUucGFydHMubGVuZ3RoID0gaXRlbS5wYXJ0cy5sZW5ndGhcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHBhcnRzID0gW11cbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgaXRlbS5wYXJ0cy5sZW5ndGg7IGorKykge1xuICAgICAgICBwYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0pKVxuICAgICAgfVxuICAgICAgc3R5bGVzSW5Eb21baXRlbS5pZF0gPSB7IGlkOiBpdGVtLmlkLCByZWZzOiAxLCBwYXJ0czogcGFydHMgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVTdHlsZUVsZW1lbnQgKCkge1xuICB2YXIgc3R5bGVFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKVxuICBzdHlsZUVsZW1lbnQudHlwZSA9ICd0ZXh0L2NzcydcbiAgaGVhZC5hcHBlbmRDaGlsZChzdHlsZUVsZW1lbnQpXG4gIHJldHVybiBzdHlsZUVsZW1lbnRcbn1cblxuZnVuY3Rpb24gYWRkU3R5bGUgKG9iaiAvKiBTdHlsZU9iamVjdFBhcnQgKi8pIHtcbiAgdmFyIHVwZGF0ZSwgcmVtb3ZlXG4gIHZhciBzdHlsZUVsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdzdHlsZVtkYXRhLXZ1ZS1zc3ItaWR+PVwiJyArIG9iai5pZCArICdcIl0nKVxuXG4gIGlmIChzdHlsZUVsZW1lbnQpIHtcbiAgICBpZiAoaXNQcm9kdWN0aW9uKSB7XG4gICAgICAvLyBoYXMgU1NSIHN0eWxlcyBhbmQgaW4gcHJvZHVjdGlvbiBtb2RlLlxuICAgICAgLy8gc2ltcGx5IGRvIG5vdGhpbmcuXG4gICAgICByZXR1cm4gbm9vcFxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBoYXMgU1NSIHN0eWxlcyBidXQgaW4gZGV2IG1vZGUuXG4gICAgICAvLyBmb3Igc29tZSByZWFzb24gQ2hyb21lIGNhbid0IGhhbmRsZSBzb3VyY2UgbWFwIGluIHNlcnZlci1yZW5kZXJlZFxuICAgICAgLy8gc3R5bGUgdGFncyAtIHNvdXJjZSBtYXBzIGluIDxzdHlsZT4gb25seSB3b3JrcyBpZiB0aGUgc3R5bGUgdGFnIGlzXG4gICAgICAvLyBjcmVhdGVkIGFuZCBpbnNlcnRlZCBkeW5hbWljYWxseS4gU28gd2UgcmVtb3ZlIHRoZSBzZXJ2ZXIgcmVuZGVyZWRcbiAgICAgIC8vIHN0eWxlcyBhbmQgaW5qZWN0IG5ldyBvbmVzLlxuICAgICAgc3R5bGVFbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGVFbGVtZW50KVxuICAgIH1cbiAgfVxuXG4gIGlmIChpc09sZElFKSB7XG4gICAgLy8gdXNlIHNpbmdsZXRvbiBtb2RlIGZvciBJRTkuXG4gICAgdmFyIHN0eWxlSW5kZXggPSBzaW5nbGV0b25Db3VudGVyKytcbiAgICBzdHlsZUVsZW1lbnQgPSBzaW5nbGV0b25FbGVtZW50IHx8IChzaW5nbGV0b25FbGVtZW50ID0gY3JlYXRlU3R5bGVFbGVtZW50KCkpXG4gICAgdXBkYXRlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlRWxlbWVudCwgc3R5bGVJbmRleCwgZmFsc2UpXG4gICAgcmVtb3ZlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlRWxlbWVudCwgc3R5bGVJbmRleCwgdHJ1ZSlcbiAgfSBlbHNlIHtcbiAgICAvLyB1c2UgbXVsdGktc3R5bGUtdGFnIG1vZGUgaW4gYWxsIG90aGVyIGNhc2VzXG4gICAgc3R5bGVFbGVtZW50ID0gY3JlYXRlU3R5bGVFbGVtZW50KClcbiAgICB1cGRhdGUgPSBhcHBseVRvVGFnLmJpbmQobnVsbCwgc3R5bGVFbGVtZW50KVxuICAgIHJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHN0eWxlRWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlRWxlbWVudClcbiAgICB9XG4gIH1cblxuICB1cGRhdGUob2JqKVxuXG4gIHJldHVybiBmdW5jdGlvbiB1cGRhdGVTdHlsZSAobmV3T2JqIC8qIFN0eWxlT2JqZWN0UGFydCAqLykge1xuICAgIGlmIChuZXdPYmopIHtcbiAgICAgIGlmIChuZXdPYmouY3NzID09PSBvYmouY3NzICYmXG4gICAgICAgICAgbmV3T2JqLm1lZGlhID09PSBvYmoubWVkaWEgJiZcbiAgICAgICAgICBuZXdPYmouc291cmNlTWFwID09PSBvYmouc291cmNlTWFwKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgdXBkYXRlKG9iaiA9IG5ld09iailcbiAgICB9IGVsc2Uge1xuICAgICAgcmVtb3ZlKClcbiAgICB9XG4gIH1cbn1cblxudmFyIHJlcGxhY2VUZXh0ID0gKGZ1bmN0aW9uICgpIHtcbiAgdmFyIHRleHRTdG9yZSA9IFtdXG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChpbmRleCwgcmVwbGFjZW1lbnQpIHtcbiAgICB0ZXh0U3RvcmVbaW5kZXhdID0gcmVwbGFjZW1lbnRcbiAgICByZXR1cm4gdGV4dFN0b3JlLmZpbHRlcihCb29sZWFuKS5qb2luKCdcXG4nKVxuICB9XG59KSgpXG5cbmZ1bmN0aW9uIGFwcGx5VG9TaW5nbGV0b25UYWcgKHN0eWxlRWxlbWVudCwgaW5kZXgsIHJlbW92ZSwgb2JqKSB7XG4gIHZhciBjc3MgPSByZW1vdmUgPyAnJyA6IG9iai5jc3NcblxuICBpZiAoc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQpIHtcbiAgICBzdHlsZUVsZW1lbnQuc3R5bGVTaGVldC5jc3NUZXh0ID0gcmVwbGFjZVRleHQoaW5kZXgsIGNzcylcbiAgfSBlbHNlIHtcbiAgICB2YXIgY3NzTm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcylcbiAgICB2YXIgY2hpbGROb2RlcyA9IHN0eWxlRWxlbWVudC5jaGlsZE5vZGVzXG4gICAgaWYgKGNoaWxkTm9kZXNbaW5kZXhdKSBzdHlsZUVsZW1lbnQucmVtb3ZlQ2hpbGQoY2hpbGROb2Rlc1tpbmRleF0pXG4gICAgaWYgKGNoaWxkTm9kZXMubGVuZ3RoKSB7XG4gICAgICBzdHlsZUVsZW1lbnQuaW5zZXJ0QmVmb3JlKGNzc05vZGUsIGNoaWxkTm9kZXNbaW5kZXhdKVxuICAgIH0gZWxzZSB7XG4gICAgICBzdHlsZUVsZW1lbnQuYXBwZW5kQ2hpbGQoY3NzTm9kZSlcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYXBwbHlUb1RhZyAoc3R5bGVFbGVtZW50LCBvYmopIHtcbiAgdmFyIGNzcyA9IG9iai5jc3NcbiAgdmFyIG1lZGlhID0gb2JqLm1lZGlhXG4gIHZhciBzb3VyY2VNYXAgPSBvYmouc291cmNlTWFwXG5cbiAgaWYgKG1lZGlhKSB7XG4gICAgc3R5bGVFbGVtZW50LnNldEF0dHJpYnV0ZSgnbWVkaWEnLCBtZWRpYSlcbiAgfVxuXG4gIGlmIChzb3VyY2VNYXApIHtcbiAgICAvLyBodHRwczovL2RldmVsb3Blci5jaHJvbWUuY29tL2RldnRvb2xzL2RvY3MvamF2YXNjcmlwdC1kZWJ1Z2dpbmdcbiAgICAvLyB0aGlzIG1ha2VzIHNvdXJjZSBtYXBzIGluc2lkZSBzdHlsZSB0YWdzIHdvcmsgcHJvcGVybHkgaW4gQ2hyb21lXG4gICAgY3NzICs9ICdcXG4vKiMgc291cmNlVVJMPScgKyBzb3VyY2VNYXAuc291cmNlc1swXSArICcgKi8nXG4gICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjY2MDM4NzVcbiAgICBjc3MgKz0gJ1xcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsJyArIGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSkgKyAnICovJ1xuICB9XG5cbiAgaWYgKHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0KSB7XG4gICAgc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQuY3NzVGV4dCA9IGNzc1xuICB9IGVsc2Uge1xuICAgIHdoaWxlIChzdHlsZUVsZW1lbnQuZmlyc3RDaGlsZCkge1xuICAgICAgc3R5bGVFbGVtZW50LnJlbW92ZUNoaWxkKHN0eWxlRWxlbWVudC5maXJzdENoaWxkKVxuICAgIH1cbiAgICBzdHlsZUVsZW1lbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSlcbiAgfVxufVxuXG5cbi8qKiovIH0pLFxuLyogMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG52YXIgZztcblxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcbmcgPSBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiB0aGlzO1xufSgpO1xuXG50cnkge1xuXHQvLyBUaGlzIHdvcmtzIGlmIGV2YWwgaXMgYWxsb3dlZCAoc2VlIENTUClcblx0ZyA9IGcgfHwgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpIHx8ICgxLCBldmFsKShcInRoaXNcIik7XG59IGNhdGNoIChlKSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXG5cdGlmICh0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKSBnID0gd2luZG93O1xufVxuXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGc7XG5cbi8qKiovIH0pLFxuLyogNCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3dlYnBhY2tfZXhwb3J0c19fLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfdnVlX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF92dWVfX19kZWZhdWx0ID0gX193ZWJwYWNrX3JlcXVpcmVfXy5uKF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF92dWVfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX3Z1ZV9jdXN0b21fZWxlbWVudF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX0FwcF92dWVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNyk7XG4vLyBUaGUgVnVlIGJ1aWxkIHZlcnNpb24gdG8gbG9hZCB3aXRoIHRoZSBgaW1wb3J0YCBjb21tYW5kXG4vLyAocnVudGltZS1vbmx5IG9yIHN0YW5kYWxvbmUpIGhhcyBiZWVuIHNldCBpbiB3ZWJwYWNrLmJhc2UuY29uZiB3aXRoIGFuIGFsaWFzLlxuXG4vLyBpbXBvcnQgXyBmcm9tICdsb2Rhc2gnXG5cbi8vIGluY2x1ZGUgdnVlLWN1c3RvbS1lbGVtZW50IHBsdWdpbiB0byBWdWVcblxuX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX3Z1ZV9fX2RlZmF1bHQuYS51c2UoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX3Z1ZV9jdXN0b21fZWxlbWVudF9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dKTtcblxuX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX3Z1ZV9fX2RlZmF1bHQuYS5jb25maWcucHJvZHVjdGlvblRpcCA9IGZhbHNlO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1uZXcgKi9cbi8vIG5ldyBWdWUoe1xuLy8gICAgIGVsOiAnI2FwcCcsXG4vLyAgICAgdGVtcGxhdGU6ICc8QXBwLz4nLFxuLy8gICAgIGNvbXBvbmVudHM6IHsgQXBwIH1cbi8vIH0pXG5cbi8vIGltcG9ydCBhbmQgcmVnaXN0ZXIgeW91ciBjb21wb25lbnQocylcblxuX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX3Z1ZV9fX2RlZmF1bHQuYS5jdXN0b21FbGVtZW50KCdzYXdzLWhvdXNlJywgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19BcHBfdnVlX19bXCJhXCIgLyogZGVmYXVsdCAqL10pO1xuXG4vKioqLyB9KSxcbi8qIDUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oZnVuY3Rpb24oZ2xvYmFsKSB7LyohXG4gKiBWdWUuanMgdjIuNC40XG4gKiAoYykgMjAxNC0yMDE3IEV2YW4gWW91XG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cblxuXG4vKiAgKi9cblxuLy8gdGhlc2UgaGVscGVycyBwcm9kdWNlcyBiZXR0ZXIgdm0gY29kZSBpbiBKUyBlbmdpbmVzIGR1ZSB0byB0aGVpclxuLy8gZXhwbGljaXRuZXNzIGFuZCBmdW5jdGlvbiBpbmxpbmluZ1xuXG5mdW5jdGlvbiBpc1VuZGVmKHYpIHtcbiAgcmV0dXJuIHYgPT09IHVuZGVmaW5lZCB8fCB2ID09PSBudWxsO1xufVxuXG5mdW5jdGlvbiBpc0RlZih2KSB7XG4gIHJldHVybiB2ICE9PSB1bmRlZmluZWQgJiYgdiAhPT0gbnVsbDtcbn1cblxuZnVuY3Rpb24gaXNUcnVlKHYpIHtcbiAgcmV0dXJuIHYgPT09IHRydWU7XG59XG5cbmZ1bmN0aW9uIGlzRmFsc2Uodikge1xuICByZXR1cm4gdiA9PT0gZmFsc2U7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdmFsdWUgaXMgcHJpbWl0aXZlXG4gKi9cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgfHwgdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbic7XG59XG5cbi8qKlxuICogUXVpY2sgb2JqZWN0IGNoZWNrIC0gdGhpcyBpcyBwcmltYXJpbHkgdXNlZCB0byB0ZWxsXG4gKiBPYmplY3RzIGZyb20gcHJpbWl0aXZlIHZhbHVlcyB3aGVuIHdlIGtub3cgdGhlIHZhbHVlXG4gKiBpcyBhIEpTT04tY29tcGxpYW50IHR5cGUuXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KG9iaikge1xuICByZXR1cm4gb2JqICE9PSBudWxsICYmIHR5cGVvZiBvYmogPT09ICdvYmplY3QnO1xufVxuXG52YXIgX3RvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuLyoqXG4gKiBTdHJpY3Qgb2JqZWN0IHR5cGUgY2hlY2suIE9ubHkgcmV0dXJucyB0cnVlXG4gKiBmb3IgcGxhaW4gSmF2YVNjcmlwdCBvYmplY3RzLlxuICovXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KG9iaikge1xuICByZXR1cm4gX3RvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgT2JqZWN0XSc7XG59XG5cbmZ1bmN0aW9uIGlzUmVnRXhwKHYpIHtcbiAgcmV0dXJuIF90b1N0cmluZy5jYWxsKHYpID09PSAnW29iamVjdCBSZWdFeHBdJztcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB2YWwgaXMgYSB2YWxpZCBhcnJheSBpbmRleC5cbiAqL1xuZnVuY3Rpb24gaXNWYWxpZEFycmF5SW5kZXgodmFsKSB7XG4gIHZhciBuID0gcGFyc2VGbG9hdCh2YWwpO1xuICByZXR1cm4gbiA+PSAwICYmIE1hdGguZmxvb3IobikgPT09IG4gJiYgaXNGaW5pdGUodmFsKTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGEgdmFsdWUgdG8gYSBzdHJpbmcgdGhhdCBpcyBhY3R1YWxseSByZW5kZXJlZC5cbiAqL1xuZnVuY3Rpb24gdG9TdHJpbmcodmFsKSB7XG4gIHJldHVybiB2YWwgPT0gbnVsbCA/ICcnIDogdHlwZW9mIHZhbCA9PT0gJ29iamVjdCcgPyBKU09OLnN0cmluZ2lmeSh2YWwsIG51bGwsIDIpIDogU3RyaW5nKHZhbCk7XG59XG5cbi8qKlxuICogQ29udmVydCBhIGlucHV0IHZhbHVlIHRvIGEgbnVtYmVyIGZvciBwZXJzaXN0ZW5jZS5cbiAqIElmIHRoZSBjb252ZXJzaW9uIGZhaWxzLCByZXR1cm4gb3JpZ2luYWwgc3RyaW5nLlxuICovXG5mdW5jdGlvbiB0b051bWJlcih2YWwpIHtcbiAgdmFyIG4gPSBwYXJzZUZsb2F0KHZhbCk7XG4gIHJldHVybiBpc05hTihuKSA/IHZhbCA6IG47XG59XG5cbi8qKlxuICogTWFrZSBhIG1hcCBhbmQgcmV0dXJuIGEgZnVuY3Rpb24gZm9yIGNoZWNraW5nIGlmIGEga2V5XG4gKiBpcyBpbiB0aGF0IG1hcC5cbiAqL1xuZnVuY3Rpb24gbWFrZU1hcChzdHIsIGV4cGVjdHNMb3dlckNhc2UpIHtcbiAgdmFyIG1hcCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHZhciBsaXN0ID0gc3RyLnNwbGl0KCcsJyk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIG1hcFtsaXN0W2ldXSA9IHRydWU7XG4gIH1cbiAgcmV0dXJuIGV4cGVjdHNMb3dlckNhc2UgPyBmdW5jdGlvbiAodmFsKSB7XG4gICAgcmV0dXJuIG1hcFt2YWwudG9Mb3dlckNhc2UoKV07XG4gIH0gOiBmdW5jdGlvbiAodmFsKSB7XG4gICAgcmV0dXJuIG1hcFt2YWxdO1xuICB9O1xufVxuXG4vKipcbiAqIENoZWNrIGlmIGEgdGFnIGlzIGEgYnVpbHQtaW4gdGFnLlxuICovXG52YXIgaXNCdWlsdEluVGFnID0gbWFrZU1hcCgnc2xvdCxjb21wb25lbnQnLCB0cnVlKTtcblxuLyoqXG4gKiBDaGVjayBpZiBhIGF0dHJpYnV0ZSBpcyBhIHJlc2VydmVkIGF0dHJpYnV0ZS5cbiAqL1xudmFyIGlzUmVzZXJ2ZWRBdHRyaWJ1dGUgPSBtYWtlTWFwKCdrZXkscmVmLHNsb3QsaXMnKTtcblxuLyoqXG4gKiBSZW1vdmUgYW4gaXRlbSBmcm9tIGFuIGFycmF5XG4gKi9cbmZ1bmN0aW9uIHJlbW92ZShhcnIsIGl0ZW0pIHtcbiAgaWYgKGFyci5sZW5ndGgpIHtcbiAgICB2YXIgaW5kZXggPSBhcnIuaW5kZXhPZihpdGVtKTtcbiAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgcmV0dXJuIGFyci5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdGhlIG9iamVjdCBoYXMgdGhlIHByb3BlcnR5LlxuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuZnVuY3Rpb24gaGFzT3duKG9iaiwga2V5KSB7XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBjYWNoZWQgdmVyc2lvbiBvZiBhIHB1cmUgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNhY2hlZChmbikge1xuICB2YXIgY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICByZXR1cm4gZnVuY3Rpb24gY2FjaGVkRm4oc3RyKSB7XG4gICAgdmFyIGhpdCA9IGNhY2hlW3N0cl07XG4gICAgcmV0dXJuIGhpdCB8fCAoY2FjaGVbc3RyXSA9IGZuKHN0cikpO1xuICB9O1xufVxuXG4vKipcbiAqIENhbWVsaXplIGEgaHlwaGVuLWRlbGltaXRlZCBzdHJpbmcuXG4gKi9cbnZhciBjYW1lbGl6ZVJFID0gLy0oXFx3KS9nO1xudmFyIGNhbWVsaXplID0gY2FjaGVkKGZ1bmN0aW9uIChzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKGNhbWVsaXplUkUsIGZ1bmN0aW9uIChfLCBjKSB7XG4gICAgcmV0dXJuIGMgPyBjLnRvVXBwZXJDYXNlKCkgOiAnJztcbiAgfSk7XG59KTtcblxuLyoqXG4gKiBDYXBpdGFsaXplIGEgc3RyaW5nLlxuICovXG52YXIgY2FwaXRhbGl6ZSA9IGNhY2hlZChmdW5jdGlvbiAoc3RyKSB7XG4gIHJldHVybiBzdHIuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHIuc2xpY2UoMSk7XG59KTtcblxuLyoqXG4gKiBIeXBoZW5hdGUgYSBjYW1lbENhc2Ugc3RyaW5nLlxuICovXG52YXIgaHlwaGVuYXRlUkUgPSAvXFxCKFtBLVpdKS9nO1xudmFyIGh5cGhlbmF0ZSA9IGNhY2hlZChmdW5jdGlvbiAoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZShoeXBoZW5hdGVSRSwgJy0kMScpLnRvTG93ZXJDYXNlKCk7XG59KTtcblxuLyoqXG4gKiBTaW1wbGUgYmluZCwgZmFzdGVyIHRoYW4gbmF0aXZlXG4gKi9cbmZ1bmN0aW9uIGJpbmQoZm4sIGN0eCkge1xuICBmdW5jdGlvbiBib3VuZEZuKGEpIHtcbiAgICB2YXIgbCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgcmV0dXJuIGwgPyBsID4gMSA/IGZuLmFwcGx5KGN0eCwgYXJndW1lbnRzKSA6IGZuLmNhbGwoY3R4LCBhKSA6IGZuLmNhbGwoY3R4KTtcbiAgfVxuICAvLyByZWNvcmQgb3JpZ2luYWwgZm4gbGVuZ3RoXG4gIGJvdW5kRm4uX2xlbmd0aCA9IGZuLmxlbmd0aDtcbiAgcmV0dXJuIGJvdW5kRm47XG59XG5cbi8qKlxuICogQ29udmVydCBhbiBBcnJheS1saWtlIG9iamVjdCB0byBhIHJlYWwgQXJyYXkuXG4gKi9cbmZ1bmN0aW9uIHRvQXJyYXkobGlzdCwgc3RhcnQpIHtcbiAgc3RhcnQgPSBzdGFydCB8fCAwO1xuICB2YXIgaSA9IGxpc3QubGVuZ3RoIC0gc3RhcnQ7XG4gIHZhciByZXQgPSBuZXcgQXJyYXkoaSk7XG4gIHdoaWxlIChpLS0pIHtcbiAgICByZXRbaV0gPSBsaXN0W2kgKyBzdGFydF07XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuLyoqXG4gKiBNaXggcHJvcGVydGllcyBpbnRvIHRhcmdldCBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGV4dGVuZCh0bywgX2Zyb20pIHtcbiAgZm9yICh2YXIga2V5IGluIF9mcm9tKSB7XG4gICAgdG9ba2V5XSA9IF9mcm9tW2tleV07XG4gIH1cbiAgcmV0dXJuIHRvO1xufVxuXG4vKipcbiAqIE1lcmdlIGFuIEFycmF5IG9mIE9iamVjdHMgaW50byBhIHNpbmdsZSBPYmplY3QuXG4gKi9cbmZ1bmN0aW9uIHRvT2JqZWN0KGFycikge1xuICB2YXIgcmVzID0ge307XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGFycltpXSkge1xuICAgICAgZXh0ZW5kKHJlcywgYXJyW2ldKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxuLyoqXG4gKiBQZXJmb3JtIG5vIG9wZXJhdGlvbi5cbiAqIFN0dWJiaW5nIGFyZ3MgdG8gbWFrZSBGbG93IGhhcHB5IHdpdGhvdXQgbGVhdmluZyB1c2VsZXNzIHRyYW5zcGlsZWQgY29kZVxuICogd2l0aCAuLi5yZXN0IChodHRwczovL2Zsb3cub3JnL2Jsb2cvMjAxNy8wNS8wNy9TdHJpY3QtRnVuY3Rpb24tQ2FsbC1Bcml0eS8pXG4gKi9cbmZ1bmN0aW9uIG5vb3AoYSwgYiwgYykge31cblxuLyoqXG4gKiBBbHdheXMgcmV0dXJuIGZhbHNlLlxuICovXG52YXIgbm8gPSBmdW5jdGlvbiAoYSwgYiwgYykge1xuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIFJldHVybiBzYW1lIHZhbHVlXG4gKi9cbnZhciBpZGVudGl0eSA9IGZ1bmN0aW9uIChfKSB7XG4gIHJldHVybiBfO1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZSBhIHN0YXRpYyBrZXlzIHN0cmluZyBmcm9tIGNvbXBpbGVyIG1vZHVsZXMuXG4gKi9cbmZ1bmN0aW9uIGdlblN0YXRpY0tleXMobW9kdWxlcykge1xuICByZXR1cm4gbW9kdWxlcy5yZWR1Y2UoZnVuY3Rpb24gKGtleXMsIG0pIHtcbiAgICByZXR1cm4ga2V5cy5jb25jYXQobS5zdGF0aWNLZXlzIHx8IFtdKTtcbiAgfSwgW10pLmpvaW4oJywnKTtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB0d28gdmFsdWVzIGFyZSBsb29zZWx5IGVxdWFsIC0gdGhhdCBpcyxcbiAqIGlmIHRoZXkgYXJlIHBsYWluIG9iamVjdHMsIGRvIHRoZXkgaGF2ZSB0aGUgc2FtZSBzaGFwZT9cbiAqL1xuZnVuY3Rpb24gbG9vc2VFcXVhbChhLCBiKSB7XG4gIGlmIChhID09PSBiKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdmFyIGlzT2JqZWN0QSA9IGlzT2JqZWN0KGEpO1xuICB2YXIgaXNPYmplY3RCID0gaXNPYmplY3QoYik7XG4gIGlmIChpc09iamVjdEEgJiYgaXNPYmplY3RCKSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBpc0FycmF5QSA9IEFycmF5LmlzQXJyYXkoYSk7XG4gICAgICB2YXIgaXNBcnJheUIgPSBBcnJheS5pc0FycmF5KGIpO1xuICAgICAgaWYgKGlzQXJyYXlBICYmIGlzQXJyYXlCKSB7XG4gICAgICAgIHJldHVybiBhLmxlbmd0aCA9PT0gYi5sZW5ndGggJiYgYS5ldmVyeShmdW5jdGlvbiAoZSwgaSkge1xuICAgICAgICAgIHJldHVybiBsb29zZUVxdWFsKGUsIGJbaV0pO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAoIWlzQXJyYXlBICYmICFpc0FycmF5Qikge1xuICAgICAgICB2YXIga2V5c0EgPSBPYmplY3Qua2V5cyhhKTtcbiAgICAgICAgdmFyIGtleXNCID0gT2JqZWN0LmtleXMoYik7XG4gICAgICAgIHJldHVybiBrZXlzQS5sZW5ndGggPT09IGtleXNCLmxlbmd0aCAmJiBrZXlzQS5ldmVyeShmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgcmV0dXJuIGxvb3NlRXF1YWwoYVtrZXldLCBiW2tleV0pO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSBlbHNlIGlmICghaXNPYmplY3RBICYmICFpc09iamVjdEIpIHtcbiAgICByZXR1cm4gU3RyaW5nKGEpID09PSBTdHJpbmcoYik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGxvb3NlSW5kZXhPZihhcnIsIHZhbCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIGlmIChsb29zZUVxdWFsKGFycltpXSwgdmFsKSkge1xuICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cblxuLyoqXG4gKiBFbnN1cmUgYSBmdW5jdGlvbiBpcyBjYWxsZWQgb25seSBvbmNlLlxuICovXG5mdW5jdGlvbiBvbmNlKGZuKSB7XG4gIHZhciBjYWxsZWQgPSBmYWxzZTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIWNhbGxlZCkge1xuICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICAgIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9O1xufVxuXG52YXIgU1NSX0FUVFIgPSAnZGF0YS1zZXJ2ZXItcmVuZGVyZWQnO1xuXG52YXIgQVNTRVRfVFlQRVMgPSBbJ2NvbXBvbmVudCcsICdkaXJlY3RpdmUnLCAnZmlsdGVyJ107XG5cbnZhciBMSUZFQ1lDTEVfSE9PS1MgPSBbJ2JlZm9yZUNyZWF0ZScsICdjcmVhdGVkJywgJ2JlZm9yZU1vdW50JywgJ21vdW50ZWQnLCAnYmVmb3JlVXBkYXRlJywgJ3VwZGF0ZWQnLCAnYmVmb3JlRGVzdHJveScsICdkZXN0cm95ZWQnLCAnYWN0aXZhdGVkJywgJ2RlYWN0aXZhdGVkJ107XG5cbi8qICAqL1xuXG52YXIgY29uZmlnID0ge1xuICAvKipcbiAgICogT3B0aW9uIG1lcmdlIHN0cmF0ZWdpZXMgKHVzZWQgaW4gY29yZS91dGlsL29wdGlvbnMpXG4gICAqL1xuICBvcHRpb25NZXJnZVN0cmF0ZWdpZXM6IE9iamVjdC5jcmVhdGUobnVsbCksXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gc3VwcHJlc3Mgd2FybmluZ3MuXG4gICAqL1xuICBzaWxlbnQ6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBTaG93IHByb2R1Y3Rpb24gbW9kZSB0aXAgbWVzc2FnZSBvbiBib290P1xuICAgKi9cbiAgcHJvZHVjdGlvblRpcDogXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyxcblxuICAvKipcbiAgICogV2hldGhlciB0byBlbmFibGUgZGV2dG9vbHNcbiAgICovXG4gIGRldnRvb2xzOiBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nLFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIHJlY29yZCBwZXJmXG4gICAqL1xuICBwZXJmb3JtYW5jZTogZmFsc2UsXG5cbiAgLyoqXG4gICAqIEVycm9yIGhhbmRsZXIgZm9yIHdhdGNoZXIgZXJyb3JzXG4gICAqL1xuICBlcnJvckhhbmRsZXI6IG51bGwsXG5cbiAgLyoqXG4gICAqIFdhcm4gaGFuZGxlciBmb3Igd2F0Y2hlciB3YXJuc1xuICAgKi9cbiAgd2FybkhhbmRsZXI6IG51bGwsXG5cbiAgLyoqXG4gICAqIElnbm9yZSBjZXJ0YWluIGN1c3RvbSBlbGVtZW50c1xuICAgKi9cbiAgaWdub3JlZEVsZW1lbnRzOiBbXSxcblxuICAvKipcbiAgICogQ3VzdG9tIHVzZXIga2V5IGFsaWFzZXMgZm9yIHYtb25cbiAgICovXG4gIGtleUNvZGVzOiBPYmplY3QuY3JlYXRlKG51bGwpLFxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhIHRhZyBpcyByZXNlcnZlZCBzbyB0aGF0IGl0IGNhbm5vdCBiZSByZWdpc3RlcmVkIGFzIGFcbiAgICogY29tcG9uZW50LiBUaGlzIGlzIHBsYXRmb3JtLWRlcGVuZGVudCBhbmQgbWF5IGJlIG92ZXJ3cml0dGVuLlxuICAgKi9cbiAgaXNSZXNlcnZlZFRhZzogbm8sXG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGFuIGF0dHJpYnV0ZSBpcyByZXNlcnZlZCBzbyB0aGF0IGl0IGNhbm5vdCBiZSB1c2VkIGFzIGEgY29tcG9uZW50XG4gICAqIHByb3AuIFRoaXMgaXMgcGxhdGZvcm0tZGVwZW5kZW50IGFuZCBtYXkgYmUgb3ZlcndyaXR0ZW4uXG4gICAqL1xuICBpc1Jlc2VydmVkQXR0cjogbm8sXG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGEgdGFnIGlzIGFuIHVua25vd24gZWxlbWVudC5cbiAgICogUGxhdGZvcm0tZGVwZW5kZW50LlxuICAgKi9cbiAgaXNVbmtub3duRWxlbWVudDogbm8sXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbmFtZXNwYWNlIG9mIGFuIGVsZW1lbnRcbiAgICovXG4gIGdldFRhZ05hbWVzcGFjZTogbm9vcCxcblxuICAvKipcbiAgICogUGFyc2UgdGhlIHJlYWwgdGFnIG5hbWUgZm9yIHRoZSBzcGVjaWZpYyBwbGF0Zm9ybS5cbiAgICovXG4gIHBhcnNlUGxhdGZvcm1UYWdOYW1lOiBpZGVudGl0eSxcblxuICAvKipcbiAgICogQ2hlY2sgaWYgYW4gYXR0cmlidXRlIG11c3QgYmUgYm91bmQgdXNpbmcgcHJvcGVydHksIGUuZy4gdmFsdWVcbiAgICogUGxhdGZvcm0tZGVwZW5kZW50LlxuICAgKi9cbiAgbXVzdFVzZVByb3A6IG5vLFxuXG4gIC8qKlxuICAgKiBFeHBvc2VkIGZvciBsZWdhY3kgcmVhc29uc1xuICAgKi9cbiAgX2xpZmVjeWNsZUhvb2tzOiBMSUZFQ1lDTEVfSE9PS1Ncbn07XG5cbi8qICAqL1xuXG52YXIgZW1wdHlPYmplY3QgPSBPYmplY3QuZnJlZXplKHt9KTtcblxuLyoqXG4gKiBDaGVjayBpZiBhIHN0cmluZyBzdGFydHMgd2l0aCAkIG9yIF9cbiAqL1xuZnVuY3Rpb24gaXNSZXNlcnZlZChzdHIpIHtcbiAgdmFyIGMgPSAoc3RyICsgJycpLmNoYXJDb2RlQXQoMCk7XG4gIHJldHVybiBjID09PSAweDI0IHx8IGMgPT09IDB4NUY7XG59XG5cbi8qKlxuICogRGVmaW5lIGEgcHJvcGVydHkuXG4gKi9cbmZ1bmN0aW9uIGRlZihvYmosIGtleSwgdmFsLCBlbnVtZXJhYmxlKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgIHZhbHVlOiB2YWwsXG4gICAgZW51bWVyYWJsZTogISFlbnVtZXJhYmxlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn1cblxuLyoqXG4gKiBQYXJzZSBzaW1wbGUgcGF0aC5cbiAqL1xudmFyIGJhaWxSRSA9IC9bXlxcdy4kXS87XG5mdW5jdGlvbiBwYXJzZVBhdGgocGF0aCkge1xuICBpZiAoYmFpbFJFLnRlc3QocGF0aCkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIHNlZ21lbnRzID0gcGF0aC5zcGxpdCgnLicpO1xuICByZXR1cm4gZnVuY3Rpb24gKG9iaikge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VnbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICghb2JqKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIG9iaiA9IG9ialtzZWdtZW50c1tpXV07XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG4gIH07XG59XG5cbi8qICAqL1xuXG52YXIgd2FybiA9IG5vb3A7XG52YXIgdGlwID0gbm9vcDtcbnZhciBmb3JtYXRDb21wb25lbnROYW1lID0gbnVsbDsgLy8gd29yayBhcm91bmQgZmxvdyBjaGVja1xuXG5pZiAoZmFsc2UpIHtcbiAgdmFyIGhhc0NvbnNvbGUgPSB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCc7XG4gIHZhciBjbGFzc2lmeVJFID0gLyg/Ol58Wy1fXSkoXFx3KS9nO1xuICB2YXIgY2xhc3NpZnkgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKGNsYXNzaWZ5UkUsIGZ1bmN0aW9uIChjKSB7XG4gICAgICByZXR1cm4gYy50b1VwcGVyQ2FzZSgpO1xuICAgIH0pLnJlcGxhY2UoL1stX10vZywgJycpO1xuICB9O1xuXG4gIHdhcm4gPSBmdW5jdGlvbiAobXNnLCB2bSkge1xuICAgIHZhciB0cmFjZSA9IHZtID8gZ2VuZXJhdGVDb21wb25lbnRUcmFjZSh2bSkgOiAnJztcblxuICAgIGlmIChjb25maWcud2FybkhhbmRsZXIpIHtcbiAgICAgIGNvbmZpZy53YXJuSGFuZGxlci5jYWxsKG51bGwsIG1zZywgdm0sIHRyYWNlKTtcbiAgICB9IGVsc2UgaWYgKGhhc0NvbnNvbGUgJiYgIWNvbmZpZy5zaWxlbnQpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJbVnVlIHdhcm5dOiBcIiArIG1zZyArIHRyYWNlKTtcbiAgICB9XG4gIH07XG5cbiAgdGlwID0gZnVuY3Rpb24gKG1zZywgdm0pIHtcbiAgICBpZiAoaGFzQ29uc29sZSAmJiAhY29uZmlnLnNpbGVudCkge1xuICAgICAgY29uc29sZS53YXJuKFwiW1Z1ZSB0aXBdOiBcIiArIG1zZyArICh2bSA/IGdlbmVyYXRlQ29tcG9uZW50VHJhY2Uodm0pIDogJycpKTtcbiAgICB9XG4gIH07XG5cbiAgZm9ybWF0Q29tcG9uZW50TmFtZSA9IGZ1bmN0aW9uICh2bSwgaW5jbHVkZUZpbGUpIHtcbiAgICBpZiAodm0uJHJvb3QgPT09IHZtKSB7XG4gICAgICByZXR1cm4gJzxSb290Pic7XG4gICAgfVxuICAgIHZhciBuYW1lID0gdHlwZW9mIHZtID09PSAnc3RyaW5nJyA/IHZtIDogdHlwZW9mIHZtID09PSAnZnVuY3Rpb24nICYmIHZtLm9wdGlvbnMgPyB2bS5vcHRpb25zLm5hbWUgOiB2bS5faXNWdWUgPyB2bS4kb3B0aW9ucy5uYW1lIHx8IHZtLiRvcHRpb25zLl9jb21wb25lbnRUYWcgOiB2bS5uYW1lO1xuXG4gICAgdmFyIGZpbGUgPSB2bS5faXNWdWUgJiYgdm0uJG9wdGlvbnMuX19maWxlO1xuICAgIGlmICghbmFtZSAmJiBmaWxlKSB7XG4gICAgICB2YXIgbWF0Y2ggPSBmaWxlLm1hdGNoKC8oW14vXFxcXF0rKVxcLnZ1ZSQvKTtcbiAgICAgIG5hbWUgPSBtYXRjaCAmJiBtYXRjaFsxXTtcbiAgICB9XG5cbiAgICByZXR1cm4gKG5hbWUgPyBcIjxcIiArIGNsYXNzaWZ5KG5hbWUpICsgXCI+XCIgOiBcIjxBbm9ueW1vdXM+XCIpICsgKGZpbGUgJiYgaW5jbHVkZUZpbGUgIT09IGZhbHNlID8gXCIgYXQgXCIgKyBmaWxlIDogJycpO1xuICB9O1xuXG4gIHZhciByZXBlYXQgPSBmdW5jdGlvbiAoc3RyLCBuKSB7XG4gICAgdmFyIHJlcyA9ICcnO1xuICAgIHdoaWxlIChuKSB7XG4gICAgICBpZiAobiAlIDIgPT09IDEpIHtcbiAgICAgICAgcmVzICs9IHN0cjtcbiAgICAgIH1cbiAgICAgIGlmIChuID4gMSkge1xuICAgICAgICBzdHIgKz0gc3RyO1xuICAgICAgfVxuICAgICAgbiA+Pj0gMTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICB2YXIgZ2VuZXJhdGVDb21wb25lbnRUcmFjZSA9IGZ1bmN0aW9uICh2bSkge1xuICAgIGlmICh2bS5faXNWdWUgJiYgdm0uJHBhcmVudCkge1xuICAgICAgdmFyIHRyZWUgPSBbXTtcbiAgICAgIHZhciBjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2UgPSAwO1xuICAgICAgd2hpbGUgKHZtKSB7XG4gICAgICAgIGlmICh0cmVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB2YXIgbGFzdCA9IHRyZWVbdHJlZS5sZW5ndGggLSAxXTtcbiAgICAgICAgICBpZiAobGFzdC5jb25zdHJ1Y3RvciA9PT0gdm0uY29uc3RydWN0b3IpIHtcbiAgICAgICAgICAgIGN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZSsrO1xuICAgICAgICAgICAgdm0gPSB2bS4kcGFyZW50O1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2UgPiAwKSB7XG4gICAgICAgICAgICB0cmVlW3RyZWUubGVuZ3RoIC0gMV0gPSBbbGFzdCwgY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlXTtcbiAgICAgICAgICAgIGN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZSA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRyZWUucHVzaCh2bSk7XG4gICAgICAgIHZtID0gdm0uJHBhcmVudDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAnXFxuXFxuZm91bmQgaW5cXG5cXG4nICsgdHJlZS5tYXAoZnVuY3Rpb24gKHZtLCBpKSB7XG4gICAgICAgIHJldHVybiBcIlwiICsgKGkgPT09IDAgPyAnLS0tPiAnIDogcmVwZWF0KCcgJywgNSArIGkgKiAyKSkgKyAoQXJyYXkuaXNBcnJheSh2bSkgPyBmb3JtYXRDb21wb25lbnROYW1lKHZtWzBdKSArIFwiLi4uIChcIiArIHZtWzFdICsgXCIgcmVjdXJzaXZlIGNhbGxzKVwiIDogZm9ybWF0Q29tcG9uZW50TmFtZSh2bSkpO1xuICAgICAgfSkuam9pbignXFxuJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBcIlxcblxcbihmb3VuZCBpbiBcIiArIGZvcm1hdENvbXBvbmVudE5hbWUodm0pICsgXCIpXCI7XG4gICAgfVxuICB9O1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaGFuZGxlRXJyb3IoZXJyLCB2bSwgaW5mbykge1xuICBpZiAoY29uZmlnLmVycm9ySGFuZGxlcikge1xuICAgIGNvbmZpZy5lcnJvckhhbmRsZXIuY2FsbChudWxsLCBlcnIsIHZtLCBpbmZvKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoZmFsc2UpIHtcbiAgICAgIHdhcm4oXCJFcnJvciBpbiBcIiArIGluZm8gKyBcIjogXFxcIlwiICsgZXJyLnRvU3RyaW5nKCkgKyBcIlxcXCJcIiwgdm0pO1xuICAgIH1cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmIChpbkJyb3dzZXIgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IGVycjtcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG4vKiBnbG9iYWxzIE11dGF0aW9uT2JzZXJ2ZXIgKi9cblxuLy8gY2FuIHdlIHVzZSBfX3Byb3RvX18/XG52YXIgaGFzUHJvdG8gPSAnX19wcm90b19fJyBpbiB7fTtcblxuLy8gQnJvd3NlciBlbnZpcm9ubWVudCBzbmlmZmluZ1xudmFyIGluQnJvd3NlciA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnO1xudmFyIFVBID0gaW5Ccm93c2VyICYmIHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCk7XG52YXIgaXNJRSA9IFVBICYmIC9tc2llfHRyaWRlbnQvLnRlc3QoVUEpO1xudmFyIGlzSUU5ID0gVUEgJiYgVUEuaW5kZXhPZignbXNpZSA5LjAnKSA+IDA7XG52YXIgaXNFZGdlID0gVUEgJiYgVUEuaW5kZXhPZignZWRnZS8nKSA+IDA7XG52YXIgaXNBbmRyb2lkID0gVUEgJiYgVUEuaW5kZXhPZignYW5kcm9pZCcpID4gMDtcbnZhciBpc0lPUyA9IFVBICYmIC9pcGhvbmV8aXBhZHxpcG9kfGlvcy8udGVzdChVQSk7XG52YXIgaXNDaHJvbWUgPSBVQSAmJiAvY2hyb21lXFwvXFxkKy8udGVzdChVQSkgJiYgIWlzRWRnZTtcblxuLy8gRmlyZWZveCBoYXMgYSBcIndhdGNoXCIgZnVuY3Rpb24gb24gT2JqZWN0LnByb3RvdHlwZS4uLlxudmFyIG5hdGl2ZVdhdGNoID0ge30ud2F0Y2g7XG5cbnZhciBzdXBwb3J0c1Bhc3NpdmUgPSBmYWxzZTtcbmlmIChpbkJyb3dzZXIpIHtcbiAgdHJ5IHtcbiAgICB2YXIgb3B0cyA9IHt9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvcHRzLCAncGFzc2l2ZScsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICBzdXBwb3J0c1Bhc3NpdmUgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pOyAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svZmxvdy9pc3N1ZXMvMjg1XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Rlc3QtcGFzc2l2ZScsIG51bGwsIG9wdHMpO1xuICB9IGNhdGNoIChlKSB7fVxufVxuXG4vLyB0aGlzIG5lZWRzIHRvIGJlIGxhenktZXZhbGVkIGJlY2F1c2UgdnVlIG1heSBiZSByZXF1aXJlZCBiZWZvcmVcbi8vIHZ1ZS1zZXJ2ZXItcmVuZGVyZXIgY2FuIHNldCBWVUVfRU5WXG52YXIgX2lzU2VydmVyO1xudmFyIGlzU2VydmVyUmVuZGVyaW5nID0gZnVuY3Rpb24gKCkge1xuICBpZiAoX2lzU2VydmVyID09PSB1bmRlZmluZWQpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIWluQnJvd3NlciAmJiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgLy8gZGV0ZWN0IHByZXNlbmNlIG9mIHZ1ZS1zZXJ2ZXItcmVuZGVyZXIgYW5kIGF2b2lkXG4gICAgICAvLyBXZWJwYWNrIHNoaW1taW5nIHRoZSBwcm9jZXNzXG4gICAgICBfaXNTZXJ2ZXIgPSBnbG9iYWxbJ3Byb2Nlc3MnXS5lbnYuVlVFX0VOViA9PT0gJ3NlcnZlcic7XG4gICAgfSBlbHNlIHtcbiAgICAgIF9pc1NlcnZlciA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gX2lzU2VydmVyO1xufTtcblxuLy8gZGV0ZWN0IGRldnRvb2xzXG52YXIgZGV2dG9vbHMgPSBpbkJyb3dzZXIgJiYgd2luZG93Ll9fVlVFX0RFVlRPT0xTX0dMT0JBTF9IT09LX187XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5mdW5jdGlvbiBpc05hdGl2ZShDdG9yKSB7XG4gIHJldHVybiB0eXBlb2YgQ3RvciA9PT0gJ2Z1bmN0aW9uJyAmJiAvbmF0aXZlIGNvZGUvLnRlc3QoQ3Rvci50b1N0cmluZygpKTtcbn1cblxudmFyIGhhc1N5bWJvbCA9IHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFN5bWJvbCkgJiYgdHlwZW9mIFJlZmxlY3QgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFJlZmxlY3Qub3duS2V5cyk7XG5cbi8qKlxuICogRGVmZXIgYSB0YXNrIHRvIGV4ZWN1dGUgaXQgYXN5bmNocm9ub3VzbHkuXG4gKi9cbnZhciBuZXh0VGljayA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGNhbGxiYWNrcyA9IFtdO1xuICB2YXIgcGVuZGluZyA9IGZhbHNlO1xuICB2YXIgdGltZXJGdW5jO1xuXG4gIGZ1bmN0aW9uIG5leHRUaWNrSGFuZGxlcigpIHtcbiAgICBwZW5kaW5nID0gZmFsc2U7XG4gICAgdmFyIGNvcGllcyA9IGNhbGxiYWNrcy5zbGljZSgwKTtcbiAgICBjYWxsYmFja3MubGVuZ3RoID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvcGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29waWVzW2ldKCk7XG4gICAgfVxuICB9XG5cbiAgLy8gdGhlIG5leHRUaWNrIGJlaGF2aW9yIGxldmVyYWdlcyB0aGUgbWljcm90YXNrIHF1ZXVlLCB3aGljaCBjYW4gYmUgYWNjZXNzZWRcbiAgLy8gdmlhIGVpdGhlciBuYXRpdmUgUHJvbWlzZS50aGVuIG9yIE11dGF0aW9uT2JzZXJ2ZXIuXG4gIC8vIE11dGF0aW9uT2JzZXJ2ZXIgaGFzIHdpZGVyIHN1cHBvcnQsIGhvd2V2ZXIgaXQgaXMgc2VyaW91c2x5IGJ1Z2dlZCBpblxuICAvLyBVSVdlYlZpZXcgaW4gaU9TID49IDkuMy4zIHdoZW4gdHJpZ2dlcmVkIGluIHRvdWNoIGV2ZW50IGhhbmRsZXJzLiBJdFxuICAvLyBjb21wbGV0ZWx5IHN0b3BzIHdvcmtpbmcgYWZ0ZXIgdHJpZ2dlcmluZyBhIGZldyB0aW1lcy4uLiBzbywgaWYgbmF0aXZlXG4gIC8vIFByb21pc2UgaXMgYXZhaWxhYmxlLCB3ZSB3aWxsIHVzZSBpdDpcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICh0eXBlb2YgUHJvbWlzZSAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoUHJvbWlzZSkpIHtcbiAgICB2YXIgcCA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgIHZhciBsb2dFcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICB9O1xuICAgIHRpbWVyRnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHAudGhlbihuZXh0VGlja0hhbmRsZXIpLmNhdGNoKGxvZ0Vycm9yKTtcbiAgICAgIC8vIGluIHByb2JsZW1hdGljIFVJV2ViVmlld3MsIFByb21pc2UudGhlbiBkb2Vzbid0IGNvbXBsZXRlbHkgYnJlYWssIGJ1dFxuICAgICAgLy8gaXQgY2FuIGdldCBzdHVjayBpbiBhIHdlaXJkIHN0YXRlIHdoZXJlIGNhbGxiYWNrcyBhcmUgcHVzaGVkIGludG8gdGhlXG4gICAgICAvLyBtaWNyb3Rhc2sgcXVldWUgYnV0IHRoZSBxdWV1ZSBpc24ndCBiZWluZyBmbHVzaGVkLCB1bnRpbCB0aGUgYnJvd3NlclxuICAgICAgLy8gbmVlZHMgdG8gZG8gc29tZSBvdGhlciB3b3JrLCBlLmcuIGhhbmRsZSBhIHRpbWVyLiBUaGVyZWZvcmUgd2UgY2FuXG4gICAgICAvLyBcImZvcmNlXCIgdGhlIG1pY3JvdGFzayBxdWV1ZSB0byBiZSBmbHVzaGVkIGJ5IGFkZGluZyBhbiBlbXB0eSB0aW1lci5cbiAgICAgIGlmIChpc0lPUykge1xuICAgICAgICBzZXRUaW1lb3V0KG5vb3ApO1xuICAgICAgfVxuICAgIH07XG4gIH0gZWxzZSBpZiAoIWlzSUUgJiYgdHlwZW9mIE11dGF0aW9uT2JzZXJ2ZXIgIT09ICd1bmRlZmluZWQnICYmIChpc05hdGl2ZShNdXRhdGlvbk9ic2VydmVyKSB8fFxuICAvLyBQaGFudG9tSlMgYW5kIGlPUyA3LnhcbiAgTXV0YXRpb25PYnNlcnZlci50b1N0cmluZygpID09PSAnW29iamVjdCBNdXRhdGlvbk9ic2VydmVyQ29uc3RydWN0b3JdJykpIHtcbiAgICAvLyB1c2UgTXV0YXRpb25PYnNlcnZlciB3aGVyZSBuYXRpdmUgUHJvbWlzZSBpcyBub3QgYXZhaWxhYmxlLFxuICAgIC8vIGUuZy4gUGhhbnRvbUpTLCBpT1M3LCBBbmRyb2lkIDQuNFxuICAgIHZhciBjb3VudGVyID0gMTtcbiAgICB2YXIgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihuZXh0VGlja0hhbmRsZXIpO1xuICAgIHZhciB0ZXh0Tm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFN0cmluZyhjb3VudGVyKSk7XG4gICAgb2JzZXJ2ZXIub2JzZXJ2ZSh0ZXh0Tm9kZSwge1xuICAgICAgY2hhcmFjdGVyRGF0YTogdHJ1ZVxuICAgIH0pO1xuICAgIHRpbWVyRnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGNvdW50ZXIgPSAoY291bnRlciArIDEpICUgMjtcbiAgICAgIHRleHROb2RlLmRhdGEgPSBTdHJpbmcoY291bnRlcik7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICAvLyBmYWxsYmFjayB0byBzZXRUaW1lb3V0XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICB0aW1lckZ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBzZXRUaW1lb3V0KG5leHRUaWNrSGFuZGxlciwgMCk7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiBxdWV1ZU5leHRUaWNrKGNiLCBjdHgpIHtcbiAgICB2YXIgX3Jlc29sdmU7XG4gICAgY2FsbGJhY2tzLnB1c2goZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGNiKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY2IuY2FsbChjdHgpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgaGFuZGxlRXJyb3IoZSwgY3R4LCAnbmV4dFRpY2snKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChfcmVzb2x2ZSkge1xuICAgICAgICBfcmVzb2x2ZShjdHgpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmICghcGVuZGluZykge1xuICAgICAgcGVuZGluZyA9IHRydWU7XG4gICAgICB0aW1lckZ1bmMoKTtcbiAgICB9XG4gICAgaWYgKCFjYiAmJiB0eXBlb2YgUHJvbWlzZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIF9yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbn0oKTtcblxudmFyIF9TZXQ7XG4vKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbmlmICh0eXBlb2YgU2V0ICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShTZXQpKSB7XG4gIC8vIHVzZSBuYXRpdmUgU2V0IHdoZW4gYXZhaWxhYmxlLlxuICBfU2V0ID0gU2V0O1xufSBlbHNlIHtcbiAgLy8gYSBub24tc3RhbmRhcmQgU2V0IHBvbHlmaWxsIHRoYXQgb25seSB3b3JrcyB3aXRoIHByaW1pdGl2ZSBrZXlzLlxuICBfU2V0ID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNldCgpIHtcbiAgICAgIHRoaXMuc2V0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB9XG4gICAgU2V0LnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiBoYXMoa2V5KSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXRba2V5XSA9PT0gdHJ1ZTtcbiAgICB9O1xuICAgIFNldC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkKGtleSkge1xuICAgICAgdGhpcy5zZXRba2V5XSA9IHRydWU7XG4gICAgfTtcbiAgICBTZXQucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgICB0aGlzLnNldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgfTtcblxuICAgIHJldHVybiBTZXQ7XG4gIH0oKTtcbn1cblxuLyogICovXG5cbnZhciB1aWQgPSAwO1xuXG4vKipcbiAqIEEgZGVwIGlzIGFuIG9ic2VydmFibGUgdGhhdCBjYW4gaGF2ZSBtdWx0aXBsZVxuICogZGlyZWN0aXZlcyBzdWJzY3JpYmluZyB0byBpdC5cbiAqL1xudmFyIERlcCA9IGZ1bmN0aW9uIERlcCgpIHtcbiAgdGhpcy5pZCA9IHVpZCsrO1xuICB0aGlzLnN1YnMgPSBbXTtcbn07XG5cbkRlcC5wcm90b3R5cGUuYWRkU3ViID0gZnVuY3Rpb24gYWRkU3ViKHN1Yikge1xuICB0aGlzLnN1YnMucHVzaChzdWIpO1xufTtcblxuRGVwLnByb3RvdHlwZS5yZW1vdmVTdWIgPSBmdW5jdGlvbiByZW1vdmVTdWIoc3ViKSB7XG4gIHJlbW92ZSh0aGlzLnN1YnMsIHN1Yik7XG59O1xuXG5EZXAucHJvdG90eXBlLmRlcGVuZCA9IGZ1bmN0aW9uIGRlcGVuZCgpIHtcbiAgaWYgKERlcC50YXJnZXQpIHtcbiAgICBEZXAudGFyZ2V0LmFkZERlcCh0aGlzKTtcbiAgfVxufTtcblxuRGVwLnByb3RvdHlwZS5ub3RpZnkgPSBmdW5jdGlvbiBub3RpZnkoKSB7XG4gIC8vIHN0YWJpbGl6ZSB0aGUgc3Vic2NyaWJlciBsaXN0IGZpcnN0XG4gIHZhciBzdWJzID0gdGhpcy5zdWJzLnNsaWNlKCk7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gc3Vicy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBzdWJzW2ldLnVwZGF0ZSgpO1xuICB9XG59O1xuXG4vLyB0aGUgY3VycmVudCB0YXJnZXQgd2F0Y2hlciBiZWluZyBldmFsdWF0ZWQuXG4vLyB0aGlzIGlzIGdsb2JhbGx5IHVuaXF1ZSBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG9ubHkgb25lXG4vLyB3YXRjaGVyIGJlaW5nIGV2YWx1YXRlZCBhdCBhbnkgdGltZS5cbkRlcC50YXJnZXQgPSBudWxsO1xudmFyIHRhcmdldFN0YWNrID0gW107XG5cbmZ1bmN0aW9uIHB1c2hUYXJnZXQoX3RhcmdldCkge1xuICBpZiAoRGVwLnRhcmdldCkge1xuICAgIHRhcmdldFN0YWNrLnB1c2goRGVwLnRhcmdldCk7XG4gIH1cbiAgRGVwLnRhcmdldCA9IF90YXJnZXQ7XG59XG5cbmZ1bmN0aW9uIHBvcFRhcmdldCgpIHtcbiAgRGVwLnRhcmdldCA9IHRhcmdldFN0YWNrLnBvcCgpO1xufVxuXG4vKlxuICogbm90IHR5cGUgY2hlY2tpbmcgdGhpcyBmaWxlIGJlY2F1c2UgZmxvdyBkb2Vzbid0IHBsYXkgd2VsbCB3aXRoXG4gKiBkeW5hbWljYWxseSBhY2Nlc3NpbmcgbWV0aG9kcyBvbiBBcnJheSBwcm90b3R5cGVcbiAqL1xuXG52YXIgYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcbnZhciBhcnJheU1ldGhvZHMgPSBPYmplY3QuY3JlYXRlKGFycmF5UHJvdG8pO1sncHVzaCcsICdwb3AnLCAnc2hpZnQnLCAndW5zaGlmdCcsICdzcGxpY2UnLCAnc29ydCcsICdyZXZlcnNlJ10uZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7XG4gIC8vIGNhY2hlIG9yaWdpbmFsIG1ldGhvZFxuICB2YXIgb3JpZ2luYWwgPSBhcnJheVByb3RvW21ldGhvZF07XG4gIGRlZihhcnJheU1ldGhvZHMsIG1ldGhvZCwgZnVuY3Rpb24gbXV0YXRvcigpIHtcbiAgICB2YXIgYXJncyA9IFtdLFxuICAgICAgICBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHdoaWxlIChsZW4tLSkgYXJnc1tsZW5dID0gYXJndW1lbnRzW2xlbl07XG5cbiAgICB2YXIgcmVzdWx0ID0gb3JpZ2luYWwuYXBwbHkodGhpcywgYXJncyk7XG4gICAgdmFyIG9iID0gdGhpcy5fX29iX187XG4gICAgdmFyIGluc2VydGVkO1xuICAgIHN3aXRjaCAobWV0aG9kKSB7XG4gICAgICBjYXNlICdwdXNoJzpcbiAgICAgIGNhc2UgJ3Vuc2hpZnQnOlxuICAgICAgICBpbnNlcnRlZCA9IGFyZ3M7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnc3BsaWNlJzpcbiAgICAgICAgaW5zZXJ0ZWQgPSBhcmdzLnNsaWNlKDIpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgaWYgKGluc2VydGVkKSB7XG4gICAgICBvYi5vYnNlcnZlQXJyYXkoaW5zZXJ0ZWQpO1xuICAgIH1cbiAgICAvLyBub3RpZnkgY2hhbmdlXG4gICAgb2IuZGVwLm5vdGlmeSgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0pO1xufSk7XG5cbi8qICAqL1xuXG52YXIgYXJyYXlLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoYXJyYXlNZXRob2RzKTtcblxuLyoqXG4gKiBCeSBkZWZhdWx0LCB3aGVuIGEgcmVhY3RpdmUgcHJvcGVydHkgaXMgc2V0LCB0aGUgbmV3IHZhbHVlIGlzXG4gKiBhbHNvIGNvbnZlcnRlZCB0byBiZWNvbWUgcmVhY3RpdmUuIEhvd2V2ZXIgd2hlbiBwYXNzaW5nIGRvd24gcHJvcHMsXG4gKiB3ZSBkb24ndCB3YW50IHRvIGZvcmNlIGNvbnZlcnNpb24gYmVjYXVzZSB0aGUgdmFsdWUgbWF5IGJlIGEgbmVzdGVkIHZhbHVlXG4gKiB1bmRlciBhIGZyb3plbiBkYXRhIHN0cnVjdHVyZS4gQ29udmVydGluZyBpdCB3b3VsZCBkZWZlYXQgdGhlIG9wdGltaXphdGlvbi5cbiAqL1xudmFyIG9ic2VydmVyU3RhdGUgPSB7XG4gIHNob3VsZENvbnZlcnQ6IHRydWVcbn07XG5cbi8qKlxuICogT2JzZXJ2ZXIgY2xhc3MgdGhhdCBhcmUgYXR0YWNoZWQgdG8gZWFjaCBvYnNlcnZlZFxuICogb2JqZWN0LiBPbmNlIGF0dGFjaGVkLCB0aGUgb2JzZXJ2ZXIgY29udmVydHMgdGFyZ2V0XG4gKiBvYmplY3QncyBwcm9wZXJ0eSBrZXlzIGludG8gZ2V0dGVyL3NldHRlcnMgdGhhdFxuICogY29sbGVjdCBkZXBlbmRlbmNpZXMgYW5kIGRpc3BhdGNoZXMgdXBkYXRlcy5cbiAqL1xudmFyIE9ic2VydmVyID0gZnVuY3Rpb24gT2JzZXJ2ZXIodmFsdWUpIHtcbiAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICB0aGlzLmRlcCA9IG5ldyBEZXAoKTtcbiAgdGhpcy52bUNvdW50ID0gMDtcbiAgZGVmKHZhbHVlLCAnX19vYl9fJywgdGhpcyk7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHZhciBhdWdtZW50ID0gaGFzUHJvdG8gPyBwcm90b0F1Z21lbnQgOiBjb3B5QXVnbWVudDtcbiAgICBhdWdtZW50KHZhbHVlLCBhcnJheU1ldGhvZHMsIGFycmF5S2V5cyk7XG4gICAgdGhpcy5vYnNlcnZlQXJyYXkodmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMud2Fsayh2YWx1ZSk7XG4gIH1cbn07XG5cbi8qKlxuICogV2FsayB0aHJvdWdoIGVhY2ggcHJvcGVydHkgYW5kIGNvbnZlcnQgdGhlbSBpbnRvXG4gKiBnZXR0ZXIvc2V0dGVycy4gVGhpcyBtZXRob2Qgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIHdoZW5cbiAqIHZhbHVlIHR5cGUgaXMgT2JqZWN0LlxuICovXG5PYnNlcnZlci5wcm90b3R5cGUud2FsayA9IGZ1bmN0aW9uIHdhbGsob2JqKSB7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgZGVmaW5lUmVhY3RpdmUkJDEob2JqLCBrZXlzW2ldLCBvYmpba2V5c1tpXV0pO1xuICB9XG59O1xuXG4vKipcbiAqIE9ic2VydmUgYSBsaXN0IG9mIEFycmF5IGl0ZW1zLlxuICovXG5PYnNlcnZlci5wcm90b3R5cGUub2JzZXJ2ZUFycmF5ID0gZnVuY3Rpb24gb2JzZXJ2ZUFycmF5KGl0ZW1zKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gaXRlbXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgb2JzZXJ2ZShpdGVtc1tpXSk7XG4gIH1cbn07XG5cbi8vIGhlbHBlcnNcblxuLyoqXG4gKiBBdWdtZW50IGFuIHRhcmdldCBPYmplY3Qgb3IgQXJyYXkgYnkgaW50ZXJjZXB0aW5nXG4gKiB0aGUgcHJvdG90eXBlIGNoYWluIHVzaW5nIF9fcHJvdG9fX1xuICovXG5mdW5jdGlvbiBwcm90b0F1Z21lbnQodGFyZ2V0LCBzcmMsIGtleXMpIHtcbiAgLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cbiAgdGFyZ2V0Ll9fcHJvdG9fXyA9IHNyYztcbiAgLyogZXNsaW50LWVuYWJsZSBuby1wcm90byAqL1xufVxuXG4vKipcbiAqIEF1Z21lbnQgYW4gdGFyZ2V0IE9iamVjdCBvciBBcnJheSBieSBkZWZpbmluZ1xuICogaGlkZGVuIHByb3BlcnRpZXMuXG4gKi9cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5mdW5jdGlvbiBjb3B5QXVnbWVudCh0YXJnZXQsIHNyYywga2V5cykge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgZGVmKHRhcmdldCwga2V5LCBzcmNba2V5XSk7XG4gIH1cbn1cblxuLyoqXG4gKiBBdHRlbXB0IHRvIGNyZWF0ZSBhbiBvYnNlcnZlciBpbnN0YW5jZSBmb3IgYSB2YWx1ZSxcbiAqIHJldHVybnMgdGhlIG5ldyBvYnNlcnZlciBpZiBzdWNjZXNzZnVsbHkgb2JzZXJ2ZWQsXG4gKiBvciB0aGUgZXhpc3Rpbmcgb2JzZXJ2ZXIgaWYgdGhlIHZhbHVlIGFscmVhZHkgaGFzIG9uZS5cbiAqL1xuZnVuY3Rpb24gb2JzZXJ2ZSh2YWx1ZSwgYXNSb290RGF0YSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgb2I7XG4gIGlmIChoYXNPd24odmFsdWUsICdfX29iX18nKSAmJiB2YWx1ZS5fX29iX18gaW5zdGFuY2VvZiBPYnNlcnZlcikge1xuICAgIG9iID0gdmFsdWUuX19vYl9fO1xuICB9IGVsc2UgaWYgKG9ic2VydmVyU3RhdGUuc2hvdWxkQ29udmVydCAmJiAhaXNTZXJ2ZXJSZW5kZXJpbmcoKSAmJiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgfHwgaXNQbGFpbk9iamVjdCh2YWx1ZSkpICYmIE9iamVjdC5pc0V4dGVuc2libGUodmFsdWUpICYmICF2YWx1ZS5faXNWdWUpIHtcbiAgICBvYiA9IG5ldyBPYnNlcnZlcih2YWx1ZSk7XG4gIH1cbiAgaWYgKGFzUm9vdERhdGEgJiYgb2IpIHtcbiAgICBvYi52bUNvdW50Kys7XG4gIH1cbiAgcmV0dXJuIG9iO1xufVxuXG4vKipcbiAqIERlZmluZSBhIHJlYWN0aXZlIHByb3BlcnR5IG9uIGFuIE9iamVjdC5cbiAqL1xuZnVuY3Rpb24gZGVmaW5lUmVhY3RpdmUkJDEob2JqLCBrZXksIHZhbCwgY3VzdG9tU2V0dGVyLCBzaGFsbG93KSB7XG4gIHZhciBkZXAgPSBuZXcgRGVwKCk7XG5cbiAgdmFyIHByb3BlcnR5ID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSk7XG4gIGlmIChwcm9wZXJ0eSAmJiBwcm9wZXJ0eS5jb25maWd1cmFibGUgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gY2F0ZXIgZm9yIHByZS1kZWZpbmVkIGdldHRlci9zZXR0ZXJzXG4gIHZhciBnZXR0ZXIgPSBwcm9wZXJ0eSAmJiBwcm9wZXJ0eS5nZXQ7XG4gIHZhciBzZXR0ZXIgPSBwcm9wZXJ0eSAmJiBwcm9wZXJ0eS5zZXQ7XG5cbiAgdmFyIGNoaWxkT2IgPSAhc2hhbGxvdyAmJiBvYnNlcnZlKHZhbCk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gcmVhY3RpdmVHZXR0ZXIoKSB7XG4gICAgICB2YXIgdmFsdWUgPSBnZXR0ZXIgPyBnZXR0ZXIuY2FsbChvYmopIDogdmFsO1xuICAgICAgaWYgKERlcC50YXJnZXQpIHtcbiAgICAgICAgZGVwLmRlcGVuZCgpO1xuICAgICAgICBpZiAoY2hpbGRPYikge1xuICAgICAgICAgIGNoaWxkT2IuZGVwLmRlcGVuZCgpO1xuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgZGVwZW5kQXJyYXkodmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiByZWFjdGl2ZVNldHRlcihuZXdWYWwpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGdldHRlciA/IGdldHRlci5jYWxsKG9iaikgOiB2YWw7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1zZWxmLWNvbXBhcmUgKi9cbiAgICAgIGlmIChuZXdWYWwgPT09IHZhbHVlIHx8IG5ld1ZhbCAhPT0gbmV3VmFsICYmIHZhbHVlICE9PSB2YWx1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXNlbGYtY29tcGFyZSAqL1xuICAgICAgaWYgKGZhbHNlKSB7XG4gICAgICAgIGN1c3RvbVNldHRlcigpO1xuICAgICAgfVxuICAgICAgaWYgKHNldHRlcikge1xuICAgICAgICBzZXR0ZXIuY2FsbChvYmosIG5ld1ZhbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWwgPSBuZXdWYWw7XG4gICAgICB9XG4gICAgICBjaGlsZE9iID0gIXNoYWxsb3cgJiYgb2JzZXJ2ZShuZXdWYWwpO1xuICAgICAgZGVwLm5vdGlmeSgpO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogU2V0IGEgcHJvcGVydHkgb24gYW4gb2JqZWN0LiBBZGRzIHRoZSBuZXcgcHJvcGVydHkgYW5kXG4gKiB0cmlnZ2VycyBjaGFuZ2Ugbm90aWZpY2F0aW9uIGlmIHRoZSBwcm9wZXJ0eSBkb2Vzbid0XG4gKiBhbHJlYWR5IGV4aXN0LlxuICovXG5mdW5jdGlvbiBzZXQodGFyZ2V0LCBrZXksIHZhbCkge1xuICBpZiAoQXJyYXkuaXNBcnJheSh0YXJnZXQpICYmIGlzVmFsaWRBcnJheUluZGV4KGtleSkpIHtcbiAgICB0YXJnZXQubGVuZ3RoID0gTWF0aC5tYXgodGFyZ2V0Lmxlbmd0aCwga2V5KTtcbiAgICB0YXJnZXQuc3BsaWNlKGtleSwgMSwgdmFsKTtcbiAgICByZXR1cm4gdmFsO1xuICB9XG4gIGlmIChoYXNPd24odGFyZ2V0LCBrZXkpKSB7XG4gICAgdGFyZ2V0W2tleV0gPSB2YWw7XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuICB2YXIgb2IgPSB0YXJnZXQuX19vYl9fO1xuICBpZiAodGFyZ2V0Ll9pc1Z1ZSB8fCBvYiAmJiBvYi52bUNvdW50KSB7XG4gICAgXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKCdBdm9pZCBhZGRpbmcgcmVhY3RpdmUgcHJvcGVydGllcyB0byBhIFZ1ZSBpbnN0YW5jZSBvciBpdHMgcm9vdCAkZGF0YSAnICsgJ2F0IHJ1bnRpbWUgLSBkZWNsYXJlIGl0IHVwZnJvbnQgaW4gdGhlIGRhdGEgb3B0aW9uLicpO1xuICAgIHJldHVybiB2YWw7XG4gIH1cbiAgaWYgKCFvYikge1xuICAgIHRhcmdldFtrZXldID0gdmFsO1xuICAgIHJldHVybiB2YWw7XG4gIH1cbiAgZGVmaW5lUmVhY3RpdmUkJDEob2IudmFsdWUsIGtleSwgdmFsKTtcbiAgb2IuZGVwLm5vdGlmeSgpO1xuICByZXR1cm4gdmFsO1xufVxuXG4vKipcbiAqIERlbGV0ZSBhIHByb3BlcnR5IGFuZCB0cmlnZ2VyIGNoYW5nZSBpZiBuZWNlc3NhcnkuXG4gKi9cbmZ1bmN0aW9uIGRlbCh0YXJnZXQsIGtleSkge1xuICBpZiAoQXJyYXkuaXNBcnJheSh0YXJnZXQpICYmIGlzVmFsaWRBcnJheUluZGV4KGtleSkpIHtcbiAgICB0YXJnZXQuc3BsaWNlKGtleSwgMSk7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBvYiA9IHRhcmdldC5fX29iX187XG4gIGlmICh0YXJnZXQuX2lzVnVlIHx8IG9iICYmIG9iLnZtQ291bnQpIHtcbiAgICBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oJ0F2b2lkIGRlbGV0aW5nIHByb3BlcnRpZXMgb24gYSBWdWUgaW5zdGFuY2Ugb3IgaXRzIHJvb3QgJGRhdGEgJyArICctIGp1c3Qgc2V0IGl0IHRvIG51bGwuJyk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICghaGFzT3duKHRhcmdldCwga2V5KSkge1xuICAgIHJldHVybjtcbiAgfVxuICBkZWxldGUgdGFyZ2V0W2tleV07XG4gIGlmICghb2IpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgb2IuZGVwLm5vdGlmeSgpO1xufVxuXG4vKipcbiAqIENvbGxlY3QgZGVwZW5kZW5jaWVzIG9uIGFycmF5IGVsZW1lbnRzIHdoZW4gdGhlIGFycmF5IGlzIHRvdWNoZWQsIHNpbmNlXG4gKiB3ZSBjYW5ub3QgaW50ZXJjZXB0IGFycmF5IGVsZW1lbnQgYWNjZXNzIGxpa2UgcHJvcGVydHkgZ2V0dGVycy5cbiAqL1xuZnVuY3Rpb24gZGVwZW5kQXJyYXkodmFsdWUpIHtcbiAgZm9yICh2YXIgZSA9IHZvaWQgMCwgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBlID0gdmFsdWVbaV07XG4gICAgZSAmJiBlLl9fb2JfXyAmJiBlLl9fb2JfXy5kZXAuZGVwZW5kKCk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZSkpIHtcbiAgICAgIGRlcGVuZEFycmF5KGUpO1xuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBPcHRpb24gb3ZlcndyaXRpbmcgc3RyYXRlZ2llcyBhcmUgZnVuY3Rpb25zIHRoYXQgaGFuZGxlXG4gKiBob3cgdG8gbWVyZ2UgYSBwYXJlbnQgb3B0aW9uIHZhbHVlIGFuZCBhIGNoaWxkIG9wdGlvblxuICogdmFsdWUgaW50byB0aGUgZmluYWwgdmFsdWUuXG4gKi9cbnZhciBzdHJhdHMgPSBjb25maWcub3B0aW9uTWVyZ2VTdHJhdGVnaWVzO1xuXG4vKipcbiAqIE9wdGlvbnMgd2l0aCByZXN0cmljdGlvbnNcbiAqL1xuaWYgKGZhbHNlKSB7XG4gIHN0cmF0cy5lbCA9IHN0cmF0cy5wcm9wc0RhdGEgPSBmdW5jdGlvbiAocGFyZW50LCBjaGlsZCwgdm0sIGtleSkge1xuICAgIGlmICghdm0pIHtcbiAgICAgIHdhcm4oXCJvcHRpb24gXFxcIlwiICsga2V5ICsgXCJcXFwiIGNhbiBvbmx5IGJlIHVzZWQgZHVyaW5nIGluc3RhbmNlIFwiICsgJ2NyZWF0aW9uIHdpdGggdGhlIGBuZXdgIGtleXdvcmQuJyk7XG4gICAgfVxuICAgIHJldHVybiBkZWZhdWx0U3RyYXQocGFyZW50LCBjaGlsZCk7XG4gIH07XG59XG5cbi8qKlxuICogSGVscGVyIHRoYXQgcmVjdXJzaXZlbHkgbWVyZ2VzIHR3byBkYXRhIG9iamVjdHMgdG9nZXRoZXIuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlRGF0YSh0bywgZnJvbSkge1xuICBpZiAoIWZyb20pIHtcbiAgICByZXR1cm4gdG87XG4gIH1cbiAgdmFyIGtleSwgdG9WYWwsIGZyb21WYWw7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZnJvbSk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGtleSA9IGtleXNbaV07XG4gICAgdG9WYWwgPSB0b1trZXldO1xuICAgIGZyb21WYWwgPSBmcm9tW2tleV07XG4gICAgaWYgKCFoYXNPd24odG8sIGtleSkpIHtcbiAgICAgIHNldCh0bywga2V5LCBmcm9tVmFsKTtcbiAgICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3QodG9WYWwpICYmIGlzUGxhaW5PYmplY3QoZnJvbVZhbCkpIHtcbiAgICAgIG1lcmdlRGF0YSh0b1ZhbCwgZnJvbVZhbCk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0bztcbn1cblxuLyoqXG4gKiBEYXRhXG4gKi9cbmZ1bmN0aW9uIG1lcmdlRGF0YU9yRm4ocGFyZW50VmFsLCBjaGlsZFZhbCwgdm0pIHtcbiAgaWYgKCF2bSkge1xuICAgIC8vIGluIGEgVnVlLmV4dGVuZCBtZXJnZSwgYm90aCBzaG91bGQgYmUgZnVuY3Rpb25zXG4gICAgaWYgKCFjaGlsZFZhbCkge1xuICAgICAgcmV0dXJuIHBhcmVudFZhbDtcbiAgICB9XG4gICAgaWYgKCFwYXJlbnRWYWwpIHtcbiAgICAgIHJldHVybiBjaGlsZFZhbDtcbiAgICB9XG4gICAgLy8gd2hlbiBwYXJlbnRWYWwgJiBjaGlsZFZhbCBhcmUgYm90aCBwcmVzZW50LFxuICAgIC8vIHdlIG5lZWQgdG8gcmV0dXJuIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZVxuICAgIC8vIG1lcmdlZCByZXN1bHQgb2YgYm90aCBmdW5jdGlvbnMuLi4gbm8gbmVlZCB0b1xuICAgIC8vIGNoZWNrIGlmIHBhcmVudFZhbCBpcyBhIGZ1bmN0aW9uIGhlcmUgYmVjYXVzZVxuICAgIC8vIGl0IGhhcyB0byBiZSBhIGZ1bmN0aW9uIHRvIHBhc3MgcHJldmlvdXMgbWVyZ2VzLlxuICAgIHJldHVybiBmdW5jdGlvbiBtZXJnZWREYXRhRm4oKSB7XG4gICAgICByZXR1cm4gbWVyZ2VEYXRhKHR5cGVvZiBjaGlsZFZhbCA9PT0gJ2Z1bmN0aW9uJyA/IGNoaWxkVmFsLmNhbGwodGhpcykgOiBjaGlsZFZhbCwgdHlwZW9mIHBhcmVudFZhbCA9PT0gJ2Z1bmN0aW9uJyA/IHBhcmVudFZhbC5jYWxsKHRoaXMpIDogcGFyZW50VmFsKTtcbiAgICB9O1xuICB9IGVsc2UgaWYgKHBhcmVudFZhbCB8fCBjaGlsZFZhbCkge1xuICAgIHJldHVybiBmdW5jdGlvbiBtZXJnZWRJbnN0YW5jZURhdGFGbigpIHtcbiAgICAgIC8vIGluc3RhbmNlIG1lcmdlXG4gICAgICB2YXIgaW5zdGFuY2VEYXRhID0gdHlwZW9mIGNoaWxkVmFsID09PSAnZnVuY3Rpb24nID8gY2hpbGRWYWwuY2FsbCh2bSkgOiBjaGlsZFZhbDtcbiAgICAgIHZhciBkZWZhdWx0RGF0YSA9IHR5cGVvZiBwYXJlbnRWYWwgPT09ICdmdW5jdGlvbicgPyBwYXJlbnRWYWwuY2FsbCh2bSkgOiBwYXJlbnRWYWw7XG4gICAgICBpZiAoaW5zdGFuY2VEYXRhKSB7XG4gICAgICAgIHJldHVybiBtZXJnZURhdGEoaW5zdGFuY2VEYXRhLCBkZWZhdWx0RGF0YSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZGVmYXVsdERhdGE7XG4gICAgICB9XG4gICAgfTtcbiAgfVxufVxuXG5zdHJhdHMuZGF0YSA9IGZ1bmN0aW9uIChwYXJlbnRWYWwsIGNoaWxkVmFsLCB2bSkge1xuICBpZiAoIXZtKSB7XG4gICAgaWYgKGNoaWxkVmFsICYmIHR5cGVvZiBjaGlsZFZhbCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKCdUaGUgXCJkYXRhXCIgb3B0aW9uIHNob3VsZCBiZSBhIGZ1bmN0aW9uICcgKyAndGhhdCByZXR1cm5zIGEgcGVyLWluc3RhbmNlIHZhbHVlIGluIGNvbXBvbmVudCAnICsgJ2RlZmluaXRpb25zLicsIHZtKTtcblxuICAgICAgcmV0dXJuIHBhcmVudFZhbDtcbiAgICB9XG4gICAgcmV0dXJuIG1lcmdlRGF0YU9yRm4uY2FsbCh0aGlzLCBwYXJlbnRWYWwsIGNoaWxkVmFsKTtcbiAgfVxuXG4gIHJldHVybiBtZXJnZURhdGFPckZuKHBhcmVudFZhbCwgY2hpbGRWYWwsIHZtKTtcbn07XG5cbi8qKlxuICogSG9va3MgYW5kIHByb3BzIGFyZSBtZXJnZWQgYXMgYXJyYXlzLlxuICovXG5mdW5jdGlvbiBtZXJnZUhvb2socGFyZW50VmFsLCBjaGlsZFZhbCkge1xuICByZXR1cm4gY2hpbGRWYWwgPyBwYXJlbnRWYWwgPyBwYXJlbnRWYWwuY29uY2F0KGNoaWxkVmFsKSA6IEFycmF5LmlzQXJyYXkoY2hpbGRWYWwpID8gY2hpbGRWYWwgOiBbY2hpbGRWYWxdIDogcGFyZW50VmFsO1xufVxuXG5MSUZFQ1lDTEVfSE9PS1MuZm9yRWFjaChmdW5jdGlvbiAoaG9vaykge1xuICBzdHJhdHNbaG9va10gPSBtZXJnZUhvb2s7XG59KTtcblxuLyoqXG4gKiBBc3NldHNcbiAqXG4gKiBXaGVuIGEgdm0gaXMgcHJlc2VudCAoaW5zdGFuY2UgY3JlYXRpb24pLCB3ZSBuZWVkIHRvIGRvXG4gKiBhIHRocmVlLXdheSBtZXJnZSBiZXR3ZWVuIGNvbnN0cnVjdG9yIG9wdGlvbnMsIGluc3RhbmNlXG4gKiBvcHRpb25zIGFuZCBwYXJlbnQgb3B0aW9ucy5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VBc3NldHMocGFyZW50VmFsLCBjaGlsZFZhbCkge1xuICB2YXIgcmVzID0gT2JqZWN0LmNyZWF0ZShwYXJlbnRWYWwgfHwgbnVsbCk7XG4gIHJldHVybiBjaGlsZFZhbCA/IGV4dGVuZChyZXMsIGNoaWxkVmFsKSA6IHJlcztcbn1cblxuQVNTRVRfVFlQRVMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICBzdHJhdHNbdHlwZSArICdzJ10gPSBtZXJnZUFzc2V0cztcbn0pO1xuXG4vKipcbiAqIFdhdGNoZXJzLlxuICpcbiAqIFdhdGNoZXJzIGhhc2hlcyBzaG91bGQgbm90IG92ZXJ3cml0ZSBvbmVcbiAqIGFub3RoZXIsIHNvIHdlIG1lcmdlIHRoZW0gYXMgYXJyYXlzLlxuICovXG5zdHJhdHMud2F0Y2ggPSBmdW5jdGlvbiAocGFyZW50VmFsLCBjaGlsZFZhbCkge1xuICAvLyB3b3JrIGFyb3VuZCBGaXJlZm94J3MgT2JqZWN0LnByb3RvdHlwZS53YXRjaC4uLlxuICBpZiAocGFyZW50VmFsID09PSBuYXRpdmVXYXRjaCkge1xuICAgIHBhcmVudFZhbCA9IHVuZGVmaW5lZDtcbiAgfVxuICBpZiAoY2hpbGRWYWwgPT09IG5hdGl2ZVdhdGNoKSB7XG4gICAgY2hpbGRWYWwgPSB1bmRlZmluZWQ7XG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICghY2hpbGRWYWwpIHtcbiAgICByZXR1cm4gT2JqZWN0LmNyZWF0ZShwYXJlbnRWYWwgfHwgbnVsbCk7XG4gIH1cbiAgaWYgKCFwYXJlbnRWYWwpIHtcbiAgICByZXR1cm4gY2hpbGRWYWw7XG4gIH1cbiAgdmFyIHJldCA9IHt9O1xuICBleHRlbmQocmV0LCBwYXJlbnRWYWwpO1xuICBmb3IgKHZhciBrZXkgaW4gY2hpbGRWYWwpIHtcbiAgICB2YXIgcGFyZW50ID0gcmV0W2tleV07XG4gICAgdmFyIGNoaWxkID0gY2hpbGRWYWxba2V5XTtcbiAgICBpZiAocGFyZW50ICYmICFBcnJheS5pc0FycmF5KHBhcmVudCkpIHtcbiAgICAgIHBhcmVudCA9IFtwYXJlbnRdO1xuICAgIH1cbiAgICByZXRba2V5XSA9IHBhcmVudCA/IHBhcmVudC5jb25jYXQoY2hpbGQpIDogQXJyYXkuaXNBcnJheShjaGlsZCkgPyBjaGlsZCA6IFtjaGlsZF07XG4gIH1cbiAgcmV0dXJuIHJldDtcbn07XG5cbi8qKlxuICogT3RoZXIgb2JqZWN0IGhhc2hlcy5cbiAqL1xuc3RyYXRzLnByb3BzID0gc3RyYXRzLm1ldGhvZHMgPSBzdHJhdHMuaW5qZWN0ID0gc3RyYXRzLmNvbXB1dGVkID0gZnVuY3Rpb24gKHBhcmVudFZhbCwgY2hpbGRWYWwpIHtcbiAgaWYgKCFwYXJlbnRWYWwpIHtcbiAgICByZXR1cm4gY2hpbGRWYWw7XG4gIH1cbiAgdmFyIHJldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGV4dGVuZChyZXQsIHBhcmVudFZhbCk7XG4gIGlmIChjaGlsZFZhbCkge1xuICAgIGV4dGVuZChyZXQsIGNoaWxkVmFsKTtcbiAgfVxuICByZXR1cm4gcmV0O1xufTtcbnN0cmF0cy5wcm92aWRlID0gbWVyZ2VEYXRhT3JGbjtcblxuLyoqXG4gKiBEZWZhdWx0IHN0cmF0ZWd5LlxuICovXG52YXIgZGVmYXVsdFN0cmF0ID0gZnVuY3Rpb24gKHBhcmVudFZhbCwgY2hpbGRWYWwpIHtcbiAgcmV0dXJuIGNoaWxkVmFsID09PSB1bmRlZmluZWQgPyBwYXJlbnRWYWwgOiBjaGlsZFZhbDtcbn07XG5cbi8qKlxuICogVmFsaWRhdGUgY29tcG9uZW50IG5hbWVzXG4gKi9cbmZ1bmN0aW9uIGNoZWNrQ29tcG9uZW50cyhvcHRpb25zKSB7XG4gIGZvciAodmFyIGtleSBpbiBvcHRpb25zLmNvbXBvbmVudHMpIHtcbiAgICB2YXIgbG93ZXIgPSBrZXkudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAoaXNCdWlsdEluVGFnKGxvd2VyKSB8fCBjb25maWcuaXNSZXNlcnZlZFRhZyhsb3dlcikpIHtcbiAgICAgIHdhcm4oJ0RvIG5vdCB1c2UgYnVpbHQtaW4gb3IgcmVzZXJ2ZWQgSFRNTCBlbGVtZW50cyBhcyBjb21wb25lbnQgJyArICdpZDogJyArIGtleSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogRW5zdXJlIGFsbCBwcm9wcyBvcHRpb24gc3ludGF4IGFyZSBub3JtYWxpemVkIGludG8gdGhlXG4gKiBPYmplY3QtYmFzZWQgZm9ybWF0LlxuICovXG5mdW5jdGlvbiBub3JtYWxpemVQcm9wcyhvcHRpb25zKSB7XG4gIHZhciBwcm9wcyA9IG9wdGlvbnMucHJvcHM7XG4gIGlmICghcHJvcHMpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIHJlcyA9IHt9O1xuICB2YXIgaSwgdmFsLCBuYW1lO1xuICBpZiAoQXJyYXkuaXNBcnJheShwcm9wcykpIHtcbiAgICBpID0gcHJvcHMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHZhbCA9IHByb3BzW2ldO1xuICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG5hbWUgPSBjYW1lbGl6ZSh2YWwpO1xuICAgICAgICByZXNbbmFtZV0gPSB7IHR5cGU6IG51bGwgfTtcbiAgICAgIH0gZWxzZSBpZiAoZmFsc2UpIHtcbiAgICAgICAgd2FybigncHJvcHMgbXVzdCBiZSBzdHJpbmdzIHdoZW4gdXNpbmcgYXJyYXkgc3ludGF4LicpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHByb3BzKSkge1xuICAgIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xuICAgICAgdmFsID0gcHJvcHNba2V5XTtcbiAgICAgIG5hbWUgPSBjYW1lbGl6ZShrZXkpO1xuICAgICAgcmVzW25hbWVdID0gaXNQbGFpbk9iamVjdCh2YWwpID8gdmFsIDogeyB0eXBlOiB2YWwgfTtcbiAgICB9XG4gIH1cbiAgb3B0aW9ucy5wcm9wcyA9IHJlcztcbn1cblxuLyoqXG4gKiBOb3JtYWxpemUgYWxsIGluamVjdGlvbnMgaW50byBPYmplY3QtYmFzZWQgZm9ybWF0XG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZUluamVjdChvcHRpb25zKSB7XG4gIHZhciBpbmplY3QgPSBvcHRpb25zLmluamVjdDtcbiAgaWYgKEFycmF5LmlzQXJyYXkoaW5qZWN0KSkge1xuICAgIHZhciBub3JtYWxpemVkID0gb3B0aW9ucy5pbmplY3QgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluamVjdC5sZW5ndGg7IGkrKykge1xuICAgICAgbm9ybWFsaXplZFtpbmplY3RbaV1dID0gaW5qZWN0W2ldO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIE5vcm1hbGl6ZSByYXcgZnVuY3Rpb24gZGlyZWN0aXZlcyBpbnRvIG9iamVjdCBmb3JtYXQuXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZURpcmVjdGl2ZXMob3B0aW9ucykge1xuICB2YXIgZGlycyA9IG9wdGlvbnMuZGlyZWN0aXZlcztcbiAgaWYgKGRpcnMpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gZGlycykge1xuICAgICAgdmFyIGRlZiA9IGRpcnNba2V5XTtcbiAgICAgIGlmICh0eXBlb2YgZGVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGRpcnNba2V5XSA9IHsgYmluZDogZGVmLCB1cGRhdGU6IGRlZiB9O1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIE1lcmdlIHR3byBvcHRpb24gb2JqZWN0cyBpbnRvIGEgbmV3IG9uZS5cbiAqIENvcmUgdXRpbGl0eSB1c2VkIGluIGJvdGggaW5zdGFudGlhdGlvbiBhbmQgaW5oZXJpdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlT3B0aW9ucyhwYXJlbnQsIGNoaWxkLCB2bSkge1xuICBpZiAoZmFsc2UpIHtcbiAgICBjaGVja0NvbXBvbmVudHMoY2hpbGQpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBjaGlsZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNoaWxkID0gY2hpbGQub3B0aW9ucztcbiAgfVxuXG4gIG5vcm1hbGl6ZVByb3BzKGNoaWxkKTtcbiAgbm9ybWFsaXplSW5qZWN0KGNoaWxkKTtcbiAgbm9ybWFsaXplRGlyZWN0aXZlcyhjaGlsZCk7XG4gIHZhciBleHRlbmRzRnJvbSA9IGNoaWxkLmV4dGVuZHM7XG4gIGlmIChleHRlbmRzRnJvbSkge1xuICAgIHBhcmVudCA9IG1lcmdlT3B0aW9ucyhwYXJlbnQsIGV4dGVuZHNGcm9tLCB2bSk7XG4gIH1cbiAgaWYgKGNoaWxkLm1peGlucykge1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGQubWl4aW5zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgcGFyZW50ID0gbWVyZ2VPcHRpb25zKHBhcmVudCwgY2hpbGQubWl4aW5zW2ldLCB2bSk7XG4gICAgfVxuICB9XG4gIHZhciBvcHRpb25zID0ge307XG4gIHZhciBrZXk7XG4gIGZvciAoa2V5IGluIHBhcmVudCkge1xuICAgIG1lcmdlRmllbGQoa2V5KTtcbiAgfVxuICBmb3IgKGtleSBpbiBjaGlsZCkge1xuICAgIGlmICghaGFzT3duKHBhcmVudCwga2V5KSkge1xuICAgICAgbWVyZ2VGaWVsZChrZXkpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBtZXJnZUZpZWxkKGtleSkge1xuICAgIHZhciBzdHJhdCA9IHN0cmF0c1trZXldIHx8IGRlZmF1bHRTdHJhdDtcbiAgICBvcHRpb25zW2tleV0gPSBzdHJhdChwYXJlbnRba2V5XSwgY2hpbGRba2V5XSwgdm0sIGtleSk7XG4gIH1cbiAgcmV0dXJuIG9wdGlvbnM7XG59XG5cbi8qKlxuICogUmVzb2x2ZSBhbiBhc3NldC5cbiAqIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCBiZWNhdXNlIGNoaWxkIGluc3RhbmNlcyBuZWVkIGFjY2Vzc1xuICogdG8gYXNzZXRzIGRlZmluZWQgaW4gaXRzIGFuY2VzdG9yIGNoYWluLlxuICovXG5mdW5jdGlvbiByZXNvbHZlQXNzZXQob3B0aW9ucywgdHlwZSwgaWQsIHdhcm5NaXNzaW5nKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAodHlwZW9mIGlkICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgYXNzZXRzID0gb3B0aW9uc1t0eXBlXTtcbiAgLy8gY2hlY2sgbG9jYWwgcmVnaXN0cmF0aW9uIHZhcmlhdGlvbnMgZmlyc3RcbiAgaWYgKGhhc093bihhc3NldHMsIGlkKSkge1xuICAgIHJldHVybiBhc3NldHNbaWRdO1xuICB9XG4gIHZhciBjYW1lbGl6ZWRJZCA9IGNhbWVsaXplKGlkKTtcbiAgaWYgKGhhc093bihhc3NldHMsIGNhbWVsaXplZElkKSkge1xuICAgIHJldHVybiBhc3NldHNbY2FtZWxpemVkSWRdO1xuICB9XG4gIHZhciBQYXNjYWxDYXNlSWQgPSBjYXBpdGFsaXplKGNhbWVsaXplZElkKTtcbiAgaWYgKGhhc093bihhc3NldHMsIFBhc2NhbENhc2VJZCkpIHtcbiAgICByZXR1cm4gYXNzZXRzW1Bhc2NhbENhc2VJZF07XG4gIH1cbiAgLy8gZmFsbGJhY2sgdG8gcHJvdG90eXBlIGNoYWluXG4gIHZhciByZXMgPSBhc3NldHNbaWRdIHx8IGFzc2V0c1tjYW1lbGl6ZWRJZF0gfHwgYXNzZXRzW1Bhc2NhbENhc2VJZF07XG4gIGlmIChmYWxzZSkge1xuICAgIHdhcm4oJ0ZhaWxlZCB0byByZXNvbHZlICcgKyB0eXBlLnNsaWNlKDAsIC0xKSArICc6ICcgKyBpZCwgb3B0aW9ucyk7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcChrZXksIHByb3BPcHRpb25zLCBwcm9wc0RhdGEsIHZtKSB7XG4gIHZhciBwcm9wID0gcHJvcE9wdGlvbnNba2V5XTtcbiAgdmFyIGFic2VudCA9ICFoYXNPd24ocHJvcHNEYXRhLCBrZXkpO1xuICB2YXIgdmFsdWUgPSBwcm9wc0RhdGFba2V5XTtcbiAgLy8gaGFuZGxlIGJvb2xlYW4gcHJvcHNcbiAgaWYgKGlzVHlwZShCb29sZWFuLCBwcm9wLnR5cGUpKSB7XG4gICAgaWYgKGFic2VudCAmJiAhaGFzT3duKHByb3AsICdkZWZhdWx0JykpIHtcbiAgICAgIHZhbHVlID0gZmFsc2U7XG4gICAgfSBlbHNlIGlmICghaXNUeXBlKFN0cmluZywgcHJvcC50eXBlKSAmJiAodmFsdWUgPT09ICcnIHx8IHZhbHVlID09PSBoeXBoZW5hdGUoa2V5KSkpIHtcbiAgICAgIHZhbHVlID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgLy8gY2hlY2sgZGVmYXVsdCB2YWx1ZVxuICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHZhbHVlID0gZ2V0UHJvcERlZmF1bHRWYWx1ZSh2bSwgcHJvcCwga2V5KTtcbiAgICAvLyBzaW5jZSB0aGUgZGVmYXVsdCB2YWx1ZSBpcyBhIGZyZXNoIGNvcHksXG4gICAgLy8gbWFrZSBzdXJlIHRvIG9ic2VydmUgaXQuXG4gICAgdmFyIHByZXZTaG91bGRDb252ZXJ0ID0gb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0O1xuICAgIG9ic2VydmVyU3RhdGUuc2hvdWxkQ29udmVydCA9IHRydWU7XG4gICAgb2JzZXJ2ZSh2YWx1ZSk7XG4gICAgb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0ID0gcHJldlNob3VsZENvbnZlcnQ7XG4gIH1cbiAgaWYgKGZhbHNlKSB7XG4gICAgYXNzZXJ0UHJvcChwcm9wLCBrZXksIHZhbHVlLCB2bSwgYWJzZW50KTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5cbi8qKlxuICogR2V0IHRoZSBkZWZhdWx0IHZhbHVlIG9mIGEgcHJvcC5cbiAqL1xuZnVuY3Rpb24gZ2V0UHJvcERlZmF1bHRWYWx1ZSh2bSwgcHJvcCwga2V5KSB7XG4gIC8vIG5vIGRlZmF1bHQsIHJldHVybiB1bmRlZmluZWRcbiAgaWYgKCFoYXNPd24ocHJvcCwgJ2RlZmF1bHQnKSkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgdmFyIGRlZiA9IHByb3AuZGVmYXVsdDtcbiAgLy8gd2FybiBhZ2FpbnN0IG5vbi1mYWN0b3J5IGRlZmF1bHRzIGZvciBPYmplY3QgJiBBcnJheVxuICBpZiAoZmFsc2UpIHtcbiAgICB3YXJuKCdJbnZhbGlkIGRlZmF1bHQgdmFsdWUgZm9yIHByb3AgXCInICsga2V5ICsgJ1wiOiAnICsgJ1Byb3BzIHdpdGggdHlwZSBPYmplY3QvQXJyYXkgbXVzdCB1c2UgYSBmYWN0b3J5IGZ1bmN0aW9uICcgKyAndG8gcmV0dXJuIHRoZSBkZWZhdWx0IHZhbHVlLicsIHZtKTtcbiAgfVxuICAvLyB0aGUgcmF3IHByb3AgdmFsdWUgd2FzIGFsc28gdW5kZWZpbmVkIGZyb20gcHJldmlvdXMgcmVuZGVyLFxuICAvLyByZXR1cm4gcHJldmlvdXMgZGVmYXVsdCB2YWx1ZSB0byBhdm9pZCB1bm5lY2Vzc2FyeSB3YXRjaGVyIHRyaWdnZXJcbiAgaWYgKHZtICYmIHZtLiRvcHRpb25zLnByb3BzRGF0YSAmJiB2bS4kb3B0aW9ucy5wcm9wc0RhdGFba2V5XSA9PT0gdW5kZWZpbmVkICYmIHZtLl9wcm9wc1trZXldICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gdm0uX3Byb3BzW2tleV07XG4gIH1cbiAgLy8gY2FsbCBmYWN0b3J5IGZ1bmN0aW9uIGZvciBub24tRnVuY3Rpb24gdHlwZXNcbiAgLy8gYSB2YWx1ZSBpcyBGdW5jdGlvbiBpZiBpdHMgcHJvdG90eXBlIGlzIGZ1bmN0aW9uIGV2ZW4gYWNyb3NzIGRpZmZlcmVudCBleGVjdXRpb24gY29udGV4dFxuICByZXR1cm4gdHlwZW9mIGRlZiA9PT0gJ2Z1bmN0aW9uJyAmJiBnZXRUeXBlKHByb3AudHlwZSkgIT09ICdGdW5jdGlvbicgPyBkZWYuY2FsbCh2bSkgOiBkZWY7XG59XG5cbi8qKlxuICogQXNzZXJ0IHdoZXRoZXIgYSBwcm9wIGlzIHZhbGlkLlxuICovXG5mdW5jdGlvbiBhc3NlcnRQcm9wKHByb3AsIG5hbWUsIHZhbHVlLCB2bSwgYWJzZW50KSB7XG4gIGlmIChwcm9wLnJlcXVpcmVkICYmIGFic2VudCkge1xuICAgIHdhcm4oJ01pc3NpbmcgcmVxdWlyZWQgcHJvcDogXCInICsgbmFtZSArICdcIicsIHZtKTtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHZhbHVlID09IG51bGwgJiYgIXByb3AucmVxdWlyZWQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIHR5cGUgPSBwcm9wLnR5cGU7XG4gIHZhciB2YWxpZCA9ICF0eXBlIHx8IHR5cGUgPT09IHRydWU7XG4gIHZhciBleHBlY3RlZFR5cGVzID0gW107XG4gIGlmICh0eXBlKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHR5cGUpKSB7XG4gICAgICB0eXBlID0gW3R5cGVdO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHR5cGUubGVuZ3RoICYmICF2YWxpZDsgaSsrKSB7XG4gICAgICB2YXIgYXNzZXJ0ZWRUeXBlID0gYXNzZXJ0VHlwZSh2YWx1ZSwgdHlwZVtpXSk7XG4gICAgICBleHBlY3RlZFR5cGVzLnB1c2goYXNzZXJ0ZWRUeXBlLmV4cGVjdGVkVHlwZSB8fCAnJyk7XG4gICAgICB2YWxpZCA9IGFzc2VydGVkVHlwZS52YWxpZDtcbiAgICB9XG4gIH1cbiAgaWYgKCF2YWxpZCkge1xuICAgIHdhcm4oJ0ludmFsaWQgcHJvcDogdHlwZSBjaGVjayBmYWlsZWQgZm9yIHByb3AgXCInICsgbmFtZSArICdcIi4nICsgJyBFeHBlY3RlZCAnICsgZXhwZWN0ZWRUeXBlcy5tYXAoY2FwaXRhbGl6ZSkuam9pbignLCAnKSArICcsIGdvdCAnICsgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKS5zbGljZSg4LCAtMSkgKyAnLicsIHZtKTtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIHZhbGlkYXRvciA9IHByb3AudmFsaWRhdG9yO1xuICBpZiAodmFsaWRhdG9yKSB7XG4gICAgaWYgKCF2YWxpZGF0b3IodmFsdWUpKSB7XG4gICAgICB3YXJuKCdJbnZhbGlkIHByb3A6IGN1c3RvbSB2YWxpZGF0b3IgY2hlY2sgZmFpbGVkIGZvciBwcm9wIFwiJyArIG5hbWUgKyAnXCIuJywgdm0pO1xuICAgIH1cbiAgfVxufVxuXG52YXIgc2ltcGxlQ2hlY2tSRSA9IC9eKFN0cmluZ3xOdW1iZXJ8Qm9vbGVhbnxGdW5jdGlvbnxTeW1ib2wpJC87XG5cbmZ1bmN0aW9uIGFzc2VydFR5cGUodmFsdWUsIHR5cGUpIHtcbiAgdmFyIHZhbGlkO1xuICB2YXIgZXhwZWN0ZWRUeXBlID0gZ2V0VHlwZSh0eXBlKTtcbiAgaWYgKHNpbXBsZUNoZWNrUkUudGVzdChleHBlY3RlZFR5cGUpKSB7XG4gICAgdmFyIHQgPSB0eXBlb2YgdmFsdWU7XG4gICAgdmFsaWQgPSB0ID09PSBleHBlY3RlZFR5cGUudG9Mb3dlckNhc2UoKTtcbiAgICAvLyBmb3IgcHJpbWl0aXZlIHdyYXBwZXIgb2JqZWN0c1xuICAgIGlmICghdmFsaWQgJiYgdCA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHZhbGlkID0gdmFsdWUgaW5zdGFuY2VvZiB0eXBlO1xuICAgIH1cbiAgfSBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09ICdPYmplY3QnKSB7XG4gICAgdmFsaWQgPSBpc1BsYWluT2JqZWN0KHZhbHVlKTtcbiAgfSBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09ICdBcnJheScpIHtcbiAgICB2YWxpZCA9IEFycmF5LmlzQXJyYXkodmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIHZhbGlkID0gdmFsdWUgaW5zdGFuY2VvZiB0eXBlO1xuICB9XG4gIHJldHVybiB7XG4gICAgdmFsaWQ6IHZhbGlkLFxuICAgIGV4cGVjdGVkVHlwZTogZXhwZWN0ZWRUeXBlXG4gIH07XG59XG5cbi8qKlxuICogVXNlIGZ1bmN0aW9uIHN0cmluZyBuYW1lIHRvIGNoZWNrIGJ1aWx0LWluIHR5cGVzLFxuICogYmVjYXVzZSBhIHNpbXBsZSBlcXVhbGl0eSBjaGVjayB3aWxsIGZhaWwgd2hlbiBydW5uaW5nXG4gKiBhY3Jvc3MgZGlmZmVyZW50IHZtcyAvIGlmcmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGdldFR5cGUoZm4pIHtcbiAgdmFyIG1hdGNoID0gZm4gJiYgZm4udG9TdHJpbmcoKS5tYXRjaCgvXlxccypmdW5jdGlvbiAoXFx3KykvKTtcbiAgcmV0dXJuIG1hdGNoID8gbWF0Y2hbMV0gOiAnJztcbn1cblxuZnVuY3Rpb24gaXNUeXBlKHR5cGUsIGZuKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShmbikpIHtcbiAgICByZXR1cm4gZ2V0VHlwZShmbikgPT09IGdldFR5cGUodHlwZSk7XG4gIH1cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGZuLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGdldFR5cGUoZm5baV0pID09PSBnZXRUeXBlKHR5cGUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKiAgKi9cblxudmFyIG1hcms7XG52YXIgbWVhc3VyZTtcblxuaWYgKGZhbHNlKSB7XG4gIHZhciBwZXJmID0gaW5Ccm93c2VyICYmIHdpbmRvdy5wZXJmb3JtYW5jZTtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChwZXJmICYmIHBlcmYubWFyayAmJiBwZXJmLm1lYXN1cmUgJiYgcGVyZi5jbGVhck1hcmtzICYmIHBlcmYuY2xlYXJNZWFzdXJlcykge1xuICAgIG1hcmsgPSBmdW5jdGlvbiAodGFnKSB7XG4gICAgICByZXR1cm4gcGVyZi5tYXJrKHRhZyk7XG4gICAgfTtcbiAgICBtZWFzdXJlID0gZnVuY3Rpb24gKG5hbWUsIHN0YXJ0VGFnLCBlbmRUYWcpIHtcbiAgICAgIHBlcmYubWVhc3VyZShuYW1lLCBzdGFydFRhZywgZW5kVGFnKTtcbiAgICAgIHBlcmYuY2xlYXJNYXJrcyhzdGFydFRhZyk7XG4gICAgICBwZXJmLmNsZWFyTWFya3MoZW5kVGFnKTtcbiAgICAgIHBlcmYuY2xlYXJNZWFzdXJlcyhuYW1lKTtcbiAgICB9O1xuICB9XG59XG5cbi8qIG5vdCB0eXBlIGNoZWNraW5nIHRoaXMgZmlsZSBiZWNhdXNlIGZsb3cgZG9lc24ndCBwbGF5IHdlbGwgd2l0aCBQcm94eSAqL1xuXG52YXIgaW5pdFByb3h5O1xuXG5pZiAoZmFsc2UpIHtcbiAgdmFyIGFsbG93ZWRHbG9iYWxzID0gbWFrZU1hcCgnSW5maW5pdHksdW5kZWZpbmVkLE5hTixpc0Zpbml0ZSxpc05hTiwnICsgJ3BhcnNlRmxvYXQscGFyc2VJbnQsZGVjb2RlVVJJLGRlY29kZVVSSUNvbXBvbmVudCxlbmNvZGVVUkksZW5jb2RlVVJJQ29tcG9uZW50LCcgKyAnTWF0aCxOdW1iZXIsRGF0ZSxBcnJheSxPYmplY3QsQm9vbGVhbixTdHJpbmcsUmVnRXhwLE1hcCxTZXQsSlNPTixJbnRsLCcgKyAncmVxdWlyZScgLy8gZm9yIFdlYnBhY2svQnJvd3NlcmlmeVxuICApO1xuXG4gIHZhciB3YXJuTm9uUHJlc2VudCA9IGZ1bmN0aW9uICh0YXJnZXQsIGtleSkge1xuICAgIHdhcm4oXCJQcm9wZXJ0eSBvciBtZXRob2QgXFxcIlwiICsga2V5ICsgXCJcXFwiIGlzIG5vdCBkZWZpbmVkIG9uIHRoZSBpbnN0YW5jZSBidXQgXCIgKyBcInJlZmVyZW5jZWQgZHVyaW5nIHJlbmRlci4gTWFrZSBzdXJlIHRvIGRlY2xhcmUgcmVhY3RpdmUgZGF0YSBcIiArIFwicHJvcGVydGllcyBpbiB0aGUgZGF0YSBvcHRpb24uXCIsIHRhcmdldCk7XG4gIH07XG5cbiAgdmFyIGhhc1Byb3h5ID0gdHlwZW9mIFByb3h5ICE9PSAndW5kZWZpbmVkJyAmJiBQcm94eS50b1N0cmluZygpLm1hdGNoKC9uYXRpdmUgY29kZS8pO1xuXG4gIGlmIChoYXNQcm94eSkge1xuICAgIHZhciBpc0J1aWx0SW5Nb2RpZmllciA9IG1ha2VNYXAoJ3N0b3AscHJldmVudCxzZWxmLGN0cmwsc2hpZnQsYWx0LG1ldGEnKTtcbiAgICBjb25maWcua2V5Q29kZXMgPSBuZXcgUHJveHkoY29uZmlnLmtleUNvZGVzLCB7XG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh0YXJnZXQsIGtleSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKGlzQnVpbHRJbk1vZGlmaWVyKGtleSkpIHtcbiAgICAgICAgICB3YXJuKFwiQXZvaWQgb3ZlcndyaXRpbmcgYnVpbHQtaW4gbW9kaWZpZXIgaW4gY29uZmlnLmtleUNvZGVzOiAuXCIgKyBrZXkpO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IHZhbHVlO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICB2YXIgaGFzSGFuZGxlciA9IHtcbiAgICBoYXM6IGZ1bmN0aW9uIGhhcyh0YXJnZXQsIGtleSkge1xuICAgICAgdmFyIGhhcyA9IGtleSBpbiB0YXJnZXQ7XG4gICAgICB2YXIgaXNBbGxvd2VkID0gYWxsb3dlZEdsb2JhbHMoa2V5KSB8fCBrZXkuY2hhckF0KDApID09PSAnXyc7XG4gICAgICBpZiAoIWhhcyAmJiAhaXNBbGxvd2VkKSB7XG4gICAgICAgIHdhcm5Ob25QcmVzZW50KHRhcmdldCwga2V5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBoYXMgfHwgIWlzQWxsb3dlZDtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGdldEhhbmRsZXIgPSB7XG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQodGFyZ2V0LCBrZXkpIHtcbiAgICAgIGlmICh0eXBlb2Yga2V5ID09PSAnc3RyaW5nJyAmJiAhKGtleSBpbiB0YXJnZXQpKSB7XG4gICAgICAgIHdhcm5Ob25QcmVzZW50KHRhcmdldCwga2V5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0YXJnZXRba2V5XTtcbiAgICB9XG4gIH07XG5cbiAgaW5pdFByb3h5ID0gZnVuY3Rpb24gaW5pdFByb3h5KHZtKSB7XG4gICAgaWYgKGhhc1Byb3h5KSB7XG4gICAgICAvLyBkZXRlcm1pbmUgd2hpY2ggcHJveHkgaGFuZGxlciB0byB1c2VcbiAgICAgIHZhciBvcHRpb25zID0gdm0uJG9wdGlvbnM7XG4gICAgICB2YXIgaGFuZGxlcnMgPSBvcHRpb25zLnJlbmRlciAmJiBvcHRpb25zLnJlbmRlci5fd2l0aFN0cmlwcGVkID8gZ2V0SGFuZGxlciA6IGhhc0hhbmRsZXI7XG4gICAgICB2bS5fcmVuZGVyUHJveHkgPSBuZXcgUHJveHkodm0sIGhhbmRsZXJzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdm0uX3JlbmRlclByb3h5ID0gdm07XG4gICAgfVxuICB9O1xufVxuXG4vKiAgKi9cblxudmFyIFZOb2RlID0gZnVuY3Rpb24gVk5vZGUodGFnLCBkYXRhLCBjaGlsZHJlbiwgdGV4dCwgZWxtLCBjb250ZXh0LCBjb21wb25lbnRPcHRpb25zLCBhc3luY0ZhY3RvcnkpIHtcbiAgdGhpcy50YWcgPSB0YWc7XG4gIHRoaXMuZGF0YSA9IGRhdGE7XG4gIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgdGhpcy5lbG0gPSBlbG07XG4gIHRoaXMubnMgPSB1bmRlZmluZWQ7XG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gIHRoaXMuZnVuY3Rpb25hbENvbnRleHQgPSB1bmRlZmluZWQ7XG4gIHRoaXMua2V5ID0gZGF0YSAmJiBkYXRhLmtleTtcbiAgdGhpcy5jb21wb25lbnRPcHRpb25zID0gY29tcG9uZW50T3B0aW9ucztcbiAgdGhpcy5jb21wb25lbnRJbnN0YW5jZSA9IHVuZGVmaW5lZDtcbiAgdGhpcy5wYXJlbnQgPSB1bmRlZmluZWQ7XG4gIHRoaXMucmF3ID0gZmFsc2U7XG4gIHRoaXMuaXNTdGF0aWMgPSBmYWxzZTtcbiAgdGhpcy5pc1Jvb3RJbnNlcnQgPSB0cnVlO1xuICB0aGlzLmlzQ29tbWVudCA9IGZhbHNlO1xuICB0aGlzLmlzQ2xvbmVkID0gZmFsc2U7XG4gIHRoaXMuaXNPbmNlID0gZmFsc2U7XG4gIHRoaXMuYXN5bmNGYWN0b3J5ID0gYXN5bmNGYWN0b3J5O1xuICB0aGlzLmFzeW5jTWV0YSA9IHVuZGVmaW5lZDtcbiAgdGhpcy5pc0FzeW5jUGxhY2Vob2xkZXIgPSBmYWxzZTtcbn07XG5cbnZhciBwcm90b3R5cGVBY2Nlc3NvcnMgPSB7IGNoaWxkOiB7fSB9O1xuXG4vLyBERVBSRUNBVEVEOiBhbGlhcyBmb3IgY29tcG9uZW50SW5zdGFuY2UgZm9yIGJhY2t3YXJkcyBjb21wYXQuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xucHJvdG90eXBlQWNjZXNzb3JzLmNoaWxkLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuY29tcG9uZW50SW5zdGFuY2U7XG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhWTm9kZS5wcm90b3R5cGUsIHByb3RvdHlwZUFjY2Vzc29ycyk7XG5cbnZhciBjcmVhdGVFbXB0eVZOb2RlID0gZnVuY3Rpb24gKHRleHQpIHtcbiAgaWYgKHRleHQgPT09IHZvaWQgMCkgdGV4dCA9ICcnO1xuXG4gIHZhciBub2RlID0gbmV3IFZOb2RlKCk7XG4gIG5vZGUudGV4dCA9IHRleHQ7XG4gIG5vZGUuaXNDb21tZW50ID0gdHJ1ZTtcbiAgcmV0dXJuIG5vZGU7XG59O1xuXG5mdW5jdGlvbiBjcmVhdGVUZXh0Vk5vZGUodmFsKSB7XG4gIHJldHVybiBuZXcgVk5vZGUodW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgU3RyaW5nKHZhbCkpO1xufVxuXG4vLyBvcHRpbWl6ZWQgc2hhbGxvdyBjbG9uZVxuLy8gdXNlZCBmb3Igc3RhdGljIG5vZGVzIGFuZCBzbG90IG5vZGVzIGJlY2F1c2UgdGhleSBtYXkgYmUgcmV1c2VkIGFjcm9zc1xuLy8gbXVsdGlwbGUgcmVuZGVycywgY2xvbmluZyB0aGVtIGF2b2lkcyBlcnJvcnMgd2hlbiBET00gbWFuaXB1bGF0aW9ucyByZWx5XG4vLyBvbiB0aGVpciBlbG0gcmVmZXJlbmNlLlxuZnVuY3Rpb24gY2xvbmVWTm9kZSh2bm9kZSwgZGVlcCkge1xuICB2YXIgY2xvbmVkID0gbmV3IFZOb2RlKHZub2RlLnRhZywgdm5vZGUuZGF0YSwgdm5vZGUuY2hpbGRyZW4sIHZub2RlLnRleHQsIHZub2RlLmVsbSwgdm5vZGUuY29udGV4dCwgdm5vZGUuY29tcG9uZW50T3B0aW9ucywgdm5vZGUuYXN5bmNGYWN0b3J5KTtcbiAgY2xvbmVkLm5zID0gdm5vZGUubnM7XG4gIGNsb25lZC5pc1N0YXRpYyA9IHZub2RlLmlzU3RhdGljO1xuICBjbG9uZWQua2V5ID0gdm5vZGUua2V5O1xuICBjbG9uZWQuaXNDb21tZW50ID0gdm5vZGUuaXNDb21tZW50O1xuICBjbG9uZWQuaXNDbG9uZWQgPSB0cnVlO1xuICBpZiAoZGVlcCAmJiB2bm9kZS5jaGlsZHJlbikge1xuICAgIGNsb25lZC5jaGlsZHJlbiA9IGNsb25lVk5vZGVzKHZub2RlLmNoaWxkcmVuKTtcbiAgfVxuICByZXR1cm4gY2xvbmVkO1xufVxuXG5mdW5jdGlvbiBjbG9uZVZOb2Rlcyh2bm9kZXMsIGRlZXApIHtcbiAgdmFyIGxlbiA9IHZub2Rlcy5sZW5ndGg7XG4gIHZhciByZXMgPSBuZXcgQXJyYXkobGVuKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIHJlc1tpXSA9IGNsb25lVk5vZGUodm5vZGVzW2ldLCBkZWVwKTtcbiAgfVxuICByZXR1cm4gcmVzO1xufVxuXG4vKiAgKi9cblxudmFyIG5vcm1hbGl6ZUV2ZW50ID0gY2FjaGVkKGZ1bmN0aW9uIChuYW1lKSB7XG4gIHZhciBwYXNzaXZlID0gbmFtZS5jaGFyQXQoMCkgPT09ICcmJztcbiAgbmFtZSA9IHBhc3NpdmUgPyBuYW1lLnNsaWNlKDEpIDogbmFtZTtcbiAgdmFyIG9uY2UkJDEgPSBuYW1lLmNoYXJBdCgwKSA9PT0gJ34nOyAvLyBQcmVmaXhlZCBsYXN0LCBjaGVja2VkIGZpcnN0XG4gIG5hbWUgPSBvbmNlJCQxID8gbmFtZS5zbGljZSgxKSA6IG5hbWU7XG4gIHZhciBjYXB0dXJlID0gbmFtZS5jaGFyQXQoMCkgPT09ICchJztcbiAgbmFtZSA9IGNhcHR1cmUgPyBuYW1lLnNsaWNlKDEpIDogbmFtZTtcbiAgdmFyIHBsYWluID0gIShwYXNzaXZlIHx8IG9uY2UkJDEgfHwgY2FwdHVyZSk7XG4gIHJldHVybiB7XG4gICAgbmFtZTogbmFtZSxcbiAgICBwbGFpbjogcGxhaW4sXG4gICAgb25jZTogb25jZSQkMSxcbiAgICBjYXB0dXJlOiBjYXB0dXJlLFxuICAgIHBhc3NpdmU6IHBhc3NpdmVcbiAgfTtcbn0pO1xuXG5mdW5jdGlvbiBjcmVhdGVGbkludm9rZXIoZm5zKSB7XG4gIGZ1bmN0aW9uIGludm9rZXIoKSB7XG4gICAgdmFyIGFyZ3VtZW50cyQxID0gYXJndW1lbnRzO1xuXG4gICAgdmFyIGZucyA9IGludm9rZXIuZm5zO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGZucykpIHtcbiAgICAgIHZhciBjbG9uZWQgPSBmbnMuc2xpY2UoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2xvbmVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNsb25lZFtpXS5hcHBseShudWxsLCBhcmd1bWVudHMkMSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHJldHVybiBoYW5kbGVyIHJldHVybiB2YWx1ZSBmb3Igc2luZ2xlIGhhbmRsZXJzXG4gICAgICByZXR1cm4gZm5zLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9XG4gIGludm9rZXIuZm5zID0gZm5zO1xuICByZXR1cm4gaW52b2tlcjtcbn1cblxuLy8gIzY1NTJcbmZ1bmN0aW9uIHByaW9yaXRpemVQbGFpbkV2ZW50cyhhLCBiKSB7XG4gIHJldHVybiBhLnBsYWluID8gLTEgOiBiLnBsYWluID8gMSA6IDA7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUxpc3RlbmVycyhvbiwgb2xkT24sIGFkZCwgcmVtb3ZlJCQxLCB2bSkge1xuICB2YXIgbmFtZSwgY3VyLCBvbGQsIGV2ZW50O1xuICB2YXIgdG9BZGQgPSBbXTtcbiAgdmFyIGhhc01vZGlmaWVyID0gZmFsc2U7XG4gIGZvciAobmFtZSBpbiBvbikge1xuICAgIGN1ciA9IG9uW25hbWVdO1xuICAgIG9sZCA9IG9sZE9uW25hbWVdO1xuICAgIGV2ZW50ID0gbm9ybWFsaXplRXZlbnQobmFtZSk7XG4gICAgaWYgKCFldmVudC5wbGFpbikge1xuICAgICAgaGFzTW9kaWZpZXIgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoaXNVbmRlZihjdXIpKSB7XG4gICAgICBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXCJJbnZhbGlkIGhhbmRsZXIgZm9yIGV2ZW50IFxcXCJcIiArIGV2ZW50Lm5hbWUgKyBcIlxcXCI6IGdvdCBcIiArIFN0cmluZyhjdXIpLCB2bSk7XG4gICAgfSBlbHNlIGlmIChpc1VuZGVmKG9sZCkpIHtcbiAgICAgIGlmIChpc1VuZGVmKGN1ci5mbnMpKSB7XG4gICAgICAgIGN1ciA9IG9uW25hbWVdID0gY3JlYXRlRm5JbnZva2VyKGN1cik7XG4gICAgICB9XG4gICAgICBldmVudC5oYW5kbGVyID0gY3VyO1xuICAgICAgdG9BZGQucHVzaChldmVudCk7XG4gICAgfSBlbHNlIGlmIChjdXIgIT09IG9sZCkge1xuICAgICAgb2xkLmZucyA9IGN1cjtcbiAgICAgIG9uW25hbWVdID0gb2xkO1xuICAgIH1cbiAgfVxuICBpZiAodG9BZGQubGVuZ3RoKSB7XG4gICAgaWYgKGhhc01vZGlmaWVyKSB7XG4gICAgICB0b0FkZC5zb3J0KHByaW9yaXRpemVQbGFpbkV2ZW50cyk7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG9BZGQubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBldmVudCQxID0gdG9BZGRbaV07XG4gICAgICBhZGQoZXZlbnQkMS5uYW1lLCBldmVudCQxLmhhbmRsZXIsIGV2ZW50JDEub25jZSwgZXZlbnQkMS5jYXB0dXJlLCBldmVudCQxLnBhc3NpdmUpO1xuICAgIH1cbiAgfVxuICBmb3IgKG5hbWUgaW4gb2xkT24pIHtcbiAgICBpZiAoaXNVbmRlZihvbltuYW1lXSkpIHtcbiAgICAgIGV2ZW50ID0gbm9ybWFsaXplRXZlbnQobmFtZSk7XG4gICAgICByZW1vdmUkJDEoZXZlbnQubmFtZSwgb2xkT25bbmFtZV0sIGV2ZW50LmNhcHR1cmUpO1xuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gbWVyZ2VWTm9kZUhvb2soZGVmLCBob29rS2V5LCBob29rKSB7XG4gIHZhciBpbnZva2VyO1xuICB2YXIgb2xkSG9vayA9IGRlZltob29rS2V5XTtcblxuICBmdW5jdGlvbiB3cmFwcGVkSG9vaygpIHtcbiAgICBob29rLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgLy8gaW1wb3J0YW50OiByZW1vdmUgbWVyZ2VkIGhvb2sgdG8gZW5zdXJlIGl0J3MgY2FsbGVkIG9ubHkgb25jZVxuICAgIC8vIGFuZCBwcmV2ZW50IG1lbW9yeSBsZWFrXG4gICAgcmVtb3ZlKGludm9rZXIuZm5zLCB3cmFwcGVkSG9vayk7XG4gIH1cblxuICBpZiAoaXNVbmRlZihvbGRIb29rKSkge1xuICAgIC8vIG5vIGV4aXN0aW5nIGhvb2tcbiAgICBpbnZva2VyID0gY3JlYXRlRm5JbnZva2VyKFt3cmFwcGVkSG9va10pO1xuICB9IGVsc2Uge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChpc0RlZihvbGRIb29rLmZucykgJiYgaXNUcnVlKG9sZEhvb2subWVyZ2VkKSkge1xuICAgICAgLy8gYWxyZWFkeSBhIG1lcmdlZCBpbnZva2VyXG4gICAgICBpbnZva2VyID0gb2xkSG9vaztcbiAgICAgIGludm9rZXIuZm5zLnB1c2god3JhcHBlZEhvb2spO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBleGlzdGluZyBwbGFpbiBob29rXG4gICAgICBpbnZva2VyID0gY3JlYXRlRm5JbnZva2VyKFtvbGRIb29rLCB3cmFwcGVkSG9va10pO1xuICAgIH1cbiAgfVxuXG4gIGludm9rZXIubWVyZ2VkID0gdHJ1ZTtcbiAgZGVmW2hvb2tLZXldID0gaW52b2tlcjtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGV4dHJhY3RQcm9wc0Zyb21WTm9kZURhdGEoZGF0YSwgQ3RvciwgdGFnKSB7XG4gIC8vIHdlIGFyZSBvbmx5IGV4dHJhY3RpbmcgcmF3IHZhbHVlcyBoZXJlLlxuICAvLyB2YWxpZGF0aW9uIGFuZCBkZWZhdWx0IHZhbHVlcyBhcmUgaGFuZGxlZCBpbiB0aGUgY2hpbGRcbiAgLy8gY29tcG9uZW50IGl0c2VsZi5cbiAgdmFyIHByb3BPcHRpb25zID0gQ3Rvci5vcHRpb25zLnByb3BzO1xuICBpZiAoaXNVbmRlZihwcm9wT3B0aW9ucykpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIHJlcyA9IHt9O1xuICB2YXIgYXR0cnMgPSBkYXRhLmF0dHJzO1xuICB2YXIgcHJvcHMgPSBkYXRhLnByb3BzO1xuICBpZiAoaXNEZWYoYXR0cnMpIHx8IGlzRGVmKHByb3BzKSkge1xuICAgIGZvciAodmFyIGtleSBpbiBwcm9wT3B0aW9ucykge1xuICAgICAgdmFyIGFsdEtleSA9IGh5cGhlbmF0ZShrZXkpO1xuICAgICAgaWYgKGZhbHNlKSB7XG4gICAgICAgIHZhciBrZXlJbkxvd2VyQ2FzZSA9IGtleS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoa2V5ICE9PSBrZXlJbkxvd2VyQ2FzZSAmJiBhdHRycyAmJiBoYXNPd24oYXR0cnMsIGtleUluTG93ZXJDYXNlKSkge1xuICAgICAgICAgIHRpcChcIlByb3AgXFxcIlwiICsga2V5SW5Mb3dlckNhc2UgKyBcIlxcXCIgaXMgcGFzc2VkIHRvIGNvbXBvbmVudCBcIiArIGZvcm1hdENvbXBvbmVudE5hbWUodGFnIHx8IEN0b3IpICsgXCIsIGJ1dCB0aGUgZGVjbGFyZWQgcHJvcCBuYW1lIGlzXCIgKyBcIiBcXFwiXCIgKyBrZXkgKyBcIlxcXCIuIFwiICsgXCJOb3RlIHRoYXQgSFRNTCBhdHRyaWJ1dGVzIGFyZSBjYXNlLWluc2Vuc2l0aXZlIGFuZCBjYW1lbENhc2VkIFwiICsgXCJwcm9wcyBuZWVkIHRvIHVzZSB0aGVpciBrZWJhYi1jYXNlIGVxdWl2YWxlbnRzIHdoZW4gdXNpbmcgaW4tRE9NIFwiICsgXCJ0ZW1wbGF0ZXMuIFlvdSBzaG91bGQgcHJvYmFibHkgdXNlIFxcXCJcIiArIGFsdEtleSArIFwiXFxcIiBpbnN0ZWFkIG9mIFxcXCJcIiArIGtleSArIFwiXFxcIi5cIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNoZWNrUHJvcChyZXMsIHByb3BzLCBrZXksIGFsdEtleSwgdHJ1ZSkgfHwgY2hlY2tQcm9wKHJlcywgYXR0cnMsIGtleSwgYWx0S2V5LCBmYWxzZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXM7XG59XG5cbmZ1bmN0aW9uIGNoZWNrUHJvcChyZXMsIGhhc2gsIGtleSwgYWx0S2V5LCBwcmVzZXJ2ZSkge1xuICBpZiAoaXNEZWYoaGFzaCkpIHtcbiAgICBpZiAoaGFzT3duKGhhc2gsIGtleSkpIHtcbiAgICAgIHJlc1trZXldID0gaGFzaFtrZXldO1xuICAgICAgaWYgKCFwcmVzZXJ2ZSkge1xuICAgICAgICBkZWxldGUgaGFzaFtrZXldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmIChoYXNPd24oaGFzaCwgYWx0S2V5KSkge1xuICAgICAgcmVzW2tleV0gPSBoYXNoW2FsdEtleV07XG4gICAgICBpZiAoIXByZXNlcnZlKSB7XG4gICAgICAgIGRlbGV0ZSBoYXNoW2FsdEtleV07XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKiAgKi9cblxuLy8gVGhlIHRlbXBsYXRlIGNvbXBpbGVyIGF0dGVtcHRzIHRvIG1pbmltaXplIHRoZSBuZWVkIGZvciBub3JtYWxpemF0aW9uIGJ5XG4vLyBzdGF0aWNhbGx5IGFuYWx5emluZyB0aGUgdGVtcGxhdGUgYXQgY29tcGlsZSB0aW1lLlxuLy9cbi8vIEZvciBwbGFpbiBIVE1MIG1hcmt1cCwgbm9ybWFsaXphdGlvbiBjYW4gYmUgY29tcGxldGVseSBza2lwcGVkIGJlY2F1c2UgdGhlXG4vLyBnZW5lcmF0ZWQgcmVuZGVyIGZ1bmN0aW9uIGlzIGd1YXJhbnRlZWQgdG8gcmV0dXJuIEFycmF5PFZOb2RlPi4gVGhlcmUgYXJlXG4vLyB0d28gY2FzZXMgd2hlcmUgZXh0cmEgbm9ybWFsaXphdGlvbiBpcyBuZWVkZWQ6XG5cbi8vIDEuIFdoZW4gdGhlIGNoaWxkcmVuIGNvbnRhaW5zIGNvbXBvbmVudHMgLSBiZWNhdXNlIGEgZnVuY3Rpb25hbCBjb21wb25lbnRcbi8vIG1heSByZXR1cm4gYW4gQXJyYXkgaW5zdGVhZCBvZiBhIHNpbmdsZSByb290LiBJbiB0aGlzIGNhc2UsIGp1c3QgYSBzaW1wbGVcbi8vIG5vcm1hbGl6YXRpb24gaXMgbmVlZGVkIC0gaWYgYW55IGNoaWxkIGlzIGFuIEFycmF5LCB3ZSBmbGF0dGVuIHRoZSB3aG9sZVxuLy8gdGhpbmcgd2l0aCBBcnJheS5wcm90b3R5cGUuY29uY2F0LiBJdCBpcyBndWFyYW50ZWVkIHRvIGJlIG9ubHkgMS1sZXZlbCBkZWVwXG4vLyBiZWNhdXNlIGZ1bmN0aW9uYWwgY29tcG9uZW50cyBhbHJlYWR5IG5vcm1hbGl6ZSB0aGVpciBvd24gY2hpbGRyZW4uXG5mdW5jdGlvbiBzaW1wbGVOb3JtYWxpemVDaGlsZHJlbihjaGlsZHJlbikge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW5baV0pKSB7XG4gICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmNvbmNhdC5hcHBseShbXSwgY2hpbGRyZW4pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY2hpbGRyZW47XG59XG5cbi8vIDIuIFdoZW4gdGhlIGNoaWxkcmVuIGNvbnRhaW5zIGNvbnN0cnVjdHMgdGhhdCBhbHdheXMgZ2VuZXJhdGVkIG5lc3RlZCBBcnJheXMsXG4vLyBlLmcuIDx0ZW1wbGF0ZT4sIDxzbG90Piwgdi1mb3IsIG9yIHdoZW4gdGhlIGNoaWxkcmVuIGlzIHByb3ZpZGVkIGJ5IHVzZXJcbi8vIHdpdGggaGFuZC13cml0dGVuIHJlbmRlciBmdW5jdGlvbnMgLyBKU1guIEluIHN1Y2ggY2FzZXMgYSBmdWxsIG5vcm1hbGl6YXRpb25cbi8vIGlzIG5lZWRlZCB0byBjYXRlciB0byBhbGwgcG9zc2libGUgdHlwZXMgb2YgY2hpbGRyZW4gdmFsdWVzLlxuZnVuY3Rpb24gbm9ybWFsaXplQ2hpbGRyZW4oY2hpbGRyZW4pIHtcbiAgcmV0dXJuIGlzUHJpbWl0aXZlKGNoaWxkcmVuKSA/IFtjcmVhdGVUZXh0Vk5vZGUoY2hpbGRyZW4pXSA6IEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pID8gbm9ybWFsaXplQXJyYXlDaGlsZHJlbihjaGlsZHJlbikgOiB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGlzVGV4dE5vZGUobm9kZSkge1xuICByZXR1cm4gaXNEZWYobm9kZSkgJiYgaXNEZWYobm9kZS50ZXh0KSAmJiBpc0ZhbHNlKG5vZGUuaXNDb21tZW50KTtcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplQXJyYXlDaGlsZHJlbihjaGlsZHJlbiwgbmVzdGVkSW5kZXgpIHtcbiAgdmFyIHJlcyA9IFtdO1xuICB2YXIgaSwgYywgbGFzdDtcbiAgZm9yIChpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgYyA9IGNoaWxkcmVuW2ldO1xuICAgIGlmIChpc1VuZGVmKGMpIHx8IHR5cGVvZiBjID09PSAnYm9vbGVhbicpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBsYXN0ID0gcmVzW3Jlcy5sZW5ndGggLSAxXTtcbiAgICAvLyAgbmVzdGVkXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYykpIHtcbiAgICAgIHJlcy5wdXNoLmFwcGx5KHJlcywgbm9ybWFsaXplQXJyYXlDaGlsZHJlbihjLCAobmVzdGVkSW5kZXggfHwgJycpICsgXCJfXCIgKyBpKSk7XG4gICAgfSBlbHNlIGlmIChpc1ByaW1pdGl2ZShjKSkge1xuICAgICAgaWYgKGlzVGV4dE5vZGUobGFzdCkpIHtcbiAgICAgICAgLy8gbWVyZ2UgYWRqYWNlbnQgdGV4dCBub2Rlc1xuICAgICAgICAvLyB0aGlzIGlzIG5lY2Vzc2FyeSBmb3IgU1NSIGh5ZHJhdGlvbiBiZWNhdXNlIHRleHQgbm9kZXMgYXJlXG4gICAgICAgIC8vIGVzc2VudGlhbGx5IG1lcmdlZCB3aGVuIHJlbmRlcmVkIHRvIEhUTUwgc3RyaW5nc1xuICAgICAgICBsYXN0LnRleHQgKz0gU3RyaW5nKGMpO1xuICAgICAgfSBlbHNlIGlmIChjICE9PSAnJykge1xuICAgICAgICAvLyBjb252ZXJ0IHByaW1pdGl2ZSB0byB2bm9kZVxuICAgICAgICByZXMucHVzaChjcmVhdGVUZXh0Vk5vZGUoYykpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaXNUZXh0Tm9kZShjKSAmJiBpc1RleHROb2RlKGxhc3QpKSB7XG4gICAgICAgIC8vIG1lcmdlIGFkamFjZW50IHRleHQgbm9kZXNcbiAgICAgICAgcmVzW3Jlcy5sZW5ndGggLSAxXSA9IGNyZWF0ZVRleHRWTm9kZShsYXN0LnRleHQgKyBjLnRleHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZGVmYXVsdCBrZXkgZm9yIG5lc3RlZCBhcnJheSBjaGlsZHJlbiAobGlrZWx5IGdlbmVyYXRlZCBieSB2LWZvcilcbiAgICAgICAgaWYgKGlzVHJ1ZShjaGlsZHJlbi5faXNWTGlzdCkgJiYgaXNEZWYoYy50YWcpICYmIGlzVW5kZWYoYy5rZXkpICYmIGlzRGVmKG5lc3RlZEluZGV4KSkge1xuICAgICAgICAgIGMua2V5ID0gXCJfX3ZsaXN0XCIgKyBuZXN0ZWRJbmRleCArIFwiX1wiICsgaSArIFwiX19cIjtcbiAgICAgICAgfVxuICAgICAgICByZXMucHVzaChjKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGVuc3VyZUN0b3IoY29tcCwgYmFzZSkge1xuICBpZiAoY29tcC5fX2VzTW9kdWxlICYmIGNvbXAuZGVmYXVsdCkge1xuICAgIGNvbXAgPSBjb21wLmRlZmF1bHQ7XG4gIH1cbiAgcmV0dXJuIGlzT2JqZWN0KGNvbXApID8gYmFzZS5leHRlbmQoY29tcCkgOiBjb21wO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVBc3luY1BsYWNlaG9sZGVyKGZhY3RvcnksIGRhdGEsIGNvbnRleHQsIGNoaWxkcmVuLCB0YWcpIHtcbiAgdmFyIG5vZGUgPSBjcmVhdGVFbXB0eVZOb2RlKCk7XG4gIG5vZGUuYXN5bmNGYWN0b3J5ID0gZmFjdG9yeTtcbiAgbm9kZS5hc3luY01ldGEgPSB7IGRhdGE6IGRhdGEsIGNvbnRleHQ6IGNvbnRleHQsIGNoaWxkcmVuOiBjaGlsZHJlbiwgdGFnOiB0YWcgfTtcbiAgcmV0dXJuIG5vZGU7XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVBc3luY0NvbXBvbmVudChmYWN0b3J5LCBiYXNlQ3RvciwgY29udGV4dCkge1xuICBpZiAoaXNUcnVlKGZhY3RvcnkuZXJyb3IpICYmIGlzRGVmKGZhY3RvcnkuZXJyb3JDb21wKSkge1xuICAgIHJldHVybiBmYWN0b3J5LmVycm9yQ29tcDtcbiAgfVxuXG4gIGlmIChpc0RlZihmYWN0b3J5LnJlc29sdmVkKSkge1xuICAgIHJldHVybiBmYWN0b3J5LnJlc29sdmVkO1xuICB9XG5cbiAgaWYgKGlzVHJ1ZShmYWN0b3J5LmxvYWRpbmcpICYmIGlzRGVmKGZhY3RvcnkubG9hZGluZ0NvbXApKSB7XG4gICAgcmV0dXJuIGZhY3RvcnkubG9hZGluZ0NvbXA7XG4gIH1cblxuICBpZiAoaXNEZWYoZmFjdG9yeS5jb250ZXh0cykpIHtcbiAgICAvLyBhbHJlYWR5IHBlbmRpbmdcbiAgICBmYWN0b3J5LmNvbnRleHRzLnB1c2goY29udGV4dCk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGNvbnRleHRzID0gZmFjdG9yeS5jb250ZXh0cyA9IFtjb250ZXh0XTtcbiAgICB2YXIgc3luYyA9IHRydWU7XG5cbiAgICB2YXIgZm9yY2VSZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNvbnRleHRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBjb250ZXh0c1tpXS4kZm9yY2VVcGRhdGUoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHJlc29sdmUgPSBvbmNlKGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgIC8vIGNhY2hlIHJlc29sdmVkXG4gICAgICBmYWN0b3J5LnJlc29sdmVkID0gZW5zdXJlQ3RvcihyZXMsIGJhc2VDdG9yKTtcbiAgICAgIC8vIGludm9rZSBjYWxsYmFja3Mgb25seSBpZiB0aGlzIGlzIG5vdCBhIHN5bmNocm9ub3VzIHJlc29sdmVcbiAgICAgIC8vIChhc3luYyByZXNvbHZlcyBhcmUgc2hpbW1lZCBhcyBzeW5jaHJvbm91cyBkdXJpbmcgU1NSKVxuICAgICAgaWYgKCFzeW5jKSB7XG4gICAgICAgIGZvcmNlUmVuZGVyKCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB2YXIgcmVqZWN0ID0gb25jZShmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXCJGYWlsZWQgdG8gcmVzb2x2ZSBhc3luYyBjb21wb25lbnQ6IFwiICsgU3RyaW5nKGZhY3RvcnkpICsgKHJlYXNvbiA/IFwiXFxuUmVhc29uOiBcIiArIHJlYXNvbiA6ICcnKSk7XG4gICAgICBpZiAoaXNEZWYoZmFjdG9yeS5lcnJvckNvbXApKSB7XG4gICAgICAgIGZhY3RvcnkuZXJyb3IgPSB0cnVlO1xuICAgICAgICBmb3JjZVJlbmRlcigpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdmFyIHJlcyA9IGZhY3RvcnkocmVzb2x2ZSwgcmVqZWN0KTtcblxuICAgIGlmIChpc09iamVjdChyZXMpKSB7XG4gICAgICBpZiAodHlwZW9mIHJlcy50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vICgpID0+IFByb21pc2VcbiAgICAgICAgaWYgKGlzVW5kZWYoZmFjdG9yeS5yZXNvbHZlZCkpIHtcbiAgICAgICAgICByZXMudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGlzRGVmKHJlcy5jb21wb25lbnQpICYmIHR5cGVvZiByZXMuY29tcG9uZW50LnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmVzLmNvbXBvbmVudC50aGVuKHJlc29sdmUsIHJlamVjdCk7XG5cbiAgICAgICAgaWYgKGlzRGVmKHJlcy5lcnJvcikpIHtcbiAgICAgICAgICBmYWN0b3J5LmVycm9yQ29tcCA9IGVuc3VyZUN0b3IocmVzLmVycm9yLCBiYXNlQ3Rvcik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNEZWYocmVzLmxvYWRpbmcpKSB7XG4gICAgICAgICAgZmFjdG9yeS5sb2FkaW5nQ29tcCA9IGVuc3VyZUN0b3IocmVzLmxvYWRpbmcsIGJhc2VDdG9yKTtcbiAgICAgICAgICBpZiAocmVzLmRlbGF5ID09PSAwKSB7XG4gICAgICAgICAgICBmYWN0b3J5LmxvYWRpbmcgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgaWYgKGlzVW5kZWYoZmFjdG9yeS5yZXNvbHZlZCkgJiYgaXNVbmRlZihmYWN0b3J5LmVycm9yKSkge1xuICAgICAgICAgICAgICAgIGZhY3RvcnkubG9hZGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgZm9yY2VSZW5kZXIoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgcmVzLmRlbGF5IHx8IDIwMCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzRGVmKHJlcy50aW1lb3V0KSkge1xuICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGlzVW5kZWYoZmFjdG9yeS5yZXNvbHZlZCkpIHtcbiAgICAgICAgICAgICAgcmVqZWN0KCBmYWxzZSA/IFwidGltZW91dCAoXCIgKyByZXMudGltZW91dCArIFwibXMpXCIgOiBudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCByZXMudGltZW91dCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBzeW5jID0gZmFsc2U7XG4gICAgLy8gcmV0dXJuIGluIGNhc2UgcmVzb2x2ZWQgc3luY2hyb25vdXNseVxuICAgIHJldHVybiBmYWN0b3J5LmxvYWRpbmcgPyBmYWN0b3J5LmxvYWRpbmdDb21wIDogZmFjdG9yeS5yZXNvbHZlZDtcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaXNBc3luY1BsYWNlaG9sZGVyKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUuaXNDb21tZW50ICYmIG5vZGUuYXN5bmNGYWN0b3J5O1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gZ2V0Rmlyc3RDb21wb25lbnRDaGlsZChjaGlsZHJlbikge1xuICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYyA9IGNoaWxkcmVuW2ldO1xuICAgICAgaWYgKGlzRGVmKGMpICYmIChpc0RlZihjLmNvbXBvbmVudE9wdGlvbnMpIHx8IGlzQXN5bmNQbGFjZWhvbGRlcihjKSkpIHtcbiAgICAgICAgcmV0dXJuIGM7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdEV2ZW50cyh2bSkge1xuICB2bS5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgdm0uX2hhc0hvb2tFdmVudCA9IGZhbHNlO1xuICAvLyBpbml0IHBhcmVudCBhdHRhY2hlZCBldmVudHNcbiAgdmFyIGxpc3RlbmVycyA9IHZtLiRvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnM7XG4gIGlmIChsaXN0ZW5lcnMpIHtcbiAgICB1cGRhdGVDb21wb25lbnRMaXN0ZW5lcnModm0sIGxpc3RlbmVycyk7XG4gIH1cbn1cblxudmFyIHRhcmdldDtcblxuZnVuY3Rpb24gYWRkKGV2ZW50LCBmbiwgb25jZSQkMSkge1xuICBpZiAob25jZSQkMSkge1xuICAgIHRhcmdldC4kb25jZShldmVudCwgZm4pO1xuICB9IGVsc2Uge1xuICAgIHRhcmdldC4kb24oZXZlbnQsIGZuKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZW1vdmUkMShldmVudCwgZm4pIHtcbiAgdGFyZ2V0LiRvZmYoZXZlbnQsIGZuKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlQ29tcG9uZW50TGlzdGVuZXJzKHZtLCBsaXN0ZW5lcnMsIG9sZExpc3RlbmVycykge1xuICB0YXJnZXQgPSB2bTtcbiAgdXBkYXRlTGlzdGVuZXJzKGxpc3RlbmVycywgb2xkTGlzdGVuZXJzIHx8IHt9LCBhZGQsIHJlbW92ZSQxLCB2bSk7XG59XG5cbmZ1bmN0aW9uIGV2ZW50c01peGluKFZ1ZSkge1xuICB2YXIgaG9va1JFID0gL15ob29rOi87XG4gIFZ1ZS5wcm90b3R5cGUuJG9uID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBpZiAoQXJyYXkuaXNBcnJheShldmVudCkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gZXZlbnQubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHRoaXMkMS4kb24oZXZlbnRbaV0sIGZuKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgKHZtLl9ldmVudHNbZXZlbnRdIHx8ICh2bS5fZXZlbnRzW2V2ZW50XSA9IFtdKSkucHVzaChmbik7XG4gICAgICAvLyBvcHRpbWl6ZSBob29rOmV2ZW50IGNvc3QgYnkgdXNpbmcgYSBib29sZWFuIGZsYWcgbWFya2VkIGF0IHJlZ2lzdHJhdGlvblxuICAgICAgLy8gaW5zdGVhZCBvZiBhIGhhc2ggbG9va3VwXG4gICAgICBpZiAoaG9va1JFLnRlc3QoZXZlbnQpKSB7XG4gICAgICAgIHZtLl9oYXNIb29rRXZlbnQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdm07XG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS4kb25jZSA9IGZ1bmN0aW9uIChldmVudCwgZm4pIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGZ1bmN0aW9uIG9uKCkge1xuICAgICAgdm0uJG9mZihldmVudCwgb24pO1xuICAgICAgZm4uYXBwbHkodm0sIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIG9uLmZuID0gZm47XG4gICAgdm0uJG9uKGV2ZW50LCBvbik7XG4gICAgcmV0dXJuIHZtO1xuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuJG9mZiA9IGZ1bmN0aW9uIChldmVudCwgZm4pIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgLy8gYWxsXG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICB2bS5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIHJldHVybiB2bTtcbiAgICB9XG4gICAgLy8gYXJyYXkgb2YgZXZlbnRzXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZXZlbnQpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGV2ZW50Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB0aGlzJDEuJG9mZihldmVudFtpXSwgZm4pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZtO1xuICAgIH1cbiAgICAvLyBzcGVjaWZpYyBldmVudFxuICAgIHZhciBjYnMgPSB2bS5fZXZlbnRzW2V2ZW50XTtcbiAgICBpZiAoIWNicykge1xuICAgICAgcmV0dXJuIHZtO1xuICAgIH1cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdm0uX2V2ZW50c1tldmVudF0gPSBudWxsO1xuICAgICAgcmV0dXJuIHZtO1xuICAgIH1cbiAgICBpZiAoZm4pIHtcbiAgICAgIC8vIHNwZWNpZmljIGhhbmRsZXJcbiAgICAgIHZhciBjYjtcbiAgICAgIHZhciBpJDEgPSBjYnMubGVuZ3RoO1xuICAgICAgd2hpbGUgKGkkMS0tKSB7XG4gICAgICAgIGNiID0gY2JzW2kkMV07XG4gICAgICAgIGlmIChjYiA9PT0gZm4gfHwgY2IuZm4gPT09IGZuKSB7XG4gICAgICAgICAgY2JzLnNwbGljZShpJDEsIDEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2bTtcbiAgfTtcblxuICBWdWUucHJvdG90eXBlLiRlbWl0ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBpZiAoZmFsc2UpIHtcbiAgICAgIHZhciBsb3dlckNhc2VFdmVudCA9IGV2ZW50LnRvTG93ZXJDYXNlKCk7XG4gICAgICBpZiAobG93ZXJDYXNlRXZlbnQgIT09IGV2ZW50ICYmIHZtLl9ldmVudHNbbG93ZXJDYXNlRXZlbnRdKSB7XG4gICAgICAgIHRpcChcIkV2ZW50IFxcXCJcIiArIGxvd2VyQ2FzZUV2ZW50ICsgXCJcXFwiIGlzIGVtaXR0ZWQgaW4gY29tcG9uZW50IFwiICsgZm9ybWF0Q29tcG9uZW50TmFtZSh2bSkgKyBcIiBidXQgdGhlIGhhbmRsZXIgaXMgcmVnaXN0ZXJlZCBmb3IgXFxcIlwiICsgZXZlbnQgKyBcIlxcXCIuIFwiICsgXCJOb3RlIHRoYXQgSFRNTCBhdHRyaWJ1dGVzIGFyZSBjYXNlLWluc2Vuc2l0aXZlIGFuZCB5b3UgY2Fubm90IHVzZSBcIiArIFwidi1vbiB0byBsaXN0ZW4gdG8gY2FtZWxDYXNlIGV2ZW50cyB3aGVuIHVzaW5nIGluLURPTSB0ZW1wbGF0ZXMuIFwiICsgXCJZb3Ugc2hvdWxkIHByb2JhYmx5IHVzZSBcXFwiXCIgKyBoeXBoZW5hdGUoZXZlbnQpICsgXCJcXFwiIGluc3RlYWQgb2YgXFxcIlwiICsgZXZlbnQgKyBcIlxcXCIuXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgY2JzID0gdm0uX2V2ZW50c1tldmVudF07XG4gICAgaWYgKGNicykge1xuICAgICAgY2JzID0gY2JzLmxlbmd0aCA+IDEgPyB0b0FycmF5KGNicykgOiBjYnM7XG4gICAgICB2YXIgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzLCAxKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2JzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNic1tpXS5hcHBseSh2bSwgYXJncyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBoYW5kbGVFcnJvcihlLCB2bSwgXCJldmVudCBoYW5kbGVyIGZvciBcXFwiXCIgKyBldmVudCArIFwiXFxcIlwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdm07XG4gIH07XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZXNvbHZpbmcgcmF3IGNoaWxkcmVuIFZOb2RlcyBpbnRvIGEgc2xvdCBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVTbG90cyhjaGlsZHJlbiwgY29udGV4dCkge1xuICB2YXIgc2xvdHMgPSB7fTtcbiAgaWYgKCFjaGlsZHJlbikge1xuICAgIHJldHVybiBzbG90cztcbiAgfVxuICB2YXIgZGVmYXVsdFNsb3QgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICB2YXIgZGF0YSA9IGNoaWxkLmRhdGE7XG4gICAgLy8gcmVtb3ZlIHNsb3QgYXR0cmlidXRlIGlmIHRoZSBub2RlIGlzIHJlc29sdmVkIGFzIGEgVnVlIHNsb3Qgbm9kZVxuICAgIGlmIChkYXRhICYmIGRhdGEuYXR0cnMgJiYgZGF0YS5hdHRycy5zbG90KSB7XG4gICAgICBkZWxldGUgZGF0YS5hdHRycy5zbG90O1xuICAgIH1cbiAgICAvLyBuYW1lZCBzbG90cyBzaG91bGQgb25seSBiZSByZXNwZWN0ZWQgaWYgdGhlIHZub2RlIHdhcyByZW5kZXJlZCBpbiB0aGVcbiAgICAvLyBzYW1lIGNvbnRleHQuXG4gICAgaWYgKChjaGlsZC5jb250ZXh0ID09PSBjb250ZXh0IHx8IGNoaWxkLmZ1bmN0aW9uYWxDb250ZXh0ID09PSBjb250ZXh0KSAmJiBkYXRhICYmIGRhdGEuc2xvdCAhPSBudWxsKSB7XG4gICAgICB2YXIgbmFtZSA9IGNoaWxkLmRhdGEuc2xvdDtcbiAgICAgIHZhciBzbG90ID0gc2xvdHNbbmFtZV0gfHwgKHNsb3RzW25hbWVdID0gW10pO1xuICAgICAgaWYgKGNoaWxkLnRhZyA9PT0gJ3RlbXBsYXRlJykge1xuICAgICAgICBzbG90LnB1c2guYXBwbHkoc2xvdCwgY2hpbGQuY2hpbGRyZW4pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2xvdC5wdXNoKGNoaWxkKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZGVmYXVsdFNsb3QucHVzaChjaGlsZCk7XG4gICAgfVxuICB9XG4gIC8vIGlnbm9yZSB3aGl0ZXNwYWNlXG4gIGlmICghZGVmYXVsdFNsb3QuZXZlcnkoaXNXaGl0ZXNwYWNlKSkge1xuICAgIHNsb3RzLmRlZmF1bHQgPSBkZWZhdWx0U2xvdDtcbiAgfVxuICByZXR1cm4gc2xvdHM7XG59XG5cbmZ1bmN0aW9uIGlzV2hpdGVzcGFjZShub2RlKSB7XG4gIHJldHVybiBub2RlLmlzQ29tbWVudCB8fCBub2RlLnRleHQgPT09ICcgJztcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZVNjb3BlZFNsb3RzKGZucywgLy8gc2VlIGZsb3cvdm5vZGVcbnJlcykge1xuICByZXMgPSByZXMgfHwge307XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZm5zLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZm5zW2ldKSkge1xuICAgICAgcmVzb2x2ZVNjb3BlZFNsb3RzKGZuc1tpXSwgcmVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzW2Zuc1tpXS5rZXldID0gZm5zW2ldLmZuO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzO1xufVxuXG4vKiAgKi9cblxudmFyIGFjdGl2ZUluc3RhbmNlID0gbnVsbDtcbnZhciBpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQgPSBmYWxzZTtcblxuZnVuY3Rpb24gaW5pdExpZmVjeWNsZSh2bSkge1xuICB2YXIgb3B0aW9ucyA9IHZtLiRvcHRpb25zO1xuXG4gIC8vIGxvY2F0ZSBmaXJzdCBub24tYWJzdHJhY3QgcGFyZW50XG4gIHZhciBwYXJlbnQgPSBvcHRpb25zLnBhcmVudDtcbiAgaWYgKHBhcmVudCAmJiAhb3B0aW9ucy5hYnN0cmFjdCkge1xuICAgIHdoaWxlIChwYXJlbnQuJG9wdGlvbnMuYWJzdHJhY3QgJiYgcGFyZW50LiRwYXJlbnQpIHtcbiAgICAgIHBhcmVudCA9IHBhcmVudC4kcGFyZW50O1xuICAgIH1cbiAgICBwYXJlbnQuJGNoaWxkcmVuLnB1c2godm0pO1xuICB9XG5cbiAgdm0uJHBhcmVudCA9IHBhcmVudDtcbiAgdm0uJHJvb3QgPSBwYXJlbnQgPyBwYXJlbnQuJHJvb3QgOiB2bTtcblxuICB2bS4kY2hpbGRyZW4gPSBbXTtcbiAgdm0uJHJlZnMgPSB7fTtcblxuICB2bS5fd2F0Y2hlciA9IG51bGw7XG4gIHZtLl9pbmFjdGl2ZSA9IG51bGw7XG4gIHZtLl9kaXJlY3RJbmFjdGl2ZSA9IGZhbHNlO1xuICB2bS5faXNNb3VudGVkID0gZmFsc2U7XG4gIHZtLl9pc0Rlc3Ryb3llZCA9IGZhbHNlO1xuICB2bS5faXNCZWluZ0Rlc3Ryb3llZCA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBsaWZlY3ljbGVNaXhpbihWdWUpIHtcbiAgVnVlLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKHZub2RlLCBoeWRyYXRpbmcpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGlmICh2bS5faXNNb3VudGVkKSB7XG4gICAgICBjYWxsSG9vayh2bSwgJ2JlZm9yZVVwZGF0ZScpO1xuICAgIH1cbiAgICB2YXIgcHJldkVsID0gdm0uJGVsO1xuICAgIHZhciBwcmV2Vm5vZGUgPSB2bS5fdm5vZGU7XG4gICAgdmFyIHByZXZBY3RpdmVJbnN0YW5jZSA9IGFjdGl2ZUluc3RhbmNlO1xuICAgIGFjdGl2ZUluc3RhbmNlID0gdm07XG4gICAgdm0uX3Zub2RlID0gdm5vZGU7XG4gICAgLy8gVnVlLnByb3RvdHlwZS5fX3BhdGNoX18gaXMgaW5qZWN0ZWQgaW4gZW50cnkgcG9pbnRzXG4gICAgLy8gYmFzZWQgb24gdGhlIHJlbmRlcmluZyBiYWNrZW5kIHVzZWQuXG4gICAgaWYgKCFwcmV2Vm5vZGUpIHtcbiAgICAgIC8vIGluaXRpYWwgcmVuZGVyXG4gICAgICB2bS4kZWwgPSB2bS5fX3BhdGNoX18odm0uJGVsLCB2bm9kZSwgaHlkcmF0aW5nLCBmYWxzZSAvKiByZW1vdmVPbmx5ICovXG4gICAgICAsIHZtLiRvcHRpb25zLl9wYXJlbnRFbG0sIHZtLiRvcHRpb25zLl9yZWZFbG0pO1xuICAgICAgLy8gbm8gbmVlZCBmb3IgdGhlIHJlZiBub2RlcyBhZnRlciBpbml0aWFsIHBhdGNoXG4gICAgICAvLyB0aGlzIHByZXZlbnRzIGtlZXBpbmcgYSBkZXRhY2hlZCBET00gdHJlZSBpbiBtZW1vcnkgKCM1ODUxKVxuICAgICAgdm0uJG9wdGlvbnMuX3BhcmVudEVsbSA9IHZtLiRvcHRpb25zLl9yZWZFbG0gPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB1cGRhdGVzXG4gICAgICB2bS4kZWwgPSB2bS5fX3BhdGNoX18ocHJldlZub2RlLCB2bm9kZSk7XG4gICAgfVxuICAgIGFjdGl2ZUluc3RhbmNlID0gcHJldkFjdGl2ZUluc3RhbmNlO1xuICAgIC8vIHVwZGF0ZSBfX3Z1ZV9fIHJlZmVyZW5jZVxuICAgIGlmIChwcmV2RWwpIHtcbiAgICAgIHByZXZFbC5fX3Z1ZV9fID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKHZtLiRlbCkge1xuICAgICAgdm0uJGVsLl9fdnVlX18gPSB2bTtcbiAgICB9XG4gICAgLy8gaWYgcGFyZW50IGlzIGFuIEhPQywgdXBkYXRlIGl0cyAkZWwgYXMgd2VsbFxuICAgIGlmICh2bS4kdm5vZGUgJiYgdm0uJHBhcmVudCAmJiB2bS4kdm5vZGUgPT09IHZtLiRwYXJlbnQuX3Zub2RlKSB7XG4gICAgICB2bS4kcGFyZW50LiRlbCA9IHZtLiRlbDtcbiAgICB9XG4gICAgLy8gdXBkYXRlZCBob29rIGlzIGNhbGxlZCBieSB0aGUgc2NoZWR1bGVyIHRvIGVuc3VyZSB0aGF0IGNoaWxkcmVuIGFyZVxuICAgIC8vIHVwZGF0ZWQgaW4gYSBwYXJlbnQncyB1cGRhdGVkIGhvb2suXG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS4kZm9yY2VVcGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBpZiAodm0uX3dhdGNoZXIpIHtcbiAgICAgIHZtLl93YXRjaGVyLnVwZGF0ZSgpO1xuICAgIH1cbiAgfTtcblxuICBWdWUucHJvdG90eXBlLiRkZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgaWYgKHZtLl9pc0JlaW5nRGVzdHJveWVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNhbGxIb29rKHZtLCAnYmVmb3JlRGVzdHJveScpO1xuICAgIHZtLl9pc0JlaW5nRGVzdHJveWVkID0gdHJ1ZTtcbiAgICAvLyByZW1vdmUgc2VsZiBmcm9tIHBhcmVudFxuICAgIHZhciBwYXJlbnQgPSB2bS4kcGFyZW50O1xuICAgIGlmIChwYXJlbnQgJiYgIXBhcmVudC5faXNCZWluZ0Rlc3Ryb3llZCAmJiAhdm0uJG9wdGlvbnMuYWJzdHJhY3QpIHtcbiAgICAgIHJlbW92ZShwYXJlbnQuJGNoaWxkcmVuLCB2bSk7XG4gICAgfVxuICAgIC8vIHRlYXJkb3duIHdhdGNoZXJzXG4gICAgaWYgKHZtLl93YXRjaGVyKSB7XG4gICAgICB2bS5fd2F0Y2hlci50ZWFyZG93bigpO1xuICAgIH1cbiAgICB2YXIgaSA9IHZtLl93YXRjaGVycy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdm0uX3dhdGNoZXJzW2ldLnRlYXJkb3duKCk7XG4gICAgfVxuICAgIC8vIHJlbW92ZSByZWZlcmVuY2UgZnJvbSBkYXRhIG9iXG4gICAgLy8gZnJvemVuIG9iamVjdCBtYXkgbm90IGhhdmUgb2JzZXJ2ZXIuXG4gICAgaWYgKHZtLl9kYXRhLl9fb2JfXykge1xuICAgICAgdm0uX2RhdGEuX19vYl9fLnZtQ291bnQtLTtcbiAgICB9XG4gICAgLy8gY2FsbCB0aGUgbGFzdCBob29rLi4uXG4gICAgdm0uX2lzRGVzdHJveWVkID0gdHJ1ZTtcbiAgICAvLyBpbnZva2UgZGVzdHJveSBob29rcyBvbiBjdXJyZW50IHJlbmRlcmVkIHRyZWVcbiAgICB2bS5fX3BhdGNoX18odm0uX3Zub2RlLCBudWxsKTtcbiAgICAvLyBmaXJlIGRlc3Ryb3llZCBob29rXG4gICAgY2FsbEhvb2sodm0sICdkZXN0cm95ZWQnKTtcbiAgICAvLyB0dXJuIG9mZiBhbGwgaW5zdGFuY2UgbGlzdGVuZXJzLlxuICAgIHZtLiRvZmYoKTtcbiAgICAvLyByZW1vdmUgX192dWVfXyByZWZlcmVuY2VcbiAgICBpZiAodm0uJGVsKSB7XG4gICAgICB2bS4kZWwuX192dWVfXyA9IG51bGw7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBtb3VudENvbXBvbmVudCh2bSwgZWwsIGh5ZHJhdGluZykge1xuICB2bS4kZWwgPSBlbDtcbiAgaWYgKCF2bS4kb3B0aW9ucy5yZW5kZXIpIHtcbiAgICB2bS4kb3B0aW9ucy5yZW5kZXIgPSBjcmVhdGVFbXB0eVZOb2RlO1xuICAgIGlmIChmYWxzZSkge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAodm0uJG9wdGlvbnMudGVtcGxhdGUgJiYgdm0uJG9wdGlvbnMudGVtcGxhdGUuY2hhckF0KDApICE9PSAnIycgfHwgdm0uJG9wdGlvbnMuZWwgfHwgZWwpIHtcbiAgICAgICAgd2FybignWW91IGFyZSB1c2luZyB0aGUgcnVudGltZS1vbmx5IGJ1aWxkIG9mIFZ1ZSB3aGVyZSB0aGUgdGVtcGxhdGUgJyArICdjb21waWxlciBpcyBub3QgYXZhaWxhYmxlLiBFaXRoZXIgcHJlLWNvbXBpbGUgdGhlIHRlbXBsYXRlcyBpbnRvICcgKyAncmVuZGVyIGZ1bmN0aW9ucywgb3IgdXNlIHRoZSBjb21waWxlci1pbmNsdWRlZCBidWlsZC4nLCB2bSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3YXJuKCdGYWlsZWQgdG8gbW91bnQgY29tcG9uZW50OiB0ZW1wbGF0ZSBvciByZW5kZXIgZnVuY3Rpb24gbm90IGRlZmluZWQuJywgdm0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjYWxsSG9vayh2bSwgJ2JlZm9yZU1vdW50Jyk7XG5cbiAgdmFyIHVwZGF0ZUNvbXBvbmVudDtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChmYWxzZSkge1xuICAgIHVwZGF0ZUNvbXBvbmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBuYW1lID0gdm0uX25hbWU7XG4gICAgICB2YXIgaWQgPSB2bS5fdWlkO1xuICAgICAgdmFyIHN0YXJ0VGFnID0gXCJ2dWUtcGVyZi1zdGFydDpcIiArIGlkO1xuICAgICAgdmFyIGVuZFRhZyA9IFwidnVlLXBlcmYtZW5kOlwiICsgaWQ7XG5cbiAgICAgIG1hcmsoc3RhcnRUYWcpO1xuICAgICAgdmFyIHZub2RlID0gdm0uX3JlbmRlcigpO1xuICAgICAgbWFyayhlbmRUYWcpO1xuICAgICAgbWVhc3VyZShuYW1lICsgXCIgcmVuZGVyXCIsIHN0YXJ0VGFnLCBlbmRUYWcpO1xuXG4gICAgICBtYXJrKHN0YXJ0VGFnKTtcbiAgICAgIHZtLl91cGRhdGUodm5vZGUsIGh5ZHJhdGluZyk7XG4gICAgICBtYXJrKGVuZFRhZyk7XG4gICAgICBtZWFzdXJlKG5hbWUgKyBcIiBwYXRjaFwiLCBzdGFydFRhZywgZW5kVGFnKTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHVwZGF0ZUNvbXBvbmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZtLl91cGRhdGUodm0uX3JlbmRlcigpLCBoeWRyYXRpbmcpO1xuICAgIH07XG4gIH1cblxuICB2bS5fd2F0Y2hlciA9IG5ldyBXYXRjaGVyKHZtLCB1cGRhdGVDb21wb25lbnQsIG5vb3ApO1xuICBoeWRyYXRpbmcgPSBmYWxzZTtcblxuICAvLyBtYW51YWxseSBtb3VudGVkIGluc3RhbmNlLCBjYWxsIG1vdW50ZWQgb24gc2VsZlxuICAvLyBtb3VudGVkIGlzIGNhbGxlZCBmb3IgcmVuZGVyLWNyZWF0ZWQgY2hpbGQgY29tcG9uZW50cyBpbiBpdHMgaW5zZXJ0ZWQgaG9va1xuICBpZiAodm0uJHZub2RlID09IG51bGwpIHtcbiAgICB2bS5faXNNb3VudGVkID0gdHJ1ZTtcbiAgICBjYWxsSG9vayh2bSwgJ21vdW50ZWQnKTtcbiAgfVxuICByZXR1cm4gdm07XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUNoaWxkQ29tcG9uZW50KHZtLCBwcm9wc0RhdGEsIGxpc3RlbmVycywgcGFyZW50Vm5vZGUsIHJlbmRlckNoaWxkcmVuKSB7XG4gIGlmIChmYWxzZSkge1xuICAgIGlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCA9IHRydWU7XG4gIH1cblxuICAvLyBkZXRlcm1pbmUgd2hldGhlciBjb21wb25lbnQgaGFzIHNsb3QgY2hpbGRyZW5cbiAgLy8gd2UgbmVlZCB0byBkbyB0aGlzIGJlZm9yZSBvdmVyd3JpdGluZyAkb3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW5cbiAgdmFyIGhhc0NoaWxkcmVuID0gISEocmVuZGVyQ2hpbGRyZW4gfHwgLy8gaGFzIG5ldyBzdGF0aWMgc2xvdHNcbiAgdm0uJG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuIHx8IC8vIGhhcyBvbGQgc3RhdGljIHNsb3RzXG4gIHBhcmVudFZub2RlLmRhdGEuc2NvcGVkU2xvdHMgfHwgLy8gaGFzIG5ldyBzY29wZWQgc2xvdHNcbiAgdm0uJHNjb3BlZFNsb3RzICE9PSBlbXB0eU9iamVjdCAvLyBoYXMgb2xkIHNjb3BlZCBzbG90c1xuICApO1xuXG4gIHZtLiRvcHRpb25zLl9wYXJlbnRWbm9kZSA9IHBhcmVudFZub2RlO1xuICB2bS4kdm5vZGUgPSBwYXJlbnRWbm9kZTsgLy8gdXBkYXRlIHZtJ3MgcGxhY2Vob2xkZXIgbm9kZSB3aXRob3V0IHJlLXJlbmRlclxuXG4gIGlmICh2bS5fdm5vZGUpIHtcbiAgICAvLyB1cGRhdGUgY2hpbGQgdHJlZSdzIHBhcmVudFxuICAgIHZtLl92bm9kZS5wYXJlbnQgPSBwYXJlbnRWbm9kZTtcbiAgfVxuICB2bS4kb3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW4gPSByZW5kZXJDaGlsZHJlbjtcblxuICAvLyB1cGRhdGUgJGF0dHJzIGFuZCAkbGlzdGVuZXJzIGhhc2hcbiAgLy8gdGhlc2UgYXJlIGFsc28gcmVhY3RpdmUgc28gdGhleSBtYXkgdHJpZ2dlciBjaGlsZCB1cGRhdGUgaWYgdGhlIGNoaWxkXG4gIC8vIHVzZWQgdGhlbSBkdXJpbmcgcmVuZGVyXG4gIHZtLiRhdHRycyA9IHBhcmVudFZub2RlLmRhdGEgJiYgcGFyZW50Vm5vZGUuZGF0YS5hdHRycyB8fCBlbXB0eU9iamVjdDtcbiAgdm0uJGxpc3RlbmVycyA9IGxpc3RlbmVycyB8fCBlbXB0eU9iamVjdDtcblxuICAvLyB1cGRhdGUgcHJvcHNcbiAgaWYgKHByb3BzRGF0YSAmJiB2bS4kb3B0aW9ucy5wcm9wcykge1xuICAgIG9ic2VydmVyU3RhdGUuc2hvdWxkQ29udmVydCA9IGZhbHNlO1xuICAgIHZhciBwcm9wcyA9IHZtLl9wcm9wcztcbiAgICB2YXIgcHJvcEtleXMgPSB2bS4kb3B0aW9ucy5fcHJvcEtleXMgfHwgW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IHByb3BLZXlzW2ldO1xuICAgICAgcHJvcHNba2V5XSA9IHZhbGlkYXRlUHJvcChrZXksIHZtLiRvcHRpb25zLnByb3BzLCBwcm9wc0RhdGEsIHZtKTtcbiAgICB9XG4gICAgb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0ID0gdHJ1ZTtcbiAgICAvLyBrZWVwIGEgY29weSBvZiByYXcgcHJvcHNEYXRhXG4gICAgdm0uJG9wdGlvbnMucHJvcHNEYXRhID0gcHJvcHNEYXRhO1xuICB9XG5cbiAgLy8gdXBkYXRlIGxpc3RlbmVyc1xuICBpZiAobGlzdGVuZXJzKSB7XG4gICAgdmFyIG9sZExpc3RlbmVycyA9IHZtLiRvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnM7XG4gICAgdm0uJG9wdGlvbnMuX3BhcmVudExpc3RlbmVycyA9IGxpc3RlbmVycztcbiAgICB1cGRhdGVDb21wb25lbnRMaXN0ZW5lcnModm0sIGxpc3RlbmVycywgb2xkTGlzdGVuZXJzKTtcbiAgfVxuICAvLyByZXNvbHZlIHNsb3RzICsgZm9yY2UgdXBkYXRlIGlmIGhhcyBjaGlsZHJlblxuICBpZiAoaGFzQ2hpbGRyZW4pIHtcbiAgICB2bS4kc2xvdHMgPSByZXNvbHZlU2xvdHMocmVuZGVyQ2hpbGRyZW4sIHBhcmVudFZub2RlLmNvbnRleHQpO1xuICAgIHZtLiRmb3JjZVVwZGF0ZSgpO1xuICB9XG5cbiAgaWYgKGZhbHNlKSB7XG4gICAgaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50ID0gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNJbkluYWN0aXZlVHJlZSh2bSkge1xuICB3aGlsZSAodm0gJiYgKHZtID0gdm0uJHBhcmVudCkpIHtcbiAgICBpZiAodm0uX2luYWN0aXZlKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KHZtLCBkaXJlY3QpIHtcbiAgaWYgKGRpcmVjdCkge1xuICAgIHZtLl9kaXJlY3RJbmFjdGl2ZSA9IGZhbHNlO1xuICAgIGlmIChpc0luSW5hY3RpdmVUcmVlKHZtKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfSBlbHNlIGlmICh2bS5fZGlyZWN0SW5hY3RpdmUpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHZtLl9pbmFjdGl2ZSB8fCB2bS5faW5hY3RpdmUgPT09IG51bGwpIHtcbiAgICB2bS5faW5hY3RpdmUgPSBmYWxzZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZtLiRjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgYWN0aXZhdGVDaGlsZENvbXBvbmVudCh2bS4kY2hpbGRyZW5baV0pO1xuICAgIH1cbiAgICBjYWxsSG9vayh2bSwgJ2FjdGl2YXRlZCcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRlYWN0aXZhdGVDaGlsZENvbXBvbmVudCh2bSwgZGlyZWN0KSB7XG4gIGlmIChkaXJlY3QpIHtcbiAgICB2bS5fZGlyZWN0SW5hY3RpdmUgPSB0cnVlO1xuICAgIGlmIChpc0luSW5hY3RpdmVUcmVlKHZtKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuICBpZiAoIXZtLl9pbmFjdGl2ZSkge1xuICAgIHZtLl9pbmFjdGl2ZSA9IHRydWU7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2bS4kY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGRlYWN0aXZhdGVDaGlsZENvbXBvbmVudCh2bS4kY2hpbGRyZW5baV0pO1xuICAgIH1cbiAgICBjYWxsSG9vayh2bSwgJ2RlYWN0aXZhdGVkJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2FsbEhvb2sodm0sIGhvb2spIHtcbiAgdmFyIGhhbmRsZXJzID0gdm0uJG9wdGlvbnNbaG9va107XG4gIGlmIChoYW5kbGVycykge1xuICAgIGZvciAodmFyIGkgPSAwLCBqID0gaGFuZGxlcnMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG4gICAgICB0cnkge1xuICAgICAgICBoYW5kbGVyc1tpXS5jYWxsKHZtKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaGFuZGxlRXJyb3IoZSwgdm0sIGhvb2sgKyBcIiBob29rXCIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAodm0uX2hhc0hvb2tFdmVudCkge1xuICAgIHZtLiRlbWl0KCdob29rOicgKyBob29rKTtcbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIE1BWF9VUERBVEVfQ09VTlQgPSAxMDA7XG5cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGFjdGl2YXRlZENoaWxkcmVuID0gW107XG52YXIgaGFzID0ge307XG52YXIgY2lyY3VsYXIgPSB7fTtcbnZhciB3YWl0aW5nID0gZmFsc2U7XG52YXIgZmx1c2hpbmcgPSBmYWxzZTtcbnZhciBpbmRleCA9IDA7XG5cbi8qKlxuICogUmVzZXQgdGhlIHNjaGVkdWxlcidzIHN0YXRlLlxuICovXG5mdW5jdGlvbiByZXNldFNjaGVkdWxlclN0YXRlKCkge1xuICBpbmRleCA9IHF1ZXVlLmxlbmd0aCA9IGFjdGl2YXRlZENoaWxkcmVuLmxlbmd0aCA9IDA7XG4gIGhhcyA9IHt9O1xuICBpZiAoZmFsc2UpIHtcbiAgICBjaXJjdWxhciA9IHt9O1xuICB9XG4gIHdhaXRpbmcgPSBmbHVzaGluZyA9IGZhbHNlO1xufVxuXG4vKipcbiAqIEZsdXNoIGJvdGggcXVldWVzIGFuZCBydW4gdGhlIHdhdGNoZXJzLlxuICovXG5mdW5jdGlvbiBmbHVzaFNjaGVkdWxlclF1ZXVlKCkge1xuICBmbHVzaGluZyA9IHRydWU7XG4gIHZhciB3YXRjaGVyLCBpZDtcblxuICAvLyBTb3J0IHF1ZXVlIGJlZm9yZSBmbHVzaC5cbiAgLy8gVGhpcyBlbnN1cmVzIHRoYXQ6XG4gIC8vIDEuIENvbXBvbmVudHMgYXJlIHVwZGF0ZWQgZnJvbSBwYXJlbnQgdG8gY2hpbGQuIChiZWNhdXNlIHBhcmVudCBpcyBhbHdheXNcbiAgLy8gICAgY3JlYXRlZCBiZWZvcmUgdGhlIGNoaWxkKVxuICAvLyAyLiBBIGNvbXBvbmVudCdzIHVzZXIgd2F0Y2hlcnMgYXJlIHJ1biBiZWZvcmUgaXRzIHJlbmRlciB3YXRjaGVyIChiZWNhdXNlXG4gIC8vICAgIHVzZXIgd2F0Y2hlcnMgYXJlIGNyZWF0ZWQgYmVmb3JlIHRoZSByZW5kZXIgd2F0Y2hlcilcbiAgLy8gMy4gSWYgYSBjb21wb25lbnQgaXMgZGVzdHJveWVkIGR1cmluZyBhIHBhcmVudCBjb21wb25lbnQncyB3YXRjaGVyIHJ1bixcbiAgLy8gICAgaXRzIHdhdGNoZXJzIGNhbiBiZSBza2lwcGVkLlxuICBxdWV1ZS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGEuaWQgLSBiLmlkO1xuICB9KTtcblxuICAvLyBkbyBub3QgY2FjaGUgbGVuZ3RoIGJlY2F1c2UgbW9yZSB3YXRjaGVycyBtaWdodCBiZSBwdXNoZWRcbiAgLy8gYXMgd2UgcnVuIGV4aXN0aW5nIHdhdGNoZXJzXG4gIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IHF1ZXVlLmxlbmd0aDsgaW5kZXgrKykge1xuICAgIHdhdGNoZXIgPSBxdWV1ZVtpbmRleF07XG4gICAgaWQgPSB3YXRjaGVyLmlkO1xuICAgIGhhc1tpZF0gPSBudWxsO1xuICAgIHdhdGNoZXIucnVuKCk7XG4gICAgLy8gaW4gZGV2IGJ1aWxkLCBjaGVjayBhbmQgc3RvcCBjaXJjdWxhciB1cGRhdGVzLlxuICAgIGlmIChmYWxzZSkge1xuICAgICAgY2lyY3VsYXJbaWRdID0gKGNpcmN1bGFyW2lkXSB8fCAwKSArIDE7XG4gICAgICBpZiAoY2lyY3VsYXJbaWRdID4gTUFYX1VQREFURV9DT1VOVCkge1xuICAgICAgICB3YXJuKCdZb3UgbWF5IGhhdmUgYW4gaW5maW5pdGUgdXBkYXRlIGxvb3AgJyArICh3YXRjaGVyLnVzZXIgPyBcImluIHdhdGNoZXIgd2l0aCBleHByZXNzaW9uIFxcXCJcIiArIHdhdGNoZXIuZXhwcmVzc2lvbiArIFwiXFxcIlwiIDogXCJpbiBhIGNvbXBvbmVudCByZW5kZXIgZnVuY3Rpb24uXCIpLCB3YXRjaGVyLnZtKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8ga2VlcCBjb3BpZXMgb2YgcG9zdCBxdWV1ZXMgYmVmb3JlIHJlc2V0dGluZyBzdGF0ZVxuICB2YXIgYWN0aXZhdGVkUXVldWUgPSBhY3RpdmF0ZWRDaGlsZHJlbi5zbGljZSgpO1xuICB2YXIgdXBkYXRlZFF1ZXVlID0gcXVldWUuc2xpY2UoKTtcblxuICByZXNldFNjaGVkdWxlclN0YXRlKCk7XG5cbiAgLy8gY2FsbCBjb21wb25lbnQgdXBkYXRlZCBhbmQgYWN0aXZhdGVkIGhvb2tzXG4gIGNhbGxBY3RpdmF0ZWRIb29rcyhhY3RpdmF0ZWRRdWV1ZSk7XG4gIGNhbGxVcGRhdGVkSG9va3ModXBkYXRlZFF1ZXVlKTtcblxuICAvLyBkZXZ0b29sIGhvb2tcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChkZXZ0b29scyAmJiBjb25maWcuZGV2dG9vbHMpIHtcbiAgICBkZXZ0b29scy5lbWl0KCdmbHVzaCcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNhbGxVcGRhdGVkSG9va3MocXVldWUpIHtcbiAgdmFyIGkgPSBxdWV1ZS5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICB2YXIgd2F0Y2hlciA9IHF1ZXVlW2ldO1xuICAgIHZhciB2bSA9IHdhdGNoZXIudm07XG4gICAgaWYgKHZtLl93YXRjaGVyID09PSB3YXRjaGVyICYmIHZtLl9pc01vdW50ZWQpIHtcbiAgICAgIGNhbGxIb29rKHZtLCAndXBkYXRlZCcpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFF1ZXVlIGEga2VwdC1hbGl2ZSBjb21wb25lbnQgdGhhdCB3YXMgYWN0aXZhdGVkIGR1cmluZyBwYXRjaC5cbiAqIFRoZSBxdWV1ZSB3aWxsIGJlIHByb2Nlc3NlZCBhZnRlciB0aGUgZW50aXJlIHRyZWUgaGFzIGJlZW4gcGF0Y2hlZC5cbiAqL1xuZnVuY3Rpb24gcXVldWVBY3RpdmF0ZWRDb21wb25lbnQodm0pIHtcbiAgLy8gc2V0dGluZyBfaW5hY3RpdmUgdG8gZmFsc2UgaGVyZSBzbyB0aGF0IGEgcmVuZGVyIGZ1bmN0aW9uIGNhblxuICAvLyByZWx5IG9uIGNoZWNraW5nIHdoZXRoZXIgaXQncyBpbiBhbiBpbmFjdGl2ZSB0cmVlIChlLmcuIHJvdXRlci12aWV3KVxuICB2bS5faW5hY3RpdmUgPSBmYWxzZTtcbiAgYWN0aXZhdGVkQ2hpbGRyZW4ucHVzaCh2bSk7XG59XG5cbmZ1bmN0aW9uIGNhbGxBY3RpdmF0ZWRIb29rcyhxdWV1ZSkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgcXVldWVbaV0uX2luYWN0aXZlID0gdHJ1ZTtcbiAgICBhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KHF1ZXVlW2ldLCB0cnVlIC8qIHRydWUgKi8pO1xuICB9XG59XG5cbi8qKlxuICogUHVzaCBhIHdhdGNoZXIgaW50byB0aGUgd2F0Y2hlciBxdWV1ZS5cbiAqIEpvYnMgd2l0aCBkdXBsaWNhdGUgSURzIHdpbGwgYmUgc2tpcHBlZCB1bmxlc3MgaXQnc1xuICogcHVzaGVkIHdoZW4gdGhlIHF1ZXVlIGlzIGJlaW5nIGZsdXNoZWQuXG4gKi9cbmZ1bmN0aW9uIHF1ZXVlV2F0Y2hlcih3YXRjaGVyKSB7XG4gIHZhciBpZCA9IHdhdGNoZXIuaWQ7XG4gIGlmIChoYXNbaWRdID09IG51bGwpIHtcbiAgICBoYXNbaWRdID0gdHJ1ZTtcbiAgICBpZiAoIWZsdXNoaW5nKSB7XG4gICAgICBxdWV1ZS5wdXNoKHdhdGNoZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBpZiBhbHJlYWR5IGZsdXNoaW5nLCBzcGxpY2UgdGhlIHdhdGNoZXIgYmFzZWQgb24gaXRzIGlkXG4gICAgICAvLyBpZiBhbHJlYWR5IHBhc3QgaXRzIGlkLCBpdCB3aWxsIGJlIHJ1biBuZXh0IGltbWVkaWF0ZWx5LlxuICAgICAgdmFyIGkgPSBxdWV1ZS5sZW5ndGggLSAxO1xuICAgICAgd2hpbGUgKGkgPiBpbmRleCAmJiBxdWV1ZVtpXS5pZCA+IHdhdGNoZXIuaWQpIHtcbiAgICAgICAgaS0tO1xuICAgICAgfVxuICAgICAgcXVldWUuc3BsaWNlKGkgKyAxLCAwLCB3YXRjaGVyKTtcbiAgICB9XG4gICAgLy8gcXVldWUgdGhlIGZsdXNoXG4gICAgaWYgKCF3YWl0aW5nKSB7XG4gICAgICB3YWl0aW5nID0gdHJ1ZTtcbiAgICAgIG5leHRUaWNrKGZsdXNoU2NoZWR1bGVyUXVldWUpO1xuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIHVpZCQyID0gMDtcblxuLyoqXG4gKiBBIHdhdGNoZXIgcGFyc2VzIGFuIGV4cHJlc3Npb24sIGNvbGxlY3RzIGRlcGVuZGVuY2llcyxcbiAqIGFuZCBmaXJlcyBjYWxsYmFjayB3aGVuIHRoZSBleHByZXNzaW9uIHZhbHVlIGNoYW5nZXMuXG4gKiBUaGlzIGlzIHVzZWQgZm9yIGJvdGggdGhlICR3YXRjaCgpIGFwaSBhbmQgZGlyZWN0aXZlcy5cbiAqL1xudmFyIFdhdGNoZXIgPSBmdW5jdGlvbiBXYXRjaGVyKHZtLCBleHBPckZuLCBjYiwgb3B0aW9ucykge1xuICB0aGlzLnZtID0gdm07XG4gIHZtLl93YXRjaGVycy5wdXNoKHRoaXMpO1xuICAvLyBvcHRpb25zXG4gIGlmIChvcHRpb25zKSB7XG4gICAgdGhpcy5kZWVwID0gISFvcHRpb25zLmRlZXA7XG4gICAgdGhpcy51c2VyID0gISFvcHRpb25zLnVzZXI7XG4gICAgdGhpcy5sYXp5ID0gISFvcHRpb25zLmxhenk7XG4gICAgdGhpcy5zeW5jID0gISFvcHRpb25zLnN5bmM7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5kZWVwID0gdGhpcy51c2VyID0gdGhpcy5sYXp5ID0gdGhpcy5zeW5jID0gZmFsc2U7XG4gIH1cbiAgdGhpcy5jYiA9IGNiO1xuICB0aGlzLmlkID0gKyt1aWQkMjsgLy8gdWlkIGZvciBiYXRjaGluZ1xuICB0aGlzLmFjdGl2ZSA9IHRydWU7XG4gIHRoaXMuZGlydHkgPSB0aGlzLmxhenk7IC8vIGZvciBsYXp5IHdhdGNoZXJzXG4gIHRoaXMuZGVwcyA9IFtdO1xuICB0aGlzLm5ld0RlcHMgPSBbXTtcbiAgdGhpcy5kZXBJZHMgPSBuZXcgX1NldCgpO1xuICB0aGlzLm5ld0RlcElkcyA9IG5ldyBfU2V0KCk7XG4gIHRoaXMuZXhwcmVzc2lvbiA9ICBmYWxzZSA/IGV4cE9yRm4udG9TdHJpbmcoKSA6ICcnO1xuICAvLyBwYXJzZSBleHByZXNzaW9uIGZvciBnZXR0ZXJcbiAgaWYgKHR5cGVvZiBleHBPckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhpcy5nZXR0ZXIgPSBleHBPckZuO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuZ2V0dGVyID0gcGFyc2VQYXRoKGV4cE9yRm4pO1xuICAgIGlmICghdGhpcy5nZXR0ZXIpIHtcbiAgICAgIHRoaXMuZ2V0dGVyID0gZnVuY3Rpb24gKCkge307XG4gICAgICBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXCJGYWlsZWQgd2F0Y2hpbmcgcGF0aDogXFxcIlwiICsgZXhwT3JGbiArIFwiXFxcIiBcIiArICdXYXRjaGVyIG9ubHkgYWNjZXB0cyBzaW1wbGUgZG90LWRlbGltaXRlZCBwYXRocy4gJyArICdGb3IgZnVsbCBjb250cm9sLCB1c2UgYSBmdW5jdGlvbiBpbnN0ZWFkLicsIHZtKTtcbiAgICB9XG4gIH1cbiAgdGhpcy52YWx1ZSA9IHRoaXMubGF6eSA/IHVuZGVmaW5lZCA6IHRoaXMuZ2V0KCk7XG59O1xuXG4vKipcbiAqIEV2YWx1YXRlIHRoZSBnZXR0ZXIsIGFuZCByZS1jb2xsZWN0IGRlcGVuZGVuY2llcy5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0KCkge1xuICBwdXNoVGFyZ2V0KHRoaXMpO1xuICB2YXIgdmFsdWU7XG4gIHZhciB2bSA9IHRoaXMudm07XG4gIHRyeSB7XG4gICAgdmFsdWUgPSB0aGlzLmdldHRlci5jYWxsKHZtLCB2bSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAodGhpcy51c2VyKSB7XG4gICAgICBoYW5kbGVFcnJvcihlLCB2bSwgXCJnZXR0ZXIgZm9yIHdhdGNoZXIgXFxcIlwiICsgdGhpcy5leHByZXNzaW9uICsgXCJcXFwiXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBlO1xuICAgIH1cbiAgfSBmaW5hbGx5IHtcbiAgICAvLyBcInRvdWNoXCIgZXZlcnkgcHJvcGVydHkgc28gdGhleSBhcmUgYWxsIHRyYWNrZWQgYXNcbiAgICAvLyBkZXBlbmRlbmNpZXMgZm9yIGRlZXAgd2F0Y2hpbmdcbiAgICBpZiAodGhpcy5kZWVwKSB7XG4gICAgICB0cmF2ZXJzZSh2YWx1ZSk7XG4gICAgfVxuICAgIHBvcFRhcmdldCgpO1xuICAgIHRoaXMuY2xlYW51cERlcHMoKTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59O1xuXG4vKipcbiAqIEFkZCBhIGRlcGVuZGVuY3kgdG8gdGhpcyBkaXJlY3RpdmUuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLmFkZERlcCA9IGZ1bmN0aW9uIGFkZERlcChkZXApIHtcbiAgdmFyIGlkID0gZGVwLmlkO1xuICBpZiAoIXRoaXMubmV3RGVwSWRzLmhhcyhpZCkpIHtcbiAgICB0aGlzLm5ld0RlcElkcy5hZGQoaWQpO1xuICAgIHRoaXMubmV3RGVwcy5wdXNoKGRlcCk7XG4gICAgaWYgKCF0aGlzLmRlcElkcy5oYXMoaWQpKSB7XG4gICAgICBkZXAuYWRkU3ViKHRoaXMpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBDbGVhbiB1cCBmb3IgZGVwZW5kZW5jeSBjb2xsZWN0aW9uLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5jbGVhbnVwRGVwcyA9IGZ1bmN0aW9uIGNsZWFudXBEZXBzKCkge1xuICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgaSA9IHRoaXMuZGVwcy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICB2YXIgZGVwID0gdGhpcyQxLmRlcHNbaV07XG4gICAgaWYgKCF0aGlzJDEubmV3RGVwSWRzLmhhcyhkZXAuaWQpKSB7XG4gICAgICBkZXAucmVtb3ZlU3ViKHRoaXMkMSk7XG4gICAgfVxuICB9XG4gIHZhciB0bXAgPSB0aGlzLmRlcElkcztcbiAgdGhpcy5kZXBJZHMgPSB0aGlzLm5ld0RlcElkcztcbiAgdGhpcy5uZXdEZXBJZHMgPSB0bXA7XG4gIHRoaXMubmV3RGVwSWRzLmNsZWFyKCk7XG4gIHRtcCA9IHRoaXMuZGVwcztcbiAgdGhpcy5kZXBzID0gdGhpcy5uZXdEZXBzO1xuICB0aGlzLm5ld0RlcHMgPSB0bXA7XG4gIHRoaXMubmV3RGVwcy5sZW5ndGggPSAwO1xufTtcblxuLyoqXG4gKiBTdWJzY3JpYmVyIGludGVyZmFjZS5cbiAqIFdpbGwgYmUgY2FsbGVkIHdoZW4gYSBkZXBlbmRlbmN5IGNoYW5nZXMuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKHRoaXMubGF6eSkge1xuICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICB9IGVsc2UgaWYgKHRoaXMuc3luYykge1xuICAgIHRoaXMucnVuKCk7XG4gIH0gZWxzZSB7XG4gICAgcXVldWVXYXRjaGVyKHRoaXMpO1xuICB9XG59O1xuXG4vKipcbiAqIFNjaGVkdWxlciBqb2IgaW50ZXJmYWNlLlxuICogV2lsbCBiZSBjYWxsZWQgYnkgdGhlIHNjaGVkdWxlci5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gcnVuKCkge1xuICBpZiAodGhpcy5hY3RpdmUpIHtcbiAgICB2YXIgdmFsdWUgPSB0aGlzLmdldCgpO1xuICAgIGlmICh2YWx1ZSAhPT0gdGhpcy52YWx1ZSB8fFxuICAgIC8vIERlZXAgd2F0Y2hlcnMgYW5kIHdhdGNoZXJzIG9uIE9iamVjdC9BcnJheXMgc2hvdWxkIGZpcmUgZXZlblxuICAgIC8vIHdoZW4gdGhlIHZhbHVlIGlzIHRoZSBzYW1lLCBiZWNhdXNlIHRoZSB2YWx1ZSBtYXlcbiAgICAvLyBoYXZlIG11dGF0ZWQuXG4gICAgaXNPYmplY3QodmFsdWUpIHx8IHRoaXMuZGVlcCkge1xuICAgICAgLy8gc2V0IG5ldyB2YWx1ZVxuICAgICAgdmFyIG9sZFZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgIGlmICh0aGlzLnVzZXIpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGlzLmNiLmNhbGwodGhpcy52bSwgdmFsdWUsIG9sZFZhbHVlKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGhhbmRsZUVycm9yKGUsIHRoaXMudm0sIFwiY2FsbGJhY2sgZm9yIHdhdGNoZXIgXFxcIlwiICsgdGhpcy5leHByZXNzaW9uICsgXCJcXFwiXCIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNiLmNhbGwodGhpcy52bSwgdmFsdWUsIG9sZFZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogRXZhbHVhdGUgdGhlIHZhbHVlIG9mIHRoZSB3YXRjaGVyLlxuICogVGhpcyBvbmx5IGdldHMgY2FsbGVkIGZvciBsYXp5IHdhdGNoZXJzLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uIGV2YWx1YXRlKCkge1xuICB0aGlzLnZhbHVlID0gdGhpcy5nZXQoKTtcbiAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xufTtcblxuLyoqXG4gKiBEZXBlbmQgb24gYWxsIGRlcHMgY29sbGVjdGVkIGJ5IHRoaXMgd2F0Y2hlci5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUuZGVwZW5kID0gZnVuY3Rpb24gZGVwZW5kKCkge1xuICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgaSA9IHRoaXMuZGVwcy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICB0aGlzJDEuZGVwc1tpXS5kZXBlbmQoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBSZW1vdmUgc2VsZiBmcm9tIGFsbCBkZXBlbmRlbmNpZXMnIHN1YnNjcmliZXIgbGlzdC5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUudGVhcmRvd24gPSBmdW5jdGlvbiB0ZWFyZG93bigpIHtcbiAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgaWYgKHRoaXMuYWN0aXZlKSB7XG4gICAgLy8gcmVtb3ZlIHNlbGYgZnJvbSB2bSdzIHdhdGNoZXIgbGlzdFxuICAgIC8vIHRoaXMgaXMgYSBzb21ld2hhdCBleHBlbnNpdmUgb3BlcmF0aW9uIHNvIHdlIHNraXAgaXRcbiAgICAvLyBpZiB0aGUgdm0gaXMgYmVpbmcgZGVzdHJveWVkLlxuICAgIGlmICghdGhpcy52bS5faXNCZWluZ0Rlc3Ryb3llZCkge1xuICAgICAgcmVtb3ZlKHRoaXMudm0uX3dhdGNoZXJzLCB0aGlzKTtcbiAgICB9XG4gICAgdmFyIGkgPSB0aGlzLmRlcHMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHRoaXMkMS5kZXBzW2ldLnJlbW92ZVN1Yih0aGlzJDEpO1xuICAgIH1cbiAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICB9XG59O1xuXG4vKipcbiAqIFJlY3Vyc2l2ZWx5IHRyYXZlcnNlIGFuIG9iamVjdCB0byBldm9rZSBhbGwgY29udmVydGVkXG4gKiBnZXR0ZXJzLCBzbyB0aGF0IGV2ZXJ5IG5lc3RlZCBwcm9wZXJ0eSBpbnNpZGUgdGhlIG9iamVjdFxuICogaXMgY29sbGVjdGVkIGFzIGEgXCJkZWVwXCIgZGVwZW5kZW5jeS5cbiAqL1xudmFyIHNlZW5PYmplY3RzID0gbmV3IF9TZXQoKTtcbmZ1bmN0aW9uIHRyYXZlcnNlKHZhbCkge1xuICBzZWVuT2JqZWN0cy5jbGVhcigpO1xuICBfdHJhdmVyc2UodmFsLCBzZWVuT2JqZWN0cyk7XG59XG5cbmZ1bmN0aW9uIF90cmF2ZXJzZSh2YWwsIHNlZW4pIHtcbiAgdmFyIGksIGtleXM7XG4gIHZhciBpc0EgPSBBcnJheS5pc0FycmF5KHZhbCk7XG4gIGlmICghaXNBICYmICFpc09iamVjdCh2YWwpIHx8ICFPYmplY3QuaXNFeHRlbnNpYmxlKHZhbCkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHZhbC5fX29iX18pIHtcbiAgICB2YXIgZGVwSWQgPSB2YWwuX19vYl9fLmRlcC5pZDtcbiAgICBpZiAoc2Vlbi5oYXMoZGVwSWQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHNlZW4uYWRkKGRlcElkKTtcbiAgfVxuICBpZiAoaXNBKSB7XG4gICAgaSA9IHZhbC5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgX3RyYXZlcnNlKHZhbFtpXSwgc2Vlbik7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGtleXMgPSBPYmplY3Qua2V5cyh2YWwpO1xuICAgIGkgPSBrZXlzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBfdHJhdmVyc2UodmFsW2tleXNbaV1dLCBzZWVuKTtcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbnZhciBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24gPSB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBub29wLFxuICBzZXQ6IG5vb3Bcbn07XG5cbmZ1bmN0aW9uIHByb3h5KHRhcmdldCwgc291cmNlS2V5LCBrZXkpIHtcbiAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLmdldCA9IGZ1bmN0aW9uIHByb3h5R2V0dGVyKCkge1xuICAgIHJldHVybiB0aGlzW3NvdXJjZUtleV1ba2V5XTtcbiAgfTtcbiAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9IGZ1bmN0aW9uIHByb3h5U2V0dGVyKHZhbCkge1xuICAgIHRoaXNbc291cmNlS2V5XVtrZXldID0gdmFsO1xuICB9O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbik7XG59XG5cbmZ1bmN0aW9uIGluaXRTdGF0ZSh2bSkge1xuICB2bS5fd2F0Y2hlcnMgPSBbXTtcbiAgdmFyIG9wdHMgPSB2bS4kb3B0aW9ucztcbiAgaWYgKG9wdHMucHJvcHMpIHtcbiAgICBpbml0UHJvcHModm0sIG9wdHMucHJvcHMpO1xuICB9XG4gIGlmIChvcHRzLm1ldGhvZHMpIHtcbiAgICBpbml0TWV0aG9kcyh2bSwgb3B0cy5tZXRob2RzKTtcbiAgfVxuICBpZiAob3B0cy5kYXRhKSB7XG4gICAgaW5pdERhdGEodm0pO1xuICB9IGVsc2Uge1xuICAgIG9ic2VydmUodm0uX2RhdGEgPSB7fSwgdHJ1ZSAvKiBhc1Jvb3REYXRhICovKTtcbiAgfVxuICBpZiAob3B0cy5jb21wdXRlZCkge1xuICAgIGluaXRDb21wdXRlZCh2bSwgb3B0cy5jb21wdXRlZCk7XG4gIH1cbiAgaWYgKG9wdHMud2F0Y2ggJiYgb3B0cy53YXRjaCAhPT0gbmF0aXZlV2F0Y2gpIHtcbiAgICBpbml0V2F0Y2godm0sIG9wdHMud2F0Y2gpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrT3B0aW9uVHlwZSh2bSwgbmFtZSkge1xuICB2YXIgb3B0aW9uID0gdm0uJG9wdGlvbnNbbmFtZV07XG4gIGlmICghaXNQbGFpbk9iamVjdChvcHRpb24pKSB7XG4gICAgd2FybihcImNvbXBvbmVudCBvcHRpb24gXFxcIlwiICsgbmFtZSArIFwiXFxcIiBzaG91bGQgYmUgYW4gb2JqZWN0LlwiLCB2bSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdFByb3BzKHZtLCBwcm9wc09wdGlvbnMpIHtcbiAgdmFyIHByb3BzRGF0YSA9IHZtLiRvcHRpb25zLnByb3BzRGF0YSB8fCB7fTtcbiAgdmFyIHByb3BzID0gdm0uX3Byb3BzID0ge307XG4gIC8vIGNhY2hlIHByb3Aga2V5cyBzbyB0aGF0IGZ1dHVyZSBwcm9wcyB1cGRhdGVzIGNhbiBpdGVyYXRlIHVzaW5nIEFycmF5XG4gIC8vIGluc3RlYWQgb2YgZHluYW1pYyBvYmplY3Qga2V5IGVudW1lcmF0aW9uLlxuICB2YXIga2V5cyA9IHZtLiRvcHRpb25zLl9wcm9wS2V5cyA9IFtdO1xuICB2YXIgaXNSb290ID0gIXZtLiRwYXJlbnQ7XG4gIC8vIHJvb3QgaW5zdGFuY2UgcHJvcHMgc2hvdWxkIGJlIGNvbnZlcnRlZFxuICBvYnNlcnZlclN0YXRlLnNob3VsZENvbnZlcnQgPSBpc1Jvb3Q7XG4gIHZhciBsb29wID0gZnVuY3Rpb24gKGtleSkge1xuICAgIGtleXMucHVzaChrZXkpO1xuICAgIHZhciB2YWx1ZSA9IHZhbGlkYXRlUHJvcChrZXksIHByb3BzT3B0aW9ucywgcHJvcHNEYXRhLCB2bSk7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAoZmFsc2UpIHtcbiAgICAgIGlmIChpc1Jlc2VydmVkQXR0cmlidXRlKGtleSkgfHwgY29uZmlnLmlzUmVzZXJ2ZWRBdHRyKGtleSkpIHtcbiAgICAgICAgd2FybihcIlxcXCJcIiArIGtleSArIFwiXFxcIiBpcyBhIHJlc2VydmVkIGF0dHJpYnV0ZSBhbmQgY2Fubm90IGJlIHVzZWQgYXMgY29tcG9uZW50IHByb3AuXCIsIHZtKTtcbiAgICAgIH1cbiAgICAgIGRlZmluZVJlYWN0aXZlJCQxKHByb3BzLCBrZXksIHZhbHVlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh2bS4kcGFyZW50ICYmICFpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQpIHtcbiAgICAgICAgICB3YXJuKFwiQXZvaWQgbXV0YXRpbmcgYSBwcm9wIGRpcmVjdGx5IHNpbmNlIHRoZSB2YWx1ZSB3aWxsIGJlIFwiICsgXCJvdmVyd3JpdHRlbiB3aGVuZXZlciB0aGUgcGFyZW50IGNvbXBvbmVudCByZS1yZW5kZXJzLiBcIiArIFwiSW5zdGVhZCwgdXNlIGEgZGF0YSBvciBjb21wdXRlZCBwcm9wZXJ0eSBiYXNlZCBvbiB0aGUgcHJvcCdzIFwiICsgXCJ2YWx1ZS4gUHJvcCBiZWluZyBtdXRhdGVkOiBcXFwiXCIgKyBrZXkgKyBcIlxcXCJcIiwgdm0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVmaW5lUmVhY3RpdmUkJDEocHJvcHMsIGtleSwgdmFsdWUpO1xuICAgIH1cbiAgICAvLyBzdGF0aWMgcHJvcHMgYXJlIGFscmVhZHkgcHJveGllZCBvbiB0aGUgY29tcG9uZW50J3MgcHJvdG90eXBlXG4gICAgLy8gZHVyaW5nIFZ1ZS5leHRlbmQoKS4gV2Ugb25seSBuZWVkIHRvIHByb3h5IHByb3BzIGRlZmluZWQgYXRcbiAgICAvLyBpbnN0YW50aWF0aW9uIGhlcmUuXG4gICAgaWYgKCEoa2V5IGluIHZtKSkge1xuICAgICAgcHJveHkodm0sIFwiX3Byb3BzXCIsIGtleSk7XG4gICAgfVxuICB9O1xuXG4gIGZvciAodmFyIGtleSBpbiBwcm9wc09wdGlvbnMpIGxvb3Aoa2V5KTtcbiAgb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0ID0gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gaW5pdERhdGEodm0pIHtcbiAgdmFyIGRhdGEgPSB2bS4kb3B0aW9ucy5kYXRhO1xuICBkYXRhID0gdm0uX2RhdGEgPSB0eXBlb2YgZGF0YSA9PT0gJ2Z1bmN0aW9uJyA/IGdldERhdGEoZGF0YSwgdm0pIDogZGF0YSB8fCB7fTtcbiAgaWYgKCFpc1BsYWluT2JqZWN0KGRhdGEpKSB7XG4gICAgZGF0YSA9IHt9O1xuICAgIFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgJiYgd2FybignZGF0YSBmdW5jdGlvbnMgc2hvdWxkIHJldHVybiBhbiBvYmplY3Q6XFxuJyArICdodHRwczovL3Z1ZWpzLm9yZy92Mi9ndWlkZS9jb21wb25lbnRzLmh0bWwjZGF0YS1NdXN0LUJlLWEtRnVuY3Rpb24nLCB2bSk7XG4gIH1cbiAgLy8gcHJveHkgZGF0YSBvbiBpbnN0YW5jZVxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGRhdGEpO1xuICB2YXIgcHJvcHMgPSB2bS4kb3B0aW9ucy5wcm9wcztcbiAgdmFyIG1ldGhvZHMgPSB2bS4kb3B0aW9ucy5tZXRob2RzO1xuICB2YXIgaSA9IGtleXMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgaWYgKGZhbHNlKSB7XG4gICAgICBpZiAobWV0aG9kcyAmJiBoYXNPd24obWV0aG9kcywga2V5KSkge1xuICAgICAgICB3YXJuKFwiTWV0aG9kIFxcXCJcIiArIGtleSArIFwiXFxcIiBoYXMgYWxyZWFkeSBiZWVuIGRlZmluZWQgYXMgYSBkYXRhIHByb3BlcnR5LlwiLCB2bSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChwcm9wcyAmJiBoYXNPd24ocHJvcHMsIGtleSkpIHtcbiAgICAgIFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcIlRoZSBkYXRhIHByb3BlcnR5IFxcXCJcIiArIGtleSArIFwiXFxcIiBpcyBhbHJlYWR5IGRlY2xhcmVkIGFzIGEgcHJvcC4gXCIgKyBcIlVzZSBwcm9wIGRlZmF1bHQgdmFsdWUgaW5zdGVhZC5cIiwgdm0pO1xuICAgIH0gZWxzZSBpZiAoIWlzUmVzZXJ2ZWQoa2V5KSkge1xuICAgICAgcHJveHkodm0sIFwiX2RhdGFcIiwga2V5KTtcbiAgICB9XG4gIH1cbiAgLy8gb2JzZXJ2ZSBkYXRhXG4gIG9ic2VydmUoZGF0YSwgdHJ1ZSAvKiBhc1Jvb3REYXRhICovKTtcbn1cblxuZnVuY3Rpb24gZ2V0RGF0YShkYXRhLCB2bSkge1xuICB0cnkge1xuICAgIHJldHVybiBkYXRhLmNhbGwodm0pO1xuICB9IGNhdGNoIChlKSB7XG4gICAgaGFuZGxlRXJyb3IoZSwgdm0sIFwiZGF0YSgpXCIpO1xuICAgIHJldHVybiB7fTtcbiAgfVxufVxuXG52YXIgY29tcHV0ZWRXYXRjaGVyT3B0aW9ucyA9IHsgbGF6eTogdHJ1ZSB9O1xuXG5mdW5jdGlvbiBpbml0Q29tcHV0ZWQodm0sIGNvbXB1dGVkKSB7XG4gIFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgJiYgY2hlY2tPcHRpb25UeXBlKHZtLCAnY29tcHV0ZWQnKTtcbiAgdmFyIHdhdGNoZXJzID0gdm0uX2NvbXB1dGVkV2F0Y2hlcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAvLyBjb21wdXRlZCBwcm9wZXJ0aWVzIGFyZSBqdXN0IGdldHRlcnMgZHVyaW5nIFNTUlxuICB2YXIgaXNTU1IgPSBpc1NlcnZlclJlbmRlcmluZygpO1xuXG4gIGZvciAodmFyIGtleSBpbiBjb21wdXRlZCkge1xuICAgIHZhciB1c2VyRGVmID0gY29tcHV0ZWRba2V5XTtcbiAgICB2YXIgZ2V0dGVyID0gdHlwZW9mIHVzZXJEZWYgPT09ICdmdW5jdGlvbicgPyB1c2VyRGVmIDogdXNlckRlZi5nZXQ7XG4gICAgaWYgKGZhbHNlKSB7XG4gICAgICB3YXJuKFwiR2V0dGVyIGlzIG1pc3NpbmcgZm9yIGNvbXB1dGVkIHByb3BlcnR5IFxcXCJcIiArIGtleSArIFwiXFxcIi5cIiwgdm0pO1xuICAgIH1cblxuICAgIGlmICghaXNTU1IpIHtcbiAgICAgIC8vIGNyZWF0ZSBpbnRlcm5hbCB3YXRjaGVyIGZvciB0aGUgY29tcHV0ZWQgcHJvcGVydHkuXG4gICAgICB3YXRjaGVyc1trZXldID0gbmV3IFdhdGNoZXIodm0sIGdldHRlciB8fCBub29wLCBub29wLCBjb21wdXRlZFdhdGNoZXJPcHRpb25zKTtcbiAgICB9XG5cbiAgICAvLyBjb21wb25lbnQtZGVmaW5lZCBjb21wdXRlZCBwcm9wZXJ0aWVzIGFyZSBhbHJlYWR5IGRlZmluZWQgb24gdGhlXG4gICAgLy8gY29tcG9uZW50IHByb3RvdHlwZS4gV2Ugb25seSBuZWVkIHRvIGRlZmluZSBjb21wdXRlZCBwcm9wZXJ0aWVzIGRlZmluZWRcbiAgICAvLyBhdCBpbnN0YW50aWF0aW9uIGhlcmUuXG4gICAgaWYgKCEoa2V5IGluIHZtKSkge1xuICAgICAgZGVmaW5lQ29tcHV0ZWQodm0sIGtleSwgdXNlckRlZik7XG4gICAgfSBlbHNlIGlmIChmYWxzZSkge1xuICAgICAgaWYgKGtleSBpbiB2bS4kZGF0YSkge1xuICAgICAgICB3YXJuKFwiVGhlIGNvbXB1dGVkIHByb3BlcnR5IFxcXCJcIiArIGtleSArIFwiXFxcIiBpcyBhbHJlYWR5IGRlZmluZWQgaW4gZGF0YS5cIiwgdm0pO1xuICAgICAgfSBlbHNlIGlmICh2bS4kb3B0aW9ucy5wcm9wcyAmJiBrZXkgaW4gdm0uJG9wdGlvbnMucHJvcHMpIHtcbiAgICAgICAgd2FybihcIlRoZSBjb21wdXRlZCBwcm9wZXJ0eSBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaXMgYWxyZWFkeSBkZWZpbmVkIGFzIGEgcHJvcC5cIiwgdm0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkZWZpbmVDb21wdXRlZCh0YXJnZXQsIGtleSwgdXNlckRlZikge1xuICB2YXIgc2hvdWxkQ2FjaGUgPSAhaXNTZXJ2ZXJSZW5kZXJpbmcoKTtcbiAgaWYgKHR5cGVvZiB1c2VyRGVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLmdldCA9IHNob3VsZENhY2hlID8gY3JlYXRlQ29tcHV0ZWRHZXR0ZXIoa2V5KSA6IHVzZXJEZWY7XG4gICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9IG5vb3A7XG4gIH0gZWxzZSB7XG4gICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLmdldCA9IHVzZXJEZWYuZ2V0ID8gc2hvdWxkQ2FjaGUgJiYgdXNlckRlZi5jYWNoZSAhPT0gZmFsc2UgPyBjcmVhdGVDb21wdXRlZEdldHRlcihrZXkpIDogdXNlckRlZi5nZXQgOiBub29wO1xuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPSB1c2VyRGVmLnNldCA/IHVzZXJEZWYuc2V0IDogbm9vcDtcbiAgfVxuICBpZiAoZmFsc2UpIHtcbiAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgd2FybihcIkNvbXB1dGVkIHByb3BlcnR5IFxcXCJcIiArIGtleSArIFwiXFxcIiB3YXMgYXNzaWduZWQgdG8gYnV0IGl0IGhhcyBubyBzZXR0ZXIuXCIsIHRoaXMpO1xuICAgIH07XG4gIH1cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24pO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVDb21wdXRlZEdldHRlcihrZXkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGNvbXB1dGVkR2V0dGVyKCkge1xuICAgIHZhciB3YXRjaGVyID0gdGhpcy5fY29tcHV0ZWRXYXRjaGVycyAmJiB0aGlzLl9jb21wdXRlZFdhdGNoZXJzW2tleV07XG4gICAgaWYgKHdhdGNoZXIpIHtcbiAgICAgIGlmICh3YXRjaGVyLmRpcnR5KSB7XG4gICAgICAgIHdhdGNoZXIuZXZhbHVhdGUoKTtcbiAgICAgIH1cbiAgICAgIGlmIChEZXAudGFyZ2V0KSB7XG4gICAgICAgIHdhdGNoZXIuZGVwZW5kKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gd2F0Y2hlci52YWx1ZTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGluaXRNZXRob2RzKHZtLCBtZXRob2RzKSB7XG4gIFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgJiYgY2hlY2tPcHRpb25UeXBlKHZtLCAnbWV0aG9kcycpO1xuICB2YXIgcHJvcHMgPSB2bS4kb3B0aW9ucy5wcm9wcztcbiAgZm9yICh2YXIga2V5IGluIG1ldGhvZHMpIHtcbiAgICBpZiAoZmFsc2UpIHtcbiAgICAgIGlmIChtZXRob2RzW2tleV0gPT0gbnVsbCkge1xuICAgICAgICB3YXJuKFwiTWV0aG9kIFxcXCJcIiArIGtleSArIFwiXFxcIiBoYXMgYW4gdW5kZWZpbmVkIHZhbHVlIGluIHRoZSBjb21wb25lbnQgZGVmaW5pdGlvbi4gXCIgKyBcIkRpZCB5b3UgcmVmZXJlbmNlIHRoZSBmdW5jdGlvbiBjb3JyZWN0bHk/XCIsIHZtKTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9wcyAmJiBoYXNPd24ocHJvcHMsIGtleSkpIHtcbiAgICAgICAgd2FybihcIk1ldGhvZCBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaGFzIGFscmVhZHkgYmVlbiBkZWZpbmVkIGFzIGEgcHJvcC5cIiwgdm0pO1xuICAgICAgfVxuICAgICAgaWYgKGtleSBpbiB2bSAmJiBpc1Jlc2VydmVkKGtleSkpIHtcbiAgICAgICAgd2FybihcIk1ldGhvZCBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgY29uZmxpY3RzIHdpdGggYW4gZXhpc3RpbmcgVnVlIGluc3RhbmNlIG1ldGhvZC4gXCIgKyBcIkF2b2lkIGRlZmluaW5nIGNvbXBvbmVudCBtZXRob2RzIHRoYXQgc3RhcnQgd2l0aCBfIG9yICQuXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICB2bVtrZXldID0gbWV0aG9kc1trZXldID09IG51bGwgPyBub29wIDogYmluZChtZXRob2RzW2tleV0sIHZtKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0V2F0Y2godm0sIHdhdGNoKSB7XG4gIFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgJiYgY2hlY2tPcHRpb25UeXBlKHZtLCAnd2F0Y2gnKTtcbiAgZm9yICh2YXIga2V5IGluIHdhdGNoKSB7XG4gICAgdmFyIGhhbmRsZXIgPSB3YXRjaFtrZXldO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGhhbmRsZXIpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhhbmRsZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY3JlYXRlV2F0Y2hlcih2bSwga2V5LCBoYW5kbGVyW2ldKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY3JlYXRlV2F0Y2hlcih2bSwga2V5LCBoYW5kbGVyKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlV2F0Y2hlcih2bSwga2V5T3JGbiwgaGFuZGxlciwgb3B0aW9ucykge1xuICBpZiAoaXNQbGFpbk9iamVjdChoYW5kbGVyKSkge1xuICAgIG9wdGlvbnMgPSBoYW5kbGVyO1xuICAgIGhhbmRsZXIgPSBoYW5kbGVyLmhhbmRsZXI7XG4gIH1cbiAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSAnc3RyaW5nJykge1xuICAgIGhhbmRsZXIgPSB2bVtoYW5kbGVyXTtcbiAgfVxuICByZXR1cm4gdm0uJHdhdGNoKGtleU9yRm4sIGhhbmRsZXIsIG9wdGlvbnMpO1xufVxuXG5mdW5jdGlvbiBzdGF0ZU1peGluKFZ1ZSkge1xuICAvLyBmbG93IHNvbWVob3cgaGFzIHByb2JsZW1zIHdpdGggZGlyZWN0bHkgZGVjbGFyZWQgZGVmaW5pdGlvbiBvYmplY3RcbiAgLy8gd2hlbiB1c2luZyBPYmplY3QuZGVmaW5lUHJvcGVydHksIHNvIHdlIGhhdmUgdG8gcHJvY2VkdXJhbGx5IGJ1aWxkIHVwXG4gIC8vIHRoZSBvYmplY3QgaGVyZS5cbiAgdmFyIGRhdGFEZWYgPSB7fTtcbiAgZGF0YURlZi5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGE7XG4gIH07XG4gIHZhciBwcm9wc0RlZiA9IHt9O1xuICBwcm9wc0RlZi5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Byb3BzO1xuICB9O1xuICBpZiAoZmFsc2UpIHtcbiAgICBkYXRhRGVmLnNldCA9IGZ1bmN0aW9uIChuZXdEYXRhKSB7XG4gICAgICB3YXJuKCdBdm9pZCByZXBsYWNpbmcgaW5zdGFuY2Ugcm9vdCAkZGF0YS4gJyArICdVc2UgbmVzdGVkIGRhdGEgcHJvcGVydGllcyBpbnN0ZWFkLicsIHRoaXMpO1xuICAgIH07XG4gICAgcHJvcHNEZWYuc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgd2FybihcIiRwcm9wcyBpcyByZWFkb25seS5cIiwgdGhpcyk7XG4gICAgfTtcbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLnByb3RvdHlwZSwgJyRkYXRhJywgZGF0YURlZik7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUucHJvdG90eXBlLCAnJHByb3BzJywgcHJvcHNEZWYpO1xuXG4gIFZ1ZS5wcm90b3R5cGUuJHNldCA9IHNldDtcbiAgVnVlLnByb3RvdHlwZS4kZGVsZXRlID0gZGVsO1xuXG4gIFZ1ZS5wcm90b3R5cGUuJHdhdGNoID0gZnVuY3Rpb24gKGV4cE9yRm4sIGNiLCBvcHRpb25zKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBpZiAoaXNQbGFpbk9iamVjdChjYikpIHtcbiAgICAgIHJldHVybiBjcmVhdGVXYXRjaGVyKHZtLCBleHBPckZuLCBjYiwgb3B0aW9ucyk7XG4gICAgfVxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIG9wdGlvbnMudXNlciA9IHRydWU7XG4gICAgdmFyIHdhdGNoZXIgPSBuZXcgV2F0Y2hlcih2bSwgZXhwT3JGbiwgY2IsIG9wdGlvbnMpO1xuICAgIGlmIChvcHRpb25zLmltbWVkaWF0ZSkge1xuICAgICAgY2IuY2FsbCh2bSwgd2F0Y2hlci52YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbiB1bndhdGNoRm4oKSB7XG4gICAgICB3YXRjaGVyLnRlYXJkb3duKCk7XG4gICAgfTtcbiAgfTtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRQcm92aWRlKHZtKSB7XG4gIHZhciBwcm92aWRlID0gdm0uJG9wdGlvbnMucHJvdmlkZTtcbiAgaWYgKHByb3ZpZGUpIHtcbiAgICB2bS5fcHJvdmlkZWQgPSB0eXBlb2YgcHJvdmlkZSA9PT0gJ2Z1bmN0aW9uJyA/IHByb3ZpZGUuY2FsbCh2bSkgOiBwcm92aWRlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRJbmplY3Rpb25zKHZtKSB7XG4gIHZhciByZXN1bHQgPSByZXNvbHZlSW5qZWN0KHZtLiRvcHRpb25zLmluamVjdCwgdm0pO1xuICBpZiAocmVzdWx0KSB7XG4gICAgb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0ID0gZmFsc2U7XG4gICAgT2JqZWN0LmtleXMocmVzdWx0KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICBpZiAoZmFsc2UpIHtcbiAgICAgICAgZGVmaW5lUmVhY3RpdmUkJDEodm0sIGtleSwgcmVzdWx0W2tleV0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB3YXJuKFwiQXZvaWQgbXV0YXRpbmcgYW4gaW5qZWN0ZWQgdmFsdWUgZGlyZWN0bHkgc2luY2UgdGhlIGNoYW5nZXMgd2lsbCBiZSBcIiArIFwib3ZlcndyaXR0ZW4gd2hlbmV2ZXIgdGhlIHByb3ZpZGVkIGNvbXBvbmVudCByZS1yZW5kZXJzLiBcIiArIFwiaW5qZWN0aW9uIGJlaW5nIG11dGF0ZWQ6IFxcXCJcIiArIGtleSArIFwiXFxcIlwiLCB2bSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVmaW5lUmVhY3RpdmUkJDEodm0sIGtleSwgcmVzdWx0W2tleV0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIG9ic2VydmVyU3RhdGUuc2hvdWxkQ29udmVydCA9IHRydWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUluamVjdChpbmplY3QsIHZtKSB7XG4gIGlmIChpbmplY3QpIHtcbiAgICAvLyBpbmplY3QgaXMgOmFueSBiZWNhdXNlIGZsb3cgaXMgbm90IHNtYXJ0IGVub3VnaCB0byBmaWd1cmUgb3V0IGNhY2hlZFxuICAgIHZhciByZXN1bHQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHZhciBrZXlzID0gaGFzU3ltYm9sID8gUmVmbGVjdC5vd25LZXlzKGluamVjdCkuZmlsdGVyKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihpbmplY3QsIGtleSkuZW51bWVyYWJsZTtcbiAgICB9KSA6IE9iamVjdC5rZXlzKGluamVjdCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgdmFyIHByb3ZpZGVLZXkgPSBpbmplY3Rba2V5XTtcbiAgICAgIHZhciBzb3VyY2UgPSB2bTtcbiAgICAgIHdoaWxlIChzb3VyY2UpIHtcbiAgICAgICAgaWYgKHNvdXJjZS5fcHJvdmlkZWQgJiYgcHJvdmlkZUtleSBpbiBzb3VyY2UuX3Byb3ZpZGVkKSB7XG4gICAgICAgICAgcmVzdWx0W2tleV0gPSBzb3VyY2UuX3Byb3ZpZGVkW3Byb3ZpZGVLZXldO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHNvdXJjZSA9IHNvdXJjZS4kcGFyZW50O1xuICAgICAgfVxuICAgICAgaWYgKGZhbHNlKSB7XG4gICAgICAgIHdhcm4oXCJJbmplY3Rpb24gXFxcIlwiICsga2V5ICsgXCJcXFwiIG5vdCBmb3VuZFwiLCB2bSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGNyZWF0ZUZ1bmN0aW9uYWxDb21wb25lbnQoQ3RvciwgcHJvcHNEYXRhLCBkYXRhLCBjb250ZXh0LCBjaGlsZHJlbikge1xuICB2YXIgcHJvcHMgPSB7fTtcbiAgdmFyIHByb3BPcHRpb25zID0gQ3Rvci5vcHRpb25zLnByb3BzO1xuICBpZiAoaXNEZWYocHJvcE9wdGlvbnMpKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHByb3BPcHRpb25zKSB7XG4gICAgICBwcm9wc1trZXldID0gdmFsaWRhdGVQcm9wKGtleSwgcHJvcE9wdGlvbnMsIHByb3BzRGF0YSB8fCBlbXB0eU9iamVjdCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChpc0RlZihkYXRhLmF0dHJzKSkge1xuICAgICAgbWVyZ2VQcm9wcyhwcm9wcywgZGF0YS5hdHRycyk7XG4gICAgfVxuICAgIGlmIChpc0RlZihkYXRhLnByb3BzKSkge1xuICAgICAgbWVyZ2VQcm9wcyhwcm9wcywgZGF0YS5wcm9wcyk7XG4gICAgfVxuICB9XG4gIC8vIGVuc3VyZSB0aGUgY3JlYXRlRWxlbWVudCBmdW5jdGlvbiBpbiBmdW5jdGlvbmFsIGNvbXBvbmVudHNcbiAgLy8gZ2V0cyBhIHVuaXF1ZSBjb250ZXh0IC0gdGhpcyBpcyBuZWNlc3NhcnkgZm9yIGNvcnJlY3QgbmFtZWQgc2xvdCBjaGVja1xuICB2YXIgX2NvbnRleHQgPSBPYmplY3QuY3JlYXRlKGNvbnRleHQpO1xuICB2YXIgaCA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoX2NvbnRleHQsIGEsIGIsIGMsIGQsIHRydWUpO1xuICB9O1xuICB2YXIgdm5vZGUgPSBDdG9yLm9wdGlvbnMucmVuZGVyLmNhbGwobnVsbCwgaCwge1xuICAgIGRhdGE6IGRhdGEsXG4gICAgcHJvcHM6IHByb3BzLFxuICAgIGNoaWxkcmVuOiBjaGlsZHJlbixcbiAgICBwYXJlbnQ6IGNvbnRleHQsXG4gICAgbGlzdGVuZXJzOiBkYXRhLm9uIHx8IGVtcHR5T2JqZWN0LFxuICAgIGluamVjdGlvbnM6IHJlc29sdmVJbmplY3QoQ3Rvci5vcHRpb25zLmluamVjdCwgY29udGV4dCksXG4gICAgc2xvdHM6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiByZXNvbHZlU2xvdHMoY2hpbGRyZW4sIGNvbnRleHQpO1xuICAgIH1cbiAgfSk7XG4gIGlmICh2bm9kZSBpbnN0YW5jZW9mIFZOb2RlKSB7XG4gICAgdm5vZGUuZnVuY3Rpb25hbENvbnRleHQgPSBjb250ZXh0O1xuICAgIHZub2RlLmZ1bmN0aW9uYWxPcHRpb25zID0gQ3Rvci5vcHRpb25zO1xuICAgIGlmIChkYXRhLnNsb3QpIHtcbiAgICAgICh2bm9kZS5kYXRhIHx8ICh2bm9kZS5kYXRhID0ge30pKS5zbG90ID0gZGF0YS5zbG90O1xuICAgIH1cbiAgfVxuICByZXR1cm4gdm5vZGU7XG59XG5cbmZ1bmN0aW9uIG1lcmdlUHJvcHModG8sIGZyb20pIHtcbiAgZm9yICh2YXIga2V5IGluIGZyb20pIHtcbiAgICB0b1tjYW1lbGl6ZShrZXkpXSA9IGZyb21ba2V5XTtcbiAgfVxufVxuXG4vKiAgKi9cblxuLy8gaG9va3MgdG8gYmUgaW52b2tlZCBvbiBjb21wb25lbnQgVk5vZGVzIGR1cmluZyBwYXRjaFxudmFyIGNvbXBvbmVudFZOb2RlSG9va3MgPSB7XG4gIGluaXQ6IGZ1bmN0aW9uIGluaXQodm5vZGUsIGh5ZHJhdGluZywgcGFyZW50RWxtLCByZWZFbG0pIHtcbiAgICBpZiAoIXZub2RlLmNvbXBvbmVudEluc3RhbmNlIHx8IHZub2RlLmNvbXBvbmVudEluc3RhbmNlLl9pc0Rlc3Ryb3llZCkge1xuICAgICAgdmFyIGNoaWxkID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgPSBjcmVhdGVDb21wb25lbnRJbnN0YW5jZUZvclZub2RlKHZub2RlLCBhY3RpdmVJbnN0YW5jZSwgcGFyZW50RWxtLCByZWZFbG0pO1xuICAgICAgY2hpbGQuJG1vdW50KGh5ZHJhdGluZyA/IHZub2RlLmVsbSA6IHVuZGVmaW5lZCwgaHlkcmF0aW5nKTtcbiAgICB9IGVsc2UgaWYgKHZub2RlLmRhdGEua2VlcEFsaXZlKSB7XG4gICAgICAvLyBrZXB0LWFsaXZlIGNvbXBvbmVudHMsIHRyZWF0IGFzIGEgcGF0Y2hcbiAgICAgIHZhciBtb3VudGVkTm9kZSA9IHZub2RlOyAvLyB3b3JrIGFyb3VuZCBmbG93XG4gICAgICBjb21wb25lbnRWTm9kZUhvb2tzLnByZXBhdGNoKG1vdW50ZWROb2RlLCBtb3VudGVkTm9kZSk7XG4gICAgfVxuICB9LFxuXG4gIHByZXBhdGNoOiBmdW5jdGlvbiBwcmVwYXRjaChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gICAgdmFyIGNoaWxkID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgPSBvbGRWbm9kZS5jb21wb25lbnRJbnN0YW5jZTtcbiAgICB1cGRhdGVDaGlsZENvbXBvbmVudChjaGlsZCwgb3B0aW9ucy5wcm9wc0RhdGEsIC8vIHVwZGF0ZWQgcHJvcHNcbiAgICBvcHRpb25zLmxpc3RlbmVycywgLy8gdXBkYXRlZCBsaXN0ZW5lcnNcbiAgICB2bm9kZSwgLy8gbmV3IHBhcmVudCB2bm9kZVxuICAgIG9wdGlvbnMuY2hpbGRyZW4gLy8gbmV3IGNoaWxkcmVuXG4gICAgKTtcbiAgfSxcblxuICBpbnNlcnQ6IGZ1bmN0aW9uIGluc2VydCh2bm9kZSkge1xuICAgIHZhciBjb250ZXh0ID0gdm5vZGUuY29udGV4dDtcbiAgICB2YXIgY29tcG9uZW50SW5zdGFuY2UgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZTtcbiAgICBpZiAoIWNvbXBvbmVudEluc3RhbmNlLl9pc01vdW50ZWQpIHtcbiAgICAgIGNvbXBvbmVudEluc3RhbmNlLl9pc01vdW50ZWQgPSB0cnVlO1xuICAgICAgY2FsbEhvb2soY29tcG9uZW50SW5zdGFuY2UsICdtb3VudGVkJyk7XG4gICAgfVxuICAgIGlmICh2bm9kZS5kYXRhLmtlZXBBbGl2ZSkge1xuICAgICAgaWYgKGNvbnRleHQuX2lzTW91bnRlZCkge1xuICAgICAgICAvLyB2dWUtcm91dGVyIzEyMTJcbiAgICAgICAgLy8gRHVyaW5nIHVwZGF0ZXMsIGEga2VwdC1hbGl2ZSBjb21wb25lbnQncyBjaGlsZCBjb21wb25lbnRzIG1heVxuICAgICAgICAvLyBjaGFuZ2UsIHNvIGRpcmVjdGx5IHdhbGtpbmcgdGhlIHRyZWUgaGVyZSBtYXkgY2FsbCBhY3RpdmF0ZWQgaG9va3NcbiAgICAgICAgLy8gb24gaW5jb3JyZWN0IGNoaWxkcmVuLiBJbnN0ZWFkIHdlIHB1c2ggdGhlbSBpbnRvIGEgcXVldWUgd2hpY2ggd2lsbFxuICAgICAgICAvLyBiZSBwcm9jZXNzZWQgYWZ0ZXIgdGhlIHdob2xlIHBhdGNoIHByb2Nlc3MgZW5kZWQuXG4gICAgICAgIHF1ZXVlQWN0aXZhdGVkQ29tcG9uZW50KGNvbXBvbmVudEluc3RhbmNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFjdGl2YXRlQ2hpbGRDb21wb25lbnQoY29tcG9uZW50SW5zdGFuY2UsIHRydWUgLyogZGlyZWN0ICovKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSh2bm9kZSkge1xuICAgIHZhciBjb21wb25lbnRJbnN0YW5jZSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlO1xuICAgIGlmICghY29tcG9uZW50SW5zdGFuY2UuX2lzRGVzdHJveWVkKSB7XG4gICAgICBpZiAoIXZub2RlLmRhdGEua2VlcEFsaXZlKSB7XG4gICAgICAgIGNvbXBvbmVudEluc3RhbmNlLiRkZXN0cm95KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWFjdGl2YXRlQ2hpbGRDb21wb25lbnQoY29tcG9uZW50SW5zdGFuY2UsIHRydWUgLyogZGlyZWN0ICovKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbnZhciBob29rc1RvTWVyZ2UgPSBPYmplY3Qua2V5cyhjb21wb25lbnRWTm9kZUhvb2tzKTtcblxuZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50KEN0b3IsIGRhdGEsIGNvbnRleHQsIGNoaWxkcmVuLCB0YWcpIHtcbiAgaWYgKGlzVW5kZWYoQ3RvcikpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgYmFzZUN0b3IgPSBjb250ZXh0LiRvcHRpb25zLl9iYXNlO1xuXG4gIC8vIHBsYWluIG9wdGlvbnMgb2JqZWN0OiB0dXJuIGl0IGludG8gYSBjb25zdHJ1Y3RvclxuICBpZiAoaXNPYmplY3QoQ3RvcikpIHtcbiAgICBDdG9yID0gYmFzZUN0b3IuZXh0ZW5kKEN0b3IpO1xuICB9XG5cbiAgLy8gaWYgYXQgdGhpcyBzdGFnZSBpdCdzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIGFuIGFzeW5jIGNvbXBvbmVudCBmYWN0b3J5LFxuICAvLyByZWplY3QuXG4gIGlmICh0eXBlb2YgQ3RvciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIGlmIChmYWxzZSkge1xuICAgICAgd2FybihcIkludmFsaWQgQ29tcG9uZW50IGRlZmluaXRpb246IFwiICsgU3RyaW5nKEN0b3IpLCBjb250ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gYXN5bmMgY29tcG9uZW50XG4gIHZhciBhc3luY0ZhY3Rvcnk7XG4gIGlmIChpc1VuZGVmKEN0b3IuY2lkKSkge1xuICAgIGFzeW5jRmFjdG9yeSA9IEN0b3I7XG4gICAgQ3RvciA9IHJlc29sdmVBc3luY0NvbXBvbmVudChhc3luY0ZhY3RvcnksIGJhc2VDdG9yLCBjb250ZXh0KTtcbiAgICBpZiAoQ3RvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyByZXR1cm4gYSBwbGFjZWhvbGRlciBub2RlIGZvciBhc3luYyBjb21wb25lbnQsIHdoaWNoIGlzIHJlbmRlcmVkXG4gICAgICAvLyBhcyBhIGNvbW1lbnQgbm9kZSBidXQgcHJlc2VydmVzIGFsbCB0aGUgcmF3IGluZm9ybWF0aW9uIGZvciB0aGUgbm9kZS5cbiAgICAgIC8vIHRoZSBpbmZvcm1hdGlvbiB3aWxsIGJlIHVzZWQgZm9yIGFzeW5jIHNlcnZlci1yZW5kZXJpbmcgYW5kIGh5ZHJhdGlvbi5cbiAgICAgIHJldHVybiBjcmVhdGVBc3luY1BsYWNlaG9sZGVyKGFzeW5jRmFjdG9yeSwgZGF0YSwgY29udGV4dCwgY2hpbGRyZW4sIHRhZyk7XG4gICAgfVxuICB9XG5cbiAgZGF0YSA9IGRhdGEgfHwge307XG5cbiAgLy8gcmVzb2x2ZSBjb25zdHJ1Y3RvciBvcHRpb25zIGluIGNhc2UgZ2xvYmFsIG1peGlucyBhcmUgYXBwbGllZCBhZnRlclxuICAvLyBjb21wb25lbnQgY29uc3RydWN0b3IgY3JlYXRpb25cbiAgcmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyhDdG9yKTtcblxuICAvLyB0cmFuc2Zvcm0gY29tcG9uZW50IHYtbW9kZWwgZGF0YSBpbnRvIHByb3BzICYgZXZlbnRzXG4gIGlmIChpc0RlZihkYXRhLm1vZGVsKSkge1xuICAgIHRyYW5zZm9ybU1vZGVsKEN0b3Iub3B0aW9ucywgZGF0YSk7XG4gIH1cblxuICAvLyBleHRyYWN0IHByb3BzXG4gIHZhciBwcm9wc0RhdGEgPSBleHRyYWN0UHJvcHNGcm9tVk5vZGVEYXRhKGRhdGEsIEN0b3IsIHRhZyk7XG5cbiAgLy8gZnVuY3Rpb25hbCBjb21wb25lbnRcbiAgaWYgKGlzVHJ1ZShDdG9yLm9wdGlvbnMuZnVuY3Rpb25hbCkpIHtcbiAgICByZXR1cm4gY3JlYXRlRnVuY3Rpb25hbENvbXBvbmVudChDdG9yLCBwcm9wc0RhdGEsIGRhdGEsIGNvbnRleHQsIGNoaWxkcmVuKTtcbiAgfVxuXG4gIC8vIGV4dHJhY3QgbGlzdGVuZXJzLCBzaW5jZSB0aGVzZSBuZWVkcyB0byBiZSB0cmVhdGVkIGFzXG4gIC8vIGNoaWxkIGNvbXBvbmVudCBsaXN0ZW5lcnMgaW5zdGVhZCBvZiBET00gbGlzdGVuZXJzXG4gIHZhciBsaXN0ZW5lcnMgPSBkYXRhLm9uO1xuICAvLyByZXBsYWNlIHdpdGggbGlzdGVuZXJzIHdpdGggLm5hdGl2ZSBtb2RpZmllclxuICAvLyBzbyBpdCBnZXRzIHByb2Nlc3NlZCBkdXJpbmcgcGFyZW50IGNvbXBvbmVudCBwYXRjaC5cbiAgZGF0YS5vbiA9IGRhdGEubmF0aXZlT247XG5cbiAgaWYgKGlzVHJ1ZShDdG9yLm9wdGlvbnMuYWJzdHJhY3QpKSB7XG4gICAgLy8gYWJzdHJhY3QgY29tcG9uZW50cyBkbyBub3Qga2VlcCBhbnl0aGluZ1xuICAgIC8vIG90aGVyIHRoYW4gcHJvcHMgJiBsaXN0ZW5lcnMgJiBzbG90XG5cbiAgICAvLyB3b3JrIGFyb3VuZCBmbG93XG4gICAgdmFyIHNsb3QgPSBkYXRhLnNsb3Q7XG4gICAgZGF0YSA9IHt9O1xuICAgIGlmIChzbG90KSB7XG4gICAgICBkYXRhLnNsb3QgPSBzbG90O1xuICAgIH1cbiAgfVxuXG4gIC8vIG1lcmdlIGNvbXBvbmVudCBtYW5hZ2VtZW50IGhvb2tzIG9udG8gdGhlIHBsYWNlaG9sZGVyIG5vZGVcbiAgbWVyZ2VIb29rcyhkYXRhKTtcblxuICAvLyByZXR1cm4gYSBwbGFjZWhvbGRlciB2bm9kZVxuICB2YXIgbmFtZSA9IEN0b3Iub3B0aW9ucy5uYW1lIHx8IHRhZztcbiAgdmFyIHZub2RlID0gbmV3IFZOb2RlKFwidnVlLWNvbXBvbmVudC1cIiArIEN0b3IuY2lkICsgKG5hbWUgPyBcIi1cIiArIG5hbWUgOiAnJyksIGRhdGEsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGNvbnRleHQsIHsgQ3RvcjogQ3RvciwgcHJvcHNEYXRhOiBwcm9wc0RhdGEsIGxpc3RlbmVyczogbGlzdGVuZXJzLCB0YWc6IHRhZywgY2hpbGRyZW46IGNoaWxkcmVuIH0sIGFzeW5jRmFjdG9yeSk7XG4gIHJldHVybiB2bm9kZTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50SW5zdGFuY2VGb3JWbm9kZSh2bm9kZSwgLy8gd2Uga25vdyBpdCdzIE1vdW50ZWRDb21wb25lbnRWTm9kZSBidXQgZmxvdyBkb2Vzbid0XG5wYXJlbnQsIC8vIGFjdGl2ZUluc3RhbmNlIGluIGxpZmVjeWNsZSBzdGF0ZVxucGFyZW50RWxtLCByZWZFbG0pIHtcbiAgdmFyIHZub2RlQ29tcG9uZW50T3B0aW9ucyA9IHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gIHZhciBvcHRpb25zID0ge1xuICAgIF9pc0NvbXBvbmVudDogdHJ1ZSxcbiAgICBwYXJlbnQ6IHBhcmVudCxcbiAgICBwcm9wc0RhdGE6IHZub2RlQ29tcG9uZW50T3B0aW9ucy5wcm9wc0RhdGEsXG4gICAgX2NvbXBvbmVudFRhZzogdm5vZGVDb21wb25lbnRPcHRpb25zLnRhZyxcbiAgICBfcGFyZW50Vm5vZGU6IHZub2RlLFxuICAgIF9wYXJlbnRMaXN0ZW5lcnM6IHZub2RlQ29tcG9uZW50T3B0aW9ucy5saXN0ZW5lcnMsXG4gICAgX3JlbmRlckNoaWxkcmVuOiB2bm9kZUNvbXBvbmVudE9wdGlvbnMuY2hpbGRyZW4sXG4gICAgX3BhcmVudEVsbTogcGFyZW50RWxtIHx8IG51bGwsXG4gICAgX3JlZkVsbTogcmVmRWxtIHx8IG51bGxcbiAgfTtcbiAgLy8gY2hlY2sgaW5saW5lLXRlbXBsYXRlIHJlbmRlciBmdW5jdGlvbnNcbiAgdmFyIGlubGluZVRlbXBsYXRlID0gdm5vZGUuZGF0YS5pbmxpbmVUZW1wbGF0ZTtcbiAgaWYgKGlzRGVmKGlubGluZVRlbXBsYXRlKSkge1xuICAgIG9wdGlvbnMucmVuZGVyID0gaW5saW5lVGVtcGxhdGUucmVuZGVyO1xuICAgIG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zID0gaW5saW5lVGVtcGxhdGUuc3RhdGljUmVuZGVyRm5zO1xuICB9XG4gIHJldHVybiBuZXcgdm5vZGVDb21wb25lbnRPcHRpb25zLkN0b3Iob3B0aW9ucyk7XG59XG5cbmZ1bmN0aW9uIG1lcmdlSG9va3MoZGF0YSkge1xuICBpZiAoIWRhdGEuaG9vaykge1xuICAgIGRhdGEuaG9vayA9IHt9O1xuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgaG9va3NUb01lcmdlLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IGhvb2tzVG9NZXJnZVtpXTtcbiAgICB2YXIgZnJvbVBhcmVudCA9IGRhdGEuaG9va1trZXldO1xuICAgIHZhciBvdXJzID0gY29tcG9uZW50Vk5vZGVIb29rc1trZXldO1xuICAgIGRhdGEuaG9va1trZXldID0gZnJvbVBhcmVudCA/IG1lcmdlSG9vayQxKG91cnMsIGZyb21QYXJlbnQpIDogb3VycztcbiAgfVxufVxuXG5mdW5jdGlvbiBtZXJnZUhvb2skMShvbmUsIHR3bykge1xuICByZXR1cm4gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHtcbiAgICBvbmUoYSwgYiwgYywgZCk7XG4gICAgdHdvKGEsIGIsIGMsIGQpO1xuICB9O1xufVxuXG4vLyB0cmFuc2Zvcm0gY29tcG9uZW50IHYtbW9kZWwgaW5mbyAodmFsdWUgYW5kIGNhbGxiYWNrKSBpbnRvXG4vLyBwcm9wIGFuZCBldmVudCBoYW5kbGVyIHJlc3BlY3RpdmVseS5cbmZ1bmN0aW9uIHRyYW5zZm9ybU1vZGVsKG9wdGlvbnMsIGRhdGEpIHtcbiAgdmFyIHByb3AgPSBvcHRpb25zLm1vZGVsICYmIG9wdGlvbnMubW9kZWwucHJvcCB8fCAndmFsdWUnO1xuICB2YXIgZXZlbnQgPSBvcHRpb25zLm1vZGVsICYmIG9wdGlvbnMubW9kZWwuZXZlbnQgfHwgJ2lucHV0JzsoZGF0YS5wcm9wcyB8fCAoZGF0YS5wcm9wcyA9IHt9KSlbcHJvcF0gPSBkYXRhLm1vZGVsLnZhbHVlO1xuICB2YXIgb24gPSBkYXRhLm9uIHx8IChkYXRhLm9uID0ge30pO1xuICBpZiAoaXNEZWYob25bZXZlbnRdKSkge1xuICAgIG9uW2V2ZW50XSA9IFtkYXRhLm1vZGVsLmNhbGxiYWNrXS5jb25jYXQob25bZXZlbnRdKTtcbiAgfSBlbHNlIHtcbiAgICBvbltldmVudF0gPSBkYXRhLm1vZGVsLmNhbGxiYWNrO1xuICB9XG59XG5cbi8qICAqL1xuXG52YXIgU0lNUExFX05PUk1BTElaRSA9IDE7XG52YXIgQUxXQVlTX05PUk1BTElaRSA9IDI7XG5cbi8vIHdyYXBwZXIgZnVuY3Rpb24gZm9yIHByb3ZpZGluZyBhIG1vcmUgZmxleGlibGUgaW50ZXJmYWNlXG4vLyB3aXRob3V0IGdldHRpbmcgeWVsbGVkIGF0IGJ5IGZsb3dcbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQoY29udGV4dCwgdGFnLCBkYXRhLCBjaGlsZHJlbiwgbm9ybWFsaXphdGlvblR5cGUsIGFsd2F5c05vcm1hbGl6ZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSB8fCBpc1ByaW1pdGl2ZShkYXRhKSkge1xuICAgIG5vcm1hbGl6YXRpb25UeXBlID0gY2hpbGRyZW47XG4gICAgY2hpbGRyZW4gPSBkYXRhO1xuICAgIGRhdGEgPSB1bmRlZmluZWQ7XG4gIH1cbiAgaWYgKGlzVHJ1ZShhbHdheXNOb3JtYWxpemUpKSB7XG4gICAgbm9ybWFsaXphdGlvblR5cGUgPSBBTFdBWVNfTk9STUFMSVpFO1xuICB9XG4gIHJldHVybiBfY3JlYXRlRWxlbWVudChjb250ZXh0LCB0YWcsIGRhdGEsIGNoaWxkcmVuLCBub3JtYWxpemF0aW9uVHlwZSk7XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVFbGVtZW50KGNvbnRleHQsIHRhZywgZGF0YSwgY2hpbGRyZW4sIG5vcm1hbGl6YXRpb25UeXBlKSB7XG4gIGlmIChpc0RlZihkYXRhKSAmJiBpc0RlZihkYXRhLl9fb2JfXykpIHtcbiAgICBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXCJBdm9pZCB1c2luZyBvYnNlcnZlZCBkYXRhIG9iamVjdCBhcyB2bm9kZSBkYXRhOiBcIiArIEpTT04uc3RyaW5naWZ5KGRhdGEpICsgXCJcXG5cIiArICdBbHdheXMgY3JlYXRlIGZyZXNoIHZub2RlIGRhdGEgb2JqZWN0cyBpbiBlYWNoIHJlbmRlciEnLCBjb250ZXh0KTtcbiAgICByZXR1cm4gY3JlYXRlRW1wdHlWTm9kZSgpO1xuICB9XG4gIC8vIG9iamVjdCBzeW50YXggaW4gdi1iaW5kXG4gIGlmIChpc0RlZihkYXRhKSAmJiBpc0RlZihkYXRhLmlzKSkge1xuICAgIHRhZyA9IGRhdGEuaXM7XG4gIH1cbiAgaWYgKCF0YWcpIHtcbiAgICAvLyBpbiBjYXNlIG9mIGNvbXBvbmVudCA6aXMgc2V0IHRvIGZhbHN5IHZhbHVlXG4gICAgcmV0dXJuIGNyZWF0ZUVtcHR5Vk5vZGUoKTtcbiAgfVxuICAvLyB3YXJuIGFnYWluc3Qgbm9uLXByaW1pdGl2ZSBrZXlcbiAgaWYgKGZhbHNlKSB7XG4gICAgd2FybignQXZvaWQgdXNpbmcgbm9uLXByaW1pdGl2ZSB2YWx1ZSBhcyBrZXksICcgKyAndXNlIHN0cmluZy9udW1iZXIgdmFsdWUgaW5zdGVhZC4nLCBjb250ZXh0KTtcbiAgfVxuICAvLyBzdXBwb3J0IHNpbmdsZSBmdW5jdGlvbiBjaGlsZHJlbiBhcyBkZWZhdWx0IHNjb3BlZCBzbG90XG4gIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSAmJiB0eXBlb2YgY2hpbGRyZW5bMF0gPT09ICdmdW5jdGlvbicpIHtcbiAgICBkYXRhID0gZGF0YSB8fCB7fTtcbiAgICBkYXRhLnNjb3BlZFNsb3RzID0geyBkZWZhdWx0OiBjaGlsZHJlblswXSB9O1xuICAgIGNoaWxkcmVuLmxlbmd0aCA9IDA7XG4gIH1cbiAgaWYgKG5vcm1hbGl6YXRpb25UeXBlID09PSBBTFdBWVNfTk9STUFMSVpFKSB7XG4gICAgY2hpbGRyZW4gPSBub3JtYWxpemVDaGlsZHJlbihjaGlsZHJlbik7XG4gIH0gZWxzZSBpZiAobm9ybWFsaXphdGlvblR5cGUgPT09IFNJTVBMRV9OT1JNQUxJWkUpIHtcbiAgICBjaGlsZHJlbiA9IHNpbXBsZU5vcm1hbGl6ZUNoaWxkcmVuKGNoaWxkcmVuKTtcbiAgfVxuICB2YXIgdm5vZGUsIG5zO1xuICBpZiAodHlwZW9mIHRhZyA9PT0gJ3N0cmluZycpIHtcbiAgICB2YXIgQ3RvcjtcbiAgICBucyA9IGNvbnRleHQuJHZub2RlICYmIGNvbnRleHQuJHZub2RlLm5zIHx8IGNvbmZpZy5nZXRUYWdOYW1lc3BhY2UodGFnKTtcbiAgICBpZiAoY29uZmlnLmlzUmVzZXJ2ZWRUYWcodGFnKSkge1xuICAgICAgLy8gcGxhdGZvcm0gYnVpbHQtaW4gZWxlbWVudHNcbiAgICAgIHZub2RlID0gbmV3IFZOb2RlKGNvbmZpZy5wYXJzZVBsYXRmb3JtVGFnTmFtZSh0YWcpLCBkYXRhLCBjaGlsZHJlbiwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGNvbnRleHQpO1xuICAgIH0gZWxzZSBpZiAoaXNEZWYoQ3RvciA9IHJlc29sdmVBc3NldChjb250ZXh0LiRvcHRpb25zLCAnY29tcG9uZW50cycsIHRhZykpKSB7XG4gICAgICAvLyBjb21wb25lbnRcbiAgICAgIHZub2RlID0gY3JlYXRlQ29tcG9uZW50KEN0b3IsIGRhdGEsIGNvbnRleHQsIGNoaWxkcmVuLCB0YWcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB1bmtub3duIG9yIHVubGlzdGVkIG5hbWVzcGFjZWQgZWxlbWVudHNcbiAgICAgIC8vIGNoZWNrIGF0IHJ1bnRpbWUgYmVjYXVzZSBpdCBtYXkgZ2V0IGFzc2lnbmVkIGEgbmFtZXNwYWNlIHdoZW4gaXRzXG4gICAgICAvLyBwYXJlbnQgbm9ybWFsaXplcyBjaGlsZHJlblxuICAgICAgdm5vZGUgPSBuZXcgVk5vZGUodGFnLCBkYXRhLCBjaGlsZHJlbiwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGNvbnRleHQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBkaXJlY3QgY29tcG9uZW50IG9wdGlvbnMgLyBjb25zdHJ1Y3RvclxuICAgIHZub2RlID0gY3JlYXRlQ29tcG9uZW50KHRhZywgZGF0YSwgY29udGV4dCwgY2hpbGRyZW4pO1xuICB9XG4gIGlmIChpc0RlZih2bm9kZSkpIHtcbiAgICBpZiAobnMpIHtcbiAgICAgIGFwcGx5TlModm5vZGUsIG5zKTtcbiAgICB9XG4gICAgcmV0dXJuIHZub2RlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBjcmVhdGVFbXB0eVZOb2RlKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYXBwbHlOUyh2bm9kZSwgbnMpIHtcbiAgdm5vZGUubnMgPSBucztcbiAgaWYgKHZub2RlLnRhZyA9PT0gJ2ZvcmVpZ25PYmplY3QnKSB7XG4gICAgLy8gdXNlIGRlZmF1bHQgbmFtZXNwYWNlIGluc2lkZSBmb3JlaWduT2JqZWN0XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChpc0RlZih2bm9kZS5jaGlsZHJlbikpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHZub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGNoaWxkID0gdm5vZGUuY2hpbGRyZW5baV07XG4gICAgICBpZiAoaXNEZWYoY2hpbGQudGFnKSAmJiBpc1VuZGVmKGNoaWxkLm5zKSkge1xuICAgICAgICBhcHBseU5TKGNoaWxkLCBucyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZW5kZXJpbmcgdi1mb3IgbGlzdHMuXG4gKi9cbmZ1bmN0aW9uIHJlbmRlckxpc3QodmFsLCByZW5kZXIpIHtcbiAgdmFyIHJldCwgaSwgbCwga2V5cywga2V5O1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpIHx8IHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0ID0gbmV3IEFycmF5KHZhbC5sZW5ndGgpO1xuICAgIGZvciAoaSA9IDAsIGwgPSB2YWwubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICByZXRbaV0gPSByZW5kZXIodmFsW2ldLCBpKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICByZXQgPSBuZXcgQXJyYXkodmFsKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgdmFsOyBpKyspIHtcbiAgICAgIHJldFtpXSA9IHJlbmRlcihpICsgMSwgaSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KHZhbCkpIHtcbiAgICBrZXlzID0gT2JqZWN0LmtleXModmFsKTtcbiAgICByZXQgPSBuZXcgQXJyYXkoa2V5cy5sZW5ndGgpO1xuICAgIGZvciAoaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgIHJldFtpXSA9IHJlbmRlcih2YWxba2V5XSwga2V5LCBpKTtcbiAgICB9XG4gIH1cbiAgaWYgKGlzRGVmKHJldCkpIHtcbiAgICByZXQuX2lzVkxpc3QgPSB0cnVlO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZW5kZXJpbmcgPHNsb3Q+XG4gKi9cbmZ1bmN0aW9uIHJlbmRlclNsb3QobmFtZSwgZmFsbGJhY2ssIHByb3BzLCBiaW5kT2JqZWN0KSB7XG4gIHZhciBzY29wZWRTbG90Rm4gPSB0aGlzLiRzY29wZWRTbG90c1tuYW1lXTtcbiAgaWYgKHNjb3BlZFNsb3RGbikge1xuICAgIC8vIHNjb3BlZCBzbG90XG4gICAgcHJvcHMgPSBwcm9wcyB8fCB7fTtcbiAgICBpZiAoYmluZE9iamVjdCkge1xuICAgICAgcHJvcHMgPSBleHRlbmQoZXh0ZW5kKHt9LCBiaW5kT2JqZWN0KSwgcHJvcHMpO1xuICAgIH1cbiAgICByZXR1cm4gc2NvcGVkU2xvdEZuKHByb3BzKSB8fCBmYWxsYmFjaztcbiAgfSBlbHNlIHtcbiAgICB2YXIgc2xvdE5vZGVzID0gdGhpcy4kc2xvdHNbbmFtZV07XG4gICAgLy8gd2FybiBkdXBsaWNhdGUgc2xvdCB1c2FnZVxuICAgIGlmIChzbG90Tm9kZXMgJiYgXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgc2xvdE5vZGVzLl9yZW5kZXJlZCAmJiB3YXJuKFwiRHVwbGljYXRlIHByZXNlbmNlIG9mIHNsb3QgXFxcIlwiICsgbmFtZSArIFwiXFxcIiBmb3VuZCBpbiB0aGUgc2FtZSByZW5kZXIgdHJlZSBcIiArIFwiLSB0aGlzIHdpbGwgbGlrZWx5IGNhdXNlIHJlbmRlciBlcnJvcnMuXCIsIHRoaXMpO1xuICAgICAgc2xvdE5vZGVzLl9yZW5kZXJlZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBzbG90Tm9kZXMgfHwgZmFsbGJhY2s7XG4gIH1cbn1cblxuLyogICovXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHJlc29sdmluZyBmaWx0ZXJzXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVGaWx0ZXIoaWQpIHtcbiAgcmV0dXJuIHJlc29sdmVBc3NldCh0aGlzLiRvcHRpb25zLCAnZmlsdGVycycsIGlkLCB0cnVlKSB8fCBpZGVudGl0eTtcbn1cblxuLyogICovXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIGNoZWNraW5nIGtleUNvZGVzIGZyb20gY29uZmlnLlxuICovXG5mdW5jdGlvbiBjaGVja0tleUNvZGVzKGV2ZW50S2V5Q29kZSwga2V5LCBidWlsdEluQWxpYXMpIHtcbiAgdmFyIGtleUNvZGVzID0gY29uZmlnLmtleUNvZGVzW2tleV0gfHwgYnVpbHRJbkFsaWFzO1xuICBpZiAoQXJyYXkuaXNBcnJheShrZXlDb2RlcykpIHtcbiAgICByZXR1cm4ga2V5Q29kZXMuaW5kZXhPZihldmVudEtleUNvZGUpID09PSAtMTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4ga2V5Q29kZXMgIT09IGV2ZW50S2V5Q29kZTtcbiAgfVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgbWVyZ2luZyB2LWJpbmQ9XCJvYmplY3RcIiBpbnRvIGEgVk5vZGUncyBkYXRhLlxuICovXG5mdW5jdGlvbiBiaW5kT2JqZWN0UHJvcHMoZGF0YSwgdGFnLCB2YWx1ZSwgYXNQcm9wLCBpc1N5bmMpIHtcbiAgaWYgKHZhbHVlKSB7XG4gICAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgIFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgJiYgd2Fybigndi1iaW5kIHdpdGhvdXQgYXJndW1lbnQgZXhwZWN0cyBhbiBPYmplY3Qgb3IgQXJyYXkgdmFsdWUnLCB0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlID0gdG9PYmplY3QodmFsdWUpO1xuICAgICAgfVxuICAgICAgdmFyIGhhc2g7XG4gICAgICB2YXIgbG9vcCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgaWYgKGtleSA9PT0gJ2NsYXNzJyB8fCBrZXkgPT09ICdzdHlsZScgfHwgaXNSZXNlcnZlZEF0dHJpYnV0ZShrZXkpKSB7XG4gICAgICAgICAgaGFzaCA9IGRhdGE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHR5cGUgPSBkYXRhLmF0dHJzICYmIGRhdGEuYXR0cnMudHlwZTtcbiAgICAgICAgICBoYXNoID0gYXNQcm9wIHx8IGNvbmZpZy5tdXN0VXNlUHJvcCh0YWcsIHR5cGUsIGtleSkgPyBkYXRhLmRvbVByb3BzIHx8IChkYXRhLmRvbVByb3BzID0ge30pIDogZGF0YS5hdHRycyB8fCAoZGF0YS5hdHRycyA9IHt9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShrZXkgaW4gaGFzaCkpIHtcbiAgICAgICAgICBoYXNoW2tleV0gPSB2YWx1ZVtrZXldO1xuXG4gICAgICAgICAgaWYgKGlzU3luYykge1xuICAgICAgICAgICAgdmFyIG9uID0gZGF0YS5vbiB8fCAoZGF0YS5vbiA9IHt9KTtcbiAgICAgICAgICAgIG9uW1widXBkYXRlOlwiICsga2V5XSA9IGZ1bmN0aW9uICgkZXZlbnQpIHtcbiAgICAgICAgICAgICAgdmFsdWVba2V5XSA9ICRldmVudDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIGxvb3Aoa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZW5kZXJpbmcgc3RhdGljIHRyZWVzLlxuICovXG5mdW5jdGlvbiByZW5kZXJTdGF0aWMoaW5kZXgsIGlzSW5Gb3IpIHtcbiAgdmFyIHRyZWUgPSB0aGlzLl9zdGF0aWNUcmVlc1tpbmRleF07XG4gIC8vIGlmIGhhcyBhbHJlYWR5LXJlbmRlcmVkIHN0YXRpYyB0cmVlIGFuZCBub3QgaW5zaWRlIHYtZm9yLFxuICAvLyB3ZSBjYW4gcmV1c2UgdGhlIHNhbWUgdHJlZSBieSBkb2luZyBhIHNoYWxsb3cgY2xvbmUuXG4gIGlmICh0cmVlICYmICFpc0luRm9yKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodHJlZSkgPyBjbG9uZVZOb2Rlcyh0cmVlKSA6IGNsb25lVk5vZGUodHJlZSk7XG4gIH1cbiAgLy8gb3RoZXJ3aXNlLCByZW5kZXIgYSBmcmVzaCB0cmVlLlxuICB0cmVlID0gdGhpcy5fc3RhdGljVHJlZXNbaW5kZXhdID0gdGhpcy4kb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnNbaW5kZXhdLmNhbGwodGhpcy5fcmVuZGVyUHJveHkpO1xuICBtYXJrU3RhdGljKHRyZWUsIFwiX19zdGF0aWNfX1wiICsgaW5kZXgsIGZhbHNlKTtcbiAgcmV0dXJuIHRyZWU7XG59XG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHYtb25jZS5cbiAqIEVmZmVjdGl2ZWx5IGl0IG1lYW5zIG1hcmtpbmcgdGhlIG5vZGUgYXMgc3RhdGljIHdpdGggYSB1bmlxdWUga2V5LlxuICovXG5mdW5jdGlvbiBtYXJrT25jZSh0cmVlLCBpbmRleCwga2V5KSB7XG4gIG1hcmtTdGF0aWModHJlZSwgXCJfX29uY2VfX1wiICsgaW5kZXggKyAoa2V5ID8gXCJfXCIgKyBrZXkgOiBcIlwiKSwgdHJ1ZSk7XG4gIHJldHVybiB0cmVlO1xufVxuXG5mdW5jdGlvbiBtYXJrU3RhdGljKHRyZWUsIGtleSwgaXNPbmNlKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHRyZWUpKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodHJlZVtpXSAmJiB0eXBlb2YgdHJlZVtpXSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgbWFya1N0YXRpY05vZGUodHJlZVtpXSwga2V5ICsgXCJfXCIgKyBpLCBpc09uY2UpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBtYXJrU3RhdGljTm9kZSh0cmVlLCBrZXksIGlzT25jZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFya1N0YXRpY05vZGUobm9kZSwga2V5LCBpc09uY2UpIHtcbiAgbm9kZS5pc1N0YXRpYyA9IHRydWU7XG4gIG5vZGUua2V5ID0ga2V5O1xuICBub2RlLmlzT25jZSA9IGlzT25jZTtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGJpbmRPYmplY3RMaXN0ZW5lcnMoZGF0YSwgdmFsdWUpIHtcbiAgaWYgKHZhbHVlKSB7XG4gICAgaWYgKCFpc1BsYWluT2JqZWN0KHZhbHVlKSkge1xuICAgICAgXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKCd2LW9uIHdpdGhvdXQgYXJndW1lbnQgZXhwZWN0cyBhbiBPYmplY3QgdmFsdWUnLCB0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG9uID0gZGF0YS5vbiA9IGRhdGEub24gPyBleHRlbmQoe30sIGRhdGEub24pIDoge307XG4gICAgICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICAgICAgdmFyIGV4aXN0aW5nID0gb25ba2V5XTtcbiAgICAgICAgdmFyIG91cnMgPSB2YWx1ZVtrZXldO1xuICAgICAgICBvbltrZXldID0gZXhpc3RpbmcgPyBbXS5jb25jYXQob3VycywgZXhpc3RpbmcpIDogb3VycztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0UmVuZGVyKHZtKSB7XG4gIHZtLl92bm9kZSA9IG51bGw7IC8vIHRoZSByb290IG9mIHRoZSBjaGlsZCB0cmVlXG4gIHZtLl9zdGF0aWNUcmVlcyA9IG51bGw7XG4gIHZhciBwYXJlbnRWbm9kZSA9IHZtLiR2bm9kZSA9IHZtLiRvcHRpb25zLl9wYXJlbnRWbm9kZTsgLy8gdGhlIHBsYWNlaG9sZGVyIG5vZGUgaW4gcGFyZW50IHRyZWVcbiAgdmFyIHJlbmRlckNvbnRleHQgPSBwYXJlbnRWbm9kZSAmJiBwYXJlbnRWbm9kZS5jb250ZXh0O1xuICB2bS4kc2xvdHMgPSByZXNvbHZlU2xvdHModm0uJG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuLCByZW5kZXJDb250ZXh0KTtcbiAgdm0uJHNjb3BlZFNsb3RzID0gZW1wdHlPYmplY3Q7XG4gIC8vIGJpbmQgdGhlIGNyZWF0ZUVsZW1lbnQgZm4gdG8gdGhpcyBpbnN0YW5jZVxuICAvLyBzbyB0aGF0IHdlIGdldCBwcm9wZXIgcmVuZGVyIGNvbnRleHQgaW5zaWRlIGl0LlxuICAvLyBhcmdzIG9yZGVyOiB0YWcsIGRhdGEsIGNoaWxkcmVuLCBub3JtYWxpemF0aW9uVHlwZSwgYWx3YXlzTm9ybWFsaXplXG4gIC8vIGludGVybmFsIHZlcnNpb24gaXMgdXNlZCBieSByZW5kZXIgZnVuY3Rpb25zIGNvbXBpbGVkIGZyb20gdGVtcGxhdGVzXG4gIHZtLl9jID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHtcbiAgICByZXR1cm4gY3JlYXRlRWxlbWVudCh2bSwgYSwgYiwgYywgZCwgZmFsc2UpO1xuICB9O1xuICAvLyBub3JtYWxpemF0aW9uIGlzIGFsd2F5cyBhcHBsaWVkIGZvciB0aGUgcHVibGljIHZlcnNpb24sIHVzZWQgaW5cbiAgLy8gdXNlci13cml0dGVuIHJlbmRlciBmdW5jdGlvbnMuXG4gIHZtLiRjcmVhdGVFbGVtZW50ID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHtcbiAgICByZXR1cm4gY3JlYXRlRWxlbWVudCh2bSwgYSwgYiwgYywgZCwgdHJ1ZSk7XG4gIH07XG5cbiAgLy8gJGF0dHJzICYgJGxpc3RlbmVycyBhcmUgZXhwb3NlZCBmb3IgZWFzaWVyIEhPQyBjcmVhdGlvbi5cbiAgLy8gdGhleSBuZWVkIHRvIGJlIHJlYWN0aXZlIHNvIHRoYXQgSE9DcyB1c2luZyB0aGVtIGFyZSBhbHdheXMgdXBkYXRlZFxuICB2YXIgcGFyZW50RGF0YSA9IHBhcmVudFZub2RlICYmIHBhcmVudFZub2RlLmRhdGE7XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKGZhbHNlKSB7XG4gICAgZGVmaW5lUmVhY3RpdmUkJDEodm0sICckYXR0cnMnLCBwYXJlbnREYXRhICYmIHBhcmVudERhdGEuYXR0cnMgfHwgZW1wdHlPYmplY3QsIGZ1bmN0aW9uICgpIHtcbiAgICAgICFpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQgJiYgd2FybihcIiRhdHRycyBpcyByZWFkb25seS5cIiwgdm0pO1xuICAgIH0sIHRydWUpO1xuICAgIGRlZmluZVJlYWN0aXZlJCQxKHZtLCAnJGxpc3RlbmVycycsIHZtLiRvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnMgfHwgZW1wdHlPYmplY3QsIGZ1bmN0aW9uICgpIHtcbiAgICAgICFpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQgJiYgd2FybihcIiRsaXN0ZW5lcnMgaXMgcmVhZG9ubHkuXCIsIHZtKTtcbiAgICB9LCB0cnVlKTtcbiAgfSBlbHNlIHtcbiAgICBkZWZpbmVSZWFjdGl2ZSQkMSh2bSwgJyRhdHRycycsIHBhcmVudERhdGEgJiYgcGFyZW50RGF0YS5hdHRycyB8fCBlbXB0eU9iamVjdCwgbnVsbCwgdHJ1ZSk7XG4gICAgZGVmaW5lUmVhY3RpdmUkJDEodm0sICckbGlzdGVuZXJzJywgdm0uJG9wdGlvbnMuX3BhcmVudExpc3RlbmVycyB8fCBlbXB0eU9iamVjdCwgbnVsbCwgdHJ1ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVuZGVyTWl4aW4oVnVlKSB7XG4gIFZ1ZS5wcm90b3R5cGUuJG5leHRUaWNrID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgcmV0dXJuIG5leHRUaWNrKGZuLCB0aGlzKTtcbiAgfTtcblxuICBWdWUucHJvdG90eXBlLl9yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICB2YXIgcmVmID0gdm0uJG9wdGlvbnM7XG4gICAgdmFyIHJlbmRlciA9IHJlZi5yZW5kZXI7XG4gICAgdmFyIHN0YXRpY1JlbmRlckZucyA9IHJlZi5zdGF0aWNSZW5kZXJGbnM7XG4gICAgdmFyIF9wYXJlbnRWbm9kZSA9IHJlZi5fcGFyZW50Vm5vZGU7XG5cbiAgICBpZiAodm0uX2lzTW91bnRlZCkge1xuICAgICAgLy8gaWYgdGhlIHBhcmVudCBkaWRuJ3QgdXBkYXRlLCB0aGUgc2xvdCBub2RlcyB3aWxsIGJlIHRoZSBvbmVzIGZyb21cbiAgICAgIC8vIGxhc3QgcmVuZGVyLiBUaGV5IG5lZWQgdG8gYmUgY2xvbmVkIHRvIGVuc3VyZSBcImZyZXNobmVzc1wiIGZvciB0aGlzIHJlbmRlci5cbiAgICAgIGZvciAodmFyIGtleSBpbiB2bS4kc2xvdHMpIHtcbiAgICAgICAgdmFyIHNsb3QgPSB2bS4kc2xvdHNba2V5XTtcbiAgICAgICAgaWYgKHNsb3QuX3JlbmRlcmVkKSB7XG4gICAgICAgICAgdm0uJHNsb3RzW2tleV0gPSBjbG9uZVZOb2RlcyhzbG90LCB0cnVlIC8qIGRlZXAgKi8pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdm0uJHNjb3BlZFNsb3RzID0gX3BhcmVudFZub2RlICYmIF9wYXJlbnRWbm9kZS5kYXRhLnNjb3BlZFNsb3RzIHx8IGVtcHR5T2JqZWN0O1xuXG4gICAgaWYgKHN0YXRpY1JlbmRlckZucyAmJiAhdm0uX3N0YXRpY1RyZWVzKSB7XG4gICAgICB2bS5fc3RhdGljVHJlZXMgPSBbXTtcbiAgICB9XG4gICAgLy8gc2V0IHBhcmVudCB2bm9kZS4gdGhpcyBhbGxvd3MgcmVuZGVyIGZ1bmN0aW9ucyB0byBoYXZlIGFjY2Vzc1xuICAgIC8vIHRvIHRoZSBkYXRhIG9uIHRoZSBwbGFjZWhvbGRlciBub2RlLlxuICAgIHZtLiR2bm9kZSA9IF9wYXJlbnRWbm9kZTtcbiAgICAvLyByZW5kZXIgc2VsZlxuICAgIHZhciB2bm9kZTtcbiAgICB0cnkge1xuICAgICAgdm5vZGUgPSByZW5kZXIuY2FsbCh2bS5fcmVuZGVyUHJveHksIHZtLiRjcmVhdGVFbGVtZW50KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBoYW5kbGVFcnJvcihlLCB2bSwgXCJyZW5kZXIgZnVuY3Rpb25cIik7XG4gICAgICAvLyByZXR1cm4gZXJyb3IgcmVuZGVyIHJlc3VsdCxcbiAgICAgIC8vIG9yIHByZXZpb3VzIHZub2RlIHRvIHByZXZlbnQgcmVuZGVyIGVycm9yIGNhdXNpbmcgYmxhbmsgY29tcG9uZW50XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgaWYgKGZhbHNlKSB7XG4gICAgICAgIHZub2RlID0gdm0uJG9wdGlvbnMucmVuZGVyRXJyb3IgPyB2bS4kb3B0aW9ucy5yZW5kZXJFcnJvci5jYWxsKHZtLl9yZW5kZXJQcm94eSwgdm0uJGNyZWF0ZUVsZW1lbnQsIGUpIDogdm0uX3Zub2RlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdm5vZGUgPSB2bS5fdm5vZGU7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIHJldHVybiBlbXB0eSB2bm9kZSBpbiBjYXNlIHRoZSByZW5kZXIgZnVuY3Rpb24gZXJyb3JlZCBvdXRcbiAgICBpZiAoISh2bm9kZSBpbnN0YW5jZW9mIFZOb2RlKSkge1xuICAgICAgaWYgKGZhbHNlKSB7XG4gICAgICAgIHdhcm4oJ011bHRpcGxlIHJvb3Qgbm9kZXMgcmV0dXJuZWQgZnJvbSByZW5kZXIgZnVuY3Rpb24uIFJlbmRlciBmdW5jdGlvbiAnICsgJ3Nob3VsZCByZXR1cm4gYSBzaW5nbGUgcm9vdCBub2RlLicsIHZtKTtcbiAgICAgIH1cbiAgICAgIHZub2RlID0gY3JlYXRlRW1wdHlWTm9kZSgpO1xuICAgIH1cbiAgICAvLyBzZXQgcGFyZW50XG4gICAgdm5vZGUucGFyZW50ID0gX3BhcmVudFZub2RlO1xuICAgIHJldHVybiB2bm9kZTtcbiAgfTtcblxuICAvLyBpbnRlcm5hbCByZW5kZXIgaGVscGVycy5cbiAgLy8gdGhlc2UgYXJlIGV4cG9zZWQgb24gdGhlIGluc3RhbmNlIHByb3RvdHlwZSB0byByZWR1Y2UgZ2VuZXJhdGVkIHJlbmRlclxuICAvLyBjb2RlIHNpemUuXG4gIFZ1ZS5wcm90b3R5cGUuX28gPSBtYXJrT25jZTtcbiAgVnVlLnByb3RvdHlwZS5fbiA9IHRvTnVtYmVyO1xuICBWdWUucHJvdG90eXBlLl9zID0gdG9TdHJpbmc7XG4gIFZ1ZS5wcm90b3R5cGUuX2wgPSByZW5kZXJMaXN0O1xuICBWdWUucHJvdG90eXBlLl90ID0gcmVuZGVyU2xvdDtcbiAgVnVlLnByb3RvdHlwZS5fcSA9IGxvb3NlRXF1YWw7XG4gIFZ1ZS5wcm90b3R5cGUuX2kgPSBsb29zZUluZGV4T2Y7XG4gIFZ1ZS5wcm90b3R5cGUuX20gPSByZW5kZXJTdGF0aWM7XG4gIFZ1ZS5wcm90b3R5cGUuX2YgPSByZXNvbHZlRmlsdGVyO1xuICBWdWUucHJvdG90eXBlLl9rID0gY2hlY2tLZXlDb2RlcztcbiAgVnVlLnByb3RvdHlwZS5fYiA9IGJpbmRPYmplY3RQcm9wcztcbiAgVnVlLnByb3RvdHlwZS5fdiA9IGNyZWF0ZVRleHRWTm9kZTtcbiAgVnVlLnByb3RvdHlwZS5fZSA9IGNyZWF0ZUVtcHR5Vk5vZGU7XG4gIFZ1ZS5wcm90b3R5cGUuX3UgPSByZXNvbHZlU2NvcGVkU2xvdHM7XG4gIFZ1ZS5wcm90b3R5cGUuX2cgPSBiaW5kT2JqZWN0TGlzdGVuZXJzO1xufVxuXG4vKiAgKi9cblxudmFyIHVpZCQxID0gMDtcblxuZnVuY3Rpb24gaW5pdE1peGluKFZ1ZSkge1xuICBWdWUucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIC8vIGEgdWlkXG4gICAgdm0uX3VpZCA9IHVpZCQxKys7XG5cbiAgICB2YXIgc3RhcnRUYWcsIGVuZFRhZztcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoZmFsc2UpIHtcbiAgICAgIHN0YXJ0VGFnID0gXCJ2dWUtcGVyZi1pbml0OlwiICsgdm0uX3VpZDtcbiAgICAgIGVuZFRhZyA9IFwidnVlLXBlcmYtZW5kOlwiICsgdm0uX3VpZDtcbiAgICAgIG1hcmsoc3RhcnRUYWcpO1xuICAgIH1cblxuICAgIC8vIGEgZmxhZyB0byBhdm9pZCB0aGlzIGJlaW5nIG9ic2VydmVkXG4gICAgdm0uX2lzVnVlID0gdHJ1ZTtcbiAgICAvLyBtZXJnZSBvcHRpb25zXG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5faXNDb21wb25lbnQpIHtcbiAgICAgIC8vIG9wdGltaXplIGludGVybmFsIGNvbXBvbmVudCBpbnN0YW50aWF0aW9uXG4gICAgICAvLyBzaW5jZSBkeW5hbWljIG9wdGlvbnMgbWVyZ2luZyBpcyBwcmV0dHkgc2xvdywgYW5kIG5vbmUgb2YgdGhlXG4gICAgICAvLyBpbnRlcm5hbCBjb21wb25lbnQgb3B0aW9ucyBuZWVkcyBzcGVjaWFsIHRyZWF0bWVudC5cbiAgICAgIGluaXRJbnRlcm5hbENvbXBvbmVudCh2bSwgb3B0aW9ucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZtLiRvcHRpb25zID0gbWVyZ2VPcHRpb25zKHJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnModm0uY29uc3RydWN0b3IpLCBvcHRpb25zIHx8IHt9LCB2bSk7XG4gICAgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKGZhbHNlKSB7XG4gICAgICBpbml0UHJveHkodm0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2bS5fcmVuZGVyUHJveHkgPSB2bTtcbiAgICB9XG4gICAgLy8gZXhwb3NlIHJlYWwgc2VsZlxuICAgIHZtLl9zZWxmID0gdm07XG4gICAgaW5pdExpZmVjeWNsZSh2bSk7XG4gICAgaW5pdEV2ZW50cyh2bSk7XG4gICAgaW5pdFJlbmRlcih2bSk7XG4gICAgY2FsbEhvb2sodm0sICdiZWZvcmVDcmVhdGUnKTtcbiAgICBpbml0SW5qZWN0aW9ucyh2bSk7IC8vIHJlc29sdmUgaW5qZWN0aW9ucyBiZWZvcmUgZGF0YS9wcm9wc1xuICAgIGluaXRTdGF0ZSh2bSk7XG4gICAgaW5pdFByb3ZpZGUodm0pOyAvLyByZXNvbHZlIHByb3ZpZGUgYWZ0ZXIgZGF0YS9wcm9wc1xuICAgIGNhbGxIb29rKHZtLCAnY3JlYXRlZCcpO1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGZhbHNlKSB7XG4gICAgICB2bS5fbmFtZSA9IGZvcm1hdENvbXBvbmVudE5hbWUodm0sIGZhbHNlKTtcbiAgICAgIG1hcmsoZW5kVGFnKTtcbiAgICAgIG1lYXN1cmUodm0uX25hbWUgKyBcIiBpbml0XCIsIHN0YXJ0VGFnLCBlbmRUYWcpO1xuICAgIH1cblxuICAgIGlmICh2bS4kb3B0aW9ucy5lbCkge1xuICAgICAgdm0uJG1vdW50KHZtLiRvcHRpb25zLmVsKTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGluaXRJbnRlcm5hbENvbXBvbmVudCh2bSwgb3B0aW9ucykge1xuICB2YXIgb3B0cyA9IHZtLiRvcHRpb25zID0gT2JqZWN0LmNyZWF0ZSh2bS5jb25zdHJ1Y3Rvci5vcHRpb25zKTtcbiAgLy8gZG9pbmcgdGhpcyBiZWNhdXNlIGl0J3MgZmFzdGVyIHRoYW4gZHluYW1pYyBlbnVtZXJhdGlvbi5cbiAgb3B0cy5wYXJlbnQgPSBvcHRpb25zLnBhcmVudDtcbiAgb3B0cy5wcm9wc0RhdGEgPSBvcHRpb25zLnByb3BzRGF0YTtcbiAgb3B0cy5fcGFyZW50Vm5vZGUgPSBvcHRpb25zLl9wYXJlbnRWbm9kZTtcbiAgb3B0cy5fcGFyZW50TGlzdGVuZXJzID0gb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzO1xuICBvcHRzLl9yZW5kZXJDaGlsZHJlbiA9IG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuO1xuICBvcHRzLl9jb21wb25lbnRUYWcgPSBvcHRpb25zLl9jb21wb25lbnRUYWc7XG4gIG9wdHMuX3BhcmVudEVsbSA9IG9wdGlvbnMuX3BhcmVudEVsbTtcbiAgb3B0cy5fcmVmRWxtID0gb3B0aW9ucy5fcmVmRWxtO1xuICBpZiAob3B0aW9ucy5yZW5kZXIpIHtcbiAgICBvcHRzLnJlbmRlciA9IG9wdGlvbnMucmVuZGVyO1xuICAgIG9wdHMuc3RhdGljUmVuZGVyRm5zID0gb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnM7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyhDdG9yKSB7XG4gIHZhciBvcHRpb25zID0gQ3Rvci5vcHRpb25zO1xuICBpZiAoQ3Rvci5zdXBlcikge1xuICAgIHZhciBzdXBlck9wdGlvbnMgPSByZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zKEN0b3Iuc3VwZXIpO1xuICAgIHZhciBjYWNoZWRTdXBlck9wdGlvbnMgPSBDdG9yLnN1cGVyT3B0aW9ucztcbiAgICBpZiAoc3VwZXJPcHRpb25zICE9PSBjYWNoZWRTdXBlck9wdGlvbnMpIHtcbiAgICAgIC8vIHN1cGVyIG9wdGlvbiBjaGFuZ2VkLFxuICAgICAgLy8gbmVlZCB0byByZXNvbHZlIG5ldyBvcHRpb25zLlxuICAgICAgQ3Rvci5zdXBlck9wdGlvbnMgPSBzdXBlck9wdGlvbnM7XG4gICAgICAvLyBjaGVjayBpZiB0aGVyZSBhcmUgYW55IGxhdGUtbW9kaWZpZWQvYXR0YWNoZWQgb3B0aW9ucyAoIzQ5NzYpXG4gICAgICB2YXIgbW9kaWZpZWRPcHRpb25zID0gcmVzb2x2ZU1vZGlmaWVkT3B0aW9ucyhDdG9yKTtcbiAgICAgIC8vIHVwZGF0ZSBiYXNlIGV4dGVuZCBvcHRpb25zXG4gICAgICBpZiAobW9kaWZpZWRPcHRpb25zKSB7XG4gICAgICAgIGV4dGVuZChDdG9yLmV4dGVuZE9wdGlvbnMsIG1vZGlmaWVkT3B0aW9ucyk7XG4gICAgICB9XG4gICAgICBvcHRpb25zID0gQ3Rvci5vcHRpb25zID0gbWVyZ2VPcHRpb25zKHN1cGVyT3B0aW9ucywgQ3Rvci5leHRlbmRPcHRpb25zKTtcbiAgICAgIGlmIChvcHRpb25zLm5hbWUpIHtcbiAgICAgICAgb3B0aW9ucy5jb21wb25lbnRzW29wdGlvbnMubmFtZV0gPSBDdG9yO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gb3B0aW9ucztcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZU1vZGlmaWVkT3B0aW9ucyhDdG9yKSB7XG4gIHZhciBtb2RpZmllZDtcbiAgdmFyIGxhdGVzdCA9IEN0b3Iub3B0aW9ucztcbiAgdmFyIGV4dGVuZGVkID0gQ3Rvci5leHRlbmRPcHRpb25zO1xuICB2YXIgc2VhbGVkID0gQ3Rvci5zZWFsZWRPcHRpb25zO1xuICBmb3IgKHZhciBrZXkgaW4gbGF0ZXN0KSB7XG4gICAgaWYgKGxhdGVzdFtrZXldICE9PSBzZWFsZWRba2V5XSkge1xuICAgICAgaWYgKCFtb2RpZmllZCkge1xuICAgICAgICBtb2RpZmllZCA9IHt9O1xuICAgICAgfVxuICAgICAgbW9kaWZpZWRba2V5XSA9IGRlZHVwZShsYXRlc3Rba2V5XSwgZXh0ZW5kZWRba2V5XSwgc2VhbGVkW2tleV0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbW9kaWZpZWQ7XG59XG5cbmZ1bmN0aW9uIGRlZHVwZShsYXRlc3QsIGV4dGVuZGVkLCBzZWFsZWQpIHtcbiAgLy8gY29tcGFyZSBsYXRlc3QgYW5kIHNlYWxlZCB0byBlbnN1cmUgbGlmZWN5Y2xlIGhvb2tzIHdvbid0IGJlIGR1cGxpY2F0ZWRcbiAgLy8gYmV0d2VlbiBtZXJnZXNcbiAgaWYgKEFycmF5LmlzQXJyYXkobGF0ZXN0KSkge1xuICAgIHZhciByZXMgPSBbXTtcbiAgICBzZWFsZWQgPSBBcnJheS5pc0FycmF5KHNlYWxlZCkgPyBzZWFsZWQgOiBbc2VhbGVkXTtcbiAgICBleHRlbmRlZCA9IEFycmF5LmlzQXJyYXkoZXh0ZW5kZWQpID8gZXh0ZW5kZWQgOiBbZXh0ZW5kZWRdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGF0ZXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAvLyBwdXNoIG9yaWdpbmFsIG9wdGlvbnMgYW5kIG5vdCBzZWFsZWQgb3B0aW9ucyB0byBleGNsdWRlIGR1cGxpY2F0ZWQgb3B0aW9uc1xuICAgICAgaWYgKGV4dGVuZGVkLmluZGV4T2YobGF0ZXN0W2ldKSA+PSAwIHx8IHNlYWxlZC5pbmRleE9mKGxhdGVzdFtpXSkgPCAwKSB7XG4gICAgICAgIHJlcy5wdXNoKGxhdGVzdFtpXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXM7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGxhdGVzdDtcbiAgfVxufVxuXG5mdW5jdGlvbiBWdWUkMyhvcHRpb25zKSB7XG4gIGlmIChmYWxzZSkge1xuICAgIHdhcm4oJ1Z1ZSBpcyBhIGNvbnN0cnVjdG9yIGFuZCBzaG91bGQgYmUgY2FsbGVkIHdpdGggdGhlIGBuZXdgIGtleXdvcmQnKTtcbiAgfVxuICB0aGlzLl9pbml0KG9wdGlvbnMpO1xufVxuXG5pbml0TWl4aW4oVnVlJDMpO1xuc3RhdGVNaXhpbihWdWUkMyk7XG5ldmVudHNNaXhpbihWdWUkMyk7XG5saWZlY3ljbGVNaXhpbihWdWUkMyk7XG5yZW5kZXJNaXhpbihWdWUkMyk7XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0VXNlKFZ1ZSkge1xuICBWdWUudXNlID0gZnVuY3Rpb24gKHBsdWdpbikge1xuICAgIHZhciBpbnN0YWxsZWRQbHVnaW5zID0gdGhpcy5faW5zdGFsbGVkUGx1Z2lucyB8fCAodGhpcy5faW5zdGFsbGVkUGx1Z2lucyA9IFtdKTtcbiAgICBpZiAoaW5zdGFsbGVkUGx1Z2lucy5pbmRleE9mKHBsdWdpbikgPiAtMSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gYWRkaXRpb25hbCBwYXJhbWV0ZXJzXG4gICAgdmFyIGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cywgMSk7XG4gICAgYXJncy51bnNoaWZ0KHRoaXMpO1xuICAgIGlmICh0eXBlb2YgcGx1Z2luLmluc3RhbGwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHBsdWdpbi5pbnN0YWxsLmFwcGx5KHBsdWdpbiwgYXJncyk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgcGx1Z2luID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwbHVnaW4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgfVxuICAgIGluc3RhbGxlZFBsdWdpbnMucHVzaChwbHVnaW4pO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdE1peGluJDEoVnVlKSB7XG4gIFZ1ZS5taXhpbiA9IGZ1bmN0aW9uIChtaXhpbikge1xuICAgIHRoaXMub3B0aW9ucyA9IG1lcmdlT3B0aW9ucyh0aGlzLm9wdGlvbnMsIG1peGluKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRFeHRlbmQoVnVlKSB7XG4gIC8qKlxuICAgKiBFYWNoIGluc3RhbmNlIGNvbnN0cnVjdG9yLCBpbmNsdWRpbmcgVnVlLCBoYXMgYSB1bmlxdWVcbiAgICogY2lkLiBUaGlzIGVuYWJsZXMgdXMgdG8gY3JlYXRlIHdyYXBwZWQgXCJjaGlsZFxuICAgKiBjb25zdHJ1Y3RvcnNcIiBmb3IgcHJvdG90eXBhbCBpbmhlcml0YW5jZSBhbmQgY2FjaGUgdGhlbS5cbiAgICovXG4gIFZ1ZS5jaWQgPSAwO1xuICB2YXIgY2lkID0gMTtcblxuICAvKipcbiAgICogQ2xhc3MgaW5oZXJpdGFuY2VcbiAgICovXG4gIFZ1ZS5leHRlbmQgPSBmdW5jdGlvbiAoZXh0ZW5kT3B0aW9ucykge1xuICAgIGV4dGVuZE9wdGlvbnMgPSBleHRlbmRPcHRpb25zIHx8IHt9O1xuICAgIHZhciBTdXBlciA9IHRoaXM7XG4gICAgdmFyIFN1cGVySWQgPSBTdXBlci5jaWQ7XG4gICAgdmFyIGNhY2hlZEN0b3JzID0gZXh0ZW5kT3B0aW9ucy5fQ3RvciB8fCAoZXh0ZW5kT3B0aW9ucy5fQ3RvciA9IHt9KTtcbiAgICBpZiAoY2FjaGVkQ3RvcnNbU3VwZXJJZF0pIHtcbiAgICAgIHJldHVybiBjYWNoZWRDdG9yc1tTdXBlcklkXTtcbiAgICB9XG5cbiAgICB2YXIgbmFtZSA9IGV4dGVuZE9wdGlvbnMubmFtZSB8fCBTdXBlci5vcHRpb25zLm5hbWU7XG4gICAgaWYgKGZhbHNlKSB7XG4gICAgICBpZiAoIS9eW2EtekEtWl1bXFx3LV0qJC8udGVzdChuYW1lKSkge1xuICAgICAgICB3YXJuKCdJbnZhbGlkIGNvbXBvbmVudCBuYW1lOiBcIicgKyBuYW1lICsgJ1wiLiBDb21wb25lbnQgbmFtZXMgJyArICdjYW4gb25seSBjb250YWluIGFscGhhbnVtZXJpYyBjaGFyYWN0ZXJzIGFuZCB0aGUgaHlwaGVuLCAnICsgJ2FuZCBtdXN0IHN0YXJ0IHdpdGggYSBsZXR0ZXIuJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIFN1YiA9IGZ1bmN0aW9uIFZ1ZUNvbXBvbmVudChvcHRpb25zKSB7XG4gICAgICB0aGlzLl9pbml0KG9wdGlvbnMpO1xuICAgIH07XG4gICAgU3ViLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU3VwZXIucHJvdG90eXBlKTtcbiAgICBTdWIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU3ViO1xuICAgIFN1Yi5jaWQgPSBjaWQrKztcbiAgICBTdWIub3B0aW9ucyA9IG1lcmdlT3B0aW9ucyhTdXBlci5vcHRpb25zLCBleHRlbmRPcHRpb25zKTtcbiAgICBTdWJbJ3N1cGVyJ10gPSBTdXBlcjtcblxuICAgIC8vIEZvciBwcm9wcyBhbmQgY29tcHV0ZWQgcHJvcGVydGllcywgd2UgZGVmaW5lIHRoZSBwcm94eSBnZXR0ZXJzIG9uXG4gICAgLy8gdGhlIFZ1ZSBpbnN0YW5jZXMgYXQgZXh0ZW5zaW9uIHRpbWUsIG9uIHRoZSBleHRlbmRlZCBwcm90b3R5cGUuIFRoaXNcbiAgICAvLyBhdm9pZHMgT2JqZWN0LmRlZmluZVByb3BlcnR5IGNhbGxzIGZvciBlYWNoIGluc3RhbmNlIGNyZWF0ZWQuXG4gICAgaWYgKFN1Yi5vcHRpb25zLnByb3BzKSB7XG4gICAgICBpbml0UHJvcHMkMShTdWIpO1xuICAgIH1cbiAgICBpZiAoU3ViLm9wdGlvbnMuY29tcHV0ZWQpIHtcbiAgICAgIGluaXRDb21wdXRlZCQxKFN1Yik7XG4gICAgfVxuXG4gICAgLy8gYWxsb3cgZnVydGhlciBleHRlbnNpb24vbWl4aW4vcGx1Z2luIHVzYWdlXG4gICAgU3ViLmV4dGVuZCA9IFN1cGVyLmV4dGVuZDtcbiAgICBTdWIubWl4aW4gPSBTdXBlci5taXhpbjtcbiAgICBTdWIudXNlID0gU3VwZXIudXNlO1xuXG4gICAgLy8gY3JlYXRlIGFzc2V0IHJlZ2lzdGVycywgc28gZXh0ZW5kZWQgY2xhc3Nlc1xuICAgIC8vIGNhbiBoYXZlIHRoZWlyIHByaXZhdGUgYXNzZXRzIHRvby5cbiAgICBBU1NFVF9UWVBFUy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICBTdWJbdHlwZV0gPSBTdXBlclt0eXBlXTtcbiAgICB9KTtcbiAgICAvLyBlbmFibGUgcmVjdXJzaXZlIHNlbGYtbG9va3VwXG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIFN1Yi5vcHRpb25zLmNvbXBvbmVudHNbbmFtZV0gPSBTdWI7XG4gICAgfVxuXG4gICAgLy8ga2VlcCBhIHJlZmVyZW5jZSB0byB0aGUgc3VwZXIgb3B0aW9ucyBhdCBleHRlbnNpb24gdGltZS5cbiAgICAvLyBsYXRlciBhdCBpbnN0YW50aWF0aW9uIHdlIGNhbiBjaGVjayBpZiBTdXBlcidzIG9wdGlvbnMgaGF2ZVxuICAgIC8vIGJlZW4gdXBkYXRlZC5cbiAgICBTdWIuc3VwZXJPcHRpb25zID0gU3VwZXIub3B0aW9ucztcbiAgICBTdWIuZXh0ZW5kT3B0aW9ucyA9IGV4dGVuZE9wdGlvbnM7XG4gICAgU3ViLnNlYWxlZE9wdGlvbnMgPSBleHRlbmQoe30sIFN1Yi5vcHRpb25zKTtcblxuICAgIC8vIGNhY2hlIGNvbnN0cnVjdG9yXG4gICAgY2FjaGVkQ3RvcnNbU3VwZXJJZF0gPSBTdWI7XG4gICAgcmV0dXJuIFN1YjtcbiAgfTtcbn1cblxuZnVuY3Rpb24gaW5pdFByb3BzJDEoQ29tcCkge1xuICB2YXIgcHJvcHMgPSBDb21wLm9wdGlvbnMucHJvcHM7XG4gIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xuICAgIHByb3h5KENvbXAucHJvdG90eXBlLCBcIl9wcm9wc1wiLCBrZXkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRDb21wdXRlZCQxKENvbXApIHtcbiAgdmFyIGNvbXB1dGVkID0gQ29tcC5vcHRpb25zLmNvbXB1dGVkO1xuICBmb3IgKHZhciBrZXkgaW4gY29tcHV0ZWQpIHtcbiAgICBkZWZpbmVDb21wdXRlZChDb21wLnByb3RvdHlwZSwga2V5LCBjb21wdXRlZFtrZXldKTtcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdEFzc2V0UmVnaXN0ZXJzKFZ1ZSkge1xuICAvKipcbiAgICogQ3JlYXRlIGFzc2V0IHJlZ2lzdHJhdGlvbiBtZXRob2RzLlxuICAgKi9cbiAgQVNTRVRfVFlQRVMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgIFZ1ZVt0eXBlXSA9IGZ1bmN0aW9uIChpZCwgZGVmaW5pdGlvbikge1xuICAgICAgaWYgKCFkZWZpbml0aW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnNbdHlwZSArICdzJ11baWRdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmIChmYWxzZSkge1xuICAgICAgICAgIGlmICh0eXBlID09PSAnY29tcG9uZW50JyAmJiBjb25maWcuaXNSZXNlcnZlZFRhZyhpZCkpIHtcbiAgICAgICAgICAgIHdhcm4oJ0RvIG5vdCB1c2UgYnVpbHQtaW4gb3IgcmVzZXJ2ZWQgSFRNTCBlbGVtZW50cyBhcyBjb21wb25lbnQgJyArICdpZDogJyArIGlkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgPT09ICdjb21wb25lbnQnICYmIGlzUGxhaW5PYmplY3QoZGVmaW5pdGlvbikpIHtcbiAgICAgICAgICBkZWZpbml0aW9uLm5hbWUgPSBkZWZpbml0aW9uLm5hbWUgfHwgaWQ7XG4gICAgICAgICAgZGVmaW5pdGlvbiA9IHRoaXMub3B0aW9ucy5fYmFzZS5leHRlbmQoZGVmaW5pdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgPT09ICdkaXJlY3RpdmUnICYmIHR5cGVvZiBkZWZpbml0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgZGVmaW5pdGlvbiA9IHsgYmluZDogZGVmaW5pdGlvbiwgdXBkYXRlOiBkZWZpbml0aW9uIH07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vcHRpb25zW3R5cGUgKyAncyddW2lkXSA9IGRlZmluaXRpb247XG4gICAgICAgIHJldHVybiBkZWZpbml0aW9uO1xuICAgICAgfVxuICAgIH07XG4gIH0pO1xufVxuXG4vKiAgKi9cblxudmFyIHBhdHRlcm5UeXBlcyA9IFtTdHJpbmcsIFJlZ0V4cCwgQXJyYXldO1xuXG5mdW5jdGlvbiBnZXRDb21wb25lbnROYW1lKG9wdHMpIHtcbiAgcmV0dXJuIG9wdHMgJiYgKG9wdHMuQ3Rvci5vcHRpb25zLm5hbWUgfHwgb3B0cy50YWcpO1xufVxuXG5mdW5jdGlvbiBtYXRjaGVzKHBhdHRlcm4sIG5hbWUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkocGF0dGVybikpIHtcbiAgICByZXR1cm4gcGF0dGVybi5pbmRleE9mKG5hbWUpID4gLTE7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHBhdHRlcm4gPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHBhdHRlcm4uc3BsaXQoJywnKS5pbmRleE9mKG5hbWUpID4gLTE7XG4gIH0gZWxzZSBpZiAoaXNSZWdFeHAocGF0dGVybikpIHtcbiAgICByZXR1cm4gcGF0dGVybi50ZXN0KG5hbWUpO1xuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gcHJ1bmVDYWNoZShjYWNoZSwgY3VycmVudCwgZmlsdGVyKSB7XG4gIGZvciAodmFyIGtleSBpbiBjYWNoZSkge1xuICAgIHZhciBjYWNoZWROb2RlID0gY2FjaGVba2V5XTtcbiAgICBpZiAoY2FjaGVkTm9kZSkge1xuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKGNhY2hlZE5vZGUuY29tcG9uZW50T3B0aW9ucyk7XG4gICAgICBpZiAobmFtZSAmJiAhZmlsdGVyKG5hbWUpKSB7XG4gICAgICAgIGlmIChjYWNoZWROb2RlICE9PSBjdXJyZW50KSB7XG4gICAgICAgICAgcHJ1bmVDYWNoZUVudHJ5KGNhY2hlZE5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGNhY2hlW2tleV0gPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcnVuZUNhY2hlRW50cnkodm5vZGUpIHtcbiAgaWYgKHZub2RlKSB7XG4gICAgdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuJGRlc3Ryb3koKTtcbiAgfVxufVxuXG52YXIgS2VlcEFsaXZlID0ge1xuICBuYW1lOiAna2VlcC1hbGl2ZScsXG4gIGFic3RyYWN0OiB0cnVlLFxuXG4gIHByb3BzOiB7XG4gICAgaW5jbHVkZTogcGF0dGVyblR5cGVzLFxuICAgIGV4Y2x1ZGU6IHBhdHRlcm5UeXBlc1xuICB9LFxuXG4gIGNyZWF0ZWQ6IGZ1bmN0aW9uIGNyZWF0ZWQoKSB7XG4gICAgdGhpcy5jYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIH0sXG5cbiAgZGVzdHJveWVkOiBmdW5jdGlvbiBkZXN0cm95ZWQoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gdGhpcyQxLmNhY2hlKSB7XG4gICAgICBwcnVuZUNhY2hlRW50cnkodGhpcyQxLmNhY2hlW2tleV0pO1xuICAgIH1cbiAgfSxcblxuICB3YXRjaDoge1xuICAgIGluY2x1ZGU6IGZ1bmN0aW9uIGluY2x1ZGUodmFsKSB7XG4gICAgICBwcnVuZUNhY2hlKHRoaXMuY2FjaGUsIHRoaXMuX3Zub2RlLCBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4gbWF0Y2hlcyh2YWwsIG5hbWUpO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBleGNsdWRlOiBmdW5jdGlvbiBleGNsdWRlKHZhbCkge1xuICAgICAgcHJ1bmVDYWNoZSh0aGlzLmNhY2hlLCB0aGlzLl92bm9kZSwgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuICFtYXRjaGVzKHZhbCwgbmFtZSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgdmFyIHZub2RlID0gZ2V0Rmlyc3RDb21wb25lbnRDaGlsZCh0aGlzLiRzbG90cy5kZWZhdWx0KTtcbiAgICB2YXIgY29tcG9uZW50T3B0aW9ucyA9IHZub2RlICYmIHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gICAgaWYgKGNvbXBvbmVudE9wdGlvbnMpIHtcbiAgICAgIC8vIGNoZWNrIHBhdHRlcm5cbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShjb21wb25lbnRPcHRpb25zKTtcbiAgICAgIGlmIChuYW1lICYmICh0aGlzLmluY2x1ZGUgJiYgIW1hdGNoZXModGhpcy5pbmNsdWRlLCBuYW1lKSB8fCB0aGlzLmV4Y2x1ZGUgJiYgbWF0Y2hlcyh0aGlzLmV4Y2x1ZGUsIG5hbWUpKSkge1xuICAgICAgICByZXR1cm4gdm5vZGU7XG4gICAgICB9XG4gICAgICB2YXIga2V5ID0gdm5vZGUua2V5ID09IG51bGxcbiAgICAgIC8vIHNhbWUgY29uc3RydWN0b3IgbWF5IGdldCByZWdpc3RlcmVkIGFzIGRpZmZlcmVudCBsb2NhbCBjb21wb25lbnRzXG4gICAgICAvLyBzbyBjaWQgYWxvbmUgaXMgbm90IGVub3VnaCAoIzMyNjkpXG4gICAgICA/IGNvbXBvbmVudE9wdGlvbnMuQ3Rvci5jaWQgKyAoY29tcG9uZW50T3B0aW9ucy50YWcgPyBcIjo6XCIgKyBjb21wb25lbnRPcHRpb25zLnRhZyA6ICcnKSA6IHZub2RlLmtleTtcbiAgICAgIGlmICh0aGlzLmNhY2hlW2tleV0pIHtcbiAgICAgICAgdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgPSB0aGlzLmNhY2hlW2tleV0uY29tcG9uZW50SW5zdGFuY2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNhY2hlW2tleV0gPSB2bm9kZTtcbiAgICAgIH1cbiAgICAgIHZub2RlLmRhdGEua2VlcEFsaXZlID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHZub2RlO1xuICB9XG59O1xuXG52YXIgYnVpbHRJbkNvbXBvbmVudHMgPSB7XG4gIEtlZXBBbGl2ZTogS2VlcEFsaXZlXG59O1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdEdsb2JhbEFQSShWdWUpIHtcbiAgLy8gY29uZmlnXG4gIHZhciBjb25maWdEZWYgPSB7fTtcbiAgY29uZmlnRGVmLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gY29uZmlnO1xuICB9O1xuICBpZiAoZmFsc2UpIHtcbiAgICBjb25maWdEZWYuc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgd2FybignRG8gbm90IHJlcGxhY2UgdGhlIFZ1ZS5jb25maWcgb2JqZWN0LCBzZXQgaW5kaXZpZHVhbCBmaWVsZHMgaW5zdGVhZC4nKTtcbiAgICB9O1xuICB9XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUsICdjb25maWcnLCBjb25maWdEZWYpO1xuXG4gIC8vIGV4cG9zZWQgdXRpbCBtZXRob2RzLlxuICAvLyBOT1RFOiB0aGVzZSBhcmUgbm90IGNvbnNpZGVyZWQgcGFydCBvZiB0aGUgcHVibGljIEFQSSAtIGF2b2lkIHJlbHlpbmcgb25cbiAgLy8gdGhlbSB1bmxlc3MgeW91IGFyZSBhd2FyZSBvZiB0aGUgcmlzay5cbiAgVnVlLnV0aWwgPSB7XG4gICAgd2Fybjogd2FybixcbiAgICBleHRlbmQ6IGV4dGVuZCxcbiAgICBtZXJnZU9wdGlvbnM6IG1lcmdlT3B0aW9ucyxcbiAgICBkZWZpbmVSZWFjdGl2ZTogZGVmaW5lUmVhY3RpdmUkJDFcbiAgfTtcblxuICBWdWUuc2V0ID0gc2V0O1xuICBWdWUuZGVsZXRlID0gZGVsO1xuICBWdWUubmV4dFRpY2sgPSBuZXh0VGljaztcblxuICBWdWUub3B0aW9ucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIEFTU0VUX1RZUEVTLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICBWdWUub3B0aW9uc1t0eXBlICsgJ3MnXSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIH0pO1xuXG4gIC8vIHRoaXMgaXMgdXNlZCB0byBpZGVudGlmeSB0aGUgXCJiYXNlXCIgY29uc3RydWN0b3IgdG8gZXh0ZW5kIGFsbCBwbGFpbi1vYmplY3RcbiAgLy8gY29tcG9uZW50cyB3aXRoIGluIFdlZXgncyBtdWx0aS1pbnN0YW5jZSBzY2VuYXJpb3MuXG4gIFZ1ZS5vcHRpb25zLl9iYXNlID0gVnVlO1xuXG4gIGV4dGVuZChWdWUub3B0aW9ucy5jb21wb25lbnRzLCBidWlsdEluQ29tcG9uZW50cyk7XG5cbiAgaW5pdFVzZShWdWUpO1xuICBpbml0TWl4aW4kMShWdWUpO1xuICBpbml0RXh0ZW5kKFZ1ZSk7XG4gIGluaXRBc3NldFJlZ2lzdGVycyhWdWUpO1xufVxuXG5pbml0R2xvYmFsQVBJKFZ1ZSQzKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZSQzLnByb3RvdHlwZSwgJyRpc1NlcnZlcicsIHtcbiAgZ2V0OiBpc1NlcnZlclJlbmRlcmluZ1xufSk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUkMy5wcm90b3R5cGUsICckc3NyQ29udGV4dCcsIHtcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICByZXR1cm4gdGhpcy4kdm5vZGUgJiYgdGhpcy4kdm5vZGUuc3NyQ29udGV4dDtcbiAgfVxufSk7XG5cblZ1ZSQzLnZlcnNpb24gPSAnMi40LjQnO1xuXG4vKiAgKi9cblxuLy8gdGhlc2UgYXJlIHJlc2VydmVkIGZvciB3ZWIgYmVjYXVzZSB0aGV5IGFyZSBkaXJlY3RseSBjb21waWxlZCBhd2F5XG4vLyBkdXJpbmcgdGVtcGxhdGUgY29tcGlsYXRpb25cbnZhciBpc1Jlc2VydmVkQXR0ciA9IG1ha2VNYXAoJ3N0eWxlLGNsYXNzJyk7XG5cbi8vIGF0dHJpYnV0ZXMgdGhhdCBzaG91bGQgYmUgdXNpbmcgcHJvcHMgZm9yIGJpbmRpbmdcbnZhciBhY2NlcHRWYWx1ZSA9IG1ha2VNYXAoJ2lucHV0LHRleHRhcmVhLG9wdGlvbixzZWxlY3QscHJvZ3Jlc3MnKTtcbnZhciBtdXN0VXNlUHJvcCA9IGZ1bmN0aW9uICh0YWcsIHR5cGUsIGF0dHIpIHtcbiAgcmV0dXJuIGF0dHIgPT09ICd2YWx1ZScgJiYgYWNjZXB0VmFsdWUodGFnKSAmJiB0eXBlICE9PSAnYnV0dG9uJyB8fCBhdHRyID09PSAnc2VsZWN0ZWQnICYmIHRhZyA9PT0gJ29wdGlvbicgfHwgYXR0ciA9PT0gJ2NoZWNrZWQnICYmIHRhZyA9PT0gJ2lucHV0JyB8fCBhdHRyID09PSAnbXV0ZWQnICYmIHRhZyA9PT0gJ3ZpZGVvJztcbn07XG5cbnZhciBpc0VudW1lcmF0ZWRBdHRyID0gbWFrZU1hcCgnY29udGVudGVkaXRhYmxlLGRyYWdnYWJsZSxzcGVsbGNoZWNrJyk7XG5cbnZhciBpc0Jvb2xlYW5BdHRyID0gbWFrZU1hcCgnYWxsb3dmdWxsc2NyZWVuLGFzeW5jLGF1dG9mb2N1cyxhdXRvcGxheSxjaGVja2VkLGNvbXBhY3QsY29udHJvbHMsZGVjbGFyZSwnICsgJ2RlZmF1bHQsZGVmYXVsdGNoZWNrZWQsZGVmYXVsdG11dGVkLGRlZmF1bHRzZWxlY3RlZCxkZWZlcixkaXNhYmxlZCwnICsgJ2VuYWJsZWQsZm9ybW5vdmFsaWRhdGUsaGlkZGVuLGluZGV0ZXJtaW5hdGUsaW5lcnQsaXNtYXAsaXRlbXNjb3BlLGxvb3AsbXVsdGlwbGUsJyArICdtdXRlZCxub2hyZWYsbm9yZXNpemUsbm9zaGFkZSxub3ZhbGlkYXRlLG5vd3JhcCxvcGVuLHBhdXNlb25leGl0LHJlYWRvbmx5LCcgKyAncmVxdWlyZWQscmV2ZXJzZWQsc2NvcGVkLHNlYW1sZXNzLHNlbGVjdGVkLHNvcnRhYmxlLHRyYW5zbGF0ZSwnICsgJ3RydWVzcGVlZCx0eXBlbXVzdG1hdGNoLHZpc2libGUnKTtcblxudmFyIHhsaW5rTlMgPSAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayc7XG5cbnZhciBpc1hsaW5rID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuIG5hbWUuY2hhckF0KDUpID09PSAnOicgJiYgbmFtZS5zbGljZSgwLCA1KSA9PT0gJ3hsaW5rJztcbn07XG5cbnZhciBnZXRYbGlua1Byb3AgPSBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gaXNYbGluayhuYW1lKSA/IG5hbWUuc2xpY2UoNiwgbmFtZS5sZW5ndGgpIDogJyc7XG59O1xuXG52YXIgaXNGYWxzeUF0dHJWYWx1ZSA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgcmV0dXJuIHZhbCA9PSBudWxsIHx8IHZhbCA9PT0gZmFsc2U7XG59O1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gZ2VuQ2xhc3NGb3JWbm9kZSh2bm9kZSkge1xuICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gIHZhciBwYXJlbnROb2RlID0gdm5vZGU7XG4gIHZhciBjaGlsZE5vZGUgPSB2bm9kZTtcbiAgd2hpbGUgKGlzRGVmKGNoaWxkTm9kZS5jb21wb25lbnRJbnN0YW5jZSkpIHtcbiAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlO1xuICAgIGlmIChjaGlsZE5vZGUuZGF0YSkge1xuICAgICAgZGF0YSA9IG1lcmdlQ2xhc3NEYXRhKGNoaWxkTm9kZS5kYXRhLCBkYXRhKTtcbiAgICB9XG4gIH1cbiAgd2hpbGUgKGlzRGVmKHBhcmVudE5vZGUgPSBwYXJlbnROb2RlLnBhcmVudCkpIHtcbiAgICBpZiAocGFyZW50Tm9kZS5kYXRhKSB7XG4gICAgICBkYXRhID0gbWVyZ2VDbGFzc0RhdGEoZGF0YSwgcGFyZW50Tm9kZS5kYXRhKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlbmRlckNsYXNzKGRhdGEuc3RhdGljQ2xhc3MsIGRhdGEuY2xhc3MpO1xufVxuXG5mdW5jdGlvbiBtZXJnZUNsYXNzRGF0YShjaGlsZCwgcGFyZW50KSB7XG4gIHJldHVybiB7XG4gICAgc3RhdGljQ2xhc3M6IGNvbmNhdChjaGlsZC5zdGF0aWNDbGFzcywgcGFyZW50LnN0YXRpY0NsYXNzKSxcbiAgICBjbGFzczogaXNEZWYoY2hpbGQuY2xhc3MpID8gW2NoaWxkLmNsYXNzLCBwYXJlbnQuY2xhc3NdIDogcGFyZW50LmNsYXNzXG4gIH07XG59XG5cbmZ1bmN0aW9uIHJlbmRlckNsYXNzKHN0YXRpY0NsYXNzLCBkeW5hbWljQ2xhc3MpIHtcbiAgaWYgKGlzRGVmKHN0YXRpY0NsYXNzKSB8fCBpc0RlZihkeW5hbWljQ2xhc3MpKSB7XG4gICAgcmV0dXJuIGNvbmNhdChzdGF0aWNDbGFzcywgc3RyaW5naWZ5Q2xhc3MoZHluYW1pY0NsYXNzKSk7XG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgcmV0dXJuICcnO1xufVxuXG5mdW5jdGlvbiBjb25jYXQoYSwgYikge1xuICByZXR1cm4gYSA/IGIgPyBhICsgJyAnICsgYiA6IGEgOiBiIHx8ICcnO1xufVxuXG5mdW5jdGlvbiBzdHJpbmdpZnlDbGFzcyh2YWx1ZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gc3RyaW5naWZ5QXJyYXkodmFsdWUpO1xuICB9XG4gIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gc3RyaW5naWZ5T2JqZWN0KHZhbHVlKTtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICByZXR1cm4gJyc7XG59XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeUFycmF5KHZhbHVlKSB7XG4gIHZhciByZXMgPSAnJztcbiAgdmFyIHN0cmluZ2lmaWVkO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmIChpc0RlZihzdHJpbmdpZmllZCA9IHN0cmluZ2lmeUNsYXNzKHZhbHVlW2ldKSkgJiYgc3RyaW5naWZpZWQgIT09ICcnKSB7XG4gICAgICBpZiAocmVzKSB7XG4gICAgICAgIHJlcyArPSAnICc7XG4gICAgICB9XG4gICAgICByZXMgKz0gc3RyaW5naWZpZWQ7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXM7XG59XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeU9iamVjdCh2YWx1ZSkge1xuICB2YXIgcmVzID0gJyc7XG4gIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgIGlmICh2YWx1ZVtrZXldKSB7XG4gICAgICBpZiAocmVzKSB7XG4gICAgICAgIHJlcyArPSAnICc7XG4gICAgICB9XG4gICAgICByZXMgKz0ga2V5O1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzO1xufVxuXG4vKiAgKi9cblxudmFyIG5hbWVzcGFjZU1hcCA9IHtcbiAgc3ZnOiAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLFxuICBtYXRoOiAnaHR0cDovL3d3dy53My5vcmcvMTk5OC9NYXRoL01hdGhNTCdcbn07XG5cbnZhciBpc0hUTUxUYWcgPSBtYWtlTWFwKCdodG1sLGJvZHksYmFzZSxoZWFkLGxpbmssbWV0YSxzdHlsZSx0aXRsZSwnICsgJ2FkZHJlc3MsYXJ0aWNsZSxhc2lkZSxmb290ZXIsaGVhZGVyLGgxLGgyLGgzLGg0LGg1LGg2LGhncm91cCxuYXYsc2VjdGlvbiwnICsgJ2RpdixkZCxkbCxkdCxmaWdjYXB0aW9uLGZpZ3VyZSxwaWN0dXJlLGhyLGltZyxsaSxtYWluLG9sLHAscHJlLHVsLCcgKyAnYSxiLGFiYnIsYmRpLGJkbyxicixjaXRlLGNvZGUsZGF0YSxkZm4sZW0saSxrYmQsbWFyayxxLHJwLHJ0LHJ0YyxydWJ5LCcgKyAncyxzYW1wLHNtYWxsLHNwYW4sc3Ryb25nLHN1YixzdXAsdGltZSx1LHZhcix3YnIsYXJlYSxhdWRpbyxtYXAsdHJhY2ssdmlkZW8sJyArICdlbWJlZCxvYmplY3QscGFyYW0sc291cmNlLGNhbnZhcyxzY3JpcHQsbm9zY3JpcHQsZGVsLGlucywnICsgJ2NhcHRpb24sY29sLGNvbGdyb3VwLHRhYmxlLHRoZWFkLHRib2R5LHRkLHRoLHRyLCcgKyAnYnV0dG9uLGRhdGFsaXN0LGZpZWxkc2V0LGZvcm0saW5wdXQsbGFiZWwsbGVnZW5kLG1ldGVyLG9wdGdyb3VwLG9wdGlvbiwnICsgJ291dHB1dCxwcm9ncmVzcyxzZWxlY3QsdGV4dGFyZWEsJyArICdkZXRhaWxzLGRpYWxvZyxtZW51LG1lbnVpdGVtLHN1bW1hcnksJyArICdjb250ZW50LGVsZW1lbnQsc2hhZG93LHRlbXBsYXRlLGJsb2NrcXVvdGUsaWZyYW1lLHRmb290Jyk7XG5cbi8vIHRoaXMgbWFwIGlzIGludGVudGlvbmFsbHkgc2VsZWN0aXZlLCBvbmx5IGNvdmVyaW5nIFNWRyBlbGVtZW50cyB0aGF0IG1heVxuLy8gY29udGFpbiBjaGlsZCBlbGVtZW50cy5cbnZhciBpc1NWRyA9IG1ha2VNYXAoJ3N2ZyxhbmltYXRlLGNpcmNsZSxjbGlwcGF0aCxjdXJzb3IsZGVmcyxkZXNjLGVsbGlwc2UsZmlsdGVyLGZvbnQtZmFjZSwnICsgJ2ZvcmVpZ25PYmplY3QsZyxnbHlwaCxpbWFnZSxsaW5lLG1hcmtlcixtYXNrLG1pc3NpbmctZ2x5cGgscGF0aCxwYXR0ZXJuLCcgKyAncG9seWdvbixwb2x5bGluZSxyZWN0LHN3aXRjaCxzeW1ib2wsdGV4dCx0ZXh0cGF0aCx0c3Bhbix1c2UsdmlldycsIHRydWUpO1xuXG52YXIgaXNQcmVUYWcgPSBmdW5jdGlvbiAodGFnKSB7XG4gIHJldHVybiB0YWcgPT09ICdwcmUnO1xufTtcblxudmFyIGlzUmVzZXJ2ZWRUYWcgPSBmdW5jdGlvbiAodGFnKSB7XG4gIHJldHVybiBpc0hUTUxUYWcodGFnKSB8fCBpc1NWRyh0YWcpO1xufTtcblxuZnVuY3Rpb24gZ2V0VGFnTmFtZXNwYWNlKHRhZykge1xuICBpZiAoaXNTVkcodGFnKSkge1xuICAgIHJldHVybiAnc3ZnJztcbiAgfVxuICAvLyBiYXNpYyBzdXBwb3J0IGZvciBNYXRoTUxcbiAgLy8gbm90ZSBpdCBkb2Vzbid0IHN1cHBvcnQgb3RoZXIgTWF0aE1MIGVsZW1lbnRzIGJlaW5nIGNvbXBvbmVudCByb290c1xuICBpZiAodGFnID09PSAnbWF0aCcpIHtcbiAgICByZXR1cm4gJ21hdGgnO1xuICB9XG59XG5cbnZhciB1bmtub3duRWxlbWVudENhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbmZ1bmN0aW9uIGlzVW5rbm93bkVsZW1lbnQodGFnKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoIWluQnJvd3Nlcikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChpc1Jlc2VydmVkVGFnKHRhZykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdGFnID0gdGFnLnRvTG93ZXJDYXNlKCk7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAodW5rbm93bkVsZW1lbnRDYWNoZVt0YWddICE9IG51bGwpIHtcbiAgICByZXR1cm4gdW5rbm93bkVsZW1lbnRDYWNoZVt0YWddO1xuICB9XG4gIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgaWYgKHRhZy5pbmRleE9mKCctJykgPiAtMSkge1xuICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzI4MjEwMzY0LzEwNzAyNDRcbiAgICByZXR1cm4gdW5rbm93bkVsZW1lbnRDYWNoZVt0YWddID0gZWwuY29uc3RydWN0b3IgPT09IHdpbmRvdy5IVE1MVW5rbm93bkVsZW1lbnQgfHwgZWwuY29uc3RydWN0b3IgPT09IHdpbmRvdy5IVE1MRWxlbWVudDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdW5rbm93bkVsZW1lbnRDYWNoZVt0YWddID0gL0hUTUxVbmtub3duRWxlbWVudC8udGVzdChlbC50b1N0cmluZygpKTtcbiAgfVxufVxuXG52YXIgaXNUZXh0SW5wdXRUeXBlID0gbWFrZU1hcCgndGV4dCxudW1iZXIscGFzc3dvcmQsc2VhcmNoLGVtYWlsLHRlbCx1cmwnKTtcblxuLyogICovXG5cbi8qKlxuICogUXVlcnkgYW4gZWxlbWVudCBzZWxlY3RvciBpZiBpdCdzIG5vdCBhbiBlbGVtZW50IGFscmVhZHkuXG4gKi9cbmZ1bmN0aW9uIHF1ZXJ5KGVsKSB7XG4gIGlmICh0eXBlb2YgZWwgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIHNlbGVjdGVkID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihlbCk7XG4gICAgaWYgKCFzZWxlY3RlZCkge1xuICAgICAgXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKCdDYW5ub3QgZmluZCBlbGVtZW50OiAnICsgZWwpO1xuICAgICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIH1cbiAgICByZXR1cm4gc2VsZWN0ZWQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGVsO1xuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50JDEodGFnTmFtZSwgdm5vZGUpIHtcbiAgdmFyIGVsbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnTmFtZSk7XG4gIGlmICh0YWdOYW1lICE9PSAnc2VsZWN0Jykge1xuICAgIHJldHVybiBlbG07XG4gIH1cbiAgLy8gZmFsc2Ugb3IgbnVsbCB3aWxsIHJlbW92ZSB0aGUgYXR0cmlidXRlIGJ1dCB1bmRlZmluZWQgd2lsbCBub3RcbiAgaWYgKHZub2RlLmRhdGEgJiYgdm5vZGUuZGF0YS5hdHRycyAmJiB2bm9kZS5kYXRhLmF0dHJzLm11bHRpcGxlICE9PSB1bmRlZmluZWQpIHtcbiAgICBlbG0uc2V0QXR0cmlidXRlKCdtdWx0aXBsZScsICdtdWx0aXBsZScpO1xuICB9XG4gIHJldHVybiBlbG07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnROUyhuYW1lc3BhY2UsIHRhZ05hbWUpIHtcbiAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhuYW1lc3BhY2VNYXBbbmFtZXNwYWNlXSwgdGFnTmFtZSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVRleHROb2RlKHRleHQpIHtcbiAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRleHQpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVDb21tZW50KHRleHQpIHtcbiAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUNvbW1lbnQodGV4dCk7XG59XG5cbmZ1bmN0aW9uIGluc2VydEJlZm9yZShwYXJlbnROb2RlLCBuZXdOb2RlLCByZWZlcmVuY2VOb2RlKSB7XG4gIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKG5ld05vZGUsIHJlZmVyZW5jZU5vZGUpO1xufVxuXG5mdW5jdGlvbiByZW1vdmVDaGlsZChub2RlLCBjaGlsZCkge1xuICBub2RlLnJlbW92ZUNoaWxkKGNoaWxkKTtcbn1cblxuZnVuY3Rpb24gYXBwZW5kQ2hpbGQobm9kZSwgY2hpbGQpIHtcbiAgbm9kZS5hcHBlbmRDaGlsZChjaGlsZCk7XG59XG5cbmZ1bmN0aW9uIHBhcmVudE5vZGUobm9kZSkge1xuICByZXR1cm4gbm9kZS5wYXJlbnROb2RlO1xufVxuXG5mdW5jdGlvbiBuZXh0U2libGluZyhub2RlKSB7XG4gIHJldHVybiBub2RlLm5leHRTaWJsaW5nO1xufVxuXG5mdW5jdGlvbiB0YWdOYW1lKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUudGFnTmFtZTtcbn1cblxuZnVuY3Rpb24gc2V0VGV4dENvbnRlbnQobm9kZSwgdGV4dCkge1xuICBub2RlLnRleHRDb250ZW50ID0gdGV4dDtcbn1cblxuZnVuY3Rpb24gc2V0QXR0cmlidXRlKG5vZGUsIGtleSwgdmFsKSB7XG4gIG5vZGUuc2V0QXR0cmlidXRlKGtleSwgdmFsKTtcbn1cblxudmFyIG5vZGVPcHMgPSBPYmplY3QuZnJlZXplKHtcbiAgY3JlYXRlRWxlbWVudDogY3JlYXRlRWxlbWVudCQxLFxuICBjcmVhdGVFbGVtZW50TlM6IGNyZWF0ZUVsZW1lbnROUyxcbiAgY3JlYXRlVGV4dE5vZGU6IGNyZWF0ZVRleHROb2RlLFxuICBjcmVhdGVDb21tZW50OiBjcmVhdGVDb21tZW50LFxuICBpbnNlcnRCZWZvcmU6IGluc2VydEJlZm9yZSxcbiAgcmVtb3ZlQ2hpbGQ6IHJlbW92ZUNoaWxkLFxuICBhcHBlbmRDaGlsZDogYXBwZW5kQ2hpbGQsXG4gIHBhcmVudE5vZGU6IHBhcmVudE5vZGUsXG4gIG5leHRTaWJsaW5nOiBuZXh0U2libGluZyxcbiAgdGFnTmFtZTogdGFnTmFtZSxcbiAgc2V0VGV4dENvbnRlbnQ6IHNldFRleHRDb250ZW50LFxuICBzZXRBdHRyaWJ1dGU6IHNldEF0dHJpYnV0ZVxufSk7XG5cbi8qICAqL1xuXG52YXIgcmVmID0ge1xuICBjcmVhdGU6IGZ1bmN0aW9uIGNyZWF0ZShfLCB2bm9kZSkge1xuICAgIHJlZ2lzdGVyUmVmKHZub2RlKTtcbiAgfSxcbiAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUob2xkVm5vZGUsIHZub2RlKSB7XG4gICAgaWYgKG9sZFZub2RlLmRhdGEucmVmICE9PSB2bm9kZS5kYXRhLnJlZikge1xuICAgICAgcmVnaXN0ZXJSZWYob2xkVm5vZGUsIHRydWUpO1xuICAgICAgcmVnaXN0ZXJSZWYodm5vZGUpO1xuICAgIH1cbiAgfSxcbiAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSh2bm9kZSkge1xuICAgIHJlZ2lzdGVyUmVmKHZub2RlLCB0cnVlKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gcmVnaXN0ZXJSZWYodm5vZGUsIGlzUmVtb3ZhbCkge1xuICB2YXIga2V5ID0gdm5vZGUuZGF0YS5yZWY7XG4gIGlmICgha2V5KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHZtID0gdm5vZGUuY29udGV4dDtcbiAgdmFyIHJlZiA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlIHx8IHZub2RlLmVsbTtcbiAgdmFyIHJlZnMgPSB2bS4kcmVmcztcbiAgaWYgKGlzUmVtb3ZhbCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHJlZnNba2V5XSkpIHtcbiAgICAgIHJlbW92ZShyZWZzW2tleV0sIHJlZik7XG4gICAgfSBlbHNlIGlmIChyZWZzW2tleV0gPT09IHJlZikge1xuICAgICAgcmVmc1trZXldID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAodm5vZGUuZGF0YS5yZWZJbkZvcikge1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHJlZnNba2V5XSkpIHtcbiAgICAgICAgcmVmc1trZXldID0gW3JlZl07XG4gICAgICB9IGVsc2UgaWYgKHJlZnNba2V5XS5pbmRleE9mKHJlZikgPCAwKSB7XG4gICAgICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgICAgICByZWZzW2tleV0ucHVzaChyZWYpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZWZzW2tleV0gPSByZWY7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogVmlydHVhbCBET00gcGF0Y2hpbmcgYWxnb3JpdGhtIGJhc2VkIG9uIFNuYWJiZG9tIGJ5XG4gKiBTaW1vbiBGcmlpcyBWaW5kdW0gKEBwYWxkZXBpbmQpXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2VcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9wYWxkZXBpbmQvc25hYmJkb20vYmxvYi9tYXN0ZXIvTElDRU5TRVxuICpcbiAqIG1vZGlmaWVkIGJ5IEV2YW4gWW91IChAeXl4OTkwODAzKVxuICpcbiAqIE5vdCB0eXBlLWNoZWNraW5nIHRoaXMgYmVjYXVzZSB0aGlzIGZpbGUgaXMgcGVyZi1jcml0aWNhbCBhbmQgdGhlIGNvc3RcbiAqIG9mIG1ha2luZyBmbG93IHVuZGVyc3RhbmQgaXQgaXMgbm90IHdvcnRoIGl0LlxuICovXG5cbnZhciBlbXB0eU5vZGUgPSBuZXcgVk5vZGUoJycsIHt9LCBbXSk7XG5cbnZhciBob29rcyA9IFsnY3JlYXRlJywgJ2FjdGl2YXRlJywgJ3VwZGF0ZScsICdyZW1vdmUnLCAnZGVzdHJveSddO1xuXG5mdW5jdGlvbiBzYW1lVm5vZGUoYSwgYikge1xuICByZXR1cm4gYS5rZXkgPT09IGIua2V5ICYmIChhLnRhZyA9PT0gYi50YWcgJiYgYS5pc0NvbW1lbnQgPT09IGIuaXNDb21tZW50ICYmIGlzRGVmKGEuZGF0YSkgPT09IGlzRGVmKGIuZGF0YSkgJiYgc2FtZUlucHV0VHlwZShhLCBiKSB8fCBpc1RydWUoYS5pc0FzeW5jUGxhY2Vob2xkZXIpICYmIGEuYXN5bmNGYWN0b3J5ID09PSBiLmFzeW5jRmFjdG9yeSAmJiBpc1VuZGVmKGIuYXN5bmNGYWN0b3J5LmVycm9yKSk7XG59XG5cbmZ1bmN0aW9uIHNhbWVJbnB1dFR5cGUoYSwgYikge1xuICBpZiAoYS50YWcgIT09ICdpbnB1dCcpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICB2YXIgaTtcbiAgdmFyIHR5cGVBID0gaXNEZWYoaSA9IGEuZGF0YSkgJiYgaXNEZWYoaSA9IGkuYXR0cnMpICYmIGkudHlwZTtcbiAgdmFyIHR5cGVCID0gaXNEZWYoaSA9IGIuZGF0YSkgJiYgaXNEZWYoaSA9IGkuYXR0cnMpICYmIGkudHlwZTtcbiAgcmV0dXJuIHR5cGVBID09PSB0eXBlQiB8fCBpc1RleHRJbnB1dFR5cGUodHlwZUEpICYmIGlzVGV4dElucHV0VHlwZSh0eXBlQik7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUtleVRvT2xkSWR4KGNoaWxkcmVuLCBiZWdpbklkeCwgZW5kSWR4KSB7XG4gIHZhciBpLCBrZXk7XG4gIHZhciBtYXAgPSB7fTtcbiAgZm9yIChpID0gYmVnaW5JZHg7IGkgPD0gZW5kSWR4OyArK2kpIHtcbiAgICBrZXkgPSBjaGlsZHJlbltpXS5rZXk7XG4gICAgaWYgKGlzRGVmKGtleSkpIHtcbiAgICAgIG1hcFtrZXldID0gaTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1hcDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlUGF0Y2hGdW5jdGlvbihiYWNrZW5kKSB7XG4gIHZhciBpLCBqO1xuICB2YXIgY2JzID0ge307XG5cbiAgdmFyIG1vZHVsZXMgPSBiYWNrZW5kLm1vZHVsZXM7XG4gIHZhciBub2RlT3BzID0gYmFja2VuZC5ub2RlT3BzO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBob29rcy5sZW5ndGg7ICsraSkge1xuICAgIGNic1tob29rc1tpXV0gPSBbXTtcbiAgICBmb3IgKGogPSAwOyBqIDwgbW9kdWxlcy5sZW5ndGg7ICsraikge1xuICAgICAgaWYgKGlzRGVmKG1vZHVsZXNbal1baG9va3NbaV1dKSkge1xuICAgICAgICBjYnNbaG9va3NbaV1dLnB1c2gobW9kdWxlc1tqXVtob29rc1tpXV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGVtcHR5Tm9kZUF0KGVsbSkge1xuICAgIHJldHVybiBuZXcgVk5vZGUobm9kZU9wcy50YWdOYW1lKGVsbSkudG9Mb3dlckNhc2UoKSwge30sIFtdLCB1bmRlZmluZWQsIGVsbSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVSbUNiKGNoaWxkRWxtLCBsaXN0ZW5lcnMpIHtcbiAgICBmdW5jdGlvbiByZW1vdmUkJDEoKSB7XG4gICAgICBpZiAoLS1yZW1vdmUkJDEubGlzdGVuZXJzID09PSAwKSB7XG4gICAgICAgIHJlbW92ZU5vZGUoY2hpbGRFbG0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZW1vdmUkJDEubGlzdGVuZXJzID0gbGlzdGVuZXJzO1xuICAgIHJldHVybiByZW1vdmUkJDE7XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVOb2RlKGVsKSB7XG4gICAgdmFyIHBhcmVudCA9IG5vZGVPcHMucGFyZW50Tm9kZShlbCk7XG4gICAgLy8gZWxlbWVudCBtYXkgaGF2ZSBhbHJlYWR5IGJlZW4gcmVtb3ZlZCBkdWUgdG8gdi1odG1sIC8gdi10ZXh0XG4gICAgaWYgKGlzRGVmKHBhcmVudCkpIHtcbiAgICAgIG5vZGVPcHMucmVtb3ZlQ2hpbGQocGFyZW50LCBlbCk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGluUHJlID0gMDtcbiAgZnVuY3Rpb24gY3JlYXRlRWxtKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtLCBuZXN0ZWQpIHtcbiAgICB2bm9kZS5pc1Jvb3RJbnNlcnQgPSAhbmVzdGVkOyAvLyBmb3IgdHJhbnNpdGlvbiBlbnRlciBjaGVja1xuICAgIGlmIChjcmVhdGVDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICAgIHZhciBjaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuO1xuICAgIHZhciB0YWcgPSB2bm9kZS50YWc7XG4gICAgaWYgKGlzRGVmKHRhZykpIHtcbiAgICAgIGlmIChmYWxzZSkge1xuICAgICAgICBpZiAoZGF0YSAmJiBkYXRhLnByZSkge1xuICAgICAgICAgIGluUHJlKys7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpblByZSAmJiAhdm5vZGUubnMgJiYgIShjb25maWcuaWdub3JlZEVsZW1lbnRzLmxlbmd0aCAmJiBjb25maWcuaWdub3JlZEVsZW1lbnRzLmluZGV4T2YodGFnKSA+IC0xKSAmJiBjb25maWcuaXNVbmtub3duRWxlbWVudCh0YWcpKSB7XG4gICAgICAgICAgd2FybignVW5rbm93biBjdXN0b20gZWxlbWVudDogPCcgKyB0YWcgKyAnPiAtIGRpZCB5b3UgJyArICdyZWdpc3RlciB0aGUgY29tcG9uZW50IGNvcnJlY3RseT8gRm9yIHJlY3Vyc2l2ZSBjb21wb25lbnRzLCAnICsgJ21ha2Ugc3VyZSB0byBwcm92aWRlIHRoZSBcIm5hbWVcIiBvcHRpb24uJywgdm5vZGUuY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZub2RlLmVsbSA9IHZub2RlLm5zID8gbm9kZU9wcy5jcmVhdGVFbGVtZW50TlModm5vZGUubnMsIHRhZykgOiBub2RlT3BzLmNyZWF0ZUVsZW1lbnQodGFnLCB2bm9kZSk7XG4gICAgICBzZXRTY29wZSh2bm9kZSk7XG5cbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAge1xuICAgICAgICBjcmVhdGVDaGlsZHJlbih2bm9kZSwgY2hpbGRyZW4sIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgICAgIGludm9rZUNyZWF0ZUhvb2tzKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICB9XG4gICAgICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGZhbHNlKSB7XG4gICAgICAgIGluUHJlLS07XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1RydWUodm5vZGUuaXNDb21tZW50KSkge1xuICAgICAgdm5vZGUuZWxtID0gbm9kZU9wcy5jcmVhdGVDb21tZW50KHZub2RlLnRleHQpO1xuICAgICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2bm9kZS5lbG0gPSBub2RlT3BzLmNyZWF0ZVRleHROb2RlKHZub2RlLnRleHQpO1xuICAgICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudCh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSkge1xuICAgIHZhciBpID0gdm5vZGUuZGF0YTtcbiAgICBpZiAoaXNEZWYoaSkpIHtcbiAgICAgIHZhciBpc1JlYWN0aXZhdGVkID0gaXNEZWYodm5vZGUuY29tcG9uZW50SW5zdGFuY2UpICYmIGkua2VlcEFsaXZlO1xuICAgICAgaWYgKGlzRGVmKGkgPSBpLmhvb2spICYmIGlzRGVmKGkgPSBpLmluaXQpKSB7XG4gICAgICAgIGkodm5vZGUsIGZhbHNlIC8qIGh5ZHJhdGluZyAqLywgcGFyZW50RWxtLCByZWZFbG0pO1xuICAgICAgfVxuICAgICAgLy8gYWZ0ZXIgY2FsbGluZyB0aGUgaW5pdCBob29rLCBpZiB0aGUgdm5vZGUgaXMgYSBjaGlsZCBjb21wb25lbnRcbiAgICAgIC8vIGl0IHNob3VsZCd2ZSBjcmVhdGVkIGEgY2hpbGQgaW5zdGFuY2UgYW5kIG1vdW50ZWQgaXQuIHRoZSBjaGlsZFxuICAgICAgLy8gY29tcG9uZW50IGFsc28gaGFzIHNldCB0aGUgcGxhY2Vob2xkZXIgdm5vZGUncyBlbG0uXG4gICAgICAvLyBpbiB0aGF0IGNhc2Ugd2UgY2FuIGp1c3QgcmV0dXJuIHRoZSBlbGVtZW50IGFuZCBiZSBkb25lLlxuICAgICAgaWYgKGlzRGVmKHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSkge1xuICAgICAgICBpbml0Q29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICBpZiAoaXNUcnVlKGlzUmVhY3RpdmF0ZWQpKSB7XG4gICAgICAgICAgcmVhY3RpdmF0ZUNvbXBvbmVudCh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW5pdENvbXBvbmVudCh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgaWYgKGlzRGVmKHZub2RlLmRhdGEucGVuZGluZ0luc2VydCkpIHtcbiAgICAgIGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoLmFwcGx5KGluc2VydGVkVm5vZGVRdWV1ZSwgdm5vZGUuZGF0YS5wZW5kaW5nSW5zZXJ0KTtcbiAgICAgIHZub2RlLmRhdGEucGVuZGluZ0luc2VydCA9IG51bGw7XG4gICAgfVxuICAgIHZub2RlLmVsbSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlLiRlbDtcbiAgICBpZiAoaXNQYXRjaGFibGUodm5vZGUpKSB7XG4gICAgICBpbnZva2VDcmVhdGVIb29rcyh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgIHNldFNjb3BlKHZub2RlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZW1wdHkgY29tcG9uZW50IHJvb3QuXG4gICAgICAvLyBza2lwIGFsbCBlbGVtZW50LXJlbGF0ZWQgbW9kdWxlcyBleGNlcHQgZm9yIHJlZiAoIzM0NTUpXG4gICAgICByZWdpc3RlclJlZih2bm9kZSk7XG4gICAgICAvLyBtYWtlIHN1cmUgdG8gaW52b2tlIHRoZSBpbnNlcnQgaG9va1xuICAgICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLnB1c2godm5vZGUpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWN0aXZhdGVDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pIHtcbiAgICB2YXIgaTtcbiAgICAvLyBoYWNrIGZvciAjNDMzOTogYSByZWFjdGl2YXRlZCBjb21wb25lbnQgd2l0aCBpbm5lciB0cmFuc2l0aW9uXG4gICAgLy8gZG9lcyBub3QgdHJpZ2dlciBiZWNhdXNlIHRoZSBpbm5lciBub2RlJ3MgY3JlYXRlZCBob29rcyBhcmUgbm90IGNhbGxlZFxuICAgIC8vIGFnYWluLiBJdCdzIG5vdCBpZGVhbCB0byBpbnZvbHZlIG1vZHVsZS1zcGVjaWZpYyBsb2dpYyBpbiBoZXJlIGJ1dFxuICAgIC8vIHRoZXJlIGRvZXNuJ3Qgc2VlbSB0byBiZSBhIGJldHRlciB3YXkgdG8gZG8gaXQuXG4gICAgdmFyIGlubmVyTm9kZSA9IHZub2RlO1xuICAgIHdoaWxlIChpbm5lck5vZGUuY29tcG9uZW50SW5zdGFuY2UpIHtcbiAgICAgIGlubmVyTm9kZSA9IGlubmVyTm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGU7XG4gICAgICBpZiAoaXNEZWYoaSA9IGlubmVyTm9kZS5kYXRhKSAmJiBpc0RlZihpID0gaS50cmFuc2l0aW9uKSkge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY2JzLmFjdGl2YXRlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgY2JzLmFjdGl2YXRlW2ldKGVtcHR5Tm9kZSwgaW5uZXJOb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpbnNlcnRlZFZub2RlUXVldWUucHVzaChpbm5lck5vZGUpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gdW5saWtlIGEgbmV3bHkgY3JlYXRlZCBjb21wb25lbnQsXG4gICAgLy8gYSByZWFjdGl2YXRlZCBrZWVwLWFsaXZlIGNvbXBvbmVudCBkb2Vzbid0IGluc2VydCBpdHNlbGZcbiAgICBpbnNlcnQocGFyZW50RWxtLCB2bm9kZS5lbG0sIHJlZkVsbSk7XG4gIH1cblxuICBmdW5jdGlvbiBpbnNlcnQocGFyZW50LCBlbG0sIHJlZiQkMSkge1xuICAgIGlmIChpc0RlZihwYXJlbnQpKSB7XG4gICAgICBpZiAoaXNEZWYocmVmJCQxKSkge1xuICAgICAgICBpZiAocmVmJCQxLnBhcmVudE5vZGUgPT09IHBhcmVudCkge1xuICAgICAgICAgIG5vZGVPcHMuaW5zZXJ0QmVmb3JlKHBhcmVudCwgZWxtLCByZWYkJDEpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlT3BzLmFwcGVuZENoaWxkKHBhcmVudCwgZWxtKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVDaGlsZHJlbih2bm9kZSwgY2hpbGRyZW4sIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7ICsraSkge1xuICAgICAgICBjcmVhdGVFbG0oY2hpbGRyZW5baV0sIGluc2VydGVkVm5vZGVRdWV1ZSwgdm5vZGUuZWxtLCBudWxsLCB0cnVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzUHJpbWl0aXZlKHZub2RlLnRleHQpKSB7XG4gICAgICBub2RlT3BzLmFwcGVuZENoaWxkKHZub2RlLmVsbSwgbm9kZU9wcy5jcmVhdGVUZXh0Tm9kZSh2bm9kZS50ZXh0KSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaXNQYXRjaGFibGUodm5vZGUpIHtcbiAgICB3aGlsZSAodm5vZGUuY29tcG9uZW50SW5zdGFuY2UpIHtcbiAgICAgIHZub2RlID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlO1xuICAgIH1cbiAgICByZXR1cm4gaXNEZWYodm5vZGUudGFnKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGludm9rZUNyZWF0ZUhvb2tzKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpIHtcbiAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBjYnMuY3JlYXRlLmxlbmd0aDsgKytpJDEpIHtcbiAgICAgIGNicy5jcmVhdGVbaSQxXShlbXB0eU5vZGUsIHZub2RlKTtcbiAgICB9XG4gICAgaSA9IHZub2RlLmRhdGEuaG9vazsgLy8gUmV1c2UgdmFyaWFibGVcbiAgICBpZiAoaXNEZWYoaSkpIHtcbiAgICAgIGlmIChpc0RlZihpLmNyZWF0ZSkpIHtcbiAgICAgICAgaS5jcmVhdGUoZW1wdHlOb2RlLCB2bm9kZSk7XG4gICAgICB9XG4gICAgICBpZiAoaXNEZWYoaS5pbnNlcnQpKSB7XG4gICAgICAgIGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoKHZub2RlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBzZXQgc2NvcGUgaWQgYXR0cmlidXRlIGZvciBzY29wZWQgQ1NTLlxuICAvLyB0aGlzIGlzIGltcGxlbWVudGVkIGFzIGEgc3BlY2lhbCBjYXNlIHRvIGF2b2lkIHRoZSBvdmVyaGVhZFxuICAvLyBvZiBnb2luZyB0aHJvdWdoIHRoZSBub3JtYWwgYXR0cmlidXRlIHBhdGNoaW5nIHByb2Nlc3MuXG4gIGZ1bmN0aW9uIHNldFNjb3BlKHZub2RlKSB7XG4gICAgdmFyIGk7XG4gICAgdmFyIGFuY2VzdG9yID0gdm5vZGU7XG4gICAgd2hpbGUgKGFuY2VzdG9yKSB7XG4gICAgICBpZiAoaXNEZWYoaSA9IGFuY2VzdG9yLmNvbnRleHQpICYmIGlzRGVmKGkgPSBpLiRvcHRpb25zLl9zY29wZUlkKSkge1xuICAgICAgICBub2RlT3BzLnNldEF0dHJpYnV0ZSh2bm9kZS5lbG0sIGksICcnKTtcbiAgICAgIH1cbiAgICAgIGFuY2VzdG9yID0gYW5jZXN0b3IucGFyZW50O1xuICAgIH1cbiAgICAvLyBmb3Igc2xvdCBjb250ZW50IHRoZXkgc2hvdWxkIGFsc28gZ2V0IHRoZSBzY29wZUlkIGZyb20gdGhlIGhvc3QgaW5zdGFuY2UuXG4gICAgaWYgKGlzRGVmKGkgPSBhY3RpdmVJbnN0YW5jZSkgJiYgaSAhPT0gdm5vZGUuY29udGV4dCAmJiBpc0RlZihpID0gaS4kb3B0aW9ucy5fc2NvcGVJZCkpIHtcbiAgICAgIG5vZGVPcHMuc2V0QXR0cmlidXRlKHZub2RlLmVsbSwgaSwgJycpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZFZub2RlcyhwYXJlbnRFbG0sIHJlZkVsbSwgdm5vZGVzLCBzdGFydElkeCwgZW5kSWR4LCBpbnNlcnRlZFZub2RlUXVldWUpIHtcbiAgICBmb3IgKDsgc3RhcnRJZHggPD0gZW5kSWR4OyArK3N0YXJ0SWR4KSB7XG4gICAgICBjcmVhdGVFbG0odm5vZGVzW3N0YXJ0SWR4XSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW52b2tlRGVzdHJveUhvb2sodm5vZGUpIHtcbiAgICB2YXIgaSwgajtcbiAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkuZGVzdHJveSkpIHtcbiAgICAgICAgaSh2bm9kZSk7XG4gICAgICB9XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgY2JzLmRlc3Ryb3kubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY2JzLmRlc3Ryb3lbaV0odm5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNEZWYoaSA9IHZub2RlLmNoaWxkcmVuKSkge1xuICAgICAgZm9yIChqID0gMDsgaiA8IHZub2RlLmNoaWxkcmVuLmxlbmd0aDsgKytqKSB7XG4gICAgICAgIGludm9rZURlc3Ryb3lIb29rKHZub2RlLmNoaWxkcmVuW2pdKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVWbm9kZXMocGFyZW50RWxtLCB2bm9kZXMsIHN0YXJ0SWR4LCBlbmRJZHgpIHtcbiAgICBmb3IgKDsgc3RhcnRJZHggPD0gZW5kSWR4OyArK3N0YXJ0SWR4KSB7XG4gICAgICB2YXIgY2ggPSB2bm9kZXNbc3RhcnRJZHhdO1xuICAgICAgaWYgKGlzRGVmKGNoKSkge1xuICAgICAgICBpZiAoaXNEZWYoY2gudGFnKSkge1xuICAgICAgICAgIHJlbW92ZUFuZEludm9rZVJlbW92ZUhvb2soY2gpO1xuICAgICAgICAgIGludm9rZURlc3Ryb3lIb29rKGNoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBUZXh0IG5vZGVcbiAgICAgICAgICByZW1vdmVOb2RlKGNoLmVsbSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVBbmRJbnZva2VSZW1vdmVIb29rKHZub2RlLCBybSkge1xuICAgIGlmIChpc0RlZihybSkgfHwgaXNEZWYodm5vZGUuZGF0YSkpIHtcbiAgICAgIHZhciBpO1xuICAgICAgdmFyIGxpc3RlbmVycyA9IGNicy5yZW1vdmUubGVuZ3RoICsgMTtcbiAgICAgIGlmIChpc0RlZihybSkpIHtcbiAgICAgICAgLy8gd2UgaGF2ZSBhIHJlY3Vyc2l2ZWx5IHBhc3NlZCBkb3duIHJtIGNhbGxiYWNrXG4gICAgICAgIC8vIGluY3JlYXNlIHRoZSBsaXN0ZW5lcnMgY291bnRcbiAgICAgICAgcm0ubGlzdGVuZXJzICs9IGxpc3RlbmVycztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGRpcmVjdGx5IHJlbW92aW5nXG4gICAgICAgIHJtID0gY3JlYXRlUm1DYih2bm9kZS5lbG0sIGxpc3RlbmVycyk7XG4gICAgICB9XG4gICAgICAvLyByZWN1cnNpdmVseSBpbnZva2UgaG9va3Mgb24gY2hpbGQgY29tcG9uZW50IHJvb3Qgbm9kZVxuICAgICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkgJiYgaXNEZWYoaSA9IGkuX3Zub2RlKSAmJiBpc0RlZihpLmRhdGEpKSB7XG4gICAgICAgIHJlbW92ZUFuZEludm9rZVJlbW92ZUhvb2soaSwgcm0pO1xuICAgICAgfVxuICAgICAgZm9yIChpID0gMDsgaSA8IGNicy5yZW1vdmUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY2JzLnJlbW92ZVtpXSh2bm9kZSwgcm0pO1xuICAgICAgfVxuICAgICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5kYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLnJlbW92ZSkpIHtcbiAgICAgICAgaSh2bm9kZSwgcm0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcm0oKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmVtb3ZlTm9kZSh2bm9kZS5lbG0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUNoaWxkcmVuKHBhcmVudEVsbSwgb2xkQ2gsIG5ld0NoLCBpbnNlcnRlZFZub2RlUXVldWUsIHJlbW92ZU9ubHkpIHtcbiAgICB2YXIgb2xkU3RhcnRJZHggPSAwO1xuICAgIHZhciBuZXdTdGFydElkeCA9IDA7XG4gICAgdmFyIG9sZEVuZElkeCA9IG9sZENoLmxlbmd0aCAtIDE7XG4gICAgdmFyIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFswXTtcbiAgICB2YXIgb2xkRW5kVm5vZGUgPSBvbGRDaFtvbGRFbmRJZHhdO1xuICAgIHZhciBuZXdFbmRJZHggPSBuZXdDaC5sZW5ndGggLSAxO1xuICAgIHZhciBuZXdTdGFydFZub2RlID0gbmV3Q2hbMF07XG4gICAgdmFyIG5ld0VuZFZub2RlID0gbmV3Q2hbbmV3RW5kSWR4XTtcbiAgICB2YXIgb2xkS2V5VG9JZHgsIGlkeEluT2xkLCBlbG1Ub01vdmUsIHJlZkVsbTtcblxuICAgIC8vIHJlbW92ZU9ubHkgaXMgYSBzcGVjaWFsIGZsYWcgdXNlZCBvbmx5IGJ5IDx0cmFuc2l0aW9uLWdyb3VwPlxuICAgIC8vIHRvIGVuc3VyZSByZW1vdmVkIGVsZW1lbnRzIHN0YXkgaW4gY29ycmVjdCByZWxhdGl2ZSBwb3NpdGlvbnNcbiAgICAvLyBkdXJpbmcgbGVhdmluZyB0cmFuc2l0aW9uc1xuICAgIHZhciBjYW5Nb3ZlID0gIXJlbW92ZU9ubHk7XG5cbiAgICB3aGlsZSAob2xkU3RhcnRJZHggPD0gb2xkRW5kSWR4ICYmIG5ld1N0YXJ0SWR4IDw9IG5ld0VuZElkeCkge1xuICAgICAgaWYgKGlzVW5kZWYob2xkU3RhcnRWbm9kZSkpIHtcbiAgICAgICAgb2xkU3RhcnRWbm9kZSA9IG9sZENoWysrb2xkU3RhcnRJZHhdOyAvLyBWbm9kZSBoYXMgYmVlbiBtb3ZlZCBsZWZ0XG4gICAgICB9IGVsc2UgaWYgKGlzVW5kZWYob2xkRW5kVm5vZGUpKSB7XG4gICAgICAgIG9sZEVuZFZub2RlID0gb2xkQ2hbLS1vbGRFbmRJZHhdO1xuICAgICAgfSBlbHNlIGlmIChzYW1lVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3U3RhcnRWbm9kZSkpIHtcbiAgICAgICAgcGF0Y2hWbm9kZShvbGRTdGFydFZub2RlLCBuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICBvbGRTdGFydFZub2RlID0gb2xkQ2hbKytvbGRTdGFydElkeF07XG4gICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgIH0gZWxzZSBpZiAoc2FtZVZub2RlKG9sZEVuZFZub2RlLCBuZXdFbmRWbm9kZSkpIHtcbiAgICAgICAgcGF0Y2hWbm9kZShvbGRFbmRWbm9kZSwgbmV3RW5kVm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIG9sZEVuZFZub2RlID0gb2xkQ2hbLS1vbGRFbmRJZHhdO1xuICAgICAgICBuZXdFbmRWbm9kZSA9IG5ld0NoWy0tbmV3RW5kSWR4XTtcbiAgICAgIH0gZWxzZSBpZiAoc2FtZVZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld0VuZFZub2RlKSkge1xuICAgICAgICAvLyBWbm9kZSBtb3ZlZCByaWdodFxuICAgICAgICBwYXRjaFZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld0VuZFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICBjYW5Nb3ZlICYmIG5vZGVPcHMuaW5zZXJ0QmVmb3JlKHBhcmVudEVsbSwgb2xkU3RhcnRWbm9kZS5lbG0sIG5vZGVPcHMubmV4dFNpYmxpbmcob2xkRW5kVm5vZGUuZWxtKSk7XG4gICAgICAgIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFsrK29sZFN0YXJ0SWR4XTtcbiAgICAgICAgbmV3RW5kVm5vZGUgPSBuZXdDaFstLW5ld0VuZElkeF07XG4gICAgICB9IGVsc2UgaWYgKHNhbWVWbm9kZShvbGRFbmRWbm9kZSwgbmV3U3RhcnRWbm9kZSkpIHtcbiAgICAgICAgLy8gVm5vZGUgbW92ZWQgbGVmdFxuICAgICAgICBwYXRjaFZub2RlKG9sZEVuZFZub2RlLCBuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICBjYW5Nb3ZlICYmIG5vZGVPcHMuaW5zZXJ0QmVmb3JlKHBhcmVudEVsbSwgb2xkRW5kVm5vZGUuZWxtLCBvbGRTdGFydFZub2RlLmVsbSk7XG4gICAgICAgIG9sZEVuZFZub2RlID0gb2xkQ2hbLS1vbGRFbmRJZHhdO1xuICAgICAgICBuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaXNVbmRlZihvbGRLZXlUb0lkeCkpIHtcbiAgICAgICAgICBvbGRLZXlUb0lkeCA9IGNyZWF0ZUtleVRvT2xkSWR4KG9sZENoLCBvbGRTdGFydElkeCwgb2xkRW5kSWR4KTtcbiAgICAgICAgfVxuICAgICAgICBpZHhJbk9sZCA9IGlzRGVmKG5ld1N0YXJ0Vm5vZGUua2V5KSA/IG9sZEtleVRvSWR4W25ld1N0YXJ0Vm5vZGUua2V5XSA6IGZpbmRJZHhJbk9sZChuZXdTdGFydFZub2RlLCBvbGRDaCwgb2xkU3RhcnRJZHgsIG9sZEVuZElkeCk7XG4gICAgICAgIGlmIChpc1VuZGVmKGlkeEluT2xkKSkge1xuICAgICAgICAgIC8vIE5ldyBlbGVtZW50XG4gICAgICAgICAgY3JlYXRlRWxtKG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCBvbGRTdGFydFZub2RlLmVsbSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZWxtVG9Nb3ZlID0gb2xkQ2hbaWR4SW5PbGRdO1xuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgIGlmIChmYWxzZSkge1xuICAgICAgICAgICAgd2FybignSXQgc2VlbXMgdGhlcmUgYXJlIGR1cGxpY2F0ZSBrZXlzIHRoYXQgaXMgY2F1c2luZyBhbiB1cGRhdGUgZXJyb3IuICcgKyAnTWFrZSBzdXJlIGVhY2ggdi1mb3IgaXRlbSBoYXMgYSB1bmlxdWUga2V5LicpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc2FtZVZub2RlKGVsbVRvTW92ZSwgbmV3U3RhcnRWbm9kZSkpIHtcbiAgICAgICAgICAgIHBhdGNoVm5vZGUoZWxtVG9Nb3ZlLCBuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICAgICAgb2xkQ2hbaWR4SW5PbGRdID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgY2FuTW92ZSAmJiBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnRFbG0sIGVsbVRvTW92ZS5lbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gc2FtZSBrZXkgYnV0IGRpZmZlcmVudCBlbGVtZW50LiB0cmVhdCBhcyBuZXcgZWxlbWVudFxuICAgICAgICAgICAgY3JlYXRlRWxtKG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCBvbGRTdGFydFZub2RlLmVsbSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9sZFN0YXJ0SWR4ID4gb2xkRW5kSWR4KSB7XG4gICAgICByZWZFbG0gPSBpc1VuZGVmKG5ld0NoW25ld0VuZElkeCArIDFdKSA/IG51bGwgOiBuZXdDaFtuZXdFbmRJZHggKyAxXS5lbG07XG4gICAgICBhZGRWbm9kZXMocGFyZW50RWxtLCByZWZFbG0sIG5ld0NoLCBuZXdTdGFydElkeCwgbmV3RW5kSWR4LCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgIH0gZWxzZSBpZiAobmV3U3RhcnRJZHggPiBuZXdFbmRJZHgpIHtcbiAgICAgIHJlbW92ZVZub2RlcyhwYXJlbnRFbG0sIG9sZENoLCBvbGRTdGFydElkeCwgb2xkRW5kSWR4KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBmaW5kSWR4SW5PbGQobm9kZSwgb2xkQ2gsIHN0YXJ0LCBlbmQpIHtcbiAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgdmFyIGMgPSBvbGRDaFtpXTtcbiAgICAgIGlmIChpc0RlZihjKSAmJiBzYW1lVm5vZGUobm9kZSwgYykpIHtcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcGF0Y2hWbm9kZShvbGRWbm9kZSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcmVtb3ZlT25seSkge1xuICAgIGlmIChvbGRWbm9kZSA9PT0gdm5vZGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgZWxtID0gdm5vZGUuZWxtID0gb2xkVm5vZGUuZWxtO1xuXG4gICAgaWYgKGlzVHJ1ZShvbGRWbm9kZS5pc0FzeW5jUGxhY2Vob2xkZXIpKSB7XG4gICAgICBpZiAoaXNEZWYodm5vZGUuYXN5bmNGYWN0b3J5LnJlc29sdmVkKSkge1xuICAgICAgICBoeWRyYXRlKG9sZFZub2RlLmVsbSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2bm9kZS5pc0FzeW5jUGxhY2Vob2xkZXIgPSB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIHJldXNlIGVsZW1lbnQgZm9yIHN0YXRpYyB0cmVlcy5cbiAgICAvLyBub3RlIHdlIG9ubHkgZG8gdGhpcyBpZiB0aGUgdm5vZGUgaXMgY2xvbmVkIC1cbiAgICAvLyBpZiB0aGUgbmV3IG5vZGUgaXMgbm90IGNsb25lZCBpdCBtZWFucyB0aGUgcmVuZGVyIGZ1bmN0aW9ucyBoYXZlIGJlZW5cbiAgICAvLyByZXNldCBieSB0aGUgaG90LXJlbG9hZC1hcGkgYW5kIHdlIG5lZWQgdG8gZG8gYSBwcm9wZXIgcmUtcmVuZGVyLlxuICAgIGlmIChpc1RydWUodm5vZGUuaXNTdGF0aWMpICYmIGlzVHJ1ZShvbGRWbm9kZS5pc1N0YXRpYykgJiYgdm5vZGUua2V5ID09PSBvbGRWbm9kZS5rZXkgJiYgKGlzVHJ1ZSh2bm9kZS5pc0Nsb25lZCkgfHwgaXNUcnVlKHZub2RlLmlzT25jZSkpKSB7XG4gICAgICB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSA9IG9sZFZub2RlLmNvbXBvbmVudEluc3RhbmNlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBpO1xuICAgIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgICBpZiAoaXNEZWYoZGF0YSkgJiYgaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkucHJlcGF0Y2gpKSB7XG4gICAgICBpKG9sZFZub2RlLCB2bm9kZSk7XG4gICAgfVxuXG4gICAgdmFyIG9sZENoID0gb2xkVm5vZGUuY2hpbGRyZW47XG4gICAgdmFyIGNoID0gdm5vZGUuY2hpbGRyZW47XG4gICAgaWYgKGlzRGVmKGRhdGEpICYmIGlzUGF0Y2hhYmxlKHZub2RlKSkge1xuICAgICAgZm9yIChpID0gMDsgaSA8IGNicy51cGRhdGUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY2JzLnVwZGF0ZVtpXShvbGRWbm9kZSwgdm5vZGUpO1xuICAgICAgfVxuICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLnVwZGF0ZSkpIHtcbiAgICAgICAgaShvbGRWbm9kZSwgdm5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNVbmRlZih2bm9kZS50ZXh0KSkge1xuICAgICAgaWYgKGlzRGVmKG9sZENoKSAmJiBpc0RlZihjaCkpIHtcbiAgICAgICAgaWYgKG9sZENoICE9PSBjaCkge1xuICAgICAgICAgIHVwZGF0ZUNoaWxkcmVuKGVsbSwgb2xkQ2gsIGNoLCBpbnNlcnRlZFZub2RlUXVldWUsIHJlbW92ZU9ubHkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGlzRGVmKGNoKSkge1xuICAgICAgICBpZiAoaXNEZWYob2xkVm5vZGUudGV4dCkpIHtcbiAgICAgICAgICBub2RlT3BzLnNldFRleHRDb250ZW50KGVsbSwgJycpO1xuICAgICAgICB9XG4gICAgICAgIGFkZFZub2RlcyhlbG0sIG51bGwsIGNoLCAwLCBjaC5sZW5ndGggLSAxLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgfSBlbHNlIGlmIChpc0RlZihvbGRDaCkpIHtcbiAgICAgICAgcmVtb3ZlVm5vZGVzKGVsbSwgb2xkQ2gsIDAsIG9sZENoLmxlbmd0aCAtIDEpO1xuICAgICAgfSBlbHNlIGlmIChpc0RlZihvbGRWbm9kZS50ZXh0KSkge1xuICAgICAgICBub2RlT3BzLnNldFRleHRDb250ZW50KGVsbSwgJycpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAob2xkVm5vZGUudGV4dCAhPT0gdm5vZGUudGV4dCkge1xuICAgICAgbm9kZU9wcy5zZXRUZXh0Q29udGVudChlbG0sIHZub2RlLnRleHQpO1xuICAgIH1cbiAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgIGlmIChpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5wb3N0cGF0Y2gpKSB7XG4gICAgICAgIGkob2xkVm5vZGUsIHZub2RlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbnZva2VJbnNlcnRIb29rKHZub2RlLCBxdWV1ZSwgaW5pdGlhbCkge1xuICAgIC8vIGRlbGF5IGluc2VydCBob29rcyBmb3IgY29tcG9uZW50IHJvb3Qgbm9kZXMsIGludm9rZSB0aGVtIGFmdGVyIHRoZVxuICAgIC8vIGVsZW1lbnQgaXMgcmVhbGx5IGluc2VydGVkXG4gICAgaWYgKGlzVHJ1ZShpbml0aWFsKSAmJiBpc0RlZih2bm9kZS5wYXJlbnQpKSB7XG4gICAgICB2bm9kZS5wYXJlbnQuZGF0YS5wZW5kaW5nSW5zZXJ0ID0gcXVldWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgcXVldWVbaV0uZGF0YS5ob29rLmluc2VydChxdWV1ZVtpXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGJhaWxlZCA9IGZhbHNlO1xuICAvLyBsaXN0IG9mIG1vZHVsZXMgdGhhdCBjYW4gc2tpcCBjcmVhdGUgaG9vayBkdXJpbmcgaHlkcmF0aW9uIGJlY2F1c2UgdGhleVxuICAvLyBhcmUgYWxyZWFkeSByZW5kZXJlZCBvbiB0aGUgY2xpZW50IG9yIGhhcyBubyBuZWVkIGZvciBpbml0aWFsaXphdGlvblxuICB2YXIgaXNSZW5kZXJlZE1vZHVsZSA9IG1ha2VNYXAoJ2F0dHJzLHN0eWxlLGNsYXNzLHN0YXRpY0NsYXNzLHN0YXRpY1N0eWxlLGtleScpO1xuXG4gIC8vIE5vdGU6IHRoaXMgaXMgYSBicm93c2VyLW9ubHkgZnVuY3Rpb24gc28gd2UgY2FuIGFzc3VtZSBlbG1zIGFyZSBET00gbm9kZXMuXG4gIGZ1bmN0aW9uIGh5ZHJhdGUoZWxtLCB2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgaWYgKGlzVHJ1ZSh2bm9kZS5pc0NvbW1lbnQpICYmIGlzRGVmKHZub2RlLmFzeW5jRmFjdG9yeSkpIHtcbiAgICAgIHZub2RlLmVsbSA9IGVsbTtcbiAgICAgIHZub2RlLmlzQXN5bmNQbGFjZWhvbGRlciA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGZhbHNlKSB7XG4gICAgICBpZiAoIWFzc2VydE5vZGVNYXRjaChlbG0sIHZub2RlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHZub2RlLmVsbSA9IGVsbTtcbiAgICB2YXIgdGFnID0gdm5vZGUudGFnO1xuICAgIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgICB2YXIgY2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlbjtcbiAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgIGlmIChpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5pbml0KSkge1xuICAgICAgICBpKHZub2RlLCB0cnVlIC8qIGh5ZHJhdGluZyAqLyk7XG4gICAgICB9XG4gICAgICBpZiAoaXNEZWYoaSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSkge1xuICAgICAgICAvLyBjaGlsZCBjb21wb25lbnQuIGl0IHNob3VsZCBoYXZlIGh5ZHJhdGVkIGl0cyBvd24gdHJlZS5cbiAgICAgICAgaW5pdENvbXBvbmVudCh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc0RlZih0YWcpKSB7XG4gICAgICBpZiAoaXNEZWYoY2hpbGRyZW4pKSB7XG4gICAgICAgIC8vIGVtcHR5IGVsZW1lbnQsIGFsbG93IGNsaWVudCB0byBwaWNrIHVwIGFuZCBwb3B1bGF0ZSBjaGlsZHJlblxuICAgICAgICBpZiAoIWVsbS5oYXNDaGlsZE5vZGVzKCkpIHtcbiAgICAgICAgICBjcmVhdGVDaGlsZHJlbih2bm9kZSwgY2hpbGRyZW4sIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gdi1odG1sIGFuZCBkb21Qcm9wczogaW5uZXJIVE1MXG4gICAgICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhKSAmJiBpc0RlZihpID0gaS5kb21Qcm9wcykgJiYgaXNEZWYoaSA9IGkuaW5uZXJIVE1MKSkge1xuICAgICAgICAgICAgaWYgKGkgIT09IGVsbS5pbm5lckhUTUwpIHtcbiAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICAgIGlmIChmYWxzZSkge1xuICAgICAgICAgICAgICAgIGJhaWxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdQYXJlbnQ6ICcsIGVsbSk7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdzZXJ2ZXIgaW5uZXJIVE1MOiAnLCBpKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ2NsaWVudCBpbm5lckhUTUw6ICcsIGVsbS5pbm5lckhUTUwpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gaXRlcmF0ZSBhbmQgY29tcGFyZSBjaGlsZHJlbiBsaXN0c1xuICAgICAgICAgICAgdmFyIGNoaWxkcmVuTWF0Y2ggPSB0cnVlO1xuICAgICAgICAgICAgdmFyIGNoaWxkTm9kZSA9IGVsbS5maXJzdENoaWxkO1xuICAgICAgICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgY2hpbGRyZW4ubGVuZ3RoOyBpJDErKykge1xuICAgICAgICAgICAgICBpZiAoIWNoaWxkTm9kZSB8fCAhaHlkcmF0ZShjaGlsZE5vZGUsIGNoaWxkcmVuW2kkMV0sIGluc2VydGVkVm5vZGVRdWV1ZSkpIHtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbk1hdGNoID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2hpbGROb2RlID0gY2hpbGROb2RlLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaWYgY2hpbGROb2RlIGlzIG5vdCBudWxsLCBpdCBtZWFucyB0aGUgYWN0dWFsIGNoaWxkTm9kZXMgbGlzdCBpc1xuICAgICAgICAgICAgLy8gbG9uZ2VyIHRoYW4gdGhlIHZpcnR1YWwgY2hpbGRyZW4gbGlzdC5cbiAgICAgICAgICAgIGlmICghY2hpbGRyZW5NYXRjaCB8fCBjaGlsZE5vZGUpIHtcbiAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICAgIGlmIChmYWxzZSkge1xuICAgICAgICAgICAgICAgIGJhaWxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdQYXJlbnQ6ICcsIGVsbSk7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdNaXNtYXRjaGluZyBjaGlsZE5vZGVzIHZzLiBWTm9kZXM6ICcsIGVsbS5jaGlsZE5vZGVzLCBjaGlsZHJlbik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBkYXRhKSB7XG4gICAgICAgICAgaWYgKCFpc1JlbmRlcmVkTW9kdWxlKGtleSkpIHtcbiAgICAgICAgICAgIGludm9rZUNyZWF0ZUhvb2tzKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChlbG0uZGF0YSAhPT0gdm5vZGUudGV4dCkge1xuICAgICAgZWxtLmRhdGEgPSB2bm9kZS50ZXh0O1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFzc2VydE5vZGVNYXRjaChub2RlLCB2bm9kZSkge1xuICAgIGlmIChpc0RlZih2bm9kZS50YWcpKSB7XG4gICAgICByZXR1cm4gdm5vZGUudGFnLmluZGV4T2YoJ3Z1ZS1jb21wb25lbnQnKSA9PT0gMCB8fCB2bm9kZS50YWcudG9Mb3dlckNhc2UoKSA9PT0gKG5vZGUudGFnTmFtZSAmJiBub2RlLnRhZ05hbWUudG9Mb3dlckNhc2UoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBub2RlLm5vZGVUeXBlID09PSAodm5vZGUuaXNDb21tZW50ID8gOCA6IDMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiBwYXRjaChvbGRWbm9kZSwgdm5vZGUsIGh5ZHJhdGluZywgcmVtb3ZlT25seSwgcGFyZW50RWxtLCByZWZFbG0pIHtcbiAgICBpZiAoaXNVbmRlZih2bm9kZSkpIHtcbiAgICAgIGlmIChpc0RlZihvbGRWbm9kZSkpIHtcbiAgICAgICAgaW52b2tlRGVzdHJveUhvb2sob2xkVm5vZGUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBpc0luaXRpYWxQYXRjaCA9IGZhbHNlO1xuICAgIHZhciBpbnNlcnRlZFZub2RlUXVldWUgPSBbXTtcblxuICAgIGlmIChpc1VuZGVmKG9sZFZub2RlKSkge1xuICAgICAgLy8gZW1wdHkgbW91bnQgKGxpa2VseSBhcyBjb21wb25lbnQpLCBjcmVhdGUgbmV3IHJvb3QgZWxlbWVudFxuICAgICAgaXNJbml0aWFsUGF0Y2ggPSB0cnVlO1xuICAgICAgY3JlYXRlRWxtKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGlzUmVhbEVsZW1lbnQgPSBpc0RlZihvbGRWbm9kZS5ub2RlVHlwZSk7XG4gICAgICBpZiAoIWlzUmVhbEVsZW1lbnQgJiYgc2FtZVZub2RlKG9sZFZub2RlLCB2bm9kZSkpIHtcbiAgICAgICAgLy8gcGF0Y2ggZXhpc3Rpbmcgcm9vdCBub2RlXG4gICAgICAgIHBhdGNoVm5vZGUob2xkVm5vZGUsIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHJlbW92ZU9ubHkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGlzUmVhbEVsZW1lbnQpIHtcbiAgICAgICAgICAvLyBtb3VudGluZyB0byBhIHJlYWwgZWxlbWVudFxuICAgICAgICAgIC8vIGNoZWNrIGlmIHRoaXMgaXMgc2VydmVyLXJlbmRlcmVkIGNvbnRlbnQgYW5kIGlmIHdlIGNhbiBwZXJmb3JtXG4gICAgICAgICAgLy8gYSBzdWNjZXNzZnVsIGh5ZHJhdGlvbi5cbiAgICAgICAgICBpZiAob2xkVm5vZGUubm9kZVR5cGUgPT09IDEgJiYgb2xkVm5vZGUuaGFzQXR0cmlidXRlKFNTUl9BVFRSKSkge1xuICAgICAgICAgICAgb2xkVm5vZGUucmVtb3ZlQXR0cmlidXRlKFNTUl9BVFRSKTtcbiAgICAgICAgICAgIGh5ZHJhdGluZyA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc1RydWUoaHlkcmF0aW5nKSkge1xuICAgICAgICAgICAgaWYgKGh5ZHJhdGUob2xkVm5vZGUsIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpKSB7XG4gICAgICAgICAgICAgIGludm9rZUluc2VydEhvb2sodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgIHJldHVybiBvbGRWbm9kZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZmFsc2UpIHtcbiAgICAgICAgICAgICAgd2FybignVGhlIGNsaWVudC1zaWRlIHJlbmRlcmVkIHZpcnR1YWwgRE9NIHRyZWUgaXMgbm90IG1hdGNoaW5nICcgKyAnc2VydmVyLXJlbmRlcmVkIGNvbnRlbnQuIFRoaXMgaXMgbGlrZWx5IGNhdXNlZCBieSBpbmNvcnJlY3QgJyArICdIVE1MIG1hcmt1cCwgZm9yIGV4YW1wbGUgbmVzdGluZyBibG9jay1sZXZlbCBlbGVtZW50cyBpbnNpZGUgJyArICc8cD4sIG9yIG1pc3NpbmcgPHRib2R5Pi4gQmFpbGluZyBoeWRyYXRpb24gYW5kIHBlcmZvcm1pbmcgJyArICdmdWxsIGNsaWVudC1zaWRlIHJlbmRlci4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gZWl0aGVyIG5vdCBzZXJ2ZXItcmVuZGVyZWQsIG9yIGh5ZHJhdGlvbiBmYWlsZWQuXG4gICAgICAgICAgLy8gY3JlYXRlIGFuIGVtcHR5IG5vZGUgYW5kIHJlcGxhY2UgaXRcbiAgICAgICAgICBvbGRWbm9kZSA9IGVtcHR5Tm9kZUF0KG9sZFZub2RlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyByZXBsYWNpbmcgZXhpc3RpbmcgZWxlbWVudFxuICAgICAgICB2YXIgb2xkRWxtID0gb2xkVm5vZGUuZWxtO1xuICAgICAgICB2YXIgcGFyZW50RWxtJDEgPSBub2RlT3BzLnBhcmVudE5vZGUob2xkRWxtKTtcbiAgICAgICAgY3JlYXRlRWxtKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsXG4gICAgICAgIC8vIGV4dHJlbWVseSByYXJlIGVkZ2UgY2FzZTogZG8gbm90IGluc2VydCBpZiBvbGQgZWxlbWVudCBpcyBpbiBhXG4gICAgICAgIC8vIGxlYXZpbmcgdHJhbnNpdGlvbi4gT25seSBoYXBwZW5zIHdoZW4gY29tYmluaW5nIHRyYW5zaXRpb24gK1xuICAgICAgICAvLyBrZWVwLWFsaXZlICsgSE9Dcy4gKCM0NTkwKVxuICAgICAgICBvbGRFbG0uX2xlYXZlQ2IgPyBudWxsIDogcGFyZW50RWxtJDEsIG5vZGVPcHMubmV4dFNpYmxpbmcob2xkRWxtKSk7XG5cbiAgICAgICAgaWYgKGlzRGVmKHZub2RlLnBhcmVudCkpIHtcbiAgICAgICAgICAvLyBjb21wb25lbnQgcm9vdCBlbGVtZW50IHJlcGxhY2VkLlxuICAgICAgICAgIC8vIHVwZGF0ZSBwYXJlbnQgcGxhY2Vob2xkZXIgbm9kZSBlbGVtZW50LCByZWN1cnNpdmVseVxuICAgICAgICAgIHZhciBhbmNlc3RvciA9IHZub2RlLnBhcmVudDtcbiAgICAgICAgICB2YXIgcGF0Y2hhYmxlID0gaXNQYXRjaGFibGUodm5vZGUpO1xuICAgICAgICAgIHdoaWxlIChhbmNlc3Rvcikge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYnMuZGVzdHJveS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICBjYnMuZGVzdHJveVtpXShhbmNlc3Rvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhbmNlc3Rvci5lbG0gPSB2bm9kZS5lbG07XG4gICAgICAgICAgICBpZiAocGF0Y2hhYmxlKSB7XG4gICAgICAgICAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGNicy5jcmVhdGUubGVuZ3RoOyArK2kkMSkge1xuICAgICAgICAgICAgICAgIGNicy5jcmVhdGVbaSQxXShlbXB0eU5vZGUsIGFuY2VzdG9yKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyAjNjUxM1xuICAgICAgICAgICAgICAvLyBpbnZva2UgaW5zZXJ0IGhvb2tzIHRoYXQgbWF5IGhhdmUgYmVlbiBtZXJnZWQgYnkgY3JlYXRlIGhvb2tzLlxuICAgICAgICAgICAgICAvLyBlLmcuIGZvciBkaXJlY3RpdmVzIHRoYXQgdXNlcyB0aGUgXCJpbnNlcnRlZFwiIGhvb2suXG4gICAgICAgICAgICAgIHZhciBpbnNlcnQgPSBhbmNlc3Rvci5kYXRhLmhvb2suaW5zZXJ0O1xuICAgICAgICAgICAgICBpZiAoaW5zZXJ0Lm1lcmdlZCkge1xuICAgICAgICAgICAgICAgIC8vIHN0YXJ0IGF0IGluZGV4IDEgdG8gYXZvaWQgcmUtaW52b2tpbmcgY29tcG9uZW50IG1vdW50ZWQgaG9va1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkkMiA9IDE7IGkkMiA8IGluc2VydC5mbnMubGVuZ3RoOyBpJDIrKykge1xuICAgICAgICAgICAgICAgICAgaW5zZXJ0LmZuc1tpJDJdKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhbmNlc3RvciA9IGFuY2VzdG9yLnBhcmVudDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNEZWYocGFyZW50RWxtJDEpKSB7XG4gICAgICAgICAgcmVtb3ZlVm5vZGVzKHBhcmVudEVsbSQxLCBbb2xkVm5vZGVdLCAwLCAwKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0RlZihvbGRWbm9kZS50YWcpKSB7XG4gICAgICAgICAgaW52b2tlRGVzdHJveUhvb2sob2xkVm5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaW52b2tlSW5zZXJ0SG9vayh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBpc0luaXRpYWxQYXRjaCk7XG4gICAgcmV0dXJuIHZub2RlLmVsbTtcbiAgfTtcbn1cblxuLyogICovXG5cbnZhciBkaXJlY3RpdmVzID0ge1xuICBjcmVhdGU6IHVwZGF0ZURpcmVjdGl2ZXMsXG4gIHVwZGF0ZTogdXBkYXRlRGlyZWN0aXZlcyxcbiAgZGVzdHJveTogZnVuY3Rpb24gdW5iaW5kRGlyZWN0aXZlcyh2bm9kZSkge1xuICAgIHVwZGF0ZURpcmVjdGl2ZXModm5vZGUsIGVtcHR5Tm9kZSk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHVwZGF0ZURpcmVjdGl2ZXMob2xkVm5vZGUsIHZub2RlKSB7XG4gIGlmIChvbGRWbm9kZS5kYXRhLmRpcmVjdGl2ZXMgfHwgdm5vZGUuZGF0YS5kaXJlY3RpdmVzKSB7XG4gICAgX3VwZGF0ZShvbGRWbm9kZSwgdm5vZGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF91cGRhdGUob2xkVm5vZGUsIHZub2RlKSB7XG4gIHZhciBpc0NyZWF0ZSA9IG9sZFZub2RlID09PSBlbXB0eU5vZGU7XG4gIHZhciBpc0Rlc3Ryb3kgPSB2bm9kZSA9PT0gZW1wdHlOb2RlO1xuICB2YXIgb2xkRGlycyA9IG5vcm1hbGl6ZURpcmVjdGl2ZXMkMShvbGRWbm9kZS5kYXRhLmRpcmVjdGl2ZXMsIG9sZFZub2RlLmNvbnRleHQpO1xuICB2YXIgbmV3RGlycyA9IG5vcm1hbGl6ZURpcmVjdGl2ZXMkMSh2bm9kZS5kYXRhLmRpcmVjdGl2ZXMsIHZub2RlLmNvbnRleHQpO1xuXG4gIHZhciBkaXJzV2l0aEluc2VydCA9IFtdO1xuICB2YXIgZGlyc1dpdGhQb3N0cGF0Y2ggPSBbXTtcblxuICB2YXIga2V5LCBvbGREaXIsIGRpcjtcbiAgZm9yIChrZXkgaW4gbmV3RGlycykge1xuICAgIG9sZERpciA9IG9sZERpcnNba2V5XTtcbiAgICBkaXIgPSBuZXdEaXJzW2tleV07XG4gICAgaWYgKCFvbGREaXIpIHtcbiAgICAgIC8vIG5ldyBkaXJlY3RpdmUsIGJpbmRcbiAgICAgIGNhbGxIb29rJDEoZGlyLCAnYmluZCcsIHZub2RlLCBvbGRWbm9kZSk7XG4gICAgICBpZiAoZGlyLmRlZiAmJiBkaXIuZGVmLmluc2VydGVkKSB7XG4gICAgICAgIGRpcnNXaXRoSW5zZXJ0LnB1c2goZGlyKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZXhpc3RpbmcgZGlyZWN0aXZlLCB1cGRhdGVcbiAgICAgIGRpci5vbGRWYWx1ZSA9IG9sZERpci52YWx1ZTtcbiAgICAgIGNhbGxIb29rJDEoZGlyLCAndXBkYXRlJywgdm5vZGUsIG9sZFZub2RlKTtcbiAgICAgIGlmIChkaXIuZGVmICYmIGRpci5kZWYuY29tcG9uZW50VXBkYXRlZCkge1xuICAgICAgICBkaXJzV2l0aFBvc3RwYXRjaC5wdXNoKGRpcik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGRpcnNXaXRoSW5zZXJ0Lmxlbmd0aCkge1xuICAgIHZhciBjYWxsSW5zZXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXJzV2l0aEluc2VydC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjYWxsSG9vayQxKGRpcnNXaXRoSW5zZXJ0W2ldLCAnaW5zZXJ0ZWQnLCB2bm9kZSwgb2xkVm5vZGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgaWYgKGlzQ3JlYXRlKSB7XG4gICAgICBtZXJnZVZOb2RlSG9vayh2bm9kZS5kYXRhLmhvb2sgfHwgKHZub2RlLmRhdGEuaG9vayA9IHt9KSwgJ2luc2VydCcsIGNhbGxJbnNlcnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYWxsSW5zZXJ0KCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGRpcnNXaXRoUG9zdHBhdGNoLmxlbmd0aCkge1xuICAgIG1lcmdlVk5vZGVIb29rKHZub2RlLmRhdGEuaG9vayB8fCAodm5vZGUuZGF0YS5ob29rID0ge30pLCAncG9zdHBhdGNoJywgZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXJzV2l0aFBvc3RwYXRjaC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjYWxsSG9vayQxKGRpcnNXaXRoUG9zdHBhdGNoW2ldLCAnY29tcG9uZW50VXBkYXRlZCcsIHZub2RlLCBvbGRWbm9kZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBpZiAoIWlzQ3JlYXRlKSB7XG4gICAgZm9yIChrZXkgaW4gb2xkRGlycykge1xuICAgICAgaWYgKCFuZXdEaXJzW2tleV0pIHtcbiAgICAgICAgLy8gbm8gbG9uZ2VyIHByZXNlbnQsIHVuYmluZFxuICAgICAgICBjYWxsSG9vayQxKG9sZERpcnNba2V5XSwgJ3VuYmluZCcsIG9sZFZub2RlLCBvbGRWbm9kZSwgaXNEZXN0cm95KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxudmFyIGVtcHR5TW9kaWZpZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuZnVuY3Rpb24gbm9ybWFsaXplRGlyZWN0aXZlcyQxKGRpcnMsIHZtKSB7XG4gIHZhciByZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBpZiAoIWRpcnMpIHtcbiAgICByZXR1cm4gcmVzO1xuICB9XG4gIHZhciBpLCBkaXI7XG4gIGZvciAoaSA9IDA7IGkgPCBkaXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgZGlyID0gZGlyc1tpXTtcbiAgICBpZiAoIWRpci5tb2RpZmllcnMpIHtcbiAgICAgIGRpci5tb2RpZmllcnMgPSBlbXB0eU1vZGlmaWVycztcbiAgICB9XG4gICAgcmVzW2dldFJhd0Rpck5hbWUoZGlyKV0gPSBkaXI7XG4gICAgZGlyLmRlZiA9IHJlc29sdmVBc3NldCh2bS4kb3B0aW9ucywgJ2RpcmVjdGl2ZXMnLCBkaXIubmFtZSwgdHJ1ZSk7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxuZnVuY3Rpb24gZ2V0UmF3RGlyTmFtZShkaXIpIHtcbiAgcmV0dXJuIGRpci5yYXdOYW1lIHx8IGRpci5uYW1lICsgXCIuXCIgKyBPYmplY3Qua2V5cyhkaXIubW9kaWZpZXJzIHx8IHt9KS5qb2luKCcuJyk7XG59XG5cbmZ1bmN0aW9uIGNhbGxIb29rJDEoZGlyLCBob29rLCB2bm9kZSwgb2xkVm5vZGUsIGlzRGVzdHJveSkge1xuICB2YXIgZm4gPSBkaXIuZGVmICYmIGRpci5kZWZbaG9va107XG4gIGlmIChmbikge1xuICAgIHRyeSB7XG4gICAgICBmbih2bm9kZS5lbG0sIGRpciwgdm5vZGUsIG9sZFZub2RlLCBpc0Rlc3Ryb3kpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGhhbmRsZUVycm9yKGUsIHZub2RlLmNvbnRleHQsIFwiZGlyZWN0aXZlIFwiICsgZGlyLm5hbWUgKyBcIiBcIiArIGhvb2sgKyBcIiBob29rXCIpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgYmFzZU1vZHVsZXMgPSBbcmVmLCBkaXJlY3RpdmVzXTtcblxuLyogICovXG5cbmZ1bmN0aW9uIHVwZGF0ZUF0dHJzKG9sZFZub2RlLCB2bm9kZSkge1xuICB2YXIgb3B0cyA9IHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gIGlmIChpc0RlZihvcHRzKSAmJiBvcHRzLkN0b3Iub3B0aW9ucy5pbmhlcml0QXR0cnMgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChpc1VuZGVmKG9sZFZub2RlLmRhdGEuYXR0cnMpICYmIGlzVW5kZWYodm5vZGUuZGF0YS5hdHRycykpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIGtleSwgY3VyLCBvbGQ7XG4gIHZhciBlbG0gPSB2bm9kZS5lbG07XG4gIHZhciBvbGRBdHRycyA9IG9sZFZub2RlLmRhdGEuYXR0cnMgfHwge307XG4gIHZhciBhdHRycyA9IHZub2RlLmRhdGEuYXR0cnMgfHwge307XG4gIC8vIGNsb25lIG9ic2VydmVkIG9iamVjdHMsIGFzIHRoZSB1c2VyIHByb2JhYmx5IHdhbnRzIHRvIG11dGF0ZSBpdFxuICBpZiAoaXNEZWYoYXR0cnMuX19vYl9fKSkge1xuICAgIGF0dHJzID0gdm5vZGUuZGF0YS5hdHRycyA9IGV4dGVuZCh7fSwgYXR0cnMpO1xuICB9XG5cbiAgZm9yIChrZXkgaW4gYXR0cnMpIHtcbiAgICBjdXIgPSBhdHRyc1trZXldO1xuICAgIG9sZCA9IG9sZEF0dHJzW2tleV07XG4gICAgaWYgKG9sZCAhPT0gY3VyKSB7XG4gICAgICBzZXRBdHRyKGVsbSwga2V5LCBjdXIpO1xuICAgIH1cbiAgfVxuICAvLyAjNDM5MTogaW4gSUU5LCBzZXR0aW5nIHR5cGUgY2FuIHJlc2V0IHZhbHVlIGZvciBpbnB1dFt0eXBlPXJhZGlvXVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGlzSUU5ICYmIGF0dHJzLnZhbHVlICE9PSBvbGRBdHRycy52YWx1ZSkge1xuICAgIHNldEF0dHIoZWxtLCAndmFsdWUnLCBhdHRycy52YWx1ZSk7XG4gIH1cbiAgZm9yIChrZXkgaW4gb2xkQXR0cnMpIHtcbiAgICBpZiAoaXNVbmRlZihhdHRyc1trZXldKSkge1xuICAgICAgaWYgKGlzWGxpbmsoa2V5KSkge1xuICAgICAgICBlbG0ucmVtb3ZlQXR0cmlidXRlTlMoeGxpbmtOUywgZ2V0WGxpbmtQcm9wKGtleSkpO1xuICAgICAgfSBlbHNlIGlmICghaXNFbnVtZXJhdGVkQXR0cihrZXkpKSB7XG4gICAgICAgIGVsbS5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0QXR0cihlbCwga2V5LCB2YWx1ZSkge1xuICBpZiAoaXNCb29sZWFuQXR0cihrZXkpKSB7XG4gICAgLy8gc2V0IGF0dHJpYnV0ZSBmb3IgYmxhbmsgdmFsdWVcbiAgICAvLyBlLmcuIDxvcHRpb24gZGlzYWJsZWQ+U2VsZWN0IG9uZTwvb3B0aW9uPlxuICAgIGlmIChpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSkge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHRlY2huaWNhbGx5IGFsbG93ZnVsbHNjcmVlbiBpcyBhIGJvb2xlYW4gYXR0cmlidXRlIGZvciA8aWZyYW1lPixcbiAgICAgIC8vIGJ1dCBGbGFzaCBleHBlY3RzIGEgdmFsdWUgb2YgXCJ0cnVlXCIgd2hlbiB1c2VkIG9uIDxlbWJlZD4gdGFnXG4gICAgICB2YWx1ZSA9IGtleSA9PT0gJ2FsbG93ZnVsbHNjcmVlbicgJiYgZWwudGFnTmFtZSA9PT0gJ0VNQkVEJyA/ICd0cnVlJyA6IGtleTtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNFbnVtZXJhdGVkQXR0cihrZXkpKSB7XG4gICAgZWwuc2V0QXR0cmlidXRlKGtleSwgaXNGYWxzeUF0dHJWYWx1ZSh2YWx1ZSkgfHwgdmFsdWUgPT09ICdmYWxzZScgPyAnZmFsc2UnIDogJ3RydWUnKTtcbiAgfSBlbHNlIGlmIChpc1hsaW5rKGtleSkpIHtcbiAgICBpZiAoaXNGYWxzeUF0dHJWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZU5TKHhsaW5rTlMsIGdldFhsaW5rUHJvcChrZXkpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuc2V0QXR0cmlidXRlTlMoeGxpbmtOUywga2V5LCB2YWx1ZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSkge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIGF0dHJzID0ge1xuICBjcmVhdGU6IHVwZGF0ZUF0dHJzLFxuICB1cGRhdGU6IHVwZGF0ZUF0dHJzXG59O1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gdXBkYXRlQ2xhc3Mob2xkVm5vZGUsIHZub2RlKSB7XG4gIHZhciBlbCA9IHZub2RlLmVsbTtcbiAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICB2YXIgb2xkRGF0YSA9IG9sZFZub2RlLmRhdGE7XG4gIGlmIChpc1VuZGVmKGRhdGEuc3RhdGljQ2xhc3MpICYmIGlzVW5kZWYoZGF0YS5jbGFzcykgJiYgKGlzVW5kZWYob2xkRGF0YSkgfHwgaXNVbmRlZihvbGREYXRhLnN0YXRpY0NsYXNzKSAmJiBpc1VuZGVmKG9sZERhdGEuY2xhc3MpKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBjbHMgPSBnZW5DbGFzc0ZvclZub2RlKHZub2RlKTtcblxuICAvLyBoYW5kbGUgdHJhbnNpdGlvbiBjbGFzc2VzXG4gIHZhciB0cmFuc2l0aW9uQ2xhc3MgPSBlbC5fdHJhbnNpdGlvbkNsYXNzZXM7XG4gIGlmIChpc0RlZih0cmFuc2l0aW9uQ2xhc3MpKSB7XG4gICAgY2xzID0gY29uY2F0KGNscywgc3RyaW5naWZ5Q2xhc3ModHJhbnNpdGlvbkNsYXNzKSk7XG4gIH1cblxuICAvLyBzZXQgdGhlIGNsYXNzXG4gIGlmIChjbHMgIT09IGVsLl9wcmV2Q2xhc3MpIHtcbiAgICBlbC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgY2xzKTtcbiAgICBlbC5fcHJldkNsYXNzID0gY2xzO1xuICB9XG59XG5cbnZhciBrbGFzcyA9IHtcbiAgY3JlYXRlOiB1cGRhdGVDbGFzcyxcbiAgdXBkYXRlOiB1cGRhdGVDbGFzc1xufTtcblxuLyogICovXG5cbnZhciB2YWxpZERpdmlzaW9uQ2hhclJFID0gL1tcXHcpLitcXC1fJFxcXV0vO1xuXG5mdW5jdGlvbiBwYXJzZUZpbHRlcnMoZXhwKSB7XG4gIHZhciBpblNpbmdsZSA9IGZhbHNlO1xuICB2YXIgaW5Eb3VibGUgPSBmYWxzZTtcbiAgdmFyIGluVGVtcGxhdGVTdHJpbmcgPSBmYWxzZTtcbiAgdmFyIGluUmVnZXggPSBmYWxzZTtcbiAgdmFyIGN1cmx5ID0gMDtcbiAgdmFyIHNxdWFyZSA9IDA7XG4gIHZhciBwYXJlbiA9IDA7XG4gIHZhciBsYXN0RmlsdGVySW5kZXggPSAwO1xuICB2YXIgYywgcHJldiwgaSwgZXhwcmVzc2lvbiwgZmlsdGVycztcblxuICBmb3IgKGkgPSAwOyBpIDwgZXhwLmxlbmd0aDsgaSsrKSB7XG4gICAgcHJldiA9IGM7XG4gICAgYyA9IGV4cC5jaGFyQ29kZUF0KGkpO1xuICAgIGlmIChpblNpbmdsZSkge1xuICAgICAgaWYgKGMgPT09IDB4MjcgJiYgcHJldiAhPT0gMHg1Qykge1xuICAgICAgICBpblNpbmdsZSA9IGZhbHNlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaW5Eb3VibGUpIHtcbiAgICAgIGlmIChjID09PSAweDIyICYmIHByZXYgIT09IDB4NUMpIHtcbiAgICAgICAgaW5Eb3VibGUgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGluVGVtcGxhdGVTdHJpbmcpIHtcbiAgICAgIGlmIChjID09PSAweDYwICYmIHByZXYgIT09IDB4NUMpIHtcbiAgICAgICAgaW5UZW1wbGF0ZVN0cmluZyA9IGZhbHNlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaW5SZWdleCkge1xuICAgICAgaWYgKGMgPT09IDB4MmYgJiYgcHJldiAhPT0gMHg1Qykge1xuICAgICAgICBpblJlZ2V4ID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjID09PSAweDdDICYmIC8vIHBpcGVcbiAgICBleHAuY2hhckNvZGVBdChpICsgMSkgIT09IDB4N0MgJiYgZXhwLmNoYXJDb2RlQXQoaSAtIDEpICE9PSAweDdDICYmICFjdXJseSAmJiAhc3F1YXJlICYmICFwYXJlbikge1xuICAgICAgaWYgKGV4cHJlc3Npb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBmaXJzdCBmaWx0ZXIsIGVuZCBvZiBleHByZXNzaW9uXG4gICAgICAgIGxhc3RGaWx0ZXJJbmRleCA9IGkgKyAxO1xuICAgICAgICBleHByZXNzaW9uID0gZXhwLnNsaWNlKDAsIGkpLnRyaW0oKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHB1c2hGaWx0ZXIoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3dpdGNoIChjKSB7XG4gICAgICAgIGNhc2UgMHgyMjpcbiAgICAgICAgICBpbkRvdWJsZSA9IHRydWU7YnJlYWs7IC8vIFwiXG4gICAgICAgIGNhc2UgMHgyNzpcbiAgICAgICAgICBpblNpbmdsZSA9IHRydWU7YnJlYWs7IC8vICdcbiAgICAgICAgY2FzZSAweDYwOlxuICAgICAgICAgIGluVGVtcGxhdGVTdHJpbmcgPSB0cnVlO2JyZWFrOyAvLyBgXG4gICAgICAgIGNhc2UgMHgyODpcbiAgICAgICAgICBwYXJlbisrO2JyZWFrOyAvLyAoXG4gICAgICAgIGNhc2UgMHgyOTpcbiAgICAgICAgICBwYXJlbi0tO2JyZWFrOyAvLyApXG4gICAgICAgIGNhc2UgMHg1QjpcbiAgICAgICAgICBzcXVhcmUrKzticmVhazsgLy8gW1xuICAgICAgICBjYXNlIDB4NUQ6XG4gICAgICAgICAgc3F1YXJlLS07YnJlYWs7IC8vIF1cbiAgICAgICAgY2FzZSAweDdCOlxuICAgICAgICAgIGN1cmx5Kys7YnJlYWs7IC8vIHtcbiAgICAgICAgY2FzZSAweDdEOlxuICAgICAgICAgIGN1cmx5LS07YnJlYWs7IC8vIH1cbiAgICAgIH1cbiAgICAgIGlmIChjID09PSAweDJmKSB7XG4gICAgICAgIC8vIC9cbiAgICAgICAgdmFyIGogPSBpIC0gMTtcbiAgICAgICAgdmFyIHAgPSB2b2lkIDA7XG4gICAgICAgIC8vIGZpbmQgZmlyc3Qgbm9uLXdoaXRlc3BhY2UgcHJldiBjaGFyXG4gICAgICAgIGZvciAoOyBqID49IDA7IGotLSkge1xuICAgICAgICAgIHAgPSBleHAuY2hhckF0KGopO1xuICAgICAgICAgIGlmIChwICE9PSAnICcpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXAgfHwgIXZhbGlkRGl2aXNpb25DaGFyUkUudGVzdChwKSkge1xuICAgICAgICAgIGluUmVnZXggPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGV4cHJlc3Npb24gPT09IHVuZGVmaW5lZCkge1xuICAgIGV4cHJlc3Npb24gPSBleHAuc2xpY2UoMCwgaSkudHJpbSgpO1xuICB9IGVsc2UgaWYgKGxhc3RGaWx0ZXJJbmRleCAhPT0gMCkge1xuICAgIHB1c2hGaWx0ZXIoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHB1c2hGaWx0ZXIoKSB7XG4gICAgKGZpbHRlcnMgfHwgKGZpbHRlcnMgPSBbXSkpLnB1c2goZXhwLnNsaWNlKGxhc3RGaWx0ZXJJbmRleCwgaSkudHJpbSgpKTtcbiAgICBsYXN0RmlsdGVySW5kZXggPSBpICsgMTtcbiAgfVxuXG4gIGlmIChmaWx0ZXJzKSB7XG4gICAgZm9yIChpID0gMDsgaSA8IGZpbHRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGV4cHJlc3Npb24gPSB3cmFwRmlsdGVyKGV4cHJlc3Npb24sIGZpbHRlcnNbaV0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBleHByZXNzaW9uO1xufVxuXG5mdW5jdGlvbiB3cmFwRmlsdGVyKGV4cCwgZmlsdGVyKSB7XG4gIHZhciBpID0gZmlsdGVyLmluZGV4T2YoJygnKTtcbiAgaWYgKGkgPCAwKSB7XG4gICAgLy8gX2Y6IHJlc29sdmVGaWx0ZXJcbiAgICByZXR1cm4gXCJfZihcXFwiXCIgKyBmaWx0ZXIgKyBcIlxcXCIpKFwiICsgZXhwICsgXCIpXCI7XG4gIH0gZWxzZSB7XG4gICAgdmFyIG5hbWUgPSBmaWx0ZXIuc2xpY2UoMCwgaSk7XG4gICAgdmFyIGFyZ3MgPSBmaWx0ZXIuc2xpY2UoaSArIDEpO1xuICAgIHJldHVybiBcIl9mKFxcXCJcIiArIG5hbWUgKyBcIlxcXCIpKFwiICsgZXhwICsgXCIsXCIgKyBhcmdzO1xuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBiYXNlV2Fybihtc2cpIHtcbiAgY29uc29sZS5lcnJvcihcIltWdWUgY29tcGlsZXJdOiBcIiArIG1zZyk7XG59XG5cbmZ1bmN0aW9uIHBsdWNrTW9kdWxlRnVuY3Rpb24obW9kdWxlcywga2V5KSB7XG4gIHJldHVybiBtb2R1bGVzID8gbW9kdWxlcy5tYXAoZnVuY3Rpb24gKG0pIHtcbiAgICByZXR1cm4gbVtrZXldO1xuICB9KS5maWx0ZXIoZnVuY3Rpb24gKF8pIHtcbiAgICByZXR1cm4gXztcbiAgfSkgOiBbXTtcbn1cblxuZnVuY3Rpb24gYWRkUHJvcChlbCwgbmFtZSwgdmFsdWUpIHtcbiAgKGVsLnByb3BzIHx8IChlbC5wcm9wcyA9IFtdKSkucHVzaCh7IG5hbWU6IG5hbWUsIHZhbHVlOiB2YWx1ZSB9KTtcbn1cblxuZnVuY3Rpb24gYWRkQXR0cihlbCwgbmFtZSwgdmFsdWUpIHtcbiAgKGVsLmF0dHJzIHx8IChlbC5hdHRycyA9IFtdKSkucHVzaCh7IG5hbWU6IG5hbWUsIHZhbHVlOiB2YWx1ZSB9KTtcbn1cblxuZnVuY3Rpb24gYWRkRGlyZWN0aXZlKGVsLCBuYW1lLCByYXdOYW1lLCB2YWx1ZSwgYXJnLCBtb2RpZmllcnMpIHtcbiAgKGVsLmRpcmVjdGl2ZXMgfHwgKGVsLmRpcmVjdGl2ZXMgPSBbXSkpLnB1c2goeyBuYW1lOiBuYW1lLCByYXdOYW1lOiByYXdOYW1lLCB2YWx1ZTogdmFsdWUsIGFyZzogYXJnLCBtb2RpZmllcnM6IG1vZGlmaWVycyB9KTtcbn1cblxuZnVuY3Rpb24gYWRkSGFuZGxlcihlbCwgbmFtZSwgdmFsdWUsIG1vZGlmaWVycywgaW1wb3J0YW50LCB3YXJuKSB7XG4gIC8vIHdhcm4gcHJldmVudCBhbmQgcGFzc2l2ZSBtb2RpZmllclxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGZhbHNlKSB7XG4gICAgd2FybigncGFzc2l2ZSBhbmQgcHJldmVudCBjYW5cXCd0IGJlIHVzZWQgdG9nZXRoZXIuICcgKyAnUGFzc2l2ZSBoYW5kbGVyIGNhblxcJ3QgcHJldmVudCBkZWZhdWx0IGV2ZW50LicpO1xuICB9XG4gIC8vIGNoZWNrIGNhcHR1cmUgbW9kaWZpZXJcbiAgaWYgKG1vZGlmaWVycyAmJiBtb2RpZmllcnMuY2FwdHVyZSkge1xuICAgIGRlbGV0ZSBtb2RpZmllcnMuY2FwdHVyZTtcbiAgICBuYW1lID0gJyEnICsgbmFtZTsgLy8gbWFyayB0aGUgZXZlbnQgYXMgY2FwdHVyZWRcbiAgfVxuICBpZiAobW9kaWZpZXJzICYmIG1vZGlmaWVycy5vbmNlKSB7XG4gICAgZGVsZXRlIG1vZGlmaWVycy5vbmNlO1xuICAgIG5hbWUgPSAnficgKyBuYW1lOyAvLyBtYXJrIHRoZSBldmVudCBhcyBvbmNlXG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChtb2RpZmllcnMgJiYgbW9kaWZpZXJzLnBhc3NpdmUpIHtcbiAgICBkZWxldGUgbW9kaWZpZXJzLnBhc3NpdmU7XG4gICAgbmFtZSA9ICcmJyArIG5hbWU7IC8vIG1hcmsgdGhlIGV2ZW50IGFzIHBhc3NpdmVcbiAgfVxuICB2YXIgZXZlbnRzO1xuICBpZiAobW9kaWZpZXJzICYmIG1vZGlmaWVycy5uYXRpdmUpIHtcbiAgICBkZWxldGUgbW9kaWZpZXJzLm5hdGl2ZTtcbiAgICBldmVudHMgPSBlbC5uYXRpdmVFdmVudHMgfHwgKGVsLm5hdGl2ZUV2ZW50cyA9IHt9KTtcbiAgfSBlbHNlIHtcbiAgICBldmVudHMgPSBlbC5ldmVudHMgfHwgKGVsLmV2ZW50cyA9IHt9KTtcbiAgfVxuICB2YXIgbmV3SGFuZGxlciA9IHsgdmFsdWU6IHZhbHVlLCBtb2RpZmllcnM6IG1vZGlmaWVycyB9O1xuICB2YXIgaGFuZGxlcnMgPSBldmVudHNbbmFtZV07XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoQXJyYXkuaXNBcnJheShoYW5kbGVycykpIHtcbiAgICBpbXBvcnRhbnQgPyBoYW5kbGVycy51bnNoaWZ0KG5ld0hhbmRsZXIpIDogaGFuZGxlcnMucHVzaChuZXdIYW5kbGVyKTtcbiAgfSBlbHNlIGlmIChoYW5kbGVycykge1xuICAgIGV2ZW50c1tuYW1lXSA9IGltcG9ydGFudCA/IFtuZXdIYW5kbGVyLCBoYW5kbGVyc10gOiBbaGFuZGxlcnMsIG5ld0hhbmRsZXJdO1xuICB9IGVsc2Uge1xuICAgIGV2ZW50c1tuYW1lXSA9IG5ld0hhbmRsZXI7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0QmluZGluZ0F0dHIoZWwsIG5hbWUsIGdldFN0YXRpYykge1xuICB2YXIgZHluYW1pY1ZhbHVlID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJzonICsgbmFtZSkgfHwgZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtYmluZDonICsgbmFtZSk7XG4gIGlmIChkeW5hbWljVmFsdWUgIT0gbnVsbCkge1xuICAgIHJldHVybiBwYXJzZUZpbHRlcnMoZHluYW1pY1ZhbHVlKTtcbiAgfSBlbHNlIGlmIChnZXRTdGF0aWMgIT09IGZhbHNlKSB7XG4gICAgdmFyIHN0YXRpY1ZhbHVlID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgbmFtZSk7XG4gICAgaWYgKHN0YXRpY1ZhbHVlICE9IG51bGwpIHtcbiAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShzdGF0aWNWYWx1ZSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldEFuZFJlbW92ZUF0dHIoZWwsIG5hbWUpIHtcbiAgdmFyIHZhbDtcbiAgaWYgKCh2YWwgPSBlbC5hdHRyc01hcFtuYW1lXSkgIT0gbnVsbCkge1xuICAgIHZhciBsaXN0ID0gZWwuYXR0cnNMaXN0O1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gbGlzdC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGlmIChsaXN0W2ldLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgbGlzdC5zcGxpY2UoaSwgMSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdmFsO1xufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBDcm9zcy1wbGF0Zm9ybSBjb2RlIGdlbmVyYXRpb24gZm9yIGNvbXBvbmVudCB2LW1vZGVsXG4gKi9cbmZ1bmN0aW9uIGdlbkNvbXBvbmVudE1vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKSB7XG4gIHZhciByZWYgPSBtb2RpZmllcnMgfHwge307XG4gIHZhciBudW1iZXIgPSByZWYubnVtYmVyO1xuICB2YXIgdHJpbSA9IHJlZi50cmltO1xuXG4gIHZhciBiYXNlVmFsdWVFeHByZXNzaW9uID0gJyQkdic7XG4gIHZhciB2YWx1ZUV4cHJlc3Npb24gPSBiYXNlVmFsdWVFeHByZXNzaW9uO1xuICBpZiAodHJpbSkge1xuICAgIHZhbHVlRXhwcmVzc2lvbiA9IFwiKHR5cGVvZiBcIiArIGJhc2VWYWx1ZUV4cHJlc3Npb24gKyBcIiA9PT0gJ3N0cmluZydcIiArIFwiPyBcIiArIGJhc2VWYWx1ZUV4cHJlc3Npb24gKyBcIi50cmltKClcIiArIFwiOiBcIiArIGJhc2VWYWx1ZUV4cHJlc3Npb24gKyBcIilcIjtcbiAgfVxuICBpZiAobnVtYmVyKSB7XG4gICAgdmFsdWVFeHByZXNzaW9uID0gXCJfbihcIiArIHZhbHVlRXhwcmVzc2lvbiArIFwiKVwiO1xuICB9XG4gIHZhciBhc3NpZ25tZW50ID0gZ2VuQXNzaWdubWVudENvZGUodmFsdWUsIHZhbHVlRXhwcmVzc2lvbik7XG5cbiAgZWwubW9kZWwgPSB7XG4gICAgdmFsdWU6IFwiKFwiICsgdmFsdWUgKyBcIilcIixcbiAgICBleHByZXNzaW9uOiBcIlxcXCJcIiArIHZhbHVlICsgXCJcXFwiXCIsXG4gICAgY2FsbGJhY2s6IFwiZnVuY3Rpb24gKFwiICsgYmFzZVZhbHVlRXhwcmVzc2lvbiArIFwiKSB7XCIgKyBhc3NpZ25tZW50ICsgXCJ9XCJcbiAgfTtcbn1cblxuLyoqXG4gKiBDcm9zcy1wbGF0Zm9ybSBjb2RlZ2VuIGhlbHBlciBmb3IgZ2VuZXJhdGluZyB2LW1vZGVsIHZhbHVlIGFzc2lnbm1lbnQgY29kZS5cbiAqL1xuZnVuY3Rpb24gZ2VuQXNzaWdubWVudENvZGUodmFsdWUsIGFzc2lnbm1lbnQpIHtcbiAgdmFyIG1vZGVsUnMgPSBwYXJzZU1vZGVsKHZhbHVlKTtcbiAgaWYgKG1vZGVsUnMuaWR4ID09PSBudWxsKSB7XG4gICAgcmV0dXJuIHZhbHVlICsgXCI9XCIgKyBhc3NpZ25tZW50O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBcIiRzZXQoXCIgKyBtb2RlbFJzLmV4cCArIFwiLCBcIiArIG1vZGVsUnMuaWR4ICsgXCIsIFwiICsgYXNzaWdubWVudCArIFwiKVwiO1xuICB9XG59XG5cbi8qKlxuICogcGFyc2UgZGlyZWN0aXZlIG1vZGVsIHRvIGRvIHRoZSBhcnJheSB1cGRhdGUgdHJhbnNmb3JtLiBhW2lkeF0gPSB2YWwgPT4gJCRhLnNwbGljZSgkJGlkeCwgMSwgdmFsKVxuICpcbiAqIGZvciBsb29wIHBvc3NpYmxlIGNhc2VzOlxuICpcbiAqIC0gdGVzdFxuICogLSB0ZXN0W2lkeF1cbiAqIC0gdGVzdFt0ZXN0MVtpZHhdXVxuICogLSB0ZXN0W1wiYVwiXVtpZHhdXG4gKiAtIHh4eC50ZXN0W2FbYV0udGVzdDFbaWR4XV1cbiAqIC0gdGVzdC54eHguYVtcImFzYVwiXVt0ZXN0MVtpZHhdXVxuICpcbiAqL1xuXG52YXIgbGVuO1xudmFyIHN0cjtcbnZhciBjaHI7XG52YXIgaW5kZXgkMTtcbnZhciBleHByZXNzaW9uUG9zO1xudmFyIGV4cHJlc3Npb25FbmRQb3M7XG5cbmZ1bmN0aW9uIHBhcnNlTW9kZWwodmFsKSB7XG4gIHN0ciA9IHZhbDtcbiAgbGVuID0gc3RyLmxlbmd0aDtcbiAgaW5kZXgkMSA9IGV4cHJlc3Npb25Qb3MgPSBleHByZXNzaW9uRW5kUG9zID0gMDtcblxuICBpZiAodmFsLmluZGV4T2YoJ1snKSA8IDAgfHwgdmFsLmxhc3RJbmRleE9mKCddJykgPCBsZW4gLSAxKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGV4cDogdmFsLFxuICAgICAgaWR4OiBudWxsXG4gICAgfTtcbiAgfVxuXG4gIHdoaWxlICghZW9mKCkpIHtcbiAgICBjaHIgPSBuZXh0KCk7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGlzU3RyaW5nU3RhcnQoY2hyKSkge1xuICAgICAgcGFyc2VTdHJpbmcoY2hyKTtcbiAgICB9IGVsc2UgaWYgKGNociA9PT0gMHg1Qikge1xuICAgICAgcGFyc2VCcmFja2V0KGNocik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBleHA6IHZhbC5zdWJzdHJpbmcoMCwgZXhwcmVzc2lvblBvcyksXG4gICAgaWR4OiB2YWwuc3Vic3RyaW5nKGV4cHJlc3Npb25Qb3MgKyAxLCBleHByZXNzaW9uRW5kUG9zKVxuICB9O1xufVxuXG5mdW5jdGlvbiBuZXh0KCkge1xuICByZXR1cm4gc3RyLmNoYXJDb2RlQXQoKytpbmRleCQxKTtcbn1cblxuZnVuY3Rpb24gZW9mKCkge1xuICByZXR1cm4gaW5kZXgkMSA+PSBsZW47XG59XG5cbmZ1bmN0aW9uIGlzU3RyaW5nU3RhcnQoY2hyKSB7XG4gIHJldHVybiBjaHIgPT09IDB4MjIgfHwgY2hyID09PSAweDI3O1xufVxuXG5mdW5jdGlvbiBwYXJzZUJyYWNrZXQoY2hyKSB7XG4gIHZhciBpbkJyYWNrZXQgPSAxO1xuICBleHByZXNzaW9uUG9zID0gaW5kZXgkMTtcbiAgd2hpbGUgKCFlb2YoKSkge1xuICAgIGNociA9IG5leHQoKTtcbiAgICBpZiAoaXNTdHJpbmdTdGFydChjaHIpKSB7XG4gICAgICBwYXJzZVN0cmluZyhjaHIpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChjaHIgPT09IDB4NUIpIHtcbiAgICAgIGluQnJhY2tldCsrO1xuICAgIH1cbiAgICBpZiAoY2hyID09PSAweDVEKSB7XG4gICAgICBpbkJyYWNrZXQtLTtcbiAgICB9XG4gICAgaWYgKGluQnJhY2tldCA9PT0gMCkge1xuICAgICAgZXhwcmVzc2lvbkVuZFBvcyA9IGluZGV4JDE7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcGFyc2VTdHJpbmcoY2hyKSB7XG4gIHZhciBzdHJpbmdRdW90ZSA9IGNocjtcbiAgd2hpbGUgKCFlb2YoKSkge1xuICAgIGNociA9IG5leHQoKTtcbiAgICBpZiAoY2hyID09PSBzdHJpbmdRdW90ZSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG52YXIgd2FybiQxO1xuXG4vLyBpbiBzb21lIGNhc2VzLCB0aGUgZXZlbnQgdXNlZCBoYXMgdG8gYmUgZGV0ZXJtaW5lZCBhdCBydW50aW1lXG4vLyBzbyB3ZSB1c2VkIHNvbWUgcmVzZXJ2ZWQgdG9rZW5zIGR1cmluZyBjb21waWxlLlxudmFyIFJBTkdFX1RPS0VOID0gJ19fcic7XG52YXIgQ0hFQ0tCT1hfUkFESU9fVE9LRU4gPSAnX19jJztcblxuZnVuY3Rpb24gbW9kZWwoZWwsIGRpciwgX3dhcm4pIHtcbiAgd2FybiQxID0gX3dhcm47XG4gIHZhciB2YWx1ZSA9IGRpci52YWx1ZTtcbiAgdmFyIG1vZGlmaWVycyA9IGRpci5tb2RpZmllcnM7XG4gIHZhciB0YWcgPSBlbC50YWc7XG4gIHZhciB0eXBlID0gZWwuYXR0cnNNYXAudHlwZTtcblxuICBpZiAoZmFsc2UpIHtcbiAgICB2YXIgZHluYW1pY1R5cGUgPSBlbC5hdHRyc01hcFsndi1iaW5kOnR5cGUnXSB8fCBlbC5hdHRyc01hcFsnOnR5cGUnXTtcbiAgICBpZiAodGFnID09PSAnaW5wdXQnICYmIGR5bmFtaWNUeXBlKSB7XG4gICAgICB3YXJuJDEoXCI8aW5wdXQgOnR5cGU9XFxcIlwiICsgZHluYW1pY1R5cGUgKyBcIlxcXCIgdi1tb2RlbD1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIj46XFxuXCIgKyBcInYtbW9kZWwgZG9lcyBub3Qgc3VwcG9ydCBkeW5hbWljIGlucHV0IHR5cGVzLiBVc2Ugdi1pZiBicmFuY2hlcyBpbnN0ZWFkLlwiKTtcbiAgICB9XG4gICAgLy8gaW5wdXRzIHdpdGggdHlwZT1cImZpbGVcIiBhcmUgcmVhZCBvbmx5IGFuZCBzZXR0aW5nIHRoZSBpbnB1dCdzXG4gICAgLy8gdmFsdWUgd2lsbCB0aHJvdyBhbiBlcnJvci5cbiAgICBpZiAodGFnID09PSAnaW5wdXQnICYmIHR5cGUgPT09ICdmaWxlJykge1xuICAgICAgd2FybiQxKFwiPFwiICsgZWwudGFnICsgXCIgdi1tb2RlbD1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIiB0eXBlPVxcXCJmaWxlXFxcIj46XFxuXCIgKyBcIkZpbGUgaW5wdXRzIGFyZSByZWFkIG9ubHkuIFVzZSBhIHYtb246Y2hhbmdlIGxpc3RlbmVyIGluc3RlYWQuXCIpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChlbC5jb21wb25lbnQpIHtcbiAgICBnZW5Db21wb25lbnRNb2RlbChlbCwgdmFsdWUsIG1vZGlmaWVycyk7XG4gICAgLy8gY29tcG9uZW50IHYtbW9kZWwgZG9lc24ndCBuZWVkIGV4dHJhIHJ1bnRpbWVcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSBpZiAodGFnID09PSAnc2VsZWN0Jykge1xuICAgIGdlblNlbGVjdChlbCwgdmFsdWUsIG1vZGlmaWVycyk7XG4gIH0gZWxzZSBpZiAodGFnID09PSAnaW5wdXQnICYmIHR5cGUgPT09ICdjaGVja2JveCcpIHtcbiAgICBnZW5DaGVja2JveE1vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgfSBlbHNlIGlmICh0YWcgPT09ICdpbnB1dCcgJiYgdHlwZSA9PT0gJ3JhZGlvJykge1xuICAgIGdlblJhZGlvTW9kZWwoZWwsIHZhbHVlLCBtb2RpZmllcnMpO1xuICB9IGVsc2UgaWYgKHRhZyA9PT0gJ2lucHV0JyB8fCB0YWcgPT09ICd0ZXh0YXJlYScpIHtcbiAgICBnZW5EZWZhdWx0TW9kZWwoZWwsIHZhbHVlLCBtb2RpZmllcnMpO1xuICB9IGVsc2UgaWYgKCFjb25maWcuaXNSZXNlcnZlZFRhZyh0YWcpKSB7XG4gICAgZ2VuQ29tcG9uZW50TW9kZWwoZWwsIHZhbHVlLCBtb2RpZmllcnMpO1xuICAgIC8vIGNvbXBvbmVudCB2LW1vZGVsIGRvZXNuJ3QgbmVlZCBleHRyYSBydW50aW1lXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IGVsc2UgaWYgKGZhbHNlKSB7XG4gICAgd2FybiQxKFwiPFwiICsgZWwudGFnICsgXCIgdi1tb2RlbD1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIj46IFwiICsgXCJ2LW1vZGVsIGlzIG5vdCBzdXBwb3J0ZWQgb24gdGhpcyBlbGVtZW50IHR5cGUuIFwiICsgJ0lmIHlvdSBhcmUgd29ya2luZyB3aXRoIGNvbnRlbnRlZGl0YWJsZSwgaXRcXCdzIHJlY29tbWVuZGVkIHRvICcgKyAnd3JhcCBhIGxpYnJhcnkgZGVkaWNhdGVkIGZvciB0aGF0IHB1cnBvc2UgaW5zaWRlIGEgY3VzdG9tIGNvbXBvbmVudC4nKTtcbiAgfVxuXG4gIC8vIGVuc3VyZSBydW50aW1lIGRpcmVjdGl2ZSBtZXRhZGF0YVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gZ2VuQ2hlY2tib3hNb2RlbChlbCwgdmFsdWUsIG1vZGlmaWVycykge1xuICB2YXIgbnVtYmVyID0gbW9kaWZpZXJzICYmIG1vZGlmaWVycy5udW1iZXI7XG4gIHZhciB2YWx1ZUJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3ZhbHVlJykgfHwgJ251bGwnO1xuICB2YXIgdHJ1ZVZhbHVlQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAndHJ1ZS12YWx1ZScpIHx8ICd0cnVlJztcbiAgdmFyIGZhbHNlVmFsdWVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICdmYWxzZS12YWx1ZScpIHx8ICdmYWxzZSc7XG4gIGFkZFByb3AoZWwsICdjaGVja2VkJywgXCJBcnJheS5pc0FycmF5KFwiICsgdmFsdWUgKyBcIilcIiArIFwiP19pKFwiICsgdmFsdWUgKyBcIixcIiArIHZhbHVlQmluZGluZyArIFwiKT4tMVwiICsgKHRydWVWYWx1ZUJpbmRpbmcgPT09ICd0cnVlJyA/IFwiOihcIiArIHZhbHVlICsgXCIpXCIgOiBcIjpfcShcIiArIHZhbHVlICsgXCIsXCIgKyB0cnVlVmFsdWVCaW5kaW5nICsgXCIpXCIpKTtcbiAgYWRkSGFuZGxlcihlbCwgQ0hFQ0tCT1hfUkFESU9fVE9LRU4sIFwidmFyICQkYT1cIiArIHZhbHVlICsgXCIsXCIgKyAnJCRlbD0kZXZlbnQudGFyZ2V0LCcgKyBcIiQkYz0kJGVsLmNoZWNrZWQ/KFwiICsgdHJ1ZVZhbHVlQmluZGluZyArIFwiKTooXCIgKyBmYWxzZVZhbHVlQmluZGluZyArIFwiKTtcIiArICdpZihBcnJheS5pc0FycmF5KCQkYSkpeycgKyBcInZhciAkJHY9XCIgKyAobnVtYmVyID8gJ19uKCcgKyB2YWx1ZUJpbmRpbmcgKyAnKScgOiB2YWx1ZUJpbmRpbmcpICsgXCIsXCIgKyAnJCRpPV9pKCQkYSwkJHYpOycgKyBcImlmKCQkZWwuY2hlY2tlZCl7JCRpPDAmJihcIiArIHZhbHVlICsgXCI9JCRhLmNvbmNhdChbJCR2XSkpfVwiICsgXCJlbHNleyQkaT4tMSYmKFwiICsgdmFsdWUgKyBcIj0kJGEuc2xpY2UoMCwkJGkpLmNvbmNhdCgkJGEuc2xpY2UoJCRpKzEpKSl9XCIgKyBcIn1lbHNle1wiICsgZ2VuQXNzaWdubWVudENvZGUodmFsdWUsICckJGMnKSArIFwifVwiLCBudWxsLCB0cnVlKTtcbn1cblxuZnVuY3Rpb24gZ2VuUmFkaW9Nb2RlbChlbCwgdmFsdWUsIG1vZGlmaWVycykge1xuICB2YXIgbnVtYmVyID0gbW9kaWZpZXJzICYmIG1vZGlmaWVycy5udW1iZXI7XG4gIHZhciB2YWx1ZUJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3ZhbHVlJykgfHwgJ251bGwnO1xuICB2YWx1ZUJpbmRpbmcgPSBudW1iZXIgPyBcIl9uKFwiICsgdmFsdWVCaW5kaW5nICsgXCIpXCIgOiB2YWx1ZUJpbmRpbmc7XG4gIGFkZFByb3AoZWwsICdjaGVja2VkJywgXCJfcShcIiArIHZhbHVlICsgXCIsXCIgKyB2YWx1ZUJpbmRpbmcgKyBcIilcIik7XG4gIGFkZEhhbmRsZXIoZWwsIENIRUNLQk9YX1JBRElPX1RPS0VOLCBnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgdmFsdWVCaW5kaW5nKSwgbnVsbCwgdHJ1ZSk7XG59XG5cbmZ1bmN0aW9uIGdlblNlbGVjdChlbCwgdmFsdWUsIG1vZGlmaWVycykge1xuICB2YXIgbnVtYmVyID0gbW9kaWZpZXJzICYmIG1vZGlmaWVycy5udW1iZXI7XG4gIHZhciBzZWxlY3RlZFZhbCA9IFwiQXJyYXkucHJvdG90eXBlLmZpbHRlclwiICsgXCIuY2FsbCgkZXZlbnQudGFyZ2V0Lm9wdGlvbnMsZnVuY3Rpb24obyl7cmV0dXJuIG8uc2VsZWN0ZWR9KVwiICsgXCIubWFwKGZ1bmN0aW9uKG8pe3ZhciB2YWwgPSBcXFwiX3ZhbHVlXFxcIiBpbiBvID8gby5fdmFsdWUgOiBvLnZhbHVlO1wiICsgXCJyZXR1cm4gXCIgKyAobnVtYmVyID8gJ19uKHZhbCknIDogJ3ZhbCcpICsgXCJ9KVwiO1xuXG4gIHZhciBhc3NpZ25tZW50ID0gJyRldmVudC50YXJnZXQubXVsdGlwbGUgPyAkJHNlbGVjdGVkVmFsIDogJCRzZWxlY3RlZFZhbFswXSc7XG4gIHZhciBjb2RlID0gXCJ2YXIgJCRzZWxlY3RlZFZhbCA9IFwiICsgc2VsZWN0ZWRWYWwgKyBcIjtcIjtcbiAgY29kZSA9IGNvZGUgKyBcIiBcIiArIGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCBhc3NpZ25tZW50KTtcbiAgYWRkSGFuZGxlcihlbCwgJ2NoYW5nZScsIGNvZGUsIG51bGwsIHRydWUpO1xufVxuXG5mdW5jdGlvbiBnZW5EZWZhdWx0TW9kZWwoZWwsIHZhbHVlLCBtb2RpZmllcnMpIHtcbiAgdmFyIHR5cGUgPSBlbC5hdHRyc01hcC50eXBlO1xuICB2YXIgcmVmID0gbW9kaWZpZXJzIHx8IHt9O1xuICB2YXIgbGF6eSA9IHJlZi5sYXp5O1xuICB2YXIgbnVtYmVyID0gcmVmLm51bWJlcjtcbiAgdmFyIHRyaW0gPSByZWYudHJpbTtcbiAgdmFyIG5lZWRDb21wb3NpdGlvbkd1YXJkID0gIWxhenkgJiYgdHlwZSAhPT0gJ3JhbmdlJztcbiAgdmFyIGV2ZW50ID0gbGF6eSA/ICdjaGFuZ2UnIDogdHlwZSA9PT0gJ3JhbmdlJyA/IFJBTkdFX1RPS0VOIDogJ2lucHV0JztcblxuICB2YXIgdmFsdWVFeHByZXNzaW9uID0gJyRldmVudC50YXJnZXQudmFsdWUnO1xuICBpZiAodHJpbSkge1xuICAgIHZhbHVlRXhwcmVzc2lvbiA9IFwiJGV2ZW50LnRhcmdldC52YWx1ZS50cmltKClcIjtcbiAgfVxuICBpZiAobnVtYmVyKSB7XG4gICAgdmFsdWVFeHByZXNzaW9uID0gXCJfbihcIiArIHZhbHVlRXhwcmVzc2lvbiArIFwiKVwiO1xuICB9XG5cbiAgdmFyIGNvZGUgPSBnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgdmFsdWVFeHByZXNzaW9uKTtcbiAgaWYgKG5lZWRDb21wb3NpdGlvbkd1YXJkKSB7XG4gICAgY29kZSA9IFwiaWYoJGV2ZW50LnRhcmdldC5jb21wb3NpbmcpcmV0dXJuO1wiICsgY29kZTtcbiAgfVxuXG4gIGFkZFByb3AoZWwsICd2YWx1ZScsIFwiKFwiICsgdmFsdWUgKyBcIilcIik7XG4gIGFkZEhhbmRsZXIoZWwsIGV2ZW50LCBjb2RlLCBudWxsLCB0cnVlKTtcbiAgaWYgKHRyaW0gfHwgbnVtYmVyKSB7XG4gICAgYWRkSGFuZGxlcihlbCwgJ2JsdXInLCAnJGZvcmNlVXBkYXRlKCknKTtcbiAgfVxufVxuXG4vKiAgKi9cblxuLy8gbm9ybWFsaXplIHYtbW9kZWwgZXZlbnQgdG9rZW5zIHRoYXQgY2FuIG9ubHkgYmUgZGV0ZXJtaW5lZCBhdCBydW50aW1lLlxuLy8gaXQncyBpbXBvcnRhbnQgdG8gcGxhY2UgdGhlIGV2ZW50IGFzIHRoZSBmaXJzdCBpbiB0aGUgYXJyYXkgYmVjYXVzZVxuLy8gdGhlIHdob2xlIHBvaW50IGlzIGVuc3VyaW5nIHRoZSB2LW1vZGVsIGNhbGxiYWNrIGdldHMgY2FsbGVkIGJlZm9yZVxuLy8gdXNlci1hdHRhY2hlZCBoYW5kbGVycy5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUV2ZW50cyhvbikge1xuICB2YXIgZXZlbnQ7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoaXNEZWYob25bUkFOR0VfVE9LRU5dKSkge1xuICAgIC8vIElFIGlucHV0W3R5cGU9cmFuZ2VdIG9ubHkgc3VwcG9ydHMgYGNoYW5nZWAgZXZlbnRcbiAgICBldmVudCA9IGlzSUUgPyAnY2hhbmdlJyA6ICdpbnB1dCc7XG4gICAgb25bZXZlbnRdID0gW10uY29uY2F0KG9uW1JBTkdFX1RPS0VOXSwgb25bZXZlbnRdIHx8IFtdKTtcbiAgICBkZWxldGUgb25bUkFOR0VfVE9LRU5dO1xuICB9XG4gIGlmIChpc0RlZihvbltDSEVDS0JPWF9SQURJT19UT0tFTl0pKSB7XG4gICAgLy8gQ2hyb21lIGZpcmVzIG1pY3JvdGFza3MgaW4gYmV0d2VlbiBjbGljay9jaGFuZ2UsIGxlYWRzIHRvICM0NTIxXG4gICAgZXZlbnQgPSBpc0Nocm9tZSA/ICdjbGljaycgOiAnY2hhbmdlJztcbiAgICBvbltldmVudF0gPSBbXS5jb25jYXQob25bQ0hFQ0tCT1hfUkFESU9fVE9LRU5dLCBvbltldmVudF0gfHwgW10pO1xuICAgIGRlbGV0ZSBvbltDSEVDS0JPWF9SQURJT19UT0tFTl07XG4gIH1cbn1cblxudmFyIHRhcmdldCQxO1xuXG5mdW5jdGlvbiBhZGQkMShldmVudCwgaGFuZGxlciwgb25jZSQkMSwgY2FwdHVyZSwgcGFzc2l2ZSkge1xuICBpZiAob25jZSQkMSkge1xuICAgIHZhciBvbGRIYW5kbGVyID0gaGFuZGxlcjtcbiAgICB2YXIgX3RhcmdldCA9IHRhcmdldCQxOyAvLyBzYXZlIGN1cnJlbnQgdGFyZ2V0IGVsZW1lbnQgaW4gY2xvc3VyZVxuICAgIGhhbmRsZXIgPSBmdW5jdGlvbiAoZXYpIHtcbiAgICAgIHZhciByZXMgPSBhcmd1bWVudHMubGVuZ3RoID09PSAxID8gb2xkSGFuZGxlcihldikgOiBvbGRIYW5kbGVyLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICBpZiAocmVzICE9PSBudWxsKSB7XG4gICAgICAgIHJlbW92ZSQyKGV2ZW50LCBoYW5kbGVyLCBjYXB0dXJlLCBfdGFyZ2V0KTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIHRhcmdldCQxLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIsIHN1cHBvcnRzUGFzc2l2ZSA/IHsgY2FwdHVyZTogY2FwdHVyZSwgcGFzc2l2ZTogcGFzc2l2ZSB9IDogY2FwdHVyZSk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZSQyKGV2ZW50LCBoYW5kbGVyLCBjYXB0dXJlLCBfdGFyZ2V0KSB7XG4gIChfdGFyZ2V0IHx8IHRhcmdldCQxKS5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyLCBjYXB0dXJlKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlRE9NTGlzdGVuZXJzKG9sZFZub2RlLCB2bm9kZSkge1xuICBpZiAoaXNVbmRlZihvbGRWbm9kZS5kYXRhLm9uKSAmJiBpc1VuZGVmKHZub2RlLmRhdGEub24pKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBvbiA9IHZub2RlLmRhdGEub24gfHwge307XG4gIHZhciBvbGRPbiA9IG9sZFZub2RlLmRhdGEub24gfHwge307XG4gIHRhcmdldCQxID0gdm5vZGUuZWxtO1xuICBub3JtYWxpemVFdmVudHMob24pO1xuICB1cGRhdGVMaXN0ZW5lcnMob24sIG9sZE9uLCBhZGQkMSwgcmVtb3ZlJDIsIHZub2RlLmNvbnRleHQpO1xufVxuXG52YXIgZXZlbnRzID0ge1xuICBjcmVhdGU6IHVwZGF0ZURPTUxpc3RlbmVycyxcbiAgdXBkYXRlOiB1cGRhdGVET01MaXN0ZW5lcnNcbn07XG5cbi8qICAqL1xuXG5mdW5jdGlvbiB1cGRhdGVET01Qcm9wcyhvbGRWbm9kZSwgdm5vZGUpIHtcbiAgaWYgKGlzVW5kZWYob2xkVm5vZGUuZGF0YS5kb21Qcm9wcykgJiYgaXNVbmRlZih2bm9kZS5kYXRhLmRvbVByb3BzKSkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIga2V5LCBjdXI7XG4gIHZhciBlbG0gPSB2bm9kZS5lbG07XG4gIHZhciBvbGRQcm9wcyA9IG9sZFZub2RlLmRhdGEuZG9tUHJvcHMgfHwge307XG4gIHZhciBwcm9wcyA9IHZub2RlLmRhdGEuZG9tUHJvcHMgfHwge307XG4gIC8vIGNsb25lIG9ic2VydmVkIG9iamVjdHMsIGFzIHRoZSB1c2VyIHByb2JhYmx5IHdhbnRzIHRvIG11dGF0ZSBpdFxuICBpZiAoaXNEZWYocHJvcHMuX19vYl9fKSkge1xuICAgIHByb3BzID0gdm5vZGUuZGF0YS5kb21Qcm9wcyA9IGV4dGVuZCh7fSwgcHJvcHMpO1xuICB9XG5cbiAgZm9yIChrZXkgaW4gb2xkUHJvcHMpIHtcbiAgICBpZiAoaXNVbmRlZihwcm9wc1trZXldKSkge1xuICAgICAgZWxtW2tleV0gPSAnJztcbiAgICB9XG4gIH1cbiAgZm9yIChrZXkgaW4gcHJvcHMpIHtcbiAgICBjdXIgPSBwcm9wc1trZXldO1xuICAgIC8vIGlnbm9yZSBjaGlsZHJlbiBpZiB0aGUgbm9kZSBoYXMgdGV4dENvbnRlbnQgb3IgaW5uZXJIVE1MLFxuICAgIC8vIGFzIHRoZXNlIHdpbGwgdGhyb3cgYXdheSBleGlzdGluZyBET00gbm9kZXMgYW5kIGNhdXNlIHJlbW92YWwgZXJyb3JzXG4gICAgLy8gb24gc3Vic2VxdWVudCBwYXRjaGVzICgjMzM2MClcbiAgICBpZiAoa2V5ID09PSAndGV4dENvbnRlbnQnIHx8IGtleSA9PT0gJ2lubmVySFRNTCcpIHtcbiAgICAgIGlmICh2bm9kZS5jaGlsZHJlbikge1xuICAgICAgICB2bm9kZS5jaGlsZHJlbi5sZW5ndGggPSAwO1xuICAgICAgfVxuICAgICAgaWYgKGN1ciA9PT0gb2xkUHJvcHNba2V5XSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoa2V5ID09PSAndmFsdWUnKSB7XG4gICAgICAvLyBzdG9yZSB2YWx1ZSBhcyBfdmFsdWUgYXMgd2VsbCBzaW5jZVxuICAgICAgLy8gbm9uLXN0cmluZyB2YWx1ZXMgd2lsbCBiZSBzdHJpbmdpZmllZFxuICAgICAgZWxtLl92YWx1ZSA9IGN1cjtcbiAgICAgIC8vIGF2b2lkIHJlc2V0dGluZyBjdXJzb3IgcG9zaXRpb24gd2hlbiB2YWx1ZSBpcyB0aGUgc2FtZVxuICAgICAgdmFyIHN0ckN1ciA9IGlzVW5kZWYoY3VyKSA/ICcnIDogU3RyaW5nKGN1cik7XG4gICAgICBpZiAoc2hvdWxkVXBkYXRlVmFsdWUoZWxtLCB2bm9kZSwgc3RyQ3VyKSkge1xuICAgICAgICBlbG0udmFsdWUgPSBzdHJDdXI7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsbVtrZXldID0gY3VyO1xuICAgIH1cbiAgfVxufVxuXG4vLyBjaGVjayBwbGF0Zm9ybXMvd2ViL3V0aWwvYXR0cnMuanMgYWNjZXB0VmFsdWVcblxuXG5mdW5jdGlvbiBzaG91bGRVcGRhdGVWYWx1ZShlbG0sIHZub2RlLCBjaGVja1ZhbCkge1xuICByZXR1cm4gIWVsbS5jb21wb3NpbmcgJiYgKHZub2RlLnRhZyA9PT0gJ29wdGlvbicgfHwgaXNEaXJ0eShlbG0sIGNoZWNrVmFsKSB8fCBpc0lucHV0Q2hhbmdlZChlbG0sIGNoZWNrVmFsKSk7XG59XG5cbmZ1bmN0aW9uIGlzRGlydHkoZWxtLCBjaGVja1ZhbCkge1xuICAvLyByZXR1cm4gdHJ1ZSB3aGVuIHRleHRib3ggKC5udW1iZXIgYW5kIC50cmltKSBsb3NlcyBmb2N1cyBhbmQgaXRzIHZhbHVlIGlzXG4gIC8vIG5vdCBlcXVhbCB0byB0aGUgdXBkYXRlZCB2YWx1ZVxuICB2YXIgbm90SW5Gb2N1cyA9IHRydWU7XG4gIC8vICM2MTU3XG4gIC8vIHdvcmsgYXJvdW5kIElFIGJ1ZyB3aGVuIGFjY2Vzc2luZyBkb2N1bWVudC5hY3RpdmVFbGVtZW50IGluIGFuIGlmcmFtZVxuICB0cnkge1xuICAgIG5vdEluRm9jdXMgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICE9PSBlbG07XG4gIH0gY2F0Y2ggKGUpIHt9XG4gIHJldHVybiBub3RJbkZvY3VzICYmIGVsbS52YWx1ZSAhPT0gY2hlY2tWYWw7XG59XG5cbmZ1bmN0aW9uIGlzSW5wdXRDaGFuZ2VkKGVsbSwgbmV3VmFsKSB7XG4gIHZhciB2YWx1ZSA9IGVsbS52YWx1ZTtcbiAgdmFyIG1vZGlmaWVycyA9IGVsbS5fdk1vZGlmaWVyczsgLy8gaW5qZWN0ZWQgYnkgdi1tb2RlbCBydW50aW1lXG4gIGlmIChpc0RlZihtb2RpZmllcnMpICYmIG1vZGlmaWVycy5udW1iZXIpIHtcbiAgICByZXR1cm4gdG9OdW1iZXIodmFsdWUpICE9PSB0b051bWJlcihuZXdWYWwpO1xuICB9XG4gIGlmIChpc0RlZihtb2RpZmllcnMpICYmIG1vZGlmaWVycy50cmltKSB7XG4gICAgcmV0dXJuIHZhbHVlLnRyaW0oKSAhPT0gbmV3VmFsLnRyaW0oKTtcbiAgfVxuICByZXR1cm4gdmFsdWUgIT09IG5ld1ZhbDtcbn1cblxudmFyIGRvbVByb3BzID0ge1xuICBjcmVhdGU6IHVwZGF0ZURPTVByb3BzLFxuICB1cGRhdGU6IHVwZGF0ZURPTVByb3BzXG59O1xuXG4vKiAgKi9cblxudmFyIHBhcnNlU3R5bGVUZXh0ID0gY2FjaGVkKGZ1bmN0aW9uIChjc3NUZXh0KSB7XG4gIHZhciByZXMgPSB7fTtcbiAgdmFyIGxpc3REZWxpbWl0ZXIgPSAvOyg/IVteKF0qXFwpKS9nO1xuICB2YXIgcHJvcGVydHlEZWxpbWl0ZXIgPSAvOiguKykvO1xuICBjc3NUZXh0LnNwbGl0KGxpc3REZWxpbWl0ZXIpLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICBpZiAoaXRlbSkge1xuICAgICAgdmFyIHRtcCA9IGl0ZW0uc3BsaXQocHJvcGVydHlEZWxpbWl0ZXIpO1xuICAgICAgdG1wLmxlbmd0aCA+IDEgJiYgKHJlc1t0bXBbMF0udHJpbSgpXSA9IHRtcFsxXS50cmltKCkpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByZXM7XG59KTtcblxuLy8gbWVyZ2Ugc3RhdGljIGFuZCBkeW5hbWljIHN0eWxlIGRhdGEgb24gdGhlIHNhbWUgdm5vZGVcbmZ1bmN0aW9uIG5vcm1hbGl6ZVN0eWxlRGF0YShkYXRhKSB7XG4gIHZhciBzdHlsZSA9IG5vcm1hbGl6ZVN0eWxlQmluZGluZyhkYXRhLnN0eWxlKTtcbiAgLy8gc3RhdGljIHN0eWxlIGlzIHByZS1wcm9jZXNzZWQgaW50byBhbiBvYmplY3QgZHVyaW5nIGNvbXBpbGF0aW9uXG4gIC8vIGFuZCBpcyBhbHdheXMgYSBmcmVzaCBvYmplY3QsIHNvIGl0J3Mgc2FmZSB0byBtZXJnZSBpbnRvIGl0XG4gIHJldHVybiBkYXRhLnN0YXRpY1N0eWxlID8gZXh0ZW5kKGRhdGEuc3RhdGljU3R5bGUsIHN0eWxlKSA6IHN0eWxlO1xufVxuXG4vLyBub3JtYWxpemUgcG9zc2libGUgYXJyYXkgLyBzdHJpbmcgdmFsdWVzIGludG8gT2JqZWN0XG5mdW5jdGlvbiBub3JtYWxpemVTdHlsZUJpbmRpbmcoYmluZGluZ1N0eWxlKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGJpbmRpbmdTdHlsZSkpIHtcbiAgICByZXR1cm4gdG9PYmplY3QoYmluZGluZ1N0eWxlKTtcbiAgfVxuICBpZiAodHlwZW9mIGJpbmRpbmdTdHlsZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gcGFyc2VTdHlsZVRleHQoYmluZGluZ1N0eWxlKTtcbiAgfVxuICByZXR1cm4gYmluZGluZ1N0eWxlO1xufVxuXG4vKipcbiAqIHBhcmVudCBjb21wb25lbnQgc3R5bGUgc2hvdWxkIGJlIGFmdGVyIGNoaWxkJ3NcbiAqIHNvIHRoYXQgcGFyZW50IGNvbXBvbmVudCdzIHN0eWxlIGNvdWxkIG92ZXJyaWRlIGl0XG4gKi9cbmZ1bmN0aW9uIGdldFN0eWxlKHZub2RlLCBjaGVja0NoaWxkKSB7XG4gIHZhciByZXMgPSB7fTtcbiAgdmFyIHN0eWxlRGF0YTtcblxuICBpZiAoY2hlY2tDaGlsZCkge1xuICAgIHZhciBjaGlsZE5vZGUgPSB2bm9kZTtcbiAgICB3aGlsZSAoY2hpbGROb2RlLmNvbXBvbmVudEluc3RhbmNlKSB7XG4gICAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlO1xuICAgICAgaWYgKGNoaWxkTm9kZS5kYXRhICYmIChzdHlsZURhdGEgPSBub3JtYWxpemVTdHlsZURhdGEoY2hpbGROb2RlLmRhdGEpKSkge1xuICAgICAgICBleHRlbmQocmVzLCBzdHlsZURhdGEpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChzdHlsZURhdGEgPSBub3JtYWxpemVTdHlsZURhdGEodm5vZGUuZGF0YSkpIHtcbiAgICBleHRlbmQocmVzLCBzdHlsZURhdGEpO1xuICB9XG5cbiAgdmFyIHBhcmVudE5vZGUgPSB2bm9kZTtcbiAgd2hpbGUgKHBhcmVudE5vZGUgPSBwYXJlbnROb2RlLnBhcmVudCkge1xuICAgIGlmIChwYXJlbnROb2RlLmRhdGEgJiYgKHN0eWxlRGF0YSA9IG5vcm1hbGl6ZVN0eWxlRGF0YShwYXJlbnROb2RlLmRhdGEpKSkge1xuICAgICAgZXh0ZW5kKHJlcywgc3R5bGVEYXRhKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxuLyogICovXG5cbnZhciBjc3NWYXJSRSA9IC9eLS0vO1xudmFyIGltcG9ydGFudFJFID0gL1xccyohaW1wb3J0YW50JC87XG52YXIgc2V0UHJvcCA9IGZ1bmN0aW9uIChlbCwgbmFtZSwgdmFsKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoY3NzVmFyUkUudGVzdChuYW1lKSkge1xuICAgIGVsLnN0eWxlLnNldFByb3BlcnR5KG5hbWUsIHZhbCk7XG4gIH0gZWxzZSBpZiAoaW1wb3J0YW50UkUudGVzdCh2YWwpKSB7XG4gICAgZWwuc3R5bGUuc2V0UHJvcGVydHkobmFtZSwgdmFsLnJlcGxhY2UoaW1wb3J0YW50UkUsICcnKSwgJ2ltcG9ydGFudCcpO1xuICB9IGVsc2Uge1xuICAgIHZhciBub3JtYWxpemVkTmFtZSA9IG5vcm1hbGl6ZShuYW1lKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICAvLyBTdXBwb3J0IHZhbHVlcyBhcnJheSBjcmVhdGVkIGJ5IGF1dG9wcmVmaXhlciwgZS5nLlxuICAgICAgLy8ge2Rpc3BsYXk6IFtcIi13ZWJraXQtYm94XCIsIFwiLW1zLWZsZXhib3hcIiwgXCJmbGV4XCJdfVxuICAgICAgLy8gU2V0IHRoZW0gb25lIGJ5IG9uZSwgYW5kIHRoZSBicm93c2VyIHdpbGwgb25seSBzZXQgdGhvc2UgaXQgY2FuIHJlY29nbml6ZVxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHZhbC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBlbC5zdHlsZVtub3JtYWxpemVkTmFtZV0gPSB2YWxbaV07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnN0eWxlW25vcm1hbGl6ZWROYW1lXSA9IHZhbDtcbiAgICB9XG4gIH1cbn07XG5cbnZhciB2ZW5kb3JOYW1lcyA9IFsnV2Via2l0JywgJ01veicsICdtcyddO1xuXG52YXIgZW1wdHlTdHlsZTtcbnZhciBub3JtYWxpemUgPSBjYWNoZWQoZnVuY3Rpb24gKHByb3ApIHtcbiAgZW1wdHlTdHlsZSA9IGVtcHR5U3R5bGUgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jykuc3R5bGU7XG4gIHByb3AgPSBjYW1lbGl6ZShwcm9wKTtcbiAgaWYgKHByb3AgIT09ICdmaWx0ZXInICYmIHByb3AgaW4gZW1wdHlTdHlsZSkge1xuICAgIHJldHVybiBwcm9wO1xuICB9XG4gIHZhciBjYXBOYW1lID0gcHJvcC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHByb3Auc2xpY2UoMSk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdmVuZG9yTmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbmFtZSA9IHZlbmRvck5hbWVzW2ldICsgY2FwTmFtZTtcbiAgICBpZiAobmFtZSBpbiBlbXB0eVN0eWxlKSB7XG4gICAgICByZXR1cm4gbmFtZTtcbiAgICB9XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiB1cGRhdGVTdHlsZShvbGRWbm9kZSwgdm5vZGUpIHtcbiAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICB2YXIgb2xkRGF0YSA9IG9sZFZub2RlLmRhdGE7XG5cbiAgaWYgKGlzVW5kZWYoZGF0YS5zdGF0aWNTdHlsZSkgJiYgaXNVbmRlZihkYXRhLnN0eWxlKSAmJiBpc1VuZGVmKG9sZERhdGEuc3RhdGljU3R5bGUpICYmIGlzVW5kZWYob2xkRGF0YS5zdHlsZSkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgY3VyLCBuYW1lO1xuICB2YXIgZWwgPSB2bm9kZS5lbG07XG4gIHZhciBvbGRTdGF0aWNTdHlsZSA9IG9sZERhdGEuc3RhdGljU3R5bGU7XG4gIHZhciBvbGRTdHlsZUJpbmRpbmcgPSBvbGREYXRhLm5vcm1hbGl6ZWRTdHlsZSB8fCBvbGREYXRhLnN0eWxlIHx8IHt9O1xuXG4gIC8vIGlmIHN0YXRpYyBzdHlsZSBleGlzdHMsIHN0eWxlYmluZGluZyBhbHJlYWR5IG1lcmdlZCBpbnRvIGl0IHdoZW4gZG9pbmcgbm9ybWFsaXplU3R5bGVEYXRhXG4gIHZhciBvbGRTdHlsZSA9IG9sZFN0YXRpY1N0eWxlIHx8IG9sZFN0eWxlQmluZGluZztcblxuICB2YXIgc3R5bGUgPSBub3JtYWxpemVTdHlsZUJpbmRpbmcodm5vZGUuZGF0YS5zdHlsZSkgfHwge307XG5cbiAgLy8gc3RvcmUgbm9ybWFsaXplZCBzdHlsZSB1bmRlciBhIGRpZmZlcmVudCBrZXkgZm9yIG5leHQgZGlmZlxuICAvLyBtYWtlIHN1cmUgdG8gY2xvbmUgaXQgaWYgaXQncyByZWFjdGl2ZSwgc2luY2UgdGhlIHVzZXIgbGlrZWx5IHdhbnRzXG4gIC8vIHRvIG11dGF0ZSBpdC5cbiAgdm5vZGUuZGF0YS5ub3JtYWxpemVkU3R5bGUgPSBpc0RlZihzdHlsZS5fX29iX18pID8gZXh0ZW5kKHt9LCBzdHlsZSkgOiBzdHlsZTtcblxuICB2YXIgbmV3U3R5bGUgPSBnZXRTdHlsZSh2bm9kZSwgdHJ1ZSk7XG5cbiAgZm9yIChuYW1lIGluIG9sZFN0eWxlKSB7XG4gICAgaWYgKGlzVW5kZWYobmV3U3R5bGVbbmFtZV0pKSB7XG4gICAgICBzZXRQcm9wKGVsLCBuYW1lLCAnJyk7XG4gICAgfVxuICB9XG4gIGZvciAobmFtZSBpbiBuZXdTdHlsZSkge1xuICAgIGN1ciA9IG5ld1N0eWxlW25hbWVdO1xuICAgIGlmIChjdXIgIT09IG9sZFN0eWxlW25hbWVdKSB7XG4gICAgICAvLyBpZTkgc2V0dGluZyB0byBudWxsIGhhcyBubyBlZmZlY3QsIG11c3QgdXNlIGVtcHR5IHN0cmluZ1xuICAgICAgc2V0UHJvcChlbCwgbmFtZSwgY3VyID09IG51bGwgPyAnJyA6IGN1cik7XG4gICAgfVxuICB9XG59XG5cbnZhciBzdHlsZSA9IHtcbiAgY3JlYXRlOiB1cGRhdGVTdHlsZSxcbiAgdXBkYXRlOiB1cGRhdGVTdHlsZVxufTtcblxuLyogICovXG5cbi8qKlxuICogQWRkIGNsYXNzIHdpdGggY29tcGF0aWJpbGl0eSBmb3IgU1ZHIHNpbmNlIGNsYXNzTGlzdCBpcyBub3Qgc3VwcG9ydGVkIG9uXG4gKiBTVkcgZWxlbWVudHMgaW4gSUVcbiAqL1xuZnVuY3Rpb24gYWRkQ2xhc3MoZWwsIGNscykge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKCFjbHMgfHwgIShjbHMgPSBjbHMudHJpbSgpKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmIChlbC5jbGFzc0xpc3QpIHtcbiAgICBpZiAoY2xzLmluZGV4T2YoJyAnKSA+IC0xKSB7XG4gICAgICBjbHMuc3BsaXQoL1xccysvKS5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHJldHVybiBlbC5jbGFzc0xpc3QuYWRkKGMpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLmNsYXNzTGlzdC5hZGQoY2xzKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGN1ciA9IFwiIFwiICsgKGVsLmdldEF0dHJpYnV0ZSgnY2xhc3MnKSB8fCAnJykgKyBcIiBcIjtcbiAgICBpZiAoY3VyLmluZGV4T2YoJyAnICsgY2xzICsgJyAnKSA8IDApIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAoY3VyICsgY2xzKS50cmltKCkpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZSBjbGFzcyB3aXRoIGNvbXBhdGliaWxpdHkgZm9yIFNWRyBzaW5jZSBjbGFzc0xpc3QgaXMgbm90IHN1cHBvcnRlZCBvblxuICogU1ZHIGVsZW1lbnRzIGluIElFXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUNsYXNzKGVsLCBjbHMpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICghY2xzIHx8ICEoY2xzID0gY2xzLnRyaW0oKSkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoZWwuY2xhc3NMaXN0KSB7XG4gICAgaWYgKGNscy5pbmRleE9mKCcgJykgPiAtMSkge1xuICAgICAgY2xzLnNwbGl0KC9cXHMrLykuZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgICByZXR1cm4gZWwuY2xhc3NMaXN0LnJlbW92ZShjKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKGNscyk7XG4gICAgfVxuICAgIGlmICghZWwuY2xhc3NMaXN0Lmxlbmd0aCkge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKCdjbGFzcycpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgY3VyID0gXCIgXCIgKyAoZWwuZ2V0QXR0cmlidXRlKCdjbGFzcycpIHx8ICcnKSArIFwiIFwiO1xuICAgIHZhciB0YXIgPSAnICcgKyBjbHMgKyAnICc7XG4gICAgd2hpbGUgKGN1ci5pbmRleE9mKHRhcikgPj0gMCkge1xuICAgICAgY3VyID0gY3VyLnJlcGxhY2UodGFyLCAnICcpO1xuICAgIH1cbiAgICBjdXIgPSBjdXIudHJpbSgpO1xuICAgIGlmIChjdXIpIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBjdXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ2NsYXNzJyk7XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiByZXNvbHZlVHJhbnNpdGlvbihkZWYkJDEpIHtcbiAgaWYgKCFkZWYkJDEpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKHR5cGVvZiBkZWYkJDEgPT09ICdvYmplY3QnKSB7XG4gICAgdmFyIHJlcyA9IHt9O1xuICAgIGlmIChkZWYkJDEuY3NzICE9PSBmYWxzZSkge1xuICAgICAgZXh0ZW5kKHJlcywgYXV0b0Nzc1RyYW5zaXRpb24oZGVmJCQxLm5hbWUgfHwgJ3YnKSk7XG4gICAgfVxuICAgIGV4dGVuZChyZXMsIGRlZiQkMSk7XG4gICAgcmV0dXJuIHJlcztcbiAgfSBlbHNlIGlmICh0eXBlb2YgZGVmJCQxID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBhdXRvQ3NzVHJhbnNpdGlvbihkZWYkJDEpO1xuICB9XG59XG5cbnZhciBhdXRvQ3NzVHJhbnNpdGlvbiA9IGNhY2hlZChmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4ge1xuICAgIGVudGVyQ2xhc3M6IG5hbWUgKyBcIi1lbnRlclwiLFxuICAgIGVudGVyVG9DbGFzczogbmFtZSArIFwiLWVudGVyLXRvXCIsXG4gICAgZW50ZXJBY3RpdmVDbGFzczogbmFtZSArIFwiLWVudGVyLWFjdGl2ZVwiLFxuICAgIGxlYXZlQ2xhc3M6IG5hbWUgKyBcIi1sZWF2ZVwiLFxuICAgIGxlYXZlVG9DbGFzczogbmFtZSArIFwiLWxlYXZlLXRvXCIsXG4gICAgbGVhdmVBY3RpdmVDbGFzczogbmFtZSArIFwiLWxlYXZlLWFjdGl2ZVwiXG4gIH07XG59KTtcblxudmFyIGhhc1RyYW5zaXRpb24gPSBpbkJyb3dzZXIgJiYgIWlzSUU5O1xudmFyIFRSQU5TSVRJT04gPSAndHJhbnNpdGlvbic7XG52YXIgQU5JTUFUSU9OID0gJ2FuaW1hdGlvbic7XG5cbi8vIFRyYW5zaXRpb24gcHJvcGVydHkvZXZlbnQgc25pZmZpbmdcbnZhciB0cmFuc2l0aW9uUHJvcCA9ICd0cmFuc2l0aW9uJztcbnZhciB0cmFuc2l0aW9uRW5kRXZlbnQgPSAndHJhbnNpdGlvbmVuZCc7XG52YXIgYW5pbWF0aW9uUHJvcCA9ICdhbmltYXRpb24nO1xudmFyIGFuaW1hdGlvbkVuZEV2ZW50ID0gJ2FuaW1hdGlvbmVuZCc7XG5pZiAoaGFzVHJhbnNpdGlvbikge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKHdpbmRvdy5vbnRyYW5zaXRpb25lbmQgPT09IHVuZGVmaW5lZCAmJiB3aW5kb3cub253ZWJraXR0cmFuc2l0aW9uZW5kICE9PSB1bmRlZmluZWQpIHtcbiAgICB0cmFuc2l0aW9uUHJvcCA9ICdXZWJraXRUcmFuc2l0aW9uJztcbiAgICB0cmFuc2l0aW9uRW5kRXZlbnQgPSAnd2Via2l0VHJhbnNpdGlvbkVuZCc7XG4gIH1cbiAgaWYgKHdpbmRvdy5vbmFuaW1hdGlvbmVuZCA9PT0gdW5kZWZpbmVkICYmIHdpbmRvdy5vbndlYmtpdGFuaW1hdGlvbmVuZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgYW5pbWF0aW9uUHJvcCA9ICdXZWJraXRBbmltYXRpb24nO1xuICAgIGFuaW1hdGlvbkVuZEV2ZW50ID0gJ3dlYmtpdEFuaW1hdGlvbkVuZCc7XG4gIH1cbn1cblxuLy8gYmluZGluZyB0byB3aW5kb3cgaXMgbmVjZXNzYXJ5IHRvIG1ha2UgaG90IHJlbG9hZCB3b3JrIGluIElFIGluIHN0cmljdCBtb2RlXG52YXIgcmFmID0gaW5Ccm93c2VyICYmIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPyB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lLmJpbmQod2luZG93KSA6IHNldFRpbWVvdXQ7XG5cbmZ1bmN0aW9uIG5leHRGcmFtZShmbikge1xuICByYWYoZnVuY3Rpb24gKCkge1xuICAgIHJhZihmbik7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGNscykge1xuICB2YXIgdHJhbnNpdGlvbkNsYXNzZXMgPSBlbC5fdHJhbnNpdGlvbkNsYXNzZXMgfHwgKGVsLl90cmFuc2l0aW9uQ2xhc3NlcyA9IFtdKTtcbiAgaWYgKHRyYW5zaXRpb25DbGFzc2VzLmluZGV4T2YoY2xzKSA8IDApIHtcbiAgICB0cmFuc2l0aW9uQ2xhc3Nlcy5wdXNoKGNscyk7XG4gICAgYWRkQ2xhc3MoZWwsIGNscyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBjbHMpIHtcbiAgaWYgKGVsLl90cmFuc2l0aW9uQ2xhc3Nlcykge1xuICAgIHJlbW92ZShlbC5fdHJhbnNpdGlvbkNsYXNzZXMsIGNscyk7XG4gIH1cbiAgcmVtb3ZlQ2xhc3MoZWwsIGNscyk7XG59XG5cbmZ1bmN0aW9uIHdoZW5UcmFuc2l0aW9uRW5kcyhlbCwgZXhwZWN0ZWRUeXBlLCBjYikge1xuICB2YXIgcmVmID0gZ2V0VHJhbnNpdGlvbkluZm8oZWwsIGV4cGVjdGVkVHlwZSk7XG4gIHZhciB0eXBlID0gcmVmLnR5cGU7XG4gIHZhciB0aW1lb3V0ID0gcmVmLnRpbWVvdXQ7XG4gIHZhciBwcm9wQ291bnQgPSByZWYucHJvcENvdW50O1xuICBpZiAoIXR5cGUpIHtcbiAgICByZXR1cm4gY2IoKTtcbiAgfVxuICB2YXIgZXZlbnQgPSB0eXBlID09PSBUUkFOU0lUSU9OID8gdHJhbnNpdGlvbkVuZEV2ZW50IDogYW5pbWF0aW9uRW5kRXZlbnQ7XG4gIHZhciBlbmRlZCA9IDA7XG4gIHZhciBlbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgb25FbmQpO1xuICAgIGNiKCk7XG4gIH07XG4gIHZhciBvbkVuZCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKGUudGFyZ2V0ID09PSBlbCkge1xuICAgICAgaWYgKCsrZW5kZWQgPj0gcHJvcENvdW50KSB7XG4gICAgICAgIGVuZCgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGVuZGVkIDwgcHJvcENvdW50KSB7XG4gICAgICBlbmQoKTtcbiAgICB9XG4gIH0sIHRpbWVvdXQgKyAxKTtcbiAgZWwuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgb25FbmQpO1xufVxuXG52YXIgdHJhbnNmb3JtUkUgPSAvXFxiKHRyYW5zZm9ybXxhbGwpKCx8JCkvO1xuXG5mdW5jdGlvbiBnZXRUcmFuc2l0aW9uSW5mbyhlbCwgZXhwZWN0ZWRUeXBlKSB7XG4gIHZhciBzdHlsZXMgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XG4gIHZhciB0cmFuc2l0aW9uRGVsYXlzID0gc3R5bGVzW3RyYW5zaXRpb25Qcm9wICsgJ0RlbGF5J10uc3BsaXQoJywgJyk7XG4gIHZhciB0cmFuc2l0aW9uRHVyYXRpb25zID0gc3R5bGVzW3RyYW5zaXRpb25Qcm9wICsgJ0R1cmF0aW9uJ10uc3BsaXQoJywgJyk7XG4gIHZhciB0cmFuc2l0aW9uVGltZW91dCA9IGdldFRpbWVvdXQodHJhbnNpdGlvbkRlbGF5cywgdHJhbnNpdGlvbkR1cmF0aW9ucyk7XG4gIHZhciBhbmltYXRpb25EZWxheXMgPSBzdHlsZXNbYW5pbWF0aW9uUHJvcCArICdEZWxheSddLnNwbGl0KCcsICcpO1xuICB2YXIgYW5pbWF0aW9uRHVyYXRpb25zID0gc3R5bGVzW2FuaW1hdGlvblByb3AgKyAnRHVyYXRpb24nXS5zcGxpdCgnLCAnKTtcbiAgdmFyIGFuaW1hdGlvblRpbWVvdXQgPSBnZXRUaW1lb3V0KGFuaW1hdGlvbkRlbGF5cywgYW5pbWF0aW9uRHVyYXRpb25zKTtcblxuICB2YXIgdHlwZTtcbiAgdmFyIHRpbWVvdXQgPSAwO1xuICB2YXIgcHJvcENvdW50ID0gMDtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChleHBlY3RlZFR5cGUgPT09IFRSQU5TSVRJT04pIHtcbiAgICBpZiAodHJhbnNpdGlvblRpbWVvdXQgPiAwKSB7XG4gICAgICB0eXBlID0gVFJBTlNJVElPTjtcbiAgICAgIHRpbWVvdXQgPSB0cmFuc2l0aW9uVGltZW91dDtcbiAgICAgIHByb3BDb3VudCA9IHRyYW5zaXRpb25EdXJhdGlvbnMubGVuZ3RoO1xuICAgIH1cbiAgfSBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09IEFOSU1BVElPTikge1xuICAgIGlmIChhbmltYXRpb25UaW1lb3V0ID4gMCkge1xuICAgICAgdHlwZSA9IEFOSU1BVElPTjtcbiAgICAgIHRpbWVvdXQgPSBhbmltYXRpb25UaW1lb3V0O1xuICAgICAgcHJvcENvdW50ID0gYW5pbWF0aW9uRHVyYXRpb25zLmxlbmd0aDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGltZW91dCA9IE1hdGgubWF4KHRyYW5zaXRpb25UaW1lb3V0LCBhbmltYXRpb25UaW1lb3V0KTtcbiAgICB0eXBlID0gdGltZW91dCA+IDAgPyB0cmFuc2l0aW9uVGltZW91dCA+IGFuaW1hdGlvblRpbWVvdXQgPyBUUkFOU0lUSU9OIDogQU5JTUFUSU9OIDogbnVsbDtcbiAgICBwcm9wQ291bnQgPSB0eXBlID8gdHlwZSA9PT0gVFJBTlNJVElPTiA/IHRyYW5zaXRpb25EdXJhdGlvbnMubGVuZ3RoIDogYW5pbWF0aW9uRHVyYXRpb25zLmxlbmd0aCA6IDA7XG4gIH1cbiAgdmFyIGhhc1RyYW5zZm9ybSA9IHR5cGUgPT09IFRSQU5TSVRJT04gJiYgdHJhbnNmb3JtUkUudGVzdChzdHlsZXNbdHJhbnNpdGlvblByb3AgKyAnUHJvcGVydHknXSk7XG4gIHJldHVybiB7XG4gICAgdHlwZTogdHlwZSxcbiAgICB0aW1lb3V0OiB0aW1lb3V0LFxuICAgIHByb3BDb3VudDogcHJvcENvdW50LFxuICAgIGhhc1RyYW5zZm9ybTogaGFzVHJhbnNmb3JtXG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldFRpbWVvdXQoZGVsYXlzLCBkdXJhdGlvbnMpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgd2hpbGUgKGRlbGF5cy5sZW5ndGggPCBkdXJhdGlvbnMubGVuZ3RoKSB7XG4gICAgZGVsYXlzID0gZGVsYXlzLmNvbmNhdChkZWxheXMpO1xuICB9XG5cbiAgcmV0dXJuIE1hdGgubWF4LmFwcGx5KG51bGwsIGR1cmF0aW9ucy5tYXAoZnVuY3Rpb24gKGQsIGkpIHtcbiAgICByZXR1cm4gdG9NcyhkKSArIHRvTXMoZGVsYXlzW2ldKTtcbiAgfSkpO1xufVxuXG5mdW5jdGlvbiB0b01zKHMpIHtcbiAgcmV0dXJuIE51bWJlcihzLnNsaWNlKDAsIC0xKSkgKiAxMDAwO1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gZW50ZXIodm5vZGUsIHRvZ2dsZURpc3BsYXkpIHtcbiAgdmFyIGVsID0gdm5vZGUuZWxtO1xuXG4gIC8vIGNhbGwgbGVhdmUgY2FsbGJhY2sgbm93XG4gIGlmIChpc0RlZihlbC5fbGVhdmVDYikpIHtcbiAgICBlbC5fbGVhdmVDYi5jYW5jZWxsZWQgPSB0cnVlO1xuICAgIGVsLl9sZWF2ZUNiKCk7XG4gIH1cblxuICB2YXIgZGF0YSA9IHJlc29sdmVUcmFuc2l0aW9uKHZub2RlLmRhdGEudHJhbnNpdGlvbik7XG4gIGlmIChpc1VuZGVmKGRhdGEpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChpc0RlZihlbC5fZW50ZXJDYikgfHwgZWwubm9kZVR5cGUgIT09IDEpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgY3NzID0gZGF0YS5jc3M7XG4gIHZhciB0eXBlID0gZGF0YS50eXBlO1xuICB2YXIgZW50ZXJDbGFzcyA9IGRhdGEuZW50ZXJDbGFzcztcbiAgdmFyIGVudGVyVG9DbGFzcyA9IGRhdGEuZW50ZXJUb0NsYXNzO1xuICB2YXIgZW50ZXJBY3RpdmVDbGFzcyA9IGRhdGEuZW50ZXJBY3RpdmVDbGFzcztcbiAgdmFyIGFwcGVhckNsYXNzID0gZGF0YS5hcHBlYXJDbGFzcztcbiAgdmFyIGFwcGVhclRvQ2xhc3MgPSBkYXRhLmFwcGVhclRvQ2xhc3M7XG4gIHZhciBhcHBlYXJBY3RpdmVDbGFzcyA9IGRhdGEuYXBwZWFyQWN0aXZlQ2xhc3M7XG4gIHZhciBiZWZvcmVFbnRlciA9IGRhdGEuYmVmb3JlRW50ZXI7XG4gIHZhciBlbnRlciA9IGRhdGEuZW50ZXI7XG4gIHZhciBhZnRlckVudGVyID0gZGF0YS5hZnRlckVudGVyO1xuICB2YXIgZW50ZXJDYW5jZWxsZWQgPSBkYXRhLmVudGVyQ2FuY2VsbGVkO1xuICB2YXIgYmVmb3JlQXBwZWFyID0gZGF0YS5iZWZvcmVBcHBlYXI7XG4gIHZhciBhcHBlYXIgPSBkYXRhLmFwcGVhcjtcbiAgdmFyIGFmdGVyQXBwZWFyID0gZGF0YS5hZnRlckFwcGVhcjtcbiAgdmFyIGFwcGVhckNhbmNlbGxlZCA9IGRhdGEuYXBwZWFyQ2FuY2VsbGVkO1xuICB2YXIgZHVyYXRpb24gPSBkYXRhLmR1cmF0aW9uO1xuXG4gIC8vIGFjdGl2ZUluc3RhbmNlIHdpbGwgYWx3YXlzIGJlIHRoZSA8dHJhbnNpdGlvbj4gY29tcG9uZW50IG1hbmFnaW5nIHRoaXNcbiAgLy8gdHJhbnNpdGlvbi4gT25lIGVkZ2UgY2FzZSB0byBjaGVjayBpcyB3aGVuIHRoZSA8dHJhbnNpdGlvbj4gaXMgcGxhY2VkXG4gIC8vIGFzIHRoZSByb290IG5vZGUgb2YgYSBjaGlsZCBjb21wb25lbnQuIEluIHRoYXQgY2FzZSB3ZSBuZWVkIHRvIGNoZWNrXG4gIC8vIDx0cmFuc2l0aW9uPidzIHBhcmVudCBmb3IgYXBwZWFyIGNoZWNrLlxuICB2YXIgY29udGV4dCA9IGFjdGl2ZUluc3RhbmNlO1xuICB2YXIgdHJhbnNpdGlvbk5vZGUgPSBhY3RpdmVJbnN0YW5jZS4kdm5vZGU7XG4gIHdoaWxlICh0cmFuc2l0aW9uTm9kZSAmJiB0cmFuc2l0aW9uTm9kZS5wYXJlbnQpIHtcbiAgICB0cmFuc2l0aW9uTm9kZSA9IHRyYW5zaXRpb25Ob2RlLnBhcmVudDtcbiAgICBjb250ZXh0ID0gdHJhbnNpdGlvbk5vZGUuY29udGV4dDtcbiAgfVxuXG4gIHZhciBpc0FwcGVhciA9ICFjb250ZXh0Ll9pc01vdW50ZWQgfHwgIXZub2RlLmlzUm9vdEluc2VydDtcblxuICBpZiAoaXNBcHBlYXIgJiYgIWFwcGVhciAmJiBhcHBlYXIgIT09ICcnKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHN0YXJ0Q2xhc3MgPSBpc0FwcGVhciAmJiBhcHBlYXJDbGFzcyA/IGFwcGVhckNsYXNzIDogZW50ZXJDbGFzcztcbiAgdmFyIGFjdGl2ZUNsYXNzID0gaXNBcHBlYXIgJiYgYXBwZWFyQWN0aXZlQ2xhc3MgPyBhcHBlYXJBY3RpdmVDbGFzcyA6IGVudGVyQWN0aXZlQ2xhc3M7XG4gIHZhciB0b0NsYXNzID0gaXNBcHBlYXIgJiYgYXBwZWFyVG9DbGFzcyA/IGFwcGVhclRvQ2xhc3MgOiBlbnRlclRvQ2xhc3M7XG5cbiAgdmFyIGJlZm9yZUVudGVySG9vayA9IGlzQXBwZWFyID8gYmVmb3JlQXBwZWFyIHx8IGJlZm9yZUVudGVyIDogYmVmb3JlRW50ZXI7XG4gIHZhciBlbnRlckhvb2sgPSBpc0FwcGVhciA/IHR5cGVvZiBhcHBlYXIgPT09ICdmdW5jdGlvbicgPyBhcHBlYXIgOiBlbnRlciA6IGVudGVyO1xuICB2YXIgYWZ0ZXJFbnRlckhvb2sgPSBpc0FwcGVhciA/IGFmdGVyQXBwZWFyIHx8IGFmdGVyRW50ZXIgOiBhZnRlckVudGVyO1xuICB2YXIgZW50ZXJDYW5jZWxsZWRIb29rID0gaXNBcHBlYXIgPyBhcHBlYXJDYW5jZWxsZWQgfHwgZW50ZXJDYW5jZWxsZWQgOiBlbnRlckNhbmNlbGxlZDtcblxuICB2YXIgZXhwbGljaXRFbnRlckR1cmF0aW9uID0gdG9OdW1iZXIoaXNPYmplY3QoZHVyYXRpb24pID8gZHVyYXRpb24uZW50ZXIgOiBkdXJhdGlvbik7XG5cbiAgaWYgKGZhbHNlKSB7XG4gICAgY2hlY2tEdXJhdGlvbihleHBsaWNpdEVudGVyRHVyYXRpb24sICdlbnRlcicsIHZub2RlKTtcbiAgfVxuXG4gIHZhciBleHBlY3RzQ1NTID0gY3NzICE9PSBmYWxzZSAmJiAhaXNJRTk7XG4gIHZhciB1c2VyV2FudHNDb250cm9sID0gZ2V0SG9va0FyZ3VtZW50c0xlbmd0aChlbnRlckhvb2spO1xuXG4gIHZhciBjYiA9IGVsLl9lbnRlckNiID0gb25jZShmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgdG9DbGFzcyk7XG4gICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGFjdGl2ZUNsYXNzKTtcbiAgICB9XG4gICAgaWYgKGNiLmNhbmNlbGxlZCkge1xuICAgICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBzdGFydENsYXNzKTtcbiAgICAgIH1cbiAgICAgIGVudGVyQ2FuY2VsbGVkSG9vayAmJiBlbnRlckNhbmNlbGxlZEhvb2soZWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhZnRlckVudGVySG9vayAmJiBhZnRlckVudGVySG9vayhlbCk7XG4gICAgfVxuICAgIGVsLl9lbnRlckNiID0gbnVsbDtcbiAgfSk7XG5cbiAgaWYgKCF2bm9kZS5kYXRhLnNob3cpIHtcbiAgICAvLyByZW1vdmUgcGVuZGluZyBsZWF2ZSBlbGVtZW50IG9uIGVudGVyIGJ5IGluamVjdGluZyBhbiBpbnNlcnQgaG9va1xuICAgIG1lcmdlVk5vZGVIb29rKHZub2RlLmRhdGEuaG9vayB8fCAodm5vZGUuZGF0YS5ob29rID0ge30pLCAnaW5zZXJ0JywgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHBhcmVudCA9IGVsLnBhcmVudE5vZGU7XG4gICAgICB2YXIgcGVuZGluZ05vZGUgPSBwYXJlbnQgJiYgcGFyZW50Ll9wZW5kaW5nICYmIHBhcmVudC5fcGVuZGluZ1t2bm9kZS5rZXldO1xuICAgICAgaWYgKHBlbmRpbmdOb2RlICYmIHBlbmRpbmdOb2RlLnRhZyA9PT0gdm5vZGUudGFnICYmIHBlbmRpbmdOb2RlLmVsbS5fbGVhdmVDYikge1xuICAgICAgICBwZW5kaW5nTm9kZS5lbG0uX2xlYXZlQ2IoKTtcbiAgICAgIH1cbiAgICAgIGVudGVySG9vayAmJiBlbnRlckhvb2soZWwsIGNiKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8vIHN0YXJ0IGVudGVyIHRyYW5zaXRpb25cbiAgYmVmb3JlRW50ZXJIb29rICYmIGJlZm9yZUVudGVySG9vayhlbCk7XG4gIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBzdGFydENsYXNzKTtcbiAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGFjdGl2ZUNsYXNzKTtcbiAgICBuZXh0RnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCB0b0NsYXNzKTtcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgc3RhcnRDbGFzcyk7XG4gICAgICBpZiAoIWNiLmNhbmNlbGxlZCAmJiAhdXNlcldhbnRzQ29udHJvbCkge1xuICAgICAgICBpZiAoaXNWYWxpZER1cmF0aW9uKGV4cGxpY2l0RW50ZXJEdXJhdGlvbikpIHtcbiAgICAgICAgICBzZXRUaW1lb3V0KGNiLCBleHBsaWNpdEVudGVyRHVyYXRpb24pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdoZW5UcmFuc2l0aW9uRW5kcyhlbCwgdHlwZSwgY2IpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBpZiAodm5vZGUuZGF0YS5zaG93KSB7XG4gICAgdG9nZ2xlRGlzcGxheSAmJiB0b2dnbGVEaXNwbGF5KCk7XG4gICAgZW50ZXJIb29rICYmIGVudGVySG9vayhlbCwgY2IpO1xuICB9XG5cbiAgaWYgKCFleHBlY3RzQ1NTICYmICF1c2VyV2FudHNDb250cm9sKSB7XG4gICAgY2IoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBsZWF2ZSh2bm9kZSwgcm0pIHtcbiAgdmFyIGVsID0gdm5vZGUuZWxtO1xuXG4gIC8vIGNhbGwgZW50ZXIgY2FsbGJhY2sgbm93XG4gIGlmIChpc0RlZihlbC5fZW50ZXJDYikpIHtcbiAgICBlbC5fZW50ZXJDYi5jYW5jZWxsZWQgPSB0cnVlO1xuICAgIGVsLl9lbnRlckNiKCk7XG4gIH1cblxuICB2YXIgZGF0YSA9IHJlc29sdmVUcmFuc2l0aW9uKHZub2RlLmRhdGEudHJhbnNpdGlvbik7XG4gIGlmIChpc1VuZGVmKGRhdGEpKSB7XG4gICAgcmV0dXJuIHJtKCk7XG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGlzRGVmKGVsLl9sZWF2ZUNiKSB8fCBlbC5ub2RlVHlwZSAhPT0gMSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBjc3MgPSBkYXRhLmNzcztcbiAgdmFyIHR5cGUgPSBkYXRhLnR5cGU7XG4gIHZhciBsZWF2ZUNsYXNzID0gZGF0YS5sZWF2ZUNsYXNzO1xuICB2YXIgbGVhdmVUb0NsYXNzID0gZGF0YS5sZWF2ZVRvQ2xhc3M7XG4gIHZhciBsZWF2ZUFjdGl2ZUNsYXNzID0gZGF0YS5sZWF2ZUFjdGl2ZUNsYXNzO1xuICB2YXIgYmVmb3JlTGVhdmUgPSBkYXRhLmJlZm9yZUxlYXZlO1xuICB2YXIgbGVhdmUgPSBkYXRhLmxlYXZlO1xuICB2YXIgYWZ0ZXJMZWF2ZSA9IGRhdGEuYWZ0ZXJMZWF2ZTtcbiAgdmFyIGxlYXZlQ2FuY2VsbGVkID0gZGF0YS5sZWF2ZUNhbmNlbGxlZDtcbiAgdmFyIGRlbGF5TGVhdmUgPSBkYXRhLmRlbGF5TGVhdmU7XG4gIHZhciBkdXJhdGlvbiA9IGRhdGEuZHVyYXRpb247XG5cbiAgdmFyIGV4cGVjdHNDU1MgPSBjc3MgIT09IGZhbHNlICYmICFpc0lFOTtcbiAgdmFyIHVzZXJXYW50c0NvbnRyb2wgPSBnZXRIb29rQXJndW1lbnRzTGVuZ3RoKGxlYXZlKTtcblxuICB2YXIgZXhwbGljaXRMZWF2ZUR1cmF0aW9uID0gdG9OdW1iZXIoaXNPYmplY3QoZHVyYXRpb24pID8gZHVyYXRpb24ubGVhdmUgOiBkdXJhdGlvbik7XG5cbiAgaWYgKGZhbHNlKSB7XG4gICAgY2hlY2tEdXJhdGlvbihleHBsaWNpdExlYXZlRHVyYXRpb24sICdsZWF2ZScsIHZub2RlKTtcbiAgfVxuXG4gIHZhciBjYiA9IGVsLl9sZWF2ZUNiID0gb25jZShmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGVsLnBhcmVudE5vZGUgJiYgZWwucGFyZW50Tm9kZS5fcGVuZGluZykge1xuICAgICAgZWwucGFyZW50Tm9kZS5fcGVuZGluZ1t2bm9kZS5rZXldID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVUb0NsYXNzKTtcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVBY3RpdmVDbGFzcyk7XG4gICAgfVxuICAgIGlmIChjYi5jYW5jZWxsZWQpIHtcbiAgICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVDbGFzcyk7XG4gICAgICB9XG4gICAgICBsZWF2ZUNhbmNlbGxlZCAmJiBsZWF2ZUNhbmNlbGxlZChlbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJtKCk7XG4gICAgICBhZnRlckxlYXZlICYmIGFmdGVyTGVhdmUoZWwpO1xuICAgIH1cbiAgICBlbC5fbGVhdmVDYiA9IG51bGw7XG4gIH0pO1xuXG4gIGlmIChkZWxheUxlYXZlKSB7XG4gICAgZGVsYXlMZWF2ZShwZXJmb3JtTGVhdmUpO1xuICB9IGVsc2Uge1xuICAgIHBlcmZvcm1MZWF2ZSgpO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVyZm9ybUxlYXZlKCkge1xuICAgIC8vIHRoZSBkZWxheWVkIGxlYXZlIG1heSBoYXZlIGFscmVhZHkgYmVlbiBjYW5jZWxsZWRcbiAgICBpZiAoY2IuY2FuY2VsbGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIHJlY29yZCBsZWF2aW5nIGVsZW1lbnRcbiAgICBpZiAoIXZub2RlLmRhdGEuc2hvdykge1xuICAgICAgKGVsLnBhcmVudE5vZGUuX3BlbmRpbmcgfHwgKGVsLnBhcmVudE5vZGUuX3BlbmRpbmcgPSB7fSkpW3Zub2RlLmtleV0gPSB2bm9kZTtcbiAgICB9XG4gICAgYmVmb3JlTGVhdmUgJiYgYmVmb3JlTGVhdmUoZWwpO1xuICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQ2xhc3MpO1xuICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUFjdGl2ZUNsYXNzKTtcbiAgICAgIG5leHRGcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVUb0NsYXNzKTtcbiAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUNsYXNzKTtcbiAgICAgICAgaWYgKCFjYi5jYW5jZWxsZWQgJiYgIXVzZXJXYW50c0NvbnRyb2wpIHtcbiAgICAgICAgICBpZiAoaXNWYWxpZER1cmF0aW9uKGV4cGxpY2l0TGVhdmVEdXJhdGlvbikpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoY2IsIGV4cGxpY2l0TGVhdmVEdXJhdGlvbik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdoZW5UcmFuc2l0aW9uRW5kcyhlbCwgdHlwZSwgY2IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGxlYXZlICYmIGxlYXZlKGVsLCBjYik7XG4gICAgaWYgKCFleHBlY3RzQ1NTICYmICF1c2VyV2FudHNDb250cm9sKSB7XG4gICAgICBjYigpO1xuICAgIH1cbiAgfVxufVxuXG4vLyBvbmx5IHVzZWQgaW4gZGV2IG1vZGVcbmZ1bmN0aW9uIGNoZWNrRHVyYXRpb24odmFsLCBuYW1lLCB2bm9kZSkge1xuICBpZiAodHlwZW9mIHZhbCAhPT0gJ251bWJlcicpIHtcbiAgICB3YXJuKFwiPHRyYW5zaXRpb24+IGV4cGxpY2l0IFwiICsgbmFtZSArIFwiIGR1cmF0aW9uIGlzIG5vdCBhIHZhbGlkIG51bWJlciAtIFwiICsgXCJnb3QgXCIgKyBKU09OLnN0cmluZ2lmeSh2YWwpICsgXCIuXCIsIHZub2RlLmNvbnRleHQpO1xuICB9IGVsc2UgaWYgKGlzTmFOKHZhbCkpIHtcbiAgICB3YXJuKFwiPHRyYW5zaXRpb24+IGV4cGxpY2l0IFwiICsgbmFtZSArIFwiIGR1cmF0aW9uIGlzIE5hTiAtIFwiICsgJ3RoZSBkdXJhdGlvbiBleHByZXNzaW9uIG1pZ2h0IGJlIGluY29ycmVjdC4nLCB2bm9kZS5jb250ZXh0KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc1ZhbGlkRHVyYXRpb24odmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsID09PSAnbnVtYmVyJyAmJiAhaXNOYU4odmFsKTtcbn1cblxuLyoqXG4gKiBOb3JtYWxpemUgYSB0cmFuc2l0aW9uIGhvb2sncyBhcmd1bWVudCBsZW5ndGguIFRoZSBob29rIG1heSBiZTpcbiAqIC0gYSBtZXJnZWQgaG9vayAoaW52b2tlcikgd2l0aCB0aGUgb3JpZ2luYWwgaW4gLmZuc1xuICogLSBhIHdyYXBwZWQgY29tcG9uZW50IG1ldGhvZCAoY2hlY2sgLl9sZW5ndGgpXG4gKiAtIGEgcGxhaW4gZnVuY3Rpb24gKC5sZW5ndGgpXG4gKi9cbmZ1bmN0aW9uIGdldEhvb2tBcmd1bWVudHNMZW5ndGgoZm4pIHtcbiAgaWYgKGlzVW5kZWYoZm4pKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBpbnZva2VyRm5zID0gZm4uZm5zO1xuICBpZiAoaXNEZWYoaW52b2tlckZucykpIHtcbiAgICAvLyBpbnZva2VyXG4gICAgcmV0dXJuIGdldEhvb2tBcmd1bWVudHNMZW5ndGgoQXJyYXkuaXNBcnJheShpbnZva2VyRm5zKSA/IGludm9rZXJGbnNbMF0gOiBpbnZva2VyRm5zKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gKGZuLl9sZW5ndGggfHwgZm4ubGVuZ3RoKSA+IDE7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2VudGVyKF8sIHZub2RlKSB7XG4gIGlmICh2bm9kZS5kYXRhLnNob3cgIT09IHRydWUpIHtcbiAgICBlbnRlcih2bm9kZSk7XG4gIH1cbn1cblxudmFyIHRyYW5zaXRpb24gPSBpbkJyb3dzZXIgPyB7XG4gIGNyZWF0ZTogX2VudGVyLFxuICBhY3RpdmF0ZTogX2VudGVyLFxuICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSQkMSh2bm9kZSwgcm0pIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmICh2bm9kZS5kYXRhLnNob3cgIT09IHRydWUpIHtcbiAgICAgIGxlYXZlKHZub2RlLCBybSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJtKCk7XG4gICAgfVxuICB9XG59IDoge307XG5cbnZhciBwbGF0Zm9ybU1vZHVsZXMgPSBbYXR0cnMsIGtsYXNzLCBldmVudHMsIGRvbVByb3BzLCBzdHlsZSwgdHJhbnNpdGlvbl07XG5cbi8qICAqL1xuXG4vLyB0aGUgZGlyZWN0aXZlIG1vZHVsZSBzaG91bGQgYmUgYXBwbGllZCBsYXN0LCBhZnRlciBhbGxcbi8vIGJ1aWx0LWluIG1vZHVsZXMgaGF2ZSBiZWVuIGFwcGxpZWQuXG52YXIgbW9kdWxlcyA9IHBsYXRmb3JtTW9kdWxlcy5jb25jYXQoYmFzZU1vZHVsZXMpO1xuXG52YXIgcGF0Y2ggPSBjcmVhdGVQYXRjaEZ1bmN0aW9uKHsgbm9kZU9wczogbm9kZU9wcywgbW9kdWxlczogbW9kdWxlcyB9KTtcblxuLyoqXG4gKiBOb3QgdHlwZSBjaGVja2luZyB0aGlzIGZpbGUgYmVjYXVzZSBmbG93IGRvZXNuJ3QgbGlrZSBhdHRhY2hpbmdcbiAqIHByb3BlcnRpZXMgdG8gRWxlbWVudHMuXG4gKi9cblxuLyogaXN0YW5idWwgaWdub3JlIGlmICovXG5pZiAoaXNJRTkpIHtcbiAgLy8gaHR0cDovL3d3dy5tYXR0czQxMS5jb20vcG9zdC9pbnRlcm5ldC1leHBsb3Jlci05LW9uaW5wdXQvXG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3NlbGVjdGlvbmNoYW5nZScsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZWwgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgIGlmIChlbCAmJiBlbC52bW9kZWwpIHtcbiAgICAgIHRyaWdnZXIoZWwsICdpbnB1dCcpO1xuICAgIH1cbiAgfSk7XG59XG5cbnZhciBtb2RlbCQxID0ge1xuICBpbnNlcnRlZDogZnVuY3Rpb24gaW5zZXJ0ZWQoZWwsIGJpbmRpbmcsIHZub2RlKSB7XG4gICAgaWYgKHZub2RlLnRhZyA9PT0gJ3NlbGVjdCcpIHtcbiAgICAgIHNldFNlbGVjdGVkKGVsLCBiaW5kaW5nLCB2bm9kZS5jb250ZXh0KTtcbiAgICAgIGVsLl92T3B0aW9ucyA9IFtdLm1hcC5jYWxsKGVsLm9wdGlvbnMsIGdldFZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKHZub2RlLnRhZyA9PT0gJ3RleHRhcmVhJyB8fCBpc1RleHRJbnB1dFR5cGUoZWwudHlwZSkpIHtcbiAgICAgIGVsLl92TW9kaWZpZXJzID0gYmluZGluZy5tb2RpZmllcnM7XG4gICAgICBpZiAoIWJpbmRpbmcubW9kaWZpZXJzLmxhenkpIHtcbiAgICAgICAgLy8gU2FmYXJpIDwgMTAuMiAmIFVJV2ViVmlldyBkb2Vzbid0IGZpcmUgY29tcG9zaXRpb25lbmQgd2hlblxuICAgICAgICAvLyBzd2l0Y2hpbmcgZm9jdXMgYmVmb3JlIGNvbmZpcm1pbmcgY29tcG9zaXRpb24gY2hvaWNlXG4gICAgICAgIC8vIHRoaXMgYWxzbyBmaXhlcyB0aGUgaXNzdWUgd2hlcmUgc29tZSBicm93c2VycyBlLmcuIGlPUyBDaHJvbWVcbiAgICAgICAgLy8gZmlyZXMgXCJjaGFuZ2VcIiBpbnN0ZWFkIG9mIFwiaW5wdXRcIiBvbiBhdXRvY29tcGxldGUuXG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIG9uQ29tcG9zaXRpb25FbmQpO1xuICAgICAgICBpZiAoIWlzQW5kcm9pZCkge1xuICAgICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NvbXBvc2l0aW9uc3RhcnQnLCBvbkNvbXBvc2l0aW9uU3RhcnQpO1xuICAgICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NvbXBvc2l0aW9uZW5kJywgb25Db21wb3NpdGlvbkVuZCk7XG4gICAgICAgIH1cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmIChpc0lFOSkge1xuICAgICAgICAgIGVsLnZtb2RlbCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGNvbXBvbmVudFVwZGF0ZWQ6IGZ1bmN0aW9uIGNvbXBvbmVudFVwZGF0ZWQoZWwsIGJpbmRpbmcsIHZub2RlKSB7XG4gICAgaWYgKHZub2RlLnRhZyA9PT0gJ3NlbGVjdCcpIHtcbiAgICAgIHNldFNlbGVjdGVkKGVsLCBiaW5kaW5nLCB2bm9kZS5jb250ZXh0KTtcbiAgICAgIC8vIGluIGNhc2UgdGhlIG9wdGlvbnMgcmVuZGVyZWQgYnkgdi1mb3IgaGF2ZSBjaGFuZ2VkLFxuICAgICAgLy8gaXQncyBwb3NzaWJsZSB0aGF0IHRoZSB2YWx1ZSBpcyBvdXQtb2Ytc3luYyB3aXRoIHRoZSByZW5kZXJlZCBvcHRpb25zLlxuICAgICAgLy8gZGV0ZWN0IHN1Y2ggY2FzZXMgYW5kIGZpbHRlciBvdXQgdmFsdWVzIHRoYXQgbm8gbG9uZ2VyIGhhcyBhIG1hdGNoaW5nXG4gICAgICAvLyBvcHRpb24gaW4gdGhlIERPTS5cbiAgICAgIHZhciBwcmV2T3B0aW9ucyA9IGVsLl92T3B0aW9ucztcbiAgICAgIHZhciBjdXJPcHRpb25zID0gZWwuX3ZPcHRpb25zID0gW10ubWFwLmNhbGwoZWwub3B0aW9ucywgZ2V0VmFsdWUpO1xuICAgICAgaWYgKGN1ck9wdGlvbnMuc29tZShmdW5jdGlvbiAobywgaSkge1xuICAgICAgICByZXR1cm4gIWxvb3NlRXF1YWwobywgcHJldk9wdGlvbnNbaV0pO1xuICAgICAgfSkpIHtcbiAgICAgICAgLy8gdHJpZ2dlciBjaGFuZ2UgZXZlbnQgaWZcbiAgICAgICAgLy8gbm8gbWF0Y2hpbmcgb3B0aW9uIGZvdW5kIGZvciBhdCBsZWFzdCBvbmUgdmFsdWVcbiAgICAgICAgdmFyIG5lZWRSZXNldCA9IGVsLm11bHRpcGxlID8gYmluZGluZy52YWx1ZS5zb21lKGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgcmV0dXJuIGhhc05vTWF0Y2hpbmdPcHRpb24odiwgY3VyT3B0aW9ucyk7XG4gICAgICAgIH0pIDogYmluZGluZy52YWx1ZSAhPT0gYmluZGluZy5vbGRWYWx1ZSAmJiBoYXNOb01hdGNoaW5nT3B0aW9uKGJpbmRpbmcudmFsdWUsIGN1ck9wdGlvbnMpO1xuICAgICAgICBpZiAobmVlZFJlc2V0KSB7XG4gICAgICAgICAgdHJpZ2dlcihlbCwgJ2NoYW5nZScpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBzZXRTZWxlY3RlZChlbCwgYmluZGluZywgdm0pIHtcbiAgYWN0dWFsbHlTZXRTZWxlY3RlZChlbCwgYmluZGluZywgdm0pO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGlzSUUgfHwgaXNFZGdlKSB7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBhY3R1YWxseVNldFNlbGVjdGVkKGVsLCBiaW5kaW5nLCB2bSk7XG4gICAgfSwgMCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYWN0dWFsbHlTZXRTZWxlY3RlZChlbCwgYmluZGluZywgdm0pIHtcbiAgdmFyIHZhbHVlID0gYmluZGluZy52YWx1ZTtcbiAgdmFyIGlzTXVsdGlwbGUgPSBlbC5tdWx0aXBsZTtcbiAgaWYgKGlzTXVsdGlwbGUgJiYgIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFwiPHNlbGVjdCBtdWx0aXBsZSB2LW1vZGVsPVxcXCJcIiArIGJpbmRpbmcuZXhwcmVzc2lvbiArIFwiXFxcIj4gXCIgKyBcImV4cGVjdHMgYW4gQXJyYXkgdmFsdWUgZm9yIGl0cyBiaW5kaW5nLCBidXQgZ290IFwiICsgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKS5zbGljZSg4LCAtMSksIHZtKTtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIHNlbGVjdGVkLCBvcHRpb247XG4gIGZvciAodmFyIGkgPSAwLCBsID0gZWwub3B0aW9ucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBvcHRpb24gPSBlbC5vcHRpb25zW2ldO1xuICAgIGlmIChpc011bHRpcGxlKSB7XG4gICAgICBzZWxlY3RlZCA9IGxvb3NlSW5kZXhPZih2YWx1ZSwgZ2V0VmFsdWUob3B0aW9uKSkgPiAtMTtcbiAgICAgIGlmIChvcHRpb24uc2VsZWN0ZWQgIT09IHNlbGVjdGVkKSB7XG4gICAgICAgIG9wdGlvbi5zZWxlY3RlZCA9IHNlbGVjdGVkO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAobG9vc2VFcXVhbChnZXRWYWx1ZShvcHRpb24pLCB2YWx1ZSkpIHtcbiAgICAgICAgaWYgKGVsLnNlbGVjdGVkSW5kZXggIT09IGkpIHtcbiAgICAgICAgICBlbC5zZWxlY3RlZEluZGV4ID0gaTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmICghaXNNdWx0aXBsZSkge1xuICAgIGVsLnNlbGVjdGVkSW5kZXggPSAtMTtcbiAgfVxufVxuXG5mdW5jdGlvbiBoYXNOb01hdGNoaW5nT3B0aW9uKHZhbHVlLCBvcHRpb25zKSB7XG4gIHJldHVybiBvcHRpb25zLmV2ZXJ5KGZ1bmN0aW9uIChvKSB7XG4gICAgcmV0dXJuICFsb29zZUVxdWFsKG8sIHZhbHVlKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGdldFZhbHVlKG9wdGlvbikge1xuICByZXR1cm4gJ192YWx1ZScgaW4gb3B0aW9uID8gb3B0aW9uLl92YWx1ZSA6IG9wdGlvbi52YWx1ZTtcbn1cblxuZnVuY3Rpb24gb25Db21wb3NpdGlvblN0YXJ0KGUpIHtcbiAgZS50YXJnZXQuY29tcG9zaW5nID0gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gb25Db21wb3NpdGlvbkVuZChlKSB7XG4gIC8vIHByZXZlbnQgdHJpZ2dlcmluZyBhbiBpbnB1dCBldmVudCBmb3Igbm8gcmVhc29uXG4gIGlmICghZS50YXJnZXQuY29tcG9zaW5nKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGUudGFyZ2V0LmNvbXBvc2luZyA9IGZhbHNlO1xuICB0cmlnZ2VyKGUudGFyZ2V0LCAnaW5wdXQnKTtcbn1cblxuZnVuY3Rpb24gdHJpZ2dlcihlbCwgdHlwZSkge1xuICB2YXIgZSA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdIVE1MRXZlbnRzJyk7XG4gIGUuaW5pdEV2ZW50KHR5cGUsIHRydWUsIHRydWUpO1xuICBlbC5kaXNwYXRjaEV2ZW50KGUpO1xufVxuXG4vKiAgKi9cblxuLy8gcmVjdXJzaXZlbHkgc2VhcmNoIGZvciBwb3NzaWJsZSB0cmFuc2l0aW9uIGRlZmluZWQgaW5zaWRlIHRoZSBjb21wb25lbnQgcm9vdFxuZnVuY3Rpb24gbG9jYXRlTm9kZSh2bm9kZSkge1xuICByZXR1cm4gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgJiYgKCF2bm9kZS5kYXRhIHx8ICF2bm9kZS5kYXRhLnRyYW5zaXRpb24pID8gbG9jYXRlTm9kZSh2bm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGUpIDogdm5vZGU7XG59XG5cbnZhciBzaG93ID0ge1xuICBiaW5kOiBmdW5jdGlvbiBiaW5kKGVsLCByZWYsIHZub2RlKSB7XG4gICAgdmFyIHZhbHVlID0gcmVmLnZhbHVlO1xuXG4gICAgdm5vZGUgPSBsb2NhdGVOb2RlKHZub2RlKTtcbiAgICB2YXIgdHJhbnNpdGlvbiQkMSA9IHZub2RlLmRhdGEgJiYgdm5vZGUuZGF0YS50cmFuc2l0aW9uO1xuICAgIHZhciBvcmlnaW5hbERpc3BsYXkgPSBlbC5fX3ZPcmlnaW5hbERpc3BsYXkgPSBlbC5zdHlsZS5kaXNwbGF5ID09PSAnbm9uZScgPyAnJyA6IGVsLnN0eWxlLmRpc3BsYXk7XG4gICAgaWYgKHZhbHVlICYmIHRyYW5zaXRpb24kJDEpIHtcbiAgICAgIHZub2RlLmRhdGEuc2hvdyA9IHRydWU7XG4gICAgICBlbnRlcih2bm9kZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gb3JpZ2luYWxEaXNwbGF5O1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSB2YWx1ZSA/IG9yaWdpbmFsRGlzcGxheSA6ICdub25lJztcbiAgICB9XG4gIH0sXG5cbiAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUoZWwsIHJlZiwgdm5vZGUpIHtcbiAgICB2YXIgdmFsdWUgPSByZWYudmFsdWU7XG4gICAgdmFyIG9sZFZhbHVlID0gcmVmLm9sZFZhbHVlO1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHZhbHVlID09PSBvbGRWYWx1ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2bm9kZSA9IGxvY2F0ZU5vZGUodm5vZGUpO1xuICAgIHZhciB0cmFuc2l0aW9uJCQxID0gdm5vZGUuZGF0YSAmJiB2bm9kZS5kYXRhLnRyYW5zaXRpb247XG4gICAgaWYgKHRyYW5zaXRpb24kJDEpIHtcbiAgICAgIHZub2RlLmRhdGEuc2hvdyA9IHRydWU7XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgZW50ZXIodm5vZGUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gZWwuX192T3JpZ2luYWxEaXNwbGF5O1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxlYXZlKHZub2RlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSB2YWx1ZSA/IGVsLl9fdk9yaWdpbmFsRGlzcGxheSA6ICdub25lJztcbiAgICB9XG4gIH0sXG5cbiAgdW5iaW5kOiBmdW5jdGlvbiB1bmJpbmQoZWwsIGJpbmRpbmcsIHZub2RlLCBvbGRWbm9kZSwgaXNEZXN0cm95KSB7XG4gICAgaWYgKCFpc0Rlc3Ryb3kpIHtcbiAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSBlbC5fX3ZPcmlnaW5hbERpc3BsYXk7XG4gICAgfVxuICB9XG59O1xuXG52YXIgcGxhdGZvcm1EaXJlY3RpdmVzID0ge1xuICBtb2RlbDogbW9kZWwkMSxcbiAgc2hvdzogc2hvd1xufTtcblxuLyogICovXG5cbi8vIFByb3ZpZGVzIHRyYW5zaXRpb24gc3VwcG9ydCBmb3IgYSBzaW5nbGUgZWxlbWVudC9jb21wb25lbnQuXG4vLyBzdXBwb3J0cyB0cmFuc2l0aW9uIG1vZGUgKG91dC1pbiAvIGluLW91dClcblxudmFyIHRyYW5zaXRpb25Qcm9wcyA9IHtcbiAgbmFtZTogU3RyaW5nLFxuICBhcHBlYXI6IEJvb2xlYW4sXG4gIGNzczogQm9vbGVhbixcbiAgbW9kZTogU3RyaW5nLFxuICB0eXBlOiBTdHJpbmcsXG4gIGVudGVyQ2xhc3M6IFN0cmluZyxcbiAgbGVhdmVDbGFzczogU3RyaW5nLFxuICBlbnRlclRvQ2xhc3M6IFN0cmluZyxcbiAgbGVhdmVUb0NsYXNzOiBTdHJpbmcsXG4gIGVudGVyQWN0aXZlQ2xhc3M6IFN0cmluZyxcbiAgbGVhdmVBY3RpdmVDbGFzczogU3RyaW5nLFxuICBhcHBlYXJDbGFzczogU3RyaW5nLFxuICBhcHBlYXJBY3RpdmVDbGFzczogU3RyaW5nLFxuICBhcHBlYXJUb0NsYXNzOiBTdHJpbmcsXG4gIGR1cmF0aW9uOiBbTnVtYmVyLCBTdHJpbmcsIE9iamVjdF1cbn07XG5cbi8vIGluIGNhc2UgdGhlIGNoaWxkIGlzIGFsc28gYW4gYWJzdHJhY3QgY29tcG9uZW50LCBlLmcuIDxrZWVwLWFsaXZlPlxuLy8gd2Ugd2FudCB0byByZWN1cnNpdmVseSByZXRyaWV2ZSB0aGUgcmVhbCBjb21wb25lbnQgdG8gYmUgcmVuZGVyZWRcbmZ1bmN0aW9uIGdldFJlYWxDaGlsZCh2bm9kZSkge1xuICB2YXIgY29tcE9wdGlvbnMgPSB2bm9kZSAmJiB2bm9kZS5jb21wb25lbnRPcHRpb25zO1xuICBpZiAoY29tcE9wdGlvbnMgJiYgY29tcE9wdGlvbnMuQ3Rvci5vcHRpb25zLmFic3RyYWN0KSB7XG4gICAgcmV0dXJuIGdldFJlYWxDaGlsZChnZXRGaXJzdENvbXBvbmVudENoaWxkKGNvbXBPcHRpb25zLmNoaWxkcmVuKSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHZub2RlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RUcmFuc2l0aW9uRGF0YShjb21wKSB7XG4gIHZhciBkYXRhID0ge307XG4gIHZhciBvcHRpb25zID0gY29tcC4kb3B0aW9ucztcbiAgLy8gcHJvcHNcbiAgZm9yICh2YXIga2V5IGluIG9wdGlvbnMucHJvcHNEYXRhKSB7XG4gICAgZGF0YVtrZXldID0gY29tcFtrZXldO1xuICB9XG4gIC8vIGV2ZW50cy5cbiAgLy8gZXh0cmFjdCBsaXN0ZW5lcnMgYW5kIHBhc3MgdGhlbSBkaXJlY3RseSB0byB0aGUgdHJhbnNpdGlvbiBtZXRob2RzXG4gIHZhciBsaXN0ZW5lcnMgPSBvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnM7XG4gIGZvciAodmFyIGtleSQxIGluIGxpc3RlbmVycykge1xuICAgIGRhdGFbY2FtZWxpemUoa2V5JDEpXSA9IGxpc3RlbmVyc1trZXkkMV07XG4gIH1cbiAgcmV0dXJuIGRhdGE7XG59XG5cbmZ1bmN0aW9uIHBsYWNlaG9sZGVyKGgsIHJhd0NoaWxkKSB7XG4gIGlmICgvXFxkLWtlZXAtYWxpdmUkLy50ZXN0KHJhd0NoaWxkLnRhZykpIHtcbiAgICByZXR1cm4gaCgna2VlcC1hbGl2ZScsIHtcbiAgICAgIHByb3BzOiByYXdDaGlsZC5jb21wb25lbnRPcHRpb25zLnByb3BzRGF0YVxuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhc1BhcmVudFRyYW5zaXRpb24odm5vZGUpIHtcbiAgd2hpbGUgKHZub2RlID0gdm5vZGUucGFyZW50KSB7XG4gICAgaWYgKHZub2RlLmRhdGEudHJhbnNpdGlvbikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGlzU2FtZUNoaWxkKGNoaWxkLCBvbGRDaGlsZCkge1xuICByZXR1cm4gb2xkQ2hpbGQua2V5ID09PSBjaGlsZC5rZXkgJiYgb2xkQ2hpbGQudGFnID09PSBjaGlsZC50YWc7XG59XG5cbnZhciBUcmFuc2l0aW9uID0ge1xuICBuYW1lOiAndHJhbnNpdGlvbicsXG4gIHByb3BzOiB0cmFuc2l0aW9uUHJvcHMsXG4gIGFic3RyYWN0OiB0cnVlLFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKGgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuJG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuO1xuICAgIGlmICghY2hpbGRyZW4pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBmaWx0ZXIgb3V0IHRleHQgbm9kZXMgKHBvc3NpYmxlIHdoaXRlc3BhY2VzKVxuICAgIGNoaWxkcmVuID0gY2hpbGRyZW4uZmlsdGVyKGZ1bmN0aW9uIChjKSB7XG4gICAgICByZXR1cm4gYy50YWcgfHwgaXNBc3luY1BsYWNlaG9sZGVyKGMpO1xuICAgIH0pO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gd2FybiBtdWx0aXBsZSBlbGVtZW50c1xuICAgIGlmIChmYWxzZSkge1xuICAgICAgd2FybignPHRyYW5zaXRpb24+IGNhbiBvbmx5IGJlIHVzZWQgb24gYSBzaW5nbGUgZWxlbWVudC4gVXNlICcgKyAnPHRyYW5zaXRpb24tZ3JvdXA+IGZvciBsaXN0cy4nLCB0aGlzLiRwYXJlbnQpO1xuICAgIH1cblxuICAgIHZhciBtb2RlID0gdGhpcy5tb2RlO1xuXG4gICAgLy8gd2FybiBpbnZhbGlkIG1vZGVcbiAgICBpZiAoZmFsc2UpIHtcbiAgICAgIHdhcm4oJ2ludmFsaWQgPHRyYW5zaXRpb24+IG1vZGU6ICcgKyBtb2RlLCB0aGlzLiRwYXJlbnQpO1xuICAgIH1cblxuICAgIHZhciByYXdDaGlsZCA9IGNoaWxkcmVuWzBdO1xuXG4gICAgLy8gaWYgdGhpcyBpcyBhIGNvbXBvbmVudCByb290IG5vZGUgYW5kIHRoZSBjb21wb25lbnQnc1xuICAgIC8vIHBhcmVudCBjb250YWluZXIgbm9kZSBhbHNvIGhhcyB0cmFuc2l0aW9uLCBza2lwLlxuICAgIGlmIChoYXNQYXJlbnRUcmFuc2l0aW9uKHRoaXMuJHZub2RlKSkge1xuICAgICAgcmV0dXJuIHJhd0NoaWxkO1xuICAgIH1cblxuICAgIC8vIGFwcGx5IHRyYW5zaXRpb24gZGF0YSB0byBjaGlsZFxuICAgIC8vIHVzZSBnZXRSZWFsQ2hpbGQoKSB0byBpZ25vcmUgYWJzdHJhY3QgY29tcG9uZW50cyBlLmcuIGtlZXAtYWxpdmVcbiAgICB2YXIgY2hpbGQgPSBnZXRSZWFsQ2hpbGQocmF3Q2hpbGQpO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghY2hpbGQpIHtcbiAgICAgIHJldHVybiByYXdDaGlsZDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fbGVhdmluZykge1xuICAgICAgcmV0dXJuIHBsYWNlaG9sZGVyKGgsIHJhd0NoaWxkKTtcbiAgICB9XG5cbiAgICAvLyBlbnN1cmUgYSBrZXkgdGhhdCBpcyB1bmlxdWUgdG8gdGhlIHZub2RlIHR5cGUgYW5kIHRvIHRoaXMgdHJhbnNpdGlvblxuICAgIC8vIGNvbXBvbmVudCBpbnN0YW5jZS4gVGhpcyBrZXkgd2lsbCBiZSB1c2VkIHRvIHJlbW92ZSBwZW5kaW5nIGxlYXZpbmcgbm9kZXNcbiAgICAvLyBkdXJpbmcgZW50ZXJpbmcuXG4gICAgdmFyIGlkID0gXCJfX3RyYW5zaXRpb24tXCIgKyB0aGlzLl91aWQgKyBcIi1cIjtcbiAgICBjaGlsZC5rZXkgPSBjaGlsZC5rZXkgPT0gbnVsbCA/IGNoaWxkLmlzQ29tbWVudCA/IGlkICsgJ2NvbW1lbnQnIDogaWQgKyBjaGlsZC50YWcgOiBpc1ByaW1pdGl2ZShjaGlsZC5rZXkpID8gU3RyaW5nKGNoaWxkLmtleSkuaW5kZXhPZihpZCkgPT09IDAgPyBjaGlsZC5rZXkgOiBpZCArIGNoaWxkLmtleSA6IGNoaWxkLmtleTtcblxuICAgIHZhciBkYXRhID0gKGNoaWxkLmRhdGEgfHwgKGNoaWxkLmRhdGEgPSB7fSkpLnRyYW5zaXRpb24gPSBleHRyYWN0VHJhbnNpdGlvbkRhdGEodGhpcyk7XG4gICAgdmFyIG9sZFJhd0NoaWxkID0gdGhpcy5fdm5vZGU7XG4gICAgdmFyIG9sZENoaWxkID0gZ2V0UmVhbENoaWxkKG9sZFJhd0NoaWxkKTtcblxuICAgIC8vIG1hcmsgdi1zaG93XG4gICAgLy8gc28gdGhhdCB0aGUgdHJhbnNpdGlvbiBtb2R1bGUgY2FuIGhhbmQgb3ZlciB0aGUgY29udHJvbCB0byB0aGUgZGlyZWN0aXZlXG4gICAgaWYgKGNoaWxkLmRhdGEuZGlyZWN0aXZlcyAmJiBjaGlsZC5kYXRhLmRpcmVjdGl2ZXMuc29tZShmdW5jdGlvbiAoZCkge1xuICAgICAgcmV0dXJuIGQubmFtZSA9PT0gJ3Nob3cnO1xuICAgIH0pKSB7XG4gICAgICBjaGlsZC5kYXRhLnNob3cgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChvbGRDaGlsZCAmJiBvbGRDaGlsZC5kYXRhICYmICFpc1NhbWVDaGlsZChjaGlsZCwgb2xkQ2hpbGQpICYmICFpc0FzeW5jUGxhY2Vob2xkZXIob2xkQ2hpbGQpKSB7XG4gICAgICAvLyByZXBsYWNlIG9sZCBjaGlsZCB0cmFuc2l0aW9uIGRhdGEgd2l0aCBmcmVzaCBvbmVcbiAgICAgIC8vIGltcG9ydGFudCBmb3IgZHluYW1pYyB0cmFuc2l0aW9ucyFcbiAgICAgIHZhciBvbGREYXRhID0gb2xkQ2hpbGQgJiYgKG9sZENoaWxkLmRhdGEudHJhbnNpdGlvbiA9IGV4dGVuZCh7fSwgZGF0YSkpO1xuICAgICAgLy8gaGFuZGxlIHRyYW5zaXRpb24gbW9kZVxuICAgICAgaWYgKG1vZGUgPT09ICdvdXQtaW4nKSB7XG4gICAgICAgIC8vIHJldHVybiBwbGFjZWhvbGRlciBub2RlIGFuZCBxdWV1ZSB1cGRhdGUgd2hlbiBsZWF2ZSBmaW5pc2hlc1xuICAgICAgICB0aGlzLl9sZWF2aW5nID0gdHJ1ZTtcbiAgICAgICAgbWVyZ2VWTm9kZUhvb2sob2xkRGF0YSwgJ2FmdGVyTGVhdmUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhpcyQxLl9sZWF2aW5nID0gZmFsc2U7XG4gICAgICAgICAgdGhpcyQxLiRmb3JjZVVwZGF0ZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHBsYWNlaG9sZGVyKGgsIHJhd0NoaWxkKTtcbiAgICAgIH0gZWxzZSBpZiAobW9kZSA9PT0gJ2luLW91dCcpIHtcbiAgICAgICAgaWYgKGlzQXN5bmNQbGFjZWhvbGRlcihjaGlsZCkpIHtcbiAgICAgICAgICByZXR1cm4gb2xkUmF3Q2hpbGQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRlbGF5ZWRMZWF2ZTtcbiAgICAgICAgdmFyIHBlcmZvcm1MZWF2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBkZWxheWVkTGVhdmUoKTtcbiAgICAgICAgfTtcbiAgICAgICAgbWVyZ2VWTm9kZUhvb2soZGF0YSwgJ2FmdGVyRW50ZXInLCBwZXJmb3JtTGVhdmUpO1xuICAgICAgICBtZXJnZVZOb2RlSG9vayhkYXRhLCAnZW50ZXJDYW5jZWxsZWQnLCBwZXJmb3JtTGVhdmUpO1xuICAgICAgICBtZXJnZVZOb2RlSG9vayhvbGREYXRhLCAnZGVsYXlMZWF2ZScsIGZ1bmN0aW9uIChsZWF2ZSkge1xuICAgICAgICAgIGRlbGF5ZWRMZWF2ZSA9IGxlYXZlO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmF3Q2hpbGQ7XG4gIH1cbn07XG5cbi8qICAqL1xuXG4vLyBQcm92aWRlcyB0cmFuc2l0aW9uIHN1cHBvcnQgZm9yIGxpc3QgaXRlbXMuXG4vLyBzdXBwb3J0cyBtb3ZlIHRyYW5zaXRpb25zIHVzaW5nIHRoZSBGTElQIHRlY2huaXF1ZS5cblxuLy8gQmVjYXVzZSB0aGUgdmRvbSdzIGNoaWxkcmVuIHVwZGF0ZSBhbGdvcml0aG0gaXMgXCJ1bnN0YWJsZVwiIC0gaS5lLlxuLy8gaXQgZG9lc24ndCBndWFyYW50ZWUgdGhlIHJlbGF0aXZlIHBvc2l0aW9uaW5nIG9mIHJlbW92ZWQgZWxlbWVudHMsXG4vLyB3ZSBmb3JjZSB0cmFuc2l0aW9uLWdyb3VwIHRvIHVwZGF0ZSBpdHMgY2hpbGRyZW4gaW50byB0d28gcGFzc2VzOlxuLy8gaW4gdGhlIGZpcnN0IHBhc3MsIHdlIHJlbW92ZSBhbGwgbm9kZXMgdGhhdCBuZWVkIHRvIGJlIHJlbW92ZWQsXG4vLyB0cmlnZ2VyaW5nIHRoZWlyIGxlYXZpbmcgdHJhbnNpdGlvbjsgaW4gdGhlIHNlY29uZCBwYXNzLCB3ZSBpbnNlcnQvbW92ZVxuLy8gaW50byB0aGUgZmluYWwgZGVzaXJlZCBzdGF0ZS4gVGhpcyB3YXkgaW4gdGhlIHNlY29uZCBwYXNzIHJlbW92ZWRcbi8vIG5vZGVzIHdpbGwgcmVtYWluIHdoZXJlIHRoZXkgc2hvdWxkIGJlLlxuXG52YXIgcHJvcHMgPSBleHRlbmQoe1xuICB0YWc6IFN0cmluZyxcbiAgbW92ZUNsYXNzOiBTdHJpbmdcbn0sIHRyYW5zaXRpb25Qcm9wcyk7XG5cbmRlbGV0ZSBwcm9wcy5tb2RlO1xuXG52YXIgVHJhbnNpdGlvbkdyb3VwID0ge1xuICBwcm9wczogcHJvcHMsXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoaCkge1xuICAgIHZhciB0YWcgPSB0aGlzLnRhZyB8fCB0aGlzLiR2bm9kZS5kYXRhLnRhZyB8fCAnc3Bhbic7XG4gICAgdmFyIG1hcCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdmFyIHByZXZDaGlsZHJlbiA9IHRoaXMucHJldkNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbjtcbiAgICB2YXIgcmF3Q2hpbGRyZW4gPSB0aGlzLiRzbG90cy5kZWZhdWx0IHx8IFtdO1xuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW4gPSBbXTtcbiAgICB2YXIgdHJhbnNpdGlvbkRhdGEgPSBleHRyYWN0VHJhbnNpdGlvbkRhdGEodGhpcyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJhd0NoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYyA9IHJhd0NoaWxkcmVuW2ldO1xuICAgICAgaWYgKGMudGFnKSB7XG4gICAgICAgIGlmIChjLmtleSAhPSBudWxsICYmIFN0cmluZyhjLmtleSkuaW5kZXhPZignX192bGlzdCcpICE9PSAwKSB7XG4gICAgICAgICAgY2hpbGRyZW4ucHVzaChjKTtcbiAgICAgICAgICBtYXBbYy5rZXldID0gYzsoYy5kYXRhIHx8IChjLmRhdGEgPSB7fSkpLnRyYW5zaXRpb24gPSB0cmFuc2l0aW9uRGF0YTtcbiAgICAgICAgfSBlbHNlIGlmIChmYWxzZSkge1xuICAgICAgICAgIHZhciBvcHRzID0gYy5jb21wb25lbnRPcHRpb25zO1xuICAgICAgICAgIHZhciBuYW1lID0gb3B0cyA/IG9wdHMuQ3Rvci5vcHRpb25zLm5hbWUgfHwgb3B0cy50YWcgfHwgJycgOiBjLnRhZztcbiAgICAgICAgICB3YXJuKFwiPHRyYW5zaXRpb24tZ3JvdXA+IGNoaWxkcmVuIG11c3QgYmUga2V5ZWQ6IDxcIiArIG5hbWUgKyBcIj5cIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocHJldkNoaWxkcmVuKSB7XG4gICAgICB2YXIga2VwdCA9IFtdO1xuICAgICAgdmFyIHJlbW92ZWQgPSBbXTtcbiAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IHByZXZDaGlsZHJlbi5sZW5ndGg7IGkkMSsrKSB7XG4gICAgICAgIHZhciBjJDEgPSBwcmV2Q2hpbGRyZW5baSQxXTtcbiAgICAgICAgYyQxLmRhdGEudHJhbnNpdGlvbiA9IHRyYW5zaXRpb25EYXRhO1xuICAgICAgICBjJDEuZGF0YS5wb3MgPSBjJDEuZWxtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBpZiAobWFwW2MkMS5rZXldKSB7XG4gICAgICAgICAga2VwdC5wdXNoKGMkMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVtb3ZlZC5wdXNoKGMkMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMua2VwdCA9IGgodGFnLCBudWxsLCBrZXB0KTtcbiAgICAgIHRoaXMucmVtb3ZlZCA9IHJlbW92ZWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGgodGFnLCBudWxsLCBjaGlsZHJlbik7XG4gIH0sXG5cbiAgYmVmb3JlVXBkYXRlOiBmdW5jdGlvbiBiZWZvcmVVcGRhdGUoKSB7XG4gICAgLy8gZm9yY2UgcmVtb3ZpbmcgcGFzc1xuICAgIHRoaXMuX19wYXRjaF9fKHRoaXMuX3Zub2RlLCB0aGlzLmtlcHQsIGZhbHNlLCAvLyBoeWRyYXRpbmdcbiAgICB0cnVlIC8vIHJlbW92ZU9ubHkgKCFpbXBvcnRhbnQsIGF2b2lkcyB1bm5lY2Vzc2FyeSBtb3ZlcylcbiAgICApO1xuICAgIHRoaXMuX3Zub2RlID0gdGhpcy5rZXB0O1xuICB9LFxuXG4gIHVwZGF0ZWQ6IGZ1bmN0aW9uIHVwZGF0ZWQoKSB7XG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5wcmV2Q2hpbGRyZW47XG4gICAgdmFyIG1vdmVDbGFzcyA9IHRoaXMubW92ZUNsYXNzIHx8ICh0aGlzLm5hbWUgfHwgJ3YnKSArICctbW92ZSc7XG4gICAgaWYgKCFjaGlsZHJlbi5sZW5ndGggfHwgIXRoaXMuaGFzTW92ZShjaGlsZHJlblswXS5lbG0sIG1vdmVDbGFzcykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyB3ZSBkaXZpZGUgdGhlIHdvcmsgaW50byB0aHJlZSBsb29wcyB0byBhdm9pZCBtaXhpbmcgRE9NIHJlYWRzIGFuZCB3cml0ZXNcbiAgICAvLyBpbiBlYWNoIGl0ZXJhdGlvbiAtIHdoaWNoIGhlbHBzIHByZXZlbnQgbGF5b3V0IHRocmFzaGluZy5cbiAgICBjaGlsZHJlbi5mb3JFYWNoKGNhbGxQZW5kaW5nQ2JzKTtcbiAgICBjaGlsZHJlbi5mb3JFYWNoKHJlY29yZFBvc2l0aW9uKTtcbiAgICBjaGlsZHJlbi5mb3JFYWNoKGFwcGx5VHJhbnNsYXRpb24pO1xuXG4gICAgLy8gZm9yY2UgcmVmbG93IHRvIHB1dCBldmVyeXRoaW5nIGluIHBvc2l0aW9uXG4gICAgdmFyIGJvZHkgPSBkb2N1bWVudC5ib2R5O1xuICAgIHZhciBmID0gYm9keS5vZmZzZXRIZWlnaHQ7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgIGlmIChjLmRhdGEubW92ZWQpIHtcbiAgICAgICAgdmFyIGVsID0gYy5lbG07XG4gICAgICAgIHZhciBzID0gZWwuc3R5bGU7XG4gICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbW92ZUNsYXNzKTtcbiAgICAgICAgcy50cmFuc2Zvcm0gPSBzLldlYmtpdFRyYW5zZm9ybSA9IHMudHJhbnNpdGlvbkR1cmF0aW9uID0gJyc7XG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIodHJhbnNpdGlvbkVuZEV2ZW50LCBlbC5fbW92ZUNiID0gZnVuY3Rpb24gY2IoZSkge1xuICAgICAgICAgIGlmICghZSB8fCAvdHJhbnNmb3JtJC8udGVzdChlLnByb3BlcnR5TmFtZSkpIHtcbiAgICAgICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIodHJhbnNpdGlvbkVuZEV2ZW50LCBjYik7XG4gICAgICAgICAgICBlbC5fbW92ZUNiID0gbnVsbDtcbiAgICAgICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbW92ZUNsYXNzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuXG4gIG1ldGhvZHM6IHtcbiAgICBoYXNNb3ZlOiBmdW5jdGlvbiBoYXNNb3ZlKGVsLCBtb3ZlQ2xhc3MpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKCFoYXNUcmFuc2l0aW9uKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKHRoaXMuX2hhc01vdmUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hhc01vdmU7XG4gICAgICB9XG4gICAgICAvLyBEZXRlY3Qgd2hldGhlciBhbiBlbGVtZW50IHdpdGggdGhlIG1vdmUgY2xhc3MgYXBwbGllZCBoYXNcbiAgICAgIC8vIENTUyB0cmFuc2l0aW9ucy4gU2luY2UgdGhlIGVsZW1lbnQgbWF5IGJlIGluc2lkZSBhbiBlbnRlcmluZ1xuICAgICAgLy8gdHJhbnNpdGlvbiBhdCB0aGlzIHZlcnkgbW9tZW50LCB3ZSBtYWtlIGEgY2xvbmUgb2YgaXQgYW5kIHJlbW92ZVxuICAgICAgLy8gYWxsIG90aGVyIHRyYW5zaXRpb24gY2xhc3NlcyBhcHBsaWVkIHRvIGVuc3VyZSBvbmx5IHRoZSBtb3ZlIGNsYXNzXG4gICAgICAvLyBpcyBhcHBsaWVkLlxuICAgICAgdmFyIGNsb25lID0gZWwuY2xvbmVOb2RlKCk7XG4gICAgICBpZiAoZWwuX3RyYW5zaXRpb25DbGFzc2VzKSB7XG4gICAgICAgIGVsLl90cmFuc2l0aW9uQ2xhc3Nlcy5mb3JFYWNoKGZ1bmN0aW9uIChjbHMpIHtcbiAgICAgICAgICByZW1vdmVDbGFzcyhjbG9uZSwgY2xzKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBhZGRDbGFzcyhjbG9uZSwgbW92ZUNsYXNzKTtcbiAgICAgIGNsb25lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICB0aGlzLiRlbC5hcHBlbmRDaGlsZChjbG9uZSk7XG4gICAgICB2YXIgaW5mbyA9IGdldFRyYW5zaXRpb25JbmZvKGNsb25lKTtcbiAgICAgIHRoaXMuJGVsLnJlbW92ZUNoaWxkKGNsb25lKTtcbiAgICAgIHJldHVybiB0aGlzLl9oYXNNb3ZlID0gaW5mby5oYXNUcmFuc2Zvcm07XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBjYWxsUGVuZGluZ0NicyhjKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoYy5lbG0uX21vdmVDYikge1xuICAgIGMuZWxtLl9tb3ZlQ2IoKTtcbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGMuZWxtLl9lbnRlckNiKSB7XG4gICAgYy5lbG0uX2VudGVyQ2IoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZWNvcmRQb3NpdGlvbihjKSB7XG4gIGMuZGF0YS5uZXdQb3MgPSBjLmVsbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbn1cblxuZnVuY3Rpb24gYXBwbHlUcmFuc2xhdGlvbihjKSB7XG4gIHZhciBvbGRQb3MgPSBjLmRhdGEucG9zO1xuICB2YXIgbmV3UG9zID0gYy5kYXRhLm5ld1BvcztcbiAgdmFyIGR4ID0gb2xkUG9zLmxlZnQgLSBuZXdQb3MubGVmdDtcbiAgdmFyIGR5ID0gb2xkUG9zLnRvcCAtIG5ld1Bvcy50b3A7XG4gIGlmIChkeCB8fCBkeSkge1xuICAgIGMuZGF0YS5tb3ZlZCA9IHRydWU7XG4gICAgdmFyIHMgPSBjLmVsbS5zdHlsZTtcbiAgICBzLnRyYW5zZm9ybSA9IHMuV2Via2l0VHJhbnNmb3JtID0gXCJ0cmFuc2xhdGUoXCIgKyBkeCArIFwicHgsXCIgKyBkeSArIFwicHgpXCI7XG4gICAgcy50cmFuc2l0aW9uRHVyYXRpb24gPSAnMHMnO1xuICB9XG59XG5cbnZhciBwbGF0Zm9ybUNvbXBvbmVudHMgPSB7XG4gIFRyYW5zaXRpb246IFRyYW5zaXRpb24sXG4gIFRyYW5zaXRpb25Hcm91cDogVHJhbnNpdGlvbkdyb3VwXG59O1xuXG4vKiAgKi9cblxuLy8gaW5zdGFsbCBwbGF0Zm9ybSBzcGVjaWZpYyB1dGlsc1xuVnVlJDMuY29uZmlnLm11c3RVc2VQcm9wID0gbXVzdFVzZVByb3A7XG5WdWUkMy5jb25maWcuaXNSZXNlcnZlZFRhZyA9IGlzUmVzZXJ2ZWRUYWc7XG5WdWUkMy5jb25maWcuaXNSZXNlcnZlZEF0dHIgPSBpc1Jlc2VydmVkQXR0cjtcblZ1ZSQzLmNvbmZpZy5nZXRUYWdOYW1lc3BhY2UgPSBnZXRUYWdOYW1lc3BhY2U7XG5WdWUkMy5jb25maWcuaXNVbmtub3duRWxlbWVudCA9IGlzVW5rbm93bkVsZW1lbnQ7XG5cbi8vIGluc3RhbGwgcGxhdGZvcm0gcnVudGltZSBkaXJlY3RpdmVzICYgY29tcG9uZW50c1xuZXh0ZW5kKFZ1ZSQzLm9wdGlvbnMuZGlyZWN0aXZlcywgcGxhdGZvcm1EaXJlY3RpdmVzKTtcbmV4dGVuZChWdWUkMy5vcHRpb25zLmNvbXBvbmVudHMsIHBsYXRmb3JtQ29tcG9uZW50cyk7XG5cbi8vIGluc3RhbGwgcGxhdGZvcm0gcGF0Y2ggZnVuY3Rpb25cblZ1ZSQzLnByb3RvdHlwZS5fX3BhdGNoX18gPSBpbkJyb3dzZXIgPyBwYXRjaCA6IG5vb3A7XG5cbi8vIHB1YmxpYyBtb3VudCBtZXRob2RcblZ1ZSQzLnByb3RvdHlwZS4kbW91bnQgPSBmdW5jdGlvbiAoZWwsIGh5ZHJhdGluZykge1xuICBlbCA9IGVsICYmIGluQnJvd3NlciA/IHF1ZXJ5KGVsKSA6IHVuZGVmaW5lZDtcbiAgcmV0dXJuIG1vdW50Q29tcG9uZW50KHRoaXMsIGVsLCBoeWRyYXRpbmcpO1xufTtcblxuLy8gZGV2dG9vbHMgZ2xvYmFsIGhvb2tcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgaWYgKGNvbmZpZy5kZXZ0b29scykge1xuICAgIGlmIChkZXZ0b29scykge1xuICAgICAgZGV2dG9vbHMuZW1pdCgnaW5pdCcsIFZ1ZSQzKTtcbiAgICB9IGVsc2UgaWYgKGZhbHNlKSB7XG4gICAgICBjb25zb2xlW2NvbnNvbGUuaW5mbyA/ICdpbmZvJyA6ICdsb2cnXSgnRG93bmxvYWQgdGhlIFZ1ZSBEZXZ0b29scyBleHRlbnNpb24gZm9yIGEgYmV0dGVyIGRldmVsb3BtZW50IGV4cGVyaWVuY2U6XFxuJyArICdodHRwczovL2dpdGh1Yi5jb20vdnVlanMvdnVlLWRldnRvb2xzJyk7XG4gICAgfVxuICB9XG4gIGlmIChmYWxzZSkge1xuICAgIGNvbnNvbGVbY29uc29sZS5pbmZvID8gJ2luZm8nIDogJ2xvZyddKFwiWW91IGFyZSBydW5uaW5nIFZ1ZSBpbiBkZXZlbG9wbWVudCBtb2RlLlxcblwiICsgXCJNYWtlIHN1cmUgdG8gdHVybiBvbiBwcm9kdWN0aW9uIG1vZGUgd2hlbiBkZXBsb3lpbmcgZm9yIHByb2R1Y3Rpb24uXFxuXCIgKyBcIlNlZSBtb3JlIHRpcHMgYXQgaHR0cHM6Ly92dWVqcy5vcmcvZ3VpZGUvZGVwbG95bWVudC5odG1sXCIpO1xuICB9XG59LCAwKTtcblxuLyogICovXG5cbi8vIGNoZWNrIHdoZXRoZXIgY3VycmVudCBicm93c2VyIGVuY29kZXMgYSBjaGFyIGluc2lkZSBhdHRyaWJ1dGUgdmFsdWVzXG5mdW5jdGlvbiBzaG91bGREZWNvZGUoY29udGVudCwgZW5jb2RlZCkge1xuICB2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIGRpdi5pbm5lckhUTUwgPSBcIjxkaXYgYT1cXFwiXCIgKyBjb250ZW50ICsgXCJcXFwiLz5cIjtcbiAgcmV0dXJuIGRpdi5pbm5lckhUTUwuaW5kZXhPZihlbmNvZGVkKSA+IDA7XG59XG5cbi8vICMzNjYzXG4vLyBJRSBlbmNvZGVzIG5ld2xpbmVzIGluc2lkZSBhdHRyaWJ1dGUgdmFsdWVzIHdoaWxlIG90aGVyIGJyb3dzZXJzIGRvbid0XG52YXIgc2hvdWxkRGVjb2RlTmV3bGluZXMgPSBpbkJyb3dzZXIgPyBzaG91bGREZWNvZGUoJ1xcbicsICcmIzEwOycpIDogZmFsc2U7XG5cbi8qICAqL1xuXG52YXIgZGVmYXVsdFRhZ1JFID0gL1xce1xceygoPzoufFxcbikrPylcXH1cXH0vZztcbnZhciByZWdleEVzY2FwZVJFID0gL1stLiorP14ke30oKXxbXFxdXFwvXFxcXF0vZztcblxudmFyIGJ1aWxkUmVnZXggPSBjYWNoZWQoZnVuY3Rpb24gKGRlbGltaXRlcnMpIHtcbiAgdmFyIG9wZW4gPSBkZWxpbWl0ZXJzWzBdLnJlcGxhY2UocmVnZXhFc2NhcGVSRSwgJ1xcXFwkJicpO1xuICB2YXIgY2xvc2UgPSBkZWxpbWl0ZXJzWzFdLnJlcGxhY2UocmVnZXhFc2NhcGVSRSwgJ1xcXFwkJicpO1xuICByZXR1cm4gbmV3IFJlZ0V4cChvcGVuICsgJygoPzoufFxcXFxuKSs/KScgKyBjbG9zZSwgJ2cnKTtcbn0pO1xuXG5mdW5jdGlvbiBwYXJzZVRleHQodGV4dCwgZGVsaW1pdGVycykge1xuICB2YXIgdGFnUkUgPSBkZWxpbWl0ZXJzID8gYnVpbGRSZWdleChkZWxpbWl0ZXJzKSA6IGRlZmF1bHRUYWdSRTtcbiAgaWYgKCF0YWdSRS50ZXN0KHRleHQpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciB0b2tlbnMgPSBbXTtcbiAgdmFyIGxhc3RJbmRleCA9IHRhZ1JFLmxhc3RJbmRleCA9IDA7XG4gIHZhciBtYXRjaCwgaW5kZXg7XG4gIHdoaWxlIChtYXRjaCA9IHRhZ1JFLmV4ZWModGV4dCkpIHtcbiAgICBpbmRleCA9IG1hdGNoLmluZGV4O1xuICAgIC8vIHB1c2ggdGV4dCB0b2tlblxuICAgIGlmIChpbmRleCA+IGxhc3RJbmRleCkge1xuICAgICAgdG9rZW5zLnB1c2goSlNPTi5zdHJpbmdpZnkodGV4dC5zbGljZShsYXN0SW5kZXgsIGluZGV4KSkpO1xuICAgIH1cbiAgICAvLyB0YWcgdG9rZW5cbiAgICB2YXIgZXhwID0gcGFyc2VGaWx0ZXJzKG1hdGNoWzFdLnRyaW0oKSk7XG4gICAgdG9rZW5zLnB1c2goXCJfcyhcIiArIGV4cCArIFwiKVwiKTtcbiAgICBsYXN0SW5kZXggPSBpbmRleCArIG1hdGNoWzBdLmxlbmd0aDtcbiAgfVxuICBpZiAobGFzdEluZGV4IDwgdGV4dC5sZW5ndGgpIHtcbiAgICB0b2tlbnMucHVzaChKU09OLnN0cmluZ2lmeSh0ZXh0LnNsaWNlKGxhc3RJbmRleCkpKTtcbiAgfVxuICByZXR1cm4gdG9rZW5zLmpvaW4oJysnKTtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIHRyYW5zZm9ybU5vZGUoZWwsIG9wdGlvbnMpIHtcbiAgdmFyIHdhcm4gPSBvcHRpb25zLndhcm4gfHwgYmFzZVdhcm47XG4gIHZhciBzdGF0aWNDbGFzcyA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICdjbGFzcycpO1xuICBpZiAoZmFsc2UpIHtcbiAgICB2YXIgZXhwcmVzc2lvbiA9IHBhcnNlVGV4dChzdGF0aWNDbGFzcywgb3B0aW9ucy5kZWxpbWl0ZXJzKTtcbiAgICBpZiAoZXhwcmVzc2lvbikge1xuICAgICAgd2FybihcImNsYXNzPVxcXCJcIiArIHN0YXRpY0NsYXNzICsgXCJcXFwiOiBcIiArICdJbnRlcnBvbGF0aW9uIGluc2lkZSBhdHRyaWJ1dGVzIGhhcyBiZWVuIHJlbW92ZWQuICcgKyAnVXNlIHYtYmluZCBvciB0aGUgY29sb24gc2hvcnRoYW5kIGluc3RlYWQuIEZvciBleGFtcGxlLCAnICsgJ2luc3RlYWQgb2YgPGRpdiBjbGFzcz1cInt7IHZhbCB9fVwiPiwgdXNlIDxkaXYgOmNsYXNzPVwidmFsXCI+LicpO1xuICAgIH1cbiAgfVxuICBpZiAoc3RhdGljQ2xhc3MpIHtcbiAgICBlbC5zdGF0aWNDbGFzcyA9IEpTT04uc3RyaW5naWZ5KHN0YXRpY0NsYXNzKTtcbiAgfVxuICB2YXIgY2xhc3NCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICdjbGFzcycsIGZhbHNlIC8qIGdldFN0YXRpYyAqLyk7XG4gIGlmIChjbGFzc0JpbmRpbmcpIHtcbiAgICBlbC5jbGFzc0JpbmRpbmcgPSBjbGFzc0JpbmRpbmc7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuRGF0YShlbCkge1xuICB2YXIgZGF0YSA9ICcnO1xuICBpZiAoZWwuc3RhdGljQ2xhc3MpIHtcbiAgICBkYXRhICs9IFwic3RhdGljQ2xhc3M6XCIgKyBlbC5zdGF0aWNDbGFzcyArIFwiLFwiO1xuICB9XG4gIGlmIChlbC5jbGFzc0JpbmRpbmcpIHtcbiAgICBkYXRhICs9IFwiY2xhc3M6XCIgKyBlbC5jbGFzc0JpbmRpbmcgKyBcIixcIjtcbiAgfVxuICByZXR1cm4gZGF0YTtcbn1cblxudmFyIGtsYXNzJDEgPSB7XG4gIHN0YXRpY0tleXM6IFsnc3RhdGljQ2xhc3MnXSxcbiAgdHJhbnNmb3JtTm9kZTogdHJhbnNmb3JtTm9kZSxcbiAgZ2VuRGF0YTogZ2VuRGF0YVxufTtcblxuLyogICovXG5cbmZ1bmN0aW9uIHRyYW5zZm9ybU5vZGUkMShlbCwgb3B0aW9ucykge1xuICB2YXIgd2FybiA9IG9wdGlvbnMud2FybiB8fCBiYXNlV2FybjtcbiAgdmFyIHN0YXRpY1N0eWxlID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3N0eWxlJyk7XG4gIGlmIChzdGF0aWNTdHlsZSkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChmYWxzZSkge1xuICAgICAgdmFyIGV4cHJlc3Npb24gPSBwYXJzZVRleHQoc3RhdGljU3R5bGUsIG9wdGlvbnMuZGVsaW1pdGVycyk7XG4gICAgICBpZiAoZXhwcmVzc2lvbikge1xuICAgICAgICB3YXJuKFwic3R5bGU9XFxcIlwiICsgc3RhdGljU3R5bGUgKyBcIlxcXCI6IFwiICsgJ0ludGVycG9sYXRpb24gaW5zaWRlIGF0dHJpYnV0ZXMgaGFzIGJlZW4gcmVtb3ZlZC4gJyArICdVc2Ugdi1iaW5kIG9yIHRoZSBjb2xvbiBzaG9ydGhhbmQgaW5zdGVhZC4gRm9yIGV4YW1wbGUsICcgKyAnaW5zdGVhZCBvZiA8ZGl2IHN0eWxlPVwie3sgdmFsIH19XCI+LCB1c2UgPGRpdiA6c3R5bGU9XCJ2YWxcIj4uJyk7XG4gICAgICB9XG4gICAgfVxuICAgIGVsLnN0YXRpY1N0eWxlID0gSlNPTi5zdHJpbmdpZnkocGFyc2VTdHlsZVRleHQoc3RhdGljU3R5bGUpKTtcbiAgfVxuXG4gIHZhciBzdHlsZUJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3N0eWxlJywgZmFsc2UgLyogZ2V0U3RhdGljICovKTtcbiAgaWYgKHN0eWxlQmluZGluZykge1xuICAgIGVsLnN0eWxlQmluZGluZyA9IHN0eWxlQmluZGluZztcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5EYXRhJDEoZWwpIHtcbiAgdmFyIGRhdGEgPSAnJztcbiAgaWYgKGVsLnN0YXRpY1N0eWxlKSB7XG4gICAgZGF0YSArPSBcInN0YXRpY1N0eWxlOlwiICsgZWwuc3RhdGljU3R5bGUgKyBcIixcIjtcbiAgfVxuICBpZiAoZWwuc3R5bGVCaW5kaW5nKSB7XG4gICAgZGF0YSArPSBcInN0eWxlOihcIiArIGVsLnN0eWxlQmluZGluZyArIFwiKSxcIjtcbiAgfVxuICByZXR1cm4gZGF0YTtcbn1cblxudmFyIHN0eWxlJDEgPSB7XG4gIHN0YXRpY0tleXM6IFsnc3RhdGljU3R5bGUnXSxcbiAgdHJhbnNmb3JtTm9kZTogdHJhbnNmb3JtTm9kZSQxLFxuICBnZW5EYXRhOiBnZW5EYXRhJDFcbn07XG5cbnZhciBtb2R1bGVzJDEgPSBba2xhc3MkMSwgc3R5bGUkMV07XG5cbi8qICAqL1xuXG5mdW5jdGlvbiB0ZXh0KGVsLCBkaXIpIHtcbiAgaWYgKGRpci52YWx1ZSkge1xuICAgIGFkZFByb3AoZWwsICd0ZXh0Q29udGVudCcsIFwiX3MoXCIgKyBkaXIudmFsdWUgKyBcIilcIik7XG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGh0bWwoZWwsIGRpcikge1xuICBpZiAoZGlyLnZhbHVlKSB7XG4gICAgYWRkUHJvcChlbCwgJ2lubmVySFRNTCcsIFwiX3MoXCIgKyBkaXIudmFsdWUgKyBcIilcIik7XG4gIH1cbn1cblxudmFyIGRpcmVjdGl2ZXMkMSA9IHtcbiAgbW9kZWw6IG1vZGVsLFxuICB0ZXh0OiB0ZXh0LFxuICBodG1sOiBodG1sXG59O1xuXG4vKiAgKi9cblxudmFyIGlzVW5hcnlUYWcgPSBtYWtlTWFwKCdhcmVhLGJhc2UsYnIsY29sLGVtYmVkLGZyYW1lLGhyLGltZyxpbnB1dCxpc2luZGV4LGtleWdlbiwnICsgJ2xpbmssbWV0YSxwYXJhbSxzb3VyY2UsdHJhY2ssd2JyJyk7XG5cbi8vIEVsZW1lbnRzIHRoYXQgeW91IGNhbiwgaW50ZW50aW9uYWxseSwgbGVhdmUgb3BlblxuLy8gKGFuZCB3aGljaCBjbG9zZSB0aGVtc2VsdmVzKVxudmFyIGNhbkJlTGVmdE9wZW5UYWcgPSBtYWtlTWFwKCdjb2xncm91cCxkZCxkdCxsaSxvcHRpb25zLHAsdGQsdGZvb3QsdGgsdGhlYWQsdHIsc291cmNlJyk7XG5cbi8vIEhUTUw1IHRhZ3MgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvaW5kaWNlcy5odG1sI2VsZW1lbnRzLTNcbi8vIFBocmFzaW5nIENvbnRlbnQgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZG9tLmh0bWwjcGhyYXNpbmctY29udGVudFxudmFyIGlzTm9uUGhyYXNpbmdUYWcgPSBtYWtlTWFwKCdhZGRyZXNzLGFydGljbGUsYXNpZGUsYmFzZSxibG9ja3F1b3RlLGJvZHksY2FwdGlvbixjb2wsY29sZ3JvdXAsZGQsJyArICdkZXRhaWxzLGRpYWxvZyxkaXYsZGwsZHQsZmllbGRzZXQsZmlnY2FwdGlvbixmaWd1cmUsZm9vdGVyLGZvcm0sJyArICdoMSxoMixoMyxoNCxoNSxoNixoZWFkLGhlYWRlcixoZ3JvdXAsaHIsaHRtbCxsZWdlbmQsbGksbWVudWl0ZW0sbWV0YSwnICsgJ29wdGdyb3VwLG9wdGlvbixwYXJhbSxycCxydCxzb3VyY2Usc3R5bGUsc3VtbWFyeSx0Ym9keSx0ZCx0Zm9vdCx0aCx0aGVhZCwnICsgJ3RpdGxlLHRyLHRyYWNrJyk7XG5cbi8qICAqL1xuXG52YXIgYmFzZU9wdGlvbnMgPSB7XG4gIGV4cGVjdEhUTUw6IHRydWUsXG4gIG1vZHVsZXM6IG1vZHVsZXMkMSxcbiAgZGlyZWN0aXZlczogZGlyZWN0aXZlcyQxLFxuICBpc1ByZVRhZzogaXNQcmVUYWcsXG4gIGlzVW5hcnlUYWc6IGlzVW5hcnlUYWcsXG4gIG11c3RVc2VQcm9wOiBtdXN0VXNlUHJvcCxcbiAgY2FuQmVMZWZ0T3BlblRhZzogY2FuQmVMZWZ0T3BlblRhZyxcbiAgaXNSZXNlcnZlZFRhZzogaXNSZXNlcnZlZFRhZyxcbiAgZ2V0VGFnTmFtZXNwYWNlOiBnZXRUYWdOYW1lc3BhY2UsXG4gIHN0YXRpY0tleXM6IGdlblN0YXRpY0tleXMobW9kdWxlcyQxKVxufTtcblxuLyogICovXG5cbnZhciBkZWNvZGVyO1xuXG52YXIgaGUgPSB7XG4gIGRlY29kZTogZnVuY3Rpb24gZGVjb2RlKGh0bWwpIHtcbiAgICBkZWNvZGVyID0gZGVjb2RlciB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBkZWNvZGVyLmlubmVySFRNTCA9IGh0bWw7XG4gICAgcmV0dXJuIGRlY29kZXIudGV4dENvbnRlbnQ7XG4gIH1cbn07XG5cbi8qKlxuICogTm90IHR5cGUtY2hlY2tpbmcgdGhpcyBmaWxlIGJlY2F1c2UgaXQncyBtb3N0bHkgdmVuZG9yIGNvZGUuXG4gKi9cblxuLyohXG4gKiBIVE1MIFBhcnNlciBCeSBKb2huIFJlc2lnIChlam9obi5vcmcpXG4gKiBNb2RpZmllZCBieSBKdXJpeSBcImthbmdheFwiIFpheXRzZXZcbiAqIE9yaWdpbmFsIGNvZGUgYnkgRXJpayBBcnZpZHNzb24sIE1vemlsbGEgUHVibGljIExpY2Vuc2VcbiAqIGh0dHA6Ly9lcmlrLmVhZS5uZXQvc2ltcGxlaHRtbHBhcnNlci9zaW1wbGVodG1scGFyc2VyLmpzXG4gKi9cblxuLy8gUmVndWxhciBFeHByZXNzaW9ucyBmb3IgcGFyc2luZyB0YWdzIGFuZCBhdHRyaWJ1dGVzXG52YXIgYXR0cmlidXRlID0gL15cXHMqKFteXFxzXCInPD5cXC89XSspKD86XFxzKig9KVxccyooPzpcIihbXlwiXSopXCIrfCcoW14nXSopJyt8KFteXFxzXCInPTw+YF0rKSkpPy87XG4vLyBjb3VsZCB1c2UgaHR0cHM6Ly93d3cudzMub3JnL1RSLzE5OTkvUkVDLXhtbC1uYW1lcy0xOTk5MDExNC8jTlQtUU5hbWVcbi8vIGJ1dCBmb3IgVnVlIHRlbXBsYXRlcyB3ZSBjYW4gZW5mb3JjZSBhIHNpbXBsZSBjaGFyc2V0XG52YXIgbmNuYW1lID0gJ1thLXpBLVpfXVtcXFxcd1xcXFwtXFxcXC5dKic7XG52YXIgcW5hbWVDYXB0dXJlID0gXCIoKD86XCIgKyBuY25hbWUgKyBcIlxcXFw6KT9cIiArIG5jbmFtZSArIFwiKVwiO1xudmFyIHN0YXJ0VGFnT3BlbiA9IG5ldyBSZWdFeHAoXCJePFwiICsgcW5hbWVDYXB0dXJlKTtcbnZhciBzdGFydFRhZ0Nsb3NlID0gL15cXHMqKFxcLz8pPi87XG52YXIgZW5kVGFnID0gbmV3IFJlZ0V4cChcIl48XFxcXC9cIiArIHFuYW1lQ2FwdHVyZSArIFwiW14+XSo+XCIpO1xudmFyIGRvY3R5cGUgPSAvXjwhRE9DVFlQRSBbXj5dKz4vaTtcbnZhciBjb21tZW50ID0gL148IS0tLztcbnZhciBjb25kaXRpb25hbENvbW1lbnQgPSAvXjwhXFxbLztcblxudmFyIElTX1JFR0VYX0NBUFRVUklOR19CUk9LRU4gPSBmYWxzZTtcbid4Jy5yZXBsYWNlKC94KC4pPy9nLCBmdW5jdGlvbiAobSwgZykge1xuICBJU19SRUdFWF9DQVBUVVJJTkdfQlJPS0VOID0gZyA9PT0gJyc7XG59KTtcblxuLy8gU3BlY2lhbCBFbGVtZW50cyAoY2FuIGNvbnRhaW4gYW55dGhpbmcpXG52YXIgaXNQbGFpblRleHRFbGVtZW50ID0gbWFrZU1hcCgnc2NyaXB0LHN0eWxlLHRleHRhcmVhJywgdHJ1ZSk7XG52YXIgcmVDYWNoZSA9IHt9O1xuXG52YXIgZGVjb2RpbmdNYXAgPSB7XG4gICcmbHQ7JzogJzwnLFxuICAnJmd0Oyc6ICc+JyxcbiAgJyZxdW90Oyc6ICdcIicsXG4gICcmYW1wOyc6ICcmJyxcbiAgJyYjMTA7JzogJ1xcbidcbn07XG52YXIgZW5jb2RlZEF0dHIgPSAvJig/Omx0fGd0fHF1b3R8YW1wKTsvZztcbnZhciBlbmNvZGVkQXR0cldpdGhOZXdMaW5lcyA9IC8mKD86bHR8Z3R8cXVvdHxhbXB8IzEwKTsvZztcblxuLy8gIzU5OTJcbnZhciBpc0lnbm9yZU5ld2xpbmVUYWcgPSBtYWtlTWFwKCdwcmUsdGV4dGFyZWEnLCB0cnVlKTtcbnZhciBzaG91bGRJZ25vcmVGaXJzdE5ld2xpbmUgPSBmdW5jdGlvbiAodGFnLCBodG1sKSB7XG4gIHJldHVybiB0YWcgJiYgaXNJZ25vcmVOZXdsaW5lVGFnKHRhZykgJiYgaHRtbFswXSA9PT0gJ1xcbic7XG59O1xuXG5mdW5jdGlvbiBkZWNvZGVBdHRyKHZhbHVlLCBzaG91bGREZWNvZGVOZXdsaW5lcykge1xuICB2YXIgcmUgPSBzaG91bGREZWNvZGVOZXdsaW5lcyA/IGVuY29kZWRBdHRyV2l0aE5ld0xpbmVzIDogZW5jb2RlZEF0dHI7XG4gIHJldHVybiB2YWx1ZS5yZXBsYWNlKHJlLCBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICByZXR1cm4gZGVjb2RpbmdNYXBbbWF0Y2hdO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gcGFyc2VIVE1MKGh0bWwsIG9wdGlvbnMpIHtcbiAgdmFyIHN0YWNrID0gW107XG4gIHZhciBleHBlY3RIVE1MID0gb3B0aW9ucy5leHBlY3RIVE1MO1xuICB2YXIgaXNVbmFyeVRhZyQkMSA9IG9wdGlvbnMuaXNVbmFyeVRhZyB8fCBubztcbiAgdmFyIGNhbkJlTGVmdE9wZW5UYWckJDEgPSBvcHRpb25zLmNhbkJlTGVmdE9wZW5UYWcgfHwgbm87XG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBsYXN0LCBsYXN0VGFnO1xuICB3aGlsZSAoaHRtbCkge1xuICAgIGxhc3QgPSBodG1sO1xuICAgIC8vIE1ha2Ugc3VyZSB3ZSdyZSBub3QgaW4gYSBwbGFpbnRleHQgY29udGVudCBlbGVtZW50IGxpa2Ugc2NyaXB0L3N0eWxlXG4gICAgaWYgKCFsYXN0VGFnIHx8ICFpc1BsYWluVGV4dEVsZW1lbnQobGFzdFRhZykpIHtcbiAgICAgIHZhciB0ZXh0RW5kID0gaHRtbC5pbmRleE9mKCc8Jyk7XG4gICAgICBpZiAodGV4dEVuZCA9PT0gMCkge1xuICAgICAgICAvLyBDb21tZW50OlxuICAgICAgICBpZiAoY29tbWVudC50ZXN0KGh0bWwpKSB7XG4gICAgICAgICAgdmFyIGNvbW1lbnRFbmQgPSBodG1sLmluZGV4T2YoJy0tPicpO1xuXG4gICAgICAgICAgaWYgKGNvbW1lbnRFbmQgPj0gMCkge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuc2hvdWxkS2VlcENvbW1lbnQpIHtcbiAgICAgICAgICAgICAgb3B0aW9ucy5jb21tZW50KGh0bWwuc3Vic3RyaW5nKDQsIGNvbW1lbnRFbmQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFkdmFuY2UoY29tbWVudEVuZCArIDMpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db25kaXRpb25hbF9jb21tZW50I0Rvd25sZXZlbC1yZXZlYWxlZF9jb25kaXRpb25hbF9jb21tZW50XG4gICAgICAgIGlmIChjb25kaXRpb25hbENvbW1lbnQudGVzdChodG1sKSkge1xuICAgICAgICAgIHZhciBjb25kaXRpb25hbEVuZCA9IGh0bWwuaW5kZXhPZignXT4nKTtcblxuICAgICAgICAgIGlmIChjb25kaXRpb25hbEVuZCA+PSAwKSB7XG4gICAgICAgICAgICBhZHZhbmNlKGNvbmRpdGlvbmFsRW5kICsgMik7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEb2N0eXBlOlxuICAgICAgICB2YXIgZG9jdHlwZU1hdGNoID0gaHRtbC5tYXRjaChkb2N0eXBlKTtcbiAgICAgICAgaWYgKGRvY3R5cGVNYXRjaCkge1xuICAgICAgICAgIGFkdmFuY2UoZG9jdHlwZU1hdGNoWzBdLmxlbmd0aCk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBFbmQgdGFnOlxuICAgICAgICB2YXIgZW5kVGFnTWF0Y2ggPSBodG1sLm1hdGNoKGVuZFRhZyk7XG4gICAgICAgIGlmIChlbmRUYWdNYXRjaCkge1xuICAgICAgICAgIHZhciBjdXJJbmRleCA9IGluZGV4O1xuICAgICAgICAgIGFkdmFuY2UoZW5kVGFnTWF0Y2hbMF0ubGVuZ3RoKTtcbiAgICAgICAgICBwYXJzZUVuZFRhZyhlbmRUYWdNYXRjaFsxXSwgY3VySW5kZXgsIGluZGV4KTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFN0YXJ0IHRhZzpcbiAgICAgICAgdmFyIHN0YXJ0VGFnTWF0Y2ggPSBwYXJzZVN0YXJ0VGFnKCk7XG4gICAgICAgIGlmIChzdGFydFRhZ01hdGNoKSB7XG4gICAgICAgICAgaGFuZGxlU3RhcnRUYWcoc3RhcnRUYWdNYXRjaCk7XG4gICAgICAgICAgaWYgKHNob3VsZElnbm9yZUZpcnN0TmV3bGluZShsYXN0VGFnLCBodG1sKSkge1xuICAgICAgICAgICAgYWR2YW5jZSgxKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHRleHQgPSB2b2lkIDAsXG4gICAgICAgICAgcmVzdCA9IHZvaWQgMCxcbiAgICAgICAgICBuZXh0ID0gdm9pZCAwO1xuICAgICAgaWYgKHRleHRFbmQgPj0gMCkge1xuICAgICAgICByZXN0ID0gaHRtbC5zbGljZSh0ZXh0RW5kKTtcbiAgICAgICAgd2hpbGUgKCFlbmRUYWcudGVzdChyZXN0KSAmJiAhc3RhcnRUYWdPcGVuLnRlc3QocmVzdCkgJiYgIWNvbW1lbnQudGVzdChyZXN0KSAmJiAhY29uZGl0aW9uYWxDb21tZW50LnRlc3QocmVzdCkpIHtcbiAgICAgICAgICAvLyA8IGluIHBsYWluIHRleHQsIGJlIGZvcmdpdmluZyBhbmQgdHJlYXQgaXQgYXMgdGV4dFxuICAgICAgICAgIG5leHQgPSByZXN0LmluZGV4T2YoJzwnLCAxKTtcbiAgICAgICAgICBpZiAobmV4dCA8IDApIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0ZXh0RW5kICs9IG5leHQ7XG4gICAgICAgICAgcmVzdCA9IGh0bWwuc2xpY2UodGV4dEVuZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGV4dCA9IGh0bWwuc3Vic3RyaW5nKDAsIHRleHRFbmQpO1xuICAgICAgICBhZHZhbmNlKHRleHRFbmQpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGV4dEVuZCA8IDApIHtcbiAgICAgICAgdGV4dCA9IGh0bWw7XG4gICAgICAgIGh0bWwgPSAnJztcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMuY2hhcnMgJiYgdGV4dCkge1xuICAgICAgICBvcHRpb25zLmNoYXJzKHRleHQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZW5kVGFnTGVuZ3RoID0gMDtcbiAgICAgIHZhciBzdGFja2VkVGFnID0gbGFzdFRhZy50b0xvd2VyQ2FzZSgpO1xuICAgICAgdmFyIHJlU3RhY2tlZFRhZyA9IHJlQ2FjaGVbc3RhY2tlZFRhZ10gfHwgKHJlQ2FjaGVbc3RhY2tlZFRhZ10gPSBuZXcgUmVnRXhwKCcoW1xcXFxzXFxcXFNdKj8pKDwvJyArIHN0YWNrZWRUYWcgKyAnW14+XSo+KScsICdpJykpO1xuICAgICAgdmFyIHJlc3QkMSA9IGh0bWwucmVwbGFjZShyZVN0YWNrZWRUYWcsIGZ1bmN0aW9uIChhbGwsIHRleHQsIGVuZFRhZykge1xuICAgICAgICBlbmRUYWdMZW5ndGggPSBlbmRUYWcubGVuZ3RoO1xuICAgICAgICBpZiAoIWlzUGxhaW5UZXh0RWxlbWVudChzdGFja2VkVGFnKSAmJiBzdGFja2VkVGFnICE9PSAnbm9zY3JpcHQnKSB7XG4gICAgICAgICAgdGV4dCA9IHRleHQucmVwbGFjZSgvPCEtLShbXFxzXFxTXSo/KS0tPi9nLCAnJDEnKS5yZXBsYWNlKC88IVxcW0NEQVRBXFxbKFtcXHNcXFNdKj8pXV0+L2csICckMScpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaG91bGRJZ25vcmVGaXJzdE5ld2xpbmUoc3RhY2tlZFRhZywgdGV4dCkpIHtcbiAgICAgICAgICB0ZXh0ID0gdGV4dC5zbGljZSgxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5jaGFycykge1xuICAgICAgICAgIG9wdGlvbnMuY2hhcnModGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfSk7XG4gICAgICBpbmRleCArPSBodG1sLmxlbmd0aCAtIHJlc3QkMS5sZW5ndGg7XG4gICAgICBodG1sID0gcmVzdCQxO1xuICAgICAgcGFyc2VFbmRUYWcoc3RhY2tlZFRhZywgaW5kZXggLSBlbmRUYWdMZW5ndGgsIGluZGV4KTtcbiAgICB9XG5cbiAgICBpZiAoaHRtbCA9PT0gbGFzdCkge1xuICAgICAgb3B0aW9ucy5jaGFycyAmJiBvcHRpb25zLmNoYXJzKGh0bWwpO1xuICAgICAgaWYgKGZhbHNlKSB7XG4gICAgICAgIG9wdGlvbnMud2FybihcIk1hbC1mb3JtYXR0ZWQgdGFnIGF0IGVuZCBvZiB0ZW1wbGF0ZTogXFxcIlwiICsgaHRtbCArIFwiXFxcIlwiKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIC8vIENsZWFuIHVwIGFueSByZW1haW5pbmcgdGFnc1xuICBwYXJzZUVuZFRhZygpO1xuXG4gIGZ1bmN0aW9uIGFkdmFuY2Uobikge1xuICAgIGluZGV4ICs9IG47XG4gICAgaHRtbCA9IGh0bWwuc3Vic3RyaW5nKG4pO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VTdGFydFRhZygpIHtcbiAgICB2YXIgc3RhcnQgPSBodG1sLm1hdGNoKHN0YXJ0VGFnT3Blbik7XG4gICAgaWYgKHN0YXJ0KSB7XG4gICAgICB2YXIgbWF0Y2ggPSB7XG4gICAgICAgIHRhZ05hbWU6IHN0YXJ0WzFdLFxuICAgICAgICBhdHRyczogW10sXG4gICAgICAgIHN0YXJ0OiBpbmRleFxuICAgICAgfTtcbiAgICAgIGFkdmFuY2Uoc3RhcnRbMF0ubGVuZ3RoKTtcbiAgICAgIHZhciBlbmQsIGF0dHI7XG4gICAgICB3aGlsZSAoIShlbmQgPSBodG1sLm1hdGNoKHN0YXJ0VGFnQ2xvc2UpKSAmJiAoYXR0ciA9IGh0bWwubWF0Y2goYXR0cmlidXRlKSkpIHtcbiAgICAgICAgYWR2YW5jZShhdHRyWzBdLmxlbmd0aCk7XG4gICAgICAgIG1hdGNoLmF0dHJzLnB1c2goYXR0cik7XG4gICAgICB9XG4gICAgICBpZiAoZW5kKSB7XG4gICAgICAgIG1hdGNoLnVuYXJ5U2xhc2ggPSBlbmRbMV07XG4gICAgICAgIGFkdmFuY2UoZW5kWzBdLmxlbmd0aCk7XG4gICAgICAgIG1hdGNoLmVuZCA9IGluZGV4O1xuICAgICAgICByZXR1cm4gbWF0Y2g7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlU3RhcnRUYWcobWF0Y2gpIHtcbiAgICB2YXIgdGFnTmFtZSA9IG1hdGNoLnRhZ05hbWU7XG4gICAgdmFyIHVuYXJ5U2xhc2ggPSBtYXRjaC51bmFyeVNsYXNoO1xuXG4gICAgaWYgKGV4cGVjdEhUTUwpIHtcbiAgICAgIGlmIChsYXN0VGFnID09PSAncCcgJiYgaXNOb25QaHJhc2luZ1RhZyh0YWdOYW1lKSkge1xuICAgICAgICBwYXJzZUVuZFRhZyhsYXN0VGFnKTtcbiAgICAgIH1cbiAgICAgIGlmIChjYW5CZUxlZnRPcGVuVGFnJCQxKHRhZ05hbWUpICYmIGxhc3RUYWcgPT09IHRhZ05hbWUpIHtcbiAgICAgICAgcGFyc2VFbmRUYWcodGFnTmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHVuYXJ5ID0gaXNVbmFyeVRhZyQkMSh0YWdOYW1lKSB8fCAhIXVuYXJ5U2xhc2g7XG5cbiAgICB2YXIgbCA9IG1hdGNoLmF0dHJzLmxlbmd0aDtcbiAgICB2YXIgYXR0cnMgPSBuZXcgQXJyYXkobCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBhcmdzID0gbWF0Y2guYXR0cnNbaV07XG4gICAgICAvLyBoYWNraXNoIHdvcmsgYXJvdW5kIEZGIGJ1ZyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0zNjk3NzhcbiAgICAgIGlmIChJU19SRUdFWF9DQVBUVVJJTkdfQlJPS0VOICYmIGFyZ3NbMF0uaW5kZXhPZignXCJcIicpID09PSAtMSkge1xuICAgICAgICBpZiAoYXJnc1szXSA9PT0gJycpIHtcbiAgICAgICAgICBkZWxldGUgYXJnc1szXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXJnc1s0XSA9PT0gJycpIHtcbiAgICAgICAgICBkZWxldGUgYXJnc1s0XTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXJnc1s1XSA9PT0gJycpIHtcbiAgICAgICAgICBkZWxldGUgYXJnc1s1XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIHZhbHVlID0gYXJnc1szXSB8fCBhcmdzWzRdIHx8IGFyZ3NbNV0gfHwgJyc7XG4gICAgICBhdHRyc1tpXSA9IHtcbiAgICAgICAgbmFtZTogYXJnc1sxXSxcbiAgICAgICAgdmFsdWU6IGRlY29kZUF0dHIodmFsdWUsIG9wdGlvbnMuc2hvdWxkRGVjb2RlTmV3bGluZXMpXG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmICghdW5hcnkpIHtcbiAgICAgIHN0YWNrLnB1c2goeyB0YWc6IHRhZ05hbWUsIGxvd2VyQ2FzZWRUYWc6IHRhZ05hbWUudG9Mb3dlckNhc2UoKSwgYXR0cnM6IGF0dHJzIH0pO1xuICAgICAgbGFzdFRhZyA9IHRhZ05hbWU7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuc3RhcnQpIHtcbiAgICAgIG9wdGlvbnMuc3RhcnQodGFnTmFtZSwgYXR0cnMsIHVuYXJ5LCBtYXRjaC5zdGFydCwgbWF0Y2guZW5kKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUVuZFRhZyh0YWdOYW1lLCBzdGFydCwgZW5kKSB7XG4gICAgdmFyIHBvcywgbG93ZXJDYXNlZFRhZ05hbWU7XG4gICAgaWYgKHN0YXJ0ID09IG51bGwpIHtcbiAgICAgIHN0YXJ0ID0gaW5kZXg7XG4gICAgfVxuICAgIGlmIChlbmQgPT0gbnVsbCkge1xuICAgICAgZW5kID0gaW5kZXg7XG4gICAgfVxuXG4gICAgaWYgKHRhZ05hbWUpIHtcbiAgICAgIGxvd2VyQ2FzZWRUYWdOYW1lID0gdGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cblxuICAgIC8vIEZpbmQgdGhlIGNsb3Nlc3Qgb3BlbmVkIHRhZyBvZiB0aGUgc2FtZSB0eXBlXG4gICAgaWYgKHRhZ05hbWUpIHtcbiAgICAgIGZvciAocG9zID0gc3RhY2subGVuZ3RoIC0gMTsgcG9zID49IDA7IHBvcy0tKSB7XG4gICAgICAgIGlmIChzdGFja1twb3NdLmxvd2VyQ2FzZWRUYWcgPT09IGxvd2VyQ2FzZWRUYWdOYW1lKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgbm8gdGFnIG5hbWUgaXMgcHJvdmlkZWQsIGNsZWFuIHNob3BcbiAgICAgIHBvcyA9IDA7XG4gICAgfVxuXG4gICAgaWYgKHBvcyA+PSAwKSB7XG4gICAgICAvLyBDbG9zZSBhbGwgdGhlIG9wZW4gZWxlbWVudHMsIHVwIHRoZSBzdGFja1xuICAgICAgZm9yICh2YXIgaSA9IHN0YWNrLmxlbmd0aCAtIDE7IGkgPj0gcG9zOyBpLS0pIHtcbiAgICAgICAgaWYgKGZhbHNlKSB7XG4gICAgICAgICAgb3B0aW9ucy53YXJuKFwidGFnIDxcIiArIHN0YWNrW2ldLnRhZyArIFwiPiBoYXMgbm8gbWF0Y2hpbmcgZW5kIHRhZy5cIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuZW5kKSB7XG4gICAgICAgICAgb3B0aW9ucy5lbmQoc3RhY2tbaV0udGFnLCBzdGFydCwgZW5kKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBSZW1vdmUgdGhlIG9wZW4gZWxlbWVudHMgZnJvbSB0aGUgc3RhY2tcbiAgICAgIHN0YWNrLmxlbmd0aCA9IHBvcztcbiAgICAgIGxhc3RUYWcgPSBwb3MgJiYgc3RhY2tbcG9zIC0gMV0udGFnO1xuICAgIH0gZWxzZSBpZiAobG93ZXJDYXNlZFRhZ05hbWUgPT09ICdicicpIHtcbiAgICAgIGlmIChvcHRpb25zLnN0YXJ0KSB7XG4gICAgICAgIG9wdGlvbnMuc3RhcnQodGFnTmFtZSwgW10sIHRydWUsIHN0YXJ0LCBlbmQpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobG93ZXJDYXNlZFRhZ05hbWUgPT09ICdwJykge1xuICAgICAgaWYgKG9wdGlvbnMuc3RhcnQpIHtcbiAgICAgICAgb3B0aW9ucy5zdGFydCh0YWdOYW1lLCBbXSwgZmFsc2UsIHN0YXJ0LCBlbmQpO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMuZW5kKSB7XG4gICAgICAgIG9wdGlvbnMuZW5kKHRhZ05hbWUsIHN0YXJ0LCBlbmQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIG9uUkUgPSAvXkB8XnYtb246LztcbnZhciBkaXJSRSA9IC9edi18XkB8XjovO1xudmFyIGZvckFsaWFzUkUgPSAvKC4qPylcXHMrKD86aW58b2YpXFxzKyguKikvO1xudmFyIGZvckl0ZXJhdG9yUkUgPSAvXFwoKFxce1tefV0qXFx9fFteLF0qKSwoW14sXSopKD86LChbXixdKikpP1xcKS87XG5cbnZhciBhcmdSRSA9IC86KC4qKSQvO1xudmFyIGJpbmRSRSA9IC9eOnxedi1iaW5kOi87XG52YXIgbW9kaWZpZXJSRSA9IC9cXC5bXi5dKy9nO1xuXG52YXIgZGVjb2RlSFRNTENhY2hlZCA9IGNhY2hlZChoZS5kZWNvZGUpO1xuXG4vLyBjb25maWd1cmFibGUgc3RhdGVcbnZhciB3YXJuJDI7XG52YXIgZGVsaW1pdGVycztcbnZhciB0cmFuc2Zvcm1zO1xudmFyIHByZVRyYW5zZm9ybXM7XG52YXIgcG9zdFRyYW5zZm9ybXM7XG52YXIgcGxhdGZvcm1Jc1ByZVRhZztcbnZhciBwbGF0Zm9ybU11c3RVc2VQcm9wO1xudmFyIHBsYXRmb3JtR2V0VGFnTmFtZXNwYWNlO1xuXG4vKipcbiAqIENvbnZlcnQgSFRNTCBzdHJpbmcgdG8gQVNULlxuICovXG5mdW5jdGlvbiBwYXJzZSh0ZW1wbGF0ZSwgb3B0aW9ucykge1xuICB3YXJuJDIgPSBvcHRpb25zLndhcm4gfHwgYmFzZVdhcm47XG5cbiAgcGxhdGZvcm1Jc1ByZVRhZyA9IG9wdGlvbnMuaXNQcmVUYWcgfHwgbm87XG4gIHBsYXRmb3JtTXVzdFVzZVByb3AgPSBvcHRpb25zLm11c3RVc2VQcm9wIHx8IG5vO1xuICBwbGF0Zm9ybUdldFRhZ05hbWVzcGFjZSA9IG9wdGlvbnMuZ2V0VGFnTmFtZXNwYWNlIHx8IG5vO1xuXG4gIHRyYW5zZm9ybXMgPSBwbHVja01vZHVsZUZ1bmN0aW9uKG9wdGlvbnMubW9kdWxlcywgJ3RyYW5zZm9ybU5vZGUnKTtcbiAgcHJlVHJhbnNmb3JtcyA9IHBsdWNrTW9kdWxlRnVuY3Rpb24ob3B0aW9ucy5tb2R1bGVzLCAncHJlVHJhbnNmb3JtTm9kZScpO1xuICBwb3N0VHJhbnNmb3JtcyA9IHBsdWNrTW9kdWxlRnVuY3Rpb24ob3B0aW9ucy5tb2R1bGVzLCAncG9zdFRyYW5zZm9ybU5vZGUnKTtcblxuICBkZWxpbWl0ZXJzID0gb3B0aW9ucy5kZWxpbWl0ZXJzO1xuXG4gIHZhciBzdGFjayA9IFtdO1xuICB2YXIgcHJlc2VydmVXaGl0ZXNwYWNlID0gb3B0aW9ucy5wcmVzZXJ2ZVdoaXRlc3BhY2UgIT09IGZhbHNlO1xuICB2YXIgcm9vdDtcbiAgdmFyIGN1cnJlbnRQYXJlbnQ7XG4gIHZhciBpblZQcmUgPSBmYWxzZTtcbiAgdmFyIGluUHJlID0gZmFsc2U7XG4gIHZhciB3YXJuZWQgPSBmYWxzZTtcblxuICBmdW5jdGlvbiB3YXJuT25jZShtc2cpIHtcbiAgICBpZiAoIXdhcm5lZCkge1xuICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICAgIHdhcm4kMihtc2cpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGVuZFByZShlbGVtZW50KSB7XG4gICAgLy8gY2hlY2sgcHJlIHN0YXRlXG4gICAgaWYgKGVsZW1lbnQucHJlKSB7XG4gICAgICBpblZQcmUgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHBsYXRmb3JtSXNQcmVUYWcoZWxlbWVudC50YWcpKSB7XG4gICAgICBpblByZSA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHBhcnNlSFRNTCh0ZW1wbGF0ZSwge1xuICAgIHdhcm46IHdhcm4kMixcbiAgICBleHBlY3RIVE1MOiBvcHRpb25zLmV4cGVjdEhUTUwsXG4gICAgaXNVbmFyeVRhZzogb3B0aW9ucy5pc1VuYXJ5VGFnLFxuICAgIGNhbkJlTGVmdE9wZW5UYWc6IG9wdGlvbnMuY2FuQmVMZWZ0T3BlblRhZyxcbiAgICBzaG91bGREZWNvZGVOZXdsaW5lczogb3B0aW9ucy5zaG91bGREZWNvZGVOZXdsaW5lcyxcbiAgICBzaG91bGRLZWVwQ29tbWVudDogb3B0aW9ucy5jb21tZW50cyxcbiAgICBzdGFydDogZnVuY3Rpb24gc3RhcnQodGFnLCBhdHRycywgdW5hcnkpIHtcbiAgICAgIC8vIGNoZWNrIG5hbWVzcGFjZS5cbiAgICAgIC8vIGluaGVyaXQgcGFyZW50IG5zIGlmIHRoZXJlIGlzIG9uZVxuICAgICAgdmFyIG5zID0gY3VycmVudFBhcmVudCAmJiBjdXJyZW50UGFyZW50Lm5zIHx8IHBsYXRmb3JtR2V0VGFnTmFtZXNwYWNlKHRhZyk7XG5cbiAgICAgIC8vIGhhbmRsZSBJRSBzdmcgYnVnXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChpc0lFICYmIG5zID09PSAnc3ZnJykge1xuICAgICAgICBhdHRycyA9IGd1YXJkSUVTVkdCdWcoYXR0cnMpO1xuICAgICAgfVxuXG4gICAgICB2YXIgZWxlbWVudCA9IHtcbiAgICAgICAgdHlwZTogMSxcbiAgICAgICAgdGFnOiB0YWcsXG4gICAgICAgIGF0dHJzTGlzdDogYXR0cnMsXG4gICAgICAgIGF0dHJzTWFwOiBtYWtlQXR0cnNNYXAoYXR0cnMpLFxuICAgICAgICBwYXJlbnQ6IGN1cnJlbnRQYXJlbnQsXG4gICAgICAgIGNoaWxkcmVuOiBbXVxuICAgICAgfTtcbiAgICAgIGlmIChucykge1xuICAgICAgICBlbGVtZW50Lm5zID0gbnM7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0ZvcmJpZGRlblRhZyhlbGVtZW50KSAmJiAhaXNTZXJ2ZXJSZW5kZXJpbmcoKSkge1xuICAgICAgICBlbGVtZW50LmZvcmJpZGRlbiA9IHRydWU7XG4gICAgICAgIFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgJiYgd2FybiQyKCdUZW1wbGF0ZXMgc2hvdWxkIG9ubHkgYmUgcmVzcG9uc2libGUgZm9yIG1hcHBpbmcgdGhlIHN0YXRlIHRvIHRoZSAnICsgJ1VJLiBBdm9pZCBwbGFjaW5nIHRhZ3Mgd2l0aCBzaWRlLWVmZmVjdHMgaW4geW91ciB0ZW1wbGF0ZXMsIHN1Y2ggYXMgJyArIFwiPFwiICsgdGFnICsgXCI+XCIgKyAnLCBhcyB0aGV5IHdpbGwgbm90IGJlIHBhcnNlZC4nKTtcbiAgICAgIH1cblxuICAgICAgLy8gYXBwbHkgcHJlLXRyYW5zZm9ybXNcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJlVHJhbnNmb3Jtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBwcmVUcmFuc2Zvcm1zW2ldKGVsZW1lbnQsIG9wdGlvbnMpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWluVlByZSkge1xuICAgICAgICBwcm9jZXNzUHJlKGVsZW1lbnQpO1xuICAgICAgICBpZiAoZWxlbWVudC5wcmUpIHtcbiAgICAgICAgICBpblZQcmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocGxhdGZvcm1Jc1ByZVRhZyhlbGVtZW50LnRhZykpIHtcbiAgICAgICAgaW5QcmUgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGluVlByZSkge1xuICAgICAgICBwcm9jZXNzUmF3QXR0cnMoZWxlbWVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9jZXNzRm9yKGVsZW1lbnQpO1xuICAgICAgICBwcm9jZXNzSWYoZWxlbWVudCk7XG4gICAgICAgIHByb2Nlc3NPbmNlKGVsZW1lbnQpO1xuICAgICAgICBwcm9jZXNzS2V5KGVsZW1lbnQpO1xuXG4gICAgICAgIC8vIGRldGVybWluZSB3aGV0aGVyIHRoaXMgaXMgYSBwbGFpbiBlbGVtZW50IGFmdGVyXG4gICAgICAgIC8vIHJlbW92aW5nIHN0cnVjdHVyYWwgYXR0cmlidXRlc1xuICAgICAgICBlbGVtZW50LnBsYWluID0gIWVsZW1lbnQua2V5ICYmICFhdHRycy5sZW5ndGg7XG5cbiAgICAgICAgcHJvY2Vzc1JlZihlbGVtZW50KTtcbiAgICAgICAgcHJvY2Vzc1Nsb3QoZWxlbWVudCk7XG4gICAgICAgIHByb2Nlc3NDb21wb25lbnQoZWxlbWVudCk7XG4gICAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IHRyYW5zZm9ybXMubGVuZ3RoOyBpJDErKykge1xuICAgICAgICAgIHRyYW5zZm9ybXNbaSQxXShlbGVtZW50LCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBwcm9jZXNzQXR0cnMoZWxlbWVudCk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGNoZWNrUm9vdENvbnN0cmFpbnRzKGVsKSB7XG4gICAgICAgIGlmIChmYWxzZSkge1xuICAgICAgICAgIGlmIChlbC50YWcgPT09ICdzbG90JyB8fCBlbC50YWcgPT09ICd0ZW1wbGF0ZScpIHtcbiAgICAgICAgICAgIHdhcm5PbmNlKFwiQ2Fubm90IHVzZSA8XCIgKyBlbC50YWcgKyBcIj4gYXMgY29tcG9uZW50IHJvb3QgZWxlbWVudCBiZWNhdXNlIGl0IG1heSBcIiArICdjb250YWluIG11bHRpcGxlIG5vZGVzLicpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZWwuYXR0cnNNYXAuaGFzT3duUHJvcGVydHkoJ3YtZm9yJykpIHtcbiAgICAgICAgICAgIHdhcm5PbmNlKCdDYW5ub3QgdXNlIHYtZm9yIG9uIHN0YXRlZnVsIGNvbXBvbmVudCByb290IGVsZW1lbnQgYmVjYXVzZSAnICsgJ2l0IHJlbmRlcnMgbXVsdGlwbGUgZWxlbWVudHMuJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIHRyZWUgbWFuYWdlbWVudFxuICAgICAgaWYgKCFyb290KSB7XG4gICAgICAgIHJvb3QgPSBlbGVtZW50O1xuICAgICAgICBjaGVja1Jvb3RDb25zdHJhaW50cyhyb290KTtcbiAgICAgIH0gZWxzZSBpZiAoIXN0YWNrLmxlbmd0aCkge1xuICAgICAgICAvLyBhbGxvdyByb290IGVsZW1lbnRzIHdpdGggdi1pZiwgdi1lbHNlLWlmIGFuZCB2LWVsc2VcbiAgICAgICAgaWYgKHJvb3QuaWYgJiYgKGVsZW1lbnQuZWxzZWlmIHx8IGVsZW1lbnQuZWxzZSkpIHtcbiAgICAgICAgICBjaGVja1Jvb3RDb25zdHJhaW50cyhlbGVtZW50KTtcbiAgICAgICAgICBhZGRJZkNvbmRpdGlvbihyb290LCB7XG4gICAgICAgICAgICBleHA6IGVsZW1lbnQuZWxzZWlmLFxuICAgICAgICAgICAgYmxvY2s6IGVsZW1lbnRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmIChmYWxzZSkge1xuICAgICAgICAgIHdhcm5PbmNlKFwiQ29tcG9uZW50IHRlbXBsYXRlIHNob3VsZCBjb250YWluIGV4YWN0bHkgb25lIHJvb3QgZWxlbWVudC4gXCIgKyBcIklmIHlvdSBhcmUgdXNpbmcgdi1pZiBvbiBtdWx0aXBsZSBlbGVtZW50cywgXCIgKyBcInVzZSB2LWVsc2UtaWYgdG8gY2hhaW4gdGhlbSBpbnN0ZWFkLlwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGN1cnJlbnRQYXJlbnQgJiYgIWVsZW1lbnQuZm9yYmlkZGVuKSB7XG4gICAgICAgIGlmIChlbGVtZW50LmVsc2VpZiB8fCBlbGVtZW50LmVsc2UpIHtcbiAgICAgICAgICBwcm9jZXNzSWZDb25kaXRpb25zKGVsZW1lbnQsIGN1cnJlbnRQYXJlbnQpO1xuICAgICAgICB9IGVsc2UgaWYgKGVsZW1lbnQuc2xvdFNjb3BlKSB7XG4gICAgICAgICAgLy8gc2NvcGVkIHNsb3RcbiAgICAgICAgICBjdXJyZW50UGFyZW50LnBsYWluID0gZmFsc2U7XG4gICAgICAgICAgdmFyIG5hbWUgPSBlbGVtZW50LnNsb3RUYXJnZXQgfHwgJ1wiZGVmYXVsdFwiJzsoY3VycmVudFBhcmVudC5zY29wZWRTbG90cyB8fCAoY3VycmVudFBhcmVudC5zY29wZWRTbG90cyA9IHt9KSlbbmFtZV0gPSBlbGVtZW50O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN1cnJlbnRQYXJlbnQuY2hpbGRyZW4ucHVzaChlbGVtZW50KTtcbiAgICAgICAgICBlbGVtZW50LnBhcmVudCA9IGN1cnJlbnRQYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghdW5hcnkpIHtcbiAgICAgICAgY3VycmVudFBhcmVudCA9IGVsZW1lbnQ7XG4gICAgICAgIHN0YWNrLnB1c2goZWxlbWVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbmRQcmUoZWxlbWVudCk7XG4gICAgICB9XG4gICAgICAvLyBhcHBseSBwb3N0LXRyYW5zZm9ybXNcbiAgICAgIGZvciAodmFyIGkkMiA9IDA7IGkkMiA8IHBvc3RUcmFuc2Zvcm1zLmxlbmd0aDsgaSQyKyspIHtcbiAgICAgICAgcG9zdFRyYW5zZm9ybXNbaSQyXShlbGVtZW50LCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZW5kOiBmdW5jdGlvbiBlbmQoKSB7XG4gICAgICAvLyByZW1vdmUgdHJhaWxpbmcgd2hpdGVzcGFjZVxuICAgICAgdmFyIGVsZW1lbnQgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcbiAgICAgIHZhciBsYXN0Tm9kZSA9IGVsZW1lbnQuY2hpbGRyZW5bZWxlbWVudC5jaGlsZHJlbi5sZW5ndGggLSAxXTtcbiAgICAgIGlmIChsYXN0Tm9kZSAmJiBsYXN0Tm9kZS50eXBlID09PSAzICYmIGxhc3ROb2RlLnRleHQgPT09ICcgJyAmJiAhaW5QcmUpIHtcbiAgICAgICAgZWxlbWVudC5jaGlsZHJlbi5wb3AoKTtcbiAgICAgIH1cbiAgICAgIC8vIHBvcCBzdGFja1xuICAgICAgc3RhY2subGVuZ3RoIC09IDE7XG4gICAgICBjdXJyZW50UGFyZW50ID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XG4gICAgICBlbmRQcmUoZWxlbWVudCk7XG4gICAgfSxcblxuICAgIGNoYXJzOiBmdW5jdGlvbiBjaGFycyh0ZXh0KSB7XG4gICAgICBpZiAoIWN1cnJlbnRQYXJlbnQpIHtcbiAgICAgICAgaWYgKGZhbHNlKSB7XG4gICAgICAgICAgaWYgKHRleHQgPT09IHRlbXBsYXRlKSB7XG4gICAgICAgICAgICB3YXJuT25jZSgnQ29tcG9uZW50IHRlbXBsYXRlIHJlcXVpcmVzIGEgcm9vdCBlbGVtZW50LCByYXRoZXIgdGhhbiBqdXN0IHRleHQuJyk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0ZXh0ID0gdGV4dC50cmltKCkpIHtcbiAgICAgICAgICAgIHdhcm5PbmNlKFwidGV4dCBcXFwiXCIgKyB0ZXh0ICsgXCJcXFwiIG91dHNpZGUgcm9vdCBlbGVtZW50IHdpbGwgYmUgaWdub3JlZC5cIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIElFIHRleHRhcmVhIHBsYWNlaG9sZGVyIGJ1Z1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoaXNJRSAmJiBjdXJyZW50UGFyZW50LnRhZyA9PT0gJ3RleHRhcmVhJyAmJiBjdXJyZW50UGFyZW50LmF0dHJzTWFwLnBsYWNlaG9sZGVyID09PSB0ZXh0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBjaGlsZHJlbiA9IGN1cnJlbnRQYXJlbnQuY2hpbGRyZW47XG4gICAgICB0ZXh0ID0gaW5QcmUgfHwgdGV4dC50cmltKCkgPyBpc1RleHRUYWcoY3VycmVudFBhcmVudCkgPyB0ZXh0IDogZGVjb2RlSFRNTENhY2hlZCh0ZXh0KVxuICAgICAgLy8gb25seSBwcmVzZXJ2ZSB3aGl0ZXNwYWNlIGlmIGl0cyBub3QgcmlnaHQgYWZ0ZXIgYSBzdGFydGluZyB0YWdcbiAgICAgIDogcHJlc2VydmVXaGl0ZXNwYWNlICYmIGNoaWxkcmVuLmxlbmd0aCA/ICcgJyA6ICcnO1xuICAgICAgaWYgKHRleHQpIHtcbiAgICAgICAgdmFyIGV4cHJlc3Npb247XG4gICAgICAgIGlmICghaW5WUHJlICYmIHRleHQgIT09ICcgJyAmJiAoZXhwcmVzc2lvbiA9IHBhcnNlVGV4dCh0ZXh0LCBkZWxpbWl0ZXJzKSkpIHtcbiAgICAgICAgICBjaGlsZHJlbi5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6IDIsXG4gICAgICAgICAgICBleHByZXNzaW9uOiBleHByZXNzaW9uLFxuICAgICAgICAgICAgdGV4dDogdGV4dFxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKHRleHQgIT09ICcgJyB8fCAhY2hpbGRyZW4ubGVuZ3RoIHx8IGNoaWxkcmVuW2NoaWxkcmVuLmxlbmd0aCAtIDFdLnRleHQgIT09ICcgJykge1xuICAgICAgICAgIGNoaWxkcmVuLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogMyxcbiAgICAgICAgICAgIHRleHQ6IHRleHRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgY29tbWVudDogZnVuY3Rpb24gY29tbWVudCh0ZXh0KSB7XG4gICAgICBjdXJyZW50UGFyZW50LmNoaWxkcmVuLnB1c2goe1xuICAgICAgICB0eXBlOiAzLFxuICAgICAgICB0ZXh0OiB0ZXh0LFxuICAgICAgICBpc0NvbW1lbnQ6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByb290O1xufVxuXG5mdW5jdGlvbiBwcm9jZXNzUHJlKGVsKSB7XG4gIGlmIChnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1wcmUnKSAhPSBudWxsKSB7XG4gICAgZWwucHJlID0gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzUmF3QXR0cnMoZWwpIHtcbiAgdmFyIGwgPSBlbC5hdHRyc0xpc3QubGVuZ3RoO1xuICBpZiAobCkge1xuICAgIHZhciBhdHRycyA9IGVsLmF0dHJzID0gbmV3IEFycmF5KGwpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICBhdHRyc1tpXSA9IHtcbiAgICAgICAgbmFtZTogZWwuYXR0cnNMaXN0W2ldLm5hbWUsXG4gICAgICAgIHZhbHVlOiBKU09OLnN0cmluZ2lmeShlbC5hdHRyc0xpc3RbaV0udmFsdWUpXG4gICAgICB9O1xuICAgIH1cbiAgfSBlbHNlIGlmICghZWwucHJlKSB7XG4gICAgLy8gbm9uIHJvb3Qgbm9kZSBpbiBwcmUgYmxvY2tzIHdpdGggbm8gYXR0cmlidXRlc1xuICAgIGVsLnBsYWluID0gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzS2V5KGVsKSB7XG4gIHZhciBleHAgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ2tleScpO1xuICBpZiAoZXhwKSB7XG4gICAgaWYgKGZhbHNlKSB7XG4gICAgICB3YXJuJDIoXCI8dGVtcGxhdGU+IGNhbm5vdCBiZSBrZXllZC4gUGxhY2UgdGhlIGtleSBvbiByZWFsIGVsZW1lbnRzIGluc3RlYWQuXCIpO1xuICAgIH1cbiAgICBlbC5rZXkgPSBleHA7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc1JlZihlbCkge1xuICB2YXIgcmVmID0gZ2V0QmluZGluZ0F0dHIoZWwsICdyZWYnKTtcbiAgaWYgKHJlZikge1xuICAgIGVsLnJlZiA9IHJlZjtcbiAgICBlbC5yZWZJbkZvciA9IGNoZWNrSW5Gb3IoZWwpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NGb3IoZWwpIHtcbiAgdmFyIGV4cDtcbiAgaWYgKGV4cCA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWZvcicpKSB7XG4gICAgdmFyIGluTWF0Y2ggPSBleHAubWF0Y2goZm9yQWxpYXNSRSk7XG4gICAgaWYgKCFpbk1hdGNoKSB7XG4gICAgICBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4kMihcIkludmFsaWQgdi1mb3IgZXhwcmVzc2lvbjogXCIgKyBleHApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlbC5mb3IgPSBpbk1hdGNoWzJdLnRyaW0oKTtcbiAgICB2YXIgYWxpYXMgPSBpbk1hdGNoWzFdLnRyaW0oKTtcbiAgICB2YXIgaXRlcmF0b3JNYXRjaCA9IGFsaWFzLm1hdGNoKGZvckl0ZXJhdG9yUkUpO1xuICAgIGlmIChpdGVyYXRvck1hdGNoKSB7XG4gICAgICBlbC5hbGlhcyA9IGl0ZXJhdG9yTWF0Y2hbMV0udHJpbSgpO1xuICAgICAgZWwuaXRlcmF0b3IxID0gaXRlcmF0b3JNYXRjaFsyXS50cmltKCk7XG4gICAgICBpZiAoaXRlcmF0b3JNYXRjaFszXSkge1xuICAgICAgICBlbC5pdGVyYXRvcjIgPSBpdGVyYXRvck1hdGNoWzNdLnRyaW0oKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZWwuYWxpYXMgPSBhbGlhcztcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0lmKGVsKSB7XG4gIHZhciBleHAgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1pZicpO1xuICBpZiAoZXhwKSB7XG4gICAgZWwuaWYgPSBleHA7XG4gICAgYWRkSWZDb25kaXRpb24oZWwsIHtcbiAgICAgIGV4cDogZXhwLFxuICAgICAgYmxvY2s6IGVsXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWVsc2UnKSAhPSBudWxsKSB7XG4gICAgICBlbC5lbHNlID0gdHJ1ZTtcbiAgICB9XG4gICAgdmFyIGVsc2VpZiA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWVsc2UtaWYnKTtcbiAgICBpZiAoZWxzZWlmKSB7XG4gICAgICBlbC5lbHNlaWYgPSBlbHNlaWY7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NJZkNvbmRpdGlvbnMoZWwsIHBhcmVudCkge1xuICB2YXIgcHJldiA9IGZpbmRQcmV2RWxlbWVudChwYXJlbnQuY2hpbGRyZW4pO1xuICBpZiAocHJldiAmJiBwcmV2LmlmKSB7XG4gICAgYWRkSWZDb25kaXRpb24ocHJldiwge1xuICAgICAgZXhwOiBlbC5lbHNlaWYsXG4gICAgICBibG9jazogZWxcbiAgICB9KTtcbiAgfSBlbHNlIGlmIChmYWxzZSkge1xuICAgIHdhcm4kMihcInYtXCIgKyAoZWwuZWxzZWlmID8gJ2Vsc2UtaWY9XCInICsgZWwuZWxzZWlmICsgJ1wiJyA6ICdlbHNlJykgKyBcIiBcIiArIFwidXNlZCBvbiBlbGVtZW50IDxcIiArIGVsLnRhZyArIFwiPiB3aXRob3V0IGNvcnJlc3BvbmRpbmcgdi1pZi5cIik7XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluZFByZXZFbGVtZW50KGNoaWxkcmVuKSB7XG4gIHZhciBpID0gY2hpbGRyZW4ubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgaWYgKGNoaWxkcmVuW2ldLnR5cGUgPT09IDEpIHtcbiAgICAgIHJldHVybiBjaGlsZHJlbltpXTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGZhbHNlKSB7XG4gICAgICAgIHdhcm4kMihcInRleHQgXFxcIlwiICsgY2hpbGRyZW5baV0udGV4dC50cmltKCkgKyBcIlxcXCIgYmV0d2VlbiB2LWlmIGFuZCB2LWVsc2UoLWlmKSBcIiArIFwid2lsbCBiZSBpZ25vcmVkLlwiKTtcbiAgICAgIH1cbiAgICAgIGNoaWxkcmVuLnBvcCgpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhZGRJZkNvbmRpdGlvbihlbCwgY29uZGl0aW9uKSB7XG4gIGlmICghZWwuaWZDb25kaXRpb25zKSB7XG4gICAgZWwuaWZDb25kaXRpb25zID0gW107XG4gIH1cbiAgZWwuaWZDb25kaXRpb25zLnB1c2goY29uZGl0aW9uKTtcbn1cblxuZnVuY3Rpb24gcHJvY2Vzc09uY2UoZWwpIHtcbiAgdmFyIG9uY2UkJDEgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1vbmNlJyk7XG4gIGlmIChvbmNlJCQxICE9IG51bGwpIHtcbiAgICBlbC5vbmNlID0gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzU2xvdChlbCkge1xuICBpZiAoZWwudGFnID09PSAnc2xvdCcpIHtcbiAgICBlbC5zbG90TmFtZSA9IGdldEJpbmRpbmdBdHRyKGVsLCAnbmFtZScpO1xuICAgIGlmIChmYWxzZSkge1xuICAgICAgd2FybiQyKFwiYGtleWAgZG9lcyBub3Qgd29yayBvbiA8c2xvdD4gYmVjYXVzZSBzbG90cyBhcmUgYWJzdHJhY3Qgb3V0bGV0cyBcIiArIFwiYW5kIGNhbiBwb3NzaWJseSBleHBhbmQgaW50byBtdWx0aXBsZSBlbGVtZW50cy4gXCIgKyBcIlVzZSB0aGUga2V5IG9uIGEgd3JhcHBpbmcgZWxlbWVudCBpbnN0ZWFkLlwiKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIHNsb3RUYXJnZXQgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3Nsb3QnKTtcbiAgICBpZiAoc2xvdFRhcmdldCkge1xuICAgICAgZWwuc2xvdFRhcmdldCA9IHNsb3RUYXJnZXQgPT09ICdcIlwiJyA/ICdcImRlZmF1bHRcIicgOiBzbG90VGFyZ2V0O1xuICAgICAgLy8gcHJlc2VydmUgc2xvdCBhcyBhbiBhdHRyaWJ1dGUgZm9yIG5hdGl2ZSBzaGFkb3cgRE9NIGNvbXBhdFxuICAgICAgYWRkQXR0cihlbCwgJ3Nsb3QnLCBzbG90VGFyZ2V0KTtcbiAgICB9XG4gICAgaWYgKGVsLnRhZyA9PT0gJ3RlbXBsYXRlJykge1xuICAgICAgZWwuc2xvdFNjb3BlID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3Njb3BlJyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NDb21wb25lbnQoZWwpIHtcbiAgdmFyIGJpbmRpbmc7XG4gIGlmIChiaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICdpcycpKSB7XG4gICAgZWwuY29tcG9uZW50ID0gYmluZGluZztcbiAgfVxuICBpZiAoZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ2lubGluZS10ZW1wbGF0ZScpICE9IG51bGwpIHtcbiAgICBlbC5pbmxpbmVUZW1wbGF0ZSA9IHRydWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0F0dHJzKGVsKSB7XG4gIHZhciBsaXN0ID0gZWwuYXR0cnNMaXN0O1xuICB2YXIgaSwgbCwgbmFtZSwgcmF3TmFtZSwgdmFsdWUsIG1vZGlmaWVycywgaXNQcm9wO1xuICBmb3IgKGkgPSAwLCBsID0gbGlzdC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBuYW1lID0gcmF3TmFtZSA9IGxpc3RbaV0ubmFtZTtcbiAgICB2YWx1ZSA9IGxpc3RbaV0udmFsdWU7XG4gICAgaWYgKGRpclJFLnRlc3QobmFtZSkpIHtcbiAgICAgIC8vIG1hcmsgZWxlbWVudCBhcyBkeW5hbWljXG4gICAgICBlbC5oYXNCaW5kaW5ncyA9IHRydWU7XG4gICAgICAvLyBtb2RpZmllcnNcbiAgICAgIG1vZGlmaWVycyA9IHBhcnNlTW9kaWZpZXJzKG5hbWUpO1xuICAgICAgaWYgKG1vZGlmaWVycykge1xuICAgICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKG1vZGlmaWVyUkUsICcnKTtcbiAgICAgIH1cbiAgICAgIGlmIChiaW5kUkUudGVzdChuYW1lKSkge1xuICAgICAgICAvLyB2LWJpbmRcbiAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZShiaW5kUkUsICcnKTtcbiAgICAgICAgdmFsdWUgPSBwYXJzZUZpbHRlcnModmFsdWUpO1xuICAgICAgICBpc1Byb3AgPSBmYWxzZTtcbiAgICAgICAgaWYgKG1vZGlmaWVycykge1xuICAgICAgICAgIGlmIChtb2RpZmllcnMucHJvcCkge1xuICAgICAgICAgICAgaXNQcm9wID0gdHJ1ZTtcbiAgICAgICAgICAgIG5hbWUgPSBjYW1lbGl6ZShuYW1lKTtcbiAgICAgICAgICAgIGlmIChuYW1lID09PSAnaW5uZXJIdG1sJykge1xuICAgICAgICAgICAgICBuYW1lID0gJ2lubmVySFRNTCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtb2RpZmllcnMuY2FtZWwpIHtcbiAgICAgICAgICAgIG5hbWUgPSBjYW1lbGl6ZShuYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1vZGlmaWVycy5zeW5jKSB7XG4gICAgICAgICAgICBhZGRIYW5kbGVyKGVsLCBcInVwZGF0ZTpcIiArIGNhbWVsaXplKG5hbWUpLCBnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgXCIkZXZlbnRcIikpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNQcm9wIHx8ICFlbC5jb21wb25lbnQgJiYgcGxhdGZvcm1NdXN0VXNlUHJvcChlbC50YWcsIGVsLmF0dHJzTWFwLnR5cGUsIG5hbWUpKSB7XG4gICAgICAgICAgYWRkUHJvcChlbCwgbmFtZSwgdmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFkZEF0dHIoZWwsIG5hbWUsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChvblJFLnRlc3QobmFtZSkpIHtcbiAgICAgICAgLy8gdi1vblxuICAgICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKG9uUkUsICcnKTtcbiAgICAgICAgYWRkSGFuZGxlcihlbCwgbmFtZSwgdmFsdWUsIG1vZGlmaWVycywgZmFsc2UsIHdhcm4kMik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBub3JtYWwgZGlyZWN0aXZlc1xuICAgICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKGRpclJFLCAnJyk7XG4gICAgICAgIC8vIHBhcnNlIGFyZ1xuICAgICAgICB2YXIgYXJnTWF0Y2ggPSBuYW1lLm1hdGNoKGFyZ1JFKTtcbiAgICAgICAgdmFyIGFyZyA9IGFyZ01hdGNoICYmIGFyZ01hdGNoWzFdO1xuICAgICAgICBpZiAoYXJnKSB7XG4gICAgICAgICAgbmFtZSA9IG5hbWUuc2xpY2UoMCwgLShhcmcubGVuZ3RoICsgMSkpO1xuICAgICAgICB9XG4gICAgICAgIGFkZERpcmVjdGl2ZShlbCwgbmFtZSwgcmF3TmFtZSwgdmFsdWUsIGFyZywgbW9kaWZpZXJzKTtcbiAgICAgICAgaWYgKGZhbHNlKSB7XG4gICAgICAgICAgY2hlY2tGb3JBbGlhc01vZGVsKGVsLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gbGl0ZXJhbCBhdHRyaWJ1dGVcbiAgICAgIGlmIChmYWxzZSkge1xuICAgICAgICB2YXIgZXhwcmVzc2lvbiA9IHBhcnNlVGV4dCh2YWx1ZSwgZGVsaW1pdGVycyk7XG4gICAgICAgIGlmIChleHByZXNzaW9uKSB7XG4gICAgICAgICAgd2FybiQyKG5hbWUgKyBcIj1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIjogXCIgKyAnSW50ZXJwb2xhdGlvbiBpbnNpZGUgYXR0cmlidXRlcyBoYXMgYmVlbiByZW1vdmVkLiAnICsgJ1VzZSB2LWJpbmQgb3IgdGhlIGNvbG9uIHNob3J0aGFuZCBpbnN0ZWFkLiBGb3IgZXhhbXBsZSwgJyArICdpbnN0ZWFkIG9mIDxkaXYgaWQ9XCJ7eyB2YWwgfX1cIj4sIHVzZSA8ZGl2IDppZD1cInZhbFwiPi4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYWRkQXR0cihlbCwgbmFtZSwgSlNPTi5zdHJpbmdpZnkodmFsdWUpKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tJbkZvcihlbCkge1xuICB2YXIgcGFyZW50ID0gZWw7XG4gIHdoaWxlIChwYXJlbnQpIHtcbiAgICBpZiAocGFyZW50LmZvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHBhcnNlTW9kaWZpZXJzKG5hbWUpIHtcbiAgdmFyIG1hdGNoID0gbmFtZS5tYXRjaChtb2RpZmllclJFKTtcbiAgaWYgKG1hdGNoKSB7XG4gICAgdmFyIHJldCA9IHt9O1xuICAgIG1hdGNoLmZvckVhY2goZnVuY3Rpb24gKG0pIHtcbiAgICAgIHJldFttLnNsaWNlKDEpXSA9IHRydWU7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJldDtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYWtlQXR0cnNNYXAoYXR0cnMpIHtcbiAgdmFyIG1hcCA9IHt9O1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGF0dHJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmIChmYWxzZSkge1xuICAgICAgd2FybiQyKCdkdXBsaWNhdGUgYXR0cmlidXRlOiAnICsgYXR0cnNbaV0ubmFtZSk7XG4gICAgfVxuICAgIG1hcFthdHRyc1tpXS5uYW1lXSA9IGF0dHJzW2ldLnZhbHVlO1xuICB9XG4gIHJldHVybiBtYXA7XG59XG5cbi8vIGZvciBzY3JpcHQgKGUuZy4gdHlwZT1cIngvdGVtcGxhdGVcIikgb3Igc3R5bGUsIGRvIG5vdCBkZWNvZGUgY29udGVudFxuZnVuY3Rpb24gaXNUZXh0VGFnKGVsKSB7XG4gIHJldHVybiBlbC50YWcgPT09ICdzY3JpcHQnIHx8IGVsLnRhZyA9PT0gJ3N0eWxlJztcbn1cblxuZnVuY3Rpb24gaXNGb3JiaWRkZW5UYWcoZWwpIHtcbiAgcmV0dXJuIGVsLnRhZyA9PT0gJ3N0eWxlJyB8fCBlbC50YWcgPT09ICdzY3JpcHQnICYmICghZWwuYXR0cnNNYXAudHlwZSB8fCBlbC5hdHRyc01hcC50eXBlID09PSAndGV4dC9qYXZhc2NyaXB0Jyk7XG59XG5cbnZhciBpZU5TQnVnID0gL154bWxuczpOU1xcZCsvO1xudmFyIGllTlNQcmVmaXggPSAvXk5TXFxkKzovO1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gZ3VhcmRJRVNWR0J1ZyhhdHRycykge1xuICB2YXIgcmVzID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXR0cnMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgYXR0ciA9IGF0dHJzW2ldO1xuICAgIGlmICghaWVOU0J1Zy50ZXN0KGF0dHIubmFtZSkpIHtcbiAgICAgIGF0dHIubmFtZSA9IGF0dHIubmFtZS5yZXBsYWNlKGllTlNQcmVmaXgsICcnKTtcbiAgICAgIHJlcy5wdXNoKGF0dHIpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzO1xufVxuXG5mdW5jdGlvbiBjaGVja0ZvckFsaWFzTW9kZWwoZWwsIHZhbHVlKSB7XG4gIHZhciBfZWwgPSBlbDtcbiAgd2hpbGUgKF9lbCkge1xuICAgIGlmIChfZWwuZm9yICYmIF9lbC5hbGlhcyA9PT0gdmFsdWUpIHtcbiAgICAgIHdhcm4kMihcIjxcIiArIGVsLnRhZyArIFwiIHYtbW9kZWw9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCI+OiBcIiArIFwiWW91IGFyZSBiaW5kaW5nIHYtbW9kZWwgZGlyZWN0bHkgdG8gYSB2LWZvciBpdGVyYXRpb24gYWxpYXMuIFwiICsgXCJUaGlzIHdpbGwgbm90IGJlIGFibGUgdG8gbW9kaWZ5IHRoZSB2LWZvciBzb3VyY2UgYXJyYXkgYmVjYXVzZSBcIiArIFwid3JpdGluZyB0byB0aGUgYWxpYXMgaXMgbGlrZSBtb2RpZnlpbmcgYSBmdW5jdGlvbiBsb2NhbCB2YXJpYWJsZS4gXCIgKyBcIkNvbnNpZGVyIHVzaW5nIGFuIGFycmF5IG9mIG9iamVjdHMgYW5kIHVzZSB2LW1vZGVsIG9uIGFuIG9iamVjdCBwcm9wZXJ0eSBpbnN0ZWFkLlwiKTtcbiAgICB9XG4gICAgX2VsID0gX2VsLnBhcmVudDtcbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIGlzU3RhdGljS2V5O1xudmFyIGlzUGxhdGZvcm1SZXNlcnZlZFRhZztcblxudmFyIGdlblN0YXRpY0tleXNDYWNoZWQgPSBjYWNoZWQoZ2VuU3RhdGljS2V5cyQxKTtcblxuLyoqXG4gKiBHb2FsIG9mIHRoZSBvcHRpbWl6ZXI6IHdhbGsgdGhlIGdlbmVyYXRlZCB0ZW1wbGF0ZSBBU1QgdHJlZVxuICogYW5kIGRldGVjdCBzdWItdHJlZXMgdGhhdCBhcmUgcHVyZWx5IHN0YXRpYywgaS5lLiBwYXJ0cyBvZlxuICogdGhlIERPTSB0aGF0IG5ldmVyIG5lZWRzIHRvIGNoYW5nZS5cbiAqXG4gKiBPbmNlIHdlIGRldGVjdCB0aGVzZSBzdWItdHJlZXMsIHdlIGNhbjpcbiAqXG4gKiAxLiBIb2lzdCB0aGVtIGludG8gY29uc3RhbnRzLCBzbyB0aGF0IHdlIG5vIGxvbmdlciBuZWVkIHRvXG4gKiAgICBjcmVhdGUgZnJlc2ggbm9kZXMgZm9yIHRoZW0gb24gZWFjaCByZS1yZW5kZXI7XG4gKiAyLiBDb21wbGV0ZWx5IHNraXAgdGhlbSBpbiB0aGUgcGF0Y2hpbmcgcHJvY2Vzcy5cbiAqL1xuZnVuY3Rpb24gb3B0aW1pemUocm9vdCwgb3B0aW9ucykge1xuICBpZiAoIXJvb3QpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaXNTdGF0aWNLZXkgPSBnZW5TdGF0aWNLZXlzQ2FjaGVkKG9wdGlvbnMuc3RhdGljS2V5cyB8fCAnJyk7XG4gIGlzUGxhdGZvcm1SZXNlcnZlZFRhZyA9IG9wdGlvbnMuaXNSZXNlcnZlZFRhZyB8fCBubztcbiAgLy8gZmlyc3QgcGFzczogbWFyayBhbGwgbm9uLXN0YXRpYyBub2Rlcy5cbiAgbWFya1N0YXRpYyQxKHJvb3QpO1xuICAvLyBzZWNvbmQgcGFzczogbWFyayBzdGF0aWMgcm9vdHMuXG4gIG1hcmtTdGF0aWNSb290cyhyb290LCBmYWxzZSk7XG59XG5cbmZ1bmN0aW9uIGdlblN0YXRpY0tleXMkMShrZXlzKSB7XG4gIHJldHVybiBtYWtlTWFwKCd0eXBlLHRhZyxhdHRyc0xpc3QsYXR0cnNNYXAscGxhaW4scGFyZW50LGNoaWxkcmVuLGF0dHJzJyArIChrZXlzID8gJywnICsga2V5cyA6ICcnKSk7XG59XG5cbmZ1bmN0aW9uIG1hcmtTdGF0aWMkMShub2RlKSB7XG4gIG5vZGUuc3RhdGljID0gaXNTdGF0aWMobm9kZSk7XG4gIGlmIChub2RlLnR5cGUgPT09IDEpIHtcbiAgICAvLyBkbyBub3QgbWFrZSBjb21wb25lbnQgc2xvdCBjb250ZW50IHN0YXRpYy4gdGhpcyBhdm9pZHNcbiAgICAvLyAxLiBjb21wb25lbnRzIG5vdCBhYmxlIHRvIG11dGF0ZSBzbG90IG5vZGVzXG4gICAgLy8gMi4gc3RhdGljIHNsb3QgY29udGVudCBmYWlscyBmb3IgaG90LXJlbG9hZGluZ1xuICAgIGlmICghaXNQbGF0Zm9ybVJlc2VydmVkVGFnKG5vZGUudGFnKSAmJiBub2RlLnRhZyAhPT0gJ3Nsb3QnICYmIG5vZGUuYXR0cnNNYXBbJ2lubGluZS10ZW1wbGF0ZSddID09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGNoaWxkID0gbm9kZS5jaGlsZHJlbltpXTtcbiAgICAgIG1hcmtTdGF0aWMkMShjaGlsZCk7XG4gICAgICBpZiAoIWNoaWxkLnN0YXRpYykge1xuICAgICAgICBub2RlLnN0YXRpYyA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobm9kZS5pZkNvbmRpdGlvbnMpIHtcbiAgICAgIGZvciAodmFyIGkkMSA9IDEsIGwkMSA9IG5vZGUuaWZDb25kaXRpb25zLmxlbmd0aDsgaSQxIDwgbCQxOyBpJDErKykge1xuICAgICAgICB2YXIgYmxvY2sgPSBub2RlLmlmQ29uZGl0aW9uc1tpJDFdLmJsb2NrO1xuICAgICAgICBtYXJrU3RhdGljJDEoYmxvY2spO1xuICAgICAgICBpZiAoIWJsb2NrLnN0YXRpYykge1xuICAgICAgICAgIG5vZGUuc3RhdGljID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFya1N0YXRpY1Jvb3RzKG5vZGUsIGlzSW5Gb3IpIHtcbiAgaWYgKG5vZGUudHlwZSA9PT0gMSkge1xuICAgIGlmIChub2RlLnN0YXRpYyB8fCBub2RlLm9uY2UpIHtcbiAgICAgIG5vZGUuc3RhdGljSW5Gb3IgPSBpc0luRm9yO1xuICAgIH1cbiAgICAvLyBGb3IgYSBub2RlIHRvIHF1YWxpZnkgYXMgYSBzdGF0aWMgcm9vdCwgaXQgc2hvdWxkIGhhdmUgY2hpbGRyZW4gdGhhdFxuICAgIC8vIGFyZSBub3QganVzdCBzdGF0aWMgdGV4dC4gT3RoZXJ3aXNlIHRoZSBjb3N0IG9mIGhvaXN0aW5nIG91dCB3aWxsXG4gICAgLy8gb3V0d2VpZ2ggdGhlIGJlbmVmaXRzIGFuZCBpdCdzIGJldHRlciBvZmYgdG8ganVzdCBhbHdheXMgcmVuZGVyIGl0IGZyZXNoLlxuICAgIGlmIChub2RlLnN0YXRpYyAmJiBub2RlLmNoaWxkcmVuLmxlbmd0aCAmJiAhKG5vZGUuY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmIG5vZGUuY2hpbGRyZW5bMF0udHlwZSA9PT0gMykpIHtcbiAgICAgIG5vZGUuc3RhdGljUm9vdCA9IHRydWU7XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUuc3RhdGljUm9vdCA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAobm9kZS5jaGlsZHJlbikge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBtYXJrU3RhdGljUm9vdHMobm9kZS5jaGlsZHJlbltpXSwgaXNJbkZvciB8fCAhIW5vZGUuZm9yKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5vZGUuaWZDb25kaXRpb25zKSB7XG4gICAgICBmb3IgKHZhciBpJDEgPSAxLCBsJDEgPSBub2RlLmlmQ29uZGl0aW9ucy5sZW5ndGg7IGkkMSA8IGwkMTsgaSQxKyspIHtcbiAgICAgICAgbWFya1N0YXRpY1Jvb3RzKG5vZGUuaWZDb25kaXRpb25zW2kkMV0uYmxvY2ssIGlzSW5Gb3IpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpc1N0YXRpYyhub2RlKSB7XG4gIGlmIChub2RlLnR5cGUgPT09IDIpIHtcbiAgICAvLyBleHByZXNzaW9uXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChub2RlLnR5cGUgPT09IDMpIHtcbiAgICAvLyB0ZXh0XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuICEhKG5vZGUucHJlIHx8ICFub2RlLmhhc0JpbmRpbmdzICYmIC8vIG5vIGR5bmFtaWMgYmluZGluZ3NcbiAgIW5vZGUuaWYgJiYgIW5vZGUuZm9yICYmIC8vIG5vdCB2LWlmIG9yIHYtZm9yIG9yIHYtZWxzZVxuICAhaXNCdWlsdEluVGFnKG5vZGUudGFnKSAmJiAvLyBub3QgYSBidWlsdC1pblxuICBpc1BsYXRmb3JtUmVzZXJ2ZWRUYWcobm9kZS50YWcpICYmIC8vIG5vdCBhIGNvbXBvbmVudFxuICAhaXNEaXJlY3RDaGlsZE9mVGVtcGxhdGVGb3Iobm9kZSkgJiYgT2JqZWN0LmtleXMobm9kZSkuZXZlcnkoaXNTdGF0aWNLZXkpKTtcbn1cblxuZnVuY3Rpb24gaXNEaXJlY3RDaGlsZE9mVGVtcGxhdGVGb3Iobm9kZSkge1xuICB3aGlsZSAobm9kZS5wYXJlbnQpIHtcbiAgICBub2RlID0gbm9kZS5wYXJlbnQ7XG4gICAgaWYgKG5vZGUudGFnICE9PSAndGVtcGxhdGUnKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChub2RlLmZvcikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyogICovXG5cbnZhciBmbkV4cFJFID0gL15cXHMqKFtcXHckX10rfFxcKFteKV0qP1xcKSlcXHMqPT58XmZ1bmN0aW9uXFxzKlxcKC87XG52YXIgc2ltcGxlUGF0aFJFID0gL15cXHMqW0EtWmEtel8kXVtcXHckXSooPzpcXC5bQS1aYS16XyRdW1xcdyRdKnxcXFsnLio/J118XFxbXCIuKj9cIl18XFxbXFxkK118XFxbW0EtWmEtel8kXVtcXHckXSpdKSpcXHMqJC87XG5cbi8vIGtleUNvZGUgYWxpYXNlc1xudmFyIGtleUNvZGVzID0ge1xuICBlc2M6IDI3LFxuICB0YWI6IDksXG4gIGVudGVyOiAxMyxcbiAgc3BhY2U6IDMyLFxuICB1cDogMzgsXG4gIGxlZnQ6IDM3LFxuICByaWdodDogMzksXG4gIGRvd246IDQwLFxuICAnZGVsZXRlJzogWzgsIDQ2XVxufTtcblxuLy8gIzQ4Njg6IG1vZGlmaWVycyB0aGF0IHByZXZlbnQgdGhlIGV4ZWN1dGlvbiBvZiB0aGUgbGlzdGVuZXJcbi8vIG5lZWQgdG8gZXhwbGljaXRseSByZXR1cm4gbnVsbCBzbyB0aGF0IHdlIGNhbiBkZXRlcm1pbmUgd2hldGhlciB0byByZW1vdmVcbi8vIHRoZSBsaXN0ZW5lciBmb3IgLm9uY2VcbnZhciBnZW5HdWFyZCA9IGZ1bmN0aW9uIChjb25kaXRpb24pIHtcbiAgcmV0dXJuIFwiaWYoXCIgKyBjb25kaXRpb24gKyBcIilyZXR1cm4gbnVsbDtcIjtcbn07XG5cbnZhciBtb2RpZmllckNvZGUgPSB7XG4gIHN0b3A6ICckZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7JyxcbiAgcHJldmVudDogJyRldmVudC5wcmV2ZW50RGVmYXVsdCgpOycsXG4gIHNlbGY6IGdlbkd1YXJkKFwiJGV2ZW50LnRhcmdldCAhPT0gJGV2ZW50LmN1cnJlbnRUYXJnZXRcIiksXG4gIGN0cmw6IGdlbkd1YXJkKFwiISRldmVudC5jdHJsS2V5XCIpLFxuICBzaGlmdDogZ2VuR3VhcmQoXCIhJGV2ZW50LnNoaWZ0S2V5XCIpLFxuICBhbHQ6IGdlbkd1YXJkKFwiISRldmVudC5hbHRLZXlcIiksXG4gIG1ldGE6IGdlbkd1YXJkKFwiISRldmVudC5tZXRhS2V5XCIpLFxuICBsZWZ0OiBnZW5HdWFyZChcIididXR0b24nIGluICRldmVudCAmJiAkZXZlbnQuYnV0dG9uICE9PSAwXCIpLFxuICBtaWRkbGU6IGdlbkd1YXJkKFwiJ2J1dHRvbicgaW4gJGV2ZW50ICYmICRldmVudC5idXR0b24gIT09IDFcIiksXG4gIHJpZ2h0OiBnZW5HdWFyZChcIididXR0b24nIGluICRldmVudCAmJiAkZXZlbnQuYnV0dG9uICE9PSAyXCIpXG59O1xuXG5mdW5jdGlvbiBnZW5IYW5kbGVycyhldmVudHMsIGlzTmF0aXZlLCB3YXJuKSB7XG4gIHZhciByZXMgPSBpc05hdGl2ZSA/ICduYXRpdmVPbjp7JyA6ICdvbjp7JztcbiAgZm9yICh2YXIgbmFtZSBpbiBldmVudHMpIHtcbiAgICB2YXIgaGFuZGxlciA9IGV2ZW50c1tuYW1lXTtcbiAgICAvLyAjNTMzMDogd2FybiBjbGljay5yaWdodCwgc2luY2UgcmlnaHQgY2xpY2tzIGRvIG5vdCBhY3R1YWxseSBmaXJlIGNsaWNrIGV2ZW50cy5cbiAgICBpZiAoZmFsc2UpIHtcbiAgICAgIHdhcm4oXCJVc2UgXFxcImNvbnRleHRtZW51XFxcIiBpbnN0ZWFkIG9mIFxcXCJjbGljay5yaWdodFxcXCIgc2luY2UgcmlnaHQgY2xpY2tzIFwiICsgXCJkbyBub3QgYWN0dWFsbHkgZmlyZSBcXFwiY2xpY2tcXFwiIGV2ZW50cy5cIik7XG4gICAgfVxuICAgIHJlcyArPSBcIlxcXCJcIiArIG5hbWUgKyBcIlxcXCI6XCIgKyBnZW5IYW5kbGVyKG5hbWUsIGhhbmRsZXIpICsgXCIsXCI7XG4gIH1cbiAgcmV0dXJuIHJlcy5zbGljZSgwLCAtMSkgKyAnfSc7XG59XG5cbmZ1bmN0aW9uIGdlbkhhbmRsZXIobmFtZSwgaGFuZGxlcikge1xuICBpZiAoIWhhbmRsZXIpIHtcbiAgICByZXR1cm4gJ2Z1bmN0aW9uKCl7fSc7XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheShoYW5kbGVyKSkge1xuICAgIHJldHVybiBcIltcIiArIGhhbmRsZXIubWFwKGZ1bmN0aW9uIChoYW5kbGVyKSB7XG4gICAgICByZXR1cm4gZ2VuSGFuZGxlcihuYW1lLCBoYW5kbGVyKTtcbiAgICB9KS5qb2luKCcsJykgKyBcIl1cIjtcbiAgfVxuXG4gIHZhciBpc01ldGhvZFBhdGggPSBzaW1wbGVQYXRoUkUudGVzdChoYW5kbGVyLnZhbHVlKTtcbiAgdmFyIGlzRnVuY3Rpb25FeHByZXNzaW9uID0gZm5FeHBSRS50ZXN0KGhhbmRsZXIudmFsdWUpO1xuXG4gIGlmICghaGFuZGxlci5tb2RpZmllcnMpIHtcbiAgICByZXR1cm4gaXNNZXRob2RQYXRoIHx8IGlzRnVuY3Rpb25FeHByZXNzaW9uID8gaGFuZGxlci52YWx1ZSA6IFwiZnVuY3Rpb24oJGV2ZW50KXtcIiArIGhhbmRsZXIudmFsdWUgKyBcIn1cIjsgLy8gaW5saW5lIHN0YXRlbWVudFxuICB9IGVsc2Uge1xuICAgIHZhciBjb2RlID0gJyc7XG4gICAgdmFyIGdlbk1vZGlmaWVyQ29kZSA9ICcnO1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIGhhbmRsZXIubW9kaWZpZXJzKSB7XG4gICAgICBpZiAobW9kaWZpZXJDb2RlW2tleV0pIHtcbiAgICAgICAgZ2VuTW9kaWZpZXJDb2RlICs9IG1vZGlmaWVyQ29kZVtrZXldO1xuICAgICAgICAvLyBsZWZ0L3JpZ2h0XG4gICAgICAgIGlmIChrZXlDb2Rlc1trZXldKSB7XG4gICAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoa2V5cy5sZW5ndGgpIHtcbiAgICAgIGNvZGUgKz0gZ2VuS2V5RmlsdGVyKGtleXMpO1xuICAgIH1cbiAgICAvLyBNYWtlIHN1cmUgbW9kaWZpZXJzIGxpa2UgcHJldmVudCBhbmQgc3RvcCBnZXQgZXhlY3V0ZWQgYWZ0ZXIga2V5IGZpbHRlcmluZ1xuICAgIGlmIChnZW5Nb2RpZmllckNvZGUpIHtcbiAgICAgIGNvZGUgKz0gZ2VuTW9kaWZpZXJDb2RlO1xuICAgIH1cbiAgICB2YXIgaGFuZGxlckNvZGUgPSBpc01ldGhvZFBhdGggPyBoYW5kbGVyLnZhbHVlICsgJygkZXZlbnQpJyA6IGlzRnVuY3Rpb25FeHByZXNzaW9uID8gXCIoXCIgKyBoYW5kbGVyLnZhbHVlICsgXCIpKCRldmVudClcIiA6IGhhbmRsZXIudmFsdWU7XG4gICAgcmV0dXJuIFwiZnVuY3Rpb24oJGV2ZW50KXtcIiArIGNvZGUgKyBoYW5kbGVyQ29kZSArIFwifVwiO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdlbktleUZpbHRlcihrZXlzKSB7XG4gIHJldHVybiBcImlmKCEoJ2J1dHRvbicgaW4gJGV2ZW50KSYmXCIgKyBrZXlzLm1hcChnZW5GaWx0ZXJDb2RlKS5qb2luKCcmJicpICsgXCIpcmV0dXJuIG51bGw7XCI7XG59XG5cbmZ1bmN0aW9uIGdlbkZpbHRlckNvZGUoa2V5KSB7XG4gIHZhciBrZXlWYWwgPSBwYXJzZUludChrZXksIDEwKTtcbiAgaWYgKGtleVZhbCkge1xuICAgIHJldHVybiBcIiRldmVudC5rZXlDb2RlIT09XCIgKyBrZXlWYWw7XG4gIH1cbiAgdmFyIGFsaWFzID0ga2V5Q29kZXNba2V5XTtcbiAgcmV0dXJuIFwiX2soJGV2ZW50LmtleUNvZGUsXCIgKyBKU09OLnN0cmluZ2lmeShrZXkpICsgKGFsaWFzID8gJywnICsgSlNPTi5zdHJpbmdpZnkoYWxpYXMpIDogJycpICsgXCIpXCI7XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBvbihlbCwgZGlyKSB7XG4gIGlmIChmYWxzZSkge1xuICAgIHdhcm4oXCJ2LW9uIHdpdGhvdXQgYXJndW1lbnQgZG9lcyBub3Qgc3VwcG9ydCBtb2RpZmllcnMuXCIpO1xuICB9XG4gIGVsLndyYXBMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoY29kZSkge1xuICAgIHJldHVybiBcIl9nKFwiICsgY29kZSArIFwiLFwiICsgZGlyLnZhbHVlICsgXCIpXCI7XG4gIH07XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBiaW5kJDEoZWwsIGRpcikge1xuICBlbC53cmFwRGF0YSA9IGZ1bmN0aW9uIChjb2RlKSB7XG4gICAgcmV0dXJuIFwiX2IoXCIgKyBjb2RlICsgXCIsJ1wiICsgZWwudGFnICsgXCInLFwiICsgZGlyLnZhbHVlICsgXCIsXCIgKyAoZGlyLm1vZGlmaWVycyAmJiBkaXIubW9kaWZpZXJzLnByb3AgPyAndHJ1ZScgOiAnZmFsc2UnKSArIChkaXIubW9kaWZpZXJzICYmIGRpci5tb2RpZmllcnMuc3luYyA/ICcsdHJ1ZScgOiAnJykgKyBcIilcIjtcbiAgfTtcbn1cblxuLyogICovXG5cbnZhciBiYXNlRGlyZWN0aXZlcyA9IHtcbiAgb246IG9uLFxuICBiaW5kOiBiaW5kJDEsXG4gIGNsb2FrOiBub29wXG59O1xuXG4vKiAgKi9cblxudmFyIENvZGVnZW5TdGF0ZSA9IGZ1bmN0aW9uIENvZGVnZW5TdGF0ZShvcHRpb25zKSB7XG4gIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gIHRoaXMud2FybiA9IG9wdGlvbnMud2FybiB8fCBiYXNlV2FybjtcbiAgdGhpcy50cmFuc2Zvcm1zID0gcGx1Y2tNb2R1bGVGdW5jdGlvbihvcHRpb25zLm1vZHVsZXMsICd0cmFuc2Zvcm1Db2RlJyk7XG4gIHRoaXMuZGF0YUdlbkZucyA9IHBsdWNrTW9kdWxlRnVuY3Rpb24ob3B0aW9ucy5tb2R1bGVzLCAnZ2VuRGF0YScpO1xuICB0aGlzLmRpcmVjdGl2ZXMgPSBleHRlbmQoZXh0ZW5kKHt9LCBiYXNlRGlyZWN0aXZlcyksIG9wdGlvbnMuZGlyZWN0aXZlcyk7XG4gIHZhciBpc1Jlc2VydmVkVGFnID0gb3B0aW9ucy5pc1Jlc2VydmVkVGFnIHx8IG5vO1xuICB0aGlzLm1heWJlQ29tcG9uZW50ID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgcmV0dXJuICFpc1Jlc2VydmVkVGFnKGVsLnRhZyk7XG4gIH07XG4gIHRoaXMub25jZUlkID0gMDtcbiAgdGhpcy5zdGF0aWNSZW5kZXJGbnMgPSBbXTtcbn07XG5cbmZ1bmN0aW9uIGdlbmVyYXRlKGFzdCwgb3B0aW9ucykge1xuICB2YXIgc3RhdGUgPSBuZXcgQ29kZWdlblN0YXRlKG9wdGlvbnMpO1xuICB2YXIgY29kZSA9IGFzdCA/IGdlbkVsZW1lbnQoYXN0LCBzdGF0ZSkgOiAnX2MoXCJkaXZcIiknO1xuICByZXR1cm4ge1xuICAgIHJlbmRlcjogXCJ3aXRoKHRoaXMpe3JldHVybiBcIiArIGNvZGUgKyBcIn1cIixcbiAgICBzdGF0aWNSZW5kZXJGbnM6IHN0YXRlLnN0YXRpY1JlbmRlckZuc1xuICB9O1xufVxuXG5mdW5jdGlvbiBnZW5FbGVtZW50KGVsLCBzdGF0ZSkge1xuICBpZiAoZWwuc3RhdGljUm9vdCAmJiAhZWwuc3RhdGljUHJvY2Vzc2VkKSB7XG4gICAgcmV0dXJuIGdlblN0YXRpYyhlbCwgc3RhdGUpO1xuICB9IGVsc2UgaWYgKGVsLm9uY2UgJiYgIWVsLm9uY2VQcm9jZXNzZWQpIHtcbiAgICByZXR1cm4gZ2VuT25jZShlbCwgc3RhdGUpO1xuICB9IGVsc2UgaWYgKGVsLmZvciAmJiAhZWwuZm9yUHJvY2Vzc2VkKSB7XG4gICAgcmV0dXJuIGdlbkZvcihlbCwgc3RhdGUpO1xuICB9IGVsc2UgaWYgKGVsLmlmICYmICFlbC5pZlByb2Nlc3NlZCkge1xuICAgIHJldHVybiBnZW5JZihlbCwgc3RhdGUpO1xuICB9IGVsc2UgaWYgKGVsLnRhZyA9PT0gJ3RlbXBsYXRlJyAmJiAhZWwuc2xvdFRhcmdldCkge1xuICAgIHJldHVybiBnZW5DaGlsZHJlbihlbCwgc3RhdGUpIHx8ICd2b2lkIDAnO1xuICB9IGVsc2UgaWYgKGVsLnRhZyA9PT0gJ3Nsb3QnKSB7XG4gICAgcmV0dXJuIGdlblNsb3QoZWwsIHN0YXRlKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBjb21wb25lbnQgb3IgZWxlbWVudFxuICAgIHZhciBjb2RlO1xuICAgIGlmIChlbC5jb21wb25lbnQpIHtcbiAgICAgIGNvZGUgPSBnZW5Db21wb25lbnQoZWwuY29tcG9uZW50LCBlbCwgc3RhdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZGF0YSA9IGVsLnBsYWluID8gdW5kZWZpbmVkIDogZ2VuRGF0YSQyKGVsLCBzdGF0ZSk7XG5cbiAgICAgIHZhciBjaGlsZHJlbiA9IGVsLmlubGluZVRlbXBsYXRlID8gbnVsbCA6IGdlbkNoaWxkcmVuKGVsLCBzdGF0ZSwgdHJ1ZSk7XG4gICAgICBjb2RlID0gXCJfYygnXCIgKyBlbC50YWcgKyBcIidcIiArIChkYXRhID8gXCIsXCIgKyBkYXRhIDogJycpICsgKGNoaWxkcmVuID8gXCIsXCIgKyBjaGlsZHJlbiA6ICcnKSArIFwiKVwiO1xuICAgIH1cbiAgICAvLyBtb2R1bGUgdHJhbnNmb3Jtc1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhdGUudHJhbnNmb3Jtcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29kZSA9IHN0YXRlLnRyYW5zZm9ybXNbaV0oZWwsIGNvZGUpO1xuICAgIH1cbiAgICByZXR1cm4gY29kZTtcbiAgfVxufVxuXG4vLyBob2lzdCBzdGF0aWMgc3ViLXRyZWVzIG91dFxuZnVuY3Rpb24gZ2VuU3RhdGljKGVsLCBzdGF0ZSkge1xuICBlbC5zdGF0aWNQcm9jZXNzZWQgPSB0cnVlO1xuICBzdGF0ZS5zdGF0aWNSZW5kZXJGbnMucHVzaChcIndpdGgodGhpcyl7cmV0dXJuIFwiICsgZ2VuRWxlbWVudChlbCwgc3RhdGUpICsgXCJ9XCIpO1xuICByZXR1cm4gXCJfbShcIiArIChzdGF0ZS5zdGF0aWNSZW5kZXJGbnMubGVuZ3RoIC0gMSkgKyAoZWwuc3RhdGljSW5Gb3IgPyAnLHRydWUnIDogJycpICsgXCIpXCI7XG59XG5cbi8vIHYtb25jZVxuZnVuY3Rpb24gZ2VuT25jZShlbCwgc3RhdGUpIHtcbiAgZWwub25jZVByb2Nlc3NlZCA9IHRydWU7XG4gIGlmIChlbC5pZiAmJiAhZWwuaWZQcm9jZXNzZWQpIHtcbiAgICByZXR1cm4gZ2VuSWYoZWwsIHN0YXRlKTtcbiAgfSBlbHNlIGlmIChlbC5zdGF0aWNJbkZvcikge1xuICAgIHZhciBrZXkgPSAnJztcbiAgICB2YXIgcGFyZW50ID0gZWwucGFyZW50O1xuICAgIHdoaWxlIChwYXJlbnQpIHtcbiAgICAgIGlmIChwYXJlbnQuZm9yKSB7XG4gICAgICAgIGtleSA9IHBhcmVudC5rZXk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgICB9XG4gICAgaWYgKCFrZXkpIHtcbiAgICAgIFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgJiYgc3RhdGUud2FybihcInYtb25jZSBjYW4gb25seSBiZSB1c2VkIGluc2lkZSB2LWZvciB0aGF0IGlzIGtleWVkLiBcIik7XG4gICAgICByZXR1cm4gZ2VuRWxlbWVudChlbCwgc3RhdGUpO1xuICAgIH1cbiAgICByZXR1cm4gXCJfbyhcIiArIGdlbkVsZW1lbnQoZWwsIHN0YXRlKSArIFwiLFwiICsgc3RhdGUub25jZUlkKysgKyBcIixcIiArIGtleSArIFwiKVwiO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBnZW5TdGF0aWMoZWwsIHN0YXRlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5JZihlbCwgc3RhdGUsIGFsdEdlbiwgYWx0RW1wdHkpIHtcbiAgZWwuaWZQcm9jZXNzZWQgPSB0cnVlOyAvLyBhdm9pZCByZWN1cnNpb25cbiAgcmV0dXJuIGdlbklmQ29uZGl0aW9ucyhlbC5pZkNvbmRpdGlvbnMuc2xpY2UoKSwgc3RhdGUsIGFsdEdlbiwgYWx0RW1wdHkpO1xufVxuXG5mdW5jdGlvbiBnZW5JZkNvbmRpdGlvbnMoY29uZGl0aW9ucywgc3RhdGUsIGFsdEdlbiwgYWx0RW1wdHkpIHtcbiAgaWYgKCFjb25kaXRpb25zLmxlbmd0aCkge1xuICAgIHJldHVybiBhbHRFbXB0eSB8fCAnX2UoKSc7XG4gIH1cblxuICB2YXIgY29uZGl0aW9uID0gY29uZGl0aW9ucy5zaGlmdCgpO1xuICBpZiAoY29uZGl0aW9uLmV4cCkge1xuICAgIHJldHVybiBcIihcIiArIGNvbmRpdGlvbi5leHAgKyBcIik/XCIgKyBnZW5UZXJuYXJ5RXhwKGNvbmRpdGlvbi5ibG9jaykgKyBcIjpcIiArIGdlbklmQ29uZGl0aW9ucyhjb25kaXRpb25zLCBzdGF0ZSwgYWx0R2VuLCBhbHRFbXB0eSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFwiXCIgKyBnZW5UZXJuYXJ5RXhwKGNvbmRpdGlvbi5ibG9jayk7XG4gIH1cblxuICAvLyB2LWlmIHdpdGggdi1vbmNlIHNob3VsZCBnZW5lcmF0ZSBjb2RlIGxpa2UgKGEpP19tKDApOl9tKDEpXG4gIGZ1bmN0aW9uIGdlblRlcm5hcnlFeHAoZWwpIHtcbiAgICByZXR1cm4gYWx0R2VuID8gYWx0R2VuKGVsLCBzdGF0ZSkgOiBlbC5vbmNlID8gZ2VuT25jZShlbCwgc3RhdGUpIDogZ2VuRWxlbWVudChlbCwgc3RhdGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdlbkZvcihlbCwgc3RhdGUsIGFsdEdlbiwgYWx0SGVscGVyKSB7XG4gIHZhciBleHAgPSBlbC5mb3I7XG4gIHZhciBhbGlhcyA9IGVsLmFsaWFzO1xuICB2YXIgaXRlcmF0b3IxID0gZWwuaXRlcmF0b3IxID8gXCIsXCIgKyBlbC5pdGVyYXRvcjEgOiAnJztcbiAgdmFyIGl0ZXJhdG9yMiA9IGVsLml0ZXJhdG9yMiA/IFwiLFwiICsgZWwuaXRlcmF0b3IyIDogJyc7XG5cbiAgaWYgKGZhbHNlKSB7XG4gICAgc3RhdGUud2FybihcIjxcIiArIGVsLnRhZyArIFwiIHYtZm9yPVxcXCJcIiArIGFsaWFzICsgXCIgaW4gXCIgKyBleHAgKyBcIlxcXCI+OiBjb21wb25lbnQgbGlzdHMgcmVuZGVyZWQgd2l0aCBcIiArIFwidi1mb3Igc2hvdWxkIGhhdmUgZXhwbGljaXQga2V5cy4gXCIgKyBcIlNlZSBodHRwczovL3Z1ZWpzLm9yZy9ndWlkZS9saXN0Lmh0bWwja2V5IGZvciBtb3JlIGluZm8uXCIsIHRydWUgLyogdGlwICovXG4gICAgKTtcbiAgfVxuXG4gIGVsLmZvclByb2Nlc3NlZCA9IHRydWU7IC8vIGF2b2lkIHJlY3Vyc2lvblxuICByZXR1cm4gKGFsdEhlbHBlciB8fCAnX2wnKSArIFwiKChcIiArIGV4cCArIFwiKSxcIiArIFwiZnVuY3Rpb24oXCIgKyBhbGlhcyArIGl0ZXJhdG9yMSArIGl0ZXJhdG9yMiArIFwiKXtcIiArIFwicmV0dXJuIFwiICsgKGFsdEdlbiB8fCBnZW5FbGVtZW50KShlbCwgc3RhdGUpICsgJ30pJztcbn1cblxuZnVuY3Rpb24gZ2VuRGF0YSQyKGVsLCBzdGF0ZSkge1xuICB2YXIgZGF0YSA9ICd7JztcblxuICAvLyBkaXJlY3RpdmVzIGZpcnN0LlxuICAvLyBkaXJlY3RpdmVzIG1heSBtdXRhdGUgdGhlIGVsJ3Mgb3RoZXIgcHJvcGVydGllcyBiZWZvcmUgdGhleSBhcmUgZ2VuZXJhdGVkLlxuICB2YXIgZGlycyA9IGdlbkRpcmVjdGl2ZXMoZWwsIHN0YXRlKTtcbiAgaWYgKGRpcnMpIHtcbiAgICBkYXRhICs9IGRpcnMgKyAnLCc7XG4gIH1cblxuICAvLyBrZXlcbiAgaWYgKGVsLmtleSkge1xuICAgIGRhdGEgKz0gXCJrZXk6XCIgKyBlbC5rZXkgKyBcIixcIjtcbiAgfVxuICAvLyByZWZcbiAgaWYgKGVsLnJlZikge1xuICAgIGRhdGEgKz0gXCJyZWY6XCIgKyBlbC5yZWYgKyBcIixcIjtcbiAgfVxuICBpZiAoZWwucmVmSW5Gb3IpIHtcbiAgICBkYXRhICs9IFwicmVmSW5Gb3I6dHJ1ZSxcIjtcbiAgfVxuICAvLyBwcmVcbiAgaWYgKGVsLnByZSkge1xuICAgIGRhdGEgKz0gXCJwcmU6dHJ1ZSxcIjtcbiAgfVxuICAvLyByZWNvcmQgb3JpZ2luYWwgdGFnIG5hbWUgZm9yIGNvbXBvbmVudHMgdXNpbmcgXCJpc1wiIGF0dHJpYnV0ZVxuICBpZiAoZWwuY29tcG9uZW50KSB7XG4gICAgZGF0YSArPSBcInRhZzpcXFwiXCIgKyBlbC50YWcgKyBcIlxcXCIsXCI7XG4gIH1cbiAgLy8gbW9kdWxlIGRhdGEgZ2VuZXJhdGlvbiBmdW5jdGlvbnNcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGF0ZS5kYXRhR2VuRm5zLmxlbmd0aDsgaSsrKSB7XG4gICAgZGF0YSArPSBzdGF0ZS5kYXRhR2VuRm5zW2ldKGVsKTtcbiAgfVxuICAvLyBhdHRyaWJ1dGVzXG4gIGlmIChlbC5hdHRycykge1xuICAgIGRhdGEgKz0gXCJhdHRyczp7XCIgKyBnZW5Qcm9wcyhlbC5hdHRycykgKyBcIn0sXCI7XG4gIH1cbiAgLy8gRE9NIHByb3BzXG4gIGlmIChlbC5wcm9wcykge1xuICAgIGRhdGEgKz0gXCJkb21Qcm9wczp7XCIgKyBnZW5Qcm9wcyhlbC5wcm9wcykgKyBcIn0sXCI7XG4gIH1cbiAgLy8gZXZlbnQgaGFuZGxlcnNcbiAgaWYgKGVsLmV2ZW50cykge1xuICAgIGRhdGEgKz0gZ2VuSGFuZGxlcnMoZWwuZXZlbnRzLCBmYWxzZSwgc3RhdGUud2FybikgKyBcIixcIjtcbiAgfVxuICBpZiAoZWwubmF0aXZlRXZlbnRzKSB7XG4gICAgZGF0YSArPSBnZW5IYW5kbGVycyhlbC5uYXRpdmVFdmVudHMsIHRydWUsIHN0YXRlLndhcm4pICsgXCIsXCI7XG4gIH1cbiAgLy8gc2xvdCB0YXJnZXRcbiAgaWYgKGVsLnNsb3RUYXJnZXQpIHtcbiAgICBkYXRhICs9IFwic2xvdDpcIiArIGVsLnNsb3RUYXJnZXQgKyBcIixcIjtcbiAgfVxuICAvLyBzY29wZWQgc2xvdHNcbiAgaWYgKGVsLnNjb3BlZFNsb3RzKSB7XG4gICAgZGF0YSArPSBnZW5TY29wZWRTbG90cyhlbC5zY29wZWRTbG90cywgc3RhdGUpICsgXCIsXCI7XG4gIH1cbiAgLy8gY29tcG9uZW50IHYtbW9kZWxcbiAgaWYgKGVsLm1vZGVsKSB7XG4gICAgZGF0YSArPSBcIm1vZGVsOnt2YWx1ZTpcIiArIGVsLm1vZGVsLnZhbHVlICsgXCIsY2FsbGJhY2s6XCIgKyBlbC5tb2RlbC5jYWxsYmFjayArIFwiLGV4cHJlc3Npb246XCIgKyBlbC5tb2RlbC5leHByZXNzaW9uICsgXCJ9LFwiO1xuICB9XG4gIC8vIGlubGluZS10ZW1wbGF0ZVxuICBpZiAoZWwuaW5saW5lVGVtcGxhdGUpIHtcbiAgICB2YXIgaW5saW5lVGVtcGxhdGUgPSBnZW5JbmxpbmVUZW1wbGF0ZShlbCwgc3RhdGUpO1xuICAgIGlmIChpbmxpbmVUZW1wbGF0ZSkge1xuICAgICAgZGF0YSArPSBpbmxpbmVUZW1wbGF0ZSArIFwiLFwiO1xuICAgIH1cbiAgfVxuICBkYXRhID0gZGF0YS5yZXBsYWNlKC8sJC8sICcnKSArICd9JztcbiAgLy8gdi1iaW5kIGRhdGEgd3JhcFxuICBpZiAoZWwud3JhcERhdGEpIHtcbiAgICBkYXRhID0gZWwud3JhcERhdGEoZGF0YSk7XG4gIH1cbiAgLy8gdi1vbiBkYXRhIHdyYXBcbiAgaWYgKGVsLndyYXBMaXN0ZW5lcnMpIHtcbiAgICBkYXRhID0gZWwud3JhcExpc3RlbmVycyhkYXRhKTtcbiAgfVxuICByZXR1cm4gZGF0YTtcbn1cblxuZnVuY3Rpb24gZ2VuRGlyZWN0aXZlcyhlbCwgc3RhdGUpIHtcbiAgdmFyIGRpcnMgPSBlbC5kaXJlY3RpdmVzO1xuICBpZiAoIWRpcnMpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIHJlcyA9ICdkaXJlY3RpdmVzOlsnO1xuICB2YXIgaGFzUnVudGltZSA9IGZhbHNlO1xuICB2YXIgaSwgbCwgZGlyLCBuZWVkUnVudGltZTtcbiAgZm9yIChpID0gMCwgbCA9IGRpcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgZGlyID0gZGlyc1tpXTtcbiAgICBuZWVkUnVudGltZSA9IHRydWU7XG4gICAgdmFyIGdlbiA9IHN0YXRlLmRpcmVjdGl2ZXNbZGlyLm5hbWVdO1xuICAgIGlmIChnZW4pIHtcbiAgICAgIC8vIGNvbXBpbGUtdGltZSBkaXJlY3RpdmUgdGhhdCBtYW5pcHVsYXRlcyBBU1QuXG4gICAgICAvLyByZXR1cm5zIHRydWUgaWYgaXQgYWxzbyBuZWVkcyBhIHJ1bnRpbWUgY291bnRlcnBhcnQuXG4gICAgICBuZWVkUnVudGltZSA9ICEhZ2VuKGVsLCBkaXIsIHN0YXRlLndhcm4pO1xuICAgIH1cbiAgICBpZiAobmVlZFJ1bnRpbWUpIHtcbiAgICAgIGhhc1J1bnRpbWUgPSB0cnVlO1xuICAgICAgcmVzICs9IFwie25hbWU6XFxcIlwiICsgZGlyLm5hbWUgKyBcIlxcXCIscmF3TmFtZTpcXFwiXCIgKyBkaXIucmF3TmFtZSArIFwiXFxcIlwiICsgKGRpci52YWx1ZSA/IFwiLHZhbHVlOihcIiArIGRpci52YWx1ZSArIFwiKSxleHByZXNzaW9uOlwiICsgSlNPTi5zdHJpbmdpZnkoZGlyLnZhbHVlKSA6ICcnKSArIChkaXIuYXJnID8gXCIsYXJnOlxcXCJcIiArIGRpci5hcmcgKyBcIlxcXCJcIiA6ICcnKSArIChkaXIubW9kaWZpZXJzID8gXCIsbW9kaWZpZXJzOlwiICsgSlNPTi5zdHJpbmdpZnkoZGlyLm1vZGlmaWVycykgOiAnJykgKyBcIn0sXCI7XG4gICAgfVxuICB9XG4gIGlmIChoYXNSdW50aW1lKSB7XG4gICAgcmV0dXJuIHJlcy5zbGljZSgwLCAtMSkgKyAnXSc7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuSW5saW5lVGVtcGxhdGUoZWwsIHN0YXRlKSB7XG4gIHZhciBhc3QgPSBlbC5jaGlsZHJlblswXTtcbiAgaWYgKGZhbHNlKSB7XG4gICAgc3RhdGUud2FybignSW5saW5lLXRlbXBsYXRlIGNvbXBvbmVudHMgbXVzdCBoYXZlIGV4YWN0bHkgb25lIGNoaWxkIGVsZW1lbnQuJyk7XG4gIH1cbiAgaWYgKGFzdC50eXBlID09PSAxKSB7XG4gICAgdmFyIGlubGluZVJlbmRlckZucyA9IGdlbmVyYXRlKGFzdCwgc3RhdGUub3B0aW9ucyk7XG4gICAgcmV0dXJuIFwiaW5saW5lVGVtcGxhdGU6e3JlbmRlcjpmdW5jdGlvbigpe1wiICsgaW5saW5lUmVuZGVyRm5zLnJlbmRlciArIFwifSxzdGF0aWNSZW5kZXJGbnM6W1wiICsgaW5saW5lUmVuZGVyRm5zLnN0YXRpY1JlbmRlckZucy5tYXAoZnVuY3Rpb24gKGNvZGUpIHtcbiAgICAgIHJldHVybiBcImZ1bmN0aW9uKCl7XCIgKyBjb2RlICsgXCJ9XCI7XG4gICAgfSkuam9pbignLCcpICsgXCJdfVwiO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdlblNjb3BlZFNsb3RzKHNsb3RzLCBzdGF0ZSkge1xuICByZXR1cm4gXCJzY29wZWRTbG90czpfdShbXCIgKyBPYmplY3Qua2V5cyhzbG90cykubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gZ2VuU2NvcGVkU2xvdChrZXksIHNsb3RzW2tleV0sIHN0YXRlKTtcbiAgfSkuam9pbignLCcpICsgXCJdKVwiO1xufVxuXG5mdW5jdGlvbiBnZW5TY29wZWRTbG90KGtleSwgZWwsIHN0YXRlKSB7XG4gIGlmIChlbC5mb3IgJiYgIWVsLmZvclByb2Nlc3NlZCkge1xuICAgIHJldHVybiBnZW5Gb3JTY29wZWRTbG90KGtleSwgZWwsIHN0YXRlKTtcbiAgfVxuICByZXR1cm4gXCJ7a2V5OlwiICsga2V5ICsgXCIsZm46ZnVuY3Rpb24oXCIgKyBTdHJpbmcoZWwuYXR0cnNNYXAuc2NvcGUpICsgXCIpe1wiICsgXCJyZXR1cm4gXCIgKyAoZWwudGFnID09PSAndGVtcGxhdGUnID8gZ2VuQ2hpbGRyZW4oZWwsIHN0YXRlKSB8fCAndm9pZCAwJyA6IGdlbkVsZW1lbnQoZWwsIHN0YXRlKSkgKyBcIn19XCI7XG59XG5cbmZ1bmN0aW9uIGdlbkZvclNjb3BlZFNsb3Qoa2V5LCBlbCwgc3RhdGUpIHtcbiAgdmFyIGV4cCA9IGVsLmZvcjtcbiAgdmFyIGFsaWFzID0gZWwuYWxpYXM7XG4gIHZhciBpdGVyYXRvcjEgPSBlbC5pdGVyYXRvcjEgPyBcIixcIiArIGVsLml0ZXJhdG9yMSA6ICcnO1xuICB2YXIgaXRlcmF0b3IyID0gZWwuaXRlcmF0b3IyID8gXCIsXCIgKyBlbC5pdGVyYXRvcjIgOiAnJztcbiAgZWwuZm9yUHJvY2Vzc2VkID0gdHJ1ZTsgLy8gYXZvaWQgcmVjdXJzaW9uXG4gIHJldHVybiBcIl9sKChcIiArIGV4cCArIFwiKSxcIiArIFwiZnVuY3Rpb24oXCIgKyBhbGlhcyArIGl0ZXJhdG9yMSArIGl0ZXJhdG9yMiArIFwiKXtcIiArIFwicmV0dXJuIFwiICsgZ2VuU2NvcGVkU2xvdChrZXksIGVsLCBzdGF0ZSkgKyAnfSknO1xufVxuXG5mdW5jdGlvbiBnZW5DaGlsZHJlbihlbCwgc3RhdGUsIGNoZWNrU2tpcCwgYWx0R2VuRWxlbWVudCwgYWx0R2VuTm9kZSkge1xuICB2YXIgY2hpbGRyZW4gPSBlbC5jaGlsZHJlbjtcbiAgaWYgKGNoaWxkcmVuLmxlbmd0aCkge1xuICAgIHZhciBlbCQxID0gY2hpbGRyZW5bMF07XG4gICAgLy8gb3B0aW1pemUgc2luZ2xlIHYtZm9yXG4gICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJiBlbCQxLmZvciAmJiBlbCQxLnRhZyAhPT0gJ3RlbXBsYXRlJyAmJiBlbCQxLnRhZyAhPT0gJ3Nsb3QnKSB7XG4gICAgICByZXR1cm4gKGFsdEdlbkVsZW1lbnQgfHwgZ2VuRWxlbWVudCkoZWwkMSwgc3RhdGUpO1xuICAgIH1cbiAgICB2YXIgbm9ybWFsaXphdGlvblR5cGUgPSBjaGVja1NraXAgPyBnZXROb3JtYWxpemF0aW9uVHlwZShjaGlsZHJlbiwgc3RhdGUubWF5YmVDb21wb25lbnQpIDogMDtcbiAgICB2YXIgZ2VuID0gYWx0R2VuTm9kZSB8fCBnZW5Ob2RlO1xuICAgIHJldHVybiBcIltcIiArIGNoaWxkcmVuLm1hcChmdW5jdGlvbiAoYykge1xuICAgICAgcmV0dXJuIGdlbihjLCBzdGF0ZSk7XG4gICAgfSkuam9pbignLCcpICsgXCJdXCIgKyAobm9ybWFsaXphdGlvblR5cGUgPyBcIixcIiArIG5vcm1hbGl6YXRpb25UeXBlIDogJycpO1xuICB9XG59XG5cbi8vIGRldGVybWluZSB0aGUgbm9ybWFsaXphdGlvbiBuZWVkZWQgZm9yIHRoZSBjaGlsZHJlbiBhcnJheS5cbi8vIDA6IG5vIG5vcm1hbGl6YXRpb24gbmVlZGVkXG4vLyAxOiBzaW1wbGUgbm9ybWFsaXphdGlvbiBuZWVkZWQgKHBvc3NpYmxlIDEtbGV2ZWwgZGVlcCBuZXN0ZWQgYXJyYXkpXG4vLyAyOiBmdWxsIG5vcm1hbGl6YXRpb24gbmVlZGVkXG5mdW5jdGlvbiBnZXROb3JtYWxpemF0aW9uVHlwZShjaGlsZHJlbiwgbWF5YmVDb21wb25lbnQpIHtcbiAgdmFyIHJlcyA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZWwgPSBjaGlsZHJlbltpXTtcbiAgICBpZiAoZWwudHlwZSAhPT0gMSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChuZWVkc05vcm1hbGl6YXRpb24oZWwpIHx8IGVsLmlmQ29uZGl0aW9ucyAmJiBlbC5pZkNvbmRpdGlvbnMuc29tZShmdW5jdGlvbiAoYykge1xuICAgICAgcmV0dXJuIG5lZWRzTm9ybWFsaXphdGlvbihjLmJsb2NrKTtcbiAgICB9KSkge1xuICAgICAgcmVzID0gMjtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZiAobWF5YmVDb21wb25lbnQoZWwpIHx8IGVsLmlmQ29uZGl0aW9ucyAmJiBlbC5pZkNvbmRpdGlvbnMuc29tZShmdW5jdGlvbiAoYykge1xuICAgICAgcmV0dXJuIG1heWJlQ29tcG9uZW50KGMuYmxvY2spO1xuICAgIH0pKSB7XG4gICAgICByZXMgPSAxO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzO1xufVxuXG5mdW5jdGlvbiBuZWVkc05vcm1hbGl6YXRpb24oZWwpIHtcbiAgcmV0dXJuIGVsLmZvciAhPT0gdW5kZWZpbmVkIHx8IGVsLnRhZyA9PT0gJ3RlbXBsYXRlJyB8fCBlbC50YWcgPT09ICdzbG90Jztcbn1cblxuZnVuY3Rpb24gZ2VuTm9kZShub2RlLCBzdGF0ZSkge1xuICBpZiAobm9kZS50eXBlID09PSAxKSB7XG4gICAgcmV0dXJuIGdlbkVsZW1lbnQobm9kZSwgc3RhdGUpO1xuICB9aWYgKG5vZGUudHlwZSA9PT0gMyAmJiBub2RlLmlzQ29tbWVudCkge1xuICAgIHJldHVybiBnZW5Db21tZW50KG5vZGUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBnZW5UZXh0KG5vZGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdlblRleHQodGV4dCkge1xuICByZXR1cm4gXCJfdihcIiArICh0ZXh0LnR5cGUgPT09IDIgPyB0ZXh0LmV4cHJlc3Npb24gLy8gbm8gbmVlZCBmb3IgKCkgYmVjYXVzZSBhbHJlYWR5IHdyYXBwZWQgaW4gX3MoKVxuICA6IHRyYW5zZm9ybVNwZWNpYWxOZXdsaW5lcyhKU09OLnN0cmluZ2lmeSh0ZXh0LnRleHQpKSkgKyBcIilcIjtcbn1cblxuZnVuY3Rpb24gZ2VuQ29tbWVudChjb21tZW50KSB7XG4gIHJldHVybiBcIl9lKFwiICsgSlNPTi5zdHJpbmdpZnkoY29tbWVudC50ZXh0KSArIFwiKVwiO1xufVxuXG5mdW5jdGlvbiBnZW5TbG90KGVsLCBzdGF0ZSkge1xuICB2YXIgc2xvdE5hbWUgPSBlbC5zbG90TmFtZSB8fCAnXCJkZWZhdWx0XCInO1xuICB2YXIgY2hpbGRyZW4gPSBnZW5DaGlsZHJlbihlbCwgc3RhdGUpO1xuICB2YXIgcmVzID0gXCJfdChcIiArIHNsb3ROYW1lICsgKGNoaWxkcmVuID8gXCIsXCIgKyBjaGlsZHJlbiA6ICcnKTtcbiAgdmFyIGF0dHJzID0gZWwuYXR0cnMgJiYgXCJ7XCIgKyBlbC5hdHRycy5tYXAoZnVuY3Rpb24gKGEpIHtcbiAgICByZXR1cm4gY2FtZWxpemUoYS5uYW1lKSArIFwiOlwiICsgYS52YWx1ZTtcbiAgfSkuam9pbignLCcpICsgXCJ9XCI7XG4gIHZhciBiaW5kJCQxID0gZWwuYXR0cnNNYXBbJ3YtYmluZCddO1xuICBpZiAoKGF0dHJzIHx8IGJpbmQkJDEpICYmICFjaGlsZHJlbikge1xuICAgIHJlcyArPSBcIixudWxsXCI7XG4gIH1cbiAgaWYgKGF0dHJzKSB7XG4gICAgcmVzICs9IFwiLFwiICsgYXR0cnM7XG4gIH1cbiAgaWYgKGJpbmQkJDEpIHtcbiAgICByZXMgKz0gKGF0dHJzID8gJycgOiAnLG51bGwnKSArIFwiLFwiICsgYmluZCQkMTtcbiAgfVxuICByZXR1cm4gcmVzICsgJyknO1xufVxuXG4vLyBjb21wb25lbnROYW1lIGlzIGVsLmNvbXBvbmVudCwgdGFrZSBpdCBhcyBhcmd1bWVudCB0byBzaHVuIGZsb3cncyBwZXNzaW1pc3RpYyByZWZpbmVtZW50XG5mdW5jdGlvbiBnZW5Db21wb25lbnQoY29tcG9uZW50TmFtZSwgZWwsIHN0YXRlKSB7XG4gIHZhciBjaGlsZHJlbiA9IGVsLmlubGluZVRlbXBsYXRlID8gbnVsbCA6IGdlbkNoaWxkcmVuKGVsLCBzdGF0ZSwgdHJ1ZSk7XG4gIHJldHVybiBcIl9jKFwiICsgY29tcG9uZW50TmFtZSArIFwiLFwiICsgZ2VuRGF0YSQyKGVsLCBzdGF0ZSkgKyAoY2hpbGRyZW4gPyBcIixcIiArIGNoaWxkcmVuIDogJycpICsgXCIpXCI7XG59XG5cbmZ1bmN0aW9uIGdlblByb3BzKHByb3BzKSB7XG4gIHZhciByZXMgPSAnJztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwcm9wID0gcHJvcHNbaV07XG4gICAgcmVzICs9IFwiXFxcIlwiICsgcHJvcC5uYW1lICsgXCJcXFwiOlwiICsgdHJhbnNmb3JtU3BlY2lhbE5ld2xpbmVzKHByb3AudmFsdWUpICsgXCIsXCI7XG4gIH1cbiAgcmV0dXJuIHJlcy5zbGljZSgwLCAtMSk7XG59XG5cbi8vICMzODk1LCAjNDI2OFxuZnVuY3Rpb24gdHJhbnNmb3JtU3BlY2lhbE5ld2xpbmVzKHRleHQpIHtcbiAgcmV0dXJuIHRleHQucmVwbGFjZSgvXFx1MjAyOC9nLCAnXFxcXHUyMDI4JykucmVwbGFjZSgvXFx1MjAyOS9nLCAnXFxcXHUyMDI5Jyk7XG59XG5cbi8qICAqL1xuXG4vLyB0aGVzZSBrZXl3b3JkcyBzaG91bGQgbm90IGFwcGVhciBpbnNpZGUgZXhwcmVzc2lvbnMsIGJ1dCBvcGVyYXRvcnMgbGlrZVxuLy8gdHlwZW9mLCBpbnN0YW5jZW9mIGFuZCBpbiBhcmUgYWxsb3dlZFxudmFyIHByb2hpYml0ZWRLZXl3b3JkUkUgPSBuZXcgUmVnRXhwKCdcXFxcYicgKyAoJ2RvLGlmLGZvcixsZXQsbmV3LHRyeSx2YXIsY2FzZSxlbHNlLHdpdGgsYXdhaXQsYnJlYWssY2F0Y2gsY2xhc3MsY29uc3QsJyArICdzdXBlcix0aHJvdyx3aGlsZSx5aWVsZCxkZWxldGUsZXhwb3J0LGltcG9ydCxyZXR1cm4sc3dpdGNoLGRlZmF1bHQsJyArICdleHRlbmRzLGZpbmFsbHksY29udGludWUsZGVidWdnZXIsZnVuY3Rpb24sYXJndW1lbnRzJykuc3BsaXQoJywnKS5qb2luKCdcXFxcYnxcXFxcYicpICsgJ1xcXFxiJyk7XG5cbi8vIHRoZXNlIHVuYXJ5IG9wZXJhdG9ycyBzaG91bGQgbm90IGJlIHVzZWQgYXMgcHJvcGVydHkvbWV0aG9kIG5hbWVzXG52YXIgdW5hcnlPcGVyYXRvcnNSRSA9IG5ldyBSZWdFeHAoJ1xcXFxiJyArICdkZWxldGUsdHlwZW9mLHZvaWQnLnNwbGl0KCcsJykuam9pbignXFxcXHMqXFxcXChbXlxcXFwpXSpcXFxcKXxcXFxcYicpICsgJ1xcXFxzKlxcXFwoW15cXFxcKV0qXFxcXCknKTtcblxuLy8gY2hlY2sgdmFsaWQgaWRlbnRpZmllciBmb3Igdi1mb3JcbnZhciBpZGVudFJFID0gL1tBLVphLXpfJF1bXFx3JF0qLztcblxuLy8gc3RyaXAgc3RyaW5ncyBpbiBleHByZXNzaW9uc1xudmFyIHN0cmlwU3RyaW5nUkUgPSAvJyg/OlteJ1xcXFxdfFxcXFwuKSonfFwiKD86W15cIlxcXFxdfFxcXFwuKSpcInxgKD86W15gXFxcXF18XFxcXC4pKlxcJFxce3xcXH0oPzpbXmBcXFxcXXxcXFxcLikqYHxgKD86W15gXFxcXF18XFxcXC4pKmAvZztcblxuLy8gZGV0ZWN0IHByb2JsZW1hdGljIGV4cHJlc3Npb25zIGluIGEgdGVtcGxhdGVcbmZ1bmN0aW9uIGRldGVjdEVycm9ycyhhc3QpIHtcbiAgdmFyIGVycm9ycyA9IFtdO1xuICBpZiAoYXN0KSB7XG4gICAgY2hlY2tOb2RlKGFzdCwgZXJyb3JzKTtcbiAgfVxuICByZXR1cm4gZXJyb3JzO1xufVxuXG5mdW5jdGlvbiBjaGVja05vZGUobm9kZSwgZXJyb3JzKSB7XG4gIGlmIChub2RlLnR5cGUgPT09IDEpIHtcbiAgICBmb3IgKHZhciBuYW1lIGluIG5vZGUuYXR0cnNNYXApIHtcbiAgICAgIGlmIChkaXJSRS50ZXN0KG5hbWUpKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IG5vZGUuYXR0cnNNYXBbbmFtZV07XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgIGlmIChuYW1lID09PSAndi1mb3InKSB7XG4gICAgICAgICAgICBjaGVja0Zvcihub2RlLCBcInYtZm9yPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiXCIsIGVycm9ycyk7XG4gICAgICAgICAgfSBlbHNlIGlmIChvblJFLnRlc3QobmFtZSkpIHtcbiAgICAgICAgICAgIGNoZWNrRXZlbnQodmFsdWUsIG5hbWUgKyBcIj1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIlwiLCBlcnJvcnMpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjaGVja0V4cHJlc3Npb24odmFsdWUsIG5hbWUgKyBcIj1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIlwiLCBlcnJvcnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAobm9kZS5jaGlsZHJlbikge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNoZWNrTm9kZShub2RlLmNoaWxkcmVuW2ldLCBlcnJvcnMpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChub2RlLnR5cGUgPT09IDIpIHtcbiAgICBjaGVja0V4cHJlc3Npb24obm9kZS5leHByZXNzaW9uLCBub2RlLnRleHQsIGVycm9ycyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tFdmVudChleHAsIHRleHQsIGVycm9ycykge1xuICB2YXIgc3RpcHBlZCA9IGV4cC5yZXBsYWNlKHN0cmlwU3RyaW5nUkUsICcnKTtcbiAgdmFyIGtleXdvcmRNYXRjaCA9IHN0aXBwZWQubWF0Y2godW5hcnlPcGVyYXRvcnNSRSk7XG4gIGlmIChrZXl3b3JkTWF0Y2ggJiYgc3RpcHBlZC5jaGFyQXQoa2V5d29yZE1hdGNoLmluZGV4IC0gMSkgIT09ICckJykge1xuICAgIGVycm9ycy5wdXNoKFwiYXZvaWQgdXNpbmcgSmF2YVNjcmlwdCB1bmFyeSBvcGVyYXRvciBhcyBwcm9wZXJ0eSBuYW1lOiBcIiArIFwiXFxcIlwiICsga2V5d29yZE1hdGNoWzBdICsgXCJcXFwiIGluIGV4cHJlc3Npb24gXCIgKyB0ZXh0LnRyaW0oKSk7XG4gIH1cbiAgY2hlY2tFeHByZXNzaW9uKGV4cCwgdGV4dCwgZXJyb3JzKTtcbn1cblxuZnVuY3Rpb24gY2hlY2tGb3Iobm9kZSwgdGV4dCwgZXJyb3JzKSB7XG4gIGNoZWNrRXhwcmVzc2lvbihub2RlLmZvciB8fCAnJywgdGV4dCwgZXJyb3JzKTtcbiAgY2hlY2tJZGVudGlmaWVyKG5vZGUuYWxpYXMsICd2LWZvciBhbGlhcycsIHRleHQsIGVycm9ycyk7XG4gIGNoZWNrSWRlbnRpZmllcihub2RlLml0ZXJhdG9yMSwgJ3YtZm9yIGl0ZXJhdG9yJywgdGV4dCwgZXJyb3JzKTtcbiAgY2hlY2tJZGVudGlmaWVyKG5vZGUuaXRlcmF0b3IyLCAndi1mb3IgaXRlcmF0b3InLCB0ZXh0LCBlcnJvcnMpO1xufVxuXG5mdW5jdGlvbiBjaGVja0lkZW50aWZpZXIoaWRlbnQsIHR5cGUsIHRleHQsIGVycm9ycykge1xuICBpZiAodHlwZW9mIGlkZW50ID09PSAnc3RyaW5nJyAmJiAhaWRlbnRSRS50ZXN0KGlkZW50KSkge1xuICAgIGVycm9ycy5wdXNoKFwiaW52YWxpZCBcIiArIHR5cGUgKyBcIiBcXFwiXCIgKyBpZGVudCArIFwiXFxcIiBpbiBleHByZXNzaW9uOiBcIiArIHRleHQudHJpbSgpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja0V4cHJlc3Npb24oZXhwLCB0ZXh0LCBlcnJvcnMpIHtcbiAgdHJ5IHtcbiAgICBuZXcgRnVuY3Rpb24oXCJyZXR1cm4gXCIgKyBleHApO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdmFyIGtleXdvcmRNYXRjaCA9IGV4cC5yZXBsYWNlKHN0cmlwU3RyaW5nUkUsICcnKS5tYXRjaChwcm9oaWJpdGVkS2V5d29yZFJFKTtcbiAgICBpZiAoa2V5d29yZE1hdGNoKSB7XG4gICAgICBlcnJvcnMucHVzaChcImF2b2lkIHVzaW5nIEphdmFTY3JpcHQga2V5d29yZCBhcyBwcm9wZXJ0eSBuYW1lOiBcIiArIFwiXFxcIlwiICsga2V5d29yZE1hdGNoWzBdICsgXCJcXFwiIGluIGV4cHJlc3Npb24gXCIgKyB0ZXh0LnRyaW0oKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVycm9ycy5wdXNoKFwiaW52YWxpZCBleHByZXNzaW9uOiBcIiArIHRleHQudHJpbSgpKTtcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGNyZWF0ZUZ1bmN0aW9uKGNvZGUsIGVycm9ycykge1xuICB0cnkge1xuICAgIHJldHVybiBuZXcgRnVuY3Rpb24oY29kZSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGVycm9ycy5wdXNoKHsgZXJyOiBlcnIsIGNvZGU6IGNvZGUgfSk7XG4gICAgcmV0dXJuIG5vb3A7XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29tcGlsZVRvRnVuY3Rpb25Gbihjb21waWxlKSB7XG4gIHZhciBjYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIGNvbXBpbGVUb0Z1bmN0aW9ucyh0ZW1wbGF0ZSwgb3B0aW9ucywgdm0pIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChmYWxzZSkge1xuICAgICAgLy8gZGV0ZWN0IHBvc3NpYmxlIENTUCByZXN0cmljdGlvblxuICAgICAgdHJ5IHtcbiAgICAgICAgbmV3IEZ1bmN0aW9uKCdyZXR1cm4gMScpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoZS50b1N0cmluZygpLm1hdGNoKC91bnNhZmUtZXZhbHxDU1AvKSkge1xuICAgICAgICAgIHdhcm4oJ0l0IHNlZW1zIHlvdSBhcmUgdXNpbmcgdGhlIHN0YW5kYWxvbmUgYnVpbGQgb2YgVnVlLmpzIGluIGFuICcgKyAnZW52aXJvbm1lbnQgd2l0aCBDb250ZW50IFNlY3VyaXR5IFBvbGljeSB0aGF0IHByb2hpYml0cyB1bnNhZmUtZXZhbC4gJyArICdUaGUgdGVtcGxhdGUgY29tcGlsZXIgY2Fubm90IHdvcmsgaW4gdGhpcyBlbnZpcm9ubWVudC4gQ29uc2lkZXIgJyArICdyZWxheGluZyB0aGUgcG9saWN5IHRvIGFsbG93IHVuc2FmZS1ldmFsIG9yIHByZS1jb21waWxpbmcgeW91ciAnICsgJ3RlbXBsYXRlcyBpbnRvIHJlbmRlciBmdW5jdGlvbnMuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBjaGVjayBjYWNoZVxuICAgIHZhciBrZXkgPSBvcHRpb25zLmRlbGltaXRlcnMgPyBTdHJpbmcob3B0aW9ucy5kZWxpbWl0ZXJzKSArIHRlbXBsYXRlIDogdGVtcGxhdGU7XG4gICAgaWYgKGNhY2hlW2tleV0pIHtcbiAgICAgIHJldHVybiBjYWNoZVtrZXldO1xuICAgIH1cblxuICAgIC8vIGNvbXBpbGVcbiAgICB2YXIgY29tcGlsZWQgPSBjb21waWxlKHRlbXBsYXRlLCBvcHRpb25zKTtcblxuICAgIC8vIGNoZWNrIGNvbXBpbGF0aW9uIGVycm9ycy90aXBzXG4gICAgaWYgKGZhbHNlKSB7XG4gICAgICBpZiAoY29tcGlsZWQuZXJyb3JzICYmIGNvbXBpbGVkLmVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgd2FybihcIkVycm9yIGNvbXBpbGluZyB0ZW1wbGF0ZTpcXG5cXG5cIiArIHRlbXBsYXRlICsgXCJcXG5cXG5cIiArIGNvbXBpbGVkLmVycm9ycy5tYXAoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICByZXR1cm4gXCItIFwiICsgZTtcbiAgICAgICAgfSkuam9pbignXFxuJykgKyAnXFxuJywgdm0pO1xuICAgICAgfVxuICAgICAgaWYgKGNvbXBpbGVkLnRpcHMgJiYgY29tcGlsZWQudGlwcy5sZW5ndGgpIHtcbiAgICAgICAgY29tcGlsZWQudGlwcy5mb3JFYWNoKGZ1bmN0aW9uIChtc2cpIHtcbiAgICAgICAgICByZXR1cm4gdGlwKG1zZywgdm0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyB0dXJuIGNvZGUgaW50byBmdW5jdGlvbnNcbiAgICB2YXIgcmVzID0ge307XG4gICAgdmFyIGZuR2VuRXJyb3JzID0gW107XG4gICAgcmVzLnJlbmRlciA9IGNyZWF0ZUZ1bmN0aW9uKGNvbXBpbGVkLnJlbmRlciwgZm5HZW5FcnJvcnMpO1xuICAgIHJlcy5zdGF0aWNSZW5kZXJGbnMgPSBjb21waWxlZC5zdGF0aWNSZW5kZXJGbnMubWFwKGZ1bmN0aW9uIChjb2RlKSB7XG4gICAgICByZXR1cm4gY3JlYXRlRnVuY3Rpb24oY29kZSwgZm5HZW5FcnJvcnMpO1xuICAgIH0pO1xuXG4gICAgLy8gY2hlY2sgZnVuY3Rpb24gZ2VuZXJhdGlvbiBlcnJvcnMuXG4gICAgLy8gdGhpcyBzaG91bGQgb25seSBoYXBwZW4gaWYgdGhlcmUgaXMgYSBidWcgaW4gdGhlIGNvbXBpbGVyIGl0c2VsZi5cbiAgICAvLyBtb3N0bHkgZm9yIGNvZGVnZW4gZGV2ZWxvcG1lbnQgdXNlXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGZhbHNlKSB7XG4gICAgICBpZiAoKCFjb21waWxlZC5lcnJvcnMgfHwgIWNvbXBpbGVkLmVycm9ycy5sZW5ndGgpICYmIGZuR2VuRXJyb3JzLmxlbmd0aCkge1xuICAgICAgICB3YXJuKFwiRmFpbGVkIHRvIGdlbmVyYXRlIHJlbmRlciBmdW5jdGlvbjpcXG5cXG5cIiArIGZuR2VuRXJyb3JzLm1hcChmdW5jdGlvbiAocmVmKSB7XG4gICAgICAgICAgdmFyIGVyciA9IHJlZi5lcnI7XG4gICAgICAgICAgdmFyIGNvZGUgPSByZWYuY29kZTtcblxuICAgICAgICAgIHJldHVybiBlcnIudG9TdHJpbmcoKSArIFwiIGluXFxuXFxuXCIgKyBjb2RlICsgXCJcXG5cIjtcbiAgICAgICAgfSkuam9pbignXFxuJyksIHZtKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY2FjaGVba2V5XSA9IHJlcztcbiAgfTtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbXBpbGVyQ3JlYXRvcihiYXNlQ29tcGlsZSkge1xuICByZXR1cm4gZnVuY3Rpb24gY3JlYXRlQ29tcGlsZXIoYmFzZU9wdGlvbnMpIHtcbiAgICBmdW5jdGlvbiBjb21waWxlKHRlbXBsYXRlLCBvcHRpb25zKSB7XG4gICAgICB2YXIgZmluYWxPcHRpb25zID0gT2JqZWN0LmNyZWF0ZShiYXNlT3B0aW9ucyk7XG4gICAgICB2YXIgZXJyb3JzID0gW107XG4gICAgICB2YXIgdGlwcyA9IFtdO1xuICAgICAgZmluYWxPcHRpb25zLndhcm4gPSBmdW5jdGlvbiAobXNnLCB0aXApIHtcbiAgICAgICAgKHRpcCA/IHRpcHMgOiBlcnJvcnMpLnB1c2gobXNnKTtcbiAgICAgIH07XG5cbiAgICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgIC8vIG1lcmdlIGN1c3RvbSBtb2R1bGVzXG4gICAgICAgIGlmIChvcHRpb25zLm1vZHVsZXMpIHtcbiAgICAgICAgICBmaW5hbE9wdGlvbnMubW9kdWxlcyA9IChiYXNlT3B0aW9ucy5tb2R1bGVzIHx8IFtdKS5jb25jYXQob3B0aW9ucy5tb2R1bGVzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBtZXJnZSBjdXN0b20gZGlyZWN0aXZlc1xuICAgICAgICBpZiAob3B0aW9ucy5kaXJlY3RpdmVzKSB7XG4gICAgICAgICAgZmluYWxPcHRpb25zLmRpcmVjdGl2ZXMgPSBleHRlbmQoT2JqZWN0LmNyZWF0ZShiYXNlT3B0aW9ucy5kaXJlY3RpdmVzKSwgb3B0aW9ucy5kaXJlY3RpdmVzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjb3B5IG90aGVyIG9wdGlvbnNcbiAgICAgICAgZm9yICh2YXIga2V5IGluIG9wdGlvbnMpIHtcbiAgICAgICAgICBpZiAoa2V5ICE9PSAnbW9kdWxlcycgJiYga2V5ICE9PSAnZGlyZWN0aXZlcycpIHtcbiAgICAgICAgICAgIGZpbmFsT3B0aW9uc1trZXldID0gb3B0aW9uc1trZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgY29tcGlsZWQgPSBiYXNlQ29tcGlsZSh0ZW1wbGF0ZSwgZmluYWxPcHRpb25zKTtcbiAgICAgIGlmIChmYWxzZSkge1xuICAgICAgICBlcnJvcnMucHVzaC5hcHBseShlcnJvcnMsIGRldGVjdEVycm9ycyhjb21waWxlZC5hc3QpKTtcbiAgICAgIH1cbiAgICAgIGNvbXBpbGVkLmVycm9ycyA9IGVycm9ycztcbiAgICAgIGNvbXBpbGVkLnRpcHMgPSB0aXBzO1xuICAgICAgcmV0dXJuIGNvbXBpbGVkO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBjb21waWxlOiBjb21waWxlLFxuICAgICAgY29tcGlsZVRvRnVuY3Rpb25zOiBjcmVhdGVDb21waWxlVG9GdW5jdGlvbkZuKGNvbXBpbGUpXG4gICAgfTtcbiAgfTtcbn1cblxuLyogICovXG5cbi8vIGBjcmVhdGVDb21waWxlckNyZWF0b3JgIGFsbG93cyBjcmVhdGluZyBjb21waWxlcnMgdGhhdCB1c2UgYWx0ZXJuYXRpdmVcbi8vIHBhcnNlci9vcHRpbWl6ZXIvY29kZWdlbiwgZS5nIHRoZSBTU1Igb3B0aW1pemluZyBjb21waWxlci5cbi8vIEhlcmUgd2UganVzdCBleHBvcnQgYSBkZWZhdWx0IGNvbXBpbGVyIHVzaW5nIHRoZSBkZWZhdWx0IHBhcnRzLlxudmFyIGNyZWF0ZUNvbXBpbGVyID0gY3JlYXRlQ29tcGlsZXJDcmVhdG9yKGZ1bmN0aW9uIGJhc2VDb21waWxlKHRlbXBsYXRlLCBvcHRpb25zKSB7XG4gIHZhciBhc3QgPSBwYXJzZSh0ZW1wbGF0ZS50cmltKCksIG9wdGlvbnMpO1xuICBvcHRpbWl6ZShhc3QsIG9wdGlvbnMpO1xuICB2YXIgY29kZSA9IGdlbmVyYXRlKGFzdCwgb3B0aW9ucyk7XG4gIHJldHVybiB7XG4gICAgYXN0OiBhc3QsXG4gICAgcmVuZGVyOiBjb2RlLnJlbmRlcixcbiAgICBzdGF0aWNSZW5kZXJGbnM6IGNvZGUuc3RhdGljUmVuZGVyRm5zXG4gIH07XG59KTtcblxuLyogICovXG5cbnZhciByZWYkMSA9IGNyZWF0ZUNvbXBpbGVyKGJhc2VPcHRpb25zKTtcbnZhciBjb21waWxlVG9GdW5jdGlvbnMgPSByZWYkMS5jb21waWxlVG9GdW5jdGlvbnM7XG5cbi8qICAqL1xuXG52YXIgaWRUb1RlbXBsYXRlID0gY2FjaGVkKGZ1bmN0aW9uIChpZCkge1xuICB2YXIgZWwgPSBxdWVyeShpZCk7XG4gIHJldHVybiBlbCAmJiBlbC5pbm5lckhUTUw7XG59KTtcblxudmFyIG1vdW50ID0gVnVlJDMucHJvdG90eXBlLiRtb3VudDtcblZ1ZSQzLnByb3RvdHlwZS4kbW91bnQgPSBmdW5jdGlvbiAoZWwsIGh5ZHJhdGluZykge1xuICBlbCA9IGVsICYmIHF1ZXJ5KGVsKTtcblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGVsID09PSBkb2N1bWVudC5ib2R5IHx8IGVsID09PSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpIHtcbiAgICBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXCJEbyBub3QgbW91bnQgVnVlIHRvIDxodG1sPiBvciA8Ym9keT4gLSBtb3VudCB0byBub3JtYWwgZWxlbWVudHMgaW5zdGVhZC5cIik7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICB2YXIgb3B0aW9ucyA9IHRoaXMuJG9wdGlvbnM7XG4gIC8vIHJlc29sdmUgdGVtcGxhdGUvZWwgYW5kIGNvbnZlcnQgdG8gcmVuZGVyIGZ1bmN0aW9uXG4gIGlmICghb3B0aW9ucy5yZW5kZXIpIHtcbiAgICB2YXIgdGVtcGxhdGUgPSBvcHRpb25zLnRlbXBsYXRlO1xuICAgIGlmICh0ZW1wbGF0ZSkge1xuICAgICAgaWYgKHR5cGVvZiB0ZW1wbGF0ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKHRlbXBsYXRlLmNoYXJBdCgwKSA9PT0gJyMnKSB7XG4gICAgICAgICAgdGVtcGxhdGUgPSBpZFRvVGVtcGxhdGUodGVtcGxhdGUpO1xuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgIGlmIChmYWxzZSkge1xuICAgICAgICAgICAgd2FybihcIlRlbXBsYXRlIGVsZW1lbnQgbm90IGZvdW5kIG9yIGlzIGVtcHR5OiBcIiArIG9wdGlvbnMudGVtcGxhdGUsIHRoaXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0ZW1wbGF0ZS5ub2RlVHlwZSkge1xuICAgICAgICB0ZW1wbGF0ZSA9IHRlbXBsYXRlLmlubmVySFRNTDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChmYWxzZSkge1xuICAgICAgICAgIHdhcm4oJ2ludmFsaWQgdGVtcGxhdGUgb3B0aW9uOicgKyB0ZW1wbGF0ZSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChlbCkge1xuICAgICAgdGVtcGxhdGUgPSBnZXRPdXRlckhUTUwoZWwpO1xuICAgIH1cbiAgICBpZiAodGVtcGxhdGUpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKGZhbHNlKSB7XG4gICAgICAgIG1hcmsoJ2NvbXBpbGUnKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlZiA9IGNvbXBpbGVUb0Z1bmN0aW9ucyh0ZW1wbGF0ZSwge1xuICAgICAgICBzaG91bGREZWNvZGVOZXdsaW5lczogc2hvdWxkRGVjb2RlTmV3bGluZXMsXG4gICAgICAgIGRlbGltaXRlcnM6IG9wdGlvbnMuZGVsaW1pdGVycyxcbiAgICAgICAgY29tbWVudHM6IG9wdGlvbnMuY29tbWVudHNcbiAgICAgIH0sIHRoaXMpO1xuICAgICAgdmFyIHJlbmRlciA9IHJlZi5yZW5kZXI7XG4gICAgICB2YXIgc3RhdGljUmVuZGVyRm5zID0gcmVmLnN0YXRpY1JlbmRlckZucztcbiAgICAgIG9wdGlvbnMucmVuZGVyID0gcmVuZGVyO1xuICAgICAgb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnMgPSBzdGF0aWNSZW5kZXJGbnM7XG5cbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKGZhbHNlKSB7XG4gICAgICAgIG1hcmsoJ2NvbXBpbGUgZW5kJyk7XG4gICAgICAgIG1lYXN1cmUodGhpcy5fbmFtZSArIFwiIGNvbXBpbGVcIiwgJ2NvbXBpbGUnLCAnY29tcGlsZSBlbmQnKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1vdW50LmNhbGwodGhpcywgZWwsIGh5ZHJhdGluZyk7XG59O1xuXG4vKipcbiAqIEdldCBvdXRlckhUTUwgb2YgZWxlbWVudHMsIHRha2luZyBjYXJlXG4gKiBvZiBTVkcgZWxlbWVudHMgaW4gSUUgYXMgd2VsbC5cbiAqL1xuZnVuY3Rpb24gZ2V0T3V0ZXJIVE1MKGVsKSB7XG4gIGlmIChlbC5vdXRlckhUTUwpIHtcbiAgICByZXR1cm4gZWwub3V0ZXJIVE1MO1xuICB9IGVsc2Uge1xuICAgIHZhciBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoZWwuY2xvbmVOb2RlKHRydWUpKTtcbiAgICByZXR1cm4gY29udGFpbmVyLmlubmVySFRNTDtcbiAgfVxufVxuXG5WdWUkMy5jb21waWxlID0gY29tcGlsZVRvRnVuY3Rpb25zO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFZ1ZSQzO1xuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18oMykpKVxuXG4vKioqLyB9KSxcbi8qIDYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAgKiB2dWUtY3VzdG9tLWVsZW1lbnQgdjEuMy4wXG4gICogKGMpIDIwMTcgS2Fyb2wgRmFiamHFhGN6dWtcbiAgKiBAbGljZW5zZSBNSVRcbiAgKi9cbi8qKlxuICogRVM2IE9iamVjdC5nZXRQcm90b3R5cGVPZiBQb2x5ZmlsbFxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L3NldFByb3RvdHlwZU9mXG4gKi9cblxuT2JqZWN0LnNldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IHNldFByb3RvdHlwZU9mO1xuXG5mdW5jdGlvbiBzZXRQcm90b3R5cGVPZihvYmosIHByb3RvKSB7XG4gIG9iai5fX3Byb3RvX18gPSBwcm90bztcbiAgcmV0dXJuIG9iajtcbn1cblxudmFyIGluZGV4ID0gc2V0UHJvdG90eXBlT2YuYmluZChPYmplY3QpO1xuXG5mdW5jdGlvbiBpc0VTMjAxNSgpIHtcbiAgaWYgKHR5cGVvZiBTeW1ib2wgPT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiBSZWZsZWN0ID09PSAndW5kZWZpbmVkJykgcmV0dXJuIGZhbHNlO1xuXG4gIHJldHVybiB0cnVlO1xufVxuXG52YXIgaXNFUzIwMTUkMSA9IGlzRVMyMDE1KCk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07ZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO2Rlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgICB9XG4gIH1yZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICAgIGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7aWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7cmV0dXJuIENvbnN0cnVjdG9yO1xuICB9O1xufSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7XG4gIGlmICghc2VsZikge1xuICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgfXJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmO1xufVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpO1xuICB9c3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTtpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7XG59XG5cbmZ1bmN0aW9uIF9DdXN0b21FbGVtZW50KCkge1xuICByZXR1cm4gUmVmbGVjdC5jb25zdHJ1Y3QoSFRNTEVsZW1lbnQsIFtdLCB0aGlzLl9fcHJvdG9fXy5jb25zdHJ1Y3Rvcik7XG59XG5cbk9iamVjdC5zZXRQcm90b3R5cGVPZihfQ3VzdG9tRWxlbWVudC5wcm90b3R5cGUsIEhUTUxFbGVtZW50LnByb3RvdHlwZSk7XG5PYmplY3Quc2V0UHJvdG90eXBlT2YoX0N1c3RvbUVsZW1lbnQsIEhUTUxFbGVtZW50KTtcbmZ1bmN0aW9uIHJlZ2lzdGVyQ3VzdG9tRWxlbWVudCh0YWcpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gIGlmICh0eXBlb2YgY3VzdG9tRWxlbWVudHMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZnVuY3Rpb24gY29uc3RydWN0b3JDYWxsYmFjaygpIHtcbiAgICBpZiAob3B0aW9ucy5zaGFkb3cgPT09IHRydWUgJiYgSFRNTEVsZW1lbnQucHJvdG90eXBlLmF0dGFjaFNoYWRvdykge1xuICAgICAgdGhpcy5hdHRhY2hTaGFkb3coeyBtb2RlOiAnb3BlbicgfSk7XG4gICAgfVxuICAgIHR5cGVvZiBvcHRpb25zLmNvbnN0cnVjdG9yQ2FsbGJhY2sgPT09ICdmdW5jdGlvbicgJiYgb3B0aW9ucy5jb25zdHJ1Y3RvckNhbGxiYWNrLmNhbGwodGhpcyk7XG4gIH1cbiAgZnVuY3Rpb24gY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgdHlwZW9mIG9wdGlvbnMuY29ubmVjdGVkQ2FsbGJhY2sgPT09ICdmdW5jdGlvbicgJiYgb3B0aW9ucy5jb25uZWN0ZWRDYWxsYmFjay5jYWxsKHRoaXMpO1xuICB9XG5cbiAgZnVuY3Rpb24gZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgdHlwZW9mIG9wdGlvbnMuZGlzY29ubmVjdGVkQ2FsbGJhY2sgPT09ICdmdW5jdGlvbicgJiYgb3B0aW9ucy5kaXNjb25uZWN0ZWRDYWxsYmFjay5jYWxsKHRoaXMpO1xuICB9XG5cbiAgZnVuY3Rpb24gYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIG9sZFZhbHVlLCB2YWx1ZSkge1xuICAgIHR5cGVvZiBvcHRpb25zLmF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJyAmJiBvcHRpb25zLmF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjay5jYWxsKHRoaXMsIG5hbWUsIG9sZFZhbHVlLCB2YWx1ZSk7XG4gIH1cblxuICBpZiAoaXNFUzIwMTUkMSkge1xuICAgIHZhciBDdXN0b21FbGVtZW50ID0gZnVuY3Rpb24gKF9DdXN0b21FbGVtZW50Mikge1xuICAgICAgX2luaGVyaXRzKEN1c3RvbUVsZW1lbnQsIF9DdXN0b21FbGVtZW50Mik7XG5cbiAgICAgIGZ1bmN0aW9uIEN1c3RvbUVsZW1lbnQoc2VsZikge1xuICAgICAgICB2YXIgX3JldDtcblxuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ3VzdG9tRWxlbWVudCk7XG5cbiAgICAgICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKEN1c3RvbUVsZW1lbnQuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihDdXN0b21FbGVtZW50KSkuY2FsbCh0aGlzKSk7XG5cbiAgICAgICAgdmFyIG1lID0gc2VsZiA/IEhUTUxFbGVtZW50LmNhbGwoc2VsZikgOiBfdGhpcztcblxuICAgICAgICBjb25zdHJ1Y3RvckNhbGxiYWNrLmNhbGwobWUpO1xuICAgICAgICByZXR1cm4gX3JldCA9IG1lLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgX3JldCk7XG4gICAgICB9XG5cbiAgICAgIF9jcmVhdGVDbGFzcyhDdXN0b21FbGVtZW50LCBudWxsLCBbe1xuICAgICAgICBrZXk6ICdvYnNlcnZlZEF0dHJpYnV0ZXMnLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gb3B0aW9ucy5vYnNlcnZlZEF0dHJpYnV0ZXMgfHwgW107XG4gICAgICAgIH1cbiAgICAgIH1dKTtcblxuICAgICAgcmV0dXJuIEN1c3RvbUVsZW1lbnQ7XG4gICAgfShfQ3VzdG9tRWxlbWVudCk7XG5cbiAgICBDdXN0b21FbGVtZW50LnByb3RvdHlwZS5jb25uZWN0ZWRDYWxsYmFjayA9IGNvbm5lY3RlZENhbGxiYWNrO1xuICAgIEN1c3RvbUVsZW1lbnQucHJvdG90eXBlLmRpc2Nvbm5lY3RlZENhbGxiYWNrID0gZGlzY29ubmVjdGVkQ2FsbGJhY2s7XG4gICAgQ3VzdG9tRWxlbWVudC5wcm90b3R5cGUuYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrID0gYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrO1xuXG4gICAgY3VzdG9tRWxlbWVudHMuZGVmaW5lKHRhZywgQ3VzdG9tRWxlbWVudCk7XG4gICAgcmV0dXJuIEN1c3RvbUVsZW1lbnQ7XG4gIH0gZWxzZSB7XG4gICAgdmFyIF9DdXN0b21FbGVtZW50MyA9IGZ1bmN0aW9uIF9DdXN0b21FbGVtZW50MyhzZWxmKSB7XG4gICAgICB2YXIgbWUgPSBzZWxmID8gSFRNTEVsZW1lbnQuY2FsbChzZWxmKSA6IHRoaXM7XG5cbiAgICAgIGNvbnN0cnVjdG9yQ2FsbGJhY2suY2FsbChtZSk7XG4gICAgICByZXR1cm4gbWU7XG4gICAgfTtcblxuICAgIF9DdXN0b21FbGVtZW50My5vYnNlcnZlZEF0dHJpYnV0ZXMgPSBvcHRpb25zLm9ic2VydmVkQXR0cmlidXRlcyB8fCBbXTtcblxuICAgIF9DdXN0b21FbGVtZW50My5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEhUTUxFbGVtZW50LnByb3RvdHlwZSwge1xuICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IF9DdXN0b21FbGVtZW50M1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgX0N1c3RvbUVsZW1lbnQzLnByb3RvdHlwZS5jb25uZWN0ZWRDYWxsYmFjayA9IGNvbm5lY3RlZENhbGxiYWNrO1xuICAgIF9DdXN0b21FbGVtZW50My5wcm90b3R5cGUuZGlzY29ubmVjdGVkQ2FsbGJhY2sgPSBkaXNjb25uZWN0ZWRDYWxsYmFjaztcbiAgICBfQ3VzdG9tRWxlbWVudDMucHJvdG90eXBlLmF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayA9IGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjaztcblxuICAgIGN1c3RvbUVsZW1lbnRzLmRlZmluZSh0YWcsIF9DdXN0b21FbGVtZW50Myk7XG4gICAgcmV0dXJuIF9DdXN0b21FbGVtZW50MztcbiAgfVxufVxuXG52YXIgY2FtZWxpemVSRSA9IC8tKFxcdykvZztcbnZhciBjYW1lbGl6ZSA9IGZ1bmN0aW9uIGNhbWVsaXplKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoY2FtZWxpemVSRSwgZnVuY3Rpb24gKF8sIGMpIHtcbiAgICByZXR1cm4gYyA/IGMudG9VcHBlckNhc2UoKSA6ICcnO1xuICB9KTtcbn07XG52YXIgaHlwaGVuYXRlUkUgPSAvKFteLV0pKFtBLVpdKS9nO1xudmFyIGh5cGhlbmF0ZSA9IGZ1bmN0aW9uIGh5cGhlbmF0ZShzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKGh5cGhlbmF0ZVJFLCAnJDEtJDInKS5yZXBsYWNlKGh5cGhlbmF0ZVJFLCAnJDEtJDInKS50b0xvd2VyQ2FzZSgpO1xufTtcblxuZnVuY3Rpb24gdG9BcnJheShsaXN0KSB7XG4gIHZhciBzdGFydCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMDtcblxuICB2YXIgaSA9IGxpc3QubGVuZ3RoIC0gc3RhcnQ7XG4gIHZhciByZXQgPSBuZXcgQXJyYXkoaSk7XG4gIHdoaWxlIChpLS0pIHtcbiAgICByZXRbaV0gPSBsaXN0W2kgKyBzdGFydF07XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmo7XG59IDogZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbn07XG5cbmZ1bmN0aW9uIGNvbnZlcnRBdHRyaWJ1dGVWYWx1ZSh2YWx1ZSkge1xuICB2YXIgcHJvcHNWYWx1ZSA9IHZhbHVlO1xuICB2YXIgaXNCb29sZWFuID0gWyd0cnVlJywgJ2ZhbHNlJ10uaW5kZXhPZih2YWx1ZSkgPiAtMTtcbiAgdmFyIHZhbHVlUGFyc2VkID0gcGFyc2VGbG9hdChwcm9wc1ZhbHVlLCAxMCk7XG4gIHZhciBpc051bWJlciA9ICFpc05hTih2YWx1ZVBhcnNlZCkgJiYgaXNGaW5pdGUocHJvcHNWYWx1ZSk7XG5cbiAgaWYgKGlzQm9vbGVhbikge1xuICAgIHByb3BzVmFsdWUgPSBwcm9wc1ZhbHVlID09PSAndHJ1ZSc7XG4gIH0gZWxzZSBpZiAoaXNOdW1iZXIpIHtcbiAgICBwcm9wc1ZhbHVlID0gdmFsdWVQYXJzZWQ7XG4gIH1cblxuICByZXR1cm4gcHJvcHNWYWx1ZTtcbn1cblxuZnVuY3Rpb24gZXh0cmFjdFByb3BzKGNvbGxlY3Rpb24sIHByb3BzKSB7XG4gIGlmIChjb2xsZWN0aW9uICYmIGNvbGxlY3Rpb24ubGVuZ3RoKSB7XG4gICAgY29sbGVjdGlvbi5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICB2YXIgY2FtZWxDYXNlUHJvcCA9IGNhbWVsaXplKHByb3ApO1xuICAgICAgcHJvcHMuY2FtZWxDYXNlLmluZGV4T2YoY2FtZWxDYXNlUHJvcCkgPT09IC0xICYmIHByb3BzLmNhbWVsQ2FzZS5wdXNoKGNhbWVsQ2FzZVByb3ApO1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKGNvbGxlY3Rpb24gJiYgKHR5cGVvZiBjb2xsZWN0aW9uID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihjb2xsZWN0aW9uKSkgPT09ICdvYmplY3QnKSB7XG4gICAgZm9yICh2YXIgcHJvcCBpbiBjb2xsZWN0aW9uKSB7XG4gICAgICB2YXIgY2FtZWxDYXNlUHJvcCA9IGNhbWVsaXplKHByb3ApO1xuICAgICAgcHJvcHMuY2FtZWxDYXNlLmluZGV4T2YoY2FtZWxDYXNlUHJvcCkgPT09IC0xICYmIHByb3BzLmNhbWVsQ2FzZS5wdXNoKGNhbWVsQ2FzZVByb3ApO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRQcm9wcygpIHtcbiAgdmFyIGNvbXBvbmVudERlZmluaXRpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gIHZhciBwcm9wcyA9IHtcbiAgICBjYW1lbENhc2U6IFtdLFxuICAgIGh5cGhlbmF0ZTogW11cbiAgfTtcblxuICBpZiAoY29tcG9uZW50RGVmaW5pdGlvbi5taXhpbnMpIHtcbiAgICBjb21wb25lbnREZWZpbml0aW9uLm1peGlucy5mb3JFYWNoKGZ1bmN0aW9uIChtaXhpbikge1xuICAgICAgZXh0cmFjdFByb3BzKG1peGluLnByb3BzLCBwcm9wcyk7XG4gICAgfSk7XG4gIH1cblxuICBpZiAoY29tcG9uZW50RGVmaW5pdGlvbi5leHRlbmRzICYmIGNvbXBvbmVudERlZmluaXRpb24uZXh0ZW5kcy5wcm9wcykge1xuICAgIHZhciBwYXJlbnRQcm9wcyA9IGNvbXBvbmVudERlZmluaXRpb24uZXh0ZW5kcy5wcm9wcztcblxuICAgIGV4dHJhY3RQcm9wcyhwYXJlbnRQcm9wcywgcHJvcHMpO1xuICB9XG5cbiAgZXh0cmFjdFByb3BzKGNvbXBvbmVudERlZmluaXRpb24ucHJvcHMsIHByb3BzKTtcblxuICBwcm9wcy5jYW1lbENhc2UuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgIHByb3BzLmh5cGhlbmF0ZS5wdXNoKGh5cGhlbmF0ZShwcm9wKSk7XG4gIH0pO1xuXG4gIHJldHVybiBwcm9wcztcbn1cblxuZnVuY3Rpb24gcmVhY3RpdmVQcm9wcyhlbGVtZW50LCBwcm9wcykge1xuICBwcm9wcy5jYW1lbENhc2UuZm9yRWFjaChmdW5jdGlvbiAobmFtZSwgaW5kZXgpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgbmFtZSwge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9fdnVlX2N1c3RvbV9lbGVtZW50X19bbmFtZV07XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgaWYgKCgodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZih2YWx1ZSkpID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpICYmIHRoaXMuX192dWVfY3VzdG9tX2VsZW1lbnRfXykge1xuICAgICAgICAgIHZhciBwcm9wTmFtZSA9IHByb3BzLmNhbWVsQ2FzZVtpbmRleF07XG4gICAgICAgICAgdGhpcy5fX3Z1ZV9jdXN0b21fZWxlbWVudF9fW3Byb3BOYW1lXSA9IHZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKHByb3BzLmh5cGhlbmF0ZVtpbmRleF0sIGNvbnZlcnRBdHRyaWJ1dGVWYWx1ZSh2YWx1ZSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBnZXRQcm9wc0RhdGEoZWxlbWVudCwgY29tcG9uZW50RGVmaW5pdGlvbiwgcHJvcHMpIHtcbiAgdmFyIHByb3BzRGF0YSA9IGNvbXBvbmVudERlZmluaXRpb24ucHJvcHNEYXRhIHx8IHt9O1xuXG4gIHByb3BzLmh5cGhlbmF0ZS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lLCBpbmRleCkge1xuICAgIHZhciB2YWx1ZSA9IGVsZW1lbnQuYXR0cmlidXRlc1tuYW1lXSAmJiBlbGVtZW50LmF0dHJpYnV0ZXNbbmFtZV0ubm9kZVZhbHVlO1xuXG4gICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09ICcnKSB7XG4gICAgICBwcm9wc0RhdGFbcHJvcHMuY2FtZWxDYXNlW2luZGV4XV0gPSBjb252ZXJ0QXR0cmlidXRlVmFsdWUodmFsdWUpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHByb3BzRGF0YTtcbn1cblxuZnVuY3Rpb24gZ2V0QXR0cmlidXRlcyhjaGlsZHJlbikge1xuICB2YXIgYXR0cmlidXRlcyA9IHt9O1xuXG4gIHRvQXJyYXkoY2hpbGRyZW4uYXR0cmlidXRlcykuZm9yRWFjaChmdW5jdGlvbiAoYXR0cmlidXRlKSB7XG4gICAgYXR0cmlidXRlc1thdHRyaWJ1dGUubm9kZU5hbWUgPT09ICd2dWUtc2xvdCcgPyAnc2xvdCcgOiBhdHRyaWJ1dGUubm9kZU5hbWVdID0gYXR0cmlidXRlLm5vZGVWYWx1ZTtcbiAgfSk7XG5cbiAgcmV0dXJuIGF0dHJpYnV0ZXM7XG59XG5cbmZ1bmN0aW9uIGdldFNsb3RzKCkge1xuICB2YXIgY2hpbGRyZW4gPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IFtdO1xuICB2YXIgY3JlYXRlRWxlbWVudCA9IGFyZ3VtZW50c1sxXTtcblxuICB2YXIgc2xvdHMgPSBbXTtcbiAgdG9BcnJheShjaGlsZHJlbikuZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICBpZiAoY2hpbGQubm9kZU5hbWUgPT09ICcjdGV4dCcpIHtcbiAgICAgIGlmIChjaGlsZC5ub2RlVmFsdWUudHJpbSgpKSB7XG4gICAgICAgIHNsb3RzLnB1c2goY3JlYXRlRWxlbWVudCgnc3BhbicsIGNoaWxkLm5vZGVWYWx1ZSkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYXR0cmlidXRlcyA9IGdldEF0dHJpYnV0ZXMoY2hpbGQpO1xuICAgICAgdmFyIGVsZW1lbnRPcHRpb25zID0ge1xuICAgICAgICBhdHRyczogYXR0cmlidXRlcyxcbiAgICAgICAgZG9tUHJvcHM6IHtcbiAgICAgICAgICBpbm5lckhUTUw6IGNoaWxkLmlubmVySFRNTFxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBpZiAoYXR0cmlidXRlcy5zbG90KSB7XG4gICAgICAgIGVsZW1lbnRPcHRpb25zLnNsb3QgPSBhdHRyaWJ1dGVzLnNsb3Q7XG4gICAgICAgIGF0dHJpYnV0ZXMuc2xvdCA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgc2xvdHMucHVzaChjcmVhdGVFbGVtZW50KGNoaWxkLnRhZ05hbWUsIGVsZW1lbnRPcHRpb25zKSk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gc2xvdHM7XG59XG5cbmZ1bmN0aW9uIGN1c3RvbUV2ZW50KGV2ZW50TmFtZSwgZGV0YWlsKSB7XG4gIHZhciBwYXJhbXMgPSB7IGJ1YmJsZXM6IGZhbHNlLCBjYW5jZWxhYmxlOiBmYWxzZSwgZGV0YWlsOiBkZXRhaWwgfTtcbiAgdmFyIGV2ZW50ID0gdm9pZCAwO1xuICBpZiAodHlwZW9mIHdpbmRvdy5DdXN0b21FdmVudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KGV2ZW50TmFtZSwgcGFyYW1zKTtcbiAgfSBlbHNlIHtcbiAgICBldmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdDdXN0b21FdmVudCcpO1xuICAgIGV2ZW50LmluaXRDdXN0b21FdmVudChldmVudE5hbWUsIHBhcmFtcy5idWJibGVzLCBwYXJhbXMuY2FuY2VsYWJsZSwgcGFyYW1zLmRldGFpbCk7XG4gIH1cbiAgcmV0dXJuIGV2ZW50O1xufVxuXG5mdW5jdGlvbiBjdXN0b21FbWl0KGVsZW1lbnQsIGV2ZW50TmFtZSkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4gPiAyID8gX2xlbiAtIDIgOiAwKSwgX2tleSA9IDI7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBhcmdzW19rZXkgLSAyXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIHZhciBldmVudCA9IGN1c3RvbUV2ZW50KGV2ZW50TmFtZSwgW10uY29uY2F0KGFyZ3MpKTtcbiAgZWxlbWVudC5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlVnVlSW5zdGFuY2UoZWxlbWVudCwgVnVlLCBjb21wb25lbnREZWZpbml0aW9uLCBwcm9wcywgb3B0aW9ucykge1xuICBpZiAoIWVsZW1lbnQuX192dWVfY3VzdG9tX2VsZW1lbnRfXykge1xuICAgIHZhciBDb21wb25lbnREZWZpbml0aW9uID0gVnVlLnV0aWwuZXh0ZW5kKHt9LCBjb21wb25lbnREZWZpbml0aW9uKTtcbiAgICB2YXIgcHJvcHNEYXRhID0gZ2V0UHJvcHNEYXRhKGVsZW1lbnQsIENvbXBvbmVudERlZmluaXRpb24sIHByb3BzKTtcbiAgICB2YXIgdnVlVmVyc2lvbiA9IFZ1ZS52ZXJzaW9uICYmIHBhcnNlSW50KFZ1ZS52ZXJzaW9uLnNwbGl0KCcuJylbMF0sIDEwKSB8fCAwO1xuXG4gICAgdmFyIGN0b3JPcHRpb25zID0ge307XG4gICAgaWYgKENvbXBvbmVudERlZmluaXRpb24uX0N0b3IpIHtcbiAgICAgIGN0b3JPcHRpb25zID0gQ29tcG9uZW50RGVmaW5pdGlvbi5fQ3RvclswXS5vcHRpb25zO1xuICAgIH1cbiAgICBDb21wb25lbnREZWZpbml0aW9uLm1ldGhvZHMgPSBjdG9yT3B0aW9ucy5tZXRob2RzID0gQ29tcG9uZW50RGVmaW5pdGlvbi5tZXRob2RzIHx8IHt9O1xuICAgIENvbXBvbmVudERlZmluaXRpb24ubWV0aG9kcy4kZW1pdCA9IGN0b3JPcHRpb25zLm1ldGhvZHMuJGVtaXQgPSBmdW5jdGlvbiBlbWl0KCkge1xuICAgICAgdmFyIF9wcm90b19fJCRlbWl0O1xuXG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuXG4gICAgICBjdXN0b21FbWl0LmFwcGx5KHVuZGVmaW5lZCwgW2VsZW1lbnRdLmNvbmNhdChhcmdzKSk7XG4gICAgICB0aGlzLl9fcHJvdG9fXyAmJiAoX3Byb3RvX18kJGVtaXQgPSB0aGlzLl9fcHJvdG9fXy4kZW1pdCkuY2FsbC5hcHBseShfcHJvdG9fXyQkZW1pdCwgW3RoaXNdLmNvbmNhdChhcmdzKSk7XG4gICAgfTtcblxuICAgIHZhciByb290RWxlbWVudCA9IHZvaWQgMDtcblxuICAgIGlmICh2dWVWZXJzaW9uID49IDIpIHtcbiAgICAgIHZhciBlbGVtZW50T3JpZ2luYWxDaGlsZHJlbiA9IGVsZW1lbnQuY2xvbmVOb2RlKHRydWUpLmNoaWxkTm9kZXM7XG4gICAgICByb290RWxlbWVudCA9IHtcbiAgICAgICAgcHJvcHNEYXRhOiBwcm9wc0RhdGEsXG4gICAgICAgIHByb3BzOiBwcm9wcy5jYW1lbENhc2UsXG4gICAgICAgIGNvbXB1dGVkOiB7XG4gICAgICAgICAgcmVhY3RpdmVQcm9wczogZnVuY3Rpb24gcmVhY3RpdmVQcm9wcyQkMSgpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgICAgIHZhciByZWFjdGl2ZVByb3BzTGlzdCA9IHt9O1xuICAgICAgICAgICAgcHJvcHMuY2FtZWxDYXNlLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgICAgICAgcmVhY3RpdmVQcm9wc0xpc3RbcHJvcF0gPSBfdGhpc1twcm9wXTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gcmVhY3RpdmVQcm9wc0xpc3Q7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcihjcmVhdGVFbGVtZW50KSB7XG4gICAgICAgICAgdmFyIGRhdGEgPSB7XG4gICAgICAgICAgICBwcm9wczogdGhpcy5yZWFjdGl2ZVByb3BzXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50KENvbXBvbmVudERlZmluaXRpb24sIGRhdGEsIGdldFNsb3RzKGVsZW1lbnRPcmlnaW5hbENoaWxkcmVuLCBjcmVhdGVFbGVtZW50KSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSBlbHNlIGlmICh2dWVWZXJzaW9uID09PSAxKSB7XG4gICAgICByb290RWxlbWVudCA9IENvbXBvbmVudERlZmluaXRpb247XG4gICAgICByb290RWxlbWVudC5wcm9wc0RhdGEgPSBwcm9wc0RhdGE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJvb3RFbGVtZW50ID0gQ29tcG9uZW50RGVmaW5pdGlvbjtcbiAgICAgIHZhciBwcm9wc1dpdGhEZWZhdWx0ID0ge307XG4gICAgICBPYmplY3Qua2V5cyhwcm9wc0RhdGEpLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgcHJvcHNXaXRoRGVmYXVsdFtwcm9wXSA9IHsgZGVmYXVsdDogcHJvcHNEYXRhW3Byb3BdIH07XG4gICAgICB9KTtcbiAgICAgIHJvb3RFbGVtZW50LnByb3BzID0gcHJvcHNXaXRoRGVmYXVsdDtcbiAgICB9XG5cbiAgICB2YXIgZWxlbWVudElubmVySHRtbCA9IHZ1ZVZlcnNpb24gPj0gMiA/ICc8ZGl2PjwvZGl2PicgOiAoJzxkaXY+JyArIGVsZW1lbnQuaW5uZXJIVE1MICsgJzwvZGl2PicpLnJlcGxhY2UoL3Z1ZS1zbG90PS9nLCAnc2xvdD0nKTtcbiAgICBpZiAob3B0aW9ucy5zaGFkb3cgJiYgZWxlbWVudC5zaGFkb3dSb290KSB7XG4gICAgICBlbGVtZW50LnNoYWRvd1Jvb3QuaW5uZXJIVE1MID0gZWxlbWVudElubmVySHRtbDtcbiAgICAgIHJvb3RFbGVtZW50LmVsID0gZWxlbWVudC5zaGFkb3dSb290LmNoaWxkcmVuWzBdO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGVtZW50LmlubmVySFRNTCA9IGVsZW1lbnRJbm5lckh0bWw7XG4gICAgICByb290RWxlbWVudC5lbCA9IGVsZW1lbnQuY2hpbGRyZW5bMF07XG4gICAgfVxuXG4gICAgcmVhY3RpdmVQcm9wcyhlbGVtZW50LCBwcm9wcyk7XG5cbiAgICBlbGVtZW50Ll9fdnVlX2N1c3RvbV9lbGVtZW50X18gPSBuZXcgVnVlKHJvb3RFbGVtZW50KTtcbiAgICBpZiAob3B0aW9ucy5zaGFkb3cgJiYgb3B0aW9ucy5zaGFkb3dDc3MgJiYgZWxlbWVudC5zaGFkb3dSb290KSB7XG4gICAgICB2YXIgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICAgICAgc3R5bGUudHlwZSA9ICd0ZXh0L2Nzcyc7XG4gICAgICBzdHlsZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShvcHRpb25zLnNoYWRvd0NzcykpO1xuXG4gICAgICBlbGVtZW50LnNoYWRvd1Jvb3QuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuICAgIH1cbiAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgndmNlLWNsb2FrJyk7XG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3ZjZS1yZWFkeScsICcnKTtcbiAgICBjdXN0b21FbWl0KGVsZW1lbnQsICd2Y2UtcmVhZHknKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbnN0YWxsKFZ1ZSkge1xuICBWdWUuY3VzdG9tRWxlbWVudCA9IGZ1bmN0aW9uIHZ1ZUN1c3RvbUVsZW1lbnQodGFnLCBjb21wb25lbnREZWZpbml0aW9uKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuXG4gICAgdmFyIGlzQXN5bmNDb21wb25lbnQgPSB0eXBlb2YgY29tcG9uZW50RGVmaW5pdGlvbiA9PT0gJ2Z1bmN0aW9uJztcbiAgICB2YXIgb3B0aW9uc1Byb3BzID0gaXNBc3luY0NvbXBvbmVudCAmJiB7IHByb3BzOiBvcHRpb25zLnByb3BzIHx8IFtdIH07XG4gICAgdmFyIHByb3BzID0gZ2V0UHJvcHMoaXNBc3luY0NvbXBvbmVudCA/IG9wdGlvbnNQcm9wcyA6IGNvbXBvbmVudERlZmluaXRpb24pO1xuXG4gICAgdmFyIEN1c3RvbUVsZW1lbnQgPSByZWdpc3RlckN1c3RvbUVsZW1lbnQodGFnLCB7XG4gICAgICBjb25zdHJ1Y3RvckNhbGxiYWNrOiBmdW5jdGlvbiBjb25zdHJ1Y3RvckNhbGxiYWNrKCkge1xuICAgICAgICB0eXBlb2Ygb3B0aW9ucy5jb25zdHJ1Y3RvckNhbGxiYWNrID09PSAnZnVuY3Rpb24nICYmIG9wdGlvbnMuY29uc3RydWN0b3JDYWxsYmFjay5jYWxsKHRoaXMpO1xuICAgICAgfSxcbiAgICAgIGNvbm5lY3RlZENhbGxiYWNrOiBmdW5jdGlvbiBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgICB2YXIgYXN5bmNDb21wb25lbnRQcm9taXNlID0gaXNBc3luY0NvbXBvbmVudCAmJiBjb21wb25lbnREZWZpbml0aW9uKCk7XG4gICAgICAgIHZhciBpc0FzeW5jQ29tcG9uZW50UHJvbWlzZSA9IGFzeW5jQ29tcG9uZW50UHJvbWlzZSAmJiBhc3luY0NvbXBvbmVudFByb21pc2UudGhlbiAmJiB0eXBlb2YgYXN5bmNDb21wb25lbnRQcm9taXNlLnRoZW4gPT09ICdmdW5jdGlvbic7XG5cbiAgICAgICAgaWYgKGlzQXN5bmNDb21wb25lbnQgJiYgIWlzQXN5bmNDb21wb25lbnRQcm9taXNlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBc3luYyBjb21wb25lbnQgJyArIHRhZyArICcgZG8gbm90IHJldHVybnMgUHJvbWlzZScpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5fX2RldGFjaGVkX18pIHtcbiAgICAgICAgICBpZiAoaXNBc3luY0NvbXBvbmVudFByb21pc2UpIHtcbiAgICAgICAgICAgIGFzeW5jQ29tcG9uZW50UHJvbWlzZS50aGVuKGZ1bmN0aW9uIChsYXp5TG9hZGVkQ29tcG9uZW50KSB7XG4gICAgICAgICAgICAgIHZhciBsYXp5TG9hZGVkQ29tcG9uZW50UHJvcHMgPSBnZXRQcm9wcyhsYXp5TG9hZGVkQ29tcG9uZW50KTtcbiAgICAgICAgICAgICAgY3JlYXRlVnVlSW5zdGFuY2UoX3RoaXMsIFZ1ZSwgbGF6eUxvYWRlZENvbXBvbmVudCwgbGF6eUxvYWRlZENvbXBvbmVudFByb3BzLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjcmVhdGVWdWVJbnN0YW5jZSh0aGlzLCBWdWUsIGNvbXBvbmVudERlZmluaXRpb24sIHByb3BzLCBvcHRpb25zKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9fZGV0YWNoZWRfXyA9IGZhbHNlO1xuICAgICAgfSxcbiAgICAgIGRpc2Nvbm5lY3RlZENhbGxiYWNrOiBmdW5jdGlvbiBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgICAgdGhpcy5fX2RldGFjaGVkX18gPSB0cnVlO1xuICAgICAgICB0eXBlb2Ygb3B0aW9ucy5kaXNjb25uZWN0ZWRDYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJyAmJiBvcHRpb25zLmRpc2Nvbm5lY3RlZENhbGxiYWNrLmNhbGwodGhpcyk7XG5cbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKF90aGlzMi5fX2RldGFjaGVkX18gJiYgX3RoaXMyLl9fdnVlX2N1c3RvbV9lbGVtZW50X18pIHtcbiAgICAgICAgICAgIF90aGlzMi5fX3Z1ZV9jdXN0b21fZWxlbWVudF9fLiRkZXN0cm95KHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgb3B0aW9ucy5kZXN0cm95VGltZW91dCB8fCAzMDAwKTtcbiAgICAgIH0sXG4gICAgICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2s6IGZ1bmN0aW9uIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBvbGRWYWx1ZSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuX192dWVfY3VzdG9tX2VsZW1lbnRfXyAmJiB0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgdmFyIG5hbWVDYW1lbENhc2UgPSBjYW1lbGl6ZShuYW1lKTtcbiAgICAgICAgICB0eXBlb2Ygb3B0aW9ucy5hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sgPT09ICdmdW5jdGlvbicgJiYgb3B0aW9ucy5hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2suY2FsbCh0aGlzLCBuYW1lLCBvbGRWYWx1ZSwgdmFsdWUpO1xuICAgICAgICAgIHRoaXMuX192dWVfY3VzdG9tX2VsZW1lbnRfX1tuYW1lQ2FtZWxDYXNlXSA9IGNvbnZlcnRBdHRyaWJ1dGVWYWx1ZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIG9ic2VydmVkQXR0cmlidXRlczogcHJvcHMuaHlwaGVuYXRlLFxuXG4gICAgICBzaGFkb3c6ICEhb3B0aW9ucy5zaGFkb3cgJiYgISFIVE1MRWxlbWVudC5wcm90b3R5cGUuYXR0YWNoU2hhZG93XG4gICAgfSk7XG5cbiAgICByZXR1cm4gQ3VzdG9tRWxlbWVudDtcbiAgfTtcbn1cblxuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5WdWUpIHtcbiAgd2luZG93LlZ1ZS51c2UoaW5zdGFsbCk7XG4gIGlmIChpbnN0YWxsLmluc3RhbGxlZCkge1xuICAgIGluc3RhbGwuaW5zdGFsbGVkID0gZmFsc2U7XG4gIH1cbn1cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9IChpbnN0YWxsKTtcblxuLyoqKi8gfSksXG4vKiA3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fYmFiZWxfbG9hZGVyX25vZGVfbW9kdWxlc192dWVfbG9hZGVyX2xpYl9zZWxlY3Rvcl90eXBlX3NjcmlwdF9pbmRleF8wX0FwcF92dWVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fbm9kZV9tb2R1bGVzX3Z1ZV9sb2FkZXJfbGliX3RlbXBsYXRlX2NvbXBpbGVyX2luZGV4X2lkX2RhdGFfdl82NWY4NWVkY19oYXNTY29wZWRfZmFsc2Vfbm9kZV9tb2R1bGVzX3Z1ZV9sb2FkZXJfbGliX3NlbGVjdG9yX3R5cGVfdGVtcGxhdGVfaW5kZXhfMF9BcHBfdnVlX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMzKTtcbmZ1bmN0aW9uIGluamVjdFN0eWxlIChzc3JDb250ZXh0KSB7XG4gIF9fd2VicGFja19yZXF1aXJlX18oOClcbn1cbnZhciBub3JtYWxpemVDb21wb25lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApXG4vKiBzY3JpcHQgKi9cblxuLyogdGVtcGxhdGUgKi9cblxuLyogc3R5bGVzICovXG52YXIgX192dWVfc3R5bGVzX18gPSBpbmplY3RTdHlsZVxuLyogc2NvcGVJZCAqL1xudmFyIF9fdnVlX3Njb3BlSWRfXyA9IG51bGxcbi8qIG1vZHVsZUlkZW50aWZpZXIgKHNlcnZlciBvbmx5KSAqL1xudmFyIF9fdnVlX21vZHVsZV9pZGVudGlmaWVyX18gPSBudWxsXG52YXIgQ29tcG9uZW50ID0gbm9ybWFsaXplQ29tcG9uZW50KFxuICBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX2JhYmVsX2xvYWRlcl9ub2RlX21vZHVsZXNfdnVlX2xvYWRlcl9saWJfc2VsZWN0b3JfdHlwZV9zY3JpcHRfaW5kZXhfMF9BcHBfdnVlX19bXCJhXCIgLyogZGVmYXVsdCAqL10sXG4gIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fbm9kZV9tb2R1bGVzX3Z1ZV9sb2FkZXJfbGliX3RlbXBsYXRlX2NvbXBpbGVyX2luZGV4X2lkX2RhdGFfdl82NWY4NWVkY19oYXNTY29wZWRfZmFsc2Vfbm9kZV9tb2R1bGVzX3Z1ZV9sb2FkZXJfbGliX3NlbGVjdG9yX3R5cGVfdGVtcGxhdGVfaW5kZXhfMF9BcHBfdnVlX19bXCJhXCIgLyogZGVmYXVsdCAqL10sXG4gIF9fdnVlX3N0eWxlc19fLFxuICBfX3Z1ZV9zY29wZUlkX18sXG4gIF9fdnVlX21vZHVsZV9pZGVudGlmaWVyX19cbilcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9IChDb21wb25lbnQuZXhwb3J0cyk7XG5cblxuLyoqKi8gfSksXG4vKiA4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaSwgY29udGVudCwgJyddXTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IF9fd2VicGFja19yZXF1aXJlX18oMikoXCIzMmUwZTk4OFwiLCBjb250ZW50LCB0cnVlKTtcblxuLyoqKi8gfSksXG4vKiA5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oMSkodW5kZWZpbmVkKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmksIFwiW3YtY2xvYWtde2Rpc3BsYXk6bm9uZX0qe2JveC1zaXppbmc6Ym9yZGVyLWJveH0jYXBwe2ZvbnQtZmFtaWx5Ok9zd2FsZDstd2Via2l0LWZvbnQtc21vb3RoaW5nOmFudGlhbGlhc2VkOy1tb3otb3N4LWZvbnQtc21vb3RoaW5nOmdyYXlzY2FsZX0uYWNjb3JkaW9uLC5ob3VzZXtkaXNwbGF5Om5vbmV9QG1lZGlhIChtaW4td2lkdGg6NzY4cHgpey5ob3VzZXttaW4td2lkdGg6NzY3cHg7bWF4LXdpZHRoOjEyMDBweDttYXJnaW46YXV0bztkaXNwbGF5OmJsb2NrfX1AbWVkaWEgKG1heC13aWR0aDo3NjdweCl7LmFjY29yZGlvbntkaXNwbGF5OmJsb2NrfX1cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG5cblxuLyoqKi8gfSksXG4vKiAxMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vKipcbiAqIFRyYW5zbGF0ZXMgdGhlIGxpc3QgZm9ybWF0IHByb2R1Y2VkIGJ5IGNzcy1sb2FkZXIgaW50byBzb21ldGhpbmdcbiAqIGVhc2llciB0byBtYW5pcHVsYXRlLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGxpc3RUb1N0eWxlcyhwYXJlbnRJZCwgbGlzdCkge1xuICB2YXIgc3R5bGVzID0gW107XG4gIHZhciBuZXdTdHlsZXMgPSB7fTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGl0ZW0gPSBsaXN0W2ldO1xuICAgIHZhciBpZCA9IGl0ZW1bMF07XG4gICAgdmFyIGNzcyA9IGl0ZW1bMV07XG4gICAgdmFyIG1lZGlhID0gaXRlbVsyXTtcbiAgICB2YXIgc291cmNlTWFwID0gaXRlbVszXTtcbiAgICB2YXIgcGFydCA9IHtcbiAgICAgIGlkOiBwYXJlbnRJZCArICc6JyArIGksXG4gICAgICBjc3M6IGNzcyxcbiAgICAgIG1lZGlhOiBtZWRpYSxcbiAgICAgIHNvdXJjZU1hcDogc291cmNlTWFwXG4gICAgfTtcbiAgICBpZiAoIW5ld1N0eWxlc1tpZF0pIHtcbiAgICAgIHN0eWxlcy5wdXNoKG5ld1N0eWxlc1tpZF0gPSB7IGlkOiBpZCwgcGFydHM6IFtwYXJ0XSB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV3U3R5bGVzW2lkXS5wYXJ0cy5wdXNoKHBhcnQpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3R5bGVzO1xufTtcblxuLyoqKi8gfSksXG4vKiAxMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX2NvbXBvbmVudHNfSG91c2VfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fY29tcG9uZW50c19BY2NvcmRpb25fXyA9IF9fd2VicGFja19yZXF1aXJlX18oMjUpO1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG5cblxuXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAoe1xuICAgIG5hbWU6ICdhcHAnLFxuICAgIGNvbXBvbmVudHM6IHtcbiAgICAgICAgSG91c2U6IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fY29tcG9uZW50c19Ib3VzZV9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dLFxuICAgICAgICBBY2NvcmRpb246IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fY29tcG9uZW50c19BY2NvcmRpb25fX1tcImFcIiAvKiBkZWZhdWx0ICovXVxuICAgIH0sXG4gICAgZGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNhbGxvdXRzOiBbe1xuICAgICAgICAgICAgICAgIHRpdGxlOiAnS2l0Y2hlbicsXG4gICAgICAgICAgICAgICAgc2x1ZzogJ2tpdGNoZW4nLFxuICAgICAgICAgICAgICAgIHRleHQ6ICdMb3JlbSBpcHN1bSBkb2xvciBzaXQgYW1ldCwgY29uc2VjdGV0dXIgYWRpcGlzaWNpbmcgZWxpdC4gRmFjZXJlIGFzcGVyaW9yZXMgdml0YWUgb2JjYWVjYXRpLCBhZGlwaXNjaSBtaW5pbWEgbmF0dXMgbnVsbGEgYWxpcXVpZCBhdHF1ZSBuZWNlc3NpdGF0aWJ1cyBpbnZlbnRvcmUhJyxcbiAgICAgICAgICAgICAgICBzaG93OiBmYWxzZSxcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgICAgICAgICAgICB0b3A6ICcyMSUnLFxuICAgICAgICAgICAgICAgICAgICBsZWZ0OiAnNTMlJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICB0aXRsZTogJ0JhdGhyb29tJyxcbiAgICAgICAgICAgICAgICBzbHVnOiAnYmF0aHJvb20nLFxuICAgICAgICAgICAgICAgIHRleHQ6ICdMb3JlbSBpcHN1bSBkb2xvciBzaXQgYW1ldCwgY29uc2VjdGV0dXIgYWRpcGlzaWNpbmcgZWxpdC4gRmFjZXJlIGFzcGVyaW9yZXMgdml0YWUgb2JjYWVjYXRpLCBhZGlwaXNjaSBtaW5pbWEgbmF0dXMgbnVsbGEgYWxpcXVpZCBhdHF1ZSBuZWNlc3NpdGF0aWJ1cyBpbnZlbnRvcmUhJyxcbiAgICAgICAgICAgICAgICBzaG93OiBmYWxzZSxcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgICAgICAgICAgICB0b3A6ICcxNSUnLFxuICAgICAgICAgICAgICAgICAgICBsZWZ0OiAnMjUlJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICB0aXRsZTogJ1dhdGVyIFNvZnRlbmVyJyxcbiAgICAgICAgICAgICAgICBzbHVnOiAnd2F0ZXItc29mdGVuZXInLFxuICAgICAgICAgICAgICAgIHRleHQ6ICdMb3JlbSBpcHN1bSBkb2xvciBzaXQgYW1ldCwgY29uc2VjdGV0dXIgYWRpcGlzaWNpbmcgZWxpdC4gRmFjZXJlIGFzcGVyaW9yZXMgdml0YWUgb2JjYWVjYXRpLCBhZGlwaXNjaSBtaW5pbWEgbmF0dXMgbnVsbGEgYWxpcXVpZCBhdHF1ZSBuZWNlc3NpdGF0aWJ1cyBpbnZlbnRvcmUhJyxcbiAgICAgICAgICAgICAgICBzaG93OiBmYWxzZSxcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgICAgICAgICAgICB0b3A6ICcxNSUnLFxuICAgICAgICAgICAgICAgICAgICBsZWZ0OiAnMTAlJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICB0aXRsZTogJ0xhdW5kcnknLFxuICAgICAgICAgICAgICAgIHNsdWc6ICdsYXVuZHJ5JyxcbiAgICAgICAgICAgICAgICB0ZXh0OiAnTG9yZW0gaXBzdW0gZG9sb3Igc2l0IGFtZXQsIGNvbnNlY3RldHVyIGFkaXBpc2ljaW5nIGVsaXQuIEZhY2VyZSBhc3BlcmlvcmVzIHZpdGFlIG9iY2FlY2F0aSwgYWRpcGlzY2kgbWluaW1hIG5hdHVzIG51bGxhIGFsaXF1aWQgYXRxdWUgbmVjZXNzaXRhdGlidXMgaW52ZW50b3JlIScsXG4gICAgICAgICAgICAgICAgc2hvdzogZmFsc2UsXG4gICAgICAgICAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICAgICAgICAgICAgdG9wOiAnMjAlJyxcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogJzEwJSdcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgdGl0bGU6ICdGb3VuZGF0aW9uJyxcbiAgICAgICAgICAgICAgICBzbHVnOiAnZm91bmRhdGlvbicsXG4gICAgICAgICAgICAgICAgdGV4dDogJ0xvcmVtIGlwc3VtIGRvbG9yIHNpdCBhbWV0LCBjb25zZWN0ZXR1ciBhZGlwaXNpY2luZyBlbGl0LiBGYWNlcmUgYXNwZXJpb3JlcyB2aXRhZSBvYmNhZWNhdGksIGFkaXBpc2NpIG1pbmltYSBuYXR1cyBudWxsYSBhbGlxdWlkIGF0cXVlIG5lY2Vzc2l0YXRpYnVzIGludmVudG9yZSEnLFxuICAgICAgICAgICAgICAgIHNob3c6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgICAgICAgICAgIHRvcDogJzQ1JScsXG4gICAgICAgICAgICAgICAgICAgIGxlZnQ6ICcxMCUnXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIHRpdGxlOiAnU2VydmljZSBMaW5lJyxcbiAgICAgICAgICAgICAgICBzbHVnOiAnc2VydmljZS1saW5lJyxcbiAgICAgICAgICAgICAgICB0ZXh0OiAnTG9yZW0gaXBzdW0gZG9sb3Igc2l0IGFtZXQsIGNvbnNlY3RldHVyIGFkaXBpc2ljaW5nIGVsaXQuIEZhY2VyZSBhc3BlcmlvcmVzIHZpdGFlIG9iY2FlY2F0aSwgYWRpcGlzY2kgbWluaW1hIG5hdHVzIG51bGxhIGFsaXF1aWQgYXRxdWUgbmVjZXNzaXRhdGlidXMgaW52ZW50b3JlIScsXG4gICAgICAgICAgICAgICAgc2hvdzogZmFsc2UsXG4gICAgICAgICAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICAgICAgICAgICAgdG9wOiAnNDAlJyxcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogJzUwJSdcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgdGl0bGU6ICdJcnJpZ2F0aW9uJyxcbiAgICAgICAgICAgICAgICBzbHVnOiAnaXJyaWdhdGlvbicsXG4gICAgICAgICAgICAgICAgdGV4dDogJ0xvcmVtIGlwc3VtIGRvbG9yIHNpdCBhbWV0LCBjb25zZWN0ZXR1ciBhZGlwaXNpY2luZyBlbGl0LiBGYWNlcmUgYXNwZXJpb3JlcyB2aXRhZSBvYmNhZWNhdGksIGFkaXBpc2NpIG1pbmltYSBuYXR1cyBudWxsYSBhbGlxdWlkIGF0cXVlIG5lY2Vzc2l0YXRpYnVzIGludmVudG9yZSEnLFxuICAgICAgICAgICAgICAgIHNob3c6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgICAgICAgICAgIHRvcDogJzMwJScsXG4gICAgICAgICAgICAgICAgICAgIGxlZnQ6ICc2MCUnXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIHRpdGxlOiAnUG9vbCcsXG4gICAgICAgICAgICAgICAgc2x1ZzogJ3Bvb2wnLFxuICAgICAgICAgICAgICAgIHRleHQ6ICdMb3JlbSBpcHN1bSBkb2xvciBzaXQgYW1ldCwgY29uc2VjdGV0dXIgYWRpcGlzaWNpbmcgZWxpdC4gRmFjZXJlIGFzcGVyaW9yZXMgdml0YWUgb2JjYWVjYXRpLCBhZGlwaXNjaSBtaW5pbWEgbmF0dXMgbnVsbGEgYWxpcXVpZCBhdHF1ZSBuZWNlc3NpdGF0aWJ1cyBpbnZlbnRvcmUhJyxcbiAgICAgICAgICAgICAgICBzaG93OiBmYWxzZSxcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgICAgICAgICAgICB0b3A6ICc0NyUnLFxuICAgICAgICAgICAgICAgICAgICBsZWZ0OiAnNzMlJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dXG4gICAgICAgIH07XG4gICAgfVxufSk7XG5cbi8qKiovIH0pLFxuLyogMTIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19iYWJlbF9sb2FkZXJfbm9kZV9tb2R1bGVzX3Z1ZV9sb2FkZXJfbGliX3NlbGVjdG9yX3R5cGVfc2NyaXB0X2luZGV4XzBfSG91c2VfdnVlX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX25vZGVfbW9kdWxlc192dWVfbG9hZGVyX2xpYl90ZW1wbGF0ZV9jb21waWxlcl9pbmRleF9pZF9kYXRhX3ZfMWJjYzkzZjRfaGFzU2NvcGVkX3RydWVfbm9kZV9tb2R1bGVzX3Z1ZV9sb2FkZXJfbGliX3NlbGVjdG9yX3R5cGVfdGVtcGxhdGVfaW5kZXhfMF9Ib3VzZV92dWVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMjMpO1xuZnVuY3Rpb24gaW5qZWN0U3R5bGUgKHNzckNvbnRleHQpIHtcbiAgX193ZWJwYWNrX3JlcXVpcmVfXygxMylcbn1cbnZhciBub3JtYWxpemVDb21wb25lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApXG4vKiBzY3JpcHQgKi9cblxuLyogdGVtcGxhdGUgKi9cblxuLyogc3R5bGVzICovXG52YXIgX192dWVfc3R5bGVzX18gPSBpbmplY3RTdHlsZVxuLyogc2NvcGVJZCAqL1xudmFyIF9fdnVlX3Njb3BlSWRfXyA9IFwiZGF0YS12LTFiY2M5M2Y0XCJcbi8qIG1vZHVsZUlkZW50aWZpZXIgKHNlcnZlciBvbmx5KSAqL1xudmFyIF9fdnVlX21vZHVsZV9pZGVudGlmaWVyX18gPSBudWxsXG52YXIgQ29tcG9uZW50ID0gbm9ybWFsaXplQ29tcG9uZW50KFxuICBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX2JhYmVsX2xvYWRlcl9ub2RlX21vZHVsZXNfdnVlX2xvYWRlcl9saWJfc2VsZWN0b3JfdHlwZV9zY3JpcHRfaW5kZXhfMF9Ib3VzZV92dWVfX1tcImFcIiAvKiBkZWZhdWx0ICovXSxcbiAgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19ub2RlX21vZHVsZXNfdnVlX2xvYWRlcl9saWJfdGVtcGxhdGVfY29tcGlsZXJfaW5kZXhfaWRfZGF0YV92XzFiY2M5M2Y0X2hhc1Njb3BlZF90cnVlX25vZGVfbW9kdWxlc192dWVfbG9hZGVyX2xpYl9zZWxlY3Rvcl90eXBlX3RlbXBsYXRlX2luZGV4XzBfSG91c2VfdnVlX19bXCJhXCIgLyogZGVmYXVsdCAqL10sXG4gIF9fdnVlX3N0eWxlc19fLFxuICBfX3Z1ZV9zY29wZUlkX18sXG4gIF9fdnVlX21vZHVsZV9pZGVudGlmaWVyX19cbilcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9IChDb21wb25lbnQuZXhwb3J0cyk7XG5cblxuLyoqKi8gfSksXG4vKiAxMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNCk7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pLCBjb250ZW50LCAnJ11dO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKShcImRjZTcxZmUwXCIsIGNvbnRlbnQsIHRydWUpO1xuXG4vKioqLyB9KSxcbi8qIDE0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oMSkodW5kZWZpbmVkKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmksIFwiLmhvdXNlLXdyYXBwZXJbZGF0YS12LTFiY2M5M2Y0XSwuaG91c2VbZGF0YS12LTFiY2M5M2Y0XXtwb3NpdGlvbjpyZWxhdGl2ZX1pbWdbZGF0YS12LTFiY2M5M2Y0XXttYXgtd2lkdGg6MTAwJTt6LWluZGV4OjB9LmNhbGxvdXRbZGF0YS12LTFiY2M5M2Y0XXtwb3NpdGlvbjphYnNvbHV0ZTt6LWluZGV4OjJ9LmZhZGUtZW50ZXItYWN0aXZlW2RhdGEtdi0xYmNjOTNmNF0sLmZhZGUtbGVhdmUtYWN0aXZlW2RhdGEtdi0xYmNjOTNmNF17dHJhbnNpdGlvbjpvcGFjaXR5IC4zc30uZmFkZS1lbnRlcltkYXRhLXYtMWJjYzkzZjRdLC5mYWRlLWxlYXZlLXRvW2RhdGEtdi0xYmNjOTNmNF17b3BhY2l0eTowfS5ob3RzcG90W2RhdGEtdi0xYmNjOTNmNF17cG9zaXRpb246YWJzb2x1dGU7ei1pbmRleDoxO2JhY2tncm91bmQtY29sb3I6dHJhbnNwYXJlbnQ7Ym9yZGVyOjNweCBkYXNoZWQgdHJhbnNwYXJlbnQ7dHJhbnNpdGlvbjpiYWNrZ3JvdW5kLWNvbG9yIC4zcyxib3JkZXItY29sb3IgLjNzfS5ob3RzcG90W2RhdGEtdi0xYmNjOTNmNF06aG92ZXJ7Ym9yZGVyLWNvbG9yOiMwMDc4YWU7YmFja2dyb3VuZC1jb2xvcjpyZ2JhKDAsMTIwLDE3NCwuMyl9LndhdGVyLXNvZnRlbmVyW2RhdGEtdi0xYmNjOTNmNF17aGVpZ2h0OjI1JTt3aWR0aDoxNS4xMSU7dG9wOjUwLjIlO2xlZnQ6MTQuMSV9LmtpdGNoZW5bZGF0YS12LTFiY2M5M2Y0XXtoZWlnaHQ6MjIlO3RvcDo1MSU7d2lkdGg6MTYuNyU7bGVmdDo1Ny4xJX0ubGF1bmRyeVtkYXRhLXYtMWJjYzkzZjRde2hlaWdodDoyMiU7d2lkdGg6OS44JTt0b3A6NTEuNCU7bGVmdDozMC4yJX0uYmF0aHJvb21bZGF0YS12LTFiY2M5M2Y0XXt0b3A6MjguNSU7bGVmdDo1MyU7d2lkdGg6MjAuOCU7aGVpZ2h0OjIwLjclfS5wb29sW2RhdGEtdi0xYmNjOTNmNF17bGVmdDo4OC42JTt0b3A6NzguNyU7d2lkdGg6MTEuMyU7aGVpZ2h0OjEzLjUlfS5mb3VuZGF0aW9uW2RhdGEtdi0xYmNjOTNmNF17bGVmdDozJTt0b3A6NzUuMiU7aGVpZ2h0OjYuNiU7d2lkdGg6NzQlfS5zZXJ2aWNlLWxpbmVbZGF0YS12LTFiY2M5M2Y0XXtsZWZ0OjYyJTt0b3A6ODEuOSU7d2lkdGg6MTUlO2hlaWdodDoxMiV9LmlycmlnYXRpb25bZGF0YS12LTFiY2M5M2Y0XXtsZWZ0Ojc3JTt3aWR0aDoxMS41JTtoZWlnaHQ6MjAlO3RvcDo2NSV9XCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuXG5cbi8qKiovIH0pLFxuLyogMTUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19DYWxsb3V0X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE2KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfbG9kYXNoX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIxKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfbG9kYXNoX19fZGVmYXVsdCA9IF9fd2VicGFja19yZXF1aXJlX18ubihfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfbG9kYXNoX18pO1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuXG4vLyBpbXBvcnQgaG91c2UgZnJvbSAnLi4vYXNzZXRzL2hvdXNlLnBuZydcblxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gKHtcbiAgICBuYW1lOiAnaG91c2UnLFxuICAgIHByb3BzOiBbJ2NhbGxvdXRzJ10sXG4gICAgY29tcG9uZW50czoge1xuICAgICAgICBDYWxsb3V0OiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX0NhbGxvdXRfX1tcImFcIiAvKiBkZWZhdWx0ICovXVxuICAgIH0sXG4gICAgbWV0aG9kczoge1xuICAgICAgICBzaG93Q2FsbG91dCh0aXRsZSkge1xuICAgICAgICAgICAgbGV0IGlkID0gT2JqZWN0KF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9sb2Rhc2hfX1tcImZpbmRJbmRleFwiXSkodGhpcy5jYWxsb3V0cywgbyA9PiBvLnRpdGxlID09PSB0aXRsZSk7XG4gICAgICAgICAgICB0aGlzLmNhbGxvdXRzW2lkXS5zaG93ID0gdHJ1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgaGlkZUNhbGxvdXQodGl0bGUpIHtcbiAgICAgICAgICAgIGxldCBpZCA9IE9iamVjdChfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfbG9kYXNoX19bXCJmaW5kSW5kZXhcIl0pKHRoaXMuY2FsbG91dHMsIG8gPT4gby50aXRsZSA9PT0gdGl0bGUpO1xuICAgICAgICAgICAgdGhpcy5jYWxsb3V0c1tpZF0uc2hvdyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cbi8qKiovIH0pLFxuLyogMTYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19iYWJlbF9sb2FkZXJfbm9kZV9tb2R1bGVzX3Z1ZV9sb2FkZXJfbGliX3NlbGVjdG9yX3R5cGVfc2NyaXB0X2luZGV4XzBfQ2FsbG91dF92dWVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTkpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fbm9kZV9tb2R1bGVzX3Z1ZV9sb2FkZXJfbGliX3RlbXBsYXRlX2NvbXBpbGVyX2luZGV4X2lkX2RhdGFfdl8wYTYyYmI5Nl9oYXNTY29wZWRfdHJ1ZV9ub2RlX21vZHVsZXNfdnVlX2xvYWRlcl9saWJfc2VsZWN0b3JfdHlwZV90ZW1wbGF0ZV9pbmRleF8wX0NhbGxvdXRfdnVlX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIwKTtcbmZ1bmN0aW9uIGluamVjdFN0eWxlIChzc3JDb250ZXh0KSB7XG4gIF9fd2VicGFja19yZXF1aXJlX18oMTcpXG59XG52YXIgbm9ybWFsaXplQ29tcG9uZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKVxuLyogc2NyaXB0ICovXG5cbi8qIHRlbXBsYXRlICovXG5cbi8qIHN0eWxlcyAqL1xudmFyIF9fdnVlX3N0eWxlc19fID0gaW5qZWN0U3R5bGVcbi8qIHNjb3BlSWQgKi9cbnZhciBfX3Z1ZV9zY29wZUlkX18gPSBcImRhdGEtdi0wYTYyYmI5NlwiXG4vKiBtb2R1bGVJZGVudGlmaWVyIChzZXJ2ZXIgb25seSkgKi9cbnZhciBfX3Z1ZV9tb2R1bGVfaWRlbnRpZmllcl9fID0gbnVsbFxudmFyIENvbXBvbmVudCA9IG5vcm1hbGl6ZUNvbXBvbmVudChcbiAgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19iYWJlbF9sb2FkZXJfbm9kZV9tb2R1bGVzX3Z1ZV9sb2FkZXJfbGliX3NlbGVjdG9yX3R5cGVfc2NyaXB0X2luZGV4XzBfQ2FsbG91dF92dWVfX1tcImFcIiAvKiBkZWZhdWx0ICovXSxcbiAgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19ub2RlX21vZHVsZXNfdnVlX2xvYWRlcl9saWJfdGVtcGxhdGVfY29tcGlsZXJfaW5kZXhfaWRfZGF0YV92XzBhNjJiYjk2X2hhc1Njb3BlZF90cnVlX25vZGVfbW9kdWxlc192dWVfbG9hZGVyX2xpYl9zZWxlY3Rvcl90eXBlX3RlbXBsYXRlX2luZGV4XzBfQ2FsbG91dF92dWVfX1tcImFcIiAvKiBkZWZhdWx0ICovXSxcbiAgX192dWVfc3R5bGVzX18sXG4gIF9fdnVlX3Njb3BlSWRfXyxcbiAgX192dWVfbW9kdWxlX2lkZW50aWZpZXJfX1xuKVxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gKENvbXBvbmVudC5leHBvcnRzKTtcblxuXG4vKioqLyB9KSxcbi8qIDE3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE4KTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmksIGNvbnRlbnQsICcnXV07XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpKFwiM2Q5MjZiOWVcIiwgY29udGVudCwgdHJ1ZSk7XG5cbi8qKiovIH0pLFxuLyogMTggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKSh1bmRlZmluZWQpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaSwgXCIuY2FsbG91dFtkYXRhLXYtMGE2MmJiOTZde2JhY2tncm91bmQtY29sb3I6I2RhNjkwYjtwYWRkaW5nOjEwcHggMTVweDtjb2xvcjojZmZmO21heC13aWR0aDozMTVweH1oM1tkYXRhLXYtMGE2MmJiOTZdLHBbZGF0YS12LTBhNjJiYjk2XXtwYWRkaW5nOjAgMCA1cHg7bWFyZ2luOjB9aDNbZGF0YS12LTBhNjJiYjk2XXtmb250LXNpemU6MThweDtmb250LXdlaWdodDo1MDB9cFtkYXRhLXYtMGE2MmJiOTZde2ZvbnQtc2l6ZToxNnB4O2ZvbnQtd2VpZ2h0OjMwMH1AbWVkaWEgKG1heC13aWR0aDo5OTRweCl7LmNhbGxvdXRbZGF0YS12LTBhNjJiYjk2XXttYXgtd2lkdGg6MjAwcHg7cGFkZGluZzo1cHggMTBweH1oM1tkYXRhLXYtMGE2MmJiOTZde2ZvbnQtc2l6ZToxNHB4fXBbZGF0YS12LTBhNjJiYjk2XXtmb250LXNpemU6MTNweH19XCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuXG5cbi8qKiovIH0pLFxuLyogMTkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gKHtcbiAgICBuYW1lOiAnY2FsbG91dCcsXG4gICAgcHJvcHM6IFsnY29udGVudCcsICd0aXRsZSddXG59KTtcblxuLyoqKi8gfSksXG4vKiAyMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbnZhciByZW5kZXIgPSBmdW5jdGlvbiAoKSB7dmFyIF92bT10aGlzO3ZhciBfaD1fdm0uJGNyZWF0ZUVsZW1lbnQ7dmFyIF9jPV92bS5fc2VsZi5fY3x8X2g7cmV0dXJuIF9jKCdkaXYnLHtzdGF0aWNDbGFzczpcImNhbGxvdXRcIixvbjp7XCJtb3VzZWVudGVyXCI6ZnVuY3Rpb24oJGV2ZW50KXskZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7JGV2ZW50LnByZXZlbnREZWZhdWx0KCk7fSxcIm1vdXNlbGVhdmVcIjpmdW5jdGlvbigkZXZlbnQpeyRldmVudC5zdG9wUHJvcGFnYXRpb24oKTskZXZlbnQucHJldmVudERlZmF1bHQoKTt9fX0sW19jKCdoMycsW192bS5fdihfdm0uX3MoX3ZtLnRpdGxlKSldKSxfdm0uX3YoXCIgXCIpLF9jKCdwJyxbX3ZtLl92KF92bS5fcyhfdm0uY29udGVudCkpXSldKX1cbnZhciBzdGF0aWNSZW5kZXJGbnMgPSBbXVxudmFyIGVzRXhwb3J0cyA9IHsgcmVuZGVyOiByZW5kZXIsIHN0YXRpY1JlbmRlckZuczogc3RhdGljUmVuZGVyRm5zIH1cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAoZXNFeHBvcnRzKTtcblxuLyoqKi8gfSksXG4vKiAyMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oZnVuY3Rpb24oZ2xvYmFsLCBtb2R1bGUpIHt2YXIgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX187LyoqXG4gKiBAbGljZW5zZVxuICogTG9kYXNoIDxodHRwczovL2xvZGFzaC5jb20vPlxuICogQ29weXJpZ2h0IEpTIEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9ycyA8aHR0cHM6Ly9qcy5mb3VuZGF0aW9uLz5cbiAqIFJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT5cbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gKiBDb3B5cmlnaHQgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbiAqLzsoZnVuY3Rpb24oKXsvKiogVXNlZCBhcyBhIHNhZmUgcmVmZXJlbmNlIGZvciBgdW5kZWZpbmVkYCBpbiBwcmUtRVM1IGVudmlyb25tZW50cy4gKi92YXIgdW5kZWZpbmVkOy8qKiBVc2VkIGFzIHRoZSBzZW1hbnRpYyB2ZXJzaW9uIG51bWJlci4gKi92YXIgVkVSU0lPTj0nNC4xNy40JzsvKiogVXNlZCBhcyB0aGUgc2l6ZSB0byBlbmFibGUgbGFyZ2UgYXJyYXkgb3B0aW1pemF0aW9ucy4gKi92YXIgTEFSR0VfQVJSQVlfU0laRT0yMDA7LyoqIEVycm9yIG1lc3NhZ2UgY29uc3RhbnRzLiAqL3ZhciBDT1JFX0VSUk9SX1RFWFQ9J1Vuc3VwcG9ydGVkIGNvcmUtanMgdXNlLiBUcnkgaHR0cHM6Ly9ucG1zLmlvL3NlYXJjaD9xPXBvbnlmaWxsLicsRlVOQ19FUlJPUl9URVhUPSdFeHBlY3RlZCBhIGZ1bmN0aW9uJzsvKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovdmFyIEhBU0hfVU5ERUZJTkVEPSdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJzsvKiogVXNlZCBhcyB0aGUgbWF4aW11bSBtZW1vaXplIGNhY2hlIHNpemUuICovdmFyIE1BWF9NRU1PSVpFX1NJWkU9NTAwOy8qKiBVc2VkIGFzIHRoZSBpbnRlcm5hbCBhcmd1bWVudCBwbGFjZWhvbGRlci4gKi92YXIgUExBQ0VIT0xERVI9J19fbG9kYXNoX3BsYWNlaG9sZGVyX18nOy8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIGNsb25pbmcuICovdmFyIENMT05FX0RFRVBfRkxBRz0xLENMT05FX0ZMQVRfRkxBRz0yLENMT05FX1NZTUJPTFNfRkxBRz00Oy8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL3ZhciBDT01QQVJFX1BBUlRJQUxfRkxBRz0xLENPTVBBUkVfVU5PUkRFUkVEX0ZMQUc9MjsvKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciBmdW5jdGlvbiBtZXRhZGF0YS4gKi92YXIgV1JBUF9CSU5EX0ZMQUc9MSxXUkFQX0JJTkRfS0VZX0ZMQUc9MixXUkFQX0NVUlJZX0JPVU5EX0ZMQUc9NCxXUkFQX0NVUlJZX0ZMQUc9OCxXUkFQX0NVUlJZX1JJR0hUX0ZMQUc9MTYsV1JBUF9QQVJUSUFMX0ZMQUc9MzIsV1JBUF9QQVJUSUFMX1JJR0hUX0ZMQUc9NjQsV1JBUF9BUllfRkxBRz0xMjgsV1JBUF9SRUFSR19GTEFHPTI1NixXUkFQX0ZMSVBfRkxBRz01MTI7LyoqIFVzZWQgYXMgZGVmYXVsdCBvcHRpb25zIGZvciBgXy50cnVuY2F0ZWAuICovdmFyIERFRkFVTFRfVFJVTkNfTEVOR1RIPTMwLERFRkFVTFRfVFJVTkNfT01JU1NJT049Jy4uLic7LyoqIFVzZWQgdG8gZGV0ZWN0IGhvdCBmdW5jdGlvbnMgYnkgbnVtYmVyIG9mIGNhbGxzIHdpdGhpbiBhIHNwYW4gb2YgbWlsbGlzZWNvbmRzLiAqL3ZhciBIT1RfQ09VTlQ9ODAwLEhPVF9TUEFOPTE2Oy8qKiBVc2VkIHRvIGluZGljYXRlIHRoZSB0eXBlIG9mIGxhenkgaXRlcmF0ZWVzLiAqL3ZhciBMQVpZX0ZJTFRFUl9GTEFHPTEsTEFaWV9NQVBfRkxBRz0yLExBWllfV0hJTEVfRkxBRz0zOy8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL3ZhciBJTkZJTklUWT0xLzAsTUFYX1NBRkVfSU5URUdFUj05MDA3MTk5MjU0NzQwOTkxLE1BWF9JTlRFR0VSPTEuNzk3NjkzMTM0ODYyMzE1N2UrMzA4LE5BTj0wLzA7LyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdGhlIG1heGltdW0gbGVuZ3RoIGFuZCBpbmRleCBvZiBhbiBhcnJheS4gKi92YXIgTUFYX0FSUkFZX0xFTkdUSD00Mjk0OTY3Mjk1LE1BWF9BUlJBWV9JTkRFWD1NQVhfQVJSQVlfTEVOR1RILTEsSEFMRl9NQVhfQVJSQVlfTEVOR1RIPU1BWF9BUlJBWV9MRU5HVEg+Pj4xOy8qKiBVc2VkIHRvIGFzc29jaWF0ZSB3cmFwIG1ldGhvZHMgd2l0aCB0aGVpciBiaXQgZmxhZ3MuICovdmFyIHdyYXBGbGFncz1bWydhcnknLFdSQVBfQVJZX0ZMQUddLFsnYmluZCcsV1JBUF9CSU5EX0ZMQUddLFsnYmluZEtleScsV1JBUF9CSU5EX0tFWV9GTEFHXSxbJ2N1cnJ5JyxXUkFQX0NVUlJZX0ZMQUddLFsnY3VycnlSaWdodCcsV1JBUF9DVVJSWV9SSUdIVF9GTEFHXSxbJ2ZsaXAnLFdSQVBfRkxJUF9GTEFHXSxbJ3BhcnRpYWwnLFdSQVBfUEFSVElBTF9GTEFHXSxbJ3BhcnRpYWxSaWdodCcsV1JBUF9QQVJUSUFMX1JJR0hUX0ZMQUddLFsncmVhcmcnLFdSQVBfUkVBUkdfRkxBR11dOy8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi92YXIgYXJnc1RhZz0nW29iamVjdCBBcmd1bWVudHNdJyxhcnJheVRhZz0nW29iamVjdCBBcnJheV0nLGFzeW5jVGFnPSdbb2JqZWN0IEFzeW5jRnVuY3Rpb25dJyxib29sVGFnPSdbb2JqZWN0IEJvb2xlYW5dJyxkYXRlVGFnPSdbb2JqZWN0IERhdGVdJyxkb21FeGNUYWc9J1tvYmplY3QgRE9NRXhjZXB0aW9uXScsZXJyb3JUYWc9J1tvYmplY3QgRXJyb3JdJyxmdW5jVGFnPSdbb2JqZWN0IEZ1bmN0aW9uXScsZ2VuVGFnPSdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXScsbWFwVGFnPSdbb2JqZWN0IE1hcF0nLG51bWJlclRhZz0nW29iamVjdCBOdW1iZXJdJyxudWxsVGFnPSdbb2JqZWN0IE51bGxdJyxvYmplY3RUYWc9J1tvYmplY3QgT2JqZWN0XScscHJvbWlzZVRhZz0nW29iamVjdCBQcm9taXNlXScscHJveHlUYWc9J1tvYmplY3QgUHJveHldJyxyZWdleHBUYWc9J1tvYmplY3QgUmVnRXhwXScsc2V0VGFnPSdbb2JqZWN0IFNldF0nLHN0cmluZ1RhZz0nW29iamVjdCBTdHJpbmddJyxzeW1ib2xUYWc9J1tvYmplY3QgU3ltYm9sXScsdW5kZWZpbmVkVGFnPSdbb2JqZWN0IFVuZGVmaW5lZF0nLHdlYWtNYXBUYWc9J1tvYmplY3QgV2Vha01hcF0nLHdlYWtTZXRUYWc9J1tvYmplY3QgV2Vha1NldF0nO3ZhciBhcnJheUJ1ZmZlclRhZz0nW29iamVjdCBBcnJheUJ1ZmZlcl0nLGRhdGFWaWV3VGFnPSdbb2JqZWN0IERhdGFWaWV3XScsZmxvYXQzMlRhZz0nW29iamVjdCBGbG9hdDMyQXJyYXldJyxmbG9hdDY0VGFnPSdbb2JqZWN0IEZsb2F0NjRBcnJheV0nLGludDhUYWc9J1tvYmplY3QgSW50OEFycmF5XScsaW50MTZUYWc9J1tvYmplY3QgSW50MTZBcnJheV0nLGludDMyVGFnPSdbb2JqZWN0IEludDMyQXJyYXldJyx1aW50OFRhZz0nW29iamVjdCBVaW50OEFycmF5XScsdWludDhDbGFtcGVkVGFnPSdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsdWludDE2VGFnPSdbb2JqZWN0IFVpbnQxNkFycmF5XScsdWludDMyVGFnPSdbb2JqZWN0IFVpbnQzMkFycmF5XSc7LyoqIFVzZWQgdG8gbWF0Y2ggZW1wdHkgc3RyaW5nIGxpdGVyYWxzIGluIGNvbXBpbGVkIHRlbXBsYXRlIHNvdXJjZS4gKi92YXIgcmVFbXB0eVN0cmluZ0xlYWRpbmc9L1xcYl9fcCBcXCs9ICcnOy9nLHJlRW1wdHlTdHJpbmdNaWRkbGU9L1xcYihfX3AgXFwrPSkgJycgXFwrL2cscmVFbXB0eVN0cmluZ1RyYWlsaW5nPS8oX19lXFwoLio/XFwpfFxcYl9fdFxcKSkgXFwrXFxuJyc7L2c7LyoqIFVzZWQgdG8gbWF0Y2ggSFRNTCBlbnRpdGllcyBhbmQgSFRNTCBjaGFyYWN0ZXJzLiAqL3ZhciByZUVzY2FwZWRIdG1sPS8mKD86YW1wfGx0fGd0fHF1b3R8IzM5KTsvZyxyZVVuZXNjYXBlZEh0bWw9L1smPD5cIiddL2cscmVIYXNFc2NhcGVkSHRtbD1SZWdFeHAocmVFc2NhcGVkSHRtbC5zb3VyY2UpLHJlSGFzVW5lc2NhcGVkSHRtbD1SZWdFeHAocmVVbmVzY2FwZWRIdG1sLnNvdXJjZSk7LyoqIFVzZWQgdG8gbWF0Y2ggdGVtcGxhdGUgZGVsaW1pdGVycy4gKi92YXIgcmVFc2NhcGU9LzwlLShbXFxzXFxTXSs/KSU+L2cscmVFdmFsdWF0ZT0vPCUoW1xcc1xcU10rPyklPi9nLHJlSW50ZXJwb2xhdGU9LzwlPShbXFxzXFxTXSs/KSU+L2c7LyoqIFVzZWQgdG8gbWF0Y2ggcHJvcGVydHkgbmFtZXMgd2l0aGluIHByb3BlcnR5IHBhdGhzLiAqL3ZhciByZUlzRGVlcFByb3A9L1xcLnxcXFsoPzpbXltcXF1dKnwoW1wiJ10pKD86KD8hXFwxKVteXFxcXF18XFxcXC4pKj9cXDEpXFxdLyxyZUlzUGxhaW5Qcm9wPS9eXFx3KiQvLHJlTGVhZGluZ0RvdD0vXlxcLi8scmVQcm9wTmFtZT0vW14uW1xcXV0rfFxcWyg/OigtP1xcZCsoPzpcXC5cXGQrKT8pfChbXCInXSkoKD86KD8hXFwyKVteXFxcXF18XFxcXC4pKj8pXFwyKVxcXXwoPz0oPzpcXC58XFxbXFxdKSg/OlxcLnxcXFtcXF18JCkpL2c7LyoqXG4gICAqIFVzZWQgdG8gbWF0Y2ggYFJlZ0V4cGBcbiAgICogW3N5bnRheCBjaGFyYWN0ZXJzXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1wYXR0ZXJucykuXG4gICAqL3ZhciByZVJlZ0V4cENoYXI9L1tcXFxcXiQuKis/KClbXFxde318XS9nLHJlSGFzUmVnRXhwQ2hhcj1SZWdFeHAocmVSZWdFeHBDaGFyLnNvdXJjZSk7LyoqIFVzZWQgdG8gbWF0Y2ggbGVhZGluZyBhbmQgdHJhaWxpbmcgd2hpdGVzcGFjZS4gKi92YXIgcmVUcmltPS9eXFxzK3xcXHMrJC9nLHJlVHJpbVN0YXJ0PS9eXFxzKy8scmVUcmltRW5kPS9cXHMrJC87LyoqIFVzZWQgdG8gbWF0Y2ggd3JhcCBkZXRhaWwgY29tbWVudHMuICovdmFyIHJlV3JhcENvbW1lbnQ9L1xceyg/OlxcblxcL1xcKiBcXFt3cmFwcGVkIHdpdGggLitcXF0gXFwqXFwvKT9cXG4/LyxyZVdyYXBEZXRhaWxzPS9cXHtcXG5cXC9cXCogXFxbd3JhcHBlZCB3aXRoICguKylcXF0gXFwqLyxyZVNwbGl0RGV0YWlscz0vLD8gJiAvOy8qKiBVc2VkIHRvIG1hdGNoIHdvcmRzIGNvbXBvc2VkIG9mIGFscGhhbnVtZXJpYyBjaGFyYWN0ZXJzLiAqL3ZhciByZUFzY2lpV29yZD0vW15cXHgwMC1cXHgyZlxceDNhLVxceDQwXFx4NWItXFx4NjBcXHg3Yi1cXHg3Zl0rL2c7LyoqIFVzZWQgdG8gbWF0Y2ggYmFja3NsYXNoZXMgaW4gcHJvcGVydHkgcGF0aHMuICovdmFyIHJlRXNjYXBlQ2hhcj0vXFxcXChcXFxcKT8vZzsvKipcbiAgICogVXNlZCB0byBtYXRjaFxuICAgKiBbRVMgdGVtcGxhdGUgZGVsaW1pdGVyc10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdGVtcGxhdGUtbGl0ZXJhbC1sZXhpY2FsLWNvbXBvbmVudHMpLlxuICAgKi92YXIgcmVFc1RlbXBsYXRlPS9cXCRcXHsoW15cXFxcfV0qKD86XFxcXC5bXlxcXFx9XSopKilcXH0vZzsvKiogVXNlZCB0byBtYXRjaCBgUmVnRXhwYCBmbGFncyBmcm9tIHRoZWlyIGNvZXJjZWQgc3RyaW5nIHZhbHVlcy4gKi92YXIgcmVGbGFncz0vXFx3KiQvOy8qKiBVc2VkIHRvIGRldGVjdCBiYWQgc2lnbmVkIGhleGFkZWNpbWFsIHN0cmluZyB2YWx1ZXMuICovdmFyIHJlSXNCYWRIZXg9L15bLStdMHhbMC05YS1mXSskL2k7LyoqIFVzZWQgdG8gZGV0ZWN0IGJpbmFyeSBzdHJpbmcgdmFsdWVzLiAqL3ZhciByZUlzQmluYXJ5PS9eMGJbMDFdKyQvaTsvKiogVXNlZCB0byBkZXRlY3QgaG9zdCBjb25zdHJ1Y3RvcnMgKFNhZmFyaSkuICovdmFyIHJlSXNIb3N0Q3Rvcj0vXlxcW29iamVjdCAuKz9Db25zdHJ1Y3RvclxcXSQvOy8qKiBVc2VkIHRvIGRldGVjdCBvY3RhbCBzdHJpbmcgdmFsdWVzLiAqL3ZhciByZUlzT2N0YWw9L14wb1swLTddKyQvaTsvKiogVXNlZCB0byBkZXRlY3QgdW5zaWduZWQgaW50ZWdlciB2YWx1ZXMuICovdmFyIHJlSXNVaW50PS9eKD86MHxbMS05XVxcZCopJC87LyoqIFVzZWQgdG8gbWF0Y2ggTGF0aW4gVW5pY29kZSBsZXR0ZXJzIChleGNsdWRpbmcgbWF0aGVtYXRpY2FsIG9wZXJhdG9ycykuICovdmFyIHJlTGF0aW49L1tcXHhjMC1cXHhkNlxceGQ4LVxceGY2XFx4ZjgtXFx4ZmZcXHUwMTAwLVxcdTAxN2ZdL2c7LyoqIFVzZWQgdG8gZW5zdXJlIGNhcHR1cmluZyBvcmRlciBvZiB0ZW1wbGF0ZSBkZWxpbWl0ZXJzLiAqL3ZhciByZU5vTWF0Y2g9LygkXikvOy8qKiBVc2VkIHRvIG1hdGNoIHVuZXNjYXBlZCBjaGFyYWN0ZXJzIGluIGNvbXBpbGVkIHN0cmluZyBsaXRlcmFscy4gKi92YXIgcmVVbmVzY2FwZWRTdHJpbmc9L1snXFxuXFxyXFx1MjAyOFxcdTIwMjlcXFxcXS9nOy8qKiBVc2VkIHRvIGNvbXBvc2UgdW5pY29kZSBjaGFyYWN0ZXIgY2xhc3Nlcy4gKi92YXIgcnNBc3RyYWxSYW5nZT0nXFxcXHVkODAwLVxcXFx1ZGZmZicscnNDb21ib01hcmtzUmFuZ2U9J1xcXFx1MDMwMC1cXFxcdTAzNmYnLHJlQ29tYm9IYWxmTWFya3NSYW5nZT0nXFxcXHVmZTIwLVxcXFx1ZmUyZicscnNDb21ib1N5bWJvbHNSYW5nZT0nXFxcXHUyMGQwLVxcXFx1MjBmZicscnNDb21ib1JhbmdlPXJzQ29tYm9NYXJrc1JhbmdlK3JlQ29tYm9IYWxmTWFya3NSYW5nZStyc0NvbWJvU3ltYm9sc1JhbmdlLHJzRGluZ2JhdFJhbmdlPSdcXFxcdTI3MDAtXFxcXHUyN2JmJyxyc0xvd2VyUmFuZ2U9J2EtelxcXFx4ZGYtXFxcXHhmNlxcXFx4ZjgtXFxcXHhmZicscnNNYXRoT3BSYW5nZT0nXFxcXHhhY1xcXFx4YjFcXFxceGQ3XFxcXHhmNycscnNOb25DaGFyUmFuZ2U9J1xcXFx4MDAtXFxcXHgyZlxcXFx4M2EtXFxcXHg0MFxcXFx4NWItXFxcXHg2MFxcXFx4N2ItXFxcXHhiZicscnNQdW5jdHVhdGlvblJhbmdlPSdcXFxcdTIwMDAtXFxcXHUyMDZmJyxyc1NwYWNlUmFuZ2U9JyBcXFxcdFxcXFx4MGJcXFxcZlxcXFx4YTBcXFxcdWZlZmZcXFxcblxcXFxyXFxcXHUyMDI4XFxcXHUyMDI5XFxcXHUxNjgwXFxcXHUxODBlXFxcXHUyMDAwXFxcXHUyMDAxXFxcXHUyMDAyXFxcXHUyMDAzXFxcXHUyMDA0XFxcXHUyMDA1XFxcXHUyMDA2XFxcXHUyMDA3XFxcXHUyMDA4XFxcXHUyMDA5XFxcXHUyMDBhXFxcXHUyMDJmXFxcXHUyMDVmXFxcXHUzMDAwJyxyc1VwcGVyUmFuZ2U9J0EtWlxcXFx4YzAtXFxcXHhkNlxcXFx4ZDgtXFxcXHhkZScscnNWYXJSYW5nZT0nXFxcXHVmZTBlXFxcXHVmZTBmJyxyc0JyZWFrUmFuZ2U9cnNNYXRoT3BSYW5nZStyc05vbkNoYXJSYW5nZStyc1B1bmN0dWF0aW9uUmFuZ2UrcnNTcGFjZVJhbmdlOy8qKiBVc2VkIHRvIGNvbXBvc2UgdW5pY29kZSBjYXB0dXJlIGdyb3Vwcy4gKi92YXIgcnNBcG9zPVwiWydcXHUyMDE5XVwiLHJzQXN0cmFsPSdbJytyc0FzdHJhbFJhbmdlKyddJyxyc0JyZWFrPSdbJytyc0JyZWFrUmFuZ2UrJ10nLHJzQ29tYm89J1snK3JzQ29tYm9SYW5nZSsnXScscnNEaWdpdHM9J1xcXFxkKycscnNEaW5nYmF0PSdbJytyc0RpbmdiYXRSYW5nZSsnXScscnNMb3dlcj0nWycrcnNMb3dlclJhbmdlKyddJyxyc01pc2M9J1teJytyc0FzdHJhbFJhbmdlK3JzQnJlYWtSYW5nZStyc0RpZ2l0cytyc0RpbmdiYXRSYW5nZStyc0xvd2VyUmFuZ2UrcnNVcHBlclJhbmdlKyddJyxyc0ZpdHo9J1xcXFx1ZDgzY1tcXFxcdWRmZmItXFxcXHVkZmZmXScscnNNb2RpZmllcj0nKD86Jytyc0NvbWJvKyd8Jytyc0ZpdHorJyknLHJzTm9uQXN0cmFsPSdbXicrcnNBc3RyYWxSYW5nZSsnXScscnNSZWdpb25hbD0nKD86XFxcXHVkODNjW1xcXFx1ZGRlNi1cXFxcdWRkZmZdKXsyfScscnNTdXJyUGFpcj0nW1xcXFx1ZDgwMC1cXFxcdWRiZmZdW1xcXFx1ZGMwMC1cXFxcdWRmZmZdJyxyc1VwcGVyPSdbJytyc1VwcGVyUmFuZ2UrJ10nLHJzWldKPSdcXFxcdTIwMGQnOy8qKiBVc2VkIHRvIGNvbXBvc2UgdW5pY29kZSByZWdleGVzLiAqL3ZhciByc01pc2NMb3dlcj0nKD86Jytyc0xvd2VyKyd8Jytyc01pc2MrJyknLHJzTWlzY1VwcGVyPScoPzonK3JzVXBwZXIrJ3wnK3JzTWlzYysnKScscnNPcHRDb250ckxvd2VyPScoPzonK3JzQXBvcysnKD86ZHxsbHxtfHJlfHN8dHx2ZSkpPycscnNPcHRDb250clVwcGVyPScoPzonK3JzQXBvcysnKD86RHxMTHxNfFJFfFN8VHxWRSkpPycscmVPcHRNb2Q9cnNNb2RpZmllcisnPycscnNPcHRWYXI9J1snK3JzVmFyUmFuZ2UrJ10/Jyxyc09wdEpvaW49Jyg/OicrcnNaV0orJyg/OicrW3JzTm9uQXN0cmFsLHJzUmVnaW9uYWwscnNTdXJyUGFpcl0uam9pbignfCcpKycpJytyc09wdFZhcityZU9wdE1vZCsnKSonLHJzT3JkTG93ZXI9J1xcXFxkKig/Oig/OjFzdHwybmR8M3JkfCg/IVsxMjNdKVxcXFxkdGgpXFxcXGIpJyxyc09yZFVwcGVyPSdcXFxcZCooPzooPzoxU1R8Mk5EfDNSRHwoPyFbMTIzXSlcXFxcZFRIKVxcXFxiKScscnNTZXE9cnNPcHRWYXIrcmVPcHRNb2QrcnNPcHRKb2luLHJzRW1vamk9Jyg/OicrW3JzRGluZ2JhdCxyc1JlZ2lvbmFsLHJzU3VyclBhaXJdLmpvaW4oJ3wnKSsnKScrcnNTZXEscnNTeW1ib2w9Jyg/OicrW3JzTm9uQXN0cmFsK3JzQ29tYm8rJz8nLHJzQ29tYm8scnNSZWdpb25hbCxyc1N1cnJQYWlyLHJzQXN0cmFsXS5qb2luKCd8JykrJyknOy8qKiBVc2VkIHRvIG1hdGNoIGFwb3N0cm9waGVzLiAqL3ZhciByZUFwb3M9UmVnRXhwKHJzQXBvcywnZycpOy8qKlxuICAgKiBVc2VkIHRvIG1hdGNoIFtjb21iaW5pbmcgZGlhY3JpdGljYWwgbWFya3NdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvbWJpbmluZ19EaWFjcml0aWNhbF9NYXJrcykgYW5kXG4gICAqIFtjb21iaW5pbmcgZGlhY3JpdGljYWwgbWFya3MgZm9yIHN5bWJvbHNdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvbWJpbmluZ19EaWFjcml0aWNhbF9NYXJrc19mb3JfU3ltYm9scykuXG4gICAqL3ZhciByZUNvbWJvTWFyaz1SZWdFeHAocnNDb21ibywnZycpOy8qKiBVc2VkIHRvIG1hdGNoIFtzdHJpbmcgc3ltYm9sc10oaHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtdW5pY29kZSkuICovdmFyIHJlVW5pY29kZT1SZWdFeHAocnNGaXR6KycoPz0nK3JzRml0eisnKXwnK3JzU3ltYm9sK3JzU2VxLCdnJyk7LyoqIFVzZWQgdG8gbWF0Y2ggY29tcGxleCBvciBjb21wb3VuZCB3b3Jkcy4gKi92YXIgcmVVbmljb2RlV29yZD1SZWdFeHAoW3JzVXBwZXIrJz8nK3JzTG93ZXIrJysnK3JzT3B0Q29udHJMb3dlcisnKD89JytbcnNCcmVhayxyc1VwcGVyLCckJ10uam9pbignfCcpKycpJyxyc01pc2NVcHBlcisnKycrcnNPcHRDb250clVwcGVyKycoPz0nK1tyc0JyZWFrLHJzVXBwZXIrcnNNaXNjTG93ZXIsJyQnXS5qb2luKCd8JykrJyknLHJzVXBwZXIrJz8nK3JzTWlzY0xvd2VyKycrJytyc09wdENvbnRyTG93ZXIscnNVcHBlcisnKycrcnNPcHRDb250clVwcGVyLHJzT3JkVXBwZXIscnNPcmRMb3dlcixyc0RpZ2l0cyxyc0Vtb2ppXS5qb2luKCd8JyksJ2cnKTsvKiogVXNlZCB0byBkZXRlY3Qgc3RyaW5ncyB3aXRoIFt6ZXJvLXdpZHRoIGpvaW5lcnMgb3IgY29kZSBwb2ludHMgZnJvbSB0aGUgYXN0cmFsIHBsYW5lc10oaHR0cDovL2Vldi5lZS9ibG9nLzIwMTUvMDkvMTIvZGFyay1jb3JuZXJzLW9mLXVuaWNvZGUvKS4gKi92YXIgcmVIYXNVbmljb2RlPVJlZ0V4cCgnWycrcnNaV0orcnNBc3RyYWxSYW5nZStyc0NvbWJvUmFuZ2UrcnNWYXJSYW5nZSsnXScpOy8qKiBVc2VkIHRvIGRldGVjdCBzdHJpbmdzIHRoYXQgbmVlZCBhIG1vcmUgcm9idXN0IHJlZ2V4cCB0byBtYXRjaCB3b3Jkcy4gKi92YXIgcmVIYXNVbmljb2RlV29yZD0vW2Etel1bQS1aXXxbQS1aXXsyLH1bYS16XXxbMC05XVthLXpBLVpdfFthLXpBLVpdWzAtOV18W15hLXpBLVowLTkgXS87LyoqIFVzZWQgdG8gYXNzaWduIGRlZmF1bHQgYGNvbnRleHRgIG9iamVjdCBwcm9wZXJ0aWVzLiAqL3ZhciBjb250ZXh0UHJvcHM9WydBcnJheScsJ0J1ZmZlcicsJ0RhdGFWaWV3JywnRGF0ZScsJ0Vycm9yJywnRmxvYXQzMkFycmF5JywnRmxvYXQ2NEFycmF5JywnRnVuY3Rpb24nLCdJbnQ4QXJyYXknLCdJbnQxNkFycmF5JywnSW50MzJBcnJheScsJ01hcCcsJ01hdGgnLCdPYmplY3QnLCdQcm9taXNlJywnUmVnRXhwJywnU2V0JywnU3RyaW5nJywnU3ltYm9sJywnVHlwZUVycm9yJywnVWludDhBcnJheScsJ1VpbnQ4Q2xhbXBlZEFycmF5JywnVWludDE2QXJyYXknLCdVaW50MzJBcnJheScsJ1dlYWtNYXAnLCdfJywnY2xlYXJUaW1lb3V0JywnaXNGaW5pdGUnLCdwYXJzZUludCcsJ3NldFRpbWVvdXQnXTsvKiogVXNlZCB0byBtYWtlIHRlbXBsYXRlIHNvdXJjZVVSTHMgZWFzaWVyIHRvIGlkZW50aWZ5LiAqL3ZhciB0ZW1wbGF0ZUNvdW50ZXI9LTE7LyoqIFVzZWQgdG8gaWRlbnRpZnkgYHRvU3RyaW5nVGFnYCB2YWx1ZXMgb2YgdHlwZWQgYXJyYXlzLiAqL3ZhciB0eXBlZEFycmF5VGFncz17fTt0eXBlZEFycmF5VGFnc1tmbG9hdDMyVGFnXT10eXBlZEFycmF5VGFnc1tmbG9hdDY0VGFnXT10eXBlZEFycmF5VGFnc1tpbnQ4VGFnXT10eXBlZEFycmF5VGFnc1tpbnQxNlRhZ109dHlwZWRBcnJheVRhZ3NbaW50MzJUYWddPXR5cGVkQXJyYXlUYWdzW3VpbnQ4VGFnXT10eXBlZEFycmF5VGFnc1t1aW50OENsYW1wZWRUYWddPXR5cGVkQXJyYXlUYWdzW3VpbnQxNlRhZ109dHlwZWRBcnJheVRhZ3NbdWludDMyVGFnXT10cnVlO3R5cGVkQXJyYXlUYWdzW2FyZ3NUYWddPXR5cGVkQXJyYXlUYWdzW2FycmF5VGFnXT10eXBlZEFycmF5VGFnc1thcnJheUJ1ZmZlclRhZ109dHlwZWRBcnJheVRhZ3NbYm9vbFRhZ109dHlwZWRBcnJheVRhZ3NbZGF0YVZpZXdUYWddPXR5cGVkQXJyYXlUYWdzW2RhdGVUYWddPXR5cGVkQXJyYXlUYWdzW2Vycm9yVGFnXT10eXBlZEFycmF5VGFnc1tmdW5jVGFnXT10eXBlZEFycmF5VGFnc1ttYXBUYWddPXR5cGVkQXJyYXlUYWdzW251bWJlclRhZ109dHlwZWRBcnJheVRhZ3Nbb2JqZWN0VGFnXT10eXBlZEFycmF5VGFnc1tyZWdleHBUYWddPXR5cGVkQXJyYXlUYWdzW3NldFRhZ109dHlwZWRBcnJheVRhZ3Nbc3RyaW5nVGFnXT10eXBlZEFycmF5VGFnc1t3ZWFrTWFwVGFnXT1mYWxzZTsvKiogVXNlZCB0byBpZGVudGlmeSBgdG9TdHJpbmdUYWdgIHZhbHVlcyBzdXBwb3J0ZWQgYnkgYF8uY2xvbmVgLiAqL3ZhciBjbG9uZWFibGVUYWdzPXt9O2Nsb25lYWJsZVRhZ3NbYXJnc1RhZ109Y2xvbmVhYmxlVGFnc1thcnJheVRhZ109Y2xvbmVhYmxlVGFnc1thcnJheUJ1ZmZlclRhZ109Y2xvbmVhYmxlVGFnc1tkYXRhVmlld1RhZ109Y2xvbmVhYmxlVGFnc1tib29sVGFnXT1jbG9uZWFibGVUYWdzW2RhdGVUYWddPWNsb25lYWJsZVRhZ3NbZmxvYXQzMlRhZ109Y2xvbmVhYmxlVGFnc1tmbG9hdDY0VGFnXT1jbG9uZWFibGVUYWdzW2ludDhUYWddPWNsb25lYWJsZVRhZ3NbaW50MTZUYWddPWNsb25lYWJsZVRhZ3NbaW50MzJUYWddPWNsb25lYWJsZVRhZ3NbbWFwVGFnXT1jbG9uZWFibGVUYWdzW251bWJlclRhZ109Y2xvbmVhYmxlVGFnc1tvYmplY3RUYWddPWNsb25lYWJsZVRhZ3NbcmVnZXhwVGFnXT1jbG9uZWFibGVUYWdzW3NldFRhZ109Y2xvbmVhYmxlVGFnc1tzdHJpbmdUYWddPWNsb25lYWJsZVRhZ3Nbc3ltYm9sVGFnXT1jbG9uZWFibGVUYWdzW3VpbnQ4VGFnXT1jbG9uZWFibGVUYWdzW3VpbnQ4Q2xhbXBlZFRhZ109Y2xvbmVhYmxlVGFnc1t1aW50MTZUYWddPWNsb25lYWJsZVRhZ3NbdWludDMyVGFnXT10cnVlO2Nsb25lYWJsZVRhZ3NbZXJyb3JUYWddPWNsb25lYWJsZVRhZ3NbZnVuY1RhZ109Y2xvbmVhYmxlVGFnc1t3ZWFrTWFwVGFnXT1mYWxzZTsvKiogVXNlZCB0byBtYXAgTGF0aW4gVW5pY29kZSBsZXR0ZXJzIHRvIGJhc2ljIExhdGluIGxldHRlcnMuICovdmFyIGRlYnVycmVkTGV0dGVycz17Ly8gTGF0aW4tMSBTdXBwbGVtZW50IGJsb2NrLlxuJ1xceGMwJzonQScsJ1xceGMxJzonQScsJ1xceGMyJzonQScsJ1xceGMzJzonQScsJ1xceGM0JzonQScsJ1xceGM1JzonQScsJ1xceGUwJzonYScsJ1xceGUxJzonYScsJ1xceGUyJzonYScsJ1xceGUzJzonYScsJ1xceGU0JzonYScsJ1xceGU1JzonYScsJ1xceGM3JzonQycsJ1xceGU3JzonYycsJ1xceGQwJzonRCcsJ1xceGYwJzonZCcsJ1xceGM4JzonRScsJ1xceGM5JzonRScsJ1xceGNhJzonRScsJ1xceGNiJzonRScsJ1xceGU4JzonZScsJ1xceGU5JzonZScsJ1xceGVhJzonZScsJ1xceGViJzonZScsJ1xceGNjJzonSScsJ1xceGNkJzonSScsJ1xceGNlJzonSScsJ1xceGNmJzonSScsJ1xceGVjJzonaScsJ1xceGVkJzonaScsJ1xceGVlJzonaScsJ1xceGVmJzonaScsJ1xceGQxJzonTicsJ1xceGYxJzonbicsJ1xceGQyJzonTycsJ1xceGQzJzonTycsJ1xceGQ0JzonTycsJ1xceGQ1JzonTycsJ1xceGQ2JzonTycsJ1xceGQ4JzonTycsJ1xceGYyJzonbycsJ1xceGYzJzonbycsJ1xceGY0JzonbycsJ1xceGY1JzonbycsJ1xceGY2JzonbycsJ1xceGY4JzonbycsJ1xceGQ5JzonVScsJ1xceGRhJzonVScsJ1xceGRiJzonVScsJ1xceGRjJzonVScsJ1xceGY5JzondScsJ1xceGZhJzondScsJ1xceGZiJzondScsJ1xceGZjJzondScsJ1xceGRkJzonWScsJ1xceGZkJzoneScsJ1xceGZmJzoneScsJ1xceGM2JzonQWUnLCdcXHhlNic6J2FlJywnXFx4ZGUnOidUaCcsJ1xceGZlJzondGgnLCdcXHhkZic6J3NzJywvLyBMYXRpbiBFeHRlbmRlZC1BIGJsb2NrLlxuJ1xcdTAxMDAnOidBJywnXFx1MDEwMic6J0EnLCdcXHUwMTA0JzonQScsJ1xcdTAxMDEnOidhJywnXFx1MDEwMyc6J2EnLCdcXHUwMTA1JzonYScsJ1xcdTAxMDYnOidDJywnXFx1MDEwOCc6J0MnLCdcXHUwMTBhJzonQycsJ1xcdTAxMGMnOidDJywnXFx1MDEwNyc6J2MnLCdcXHUwMTA5JzonYycsJ1xcdTAxMGInOidjJywnXFx1MDEwZCc6J2MnLCdcXHUwMTBlJzonRCcsJ1xcdTAxMTAnOidEJywnXFx1MDEwZic6J2QnLCdcXHUwMTExJzonZCcsJ1xcdTAxMTInOidFJywnXFx1MDExNCc6J0UnLCdcXHUwMTE2JzonRScsJ1xcdTAxMTgnOidFJywnXFx1MDExYSc6J0UnLCdcXHUwMTEzJzonZScsJ1xcdTAxMTUnOidlJywnXFx1MDExNyc6J2UnLCdcXHUwMTE5JzonZScsJ1xcdTAxMWInOidlJywnXFx1MDExYyc6J0cnLCdcXHUwMTFlJzonRycsJ1xcdTAxMjAnOidHJywnXFx1MDEyMic6J0cnLCdcXHUwMTFkJzonZycsJ1xcdTAxMWYnOidnJywnXFx1MDEyMSc6J2cnLCdcXHUwMTIzJzonZycsJ1xcdTAxMjQnOidIJywnXFx1MDEyNic6J0gnLCdcXHUwMTI1JzonaCcsJ1xcdTAxMjcnOidoJywnXFx1MDEyOCc6J0knLCdcXHUwMTJhJzonSScsJ1xcdTAxMmMnOidJJywnXFx1MDEyZSc6J0knLCdcXHUwMTMwJzonSScsJ1xcdTAxMjknOidpJywnXFx1MDEyYic6J2knLCdcXHUwMTJkJzonaScsJ1xcdTAxMmYnOidpJywnXFx1MDEzMSc6J2knLCdcXHUwMTM0JzonSicsJ1xcdTAxMzUnOidqJywnXFx1MDEzNic6J0snLCdcXHUwMTM3JzonaycsJ1xcdTAxMzgnOidrJywnXFx1MDEzOSc6J0wnLCdcXHUwMTNiJzonTCcsJ1xcdTAxM2QnOidMJywnXFx1MDEzZic6J0wnLCdcXHUwMTQxJzonTCcsJ1xcdTAxM2EnOidsJywnXFx1MDEzYyc6J2wnLCdcXHUwMTNlJzonbCcsJ1xcdTAxNDAnOidsJywnXFx1MDE0Mic6J2wnLCdcXHUwMTQzJzonTicsJ1xcdTAxNDUnOidOJywnXFx1MDE0Nyc6J04nLCdcXHUwMTRhJzonTicsJ1xcdTAxNDQnOiduJywnXFx1MDE0Nic6J24nLCdcXHUwMTQ4JzonbicsJ1xcdTAxNGInOiduJywnXFx1MDE0Yyc6J08nLCdcXHUwMTRlJzonTycsJ1xcdTAxNTAnOidPJywnXFx1MDE0ZCc6J28nLCdcXHUwMTRmJzonbycsJ1xcdTAxNTEnOidvJywnXFx1MDE1NCc6J1InLCdcXHUwMTU2JzonUicsJ1xcdTAxNTgnOidSJywnXFx1MDE1NSc6J3InLCdcXHUwMTU3JzoncicsJ1xcdTAxNTknOidyJywnXFx1MDE1YSc6J1MnLCdcXHUwMTVjJzonUycsJ1xcdTAxNWUnOidTJywnXFx1MDE2MCc6J1MnLCdcXHUwMTViJzoncycsJ1xcdTAxNWQnOidzJywnXFx1MDE1Zic6J3MnLCdcXHUwMTYxJzoncycsJ1xcdTAxNjInOidUJywnXFx1MDE2NCc6J1QnLCdcXHUwMTY2JzonVCcsJ1xcdTAxNjMnOid0JywnXFx1MDE2NSc6J3QnLCdcXHUwMTY3JzondCcsJ1xcdTAxNjgnOidVJywnXFx1MDE2YSc6J1UnLCdcXHUwMTZjJzonVScsJ1xcdTAxNmUnOidVJywnXFx1MDE3MCc6J1UnLCdcXHUwMTcyJzonVScsJ1xcdTAxNjknOid1JywnXFx1MDE2Yic6J3UnLCdcXHUwMTZkJzondScsJ1xcdTAxNmYnOid1JywnXFx1MDE3MSc6J3UnLCdcXHUwMTczJzondScsJ1xcdTAxNzQnOidXJywnXFx1MDE3NSc6J3cnLCdcXHUwMTc2JzonWScsJ1xcdTAxNzcnOid5JywnXFx1MDE3OCc6J1knLCdcXHUwMTc5JzonWicsJ1xcdTAxN2InOidaJywnXFx1MDE3ZCc6J1onLCdcXHUwMTdhJzoneicsJ1xcdTAxN2MnOid6JywnXFx1MDE3ZSc6J3onLCdcXHUwMTMyJzonSUonLCdcXHUwMTMzJzonaWonLCdcXHUwMTUyJzonT2UnLCdcXHUwMTUzJzonb2UnLCdcXHUwMTQ5JzpcIiduXCIsJ1xcdTAxN2YnOidzJ307LyoqIFVzZWQgdG8gbWFwIGNoYXJhY3RlcnMgdG8gSFRNTCBlbnRpdGllcy4gKi92YXIgaHRtbEVzY2FwZXM9eycmJzonJmFtcDsnLCc8JzonJmx0OycsJz4nOicmZ3Q7JywnXCInOicmcXVvdDsnLFwiJ1wiOicmIzM5Oyd9Oy8qKiBVc2VkIHRvIG1hcCBIVE1MIGVudGl0aWVzIHRvIGNoYXJhY3RlcnMuICovdmFyIGh0bWxVbmVzY2FwZXM9eycmYW1wOyc6JyYnLCcmbHQ7JzonPCcsJyZndDsnOic+JywnJnF1b3Q7JzonXCInLCcmIzM5Oyc6XCInXCJ9Oy8qKiBVc2VkIHRvIGVzY2FwZSBjaGFyYWN0ZXJzIGZvciBpbmNsdXNpb24gaW4gY29tcGlsZWQgc3RyaW5nIGxpdGVyYWxzLiAqL3ZhciBzdHJpbmdFc2NhcGVzPXsnXFxcXCc6J1xcXFwnLFwiJ1wiOlwiJ1wiLCdcXG4nOiduJywnXFxyJzoncicsJ1xcdTIwMjgnOid1MjAyOCcsJ1xcdTIwMjknOid1MjAyOSd9Oy8qKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB3aXRob3V0IGEgZGVwZW5kZW5jeSBvbiBgcm9vdGAuICovdmFyIGZyZWVQYXJzZUZsb2F0PXBhcnNlRmxvYXQsZnJlZVBhcnNlSW50PXBhcnNlSW50Oy8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCBmcm9tIE5vZGUuanMuICovdmFyIGZyZWVHbG9iYWw9dHlwZW9mIGdsb2JhbD09J29iamVjdCcmJmdsb2JhbCYmZ2xvYmFsLk9iamVjdD09PU9iamVjdCYmZ2xvYmFsOy8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgc2VsZmAuICovdmFyIGZyZWVTZWxmPXR5cGVvZiBzZWxmPT0nb2JqZWN0JyYmc2VsZiYmc2VsZi5PYmplY3Q9PT1PYmplY3QmJnNlbGY7LyoqIFVzZWQgYXMgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QuICovdmFyIHJvb3Q9ZnJlZUdsb2JhbHx8ZnJlZVNlbGZ8fEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7LyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi92YXIgZnJlZUV4cG9ydHM9dHlwZW9mIGV4cG9ydHM9PSdvYmplY3QnJiZleHBvcnRzJiYhZXhwb3J0cy5ub2RlVHlwZSYmZXhwb3J0czsvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovdmFyIGZyZWVNb2R1bGU9ZnJlZUV4cG9ydHMmJnR5cGVvZiBtb2R1bGU9PSdvYmplY3QnJiZtb2R1bGUmJiFtb2R1bGUubm9kZVR5cGUmJm1vZHVsZTsvKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL3ZhciBtb2R1bGVFeHBvcnRzPWZyZWVNb2R1bGUmJmZyZWVNb2R1bGUuZXhwb3J0cz09PWZyZWVFeHBvcnRzOy8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgcHJvY2Vzc2AgZnJvbSBOb2RlLmpzLiAqL3ZhciBmcmVlUHJvY2Vzcz1tb2R1bGVFeHBvcnRzJiZmcmVlR2xvYmFsLnByb2Nlc3M7LyoqIFVzZWQgdG8gYWNjZXNzIGZhc3RlciBOb2RlLmpzIGhlbHBlcnMuICovdmFyIG5vZGVVdGlsPWZ1bmN0aW9uKCl7dHJ5e3JldHVybiBmcmVlUHJvY2VzcyYmZnJlZVByb2Nlc3MuYmluZGluZyYmZnJlZVByb2Nlc3MuYmluZGluZygndXRpbCcpO31jYXRjaChlKXt9fSgpOy8qIE5vZGUuanMgaGVscGVyIHJlZmVyZW5jZXMuICovdmFyIG5vZGVJc0FycmF5QnVmZmVyPW5vZGVVdGlsJiZub2RlVXRpbC5pc0FycmF5QnVmZmVyLG5vZGVJc0RhdGU9bm9kZVV0aWwmJm5vZGVVdGlsLmlzRGF0ZSxub2RlSXNNYXA9bm9kZVV0aWwmJm5vZGVVdGlsLmlzTWFwLG5vZGVJc1JlZ0V4cD1ub2RlVXRpbCYmbm9kZVV0aWwuaXNSZWdFeHAsbm9kZUlzU2V0PW5vZGVVdGlsJiZub2RlVXRpbC5pc1NldCxub2RlSXNUeXBlZEFycmF5PW5vZGVVdGlsJiZub2RlVXRpbC5pc1R5cGVkQXJyYXk7LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovLyoqXG4gICAqIEFkZHMgdGhlIGtleS12YWx1ZSBgcGFpcmAgdG8gYG1hcGAuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgVGhlIG1hcCB0byBtb2RpZnkuXG4gICAqIEBwYXJhbSB7QXJyYXl9IHBhaXIgVGhlIGtleS12YWx1ZSBwYWlyIHRvIGFkZC5cbiAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgbWFwYC5cbiAgICovZnVuY3Rpb24gYWRkTWFwRW50cnkobWFwLHBhaXIpey8vIERvbid0IHJldHVybiBgbWFwLnNldGAgYmVjYXVzZSBpdCdzIG5vdCBjaGFpbmFibGUgaW4gSUUgMTEuXG5tYXAuc2V0KHBhaXJbMF0scGFpclsxXSk7cmV0dXJuIG1hcDt9LyoqXG4gICAqIEFkZHMgYHZhbHVlYCB0byBgc2V0YC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IHNldCBUaGUgc2V0IHRvIG1vZGlmeS5cbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYWRkLlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBzZXRgLlxuICAgKi9mdW5jdGlvbiBhZGRTZXRFbnRyeShzZXQsdmFsdWUpey8vIERvbid0IHJldHVybiBgc2V0LmFkZGAgYmVjYXVzZSBpdCdzIG5vdCBjaGFpbmFibGUgaW4gSUUgMTEuXG5zZXQuYWRkKHZhbHVlKTtyZXR1cm4gc2V0O30vKipcbiAgICogQSBmYXN0ZXIgYWx0ZXJuYXRpdmUgdG8gYEZ1bmN0aW9uI2FwcGx5YCwgdGhpcyBmdW5jdGlvbiBpbnZva2VzIGBmdW5jYFxuICAgKiB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiBgdGhpc0FyZ2AgYW5kIHRoZSBhcmd1bWVudHMgb2YgYGFyZ3NgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBpbnZva2UuXG4gICAqIEBwYXJhbSB7Kn0gdGhpc0FyZyBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICAgKiBAcGFyYW0ge0FycmF5fSBhcmdzIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIGBmdW5jYCB3aXRoLlxuICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzdWx0IG9mIGBmdW5jYC5cbiAgICovZnVuY3Rpb24gYXBwbHkoZnVuYyx0aGlzQXJnLGFyZ3Mpe3N3aXRjaChhcmdzLmxlbmd0aCl7Y2FzZSAwOnJldHVybiBmdW5jLmNhbGwodGhpc0FyZyk7Y2FzZSAxOnJldHVybiBmdW5jLmNhbGwodGhpc0FyZyxhcmdzWzBdKTtjYXNlIDI6cmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLGFyZ3NbMF0sYXJnc1sxXSk7Y2FzZSAzOnJldHVybiBmdW5jLmNhbGwodGhpc0FyZyxhcmdzWzBdLGFyZ3NbMV0sYXJnc1syXSk7fXJldHVybiBmdW5jLmFwcGx5KHRoaXNBcmcsYXJncyk7fS8qKlxuICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VBZ2dyZWdhdG9yYCBmb3IgYXJyYXlzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHNldHRlciBUaGUgZnVuY3Rpb24gdG8gc2V0IGBhY2N1bXVsYXRvcmAgdmFsdWVzLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgaXRlcmF0ZWUgdG8gdHJhbnNmb3JtIGtleXMuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhY2N1bXVsYXRvciBUaGUgaW5pdGlhbCBhZ2dyZWdhdGVkIG9iamVjdC5cbiAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBhY2N1bXVsYXRvcmAuXG4gICAqL2Z1bmN0aW9uIGFycmF5QWdncmVnYXRvcihhcnJheSxzZXR0ZXIsaXRlcmF0ZWUsYWNjdW11bGF0b3Ipe3ZhciBpbmRleD0tMSxsZW5ndGg9YXJyYXk9PW51bGw/MDphcnJheS5sZW5ndGg7d2hpbGUoKytpbmRleDxsZW5ndGgpe3ZhciB2YWx1ZT1hcnJheVtpbmRleF07c2V0dGVyKGFjY3VtdWxhdG9yLHZhbHVlLGl0ZXJhdGVlKHZhbHVlKSxhcnJheSk7fXJldHVybiBhY2N1bXVsYXRvcjt9LyoqXG4gICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5mb3JFYWNoYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAgICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICovZnVuY3Rpb24gYXJyYXlFYWNoKGFycmF5LGl0ZXJhdGVlKXt2YXIgaW5kZXg9LTEsbGVuZ3RoPWFycmF5PT1udWxsPzA6YXJyYXkubGVuZ3RoO3doaWxlKCsraW5kZXg8bGVuZ3RoKXtpZihpdGVyYXRlZShhcnJheVtpbmRleF0saW5kZXgsYXJyYXkpPT09ZmFsc2Upe2JyZWFrO319cmV0dXJuIGFycmF5O30vKipcbiAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmZvckVhY2hSaWdodGAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gICAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAqL2Z1bmN0aW9uIGFycmF5RWFjaFJpZ2h0KGFycmF5LGl0ZXJhdGVlKXt2YXIgbGVuZ3RoPWFycmF5PT1udWxsPzA6YXJyYXkubGVuZ3RoO3doaWxlKGxlbmd0aC0tKXtpZihpdGVyYXRlZShhcnJheVtsZW5ndGhdLGxlbmd0aCxhcnJheSk9PT1mYWxzZSl7YnJlYWs7fX1yZXR1cm4gYXJyYXk7fS8qKlxuICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uZXZlcnlgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICAgKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYWxsIGVsZW1lbnRzIHBhc3MgdGhlIHByZWRpY2F0ZSBjaGVjayxcbiAgICogIGVsc2UgYGZhbHNlYC5cbiAgICovZnVuY3Rpb24gYXJyYXlFdmVyeShhcnJheSxwcmVkaWNhdGUpe3ZhciBpbmRleD0tMSxsZW5ndGg9YXJyYXk9PW51bGw/MDphcnJheS5sZW5ndGg7d2hpbGUoKytpbmRleDxsZW5ndGgpe2lmKCFwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLGluZGV4LGFycmF5KSl7cmV0dXJuIGZhbHNlO319cmV0dXJuIHRydWU7fS8qKlxuICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uZmlsdGVyYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAgICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmlsdGVyZWQgYXJyYXkuXG4gICAqL2Z1bmN0aW9uIGFycmF5RmlsdGVyKGFycmF5LHByZWRpY2F0ZSl7dmFyIGluZGV4PS0xLGxlbmd0aD1hcnJheT09bnVsbD8wOmFycmF5Lmxlbmd0aCxyZXNJbmRleD0wLHJlc3VsdD1bXTt3aGlsZSgrK2luZGV4PGxlbmd0aCl7dmFyIHZhbHVlPWFycmF5W2luZGV4XTtpZihwcmVkaWNhdGUodmFsdWUsaW5kZXgsYXJyYXkpKXtyZXN1bHRbcmVzSW5kZXgrK109dmFsdWU7fX1yZXR1cm4gcmVzdWx0O30vKipcbiAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmluY2x1ZGVzYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAgICogc3BlY2lmeWluZyBhbiBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICogQHBhcmFtIHsqfSB0YXJnZXQgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdGFyZ2V0YCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICAgKi9mdW5jdGlvbiBhcnJheUluY2x1ZGVzKGFycmF5LHZhbHVlKXt2YXIgbGVuZ3RoPWFycmF5PT1udWxsPzA6YXJyYXkubGVuZ3RoO3JldHVybiEhbGVuZ3RoJiZiYXNlSW5kZXhPZihhcnJheSx2YWx1ZSwwKT4tMTt9LyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZSBgYXJyYXlJbmNsdWRlc2AgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBhIGNvbXBhcmF0b3IuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAqIEBwYXJhbSB7Kn0gdGFyZ2V0IFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb21wYXJhdG9yIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdGFyZ2V0YCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICAgKi9mdW5jdGlvbiBhcnJheUluY2x1ZGVzV2l0aChhcnJheSx2YWx1ZSxjb21wYXJhdG9yKXt2YXIgaW5kZXg9LTEsbGVuZ3RoPWFycmF5PT1udWxsPzA6YXJyYXkubGVuZ3RoO3doaWxlKCsraW5kZXg8bGVuZ3RoKXtpZihjb21wYXJhdG9yKHZhbHVlLGFycmF5W2luZGV4XSkpe3JldHVybiB0cnVlO319cmV0dXJuIGZhbHNlO30vKipcbiAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLm1hcGAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlXG4gICAqIHNob3J0aGFuZHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIGFycmF5LlxuICAgKi9mdW5jdGlvbiBhcnJheU1hcChhcnJheSxpdGVyYXRlZSl7dmFyIGluZGV4PS0xLGxlbmd0aD1hcnJheT09bnVsbD8wOmFycmF5Lmxlbmd0aCxyZXN1bHQ9QXJyYXkobGVuZ3RoKTt3aGlsZSgrK2luZGV4PGxlbmd0aCl7cmVzdWx0W2luZGV4XT1pdGVyYXRlZShhcnJheVtpbmRleF0saW5kZXgsYXJyYXkpO31yZXR1cm4gcmVzdWx0O30vKipcbiAgICogQXBwZW5kcyB0aGUgZWxlbWVudHMgb2YgYHZhbHVlc2AgdG8gYGFycmF5YC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAgICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gYXBwZW5kLlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICovZnVuY3Rpb24gYXJyYXlQdXNoKGFycmF5LHZhbHVlcyl7dmFyIGluZGV4PS0xLGxlbmd0aD12YWx1ZXMubGVuZ3RoLG9mZnNldD1hcnJheS5sZW5ndGg7d2hpbGUoKytpbmRleDxsZW5ndGgpe2FycmF5W29mZnNldCtpbmRleF09dmFsdWVzW2luZGV4XTt9cmV0dXJuIGFycmF5O30vKipcbiAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnJlZHVjZWAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gICAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHBhcmFtIHsqfSBbYWNjdW11bGF0b3JdIFRoZSBpbml0aWFsIHZhbHVlLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpbml0QWNjdW1dIFNwZWNpZnkgdXNpbmcgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYGFycmF5YCBhc1xuICAgKiAgdGhlIGluaXRpYWwgdmFsdWUuXG4gICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAgICovZnVuY3Rpb24gYXJyYXlSZWR1Y2UoYXJyYXksaXRlcmF0ZWUsYWNjdW11bGF0b3IsaW5pdEFjY3VtKXt2YXIgaW5kZXg9LTEsbGVuZ3RoPWFycmF5PT1udWxsPzA6YXJyYXkubGVuZ3RoO2lmKGluaXRBY2N1bSYmbGVuZ3RoKXthY2N1bXVsYXRvcj1hcnJheVsrK2luZGV4XTt9d2hpbGUoKytpbmRleDxsZW5ndGgpe2FjY3VtdWxhdG9yPWl0ZXJhdGVlKGFjY3VtdWxhdG9yLGFycmF5W2luZGV4XSxpbmRleCxhcnJheSk7fXJldHVybiBhY2N1bXVsYXRvcjt9LyoqXG4gICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5yZWR1Y2VSaWdodGAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gICAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHBhcmFtIHsqfSBbYWNjdW11bGF0b3JdIFRoZSBpbml0aWFsIHZhbHVlLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpbml0QWNjdW1dIFNwZWNpZnkgdXNpbmcgdGhlIGxhc3QgZWxlbWVudCBvZiBgYXJyYXlgIGFzXG4gICAqICB0aGUgaW5pdGlhbCB2YWx1ZS5cbiAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGFjY3VtdWxhdGVkIHZhbHVlLlxuICAgKi9mdW5jdGlvbiBhcnJheVJlZHVjZVJpZ2h0KGFycmF5LGl0ZXJhdGVlLGFjY3VtdWxhdG9yLGluaXRBY2N1bSl7dmFyIGxlbmd0aD1hcnJheT09bnVsbD8wOmFycmF5Lmxlbmd0aDtpZihpbml0QWNjdW0mJmxlbmd0aCl7YWNjdW11bGF0b3I9YXJyYXlbLS1sZW5ndGhdO313aGlsZShsZW5ndGgtLSl7YWNjdW11bGF0b3I9aXRlcmF0ZWUoYWNjdW11bGF0b3IsYXJyYXlbbGVuZ3RoXSxsZW5ndGgsYXJyYXkpO31yZXR1cm4gYWNjdW11bGF0b3I7fS8qKlxuICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uc29tZWAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlXG4gICAqIHNob3J0aGFuZHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbnkgZWxlbWVudCBwYXNzZXMgdGhlIHByZWRpY2F0ZSBjaGVjayxcbiAgICogIGVsc2UgYGZhbHNlYC5cbiAgICovZnVuY3Rpb24gYXJyYXlTb21lKGFycmF5LHByZWRpY2F0ZSl7dmFyIGluZGV4PS0xLGxlbmd0aD1hcnJheT09bnVsbD8wOmFycmF5Lmxlbmd0aDt3aGlsZSgrK2luZGV4PGxlbmd0aCl7aWYocHJlZGljYXRlKGFycmF5W2luZGV4XSxpbmRleCxhcnJheSkpe3JldHVybiB0cnVlO319cmV0dXJuIGZhbHNlO30vKipcbiAgICogR2V0cyB0aGUgc2l6ZSBvZiBhbiBBU0NJSSBgc3RyaW5nYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIGluc3BlY3QuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHN0cmluZyBzaXplLlxuICAgKi92YXIgYXNjaWlTaXplPWJhc2VQcm9wZXJ0eSgnbGVuZ3RoJyk7LyoqXG4gICAqIENvbnZlcnRzIGFuIEFTQ0lJIGBzdHJpbmdgIHRvIGFuIGFycmF5LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgYXJyYXkuXG4gICAqL2Z1bmN0aW9uIGFzY2lpVG9BcnJheShzdHJpbmcpe3JldHVybiBzdHJpbmcuc3BsaXQoJycpO30vKipcbiAgICogU3BsaXRzIGFuIEFTQ0lJIGBzdHJpbmdgIGludG8gYW4gYXJyYXkgb2YgaXRzIHdvcmRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHdvcmRzIG9mIGBzdHJpbmdgLlxuICAgKi9mdW5jdGlvbiBhc2NpaVdvcmRzKHN0cmluZyl7cmV0dXJuIHN0cmluZy5tYXRjaChyZUFzY2lpV29yZCl8fFtdO30vKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgbWV0aG9kcyBsaWtlIGBfLmZpbmRLZXlgIGFuZCBgXy5maW5kTGFzdEtleWAsXG4gICAqIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcywgd2hpY2ggaXRlcmF0ZXMgb3ZlciBgY29sbGVjdGlvbmBcbiAgICogdXNpbmcgYGVhY2hGdW5jYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaW5zcGVjdC5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGVhY2hGdW5jIFRoZSBmdW5jdGlvbiB0byBpdGVyYXRlIG92ZXIgYGNvbGxlY3Rpb25gLlxuICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZm91bmQgZWxlbWVudCBvciBpdHMga2V5LCBlbHNlIGB1bmRlZmluZWRgLlxuICAgKi9mdW5jdGlvbiBiYXNlRmluZEtleShjb2xsZWN0aW9uLHByZWRpY2F0ZSxlYWNoRnVuYyl7dmFyIHJlc3VsdDtlYWNoRnVuYyhjb2xsZWN0aW9uLGZ1bmN0aW9uKHZhbHVlLGtleSxjb2xsZWN0aW9uKXtpZihwcmVkaWNhdGUodmFsdWUsa2V5LGNvbGxlY3Rpb24pKXtyZXN1bHQ9a2V5O3JldHVybiBmYWxzZTt9fSk7cmV0dXJuIHJlc3VsdDt9LyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZpbmRJbmRleGAgYW5kIGBfLmZpbmRMYXN0SW5kZXhgIHdpdGhvdXRcbiAgICogc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gICAqL2Z1bmN0aW9uIGJhc2VGaW5kSW5kZXgoYXJyYXkscHJlZGljYXRlLGZyb21JbmRleCxmcm9tUmlnaHQpe3ZhciBsZW5ndGg9YXJyYXkubGVuZ3RoLGluZGV4PWZyb21JbmRleCsoZnJvbVJpZ2h0PzE6LTEpO3doaWxlKGZyb21SaWdodD9pbmRleC0tOisraW5kZXg8bGVuZ3RoKXtpZihwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLGluZGV4LGFycmF5KSl7cmV0dXJuIGluZGV4O319cmV0dXJuLTE7fS8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pbmRleE9mYCB3aXRob3V0IGBmcm9tSW5kZXhgIGJvdW5kcyBjaGVja3MuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICAgKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAgICovZnVuY3Rpb24gYmFzZUluZGV4T2YoYXJyYXksdmFsdWUsZnJvbUluZGV4KXtyZXR1cm4gdmFsdWU9PT12YWx1ZT9zdHJpY3RJbmRleE9mKGFycmF5LHZhbHVlLGZyb21JbmRleCk6YmFzZUZpbmRJbmRleChhcnJheSxiYXNlSXNOYU4sZnJvbUluZGV4KTt9LyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZSBgYmFzZUluZGV4T2ZgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYSBjb21wYXJhdG9yLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbXBhcmF0b3IgVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAgICovZnVuY3Rpb24gYmFzZUluZGV4T2ZXaXRoKGFycmF5LHZhbHVlLGZyb21JbmRleCxjb21wYXJhdG9yKXt2YXIgaW5kZXg9ZnJvbUluZGV4LTEsbGVuZ3RoPWFycmF5Lmxlbmd0aDt3aGlsZSgrK2luZGV4PGxlbmd0aCl7aWYoY29tcGFyYXRvcihhcnJheVtpbmRleF0sdmFsdWUpKXtyZXR1cm4gaW5kZXg7fX1yZXR1cm4tMTt9LyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTmFOYCB3aXRob3V0IHN1cHBvcnQgZm9yIG51bWJlciBvYmplY3RzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYE5hTmAsIGVsc2UgYGZhbHNlYC5cbiAgICovZnVuY3Rpb24gYmFzZUlzTmFOKHZhbHVlKXtyZXR1cm4gdmFsdWUhPT12YWx1ZTt9LyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1lYW5gIGFuZCBgXy5tZWFuQnlgIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAgICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgbWVhbi5cbiAgICovZnVuY3Rpb24gYmFzZU1lYW4oYXJyYXksaXRlcmF0ZWUpe3ZhciBsZW5ndGg9YXJyYXk9PW51bGw/MDphcnJheS5sZW5ndGg7cmV0dXJuIGxlbmd0aD9iYXNlU3VtKGFycmF5LGl0ZXJhdGVlKS9sZW5ndGg6TkFOO30vKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucHJvcGVydHlgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVlcCBwYXRocy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICAgKi9mdW5jdGlvbiBiYXNlUHJvcGVydHkoa2V5KXtyZXR1cm4gZnVuY3Rpb24ob2JqZWN0KXtyZXR1cm4gb2JqZWN0PT1udWxsP3VuZGVmaW5lZDpvYmplY3Rba2V5XTt9O30vKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucHJvcGVydHlPZmAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICAgKi9mdW5jdGlvbiBiYXNlUHJvcGVydHlPZihvYmplY3Qpe3JldHVybiBmdW5jdGlvbihrZXkpe3JldHVybiBvYmplY3Q9PW51bGw/dW5kZWZpbmVkOm9iamVjdFtrZXldO307fS8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5yZWR1Y2VgIGFuZCBgXy5yZWR1Y2VSaWdodGAsIHdpdGhvdXQgc3VwcG9ydFxuICAgKiBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcywgd2hpY2ggaXRlcmF0ZXMgb3ZlciBgY29sbGVjdGlvbmAgdXNpbmcgYGVhY2hGdW5jYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcGFyYW0geyp9IGFjY3VtdWxhdG9yIFRoZSBpbml0aWFsIHZhbHVlLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGluaXRBY2N1bSBTcGVjaWZ5IHVzaW5nIHRoZSBmaXJzdCBvciBsYXN0IGVsZW1lbnQgb2ZcbiAgICogIGBjb2xsZWN0aW9uYCBhcyB0aGUgaW5pdGlhbCB2YWx1ZS5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZWFjaEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGl0ZXJhdGUgb3ZlciBgY29sbGVjdGlvbmAuXG4gICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAgICovZnVuY3Rpb24gYmFzZVJlZHVjZShjb2xsZWN0aW9uLGl0ZXJhdGVlLGFjY3VtdWxhdG9yLGluaXRBY2N1bSxlYWNoRnVuYyl7ZWFjaEZ1bmMoY29sbGVjdGlvbixmdW5jdGlvbih2YWx1ZSxpbmRleCxjb2xsZWN0aW9uKXthY2N1bXVsYXRvcj1pbml0QWNjdW0/KGluaXRBY2N1bT1mYWxzZSx2YWx1ZSk6aXRlcmF0ZWUoYWNjdW11bGF0b3IsdmFsdWUsaW5kZXgsY29sbGVjdGlvbik7fSk7cmV0dXJuIGFjY3VtdWxhdG9yO30vKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc29ydEJ5YCB3aGljaCB1c2VzIGBjb21wYXJlcmAgdG8gZGVmaW5lIHRoZVxuICAgKiBzb3J0IG9yZGVyIG9mIGBhcnJheWAgYW5kIHJlcGxhY2VzIGNyaXRlcmlhIG9iamVjdHMgd2l0aCB0aGVpciBjb3JyZXNwb25kaW5nXG4gICAqIHZhbHVlcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNvcnQuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbXBhcmVyIFRoZSBmdW5jdGlvbiB0byBkZWZpbmUgc29ydCBvcmRlci5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAqL2Z1bmN0aW9uIGJhc2VTb3J0QnkoYXJyYXksY29tcGFyZXIpe3ZhciBsZW5ndGg9YXJyYXkubGVuZ3RoO2FycmF5LnNvcnQoY29tcGFyZXIpO3doaWxlKGxlbmd0aC0tKXthcnJheVtsZW5ndGhdPWFycmF5W2xlbmd0aF0udmFsdWU7fXJldHVybiBhcnJheTt9LyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnN1bWAgYW5kIGBfLnN1bUJ5YCB3aXRob3V0IHN1cHBvcnQgZm9yXG4gICAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHN1bS5cbiAgICovZnVuY3Rpb24gYmFzZVN1bShhcnJheSxpdGVyYXRlZSl7dmFyIHJlc3VsdCxpbmRleD0tMSxsZW5ndGg9YXJyYXkubGVuZ3RoO3doaWxlKCsraW5kZXg8bGVuZ3RoKXt2YXIgY3VycmVudD1pdGVyYXRlZShhcnJheVtpbmRleF0pO2lmKGN1cnJlbnQhPT11bmRlZmluZWQpe3Jlc3VsdD1yZXN1bHQ9PT11bmRlZmluZWQ/Y3VycmVudDpyZXN1bHQrY3VycmVudDt9fXJldHVybiByZXN1bHQ7fS8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50aW1lc2Agd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzXG4gICAqIG9yIG1heCBhcnJheSBsZW5ndGggY2hlY2tzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIGludm9rZSBgaXRlcmF0ZWVgLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHJlc3VsdHMuXG4gICAqL2Z1bmN0aW9uIGJhc2VUaW1lcyhuLGl0ZXJhdGVlKXt2YXIgaW5kZXg9LTEscmVzdWx0PUFycmF5KG4pO3doaWxlKCsraW5kZXg8bil7cmVzdWx0W2luZGV4XT1pdGVyYXRlZShpbmRleCk7fXJldHVybiByZXN1bHQ7fS8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50b1BhaXJzYCBhbmQgYF8udG9QYWlyc0luYCB3aGljaCBjcmVhdGVzIGFuIGFycmF5XG4gICAqIG9mIGtleS12YWx1ZSBwYWlycyBmb3IgYG9iamVjdGAgY29ycmVzcG9uZGluZyB0byB0aGUgcHJvcGVydHkgbmFtZXMgb2YgYHByb3BzYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgKiBAcGFyYW0ge0FycmF5fSBwcm9wcyBUaGUgcHJvcGVydHkgbmFtZXMgdG8gZ2V0IHZhbHVlcyBmb3IuXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGtleS12YWx1ZSBwYWlycy5cbiAgICovZnVuY3Rpb24gYmFzZVRvUGFpcnMob2JqZWN0LHByb3BzKXtyZXR1cm4gYXJyYXlNYXAocHJvcHMsZnVuY3Rpb24oa2V5KXtyZXR1cm5ba2V5LG9iamVjdFtrZXldXTt9KTt9LyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnVuYXJ5YCB3aXRob3V0IHN1cHBvcnQgZm9yIHN0b3JpbmcgbWV0YWRhdGEuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNhcCBhcmd1bWVudHMgZm9yLlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjYXBwZWQgZnVuY3Rpb24uXG4gICAqL2Z1bmN0aW9uIGJhc2VVbmFyeShmdW5jKXtyZXR1cm4gZnVuY3Rpb24odmFsdWUpe3JldHVybiBmdW5jKHZhbHVlKTt9O30vKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udmFsdWVzYCBhbmQgYF8udmFsdWVzSW5gIHdoaWNoIGNyZWF0ZXMgYW5cbiAgICogYXJyYXkgb2YgYG9iamVjdGAgcHJvcGVydHkgdmFsdWVzIGNvcnJlc3BvbmRpbmcgdG8gdGhlIHByb3BlcnR5IG5hbWVzXG4gICAqIG9mIGBwcm9wc2AuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICogQHBhcmFtIHtBcnJheX0gcHJvcHMgVGhlIHByb3BlcnR5IG5hbWVzIHRvIGdldCB2YWx1ZXMgZm9yLlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAqL2Z1bmN0aW9uIGJhc2VWYWx1ZXMob2JqZWN0LHByb3BzKXtyZXR1cm4gYXJyYXlNYXAocHJvcHMsZnVuY3Rpb24oa2V5KXtyZXR1cm4gb2JqZWN0W2tleV07fSk7fS8qKlxuICAgKiBDaGVja3MgaWYgYSBgY2FjaGVgIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjYWNoZSBUaGUgY2FjaGUgdG8gcXVlcnkuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gICAqL2Z1bmN0aW9uIGNhY2hlSGFzKGNhY2hlLGtleSl7cmV0dXJuIGNhY2hlLmhhcyhrZXkpO30vKipcbiAgICogVXNlZCBieSBgXy50cmltYCBhbmQgYF8udHJpbVN0YXJ0YCB0byBnZXQgdGhlIGluZGV4IG9mIHRoZSBmaXJzdCBzdHJpbmcgc3ltYm9sXG4gICAqIHRoYXQgaXMgbm90IGZvdW5kIGluIHRoZSBjaGFyYWN0ZXIgc3ltYm9scy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gc3RyU3ltYm9scyBUaGUgc3RyaW5nIHN5bWJvbHMgdG8gaW5zcGVjdC5cbiAgICogQHBhcmFtIHtBcnJheX0gY2hyU3ltYm9scyBUaGUgY2hhcmFjdGVyIHN5bWJvbHMgdG8gZmluZC5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IHVubWF0Y2hlZCBzdHJpbmcgc3ltYm9sLlxuICAgKi9mdW5jdGlvbiBjaGFyc1N0YXJ0SW5kZXgoc3RyU3ltYm9scyxjaHJTeW1ib2xzKXt2YXIgaW5kZXg9LTEsbGVuZ3RoPXN0clN5bWJvbHMubGVuZ3RoO3doaWxlKCsraW5kZXg8bGVuZ3RoJiZiYXNlSW5kZXhPZihjaHJTeW1ib2xzLHN0clN5bWJvbHNbaW5kZXhdLDApPi0xKXt9cmV0dXJuIGluZGV4O30vKipcbiAgICogVXNlZCBieSBgXy50cmltYCBhbmQgYF8udHJpbUVuZGAgdG8gZ2V0IHRoZSBpbmRleCBvZiB0aGUgbGFzdCBzdHJpbmcgc3ltYm9sXG4gICAqIHRoYXQgaXMgbm90IGZvdW5kIGluIHRoZSBjaGFyYWN0ZXIgc3ltYm9scy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gc3RyU3ltYm9scyBUaGUgc3RyaW5nIHN5bWJvbHMgdG8gaW5zcGVjdC5cbiAgICogQHBhcmFtIHtBcnJheX0gY2hyU3ltYm9scyBUaGUgY2hhcmFjdGVyIHN5bWJvbHMgdG8gZmluZC5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGxhc3QgdW5tYXRjaGVkIHN0cmluZyBzeW1ib2wuXG4gICAqL2Z1bmN0aW9uIGNoYXJzRW5kSW5kZXgoc3RyU3ltYm9scyxjaHJTeW1ib2xzKXt2YXIgaW5kZXg9c3RyU3ltYm9scy5sZW5ndGg7d2hpbGUoaW5kZXgtLSYmYmFzZUluZGV4T2YoY2hyU3ltYm9scyxzdHJTeW1ib2xzW2luZGV4XSwwKT4tMSl7fXJldHVybiBpbmRleDt9LyoqXG4gICAqIEdldHMgdGhlIG51bWJlciBvZiBgcGxhY2Vob2xkZXJgIG9jY3VycmVuY2VzIGluIGBhcnJheWAuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgKiBAcGFyYW0geyp9IHBsYWNlaG9sZGVyIFRoZSBwbGFjZWhvbGRlciB0byBzZWFyY2ggZm9yLlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBwbGFjZWhvbGRlciBjb3VudC5cbiAgICovZnVuY3Rpb24gY291bnRIb2xkZXJzKGFycmF5LHBsYWNlaG9sZGVyKXt2YXIgbGVuZ3RoPWFycmF5Lmxlbmd0aCxyZXN1bHQ9MDt3aGlsZShsZW5ndGgtLSl7aWYoYXJyYXlbbGVuZ3RoXT09PXBsYWNlaG9sZGVyKXsrK3Jlc3VsdDt9fXJldHVybiByZXN1bHQ7fS8qKlxuICAgKiBVc2VkIGJ5IGBfLmRlYnVycmAgdG8gY29udmVydCBMYXRpbi0xIFN1cHBsZW1lbnQgYW5kIExhdGluIEV4dGVuZGVkLUFcbiAgICogbGV0dGVycyB0byBiYXNpYyBMYXRpbiBsZXR0ZXJzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gbGV0dGVyIFRoZSBtYXRjaGVkIGxldHRlciB0byBkZWJ1cnIuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGRlYnVycmVkIGxldHRlci5cbiAgICovdmFyIGRlYnVyckxldHRlcj1iYXNlUHJvcGVydHlPZihkZWJ1cnJlZExldHRlcnMpOy8qKlxuICAgKiBVc2VkIGJ5IGBfLmVzY2FwZWAgdG8gY29udmVydCBjaGFyYWN0ZXJzIHRvIEhUTUwgZW50aXRpZXMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjaHIgVGhlIG1hdGNoZWQgY2hhcmFjdGVyIHRvIGVzY2FwZS5cbiAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZXNjYXBlZCBjaGFyYWN0ZXIuXG4gICAqL3ZhciBlc2NhcGVIdG1sQ2hhcj1iYXNlUHJvcGVydHlPZihodG1sRXNjYXBlcyk7LyoqXG4gICAqIFVzZWQgYnkgYF8udGVtcGxhdGVgIHRvIGVzY2FwZSBjaGFyYWN0ZXJzIGZvciBpbmNsdXNpb24gaW4gY29tcGlsZWQgc3RyaW5nIGxpdGVyYWxzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2hyIFRoZSBtYXRjaGVkIGNoYXJhY3RlciB0byBlc2NhcGUuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGVzY2FwZWQgY2hhcmFjdGVyLlxuICAgKi9mdW5jdGlvbiBlc2NhcGVTdHJpbmdDaGFyKGNocil7cmV0dXJuJ1xcXFwnK3N0cmluZ0VzY2FwZXNbY2hyXTt9LyoqXG4gICAqIEdldHMgdGhlIHZhbHVlIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZS5cbiAgICovZnVuY3Rpb24gZ2V0VmFsdWUob2JqZWN0LGtleSl7cmV0dXJuIG9iamVjdD09bnVsbD91bmRlZmluZWQ6b2JqZWN0W2tleV07fS8qKlxuICAgKiBDaGVja3MgaWYgYHN0cmluZ2AgY29udGFpbnMgVW5pY29kZSBzeW1ib2xzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGEgc3ltYm9sIGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gICAqL2Z1bmN0aW9uIGhhc1VuaWNvZGUoc3RyaW5nKXtyZXR1cm4gcmVIYXNVbmljb2RlLnRlc3Qoc3RyaW5nKTt9LyoqXG4gICAqIENoZWNrcyBpZiBgc3RyaW5nYCBjb250YWlucyBhIHdvcmQgY29tcG9zZWQgb2YgVW5pY29kZSBzeW1ib2xzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGEgd29yZCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICAgKi9mdW5jdGlvbiBoYXNVbmljb2RlV29yZChzdHJpbmcpe3JldHVybiByZUhhc1VuaWNvZGVXb3JkLnRlc3Qoc3RyaW5nKTt9LyoqXG4gICAqIENvbnZlcnRzIGBpdGVyYXRvcmAgdG8gYW4gYXJyYXkuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBpdGVyYXRvciBUaGUgaXRlcmF0b3IgdG8gY29udmVydC5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgYXJyYXkuXG4gICAqL2Z1bmN0aW9uIGl0ZXJhdG9yVG9BcnJheShpdGVyYXRvcil7dmFyIGRhdGEscmVzdWx0PVtdO3doaWxlKCEoZGF0YT1pdGVyYXRvci5uZXh0KCkpLmRvbmUpe3Jlc3VsdC5wdXNoKGRhdGEudmFsdWUpO31yZXR1cm4gcmVzdWx0O30vKipcbiAgICogQ29udmVydHMgYG1hcGAgdG8gaXRzIGtleS12YWx1ZSBwYWlycy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIGNvbnZlcnQuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUga2V5LXZhbHVlIHBhaXJzLlxuICAgKi9mdW5jdGlvbiBtYXBUb0FycmF5KG1hcCl7dmFyIGluZGV4PS0xLHJlc3VsdD1BcnJheShtYXAuc2l6ZSk7bWFwLmZvckVhY2goZnVuY3Rpb24odmFsdWUsa2V5KXtyZXN1bHRbKytpbmRleF09W2tleSx2YWx1ZV07fSk7cmV0dXJuIHJlc3VsdDt9LyoqXG4gICAqIENyZWF0ZXMgYSB1bmFyeSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggaXRzIGFyZ3VtZW50IHRyYW5zZm9ybWVkLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmFuc2Zvcm0gVGhlIGFyZ3VtZW50IHRyYW5zZm9ybS5cbiAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAqL2Z1bmN0aW9uIG92ZXJBcmcoZnVuYyx0cmFuc2Zvcm0pe3JldHVybiBmdW5jdGlvbihhcmcpe3JldHVybiBmdW5jKHRyYW5zZm9ybShhcmcpKTt9O30vKipcbiAgICogUmVwbGFjZXMgYWxsIGBwbGFjZWhvbGRlcmAgZWxlbWVudHMgaW4gYGFycmF5YCB3aXRoIGFuIGludGVybmFsIHBsYWNlaG9sZGVyXG4gICAqIGFuZCByZXR1cm5zIGFuIGFycmF5IG9mIHRoZWlyIGluZGV4ZXMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gICAqIEBwYXJhbSB7Kn0gcGxhY2Vob2xkZXIgVGhlIHBsYWNlaG9sZGVyIHRvIHJlcGxhY2UuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIHBsYWNlaG9sZGVyIGluZGV4ZXMuXG4gICAqL2Z1bmN0aW9uIHJlcGxhY2VIb2xkZXJzKGFycmF5LHBsYWNlaG9sZGVyKXt2YXIgaW5kZXg9LTEsbGVuZ3RoPWFycmF5Lmxlbmd0aCxyZXNJbmRleD0wLHJlc3VsdD1bXTt3aGlsZSgrK2luZGV4PGxlbmd0aCl7dmFyIHZhbHVlPWFycmF5W2luZGV4XTtpZih2YWx1ZT09PXBsYWNlaG9sZGVyfHx2YWx1ZT09PVBMQUNFSE9MREVSKXthcnJheVtpbmRleF09UExBQ0VIT0xERVI7cmVzdWx0W3Jlc0luZGV4KytdPWluZGV4O319cmV0dXJuIHJlc3VsdDt9LyoqXG4gICAqIENvbnZlcnRzIGBzZXRgIHRvIGFuIGFycmF5IG9mIGl0cyB2YWx1ZXMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzZXQgVGhlIHNldCB0byBjb252ZXJ0LlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHZhbHVlcy5cbiAgICovZnVuY3Rpb24gc2V0VG9BcnJheShzZXQpe3ZhciBpbmRleD0tMSxyZXN1bHQ9QXJyYXkoc2V0LnNpemUpO3NldC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlKXtyZXN1bHRbKytpbmRleF09dmFsdWU7fSk7cmV0dXJuIHJlc3VsdDt9LyoqXG4gICAqIENvbnZlcnRzIGBzZXRgIHRvIGl0cyB2YWx1ZS12YWx1ZSBwYWlycy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IHNldCBUaGUgc2V0IHRvIGNvbnZlcnQuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgdmFsdWUtdmFsdWUgcGFpcnMuXG4gICAqL2Z1bmN0aW9uIHNldFRvUGFpcnMoc2V0KXt2YXIgaW5kZXg9LTEscmVzdWx0PUFycmF5KHNldC5zaXplKTtzZXQuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSl7cmVzdWx0WysraW5kZXhdPVt2YWx1ZSx2YWx1ZV07fSk7cmV0dXJuIHJlc3VsdDt9LyoqXG4gICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5pbmRleE9mYCB3aGljaCBwZXJmb3JtcyBzdHJpY3QgZXF1YWxpdHlcbiAgICogY29tcGFyaXNvbnMgb2YgdmFsdWVzLCBpLmUuIGA9PT1gLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gICAqL2Z1bmN0aW9uIHN0cmljdEluZGV4T2YoYXJyYXksdmFsdWUsZnJvbUluZGV4KXt2YXIgaW5kZXg9ZnJvbUluZGV4LTEsbGVuZ3RoPWFycmF5Lmxlbmd0aDt3aGlsZSgrK2luZGV4PGxlbmd0aCl7aWYoYXJyYXlbaW5kZXhdPT09dmFsdWUpe3JldHVybiBpbmRleDt9fXJldHVybi0xO30vKipcbiAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmxhc3RJbmRleE9mYCB3aGljaCBwZXJmb3JtcyBzdHJpY3QgZXF1YWxpdHlcbiAgICogY29tcGFyaXNvbnMgb2YgdmFsdWVzLCBpLmUuIGA9PT1gLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gICAqL2Z1bmN0aW9uIHN0cmljdExhc3RJbmRleE9mKGFycmF5LHZhbHVlLGZyb21JbmRleCl7dmFyIGluZGV4PWZyb21JbmRleCsxO3doaWxlKGluZGV4LS0pe2lmKGFycmF5W2luZGV4XT09PXZhbHVlKXtyZXR1cm4gaW5kZXg7fX1yZXR1cm4gaW5kZXg7fS8qKlxuICAgKiBHZXRzIHRoZSBudW1iZXIgb2Ygc3ltYm9scyBpbiBgc3RyaW5nYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHN0cmluZyBzaXplLlxuICAgKi9mdW5jdGlvbiBzdHJpbmdTaXplKHN0cmluZyl7cmV0dXJuIGhhc1VuaWNvZGUoc3RyaW5nKT91bmljb2RlU2l6ZShzdHJpbmcpOmFzY2lpU2l6ZShzdHJpbmcpO30vKipcbiAgICogQ29udmVydHMgYHN0cmluZ2AgdG8gYW4gYXJyYXkuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBhcnJheS5cbiAgICovZnVuY3Rpb24gc3RyaW5nVG9BcnJheShzdHJpbmcpe3JldHVybiBoYXNVbmljb2RlKHN0cmluZyk/dW5pY29kZVRvQXJyYXkoc3RyaW5nKTphc2NpaVRvQXJyYXkoc3RyaW5nKTt9LyoqXG4gICAqIFVzZWQgYnkgYF8udW5lc2NhcGVgIHRvIGNvbnZlcnQgSFRNTCBlbnRpdGllcyB0byBjaGFyYWN0ZXJzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2hyIFRoZSBtYXRjaGVkIGNoYXJhY3RlciB0byB1bmVzY2FwZS5cbiAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdW5lc2NhcGVkIGNoYXJhY3Rlci5cbiAgICovdmFyIHVuZXNjYXBlSHRtbENoYXI9YmFzZVByb3BlcnR5T2YoaHRtbFVuZXNjYXBlcyk7LyoqXG4gICAqIEdldHMgdGhlIHNpemUgb2YgYSBVbmljb2RlIGBzdHJpbmdgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgaW5zcGVjdC5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc3RyaW5nIHNpemUuXG4gICAqL2Z1bmN0aW9uIHVuaWNvZGVTaXplKHN0cmluZyl7dmFyIHJlc3VsdD1yZVVuaWNvZGUubGFzdEluZGV4PTA7d2hpbGUocmVVbmljb2RlLnRlc3Qoc3RyaW5nKSl7KytyZXN1bHQ7fXJldHVybiByZXN1bHQ7fS8qKlxuICAgKiBDb252ZXJ0cyBhIFVuaWNvZGUgYHN0cmluZ2AgdG8gYW4gYXJyYXkuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBhcnJheS5cbiAgICovZnVuY3Rpb24gdW5pY29kZVRvQXJyYXkoc3RyaW5nKXtyZXR1cm4gc3RyaW5nLm1hdGNoKHJlVW5pY29kZSl8fFtdO30vKipcbiAgICogU3BsaXRzIGEgVW5pY29kZSBgc3RyaW5nYCBpbnRvIGFuIGFycmF5IG9mIGl0cyB3b3Jkcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSB3b3JkcyBvZiBgc3RyaW5nYC5cbiAgICovZnVuY3Rpb24gdW5pY29kZVdvcmRzKHN0cmluZyl7cmV0dXJuIHN0cmluZy5tYXRjaChyZVVuaWNvZGVXb3JkKXx8W107fS8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qLy8qKlxuICAgKiBDcmVhdGUgYSBuZXcgcHJpc3RpbmUgYGxvZGFzaGAgZnVuY3Rpb24gdXNpbmcgdGhlIGBjb250ZXh0YCBvYmplY3QuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQHNpbmNlIDEuMS4wXG4gICAqIEBjYXRlZ29yeSBVdGlsXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbY29udGV4dD1yb290XSBUaGUgY29udGV4dCBvYmplY3QuXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBhIG5ldyBgbG9kYXNoYCBmdW5jdGlvbi5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogXy5taXhpbih7ICdmb28nOiBfLmNvbnN0YW50KCdmb28nKSB9KTtcbiAgICpcbiAgICogdmFyIGxvZGFzaCA9IF8ucnVuSW5Db250ZXh0KCk7XG4gICAqIGxvZGFzaC5taXhpbih7ICdiYXInOiBsb2Rhc2guY29uc3RhbnQoJ2JhcicpIH0pO1xuICAgKlxuICAgKiBfLmlzRnVuY3Rpb24oXy5mb28pO1xuICAgKiAvLyA9PiB0cnVlXG4gICAqIF8uaXNGdW5jdGlvbihfLmJhcik7XG4gICAqIC8vID0+IGZhbHNlXG4gICAqXG4gICAqIGxvZGFzaC5pc0Z1bmN0aW9uKGxvZGFzaC5mb28pO1xuICAgKiAvLyA9PiBmYWxzZVxuICAgKiBsb2Rhc2guaXNGdW5jdGlvbihsb2Rhc2guYmFyKTtcbiAgICogLy8gPT4gdHJ1ZVxuICAgKlxuICAgKiAvLyBDcmVhdGUgYSBzdXBlZC11cCBgZGVmZXJgIGluIE5vZGUuanMuXG4gICAqIHZhciBkZWZlciA9IF8ucnVuSW5Db250ZXh0KHsgJ3NldFRpbWVvdXQnOiBzZXRJbW1lZGlhdGUgfSkuZGVmZXI7XG4gICAqL3ZhciBydW5JbkNvbnRleHQ9ZnVuY3Rpb24gcnVuSW5Db250ZXh0KGNvbnRleHQpe2NvbnRleHQ9Y29udGV4dD09bnVsbD9yb290Ol8uZGVmYXVsdHMocm9vdC5PYmplY3QoKSxjb250ZXh0LF8ucGljayhyb290LGNvbnRleHRQcm9wcykpOy8qKiBCdWlsdC1pbiBjb25zdHJ1Y3RvciByZWZlcmVuY2VzLiAqL3ZhciBBcnJheT1jb250ZXh0LkFycmF5LERhdGU9Y29udGV4dC5EYXRlLEVycm9yPWNvbnRleHQuRXJyb3IsRnVuY3Rpb249Y29udGV4dC5GdW5jdGlvbixNYXRoPWNvbnRleHQuTWF0aCxPYmplY3Q9Y29udGV4dC5PYmplY3QsUmVnRXhwPWNvbnRleHQuUmVnRXhwLFN0cmluZz1jb250ZXh0LlN0cmluZyxUeXBlRXJyb3I9Y29udGV4dC5UeXBlRXJyb3I7LyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL3ZhciBhcnJheVByb3RvPUFycmF5LnByb3RvdHlwZSxmdW5jUHJvdG89RnVuY3Rpb24ucHJvdG90eXBlLG9iamVjdFByb3RvPU9iamVjdC5wcm90b3R5cGU7LyoqIFVzZWQgdG8gZGV0ZWN0IG92ZXJyZWFjaGluZyBjb3JlLWpzIHNoaW1zLiAqL3ZhciBjb3JlSnNEYXRhPWNvbnRleHRbJ19fY29yZS1qc19zaGFyZWRfXyddOy8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi92YXIgZnVuY1RvU3RyaW5nPWZ1bmNQcm90by50b1N0cmluZzsvKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi92YXIgaGFzT3duUHJvcGVydHk9b2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7LyoqIFVzZWQgdG8gZ2VuZXJhdGUgdW5pcXVlIElEcy4gKi92YXIgaWRDb3VudGVyPTA7LyoqIFVzZWQgdG8gZGV0ZWN0IG1ldGhvZHMgbWFzcXVlcmFkaW5nIGFzIG5hdGl2ZS4gKi92YXIgbWFza1NyY0tleT1mdW5jdGlvbigpe3ZhciB1aWQ9L1teLl0rJC8uZXhlYyhjb3JlSnNEYXRhJiZjb3JlSnNEYXRhLmtleXMmJmNvcmVKc0RhdGEua2V5cy5JRV9QUk9UT3x8JycpO3JldHVybiB1aWQ/J1N5bWJvbChzcmMpXzEuJyt1aWQ6Jyc7fSgpOy8qKlxuICAgICAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAgICAgKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAgICAgKiBvZiB2YWx1ZXMuXG4gICAgICovdmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nPW9iamVjdFByb3RvLnRvU3RyaW5nOy8qKiBVc2VkIHRvIGluZmVyIHRoZSBgT2JqZWN0YCBjb25zdHJ1Y3Rvci4gKi92YXIgb2JqZWN0Q3RvclN0cmluZz1mdW5jVG9TdHJpbmcuY2FsbChPYmplY3QpOy8qKiBVc2VkIHRvIHJlc3RvcmUgdGhlIG9yaWdpbmFsIGBfYCByZWZlcmVuY2UgaW4gYF8ubm9Db25mbGljdGAuICovdmFyIG9sZERhc2g9cm9vdC5fOy8qKiBVc2VkIHRvIGRldGVjdCBpZiBhIG1ldGhvZCBpcyBuYXRpdmUuICovdmFyIHJlSXNOYXRpdmU9UmVnRXhwKCdeJytmdW5jVG9TdHJpbmcuY2FsbChoYXNPd25Qcm9wZXJ0eSkucmVwbGFjZShyZVJlZ0V4cENoYXIsJ1xcXFwkJicpLnJlcGxhY2UoL2hhc093blByb3BlcnR5fChmdW5jdGlvbikuKj8oPz1cXFxcXFwoKXwgZm9yIC4rPyg/PVxcXFxcXF0pL2csJyQxLio/JykrJyQnKTsvKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi92YXIgQnVmZmVyPW1vZHVsZUV4cG9ydHM/Y29udGV4dC5CdWZmZXI6dW5kZWZpbmVkLFN5bWJvbD1jb250ZXh0LlN5bWJvbCxVaW50OEFycmF5PWNvbnRleHQuVWludDhBcnJheSxhbGxvY1Vuc2FmZT1CdWZmZXI/QnVmZmVyLmFsbG9jVW5zYWZlOnVuZGVmaW5lZCxnZXRQcm90b3R5cGU9b3ZlckFyZyhPYmplY3QuZ2V0UHJvdG90eXBlT2YsT2JqZWN0KSxvYmplY3RDcmVhdGU9T2JqZWN0LmNyZWF0ZSxwcm9wZXJ0eUlzRW51bWVyYWJsZT1vYmplY3RQcm90by5wcm9wZXJ0eUlzRW51bWVyYWJsZSxzcGxpY2U9YXJyYXlQcm90by5zcGxpY2Usc3ByZWFkYWJsZVN5bWJvbD1TeW1ib2w/U3ltYm9sLmlzQ29uY2F0U3ByZWFkYWJsZTp1bmRlZmluZWQsc3ltSXRlcmF0b3I9U3ltYm9sP1N5bWJvbC5pdGVyYXRvcjp1bmRlZmluZWQsc3ltVG9TdHJpbmdUYWc9U3ltYm9sP1N5bWJvbC50b1N0cmluZ1RhZzp1bmRlZmluZWQ7dmFyIGRlZmluZVByb3BlcnR5PWZ1bmN0aW9uKCl7dHJ5e3ZhciBmdW5jPWdldE5hdGl2ZShPYmplY3QsJ2RlZmluZVByb3BlcnR5Jyk7ZnVuYyh7fSwnJyx7fSk7cmV0dXJuIGZ1bmM7fWNhdGNoKGUpe319KCk7LyoqIE1vY2tlZCBidWlsdC1pbnMuICovdmFyIGN0eENsZWFyVGltZW91dD1jb250ZXh0LmNsZWFyVGltZW91dCE9PXJvb3QuY2xlYXJUaW1lb3V0JiZjb250ZXh0LmNsZWFyVGltZW91dCxjdHhOb3c9RGF0ZSYmRGF0ZS5ub3chPT1yb290LkRhdGUubm93JiZEYXRlLm5vdyxjdHhTZXRUaW1lb3V0PWNvbnRleHQuc2V0VGltZW91dCE9PXJvb3Quc2V0VGltZW91dCYmY29udGV4dC5zZXRUaW1lb3V0Oy8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi92YXIgbmF0aXZlQ2VpbD1NYXRoLmNlaWwsbmF0aXZlRmxvb3I9TWF0aC5mbG9vcixuYXRpdmVHZXRTeW1ib2xzPU9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMsbmF0aXZlSXNCdWZmZXI9QnVmZmVyP0J1ZmZlci5pc0J1ZmZlcjp1bmRlZmluZWQsbmF0aXZlSXNGaW5pdGU9Y29udGV4dC5pc0Zpbml0ZSxuYXRpdmVKb2luPWFycmF5UHJvdG8uam9pbixuYXRpdmVLZXlzPW92ZXJBcmcoT2JqZWN0LmtleXMsT2JqZWN0KSxuYXRpdmVNYXg9TWF0aC5tYXgsbmF0aXZlTWluPU1hdGgubWluLG5hdGl2ZU5vdz1EYXRlLm5vdyxuYXRpdmVQYXJzZUludD1jb250ZXh0LnBhcnNlSW50LG5hdGl2ZVJhbmRvbT1NYXRoLnJhbmRvbSxuYXRpdmVSZXZlcnNlPWFycmF5UHJvdG8ucmV2ZXJzZTsvKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovdmFyIERhdGFWaWV3PWdldE5hdGl2ZShjb250ZXh0LCdEYXRhVmlldycpLE1hcD1nZXROYXRpdmUoY29udGV4dCwnTWFwJyksUHJvbWlzZT1nZXROYXRpdmUoY29udGV4dCwnUHJvbWlzZScpLFNldD1nZXROYXRpdmUoY29udGV4dCwnU2V0JyksV2Vha01hcD1nZXROYXRpdmUoY29udGV4dCwnV2Vha01hcCcpLG5hdGl2ZUNyZWF0ZT1nZXROYXRpdmUoT2JqZWN0LCdjcmVhdGUnKTsvKiogVXNlZCB0byBzdG9yZSBmdW5jdGlvbiBtZXRhZGF0YS4gKi92YXIgbWV0YU1hcD1XZWFrTWFwJiZuZXcgV2Vha01hcCgpOy8qKiBVc2VkIHRvIGxvb2t1cCB1bm1pbmlmaWVkIGZ1bmN0aW9uIG5hbWVzLiAqL3ZhciByZWFsTmFtZXM9e307LyoqIFVzZWQgdG8gZGV0ZWN0IG1hcHMsIHNldHMsIGFuZCB3ZWFrbWFwcy4gKi92YXIgZGF0YVZpZXdDdG9yU3RyaW5nPXRvU291cmNlKERhdGFWaWV3KSxtYXBDdG9yU3RyaW5nPXRvU291cmNlKE1hcCkscHJvbWlzZUN0b3JTdHJpbmc9dG9Tb3VyY2UoUHJvbWlzZSksc2V0Q3RvclN0cmluZz10b1NvdXJjZShTZXQpLHdlYWtNYXBDdG9yU3RyaW5nPXRvU291cmNlKFdlYWtNYXApOy8qKiBVc2VkIHRvIGNvbnZlcnQgc3ltYm9scyB0byBwcmltaXRpdmVzIGFuZCBzdHJpbmdzLiAqL3ZhciBzeW1ib2xQcm90bz1TeW1ib2w/U3ltYm9sLnByb3RvdHlwZTp1bmRlZmluZWQsc3ltYm9sVmFsdWVPZj1zeW1ib2xQcm90bz9zeW1ib2xQcm90by52YWx1ZU9mOnVuZGVmaW5lZCxzeW1ib2xUb1N0cmluZz1zeW1ib2xQcm90bz9zeW1ib2xQcm90by50b1N0cmluZzp1bmRlZmluZWQ7LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qLy8qKlxuICAgICAqIENyZWF0ZXMgYSBgbG9kYXNoYCBvYmplY3Qgd2hpY2ggd3JhcHMgYHZhbHVlYCB0byBlbmFibGUgaW1wbGljaXQgbWV0aG9kXG4gICAgICogY2hhaW4gc2VxdWVuY2VzLiBNZXRob2RzIHRoYXQgb3BlcmF0ZSBvbiBhbmQgcmV0dXJuIGFycmF5cywgY29sbGVjdGlvbnMsXG4gICAgICogYW5kIGZ1bmN0aW9ucyBjYW4gYmUgY2hhaW5lZCB0b2dldGhlci4gTWV0aG9kcyB0aGF0IHJldHJpZXZlIGEgc2luZ2xlIHZhbHVlXG4gICAgICogb3IgbWF5IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZSB3aWxsIGF1dG9tYXRpY2FsbHkgZW5kIHRoZSBjaGFpbiBzZXF1ZW5jZVxuICAgICAqIGFuZCByZXR1cm4gdGhlIHVud3JhcHBlZCB2YWx1ZS4gT3RoZXJ3aXNlLCB0aGUgdmFsdWUgbXVzdCBiZSB1bndyYXBwZWRcbiAgICAgKiB3aXRoIGBfI3ZhbHVlYC5cbiAgICAgKlxuICAgICAqIEV4cGxpY2l0IGNoYWluIHNlcXVlbmNlcywgd2hpY2ggbXVzdCBiZSB1bndyYXBwZWQgd2l0aCBgXyN2YWx1ZWAsIG1heSBiZVxuICAgICAqIGVuYWJsZWQgdXNpbmcgYF8uY2hhaW5gLlxuICAgICAqXG4gICAgICogVGhlIGV4ZWN1dGlvbiBvZiBjaGFpbmVkIG1ldGhvZHMgaXMgbGF6eSwgdGhhdCBpcywgaXQncyBkZWZlcnJlZCB1bnRpbFxuICAgICAqIGBfI3ZhbHVlYCBpcyBpbXBsaWNpdGx5IG9yIGV4cGxpY2l0bHkgY2FsbGVkLlxuICAgICAqXG4gICAgICogTGF6eSBldmFsdWF0aW9uIGFsbG93cyBzZXZlcmFsIG1ldGhvZHMgdG8gc3VwcG9ydCBzaG9ydGN1dCBmdXNpb24uXG4gICAgICogU2hvcnRjdXQgZnVzaW9uIGlzIGFuIG9wdGltaXphdGlvbiB0byBtZXJnZSBpdGVyYXRlZSBjYWxsczsgdGhpcyBhdm9pZHNcbiAgICAgKiB0aGUgY3JlYXRpb24gb2YgaW50ZXJtZWRpYXRlIGFycmF5cyBhbmQgY2FuIGdyZWF0bHkgcmVkdWNlIHRoZSBudW1iZXIgb2ZcbiAgICAgKiBpdGVyYXRlZSBleGVjdXRpb25zLiBTZWN0aW9ucyBvZiBhIGNoYWluIHNlcXVlbmNlIHF1YWxpZnkgZm9yIHNob3J0Y3V0XG4gICAgICogZnVzaW9uIGlmIHRoZSBzZWN0aW9uIGlzIGFwcGxpZWQgdG8gYW4gYXJyYXkgYW5kIGl0ZXJhdGVlcyBhY2NlcHQgb25seVxuICAgICAqIG9uZSBhcmd1bWVudC4gVGhlIGhldXJpc3RpYyBmb3Igd2hldGhlciBhIHNlY3Rpb24gcXVhbGlmaWVzIGZvciBzaG9ydGN1dFxuICAgICAqIGZ1c2lvbiBpcyBzdWJqZWN0IHRvIGNoYW5nZS5cbiAgICAgKlxuICAgICAqIENoYWluaW5nIGlzIHN1cHBvcnRlZCBpbiBjdXN0b20gYnVpbGRzIGFzIGxvbmcgYXMgdGhlIGBfI3ZhbHVlYCBtZXRob2QgaXNcbiAgICAgKiBkaXJlY3RseSBvciBpbmRpcmVjdGx5IGluY2x1ZGVkIGluIHRoZSBidWlsZC5cbiAgICAgKlxuICAgICAqIEluIGFkZGl0aW9uIHRvIGxvZGFzaCBtZXRob2RzLCB3cmFwcGVycyBoYXZlIGBBcnJheWAgYW5kIGBTdHJpbmdgIG1ldGhvZHMuXG4gICAgICpcbiAgICAgKiBUaGUgd3JhcHBlciBgQXJyYXlgIG1ldGhvZHMgYXJlOlxuICAgICAqIGBjb25jYXRgLCBgam9pbmAsIGBwb3BgLCBgcHVzaGAsIGBzaGlmdGAsIGBzb3J0YCwgYHNwbGljZWAsIGFuZCBgdW5zaGlmdGBcbiAgICAgKlxuICAgICAqIFRoZSB3cmFwcGVyIGBTdHJpbmdgIG1ldGhvZHMgYXJlOlxuICAgICAqIGByZXBsYWNlYCBhbmQgYHNwbGl0YFxuICAgICAqXG4gICAgICogVGhlIHdyYXBwZXIgbWV0aG9kcyB0aGF0IHN1cHBvcnQgc2hvcnRjdXQgZnVzaW9uIGFyZTpcbiAgICAgKiBgYXRgLCBgY29tcGFjdGAsIGBkcm9wYCwgYGRyb3BSaWdodGAsIGBkcm9wV2hpbGVgLCBgZmlsdGVyYCwgYGZpbmRgLFxuICAgICAqIGBmaW5kTGFzdGAsIGBoZWFkYCwgYGluaXRpYWxgLCBgbGFzdGAsIGBtYXBgLCBgcmVqZWN0YCwgYHJldmVyc2VgLCBgc2xpY2VgLFxuICAgICAqIGB0YWlsYCwgYHRha2VgLCBgdGFrZVJpZ2h0YCwgYHRha2VSaWdodFdoaWxlYCwgYHRha2VXaGlsZWAsIGFuZCBgdG9BcnJheWBcbiAgICAgKlxuICAgICAqIFRoZSBjaGFpbmFibGUgd3JhcHBlciBtZXRob2RzIGFyZTpcbiAgICAgKiBgYWZ0ZXJgLCBgYXJ5YCwgYGFzc2lnbmAsIGBhc3NpZ25JbmAsIGBhc3NpZ25JbldpdGhgLCBgYXNzaWduV2l0aGAsIGBhdGAsXG4gICAgICogYGJlZm9yZWAsIGBiaW5kYCwgYGJpbmRBbGxgLCBgYmluZEtleWAsIGBjYXN0QXJyYXlgLCBgY2hhaW5gLCBgY2h1bmtgLFxuICAgICAqIGBjb21taXRgLCBgY29tcGFjdGAsIGBjb25jYXRgLCBgY29uZm9ybXNgLCBgY29uc3RhbnRgLCBgY291bnRCeWAsIGBjcmVhdGVgLFxuICAgICAqIGBjdXJyeWAsIGBkZWJvdW5jZWAsIGBkZWZhdWx0c2AsIGBkZWZhdWx0c0RlZXBgLCBgZGVmZXJgLCBgZGVsYXlgLFxuICAgICAqIGBkaWZmZXJlbmNlYCwgYGRpZmZlcmVuY2VCeWAsIGBkaWZmZXJlbmNlV2l0aGAsIGBkcm9wYCwgYGRyb3BSaWdodGAsXG4gICAgICogYGRyb3BSaWdodFdoaWxlYCwgYGRyb3BXaGlsZWAsIGBleHRlbmRgLCBgZXh0ZW5kV2l0aGAsIGBmaWxsYCwgYGZpbHRlcmAsXG4gICAgICogYGZsYXRNYXBgLCBgZmxhdE1hcERlZXBgLCBgZmxhdE1hcERlcHRoYCwgYGZsYXR0ZW5gLCBgZmxhdHRlbkRlZXBgLFxuICAgICAqIGBmbGF0dGVuRGVwdGhgLCBgZmxpcGAsIGBmbG93YCwgYGZsb3dSaWdodGAsIGBmcm9tUGFpcnNgLCBgZnVuY3Rpb25zYCxcbiAgICAgKiBgZnVuY3Rpb25zSW5gLCBgZ3JvdXBCeWAsIGBpbml0aWFsYCwgYGludGVyc2VjdGlvbmAsIGBpbnRlcnNlY3Rpb25CeWAsXG4gICAgICogYGludGVyc2VjdGlvbldpdGhgLCBgaW52ZXJ0YCwgYGludmVydEJ5YCwgYGludm9rZU1hcGAsIGBpdGVyYXRlZWAsIGBrZXlCeWAsXG4gICAgICogYGtleXNgLCBga2V5c0luYCwgYG1hcGAsIGBtYXBLZXlzYCwgYG1hcFZhbHVlc2AsIGBtYXRjaGVzYCwgYG1hdGNoZXNQcm9wZXJ0eWAsXG4gICAgICogYG1lbW9pemVgLCBgbWVyZ2VgLCBgbWVyZ2VXaXRoYCwgYG1ldGhvZGAsIGBtZXRob2RPZmAsIGBtaXhpbmAsIGBuZWdhdGVgLFxuICAgICAqIGBudGhBcmdgLCBgb21pdGAsIGBvbWl0QnlgLCBgb25jZWAsIGBvcmRlckJ5YCwgYG92ZXJgLCBgb3ZlckFyZ3NgLFxuICAgICAqIGBvdmVyRXZlcnlgLCBgb3ZlclNvbWVgLCBgcGFydGlhbGAsIGBwYXJ0aWFsUmlnaHRgLCBgcGFydGl0aW9uYCwgYHBpY2tgLFxuICAgICAqIGBwaWNrQnlgLCBgcGxhbnRgLCBgcHJvcGVydHlgLCBgcHJvcGVydHlPZmAsIGBwdWxsYCwgYHB1bGxBbGxgLCBgcHVsbEFsbEJ5YCxcbiAgICAgKiBgcHVsbEFsbFdpdGhgLCBgcHVsbEF0YCwgYHB1c2hgLCBgcmFuZ2VgLCBgcmFuZ2VSaWdodGAsIGByZWFyZ2AsIGByZWplY3RgLFxuICAgICAqIGByZW1vdmVgLCBgcmVzdGAsIGByZXZlcnNlYCwgYHNhbXBsZVNpemVgLCBgc2V0YCwgYHNldFdpdGhgLCBgc2h1ZmZsZWAsXG4gICAgICogYHNsaWNlYCwgYHNvcnRgLCBgc29ydEJ5YCwgYHNwbGljZWAsIGBzcHJlYWRgLCBgdGFpbGAsIGB0YWtlYCwgYHRha2VSaWdodGAsXG4gICAgICogYHRha2VSaWdodFdoaWxlYCwgYHRha2VXaGlsZWAsIGB0YXBgLCBgdGhyb3R0bGVgLCBgdGhydWAsIGB0b0FycmF5YCxcbiAgICAgKiBgdG9QYWlyc2AsIGB0b1BhaXJzSW5gLCBgdG9QYXRoYCwgYHRvUGxhaW5PYmplY3RgLCBgdHJhbnNmb3JtYCwgYHVuYXJ5YCxcbiAgICAgKiBgdW5pb25gLCBgdW5pb25CeWAsIGB1bmlvbldpdGhgLCBgdW5pcWAsIGB1bmlxQnlgLCBgdW5pcVdpdGhgLCBgdW5zZXRgLFxuICAgICAqIGB1bnNoaWZ0YCwgYHVuemlwYCwgYHVuemlwV2l0aGAsIGB1cGRhdGVgLCBgdXBkYXRlV2l0aGAsIGB2YWx1ZXNgLFxuICAgICAqIGB2YWx1ZXNJbmAsIGB3aXRob3V0YCwgYHdyYXBgLCBgeG9yYCwgYHhvckJ5YCwgYHhvcldpdGhgLCBgemlwYCxcbiAgICAgKiBgemlwT2JqZWN0YCwgYHppcE9iamVjdERlZXBgLCBhbmQgYHppcFdpdGhgXG4gICAgICpcbiAgICAgKiBUaGUgd3JhcHBlciBtZXRob2RzIHRoYXQgYXJlICoqbm90KiogY2hhaW5hYmxlIGJ5IGRlZmF1bHQgYXJlOlxuICAgICAqIGBhZGRgLCBgYXR0ZW1wdGAsIGBjYW1lbENhc2VgLCBgY2FwaXRhbGl6ZWAsIGBjZWlsYCwgYGNsYW1wYCwgYGNsb25lYCxcbiAgICAgKiBgY2xvbmVEZWVwYCwgYGNsb25lRGVlcFdpdGhgLCBgY2xvbmVXaXRoYCwgYGNvbmZvcm1zVG9gLCBgZGVidXJyYCxcbiAgICAgKiBgZGVmYXVsdFRvYCwgYGRpdmlkZWAsIGBlYWNoYCwgYGVhY2hSaWdodGAsIGBlbmRzV2l0aGAsIGBlcWAsIGBlc2NhcGVgLFxuICAgICAqIGBlc2NhcGVSZWdFeHBgLCBgZXZlcnlgLCBgZmluZGAsIGBmaW5kSW5kZXhgLCBgZmluZEtleWAsIGBmaW5kTGFzdGAsXG4gICAgICogYGZpbmRMYXN0SW5kZXhgLCBgZmluZExhc3RLZXlgLCBgZmlyc3RgLCBgZmxvb3JgLCBgZm9yRWFjaGAsIGBmb3JFYWNoUmlnaHRgLFxuICAgICAqIGBmb3JJbmAsIGBmb3JJblJpZ2h0YCwgYGZvck93bmAsIGBmb3JPd25SaWdodGAsIGBnZXRgLCBgZ3RgLCBgZ3RlYCwgYGhhc2AsXG4gICAgICogYGhhc0luYCwgYGhlYWRgLCBgaWRlbnRpdHlgLCBgaW5jbHVkZXNgLCBgaW5kZXhPZmAsIGBpblJhbmdlYCwgYGludm9rZWAsXG4gICAgICogYGlzQXJndW1lbnRzYCwgYGlzQXJyYXlgLCBgaXNBcnJheUJ1ZmZlcmAsIGBpc0FycmF5TGlrZWAsIGBpc0FycmF5TGlrZU9iamVjdGAsXG4gICAgICogYGlzQm9vbGVhbmAsIGBpc0J1ZmZlcmAsIGBpc0RhdGVgLCBgaXNFbGVtZW50YCwgYGlzRW1wdHlgLCBgaXNFcXVhbGAsXG4gICAgICogYGlzRXF1YWxXaXRoYCwgYGlzRXJyb3JgLCBgaXNGaW5pdGVgLCBgaXNGdW5jdGlvbmAsIGBpc0ludGVnZXJgLCBgaXNMZW5ndGhgLFxuICAgICAqIGBpc01hcGAsIGBpc01hdGNoYCwgYGlzTWF0Y2hXaXRoYCwgYGlzTmFOYCwgYGlzTmF0aXZlYCwgYGlzTmlsYCwgYGlzTnVsbGAsXG4gICAgICogYGlzTnVtYmVyYCwgYGlzT2JqZWN0YCwgYGlzT2JqZWN0TGlrZWAsIGBpc1BsYWluT2JqZWN0YCwgYGlzUmVnRXhwYCxcbiAgICAgKiBgaXNTYWZlSW50ZWdlcmAsIGBpc1NldGAsIGBpc1N0cmluZ2AsIGBpc1VuZGVmaW5lZGAsIGBpc1R5cGVkQXJyYXlgLFxuICAgICAqIGBpc1dlYWtNYXBgLCBgaXNXZWFrU2V0YCwgYGpvaW5gLCBga2ViYWJDYXNlYCwgYGxhc3RgLCBgbGFzdEluZGV4T2ZgLFxuICAgICAqIGBsb3dlckNhc2VgLCBgbG93ZXJGaXJzdGAsIGBsdGAsIGBsdGVgLCBgbWF4YCwgYG1heEJ5YCwgYG1lYW5gLCBgbWVhbkJ5YCxcbiAgICAgKiBgbWluYCwgYG1pbkJ5YCwgYG11bHRpcGx5YCwgYG5vQ29uZmxpY3RgLCBgbm9vcGAsIGBub3dgLCBgbnRoYCwgYHBhZGAsXG4gICAgICogYHBhZEVuZGAsIGBwYWRTdGFydGAsIGBwYXJzZUludGAsIGBwb3BgLCBgcmFuZG9tYCwgYHJlZHVjZWAsIGByZWR1Y2VSaWdodGAsXG4gICAgICogYHJlcGVhdGAsIGByZXN1bHRgLCBgcm91bmRgLCBgcnVuSW5Db250ZXh0YCwgYHNhbXBsZWAsIGBzaGlmdGAsIGBzaXplYCxcbiAgICAgKiBgc25ha2VDYXNlYCwgYHNvbWVgLCBgc29ydGVkSW5kZXhgLCBgc29ydGVkSW5kZXhCeWAsIGBzb3J0ZWRMYXN0SW5kZXhgLFxuICAgICAqIGBzb3J0ZWRMYXN0SW5kZXhCeWAsIGBzdGFydENhc2VgLCBgc3RhcnRzV2l0aGAsIGBzdHViQXJyYXlgLCBgc3R1YkZhbHNlYCxcbiAgICAgKiBgc3R1Yk9iamVjdGAsIGBzdHViU3RyaW5nYCwgYHN0dWJUcnVlYCwgYHN1YnRyYWN0YCwgYHN1bWAsIGBzdW1CeWAsXG4gICAgICogYHRlbXBsYXRlYCwgYHRpbWVzYCwgYHRvRmluaXRlYCwgYHRvSW50ZWdlcmAsIGB0b0pTT05gLCBgdG9MZW5ndGhgLFxuICAgICAqIGB0b0xvd2VyYCwgYHRvTnVtYmVyYCwgYHRvU2FmZUludGVnZXJgLCBgdG9TdHJpbmdgLCBgdG9VcHBlcmAsIGB0cmltYCxcbiAgICAgKiBgdHJpbUVuZGAsIGB0cmltU3RhcnRgLCBgdHJ1bmNhdGVgLCBgdW5lc2NhcGVgLCBgdW5pcXVlSWRgLCBgdXBwZXJDYXNlYCxcbiAgICAgKiBgdXBwZXJGaXJzdGAsIGB2YWx1ZWAsIGFuZCBgd29yZHNgXG4gICAgICpcbiAgICAgKiBAbmFtZSBfXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQGNhdGVnb3J5IFNlcVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHdyYXAgaW4gYSBgbG9kYXNoYCBpbnN0YW5jZS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgYGxvZGFzaGAgd3JhcHBlciBpbnN0YW5jZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gc3F1YXJlKG4pIHtcbiAgICAgKiAgIHJldHVybiBuICogbjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgd3JhcHBlZCA9IF8oWzEsIDIsIDNdKTtcbiAgICAgKlxuICAgICAqIC8vIFJldHVybnMgYW4gdW53cmFwcGVkIHZhbHVlLlxuICAgICAqIHdyYXBwZWQucmVkdWNlKF8uYWRkKTtcbiAgICAgKiAvLyA9PiA2XG4gICAgICpcbiAgICAgKiAvLyBSZXR1cm5zIGEgd3JhcHBlZCB2YWx1ZS5cbiAgICAgKiB2YXIgc3F1YXJlcyA9IHdyYXBwZWQubWFwKHNxdWFyZSk7XG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXkoc3F1YXJlcyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheShzcXVhcmVzLnZhbHVlKCkpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9mdW5jdGlvbiBsb2Rhc2godmFsdWUpe2lmKGlzT2JqZWN0TGlrZSh2YWx1ZSkmJiFpc0FycmF5KHZhbHVlKSYmISh2YWx1ZSBpbnN0YW5jZW9mIExhenlXcmFwcGVyKSl7aWYodmFsdWUgaW5zdGFuY2VvZiBMb2Rhc2hXcmFwcGVyKXtyZXR1cm4gdmFsdWU7fWlmKGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsJ19fd3JhcHBlZF9fJykpe3JldHVybiB3cmFwcGVyQ2xvbmUodmFsdWUpO319cmV0dXJuIG5ldyBMb2Rhc2hXcmFwcGVyKHZhbHVlKTt9LyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uY3JlYXRlYCB3aXRob3V0IHN1cHBvcnQgZm9yIGFzc2lnbmluZ1xuICAgICAqIHByb3BlcnRpZXMgdG8gdGhlIGNyZWF0ZWQgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvdG8gVGhlIG9iamVjdCB0byBpbmhlcml0IGZyb20uXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAgICAgKi92YXIgYmFzZUNyZWF0ZT1mdW5jdGlvbigpe2Z1bmN0aW9uIG9iamVjdCgpe31yZXR1cm4gZnVuY3Rpb24ocHJvdG8pe2lmKCFpc09iamVjdChwcm90bykpe3JldHVybnt9O31pZihvYmplY3RDcmVhdGUpe3JldHVybiBvYmplY3RDcmVhdGUocHJvdG8pO31vYmplY3QucHJvdG90eXBlPXByb3RvO3ZhciByZXN1bHQ9bmV3IG9iamVjdCgpO29iamVjdC5wcm90b3R5cGU9dW5kZWZpbmVkO3JldHVybiByZXN1bHQ7fTt9KCk7LyoqXG4gICAgICogVGhlIGZ1bmN0aW9uIHdob3NlIHByb3RvdHlwZSBjaGFpbiBzZXF1ZW5jZSB3cmFwcGVycyBpbmhlcml0IGZyb20uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL2Z1bmN0aW9uIGJhc2VMb2Rhc2goKXt9Ly8gTm8gb3BlcmF0aW9uIHBlcmZvcm1lZC5cbi8qKlxuICAgICAqIFRoZSBiYXNlIGNvbnN0cnVjdG9yIGZvciBjcmVhdGluZyBgbG9kYXNoYCB3cmFwcGVyIG9iamVjdHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHdyYXAuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbY2hhaW5BbGxdIEVuYWJsZSBleHBsaWNpdCBtZXRob2QgY2hhaW4gc2VxdWVuY2VzLlxuICAgICAqL2Z1bmN0aW9uIExvZGFzaFdyYXBwZXIodmFsdWUsY2hhaW5BbGwpe3RoaXMuX193cmFwcGVkX189dmFsdWU7dGhpcy5fX2FjdGlvbnNfXz1bXTt0aGlzLl9fY2hhaW5fXz0hIWNoYWluQWxsO3RoaXMuX19pbmRleF9fPTA7dGhpcy5fX3ZhbHVlc19fPXVuZGVmaW5lZDt9LyoqXG4gICAgICogQnkgZGVmYXVsdCwgdGhlIHRlbXBsYXRlIGRlbGltaXRlcnMgdXNlZCBieSBsb2Rhc2ggYXJlIGxpa2UgdGhvc2UgaW5cbiAgICAgKiBlbWJlZGRlZCBSdWJ5IChFUkIpIGFzIHdlbGwgYXMgRVMyMDE1IHRlbXBsYXRlIHN0cmluZ3MuIENoYW5nZSB0aGVcbiAgICAgKiBmb2xsb3dpbmcgdGVtcGxhdGUgc2V0dGluZ3MgdG8gdXNlIGFsdGVybmF0aXZlIGRlbGltaXRlcnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqL2xvZGFzaC50ZW1wbGF0ZVNldHRpbmdzPXsvKipcbiAgICAgICAqIFVzZWQgdG8gZGV0ZWN0IGBkYXRhYCBwcm9wZXJ0eSB2YWx1ZXMgdG8gYmUgSFRNTC1lc2NhcGVkLlxuICAgICAgICpcbiAgICAgICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcbiAgICAgICAqIEB0eXBlIHtSZWdFeHB9XG4gICAgICAgKi8nZXNjYXBlJzpyZUVzY2FwZSwvKipcbiAgICAgICAqIFVzZWQgdG8gZGV0ZWN0IGNvZGUgdG8gYmUgZXZhbHVhdGVkLlxuICAgICAgICpcbiAgICAgICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcbiAgICAgICAqIEB0eXBlIHtSZWdFeHB9XG4gICAgICAgKi8nZXZhbHVhdGUnOnJlRXZhbHVhdGUsLyoqXG4gICAgICAgKiBVc2VkIHRvIGRldGVjdCBgZGF0YWAgcHJvcGVydHkgdmFsdWVzIHRvIGluamVjdC5cbiAgICAgICAqXG4gICAgICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzXG4gICAgICAgKiBAdHlwZSB7UmVnRXhwfVxuICAgICAgICovJ2ludGVycG9sYXRlJzpyZUludGVycG9sYXRlLC8qKlxuICAgICAgICogVXNlZCB0byByZWZlcmVuY2UgdGhlIGRhdGEgb2JqZWN0IGluIHRoZSB0ZW1wbGF0ZSB0ZXh0LlxuICAgICAgICpcbiAgICAgICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcbiAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgKi8ndmFyaWFibGUnOicnLC8qKlxuICAgICAgICogVXNlZCB0byBpbXBvcnQgdmFyaWFibGVzIGludG8gdGhlIGNvbXBpbGVkIHRlbXBsYXRlLlxuICAgICAgICpcbiAgICAgICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcbiAgICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICAgKi8naW1wb3J0cyc6ey8qKlxuICAgICAgICAgKiBBIHJlZmVyZW5jZSB0byB0aGUgYGxvZGFzaGAgZnVuY3Rpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3MuaW1wb3J0c1xuICAgICAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICAgICAqLydfJzpsb2Rhc2h9fTsvLyBFbnN1cmUgd3JhcHBlcnMgYXJlIGluc3RhbmNlcyBvZiBgYmFzZUxvZGFzaGAuXG5sb2Rhc2gucHJvdG90eXBlPWJhc2VMb2Rhc2gucHJvdG90eXBlO2xvZGFzaC5wcm90b3R5cGUuY29uc3RydWN0b3I9bG9kYXNoO0xvZGFzaFdyYXBwZXIucHJvdG90eXBlPWJhc2VDcmVhdGUoYmFzZUxvZGFzaC5wcm90b3R5cGUpO0xvZGFzaFdyYXBwZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yPUxvZGFzaFdyYXBwZXI7LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qLy8qKlxuICAgICAqIENyZWF0ZXMgYSBsYXp5IHdyYXBwZXIgb2JqZWN0IHdoaWNoIHdyYXBzIGB2YWx1ZWAgdG8gZW5hYmxlIGxhenkgZXZhbHVhdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gd3JhcC5cbiAgICAgKi9mdW5jdGlvbiBMYXp5V3JhcHBlcih2YWx1ZSl7dGhpcy5fX3dyYXBwZWRfXz12YWx1ZTt0aGlzLl9fYWN0aW9uc19fPVtdO3RoaXMuX19kaXJfXz0xO3RoaXMuX19maWx0ZXJlZF9fPWZhbHNlO3RoaXMuX19pdGVyYXRlZXNfXz1bXTt0aGlzLl9fdGFrZUNvdW50X189TUFYX0FSUkFZX0xFTkdUSDt0aGlzLl9fdmlld3NfXz1bXTt9LyoqXG4gICAgICogQ3JlYXRlcyBhIGNsb25lIG9mIHRoZSBsYXp5IHdyYXBwZXIgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBjbG9uZVxuICAgICAqIEBtZW1iZXJPZiBMYXp5V3JhcHBlclxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCBgTGF6eVdyYXBwZXJgIG9iamVjdC5cbiAgICAgKi9mdW5jdGlvbiBsYXp5Q2xvbmUoKXt2YXIgcmVzdWx0PW5ldyBMYXp5V3JhcHBlcih0aGlzLl9fd3JhcHBlZF9fKTtyZXN1bHQuX19hY3Rpb25zX189Y29weUFycmF5KHRoaXMuX19hY3Rpb25zX18pO3Jlc3VsdC5fX2Rpcl9fPXRoaXMuX19kaXJfXztyZXN1bHQuX19maWx0ZXJlZF9fPXRoaXMuX19maWx0ZXJlZF9fO3Jlc3VsdC5fX2l0ZXJhdGVlc19fPWNvcHlBcnJheSh0aGlzLl9faXRlcmF0ZWVzX18pO3Jlc3VsdC5fX3Rha2VDb3VudF9fPXRoaXMuX190YWtlQ291bnRfXztyZXN1bHQuX192aWV3c19fPWNvcHlBcnJheSh0aGlzLl9fdmlld3NfXyk7cmV0dXJuIHJlc3VsdDt9LyoqXG4gICAgICogUmV2ZXJzZXMgdGhlIGRpcmVjdGlvbiBvZiBsYXp5IGl0ZXJhdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgcmV2ZXJzZVxuICAgICAqIEBtZW1iZXJPZiBMYXp5V3JhcHBlclxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyByZXZlcnNlZCBgTGF6eVdyYXBwZXJgIG9iamVjdC5cbiAgICAgKi9mdW5jdGlvbiBsYXp5UmV2ZXJzZSgpe2lmKHRoaXMuX19maWx0ZXJlZF9fKXt2YXIgcmVzdWx0PW5ldyBMYXp5V3JhcHBlcih0aGlzKTtyZXN1bHQuX19kaXJfXz0tMTtyZXN1bHQuX19maWx0ZXJlZF9fPXRydWU7fWVsc2V7cmVzdWx0PXRoaXMuY2xvbmUoKTtyZXN1bHQuX19kaXJfXyo9LTE7fXJldHVybiByZXN1bHQ7fS8qKlxuICAgICAqIEV4dHJhY3RzIHRoZSB1bndyYXBwZWQgdmFsdWUgZnJvbSBpdHMgbGF6eSB3cmFwcGVyLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSB2YWx1ZVxuICAgICAqIEBtZW1iZXJPZiBMYXp5V3JhcHBlclxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSB1bndyYXBwZWQgdmFsdWUuXG4gICAgICovZnVuY3Rpb24gbGF6eVZhbHVlKCl7dmFyIGFycmF5PXRoaXMuX193cmFwcGVkX18udmFsdWUoKSxkaXI9dGhpcy5fX2Rpcl9fLGlzQXJyPWlzQXJyYXkoYXJyYXkpLGlzUmlnaHQ9ZGlyPDAsYXJyTGVuZ3RoPWlzQXJyP2FycmF5Lmxlbmd0aDowLHZpZXc9Z2V0VmlldygwLGFyckxlbmd0aCx0aGlzLl9fdmlld3NfXyksc3RhcnQ9dmlldy5zdGFydCxlbmQ9dmlldy5lbmQsbGVuZ3RoPWVuZC1zdGFydCxpbmRleD1pc1JpZ2h0P2VuZDpzdGFydC0xLGl0ZXJhdGVlcz10aGlzLl9faXRlcmF0ZWVzX18saXRlckxlbmd0aD1pdGVyYXRlZXMubGVuZ3RoLHJlc0luZGV4PTAsdGFrZUNvdW50PW5hdGl2ZU1pbihsZW5ndGgsdGhpcy5fX3Rha2VDb3VudF9fKTtpZighaXNBcnJ8fCFpc1JpZ2h0JiZhcnJMZW5ndGg9PWxlbmd0aCYmdGFrZUNvdW50PT1sZW5ndGgpe3JldHVybiBiYXNlV3JhcHBlclZhbHVlKGFycmF5LHRoaXMuX19hY3Rpb25zX18pO312YXIgcmVzdWx0PVtdO291dGVyOndoaWxlKGxlbmd0aC0tJiZyZXNJbmRleDx0YWtlQ291bnQpe2luZGV4Kz1kaXI7dmFyIGl0ZXJJbmRleD0tMSx2YWx1ZT1hcnJheVtpbmRleF07d2hpbGUoKytpdGVySW5kZXg8aXRlckxlbmd0aCl7dmFyIGRhdGE9aXRlcmF0ZWVzW2l0ZXJJbmRleF0saXRlcmF0ZWU9ZGF0YS5pdGVyYXRlZSx0eXBlPWRhdGEudHlwZSxjb21wdXRlZD1pdGVyYXRlZSh2YWx1ZSk7aWYodHlwZT09TEFaWV9NQVBfRkxBRyl7dmFsdWU9Y29tcHV0ZWQ7fWVsc2UgaWYoIWNvbXB1dGVkKXtpZih0eXBlPT1MQVpZX0ZJTFRFUl9GTEFHKXtjb250aW51ZSBvdXRlcjt9ZWxzZXticmVhayBvdXRlcjt9fX1yZXN1bHRbcmVzSW5kZXgrK109dmFsdWU7fXJldHVybiByZXN1bHQ7fS8vIEVuc3VyZSBgTGF6eVdyYXBwZXJgIGlzIGFuIGluc3RhbmNlIG9mIGBiYXNlTG9kYXNoYC5cbkxhenlXcmFwcGVyLnByb3RvdHlwZT1iYXNlQ3JlYXRlKGJhc2VMb2Rhc2gucHJvdG90eXBlKTtMYXp5V3JhcHBlci5wcm90b3R5cGUuY29uc3RydWN0b3I9TGF6eVdyYXBwZXI7LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qLy8qKlxuICAgICAqIENyZWF0ZXMgYSBoYXNoIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gICAgICovZnVuY3Rpb24gSGFzaChlbnRyaWVzKXt2YXIgaW5kZXg9LTEsbGVuZ3RoPWVudHJpZXM9PW51bGw/MDplbnRyaWVzLmxlbmd0aDt0aGlzLmNsZWFyKCk7d2hpbGUoKytpbmRleDxsZW5ndGgpe3ZhciBlbnRyeT1lbnRyaWVzW2luZGV4XTt0aGlzLnNldChlbnRyeVswXSxlbnRyeVsxXSk7fX0vKipcbiAgICAgKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBoYXNoLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBjbGVhclxuICAgICAqIEBtZW1iZXJPZiBIYXNoXG4gICAgICovZnVuY3Rpb24gaGFzaENsZWFyKCl7dGhpcy5fX2RhdGFfXz1uYXRpdmVDcmVhdGU/bmF0aXZlQ3JlYXRlKG51bGwpOnt9O3RoaXMuc2l6ZT0wO30vKipcbiAgICAgKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgaGFzaC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgZGVsZXRlXG4gICAgICogQG1lbWJlck9mIEhhc2hcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaGFzaCBUaGUgaGFzaCB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL2Z1bmN0aW9uIGhhc2hEZWxldGUoa2V5KXt2YXIgcmVzdWx0PXRoaXMuaGFzKGtleSkmJmRlbGV0ZSB0aGlzLl9fZGF0YV9fW2tleV07dGhpcy5zaXplLT1yZXN1bHQ/MTowO3JldHVybiByZXN1bHQ7fS8qKlxuICAgICAqIEdldHMgdGhlIGhhc2ggdmFsdWUgZm9yIGBrZXlgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBnZXRcbiAgICAgKiBAbWVtYmVyT2YgSGFzaFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAgICAgKi9mdW5jdGlvbiBoYXNoR2V0KGtleSl7dmFyIGRhdGE9dGhpcy5fX2RhdGFfXztpZihuYXRpdmVDcmVhdGUpe3ZhciByZXN1bHQ9ZGF0YVtrZXldO3JldHVybiByZXN1bHQ9PT1IQVNIX1VOREVGSU5FRD91bmRlZmluZWQ6cmVzdWx0O31yZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLGtleSk/ZGF0YVtrZXldOnVuZGVmaW5lZDt9LyoqXG4gICAgICogQ2hlY2tzIGlmIGEgaGFzaCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBoYXNcbiAgICAgKiBAbWVtYmVyT2YgSGFzaFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9mdW5jdGlvbiBoYXNoSGFzKGtleSl7dmFyIGRhdGE9dGhpcy5fX2RhdGFfXztyZXR1cm4gbmF0aXZlQ3JlYXRlP2RhdGFba2V5XSE9PXVuZGVmaW5lZDpoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsa2V5KTt9LyoqXG4gICAgICogU2V0cyB0aGUgaGFzaCBga2V5YCB0byBgdmFsdWVgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBzZXRcbiAgICAgKiBAbWVtYmVyT2YgSGFzaFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBoYXNoIGluc3RhbmNlLlxuICAgICAqL2Z1bmN0aW9uIGhhc2hTZXQoa2V5LHZhbHVlKXt2YXIgZGF0YT10aGlzLl9fZGF0YV9fO3RoaXMuc2l6ZSs9dGhpcy5oYXMoa2V5KT8wOjE7ZGF0YVtrZXldPW5hdGl2ZUNyZWF0ZSYmdmFsdWU9PT11bmRlZmluZWQ/SEFTSF9VTkRFRklORUQ6dmFsdWU7cmV0dXJuIHRoaXM7fS8vIEFkZCBtZXRob2RzIHRvIGBIYXNoYC5cbkhhc2gucHJvdG90eXBlLmNsZWFyPWhhc2hDbGVhcjtIYXNoLnByb3RvdHlwZVsnZGVsZXRlJ109aGFzaERlbGV0ZTtIYXNoLnByb3RvdHlwZS5nZXQ9aGFzaEdldDtIYXNoLnByb3RvdHlwZS5oYXM9aGFzaEhhcztIYXNoLnByb3RvdHlwZS5zZXQ9aGFzaFNldDsvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovLyoqXG4gICAgICogQ3JlYXRlcyBhbiBsaXN0IGNhY2hlIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gICAgICovZnVuY3Rpb24gTGlzdENhY2hlKGVudHJpZXMpe3ZhciBpbmRleD0tMSxsZW5ndGg9ZW50cmllcz09bnVsbD8wOmVudHJpZXMubGVuZ3RoO3RoaXMuY2xlYXIoKTt3aGlsZSgrK2luZGV4PGxlbmd0aCl7dmFyIGVudHJ5PWVudHJpZXNbaW5kZXhdO3RoaXMuc2V0KGVudHJ5WzBdLGVudHJ5WzFdKTt9fS8qKlxuICAgICAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGNsZWFyXG4gICAgICogQG1lbWJlck9mIExpc3RDYWNoZVxuICAgICAqL2Z1bmN0aW9uIGxpc3RDYWNoZUNsZWFyKCl7dGhpcy5fX2RhdGFfXz1bXTt0aGlzLnNpemU9MDt9LyoqXG4gICAgICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGRlbGV0ZVxuICAgICAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gICAgICovZnVuY3Rpb24gbGlzdENhY2hlRGVsZXRlKGtleSl7dmFyIGRhdGE9dGhpcy5fX2RhdGFfXyxpbmRleD1hc3NvY0luZGV4T2YoZGF0YSxrZXkpO2lmKGluZGV4PDApe3JldHVybiBmYWxzZTt9dmFyIGxhc3RJbmRleD1kYXRhLmxlbmd0aC0xO2lmKGluZGV4PT1sYXN0SW5kZXgpe2RhdGEucG9wKCk7fWVsc2V7c3BsaWNlLmNhbGwoZGF0YSxpbmRleCwxKTt9LS10aGlzLnNpemU7cmV0dXJuIHRydWU7fS8qKlxuICAgICAqIEdldHMgdGhlIGxpc3QgY2FjaGUgdmFsdWUgZm9yIGBrZXlgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBnZXRcbiAgICAgKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICAgICAqL2Z1bmN0aW9uIGxpc3RDYWNoZUdldChrZXkpe3ZhciBkYXRhPXRoaXMuX19kYXRhX18saW5kZXg9YXNzb2NJbmRleE9mKGRhdGEsa2V5KTtyZXR1cm4gaW5kZXg8MD91bmRlZmluZWQ6ZGF0YVtpbmRleF1bMV07fS8qKlxuICAgICAqIENoZWNrcyBpZiBhIGxpc3QgY2FjaGUgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgaGFzXG4gICAgICogQG1lbWJlck9mIExpc3RDYWNoZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9mdW5jdGlvbiBsaXN0Q2FjaGVIYXMoa2V5KXtyZXR1cm4gYXNzb2NJbmRleE9mKHRoaXMuX19kYXRhX18sa2V5KT4tMTt9LyoqXG4gICAgICogU2V0cyB0aGUgbGlzdCBjYWNoZSBga2V5YCB0byBgdmFsdWVgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBzZXRcbiAgICAgKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGxpc3QgY2FjaGUgaW5zdGFuY2UuXG4gICAgICovZnVuY3Rpb24gbGlzdENhY2hlU2V0KGtleSx2YWx1ZSl7dmFyIGRhdGE9dGhpcy5fX2RhdGFfXyxpbmRleD1hc3NvY0luZGV4T2YoZGF0YSxrZXkpO2lmKGluZGV4PDApeysrdGhpcy5zaXplO2RhdGEucHVzaChba2V5LHZhbHVlXSk7fWVsc2V7ZGF0YVtpbmRleF1bMV09dmFsdWU7fXJldHVybiB0aGlzO30vLyBBZGQgbWV0aG9kcyB0byBgTGlzdENhY2hlYC5cbkxpc3RDYWNoZS5wcm90b3R5cGUuY2xlYXI9bGlzdENhY2hlQ2xlYXI7TGlzdENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ109bGlzdENhY2hlRGVsZXRlO0xpc3RDYWNoZS5wcm90b3R5cGUuZ2V0PWxpc3RDYWNoZUdldDtMaXN0Q2FjaGUucHJvdG90eXBlLmhhcz1saXN0Q2FjaGVIYXM7TGlzdENhY2hlLnByb3RvdHlwZS5zZXQ9bGlzdENhY2hlU2V0Oy8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi8vKipcbiAgICAgKiBDcmVhdGVzIGEgbWFwIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICAgICAqL2Z1bmN0aW9uIE1hcENhY2hlKGVudHJpZXMpe3ZhciBpbmRleD0tMSxsZW5ndGg9ZW50cmllcz09bnVsbD8wOmVudHJpZXMubGVuZ3RoO3RoaXMuY2xlYXIoKTt3aGlsZSgrK2luZGV4PGxlbmd0aCl7dmFyIGVudHJ5PWVudHJpZXNbaW5kZXhdO3RoaXMuc2V0KGVudHJ5WzBdLGVudHJ5WzFdKTt9fS8qKlxuICAgICAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIG1hcC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgY2xlYXJcbiAgICAgKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAgICAgKi9mdW5jdGlvbiBtYXBDYWNoZUNsZWFyKCl7dGhpcy5zaXplPTA7dGhpcy5fX2RhdGFfXz17J2hhc2gnOm5ldyBIYXNoKCksJ21hcCc6bmV3KE1hcHx8TGlzdENhY2hlKSgpLCdzdHJpbmcnOm5ldyBIYXNoKCl9O30vKipcbiAgICAgKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbWFwLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBkZWxldGVcbiAgICAgKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gICAgICovZnVuY3Rpb24gbWFwQ2FjaGVEZWxldGUoa2V5KXt2YXIgcmVzdWx0PWdldE1hcERhdGEodGhpcyxrZXkpWydkZWxldGUnXShrZXkpO3RoaXMuc2l6ZS09cmVzdWx0PzE6MDtyZXR1cm4gcmVzdWx0O30vKipcbiAgICAgKiBHZXRzIHRoZSBtYXAgdmFsdWUgZm9yIGBrZXlgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBnZXRcbiAgICAgKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gICAgICovZnVuY3Rpb24gbWFwQ2FjaGVHZXQoa2V5KXtyZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLGtleSkuZ2V0KGtleSk7fS8qKlxuICAgICAqIENoZWNrcyBpZiBhIG1hcCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBoYXNcbiAgICAgKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gICAgICovZnVuY3Rpb24gbWFwQ2FjaGVIYXMoa2V5KXtyZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLGtleSkuaGFzKGtleSk7fS8qKlxuICAgICAqIFNldHMgdGhlIG1hcCBga2V5YCB0byBgdmFsdWVgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBzZXRcbiAgICAgKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbWFwIGNhY2hlIGluc3RhbmNlLlxuICAgICAqL2Z1bmN0aW9uIG1hcENhY2hlU2V0KGtleSx2YWx1ZSl7dmFyIGRhdGE9Z2V0TWFwRGF0YSh0aGlzLGtleSksc2l6ZT1kYXRhLnNpemU7ZGF0YS5zZXQoa2V5LHZhbHVlKTt0aGlzLnNpemUrPWRhdGEuc2l6ZT09c2l6ZT8wOjE7cmV0dXJuIHRoaXM7fS8vIEFkZCBtZXRob2RzIHRvIGBNYXBDYWNoZWAuXG5NYXBDYWNoZS5wcm90b3R5cGUuY2xlYXI9bWFwQ2FjaGVDbGVhcjtNYXBDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddPW1hcENhY2hlRGVsZXRlO01hcENhY2hlLnByb3RvdHlwZS5nZXQ9bWFwQ2FjaGVHZXQ7TWFwQ2FjaGUucHJvdG90eXBlLmhhcz1tYXBDYWNoZUhhcztNYXBDYWNoZS5wcm90b3R5cGUuc2V0PW1hcENhY2hlU2V0Oy8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi8vKipcbiAgICAgKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIHVuaXF1ZSB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFt2YWx1ZXNdIFRoZSB2YWx1ZXMgdG8gY2FjaGUuXG4gICAgICovZnVuY3Rpb24gU2V0Q2FjaGUodmFsdWVzKXt2YXIgaW5kZXg9LTEsbGVuZ3RoPXZhbHVlcz09bnVsbD8wOnZhbHVlcy5sZW5ndGg7dGhpcy5fX2RhdGFfXz1uZXcgTWFwQ2FjaGUoKTt3aGlsZSgrK2luZGV4PGxlbmd0aCl7dGhpcy5hZGQodmFsdWVzW2luZGV4XSk7fX0vKipcbiAgICAgKiBBZGRzIGB2YWx1ZWAgdG8gdGhlIGFycmF5IGNhY2hlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBhZGRcbiAgICAgKiBAbWVtYmVyT2YgU2V0Q2FjaGVcbiAgICAgKiBAYWxpYXMgcHVzaFxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNhY2hlLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNhY2hlIGluc3RhbmNlLlxuICAgICAqL2Z1bmN0aW9uIHNldENhY2hlQWRkKHZhbHVlKXt0aGlzLl9fZGF0YV9fLnNldCh2YWx1ZSxIQVNIX1VOREVGSU5FRCk7cmV0dXJuIHRoaXM7fS8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGluIHRoZSBhcnJheSBjYWNoZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgaGFzXG4gICAgICogQG1lbWJlck9mIFNldENhY2hlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gICAgICovZnVuY3Rpb24gc2V0Q2FjaGVIYXModmFsdWUpe3JldHVybiB0aGlzLl9fZGF0YV9fLmhhcyh2YWx1ZSk7fS8vIEFkZCBtZXRob2RzIHRvIGBTZXRDYWNoZWAuXG5TZXRDYWNoZS5wcm90b3R5cGUuYWRkPVNldENhY2hlLnByb3RvdHlwZS5wdXNoPXNldENhY2hlQWRkO1NldENhY2hlLnByb3RvdHlwZS5oYXM9c2V0Q2FjaGVIYXM7LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qLy8qKlxuICAgICAqIENyZWF0ZXMgYSBzdGFjayBjYWNoZSBvYmplY3QgdG8gc3RvcmUga2V5LXZhbHVlIHBhaXJzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAgICAgKi9mdW5jdGlvbiBTdGFjayhlbnRyaWVzKXt2YXIgZGF0YT10aGlzLl9fZGF0YV9fPW5ldyBMaXN0Q2FjaGUoZW50cmllcyk7dGhpcy5zaXplPWRhdGEuc2l6ZTt9LyoqXG4gICAgICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgc3RhY2suXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGNsZWFyXG4gICAgICogQG1lbWJlck9mIFN0YWNrXG4gICAgICovZnVuY3Rpb24gc3RhY2tDbGVhcigpe3RoaXMuX19kYXRhX189bmV3IExpc3RDYWNoZSgpO3RoaXMuc2l6ZT0wO30vKipcbiAgICAgKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgc3RhY2suXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGRlbGV0ZVxuICAgICAqIEBtZW1iZXJPZiBTdGFja1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9mdW5jdGlvbiBzdGFja0RlbGV0ZShrZXkpe3ZhciBkYXRhPXRoaXMuX19kYXRhX18scmVzdWx0PWRhdGFbJ2RlbGV0ZSddKGtleSk7dGhpcy5zaXplPWRhdGEuc2l6ZTtyZXR1cm4gcmVzdWx0O30vKipcbiAgICAgKiBHZXRzIHRoZSBzdGFjayB2YWx1ZSBmb3IgYGtleWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGdldFxuICAgICAqIEBtZW1iZXJPZiBTdGFja1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAgICAgKi9mdW5jdGlvbiBzdGFja0dldChrZXkpe3JldHVybiB0aGlzLl9fZGF0YV9fLmdldChrZXkpO30vKipcbiAgICAgKiBDaGVja3MgaWYgYSBzdGFjayB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBoYXNcbiAgICAgKiBAbWVtYmVyT2YgU3RhY2tcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gICAgICovZnVuY3Rpb24gc3RhY2tIYXMoa2V5KXtyZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXMoa2V5KTt9LyoqXG4gICAgICogU2V0cyB0aGUgc3RhY2sgYGtleWAgdG8gYHZhbHVlYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgc2V0XG4gICAgICogQG1lbWJlck9mIFN0YWNrXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIHN0YWNrIGNhY2hlIGluc3RhbmNlLlxuICAgICAqL2Z1bmN0aW9uIHN0YWNrU2V0KGtleSx2YWx1ZSl7dmFyIGRhdGE9dGhpcy5fX2RhdGFfXztpZihkYXRhIGluc3RhbmNlb2YgTGlzdENhY2hlKXt2YXIgcGFpcnM9ZGF0YS5fX2RhdGFfXztpZighTWFwfHxwYWlycy5sZW5ndGg8TEFSR0VfQVJSQVlfU0laRS0xKXtwYWlycy5wdXNoKFtrZXksdmFsdWVdKTt0aGlzLnNpemU9KytkYXRhLnNpemU7cmV0dXJuIHRoaXM7fWRhdGE9dGhpcy5fX2RhdGFfXz1uZXcgTWFwQ2FjaGUocGFpcnMpO31kYXRhLnNldChrZXksdmFsdWUpO3RoaXMuc2l6ZT1kYXRhLnNpemU7cmV0dXJuIHRoaXM7fS8vIEFkZCBtZXRob2RzIHRvIGBTdGFja2AuXG5TdGFjay5wcm90b3R5cGUuY2xlYXI9c3RhY2tDbGVhcjtTdGFjay5wcm90b3R5cGVbJ2RlbGV0ZSddPXN0YWNrRGVsZXRlO1N0YWNrLnByb3RvdHlwZS5nZXQ9c3RhY2tHZXQ7U3RhY2sucHJvdG90eXBlLmhhcz1zdGFja0hhcztTdGFjay5wcm90b3R5cGUuc2V0PXN0YWNrU2V0Oy8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi8vKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIHRoZSBhcnJheS1saWtlIGB2YWx1ZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5oZXJpdGVkIFNwZWNpZnkgcmV0dXJuaW5nIGluaGVyaXRlZCBwcm9wZXJ0eSBuYW1lcy5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICAgICAqL2Z1bmN0aW9uIGFycmF5TGlrZUtleXModmFsdWUsaW5oZXJpdGVkKXt2YXIgaXNBcnI9aXNBcnJheSh2YWx1ZSksaXNBcmc9IWlzQXJyJiZpc0FyZ3VtZW50cyh2YWx1ZSksaXNCdWZmPSFpc0FyciYmIWlzQXJnJiZpc0J1ZmZlcih2YWx1ZSksaXNUeXBlPSFpc0FyciYmIWlzQXJnJiYhaXNCdWZmJiZpc1R5cGVkQXJyYXkodmFsdWUpLHNraXBJbmRleGVzPWlzQXJyfHxpc0FyZ3x8aXNCdWZmfHxpc1R5cGUscmVzdWx0PXNraXBJbmRleGVzP2Jhc2VUaW1lcyh2YWx1ZS5sZW5ndGgsU3RyaW5nKTpbXSxsZW5ndGg9cmVzdWx0Lmxlbmd0aDtmb3IodmFyIGtleSBpbiB2YWx1ZSl7aWYoKGluaGVyaXRlZHx8aGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSxrZXkpKSYmIShza2lwSW5kZXhlcyYmKC8vIFNhZmFyaSA5IGhhcyBlbnVtZXJhYmxlIGBhcmd1bWVudHMubGVuZ3RoYCBpbiBzdHJpY3QgbW9kZS5cbmtleT09J2xlbmd0aCd8fC8vIE5vZGUuanMgMC4xMCBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiBidWZmZXJzLlxuaXNCdWZmJiYoa2V5PT0nb2Zmc2V0J3x8a2V5PT0ncGFyZW50Jyl8fC8vIFBoYW50b21KUyAyIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIHR5cGVkIGFycmF5cy5cbmlzVHlwZSYmKGtleT09J2J1ZmZlcid8fGtleT09J2J5dGVMZW5ndGgnfHxrZXk9PSdieXRlT2Zmc2V0Jyl8fC8vIFNraXAgaW5kZXggcHJvcGVydGllcy5cbmlzSW5kZXgoa2V5LGxlbmd0aCkpKSl7cmVzdWx0LnB1c2goa2V5KTt9fXJldHVybiByZXN1bHQ7fS8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5zYW1wbGVgIGZvciBhcnJheXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzYW1wbGUuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJhbmRvbSBlbGVtZW50LlxuICAgICAqL2Z1bmN0aW9uIGFycmF5U2FtcGxlKGFycmF5KXt2YXIgbGVuZ3RoPWFycmF5Lmxlbmd0aDtyZXR1cm4gbGVuZ3RoP2FycmF5W2Jhc2VSYW5kb20oMCxsZW5ndGgtMSldOnVuZGVmaW5lZDt9LyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnNhbXBsZVNpemVgIGZvciBhcnJheXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzYW1wbGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byBzYW1wbGUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSByYW5kb20gZWxlbWVudHMuXG4gICAgICovZnVuY3Rpb24gYXJyYXlTYW1wbGVTaXplKGFycmF5LG4pe3JldHVybiBzaHVmZmxlU2VsZihjb3B5QXJyYXkoYXJyYXkpLGJhc2VDbGFtcChuLDAsYXJyYXkubGVuZ3RoKSk7fS8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5zaHVmZmxlYCBmb3IgYXJyYXlzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2h1ZmZsZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBzaHVmZmxlZCBhcnJheS5cbiAgICAgKi9mdW5jdGlvbiBhcnJheVNodWZmbGUoYXJyYXkpe3JldHVybiBzaHVmZmxlU2VsZihjb3B5QXJyYXkoYXJyYXkpKTt9LyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlIGBhc3NpZ25WYWx1ZWAgZXhjZXB0IHRoYXQgaXQgZG9lc24ndCBhc3NpZ25cbiAgICAgKiBgdW5kZWZpbmVkYCB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYXNzaWduLlxuICAgICAqL2Z1bmN0aW9uIGFzc2lnbk1lcmdlVmFsdWUob2JqZWN0LGtleSx2YWx1ZSl7aWYodmFsdWUhPT11bmRlZmluZWQmJiFlcShvYmplY3Rba2V5XSx2YWx1ZSl8fHZhbHVlPT09dW5kZWZpbmVkJiYhKGtleSBpbiBvYmplY3QpKXtiYXNlQXNzaWduVmFsdWUob2JqZWN0LGtleSx2YWx1ZSk7fX0vKipcbiAgICAgKiBBc3NpZ25zIGB2YWx1ZWAgdG8gYGtleWAgb2YgYG9iamVjdGAgaWYgdGhlIGV4aXN0aW5nIHZhbHVlIGlzIG5vdCBlcXVpdmFsZW50XG4gICAgICogdXNpbmcgW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAgICAgKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYXNzaWduLlxuICAgICAqL2Z1bmN0aW9uIGFzc2lnblZhbHVlKG9iamVjdCxrZXksdmFsdWUpe3ZhciBvYmpWYWx1ZT1vYmplY3Rba2V5XTtpZighKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LGtleSkmJmVxKG9ialZhbHVlLHZhbHVlKSl8fHZhbHVlPT09dW5kZWZpbmVkJiYhKGtleSBpbiBvYmplY3QpKXtiYXNlQXNzaWduVmFsdWUob2JqZWN0LGtleSx2YWx1ZSk7fX0vKipcbiAgICAgKiBHZXRzIHRoZSBpbmRleCBhdCB3aGljaCB0aGUgYGtleWAgaXMgZm91bmQgaW4gYGFycmF5YCBvZiBrZXktdmFsdWUgcGFpcnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Kn0ga2V5IFRoZSBrZXkgdG8gc2VhcmNoIGZvci5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICAgICAqL2Z1bmN0aW9uIGFzc29jSW5kZXhPZihhcnJheSxrZXkpe3ZhciBsZW5ndGg9YXJyYXkubGVuZ3RoO3doaWxlKGxlbmd0aC0tKXtpZihlcShhcnJheVtsZW5ndGhdWzBdLGtleSkpe3JldHVybiBsZW5ndGg7fX1yZXR1cm4tMTt9LyoqXG4gICAgICogQWdncmVnYXRlcyBlbGVtZW50cyBvZiBgY29sbGVjdGlvbmAgb24gYGFjY3VtdWxhdG9yYCB3aXRoIGtleXMgdHJhbnNmb3JtZWRcbiAgICAgKiBieSBgaXRlcmF0ZWVgIGFuZCB2YWx1ZXMgc2V0IGJ5IGBzZXR0ZXJgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gc2V0dGVyIFRoZSBmdW5jdGlvbiB0byBzZXQgYGFjY3VtdWxhdG9yYCB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGl0ZXJhdGVlIHRvIHRyYW5zZm9ybSBrZXlzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhY2N1bXVsYXRvciBUaGUgaW5pdGlhbCBhZ2dyZWdhdGVkIG9iamVjdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGFjY3VtdWxhdG9yYC5cbiAgICAgKi9mdW5jdGlvbiBiYXNlQWdncmVnYXRvcihjb2xsZWN0aW9uLHNldHRlcixpdGVyYXRlZSxhY2N1bXVsYXRvcil7YmFzZUVhY2goY29sbGVjdGlvbixmdW5jdGlvbih2YWx1ZSxrZXksY29sbGVjdGlvbil7c2V0dGVyKGFjY3VtdWxhdG9yLHZhbHVlLGl0ZXJhdGVlKHZhbHVlKSxjb2xsZWN0aW9uKTt9KTtyZXR1cm4gYWNjdW11bGF0b3I7fS8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmFzc2lnbmAgd2l0aG91dCBzdXBwb3J0IGZvciBtdWx0aXBsZSBzb3VyY2VzXG4gICAgICogb3IgYGN1c3RvbWl6ZXJgIGZ1bmN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKi9mdW5jdGlvbiBiYXNlQXNzaWduKG9iamVjdCxzb3VyY2Upe3JldHVybiBvYmplY3QmJmNvcHlPYmplY3Qoc291cmNlLGtleXMoc291cmNlKSxvYmplY3QpO30vKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5hc3NpZ25JbmAgd2l0aG91dCBzdXBwb3J0IGZvciBtdWx0aXBsZSBzb3VyY2VzXG4gICAgICogb3IgYGN1c3RvbWl6ZXJgIGZ1bmN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKi9mdW5jdGlvbiBiYXNlQXNzaWduSW4ob2JqZWN0LHNvdXJjZSl7cmV0dXJuIG9iamVjdCYmY29weU9iamVjdChzb3VyY2Usa2V5c0luKHNvdXJjZSksb2JqZWN0KTt9LyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGFzc2lnblZhbHVlYCBhbmQgYGFzc2lnbk1lcmdlVmFsdWVgIHdpdGhvdXRcbiAgICAgKiB2YWx1ZSBjaGVja3MuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYXNzaWduLlxuICAgICAqL2Z1bmN0aW9uIGJhc2VBc3NpZ25WYWx1ZShvYmplY3Qsa2V5LHZhbHVlKXtpZihrZXk9PSdfX3Byb3RvX18nJiZkZWZpbmVQcm9wZXJ0eSl7ZGVmaW5lUHJvcGVydHkob2JqZWN0LGtleSx7J2NvbmZpZ3VyYWJsZSc6dHJ1ZSwnZW51bWVyYWJsZSc6dHJ1ZSwndmFsdWUnOnZhbHVlLCd3cml0YWJsZSc6dHJ1ZX0pO31lbHNle29iamVjdFtrZXldPXZhbHVlO319LyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uYXRgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaW5kaXZpZHVhbCBwYXRocy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBwYXRocyBUaGUgcHJvcGVydHkgcGF0aHMgdG8gcGljay5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHBpY2tlZCBlbGVtZW50cy5cbiAgICAgKi9mdW5jdGlvbiBiYXNlQXQob2JqZWN0LHBhdGhzKXt2YXIgaW5kZXg9LTEsbGVuZ3RoPXBhdGhzLmxlbmd0aCxyZXN1bHQ9QXJyYXkobGVuZ3RoKSxza2lwPW9iamVjdD09bnVsbDt3aGlsZSgrK2luZGV4PGxlbmd0aCl7cmVzdWx0W2luZGV4XT1za2lwP3VuZGVmaW5lZDpnZXQob2JqZWN0LHBhdGhzW2luZGV4XSk7fXJldHVybiByZXN1bHQ7fS8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNsYW1wYCB3aGljaCBkb2Vzbid0IGNvZXJjZSBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBudW1iZXIgVGhlIG51bWJlciB0byBjbGFtcC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xvd2VyXSBUaGUgbG93ZXIgYm91bmQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHVwcGVyIFRoZSB1cHBlciBib3VuZC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjbGFtcGVkIG51bWJlci5cbiAgICAgKi9mdW5jdGlvbiBiYXNlQ2xhbXAobnVtYmVyLGxvd2VyLHVwcGVyKXtpZihudW1iZXI9PT1udW1iZXIpe2lmKHVwcGVyIT09dW5kZWZpbmVkKXtudW1iZXI9bnVtYmVyPD11cHBlcj9udW1iZXI6dXBwZXI7fWlmKGxvd2VyIT09dW5kZWZpbmVkKXtudW1iZXI9bnVtYmVyPj1sb3dlcj9udW1iZXI6bG93ZXI7fX1yZXR1cm4gbnVtYmVyO30vKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jbG9uZWAgYW5kIGBfLmNsb25lRGVlcGAgd2hpY2ggdHJhY2tzXG4gICAgICogdHJhdmVyc2VkIG9iamVjdHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNsb25lLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy5cbiAgICAgKiAgMSAtIERlZXAgY2xvbmVcbiAgICAgKiAgMiAtIEZsYXR0ZW4gaW5oZXJpdGVkIHByb3BlcnRpZXNcbiAgICAgKiAgNCAtIENsb25lIHN5bWJvbHNcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjbG9uaW5nLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBba2V5XSBUaGUga2V5IG9mIGB2YWx1ZWAuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBwYXJlbnQgb2JqZWN0IG9mIGB2YWx1ZWAuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzIGFuZCB0aGVpciBjbG9uZSBjb3VudGVycGFydHMuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGNsb25lZCB2YWx1ZS5cbiAgICAgKi9mdW5jdGlvbiBiYXNlQ2xvbmUodmFsdWUsYml0bWFzayxjdXN0b21pemVyLGtleSxvYmplY3Qsc3RhY2spe3ZhciByZXN1bHQsaXNEZWVwPWJpdG1hc2smQ0xPTkVfREVFUF9GTEFHLGlzRmxhdD1iaXRtYXNrJkNMT05FX0ZMQVRfRkxBRyxpc0Z1bGw9Yml0bWFzayZDTE9ORV9TWU1CT0xTX0ZMQUc7aWYoY3VzdG9taXplcil7cmVzdWx0PW9iamVjdD9jdXN0b21pemVyKHZhbHVlLGtleSxvYmplY3Qsc3RhY2spOmN1c3RvbWl6ZXIodmFsdWUpO31pZihyZXN1bHQhPT11bmRlZmluZWQpe3JldHVybiByZXN1bHQ7fWlmKCFpc09iamVjdCh2YWx1ZSkpe3JldHVybiB2YWx1ZTt9dmFyIGlzQXJyPWlzQXJyYXkodmFsdWUpO2lmKGlzQXJyKXtyZXN1bHQ9aW5pdENsb25lQXJyYXkodmFsdWUpO2lmKCFpc0RlZXApe3JldHVybiBjb3B5QXJyYXkodmFsdWUscmVzdWx0KTt9fWVsc2V7dmFyIHRhZz1nZXRUYWcodmFsdWUpLGlzRnVuYz10YWc9PWZ1bmNUYWd8fHRhZz09Z2VuVGFnO2lmKGlzQnVmZmVyKHZhbHVlKSl7cmV0dXJuIGNsb25lQnVmZmVyKHZhbHVlLGlzRGVlcCk7fWlmKHRhZz09b2JqZWN0VGFnfHx0YWc9PWFyZ3NUYWd8fGlzRnVuYyYmIW9iamVjdCl7cmVzdWx0PWlzRmxhdHx8aXNGdW5jP3t9OmluaXRDbG9uZU9iamVjdCh2YWx1ZSk7aWYoIWlzRGVlcCl7cmV0dXJuIGlzRmxhdD9jb3B5U3ltYm9sc0luKHZhbHVlLGJhc2VBc3NpZ25JbihyZXN1bHQsdmFsdWUpKTpjb3B5U3ltYm9scyh2YWx1ZSxiYXNlQXNzaWduKHJlc3VsdCx2YWx1ZSkpO319ZWxzZXtpZighY2xvbmVhYmxlVGFnc1t0YWddKXtyZXR1cm4gb2JqZWN0P3ZhbHVlOnt9O31yZXN1bHQ9aW5pdENsb25lQnlUYWcodmFsdWUsdGFnLGJhc2VDbG9uZSxpc0RlZXApO319Ly8gQ2hlY2sgZm9yIGNpcmN1bGFyIHJlZmVyZW5jZXMgYW5kIHJldHVybiBpdHMgY29ycmVzcG9uZGluZyBjbG9uZS5cbnN0YWNrfHwoc3RhY2s9bmV3IFN0YWNrKCkpO3ZhciBzdGFja2VkPXN0YWNrLmdldCh2YWx1ZSk7aWYoc3RhY2tlZCl7cmV0dXJuIHN0YWNrZWQ7fXN0YWNrLnNldCh2YWx1ZSxyZXN1bHQpO3ZhciBrZXlzRnVuYz1pc0Z1bGw/aXNGbGF0P2dldEFsbEtleXNJbjpnZXRBbGxLZXlzOmlzRmxhdD9rZXlzSW46a2V5czt2YXIgcHJvcHM9aXNBcnI/dW5kZWZpbmVkOmtleXNGdW5jKHZhbHVlKTthcnJheUVhY2gocHJvcHN8fHZhbHVlLGZ1bmN0aW9uKHN1YlZhbHVlLGtleSl7aWYocHJvcHMpe2tleT1zdWJWYWx1ZTtzdWJWYWx1ZT12YWx1ZVtrZXldO30vLyBSZWN1cnNpdmVseSBwb3B1bGF0ZSBjbG9uZSAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuYXNzaWduVmFsdWUocmVzdWx0LGtleSxiYXNlQ2xvbmUoc3ViVmFsdWUsYml0bWFzayxjdXN0b21pemVyLGtleSx2YWx1ZSxzdGFjaykpO30pO3JldHVybiByZXN1bHQ7fS8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNvbmZvcm1zYCB3aGljaCBkb2Vzbid0IGNsb25lIGBzb3VyY2VgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgcHJlZGljYXRlcyB0byBjb25mb3JtIHRvLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gICAgICovZnVuY3Rpb24gYmFzZUNvbmZvcm1zKHNvdXJjZSl7dmFyIHByb3BzPWtleXMoc291cmNlKTtyZXR1cm4gZnVuY3Rpb24ob2JqZWN0KXtyZXR1cm4gYmFzZUNvbmZvcm1zVG8ob2JqZWN0LHNvdXJjZSxwcm9wcyk7fTt9LyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uY29uZm9ybXNUb2Agd2hpY2ggYWNjZXB0cyBgcHJvcHNgIHRvIGNoZWNrLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgcHJlZGljYXRlcyB0byBjb25mb3JtIHRvLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgb2JqZWN0YCBjb25mb3JtcywgZWxzZSBgZmFsc2VgLlxuICAgICAqL2Z1bmN0aW9uIGJhc2VDb25mb3Jtc1RvKG9iamVjdCxzb3VyY2UscHJvcHMpe3ZhciBsZW5ndGg9cHJvcHMubGVuZ3RoO2lmKG9iamVjdD09bnVsbCl7cmV0dXJuIWxlbmd0aDt9b2JqZWN0PU9iamVjdChvYmplY3QpO3doaWxlKGxlbmd0aC0tKXt2YXIga2V5PXByb3BzW2xlbmd0aF0scHJlZGljYXRlPXNvdXJjZVtrZXldLHZhbHVlPW9iamVjdFtrZXldO2lmKHZhbHVlPT09dW5kZWZpbmVkJiYhKGtleSBpbiBvYmplY3QpfHwhcHJlZGljYXRlKHZhbHVlKSl7cmV0dXJuIGZhbHNlO319cmV0dXJuIHRydWU7fS8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmRlbGF5YCBhbmQgYF8uZGVmZXJgIHdoaWNoIGFjY2VwdHMgYGFyZ3NgXG4gICAgICogdG8gcHJvdmlkZSB0byBgZnVuY2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRlbGF5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3YWl0IFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIGRlbGF5IGludm9jYXRpb24uXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJncyBUaGUgYXJndW1lbnRzIHRvIHByb3ZpZGUgdG8gYGZ1bmNgLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ8T2JqZWN0fSBSZXR1cm5zIHRoZSB0aW1lciBpZCBvciB0aW1lb3V0IG9iamVjdC5cbiAgICAgKi9mdW5jdGlvbiBiYXNlRGVsYXkoZnVuYyx3YWl0LGFyZ3Mpe2lmKHR5cGVvZiBmdW5jIT0nZnVuY3Rpb24nKXt0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7fXJldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7ZnVuYy5hcHBseSh1bmRlZmluZWQsYXJncyk7fSx3YWl0KTt9LyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgbWV0aG9kcyBsaWtlIGBfLmRpZmZlcmVuY2VgIHdpdGhvdXQgc3VwcG9ydFxuICAgICAqIGZvciBleGNsdWRpbmcgbXVsdGlwbGUgYXJyYXlzIG9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgdmFsdWVzIHRvIGV4Y2x1ZGUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlXSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcGFyYXRvcl0gVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBmaWx0ZXJlZCB2YWx1ZXMuXG4gICAgICovZnVuY3Rpb24gYmFzZURpZmZlcmVuY2UoYXJyYXksdmFsdWVzLGl0ZXJhdGVlLGNvbXBhcmF0b3Ipe3ZhciBpbmRleD0tMSxpbmNsdWRlcz1hcnJheUluY2x1ZGVzLGlzQ29tbW9uPXRydWUsbGVuZ3RoPWFycmF5Lmxlbmd0aCxyZXN1bHQ9W10sdmFsdWVzTGVuZ3RoPXZhbHVlcy5sZW5ndGg7aWYoIWxlbmd0aCl7cmV0dXJuIHJlc3VsdDt9aWYoaXRlcmF0ZWUpe3ZhbHVlcz1hcnJheU1hcCh2YWx1ZXMsYmFzZVVuYXJ5KGl0ZXJhdGVlKSk7fWlmKGNvbXBhcmF0b3Ipe2luY2x1ZGVzPWFycmF5SW5jbHVkZXNXaXRoO2lzQ29tbW9uPWZhbHNlO31lbHNlIGlmKHZhbHVlcy5sZW5ndGg+PUxBUkdFX0FSUkFZX1NJWkUpe2luY2x1ZGVzPWNhY2hlSGFzO2lzQ29tbW9uPWZhbHNlO3ZhbHVlcz1uZXcgU2V0Q2FjaGUodmFsdWVzKTt9b3V0ZXI6d2hpbGUoKytpbmRleDxsZW5ndGgpe3ZhciB2YWx1ZT1hcnJheVtpbmRleF0sY29tcHV0ZWQ9aXRlcmF0ZWU9PW51bGw/dmFsdWU6aXRlcmF0ZWUodmFsdWUpO3ZhbHVlPWNvbXBhcmF0b3J8fHZhbHVlIT09MD92YWx1ZTowO2lmKGlzQ29tbW9uJiZjb21wdXRlZD09PWNvbXB1dGVkKXt2YXIgdmFsdWVzSW5kZXg9dmFsdWVzTGVuZ3RoO3doaWxlKHZhbHVlc0luZGV4LS0pe2lmKHZhbHVlc1t2YWx1ZXNJbmRleF09PT1jb21wdXRlZCl7Y29udGludWUgb3V0ZXI7fX1yZXN1bHQucHVzaCh2YWx1ZSk7fWVsc2UgaWYoIWluY2x1ZGVzKHZhbHVlcyxjb21wdXRlZCxjb21wYXJhdG9yKSl7cmVzdWx0LnB1c2godmFsdWUpO319cmV0dXJuIHJlc3VsdDt9LyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZm9yRWFjaGAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl8T2JqZWN0fSBSZXR1cm5zIGBjb2xsZWN0aW9uYC5cbiAgICAgKi92YXIgYmFzZUVhY2g9Y3JlYXRlQmFzZUVhY2goYmFzZUZvck93bik7LyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZm9yRWFjaFJpZ2h0YCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheXxPYmplY3R9IFJldHVybnMgYGNvbGxlY3Rpb25gLlxuICAgICAqL3ZhciBiYXNlRWFjaFJpZ2h0PWNyZWF0ZUJhc2VFYWNoKGJhc2VGb3JPd25SaWdodCx0cnVlKTsvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5ldmVyeWAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFsbCBlbGVtZW50cyBwYXNzIHRoZSBwcmVkaWNhdGUgY2hlY2ssXG4gICAgICogIGVsc2UgYGZhbHNlYFxuICAgICAqL2Z1bmN0aW9uIGJhc2VFdmVyeShjb2xsZWN0aW9uLHByZWRpY2F0ZSl7dmFyIHJlc3VsdD10cnVlO2Jhc2VFYWNoKGNvbGxlY3Rpb24sZnVuY3Rpb24odmFsdWUsaW5kZXgsY29sbGVjdGlvbil7cmVzdWx0PSEhcHJlZGljYXRlKHZhbHVlLGluZGV4LGNvbGxlY3Rpb24pO3JldHVybiByZXN1bHQ7fSk7cmV0dXJuIHJlc3VsdDt9LyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgbWV0aG9kcyBsaWtlIGBfLm1heGAgYW5kIGBfLm1pbmAgd2hpY2ggYWNjZXB0cyBhXG4gICAgICogYGNvbXBhcmF0b3JgIHRvIGRldGVybWluZSB0aGUgZXh0cmVtdW0gdmFsdWUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb21wYXJhdG9yIFRoZSBjb21wYXJhdG9yIHVzZWQgdG8gY29tcGFyZSB2YWx1ZXMuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGV4dHJlbXVtIHZhbHVlLlxuICAgICAqL2Z1bmN0aW9uIGJhc2VFeHRyZW11bShhcnJheSxpdGVyYXRlZSxjb21wYXJhdG9yKXt2YXIgaW5kZXg9LTEsbGVuZ3RoPWFycmF5Lmxlbmd0aDt3aGlsZSgrK2luZGV4PGxlbmd0aCl7dmFyIHZhbHVlPWFycmF5W2luZGV4XSxjdXJyZW50PWl0ZXJhdGVlKHZhbHVlKTtpZihjdXJyZW50IT1udWxsJiYoY29tcHV0ZWQ9PT11bmRlZmluZWQ/Y3VycmVudD09PWN1cnJlbnQmJiFpc1N5bWJvbChjdXJyZW50KTpjb21wYXJhdG9yKGN1cnJlbnQsY29tcHV0ZWQpKSl7dmFyIGNvbXB1dGVkPWN1cnJlbnQscmVzdWx0PXZhbHVlO319cmV0dXJuIHJlc3VsdDt9LyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZmlsbGAgd2l0aG91dCBhbiBpdGVyYXRlZSBjYWxsIGd1YXJkLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gZmlsbC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBmaWxsIGBhcnJheWAgd2l0aC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PTBdIFRoZSBzdGFydCBwb3NpdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2VuZD1hcnJheS5sZW5ndGhdIFRoZSBlbmQgcG9zaXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICovZnVuY3Rpb24gYmFzZUZpbGwoYXJyYXksdmFsdWUsc3RhcnQsZW5kKXt2YXIgbGVuZ3RoPWFycmF5Lmxlbmd0aDtzdGFydD10b0ludGVnZXIoc3RhcnQpO2lmKHN0YXJ0PDApe3N0YXJ0PS1zdGFydD5sZW5ndGg/MDpsZW5ndGgrc3RhcnQ7fWVuZD1lbmQ9PT11bmRlZmluZWR8fGVuZD5sZW5ndGg/bGVuZ3RoOnRvSW50ZWdlcihlbmQpO2lmKGVuZDwwKXtlbmQrPWxlbmd0aDt9ZW5kPXN0YXJ0PmVuZD8wOnRvTGVuZ3RoKGVuZCk7d2hpbGUoc3RhcnQ8ZW5kKXthcnJheVtzdGFydCsrXT12YWx1ZTt9cmV0dXJuIGFycmF5O30vKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5maWx0ZXJgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZpbHRlcmVkIGFycmF5LlxuICAgICAqL2Z1bmN0aW9uIGJhc2VGaWx0ZXIoY29sbGVjdGlvbixwcmVkaWNhdGUpe3ZhciByZXN1bHQ9W107YmFzZUVhY2goY29sbGVjdGlvbixmdW5jdGlvbih2YWx1ZSxpbmRleCxjb2xsZWN0aW9uKXtpZihwcmVkaWNhdGUodmFsdWUsaW5kZXgsY29sbGVjdGlvbikpe3Jlc3VsdC5wdXNoKHZhbHVlKTt9fSk7cmV0dXJuIHJlc3VsdDt9LyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZmxhdHRlbmAgd2l0aCBzdXBwb3J0IGZvciByZXN0cmljdGluZyBmbGF0dGVuaW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gZmxhdHRlbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZGVwdGggVGhlIG1heGltdW0gcmVjdXJzaW9uIGRlcHRoLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3ByZWRpY2F0ZT1pc0ZsYXR0ZW5hYmxlXSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzU3RyaWN0XSBSZXN0cmljdCB0byB2YWx1ZXMgdGhhdCBwYXNzIGBwcmVkaWNhdGVgIGNoZWNrcy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcmVzdWx0PVtdXSBUaGUgaW5pdGlhbCByZXN1bHQgdmFsdWUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICAgICAqL2Z1bmN0aW9uIGJhc2VGbGF0dGVuKGFycmF5LGRlcHRoLHByZWRpY2F0ZSxpc1N0cmljdCxyZXN1bHQpe3ZhciBpbmRleD0tMSxsZW5ndGg9YXJyYXkubGVuZ3RoO3ByZWRpY2F0ZXx8KHByZWRpY2F0ZT1pc0ZsYXR0ZW5hYmxlKTtyZXN1bHR8fChyZXN1bHQ9W10pO3doaWxlKCsraW5kZXg8bGVuZ3RoKXt2YXIgdmFsdWU9YXJyYXlbaW5kZXhdO2lmKGRlcHRoPjAmJnByZWRpY2F0ZSh2YWx1ZSkpe2lmKGRlcHRoPjEpey8vIFJlY3Vyc2l2ZWx5IGZsYXR0ZW4gYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG5iYXNlRmxhdHRlbih2YWx1ZSxkZXB0aC0xLHByZWRpY2F0ZSxpc1N0cmljdCxyZXN1bHQpO31lbHNle2FycmF5UHVzaChyZXN1bHQsdmFsdWUpO319ZWxzZSBpZighaXNTdHJpY3Qpe3Jlc3VsdFtyZXN1bHQubGVuZ3RoXT12YWx1ZTt9fXJldHVybiByZXN1bHQ7fS8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBiYXNlRm9yT3duYCB3aGljaCBpdGVyYXRlcyBvdmVyIGBvYmplY3RgXG4gICAgICogcHJvcGVydGllcyByZXR1cm5lZCBieSBga2V5c0Z1bmNgIGFuZCBpbnZva2VzIGBpdGVyYXRlZWAgZm9yIGVhY2ggcHJvcGVydHkuXG4gICAgICogSXRlcmF0ZWUgZnVuY3Rpb25zIG1heSBleGl0IGl0ZXJhdGlvbiBlYXJseSBieSBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5c0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUga2V5cyBvZiBgb2JqZWN0YC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqL3ZhciBiYXNlRm9yPWNyZWF0ZUJhc2VGb3IoKTsvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGxpa2UgYGJhc2VGb3JgIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgcHJvcGVydGllc1xuICAgICAqIGluIHRoZSBvcHBvc2l0ZSBvcmRlci5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGtleXNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIGtleXMgb2YgYG9iamVjdGAuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKi92YXIgYmFzZUZvclJpZ2h0PWNyZWF0ZUJhc2VGb3IodHJ1ZSk7LyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZm9yT3duYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqL2Z1bmN0aW9uIGJhc2VGb3JPd24ob2JqZWN0LGl0ZXJhdGVlKXtyZXR1cm4gb2JqZWN0JiZiYXNlRm9yKG9iamVjdCxpdGVyYXRlZSxrZXlzKTt9LyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZm9yT3duUmlnaHRgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICovZnVuY3Rpb24gYmFzZUZvck93blJpZ2h0KG9iamVjdCxpdGVyYXRlZSl7cmV0dXJuIG9iamVjdCYmYmFzZUZvclJpZ2h0KG9iamVjdCxpdGVyYXRlZSxrZXlzKTt9LyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZnVuY3Rpb25zYCB3aGljaCBjcmVhdGVzIGFuIGFycmF5IG9mXG4gICAgICogYG9iamVjdGAgZnVuY3Rpb24gcHJvcGVydHkgbmFtZXMgZmlsdGVyZWQgZnJvbSBgcHJvcHNgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwcm9wcyBUaGUgcHJvcGVydHkgbmFtZXMgdG8gZmlsdGVyLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgZnVuY3Rpb24gbmFtZXMuXG4gICAgICovZnVuY3Rpb24gYmFzZUZ1bmN0aW9ucyhvYmplY3QscHJvcHMpe3JldHVybiBhcnJheUZpbHRlcihwcm9wcyxmdW5jdGlvbihrZXkpe3JldHVybiBpc0Z1bmN0aW9uKG9iamVjdFtrZXldKTt9KTt9LyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZ2V0YCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZmF1bHQgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG4gICAgICovZnVuY3Rpb24gYmFzZUdldChvYmplY3QscGF0aCl7cGF0aD1jYXN0UGF0aChwYXRoLG9iamVjdCk7dmFyIGluZGV4PTAsbGVuZ3RoPXBhdGgubGVuZ3RoO3doaWxlKG9iamVjdCE9bnVsbCYmaW5kZXg8bGVuZ3RoKXtvYmplY3Q9b2JqZWN0W3RvS2V5KHBhdGhbaW5kZXgrK10pXTt9cmV0dXJuIGluZGV4JiZpbmRleD09bGVuZ3RoP29iamVjdDp1bmRlZmluZWQ7fS8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRBbGxLZXlzYCBhbmQgYGdldEFsbEtleXNJbmAgd2hpY2ggdXNlc1xuICAgICAqIGBrZXlzRnVuY2AgYW5kIGBzeW1ib2xzRnVuY2AgdG8gZ2V0IHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIGFuZFxuICAgICAqIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBrZXlzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBrZXlzIG9mIGBvYmplY3RgLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHN5bWJvbHNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scy5cbiAgICAgKi9mdW5jdGlvbiBiYXNlR2V0QWxsS2V5cyhvYmplY3Qsa2V5c0Z1bmMsc3ltYm9sc0Z1bmMpe3ZhciByZXN1bHQ9a2V5c0Z1bmMob2JqZWN0KTtyZXR1cm4gaXNBcnJheShvYmplY3QpP3Jlc3VsdDphcnJheVB1c2gocmVzdWx0LHN5bWJvbHNGdW5jKG9iamVjdCkpO30vKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0VGFnYCB3aXRob3V0IGZhbGxiYWNrcyBmb3IgYnVnZ3kgZW52aXJvbm1lbnRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICAgICAqL2Z1bmN0aW9uIGJhc2VHZXRUYWcodmFsdWUpe2lmKHZhbHVlPT1udWxsKXtyZXR1cm4gdmFsdWU9PT11bmRlZmluZWQ/dW5kZWZpbmVkVGFnOm51bGxUYWc7fXJldHVybiBzeW1Ub1N0cmluZ1RhZyYmc3ltVG9TdHJpbmdUYWcgaW4gT2JqZWN0KHZhbHVlKT9nZXRSYXdUYWcodmFsdWUpOm9iamVjdFRvU3RyaW5nKHZhbHVlKTt9LyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZ3RgIHdoaWNoIGRvZXNuJ3QgY29lcmNlIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGdyZWF0ZXIgdGhhbiBgb3RoZXJgLFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICovZnVuY3Rpb24gYmFzZUd0KHZhbHVlLG90aGVyKXtyZXR1cm4gdmFsdWU+b3RoZXI7fS8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmhhc2Agd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30ga2V5IFRoZSBrZXkgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICAgICAqL2Z1bmN0aW9uIGJhc2VIYXMob2JqZWN0LGtleSl7cmV0dXJuIG9iamVjdCE9bnVsbCYmaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3Qsa2V5KTt9LyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaGFzSW5gIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVlcCBwYXRocy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IGtleSBUaGUga2V5IHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9mdW5jdGlvbiBiYXNlSGFzSW4ob2JqZWN0LGtleSl7cmV0dXJuIG9iamVjdCE9bnVsbCYma2V5IGluIE9iamVjdChvYmplY3QpO30vKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pblJhbmdlYCB3aGljaCBkb2Vzbid0IGNvZXJjZSBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBudW1iZXIgVGhlIG51bWJlciB0byBjaGVjay5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgVGhlIHN0YXJ0IG9mIHRoZSByYW5nZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZW5kIFRoZSBlbmQgb2YgdGhlIHJhbmdlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgbnVtYmVyYCBpcyBpbiB0aGUgcmFuZ2UsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9mdW5jdGlvbiBiYXNlSW5SYW5nZShudW1iZXIsc3RhcnQsZW5kKXtyZXR1cm4gbnVtYmVyPj1uYXRpdmVNaW4oc3RhcnQsZW5kKSYmbnVtYmVyPG5hdGl2ZU1heChzdGFydCxlbmQpO30vKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBtZXRob2RzIGxpa2UgYF8uaW50ZXJzZWN0aW9uYCwgd2l0aG91dCBzdXBwb3J0XG4gICAgICogZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMsIHRoYXQgYWNjZXB0cyBhbiBhcnJheSBvZiBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXlzIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWVdIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJhdG9yXSBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIHNoYXJlZCB2YWx1ZXMuXG4gICAgICovZnVuY3Rpb24gYmFzZUludGVyc2VjdGlvbihhcnJheXMsaXRlcmF0ZWUsY29tcGFyYXRvcil7dmFyIGluY2x1ZGVzPWNvbXBhcmF0b3I/YXJyYXlJbmNsdWRlc1dpdGg6YXJyYXlJbmNsdWRlcyxsZW5ndGg9YXJyYXlzWzBdLmxlbmd0aCxvdGhMZW5ndGg9YXJyYXlzLmxlbmd0aCxvdGhJbmRleD1vdGhMZW5ndGgsY2FjaGVzPUFycmF5KG90aExlbmd0aCksbWF4TGVuZ3RoPUluZmluaXR5LHJlc3VsdD1bXTt3aGlsZShvdGhJbmRleC0tKXt2YXIgYXJyYXk9YXJyYXlzW290aEluZGV4XTtpZihvdGhJbmRleCYmaXRlcmF0ZWUpe2FycmF5PWFycmF5TWFwKGFycmF5LGJhc2VVbmFyeShpdGVyYXRlZSkpO31tYXhMZW5ndGg9bmF0aXZlTWluKGFycmF5Lmxlbmd0aCxtYXhMZW5ndGgpO2NhY2hlc1tvdGhJbmRleF09IWNvbXBhcmF0b3ImJihpdGVyYXRlZXx8bGVuZ3RoPj0xMjAmJmFycmF5Lmxlbmd0aD49MTIwKT9uZXcgU2V0Q2FjaGUob3RoSW5kZXgmJmFycmF5KTp1bmRlZmluZWQ7fWFycmF5PWFycmF5c1swXTt2YXIgaW5kZXg9LTEsc2Vlbj1jYWNoZXNbMF07b3V0ZXI6d2hpbGUoKytpbmRleDxsZW5ndGgmJnJlc3VsdC5sZW5ndGg8bWF4TGVuZ3RoKXt2YXIgdmFsdWU9YXJyYXlbaW5kZXhdLGNvbXB1dGVkPWl0ZXJhdGVlP2l0ZXJhdGVlKHZhbHVlKTp2YWx1ZTt2YWx1ZT1jb21wYXJhdG9yfHx2YWx1ZSE9PTA/dmFsdWU6MDtpZighKHNlZW4/Y2FjaGVIYXMoc2Vlbixjb21wdXRlZCk6aW5jbHVkZXMocmVzdWx0LGNvbXB1dGVkLGNvbXBhcmF0b3IpKSl7b3RoSW5kZXg9b3RoTGVuZ3RoO3doaWxlKC0tb3RoSW5kZXgpe3ZhciBjYWNoZT1jYWNoZXNbb3RoSW5kZXhdO2lmKCEoY2FjaGU/Y2FjaGVIYXMoY2FjaGUsY29tcHV0ZWQpOmluY2x1ZGVzKGFycmF5c1tvdGhJbmRleF0sY29tcHV0ZWQsY29tcGFyYXRvcikpKXtjb250aW51ZSBvdXRlcjt9fWlmKHNlZW4pe3NlZW4ucHVzaChjb21wdXRlZCk7fXJlc3VsdC5wdXNoKHZhbHVlKTt9fXJldHVybiByZXN1bHQ7fS8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmludmVydGAgYW5kIGBfLmludmVydEJ5YCB3aGljaCBpbnZlcnRzXG4gICAgICogYG9iamVjdGAgd2l0aCB2YWx1ZXMgdHJhbnNmb3JtZWQgYnkgYGl0ZXJhdGVlYCBhbmQgc2V0IGJ5IGBzZXR0ZXJgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHNldHRlciBUaGUgZnVuY3Rpb24gdG8gc2V0IGBhY2N1bXVsYXRvcmAgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBpdGVyYXRlZSB0byB0cmFuc2Zvcm0gdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhY2N1bXVsYXRvciBUaGUgaW5pdGlhbCBpbnZlcnRlZCBvYmplY3QuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBhY2N1bXVsYXRvcmAuXG4gICAgICovZnVuY3Rpb24gYmFzZUludmVydGVyKG9iamVjdCxzZXR0ZXIsaXRlcmF0ZWUsYWNjdW11bGF0b3Ipe2Jhc2VGb3JPd24ob2JqZWN0LGZ1bmN0aW9uKHZhbHVlLGtleSxvYmplY3Qpe3NldHRlcihhY2N1bXVsYXRvcixpdGVyYXRlZSh2YWx1ZSksa2V5LG9iamVjdCk7fSk7cmV0dXJuIGFjY3VtdWxhdG9yO30vKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pbnZva2VgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaW5kaXZpZHVhbFxuICAgICAqIG1ldGhvZCBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgbWV0aG9kIHRvIGludm9rZS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcmdzIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIHRoZSBtZXRob2Qgd2l0aC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzdWx0IG9mIHRoZSBpbnZva2VkIG1ldGhvZC5cbiAgICAgKi9mdW5jdGlvbiBiYXNlSW52b2tlKG9iamVjdCxwYXRoLGFyZ3Mpe3BhdGg9Y2FzdFBhdGgocGF0aCxvYmplY3QpO29iamVjdD1wYXJlbnQob2JqZWN0LHBhdGgpO3ZhciBmdW5jPW9iamVjdD09bnVsbD9vYmplY3Q6b2JqZWN0W3RvS2V5KGxhc3QocGF0aCkpXTtyZXR1cm4gZnVuYz09bnVsbD91bmRlZmluZWQ6YXBwbHkoZnVuYyxvYmplY3QsYXJncyk7fS8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzQXJndW1lbnRzYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICAgICAqL2Z1bmN0aW9uIGJhc2VJc0FyZ3VtZW50cyh2YWx1ZSl7cmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkmJmJhc2VHZXRUYWcodmFsdWUpPT1hcmdzVGFnO30vKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0FycmF5QnVmZmVyYCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXkgYnVmZmVyLCBlbHNlIGBmYWxzZWAuXG4gICAgICovZnVuY3Rpb24gYmFzZUlzQXJyYXlCdWZmZXIodmFsdWUpe3JldHVybiBpc09iamVjdExpa2UodmFsdWUpJiZiYXNlR2V0VGFnKHZhbHVlKT09YXJyYXlCdWZmZXJUYWc7fS8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzRGF0ZWAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZGF0ZSBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9mdW5jdGlvbiBiYXNlSXNEYXRlKHZhbHVlKXtyZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSYmYmFzZUdldFRhZyh2YWx1ZSk9PWRhdGVUYWc7fS8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzRXF1YWxgIHdoaWNoIHN1cHBvcnRzIHBhcnRpYWwgY29tcGFyaXNvbnNcbiAgICAgKiBhbmQgdHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLlxuICAgICAqICAxIC0gVW5vcmRlcmVkIGNvbXBhcmlzb25cbiAgICAgKiAgMiAtIFBhcnRpYWwgY29tcGFyaXNvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgYHZhbHVlYCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gICAgICovZnVuY3Rpb24gYmFzZUlzRXF1YWwodmFsdWUsb3RoZXIsYml0bWFzayxjdXN0b21pemVyLHN0YWNrKXtpZih2YWx1ZT09PW90aGVyKXtyZXR1cm4gdHJ1ZTt9aWYodmFsdWU9PW51bGx8fG90aGVyPT1udWxsfHwhaXNPYmplY3RMaWtlKHZhbHVlKSYmIWlzT2JqZWN0TGlrZShvdGhlcikpe3JldHVybiB2YWx1ZSE9PXZhbHVlJiZvdGhlciE9PW90aGVyO31yZXR1cm4gYmFzZUlzRXF1YWxEZWVwKHZhbHVlLG90aGVyLGJpdG1hc2ssY3VzdG9taXplcixiYXNlSXNFcXVhbCxzdGFjayk7fS8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxgIGZvciBhcnJheXMgYW5kIG9iamVjdHMgd2hpY2ggcGVyZm9ybXNcbiAgICAgKiBkZWVwIGNvbXBhcmlzb25zIGFuZCB0cmFja3MgdHJhdmVyc2VkIG9iamVjdHMgZW5hYmxpbmcgb2JqZWN0cyB3aXRoIGNpcmN1bGFyXG4gICAgICogcmVmZXJlbmNlcyB0byBiZSBjb21wYXJlZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgYG9iamVjdGAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9mdW5jdGlvbiBiYXNlSXNFcXVhbERlZXAob2JqZWN0LG90aGVyLGJpdG1hc2ssY3VzdG9taXplcixlcXVhbEZ1bmMsc3RhY2spe3ZhciBvYmpJc0Fycj1pc0FycmF5KG9iamVjdCksb3RoSXNBcnI9aXNBcnJheShvdGhlciksb2JqVGFnPW9iaklzQXJyP2FycmF5VGFnOmdldFRhZyhvYmplY3QpLG90aFRhZz1vdGhJc0Fycj9hcnJheVRhZzpnZXRUYWcob3RoZXIpO29ialRhZz1vYmpUYWc9PWFyZ3NUYWc/b2JqZWN0VGFnOm9ialRhZztvdGhUYWc9b3RoVGFnPT1hcmdzVGFnP29iamVjdFRhZzpvdGhUYWc7dmFyIG9iaklzT2JqPW9ialRhZz09b2JqZWN0VGFnLG90aElzT2JqPW90aFRhZz09b2JqZWN0VGFnLGlzU2FtZVRhZz1vYmpUYWc9PW90aFRhZztpZihpc1NhbWVUYWcmJmlzQnVmZmVyKG9iamVjdCkpe2lmKCFpc0J1ZmZlcihvdGhlcikpe3JldHVybiBmYWxzZTt9b2JqSXNBcnI9dHJ1ZTtvYmpJc09iaj1mYWxzZTt9aWYoaXNTYW1lVGFnJiYhb2JqSXNPYmope3N0YWNrfHwoc3RhY2s9bmV3IFN0YWNrKCkpO3JldHVybiBvYmpJc0Fycnx8aXNUeXBlZEFycmF5KG9iamVjdCk/ZXF1YWxBcnJheXMob2JqZWN0LG90aGVyLGJpdG1hc2ssY3VzdG9taXplcixlcXVhbEZ1bmMsc3RhY2spOmVxdWFsQnlUYWcob2JqZWN0LG90aGVyLG9ialRhZyxiaXRtYXNrLGN1c3RvbWl6ZXIsZXF1YWxGdW5jLHN0YWNrKTt9aWYoIShiaXRtYXNrJkNPTVBBUkVfUEFSVElBTF9GTEFHKSl7dmFyIG9iaklzV3JhcHBlZD1vYmpJc09iaiYmaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsJ19fd3JhcHBlZF9fJyksb3RoSXNXcmFwcGVkPW90aElzT2JqJiZoYXNPd25Qcm9wZXJ0eS5jYWxsKG90aGVyLCdfX3dyYXBwZWRfXycpO2lmKG9iaklzV3JhcHBlZHx8b3RoSXNXcmFwcGVkKXt2YXIgb2JqVW53cmFwcGVkPW9iaklzV3JhcHBlZD9vYmplY3QudmFsdWUoKTpvYmplY3Qsb3RoVW53cmFwcGVkPW90aElzV3JhcHBlZD9vdGhlci52YWx1ZSgpOm90aGVyO3N0YWNrfHwoc3RhY2s9bmV3IFN0YWNrKCkpO3JldHVybiBlcXVhbEZ1bmMob2JqVW53cmFwcGVkLG90aFVud3JhcHBlZCxiaXRtYXNrLGN1c3RvbWl6ZXIsc3RhY2spO319aWYoIWlzU2FtZVRhZyl7cmV0dXJuIGZhbHNlO31zdGFja3x8KHN0YWNrPW5ldyBTdGFjaygpKTtyZXR1cm4gZXF1YWxPYmplY3RzKG9iamVjdCxvdGhlcixiaXRtYXNrLGN1c3RvbWl6ZXIsZXF1YWxGdW5jLHN0YWNrKTt9LyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNNYXBgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG1hcCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL2Z1bmN0aW9uIGJhc2VJc01hcCh2YWx1ZSl7cmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkmJmdldFRhZyh2YWx1ZSk9PW1hcFRhZzt9LyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNNYXRjaGAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIG1hdGNoLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IG1hdGNoRGF0YSBUaGUgcHJvcGVydHkgbmFtZXMsIHZhbHVlcywgYW5kIGNvbXBhcmUgZmxhZ3MgdG8gbWF0Y2guXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBvYmplY3RgIGlzIGEgbWF0Y2gsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9mdW5jdGlvbiBiYXNlSXNNYXRjaChvYmplY3Qsc291cmNlLG1hdGNoRGF0YSxjdXN0b21pemVyKXt2YXIgaW5kZXg9bWF0Y2hEYXRhLmxlbmd0aCxsZW5ndGg9aW5kZXgsbm9DdXN0b21pemVyPSFjdXN0b21pemVyO2lmKG9iamVjdD09bnVsbCl7cmV0dXJuIWxlbmd0aDt9b2JqZWN0PU9iamVjdChvYmplY3QpO3doaWxlKGluZGV4LS0pe3ZhciBkYXRhPW1hdGNoRGF0YVtpbmRleF07aWYobm9DdXN0b21pemVyJiZkYXRhWzJdP2RhdGFbMV0hPT1vYmplY3RbZGF0YVswXV06IShkYXRhWzBdaW4gb2JqZWN0KSl7cmV0dXJuIGZhbHNlO319d2hpbGUoKytpbmRleDxsZW5ndGgpe2RhdGE9bWF0Y2hEYXRhW2luZGV4XTt2YXIga2V5PWRhdGFbMF0sb2JqVmFsdWU9b2JqZWN0W2tleV0sc3JjVmFsdWU9ZGF0YVsxXTtpZihub0N1c3RvbWl6ZXImJmRhdGFbMl0pe2lmKG9ialZhbHVlPT09dW5kZWZpbmVkJiYhKGtleSBpbiBvYmplY3QpKXtyZXR1cm4gZmFsc2U7fX1lbHNle3ZhciBzdGFjaz1uZXcgU3RhY2soKTtpZihjdXN0b21pemVyKXt2YXIgcmVzdWx0PWN1c3RvbWl6ZXIob2JqVmFsdWUsc3JjVmFsdWUsa2V5LG9iamVjdCxzb3VyY2Usc3RhY2spO31pZighKHJlc3VsdD09PXVuZGVmaW5lZD9iYXNlSXNFcXVhbChzcmNWYWx1ZSxvYmpWYWx1ZSxDT01QQVJFX1BBUlRJQUxfRkxBR3xDT01QQVJFX1VOT1JERVJFRF9GTEFHLGN1c3RvbWl6ZXIsc3RhY2spOnJlc3VsdCkpe3JldHVybiBmYWxzZTt9fX1yZXR1cm4gdHJ1ZTt9LyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNOYXRpdmVgIHdpdGhvdXQgYmFkIHNoaW0gY2hlY2tzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbixcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqL2Z1bmN0aW9uIGJhc2VJc05hdGl2ZSh2YWx1ZSl7aWYoIWlzT2JqZWN0KHZhbHVlKXx8aXNNYXNrZWQodmFsdWUpKXtyZXR1cm4gZmFsc2U7fXZhciBwYXR0ZXJuPWlzRnVuY3Rpb24odmFsdWUpP3JlSXNOYXRpdmU6cmVJc0hvc3RDdG9yO3JldHVybiBwYXR0ZXJuLnRlc3QodG9Tb3VyY2UodmFsdWUpKTt9LyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNSZWdFeHBgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHJlZ2V4cCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL2Z1bmN0aW9uIGJhc2VJc1JlZ0V4cCh2YWx1ZSl7cmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkmJmJhc2VHZXRUYWcodmFsdWUpPT1yZWdleHBUYWc7fS8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzU2V0YCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzZXQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9mdW5jdGlvbiBiYXNlSXNTZXQodmFsdWUpe3JldHVybiBpc09iamVjdExpa2UodmFsdWUpJiZnZXRUYWcodmFsdWUpPT1zZXRUYWc7fS8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzVHlwZWRBcnJheWAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdHlwZWQgYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9mdW5jdGlvbiBiYXNlSXNUeXBlZEFycmF5KHZhbHVlKXtyZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSYmaXNMZW5ndGgodmFsdWUubGVuZ3RoKSYmISF0eXBlZEFycmF5VGFnc1tiYXNlR2V0VGFnKHZhbHVlKV07fS8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLml0ZXJhdGVlYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSBbdmFsdWU9Xy5pZGVudGl0eV0gVGhlIHZhbHVlIHRvIGNvbnZlcnQgdG8gYW4gaXRlcmF0ZWUuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBpdGVyYXRlZS5cbiAgICAgKi9mdW5jdGlvbiBiYXNlSXRlcmF0ZWUodmFsdWUpey8vIERvbid0IHN0b3JlIHRoZSBgdHlwZW9mYCByZXN1bHQgaW4gYSB2YXJpYWJsZSB0byBhdm9pZCBhIEpJVCBidWcgaW4gU2FmYXJpIDkuXG4vLyBTZWUgaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTE1NjAzNCBmb3IgbW9yZSBkZXRhaWxzLlxuaWYodHlwZW9mIHZhbHVlPT0nZnVuY3Rpb24nKXtyZXR1cm4gdmFsdWU7fWlmKHZhbHVlPT1udWxsKXtyZXR1cm4gaWRlbnRpdHk7fWlmKHR5cGVvZiB2YWx1ZT09J29iamVjdCcpe3JldHVybiBpc0FycmF5KHZhbHVlKT9iYXNlTWF0Y2hlc1Byb3BlcnR5KHZhbHVlWzBdLHZhbHVlWzFdKTpiYXNlTWF0Y2hlcyh2YWx1ZSk7fXJldHVybiBwcm9wZXJ0eSh2YWx1ZSk7fS8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmtleXNgIHdoaWNoIGRvZXNuJ3QgdHJlYXQgc3BhcnNlIGFycmF5cyBhcyBkZW5zZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gICAgICovZnVuY3Rpb24gYmFzZUtleXMob2JqZWN0KXtpZighaXNQcm90b3R5cGUob2JqZWN0KSl7cmV0dXJuIG5hdGl2ZUtleXMob2JqZWN0KTt9dmFyIHJlc3VsdD1bXTtmb3IodmFyIGtleSBpbiBPYmplY3Qob2JqZWN0KSl7aWYoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3Qsa2V5KSYma2V5IT0nY29uc3RydWN0b3InKXtyZXN1bHQucHVzaChrZXkpO319cmV0dXJuIHJlc3VsdDt9LyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ua2V5c0luYCB3aGljaCBkb2Vzbid0IHRyZWF0IHNwYXJzZSBhcnJheXMgYXMgZGVuc2UuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICAgICAqL2Z1bmN0aW9uIGJhc2VLZXlzSW4ob2JqZWN0KXtpZighaXNPYmplY3Qob2JqZWN0KSl7cmV0dXJuIG5hdGl2ZUtleXNJbihvYmplY3QpO312YXIgaXNQcm90bz1pc1Byb3RvdHlwZShvYmplY3QpLHJlc3VsdD1bXTtmb3IodmFyIGtleSBpbiBvYmplY3Qpe2lmKCEoa2V5PT0nY29uc3RydWN0b3InJiYoaXNQcm90b3x8IWhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LGtleSkpKSl7cmVzdWx0LnB1c2goa2V5KTt9fXJldHVybiByZXN1bHQ7fS8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmx0YCB3aGljaCBkb2Vzbid0IGNvZXJjZSBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBsZXNzIHRoYW4gYG90aGVyYCxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqL2Z1bmN0aW9uIGJhc2VMdCh2YWx1ZSxvdGhlcil7cmV0dXJuIHZhbHVlPG90aGVyO30vKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tYXBgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIGFycmF5LlxuICAgICAqL2Z1bmN0aW9uIGJhc2VNYXAoY29sbGVjdGlvbixpdGVyYXRlZSl7dmFyIGluZGV4PS0xLHJlc3VsdD1pc0FycmF5TGlrZShjb2xsZWN0aW9uKT9BcnJheShjb2xsZWN0aW9uLmxlbmd0aCk6W107YmFzZUVhY2goY29sbGVjdGlvbixmdW5jdGlvbih2YWx1ZSxrZXksY29sbGVjdGlvbil7cmVzdWx0WysraW5kZXhdPWl0ZXJhdGVlKHZhbHVlLGtleSxjb2xsZWN0aW9uKTt9KTtyZXR1cm4gcmVzdWx0O30vKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tYXRjaGVzYCB3aGljaCBkb2Vzbid0IGNsb25lIGBzb3VyY2VgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIG1hdGNoLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gICAgICovZnVuY3Rpb24gYmFzZU1hdGNoZXMoc291cmNlKXt2YXIgbWF0Y2hEYXRhPWdldE1hdGNoRGF0YShzb3VyY2UpO2lmKG1hdGNoRGF0YS5sZW5ndGg9PTEmJm1hdGNoRGF0YVswXVsyXSl7cmV0dXJuIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlKG1hdGNoRGF0YVswXVswXSxtYXRjaERhdGFbMF1bMV0pO31yZXR1cm4gZnVuY3Rpb24ob2JqZWN0KXtyZXR1cm4gb2JqZWN0PT09c291cmNlfHxiYXNlSXNNYXRjaChvYmplY3Qsc291cmNlLG1hdGNoRGF0YSk7fTt9LyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWF0Y2hlc1Byb3BlcnR5YCB3aGljaCBkb2Vzbid0IGNsb25lIGBzcmNWYWx1ZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gICAgICogQHBhcmFtIHsqfSBzcmNWYWx1ZSBUaGUgdmFsdWUgdG8gbWF0Y2guXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAgICAgKi9mdW5jdGlvbiBiYXNlTWF0Y2hlc1Byb3BlcnR5KHBhdGgsc3JjVmFsdWUpe2lmKGlzS2V5KHBhdGgpJiZpc1N0cmljdENvbXBhcmFibGUoc3JjVmFsdWUpKXtyZXR1cm4gbWF0Y2hlc1N0cmljdENvbXBhcmFibGUodG9LZXkocGF0aCksc3JjVmFsdWUpO31yZXR1cm4gZnVuY3Rpb24ob2JqZWN0KXt2YXIgb2JqVmFsdWU9Z2V0KG9iamVjdCxwYXRoKTtyZXR1cm4gb2JqVmFsdWU9PT11bmRlZmluZWQmJm9ialZhbHVlPT09c3JjVmFsdWU/aGFzSW4ob2JqZWN0LHBhdGgpOmJhc2VJc0VxdWFsKHNyY1ZhbHVlLG9ialZhbHVlLENPTVBBUkVfUEFSVElBTF9GTEFHfENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcpO307fS8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1lcmdlYCB3aXRob3V0IHN1cHBvcnQgZm9yIG11bHRpcGxlIHNvdXJjZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzcmNJbmRleCBUaGUgaW5kZXggb2YgYHNvdXJjZWAuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgbWVyZ2VkIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIHNvdXJjZSB2YWx1ZXMgYW5kIHRoZWlyIG1lcmdlZFxuICAgICAqICBjb3VudGVycGFydHMuXG4gICAgICovZnVuY3Rpb24gYmFzZU1lcmdlKG9iamVjdCxzb3VyY2Usc3JjSW5kZXgsY3VzdG9taXplcixzdGFjayl7aWYob2JqZWN0PT09c291cmNlKXtyZXR1cm47fWJhc2VGb3Ioc291cmNlLGZ1bmN0aW9uKHNyY1ZhbHVlLGtleSl7aWYoaXNPYmplY3Qoc3JjVmFsdWUpKXtzdGFja3x8KHN0YWNrPW5ldyBTdGFjaygpKTtiYXNlTWVyZ2VEZWVwKG9iamVjdCxzb3VyY2Usa2V5LHNyY0luZGV4LGJhc2VNZXJnZSxjdXN0b21pemVyLHN0YWNrKTt9ZWxzZXt2YXIgbmV3VmFsdWU9Y3VzdG9taXplcj9jdXN0b21pemVyKG9iamVjdFtrZXldLHNyY1ZhbHVlLGtleSsnJyxvYmplY3Qsc291cmNlLHN0YWNrKTp1bmRlZmluZWQ7aWYobmV3VmFsdWU9PT11bmRlZmluZWQpe25ld1ZhbHVlPXNyY1ZhbHVlO31hc3NpZ25NZXJnZVZhbHVlKG9iamVjdCxrZXksbmV3VmFsdWUpO319LGtleXNJbik7fS8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZU1lcmdlYCBmb3IgYXJyYXlzIGFuZCBvYmplY3RzIHdoaWNoIHBlcmZvcm1zXG4gICAgICogZGVlcCBtZXJnZXMgYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cyBlbmFibGluZyBvYmplY3RzIHdpdGggY2lyY3VsYXJcbiAgICAgKiByZWZlcmVuY2VzIHRvIGJlIG1lcmdlZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBtZXJnZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3JjSW5kZXggVGhlIGluZGV4IG9mIGBzb3VyY2VgLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IG1lcmdlRnVuYyBUaGUgZnVuY3Rpb24gdG8gbWVyZ2UgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGFzc2lnbmVkIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIHNvdXJjZSB2YWx1ZXMgYW5kIHRoZWlyIG1lcmdlZFxuICAgICAqICBjb3VudGVycGFydHMuXG4gICAgICovZnVuY3Rpb24gYmFzZU1lcmdlRGVlcChvYmplY3Qsc291cmNlLGtleSxzcmNJbmRleCxtZXJnZUZ1bmMsY3VzdG9taXplcixzdGFjayl7dmFyIG9ialZhbHVlPW9iamVjdFtrZXldLHNyY1ZhbHVlPXNvdXJjZVtrZXldLHN0YWNrZWQ9c3RhY2suZ2V0KHNyY1ZhbHVlKTtpZihzdGFja2VkKXthc3NpZ25NZXJnZVZhbHVlKG9iamVjdCxrZXksc3RhY2tlZCk7cmV0dXJuO312YXIgbmV3VmFsdWU9Y3VzdG9taXplcj9jdXN0b21pemVyKG9ialZhbHVlLHNyY1ZhbHVlLGtleSsnJyxvYmplY3Qsc291cmNlLHN0YWNrKTp1bmRlZmluZWQ7dmFyIGlzQ29tbW9uPW5ld1ZhbHVlPT09dW5kZWZpbmVkO2lmKGlzQ29tbW9uKXt2YXIgaXNBcnI9aXNBcnJheShzcmNWYWx1ZSksaXNCdWZmPSFpc0FyciYmaXNCdWZmZXIoc3JjVmFsdWUpLGlzVHlwZWQ9IWlzQXJyJiYhaXNCdWZmJiZpc1R5cGVkQXJyYXkoc3JjVmFsdWUpO25ld1ZhbHVlPXNyY1ZhbHVlO2lmKGlzQXJyfHxpc0J1ZmZ8fGlzVHlwZWQpe2lmKGlzQXJyYXkob2JqVmFsdWUpKXtuZXdWYWx1ZT1vYmpWYWx1ZTt9ZWxzZSBpZihpc0FycmF5TGlrZU9iamVjdChvYmpWYWx1ZSkpe25ld1ZhbHVlPWNvcHlBcnJheShvYmpWYWx1ZSk7fWVsc2UgaWYoaXNCdWZmKXtpc0NvbW1vbj1mYWxzZTtuZXdWYWx1ZT1jbG9uZUJ1ZmZlcihzcmNWYWx1ZSx0cnVlKTt9ZWxzZSBpZihpc1R5cGVkKXtpc0NvbW1vbj1mYWxzZTtuZXdWYWx1ZT1jbG9uZVR5cGVkQXJyYXkoc3JjVmFsdWUsdHJ1ZSk7fWVsc2V7bmV3VmFsdWU9W107fX1lbHNlIGlmKGlzUGxhaW5PYmplY3Qoc3JjVmFsdWUpfHxpc0FyZ3VtZW50cyhzcmNWYWx1ZSkpe25ld1ZhbHVlPW9ialZhbHVlO2lmKGlzQXJndW1lbnRzKG9ialZhbHVlKSl7bmV3VmFsdWU9dG9QbGFpbk9iamVjdChvYmpWYWx1ZSk7fWVsc2UgaWYoIWlzT2JqZWN0KG9ialZhbHVlKXx8c3JjSW5kZXgmJmlzRnVuY3Rpb24ob2JqVmFsdWUpKXtuZXdWYWx1ZT1pbml0Q2xvbmVPYmplY3Qoc3JjVmFsdWUpO319ZWxzZXtpc0NvbW1vbj1mYWxzZTt9fWlmKGlzQ29tbW9uKXsvLyBSZWN1cnNpdmVseSBtZXJnZSBvYmplY3RzIGFuZCBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbnN0YWNrLnNldChzcmNWYWx1ZSxuZXdWYWx1ZSk7bWVyZ2VGdW5jKG5ld1ZhbHVlLHNyY1ZhbHVlLHNyY0luZGV4LGN1c3RvbWl6ZXIsc3RhY2spO3N0YWNrWydkZWxldGUnXShzcmNWYWx1ZSk7fWFzc2lnbk1lcmdlVmFsdWUob2JqZWN0LGtleSxuZXdWYWx1ZSk7fS8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm50aGAgd2hpY2ggZG9lc24ndCBjb2VyY2UgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIGluZGV4IG9mIHRoZSBlbGVtZW50IHRvIHJldHVybi5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbnRoIGVsZW1lbnQgb2YgYGFycmF5YC5cbiAgICAgKi9mdW5jdGlvbiBiYXNlTnRoKGFycmF5LG4pe3ZhciBsZW5ndGg9YXJyYXkubGVuZ3RoO2lmKCFsZW5ndGgpe3JldHVybjt9bis9bjwwP2xlbmd0aDowO3JldHVybiBpc0luZGV4KG4sbGVuZ3RoKT9hcnJheVtuXTp1bmRlZmluZWQ7fS8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm9yZGVyQnlgIHdpdGhvdXQgcGFyYW0gZ3VhcmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbltdfE9iamVjdFtdfHN0cmluZ1tdfSBpdGVyYXRlZXMgVGhlIGl0ZXJhdGVlcyB0byBzb3J0IGJ5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IG9yZGVycyBUaGUgc29ydCBvcmRlcnMgb2YgYGl0ZXJhdGVlc2AuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgc29ydGVkIGFycmF5LlxuICAgICAqL2Z1bmN0aW9uIGJhc2VPcmRlckJ5KGNvbGxlY3Rpb24saXRlcmF0ZWVzLG9yZGVycyl7dmFyIGluZGV4PS0xO2l0ZXJhdGVlcz1hcnJheU1hcChpdGVyYXRlZXMubGVuZ3RoP2l0ZXJhdGVlczpbaWRlbnRpdHldLGJhc2VVbmFyeShnZXRJdGVyYXRlZSgpKSk7dmFyIHJlc3VsdD1iYXNlTWFwKGNvbGxlY3Rpb24sZnVuY3Rpb24odmFsdWUsa2V5LGNvbGxlY3Rpb24pe3ZhciBjcml0ZXJpYT1hcnJheU1hcChpdGVyYXRlZXMsZnVuY3Rpb24oaXRlcmF0ZWUpe3JldHVybiBpdGVyYXRlZSh2YWx1ZSk7fSk7cmV0dXJueydjcml0ZXJpYSc6Y3JpdGVyaWEsJ2luZGV4JzorK2luZGV4LCd2YWx1ZSc6dmFsdWV9O30pO3JldHVybiBiYXNlU29ydEJ5KHJlc3VsdCxmdW5jdGlvbihvYmplY3Qsb3RoZXIpe3JldHVybiBjb21wYXJlTXVsdGlwbGUob2JqZWN0LG90aGVyLG9yZGVycyk7fSk7fS8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnBpY2tgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaW5kaXZpZHVhbFxuICAgICAqIHByb3BlcnR5IGlkZW50aWZpZXJzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBzb3VyY2Ugb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IHBhdGhzIFRoZSBwcm9wZXJ0eSBwYXRocyB0byBwaWNrLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gICAgICovZnVuY3Rpb24gYmFzZVBpY2sob2JqZWN0LHBhdGhzKXtyZXR1cm4gYmFzZVBpY2tCeShvYmplY3QscGF0aHMsZnVuY3Rpb24odmFsdWUscGF0aCl7cmV0dXJuIGhhc0luKG9iamVjdCxwYXRoKTt9KTt9LyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgIGBfLnBpY2tCeWAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBzb3VyY2Ugb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IHBhdGhzIFRoZSBwcm9wZXJ0eSBwYXRocyB0byBwaWNrLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgcHJvcGVydHkuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAgICAgKi9mdW5jdGlvbiBiYXNlUGlja0J5KG9iamVjdCxwYXRocyxwcmVkaWNhdGUpe3ZhciBpbmRleD0tMSxsZW5ndGg9cGF0aHMubGVuZ3RoLHJlc3VsdD17fTt3aGlsZSgrK2luZGV4PGxlbmd0aCl7dmFyIHBhdGg9cGF0aHNbaW5kZXhdLHZhbHVlPWJhc2VHZXQob2JqZWN0LHBhdGgpO2lmKHByZWRpY2F0ZSh2YWx1ZSxwYXRoKSl7YmFzZVNldChyZXN1bHQsY2FzdFBhdGgocGF0aCxvYmplY3QpLHZhbHVlKTt9fXJldHVybiByZXN1bHQ7fS8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZVByb3BlcnR5YCB3aGljaCBzdXBwb3J0cyBkZWVwIHBhdGhzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICAgICAqL2Z1bmN0aW9uIGJhc2VQcm9wZXJ0eURlZXAocGF0aCl7cmV0dXJuIGZ1bmN0aW9uKG9iamVjdCl7cmV0dXJuIGJhc2VHZXQob2JqZWN0LHBhdGgpO307fS8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnB1bGxBbGxCeWAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZVxuICAgICAqIHNob3J0aGFuZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gcmVtb3ZlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmF0b3JdIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICovZnVuY3Rpb24gYmFzZVB1bGxBbGwoYXJyYXksdmFsdWVzLGl0ZXJhdGVlLGNvbXBhcmF0b3Ipe3ZhciBpbmRleE9mPWNvbXBhcmF0b3I/YmFzZUluZGV4T2ZXaXRoOmJhc2VJbmRleE9mLGluZGV4PS0xLGxlbmd0aD12YWx1ZXMubGVuZ3RoLHNlZW49YXJyYXk7aWYoYXJyYXk9PT12YWx1ZXMpe3ZhbHVlcz1jb3B5QXJyYXkodmFsdWVzKTt9aWYoaXRlcmF0ZWUpe3NlZW49YXJyYXlNYXAoYXJyYXksYmFzZVVuYXJ5KGl0ZXJhdGVlKSk7fXdoaWxlKCsraW5kZXg8bGVuZ3RoKXt2YXIgZnJvbUluZGV4PTAsdmFsdWU9dmFsdWVzW2luZGV4XSxjb21wdXRlZD1pdGVyYXRlZT9pdGVyYXRlZSh2YWx1ZSk6dmFsdWU7d2hpbGUoKGZyb21JbmRleD1pbmRleE9mKHNlZW4sY29tcHV0ZWQsZnJvbUluZGV4LGNvbXBhcmF0b3IpKT4tMSl7aWYoc2VlbiE9PWFycmF5KXtzcGxpY2UuY2FsbChzZWVuLGZyb21JbmRleCwxKTt9c3BsaWNlLmNhbGwoYXJyYXksZnJvbUluZGV4LDEpO319cmV0dXJuIGFycmF5O30vKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5wdWxsQXRgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaW5kaXZpZHVhbFxuICAgICAqIGluZGV4ZXMgb3IgY2FwdHVyaW5nIHRoZSByZW1vdmVkIGVsZW1lbnRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyW119IGluZGV4ZXMgVGhlIGluZGV4ZXMgb2YgZWxlbWVudHMgdG8gcmVtb3ZlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqL2Z1bmN0aW9uIGJhc2VQdWxsQXQoYXJyYXksaW5kZXhlcyl7dmFyIGxlbmd0aD1hcnJheT9pbmRleGVzLmxlbmd0aDowLGxhc3RJbmRleD1sZW5ndGgtMTt3aGlsZShsZW5ndGgtLSl7dmFyIGluZGV4PWluZGV4ZXNbbGVuZ3RoXTtpZihsZW5ndGg9PWxhc3RJbmRleHx8aW5kZXghPT1wcmV2aW91cyl7dmFyIHByZXZpb3VzPWluZGV4O2lmKGlzSW5kZXgoaW5kZXgpKXtzcGxpY2UuY2FsbChhcnJheSxpbmRleCwxKTt9ZWxzZXtiYXNlVW5zZXQoYXJyYXksaW5kZXgpO319fXJldHVybiBhcnJheTt9LyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucmFuZG9tYCB3aXRob3V0IHN1cHBvcnQgZm9yIHJldHVybmluZ1xuICAgICAqIGZsb2F0aW5nLXBvaW50IG51bWJlcnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsb3dlciBUaGUgbG93ZXIgYm91bmQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHVwcGVyIFRoZSB1cHBlciBib3VuZC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSByYW5kb20gbnVtYmVyLlxuICAgICAqL2Z1bmN0aW9uIGJhc2VSYW5kb20obG93ZXIsdXBwZXIpe3JldHVybiBsb3dlcituYXRpdmVGbG9vcihuYXRpdmVSYW5kb20oKSoodXBwZXItbG93ZXIrMSkpO30vKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5yYW5nZWAgYW5kIGBfLnJhbmdlUmlnaHRgIHdoaWNoIGRvZXNuJ3RcbiAgICAgKiBjb2VyY2UgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgVGhlIHN0YXJ0IG9mIHRoZSByYW5nZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZW5kIFRoZSBlbmQgb2YgdGhlIHJhbmdlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGVwIFRoZSB2YWx1ZSB0byBpbmNyZW1lbnQgb3IgZGVjcmVtZW50IGJ5LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcmFuZ2Ugb2YgbnVtYmVycy5cbiAgICAgKi9mdW5jdGlvbiBiYXNlUmFuZ2Uoc3RhcnQsZW5kLHN0ZXAsZnJvbVJpZ2h0KXt2YXIgaW5kZXg9LTEsbGVuZ3RoPW5hdGl2ZU1heChuYXRpdmVDZWlsKChlbmQtc3RhcnQpLyhzdGVwfHwxKSksMCkscmVzdWx0PUFycmF5KGxlbmd0aCk7d2hpbGUobGVuZ3RoLS0pe3Jlc3VsdFtmcm9tUmlnaHQ/bGVuZ3RoOisraW5kZXhdPXN0YXJ0O3N0YXJ0Kz1zdGVwO31yZXR1cm4gcmVzdWx0O30vKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5yZXBlYXRgIHdoaWNoIGRvZXNuJ3QgY29lcmNlIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIHJlcGVhdC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIHJlcGVhdCB0aGUgc3RyaW5nLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHJlcGVhdGVkIHN0cmluZy5cbiAgICAgKi9mdW5jdGlvbiBiYXNlUmVwZWF0KHN0cmluZyxuKXt2YXIgcmVzdWx0PScnO2lmKCFzdHJpbmd8fG48MXx8bj5NQVhfU0FGRV9JTlRFR0VSKXtyZXR1cm4gcmVzdWx0O30vLyBMZXZlcmFnZSB0aGUgZXhwb25lbnRpYXRpb24gYnkgc3F1YXJpbmcgYWxnb3JpdGhtIGZvciBhIGZhc3RlciByZXBlYXQuXG4vLyBTZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRXhwb25lbnRpYXRpb25fYnlfc3F1YXJpbmcgZm9yIG1vcmUgZGV0YWlscy5cbmRve2lmKG4lMil7cmVzdWx0Kz1zdHJpbmc7fW49bmF0aXZlRmxvb3Iobi8yKTtpZihuKXtzdHJpbmcrPXN0cmluZzt9fXdoaWxlKG4pO3JldHVybiByZXN1bHQ7fS8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnJlc3RgIHdoaWNoIGRvZXNuJ3QgdmFsaWRhdGUgb3IgY29lcmNlIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgYSByZXN0IHBhcmFtZXRlciB0by5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PWZ1bmMubGVuZ3RoLTFdIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgcmVzdCBwYXJhbWV0ZXIuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICovZnVuY3Rpb24gYmFzZVJlc3QoZnVuYyxzdGFydCl7cmV0dXJuIHNldFRvU3RyaW5nKG92ZXJSZXN0KGZ1bmMsc3RhcnQsaWRlbnRpdHkpLGZ1bmMrJycpO30vKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zYW1wbGVgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBzYW1wbGUuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJhbmRvbSBlbGVtZW50LlxuICAgICAqL2Z1bmN0aW9uIGJhc2VTYW1wbGUoY29sbGVjdGlvbil7cmV0dXJuIGFycmF5U2FtcGxlKHZhbHVlcyhjb2xsZWN0aW9uKSk7fS8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNhbXBsZVNpemVgIHdpdGhvdXQgcGFyYW0gZ3VhcmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBzYW1wbGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byBzYW1wbGUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSByYW5kb20gZWxlbWVudHMuXG4gICAgICovZnVuY3Rpb24gYmFzZVNhbXBsZVNpemUoY29sbGVjdGlvbixuKXt2YXIgYXJyYXk9dmFsdWVzKGNvbGxlY3Rpb24pO3JldHVybiBzaHVmZmxlU2VsZihhcnJheSxiYXNlQ2xhbXAobiwwLGFycmF5Lmxlbmd0aCkpO30vKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zZXRgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBzZXQuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIHBhdGggY3JlYXRpb24uXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKi9mdW5jdGlvbiBiYXNlU2V0KG9iamVjdCxwYXRoLHZhbHVlLGN1c3RvbWl6ZXIpe2lmKCFpc09iamVjdChvYmplY3QpKXtyZXR1cm4gb2JqZWN0O31wYXRoPWNhc3RQYXRoKHBhdGgsb2JqZWN0KTt2YXIgaW5kZXg9LTEsbGVuZ3RoPXBhdGgubGVuZ3RoLGxhc3RJbmRleD1sZW5ndGgtMSxuZXN0ZWQ9b2JqZWN0O3doaWxlKG5lc3RlZCE9bnVsbCYmKytpbmRleDxsZW5ndGgpe3ZhciBrZXk9dG9LZXkocGF0aFtpbmRleF0pLG5ld1ZhbHVlPXZhbHVlO2lmKGluZGV4IT1sYXN0SW5kZXgpe3ZhciBvYmpWYWx1ZT1uZXN0ZWRba2V5XTtuZXdWYWx1ZT1jdXN0b21pemVyP2N1c3RvbWl6ZXIob2JqVmFsdWUsa2V5LG5lc3RlZCk6dW5kZWZpbmVkO2lmKG5ld1ZhbHVlPT09dW5kZWZpbmVkKXtuZXdWYWx1ZT1pc09iamVjdChvYmpWYWx1ZSk/b2JqVmFsdWU6aXNJbmRleChwYXRoW2luZGV4KzFdKT9bXTp7fTt9fWFzc2lnblZhbHVlKG5lc3RlZCxrZXksbmV3VmFsdWUpO25lc3RlZD1uZXN0ZWRba2V5XTt9cmV0dXJuIG9iamVjdDt9LyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYHNldERhdGFgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaG90IGxvb3Agc2hvcnRpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFzc29jaWF0ZSBtZXRhZGF0YSB3aXRoLlxuICAgICAqIEBwYXJhbSB7Kn0gZGF0YSBUaGUgbWV0YWRhdGEuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBmdW5jYC5cbiAgICAgKi92YXIgYmFzZVNldERhdGE9IW1ldGFNYXA/aWRlbnRpdHk6ZnVuY3Rpb24oZnVuYyxkYXRhKXttZXRhTWFwLnNldChmdW5jLGRhdGEpO3JldHVybiBmdW5jO307LyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYHNldFRvU3RyaW5nYCB3aXRob3V0IHN1cHBvcnQgZm9yIGhvdCBsb29wIHNob3J0aW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gc3RyaW5nIFRoZSBgdG9TdHJpbmdgIHJlc3VsdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGZ1bmNgLlxuICAgICAqL3ZhciBiYXNlU2V0VG9TdHJpbmc9IWRlZmluZVByb3BlcnR5P2lkZW50aXR5OmZ1bmN0aW9uKGZ1bmMsc3RyaW5nKXtyZXR1cm4gZGVmaW5lUHJvcGVydHkoZnVuYywndG9TdHJpbmcnLHsnY29uZmlndXJhYmxlJzp0cnVlLCdlbnVtZXJhYmxlJzpmYWxzZSwndmFsdWUnOmNvbnN0YW50KHN0cmluZyksJ3dyaXRhYmxlJzp0cnVlfSk7fTsvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zaHVmZmxlYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gc2h1ZmZsZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBzaHVmZmxlZCBhcnJheS5cbiAgICAgKi9mdW5jdGlvbiBiYXNlU2h1ZmZsZShjb2xsZWN0aW9uKXtyZXR1cm4gc2h1ZmZsZVNlbGYodmFsdWVzKGNvbGxlY3Rpb24pKTt9LyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc2xpY2VgIHdpdGhvdXQgYW4gaXRlcmF0ZWUgY2FsbCBndWFyZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNsaWNlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9MF0gVGhlIHN0YXJ0IHBvc2l0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZW5kPWFycmF5Lmxlbmd0aF0gVGhlIGVuZCBwb3NpdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICovZnVuY3Rpb24gYmFzZVNsaWNlKGFycmF5LHN0YXJ0LGVuZCl7dmFyIGluZGV4PS0xLGxlbmd0aD1hcnJheS5sZW5ndGg7aWYoc3RhcnQ8MCl7c3RhcnQ9LXN0YXJ0Pmxlbmd0aD8wOmxlbmd0aCtzdGFydDt9ZW5kPWVuZD5sZW5ndGg/bGVuZ3RoOmVuZDtpZihlbmQ8MCl7ZW5kKz1sZW5ndGg7fWxlbmd0aD1zdGFydD5lbmQ/MDplbmQtc3RhcnQ+Pj4wO3N0YXJ0Pj4+PTA7dmFyIHJlc3VsdD1BcnJheShsZW5ndGgpO3doaWxlKCsraW5kZXg8bGVuZ3RoKXtyZXN1bHRbaW5kZXhdPWFycmF5W2luZGV4K3N0YXJ0XTt9cmV0dXJuIHJlc3VsdDt9LyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc29tZWAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFueSBlbGVtZW50IHBhc3NlcyB0aGUgcHJlZGljYXRlIGNoZWNrLFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICovZnVuY3Rpb24gYmFzZVNvbWUoY29sbGVjdGlvbixwcmVkaWNhdGUpe3ZhciByZXN1bHQ7YmFzZUVhY2goY29sbGVjdGlvbixmdW5jdGlvbih2YWx1ZSxpbmRleCxjb2xsZWN0aW9uKXtyZXN1bHQ9cHJlZGljYXRlKHZhbHVlLGluZGV4LGNvbGxlY3Rpb24pO3JldHVybiFyZXN1bHQ7fSk7cmV0dXJuISFyZXN1bHQ7fS8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNvcnRlZEluZGV4YCBhbmQgYF8uc29ydGVkTGFzdEluZGV4YCB3aGljaFxuICAgICAqIHBlcmZvcm1zIGEgYmluYXJ5IHNlYXJjaCBvZiBgYXJyYXlgIHRvIGRldGVybWluZSB0aGUgaW5kZXggYXQgd2hpY2ggYHZhbHVlYFxuICAgICAqIHNob3VsZCBiZSBpbnNlcnRlZCBpbnRvIGBhcnJheWAgaW4gb3JkZXIgdG8gbWFpbnRhaW4gaXRzIHNvcnQgb3JkZXIuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBzb3J0ZWQgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBldmFsdWF0ZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtyZXRIaWdoZXN0XSBTcGVjaWZ5IHJldHVybmluZyB0aGUgaGlnaGVzdCBxdWFsaWZpZWQgaW5kZXguXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggYXQgd2hpY2ggYHZhbHVlYCBzaG91bGQgYmUgaW5zZXJ0ZWRcbiAgICAgKiAgaW50byBgYXJyYXlgLlxuICAgICAqL2Z1bmN0aW9uIGJhc2VTb3J0ZWRJbmRleChhcnJheSx2YWx1ZSxyZXRIaWdoZXN0KXt2YXIgbG93PTAsaGlnaD1hcnJheT09bnVsbD9sb3c6YXJyYXkubGVuZ3RoO2lmKHR5cGVvZiB2YWx1ZT09J251bWJlcicmJnZhbHVlPT09dmFsdWUmJmhpZ2g8PUhBTEZfTUFYX0FSUkFZX0xFTkdUSCl7d2hpbGUobG93PGhpZ2gpe3ZhciBtaWQ9bG93K2hpZ2g+Pj4xLGNvbXB1dGVkPWFycmF5W21pZF07aWYoY29tcHV0ZWQhPT1udWxsJiYhaXNTeW1ib2woY29tcHV0ZWQpJiYocmV0SGlnaGVzdD9jb21wdXRlZDw9dmFsdWU6Y29tcHV0ZWQ8dmFsdWUpKXtsb3c9bWlkKzE7fWVsc2V7aGlnaD1taWQ7fX1yZXR1cm4gaGlnaDt9cmV0dXJuIGJhc2VTb3J0ZWRJbmRleEJ5KGFycmF5LHZhbHVlLGlkZW50aXR5LHJldEhpZ2hlc3QpO30vKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zb3J0ZWRJbmRleEJ5YCBhbmQgYF8uc29ydGVkTGFzdEluZGV4QnlgXG4gICAgICogd2hpY2ggaW52b2tlcyBgaXRlcmF0ZWVgIGZvciBgdmFsdWVgIGFuZCBlYWNoIGVsZW1lbnQgb2YgYGFycmF5YCB0byBjb21wdXRlXG4gICAgICogdGhlaXIgc29ydCByYW5raW5nLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDsgKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIHNvcnRlZCBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGV2YWx1YXRlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JldEhpZ2hlc3RdIFNwZWNpZnkgcmV0dXJuaW5nIHRoZSBoaWdoZXN0IHF1YWxpZmllZCBpbmRleC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBhdCB3aGljaCBgdmFsdWVgIHNob3VsZCBiZSBpbnNlcnRlZFxuICAgICAqICBpbnRvIGBhcnJheWAuXG4gICAgICovZnVuY3Rpb24gYmFzZVNvcnRlZEluZGV4QnkoYXJyYXksdmFsdWUsaXRlcmF0ZWUscmV0SGlnaGVzdCl7dmFsdWU9aXRlcmF0ZWUodmFsdWUpO3ZhciBsb3c9MCxoaWdoPWFycmF5PT1udWxsPzA6YXJyYXkubGVuZ3RoLHZhbElzTmFOPXZhbHVlIT09dmFsdWUsdmFsSXNOdWxsPXZhbHVlPT09bnVsbCx2YWxJc1N5bWJvbD1pc1N5bWJvbCh2YWx1ZSksdmFsSXNVbmRlZmluZWQ9dmFsdWU9PT11bmRlZmluZWQ7d2hpbGUobG93PGhpZ2gpe3ZhciBtaWQ9bmF0aXZlRmxvb3IoKGxvdytoaWdoKS8yKSxjb21wdXRlZD1pdGVyYXRlZShhcnJheVttaWRdKSxvdGhJc0RlZmluZWQ9Y29tcHV0ZWQhPT11bmRlZmluZWQsb3RoSXNOdWxsPWNvbXB1dGVkPT09bnVsbCxvdGhJc1JlZmxleGl2ZT1jb21wdXRlZD09PWNvbXB1dGVkLG90aElzU3ltYm9sPWlzU3ltYm9sKGNvbXB1dGVkKTtpZih2YWxJc05hTil7dmFyIHNldExvdz1yZXRIaWdoZXN0fHxvdGhJc1JlZmxleGl2ZTt9ZWxzZSBpZih2YWxJc1VuZGVmaW5lZCl7c2V0TG93PW90aElzUmVmbGV4aXZlJiYocmV0SGlnaGVzdHx8b3RoSXNEZWZpbmVkKTt9ZWxzZSBpZih2YWxJc051bGwpe3NldExvdz1vdGhJc1JlZmxleGl2ZSYmb3RoSXNEZWZpbmVkJiYocmV0SGlnaGVzdHx8IW90aElzTnVsbCk7fWVsc2UgaWYodmFsSXNTeW1ib2wpe3NldExvdz1vdGhJc1JlZmxleGl2ZSYmb3RoSXNEZWZpbmVkJiYhb3RoSXNOdWxsJiYocmV0SGlnaGVzdHx8IW90aElzU3ltYm9sKTt9ZWxzZSBpZihvdGhJc051bGx8fG90aElzU3ltYm9sKXtzZXRMb3c9ZmFsc2U7fWVsc2V7c2V0TG93PXJldEhpZ2hlc3Q/Y29tcHV0ZWQ8PXZhbHVlOmNvbXB1dGVkPHZhbHVlO31pZihzZXRMb3cpe2xvdz1taWQrMTt9ZWxzZXtoaWdoPW1pZDt9fXJldHVybiBuYXRpdmVNaW4oaGlnaCxNQVhfQVJSQVlfSU5ERVgpO30vKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zb3J0ZWRVbmlxYCBhbmQgYF8uc29ydGVkVW5pcUJ5YCB3aXRob3V0XG4gICAgICogc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlXSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBkdXBsaWNhdGUgZnJlZSBhcnJheS5cbiAgICAgKi9mdW5jdGlvbiBiYXNlU29ydGVkVW5pcShhcnJheSxpdGVyYXRlZSl7dmFyIGluZGV4PS0xLGxlbmd0aD1hcnJheS5sZW5ndGgscmVzSW5kZXg9MCxyZXN1bHQ9W107d2hpbGUoKytpbmRleDxsZW5ndGgpe3ZhciB2YWx1ZT1hcnJheVtpbmRleF0sY29tcHV0ZWQ9aXRlcmF0ZWU/aXRlcmF0ZWUodmFsdWUpOnZhbHVlO2lmKCFpbmRleHx8IWVxKGNvbXB1dGVkLHNlZW4pKXt2YXIgc2Vlbj1jb21wdXRlZDtyZXN1bHRbcmVzSW5kZXgrK109dmFsdWU9PT0wPzA6dmFsdWU7fX1yZXR1cm4gcmVzdWx0O30vKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50b051bWJlcmAgd2hpY2ggZG9lc24ndCBlbnN1cmUgY29ycmVjdFxuICAgICAqIGNvbnZlcnNpb25zIG9mIGJpbmFyeSwgaGV4YWRlY2ltYWwsIG9yIG9jdGFsIHN0cmluZyB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgbnVtYmVyLlxuICAgICAqL2Z1bmN0aW9uIGJhc2VUb051bWJlcih2YWx1ZSl7aWYodHlwZW9mIHZhbHVlPT0nbnVtYmVyJyl7cmV0dXJuIHZhbHVlO31pZihpc1N5bWJvbCh2YWx1ZSkpe3JldHVybiBOQU47fXJldHVybit2YWx1ZTt9LyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udG9TdHJpbmdgIHdoaWNoIGRvZXNuJ3QgY29udmVydCBudWxsaXNoXG4gICAgICogdmFsdWVzIHRvIGVtcHR5IHN0cmluZ3MuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc3RyaW5nLlxuICAgICAqL2Z1bmN0aW9uIGJhc2VUb1N0cmluZyh2YWx1ZSl7Ly8gRXhpdCBlYXJseSBmb3Igc3RyaW5ncyB0byBhdm9pZCBhIHBlcmZvcm1hbmNlIGhpdCBpbiBzb21lIGVudmlyb25tZW50cy5cbmlmKHR5cGVvZiB2YWx1ZT09J3N0cmluZycpe3JldHVybiB2YWx1ZTt9aWYoaXNBcnJheSh2YWx1ZSkpey8vIFJlY3Vyc2l2ZWx5IGNvbnZlcnQgdmFsdWVzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG5yZXR1cm4gYXJyYXlNYXAodmFsdWUsYmFzZVRvU3RyaW5nKSsnJzt9aWYoaXNTeW1ib2wodmFsdWUpKXtyZXR1cm4gc3ltYm9sVG9TdHJpbmc/c3ltYm9sVG9TdHJpbmcuY2FsbCh2YWx1ZSk6Jyc7fXZhciByZXN1bHQ9dmFsdWUrJyc7cmV0dXJuIHJlc3VsdD09JzAnJiYxL3ZhbHVlPT0tSU5GSU5JVFk/Jy0wJzpyZXN1bHQ7fS8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnVuaXFCeWAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWVdIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJhdG9yXSBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGR1cGxpY2F0ZSBmcmVlIGFycmF5LlxuICAgICAqL2Z1bmN0aW9uIGJhc2VVbmlxKGFycmF5LGl0ZXJhdGVlLGNvbXBhcmF0b3Ipe3ZhciBpbmRleD0tMSxpbmNsdWRlcz1hcnJheUluY2x1ZGVzLGxlbmd0aD1hcnJheS5sZW5ndGgsaXNDb21tb249dHJ1ZSxyZXN1bHQ9W10sc2Vlbj1yZXN1bHQ7aWYoY29tcGFyYXRvcil7aXNDb21tb249ZmFsc2U7aW5jbHVkZXM9YXJyYXlJbmNsdWRlc1dpdGg7fWVsc2UgaWYobGVuZ3RoPj1MQVJHRV9BUlJBWV9TSVpFKXt2YXIgc2V0PWl0ZXJhdGVlP251bGw6Y3JlYXRlU2V0KGFycmF5KTtpZihzZXQpe3JldHVybiBzZXRUb0FycmF5KHNldCk7fWlzQ29tbW9uPWZhbHNlO2luY2x1ZGVzPWNhY2hlSGFzO3NlZW49bmV3IFNldENhY2hlKCk7fWVsc2V7c2Vlbj1pdGVyYXRlZT9bXTpyZXN1bHQ7fW91dGVyOndoaWxlKCsraW5kZXg8bGVuZ3RoKXt2YXIgdmFsdWU9YXJyYXlbaW5kZXhdLGNvbXB1dGVkPWl0ZXJhdGVlP2l0ZXJhdGVlKHZhbHVlKTp2YWx1ZTt2YWx1ZT1jb21wYXJhdG9yfHx2YWx1ZSE9PTA/dmFsdWU6MDtpZihpc0NvbW1vbiYmY29tcHV0ZWQ9PT1jb21wdXRlZCl7dmFyIHNlZW5JbmRleD1zZWVuLmxlbmd0aDt3aGlsZShzZWVuSW5kZXgtLSl7aWYoc2VlbltzZWVuSW5kZXhdPT09Y29tcHV0ZWQpe2NvbnRpbnVlIG91dGVyO319aWYoaXRlcmF0ZWUpe3NlZW4ucHVzaChjb21wdXRlZCk7fXJlc3VsdC5wdXNoKHZhbHVlKTt9ZWxzZSBpZighaW5jbHVkZXMoc2Vlbixjb21wdXRlZCxjb21wYXJhdG9yKSl7aWYoc2VlbiE9PXJlc3VsdCl7c2Vlbi5wdXNoKGNvbXB1dGVkKTt9cmVzdWx0LnB1c2godmFsdWUpO319cmV0dXJuIHJlc3VsdDt9LyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udW5zZXRgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwcm9wZXJ0eSBwYXRoIHRvIHVuc2V0LlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcHJvcGVydHkgaXMgZGVsZXRlZCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL2Z1bmN0aW9uIGJhc2VVbnNldChvYmplY3QscGF0aCl7cGF0aD1jYXN0UGF0aChwYXRoLG9iamVjdCk7b2JqZWN0PXBhcmVudChvYmplY3QscGF0aCk7cmV0dXJuIG9iamVjdD09bnVsbHx8ZGVsZXRlIG9iamVjdFt0b0tleShsYXN0KHBhdGgpKV07fS8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnVwZGF0ZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIHVwZGF0ZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB1cGRhdGVyIFRoZSBmdW5jdGlvbiB0byBwcm9kdWNlIHRoZSB1cGRhdGVkIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIHBhdGggY3JlYXRpb24uXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKi9mdW5jdGlvbiBiYXNlVXBkYXRlKG9iamVjdCxwYXRoLHVwZGF0ZXIsY3VzdG9taXplcil7cmV0dXJuIGJhc2VTZXQob2JqZWN0LHBhdGgsdXBkYXRlcihiYXNlR2V0KG9iamVjdCxwYXRoKSksY3VzdG9taXplcik7fS8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIG1ldGhvZHMgbGlrZSBgXy5kcm9wV2hpbGVgIGFuZCBgXy50YWtlV2hpbGVgXG4gICAgICogd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNEcm9wXSBTcGVjaWZ5IGRyb3BwaW5nIGVsZW1lbnRzIGluc3RlYWQgb2YgdGFraW5nIHRoZW0uXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqL2Z1bmN0aW9uIGJhc2VXaGlsZShhcnJheSxwcmVkaWNhdGUsaXNEcm9wLGZyb21SaWdodCl7dmFyIGxlbmd0aD1hcnJheS5sZW5ndGgsaW5kZXg9ZnJvbVJpZ2h0P2xlbmd0aDotMTt3aGlsZSgoZnJvbVJpZ2h0P2luZGV4LS06KytpbmRleDxsZW5ndGgpJiZwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLGluZGV4LGFycmF5KSl7fXJldHVybiBpc0Ryb3A/YmFzZVNsaWNlKGFycmF5LGZyb21SaWdodD8wOmluZGV4LGZyb21SaWdodD9pbmRleCsxOmxlbmd0aCk6YmFzZVNsaWNlKGFycmF5LGZyb21SaWdodD9pbmRleCsxOjAsZnJvbVJpZ2h0P2xlbmd0aDppbmRleCk7fS8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGB3cmFwcGVyVmFsdWVgIHdoaWNoIHJldHVybnMgdGhlIHJlc3VsdCBvZlxuICAgICAqIHBlcmZvcm1pbmcgYSBzZXF1ZW5jZSBvZiBhY3Rpb25zIG9uIHRoZSB1bndyYXBwZWQgYHZhbHVlYCwgd2hlcmUgZWFjaFxuICAgICAqIHN1Y2Nlc3NpdmUgYWN0aW9uIGlzIHN1cHBsaWVkIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIHByZXZpb3VzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB1bndyYXBwZWQgdmFsdWUuXG4gICAgICogQHBhcmFtIHtBcnJheX0gYWN0aW9ucyBBY3Rpb25zIHRvIHBlcmZvcm0gdG8gcmVzb2x2ZSB0aGUgdW53cmFwcGVkIHZhbHVlLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAgICAgKi9mdW5jdGlvbiBiYXNlV3JhcHBlclZhbHVlKHZhbHVlLGFjdGlvbnMpe3ZhciByZXN1bHQ9dmFsdWU7aWYocmVzdWx0IGluc3RhbmNlb2YgTGF6eVdyYXBwZXIpe3Jlc3VsdD1yZXN1bHQudmFsdWUoKTt9cmV0dXJuIGFycmF5UmVkdWNlKGFjdGlvbnMsZnVuY3Rpb24ocmVzdWx0LGFjdGlvbil7cmV0dXJuIGFjdGlvbi5mdW5jLmFwcGx5KGFjdGlvbi50aGlzQXJnLGFycmF5UHVzaChbcmVzdWx0XSxhY3Rpb24uYXJncykpO30scmVzdWx0KTt9LyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgbWV0aG9kcyBsaWtlIGBfLnhvcmAsIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAgICAgKiBpdGVyYXRlZSBzaG9ydGhhbmRzLCB0aGF0IGFjY2VwdHMgYW4gYXJyYXkgb2YgYXJyYXlzIHRvIGluc3BlY3QuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5cyBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlXSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcGFyYXRvcl0gVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiB2YWx1ZXMuXG4gICAgICovZnVuY3Rpb24gYmFzZVhvcihhcnJheXMsaXRlcmF0ZWUsY29tcGFyYXRvcil7dmFyIGxlbmd0aD1hcnJheXMubGVuZ3RoO2lmKGxlbmd0aDwyKXtyZXR1cm4gbGVuZ3RoP2Jhc2VVbmlxKGFycmF5c1swXSk6W107fXZhciBpbmRleD0tMSxyZXN1bHQ9QXJyYXkobGVuZ3RoKTt3aGlsZSgrK2luZGV4PGxlbmd0aCl7dmFyIGFycmF5PWFycmF5c1tpbmRleF0sb3RoSW5kZXg9LTE7d2hpbGUoKytvdGhJbmRleDxsZW5ndGgpe2lmKG90aEluZGV4IT1pbmRleCl7cmVzdWx0W2luZGV4XT1iYXNlRGlmZmVyZW5jZShyZXN1bHRbaW5kZXhdfHxhcnJheSxhcnJheXNbb3RoSW5kZXhdLGl0ZXJhdGVlLGNvbXBhcmF0b3IpO319fXJldHVybiBiYXNlVW5pcShiYXNlRmxhdHRlbihyZXN1bHQsMSksaXRlcmF0ZWUsY29tcGFyYXRvcik7fS8qKlxuICAgICAqIFRoaXMgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy56aXBPYmplY3RgIHdoaWNoIGFzc2lnbnMgdmFsdWVzIHVzaW5nIGBhc3NpZ25GdW5jYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gcHJvcHMgVGhlIHByb3BlcnR5IGlkZW50aWZpZXJzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgcHJvcGVydHkgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGFzc2lnbkZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFzc2lnbiB2YWx1ZXMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAgICAgKi9mdW5jdGlvbiBiYXNlWmlwT2JqZWN0KHByb3BzLHZhbHVlcyxhc3NpZ25GdW5jKXt2YXIgaW5kZXg9LTEsbGVuZ3RoPXByb3BzLmxlbmd0aCx2YWxzTGVuZ3RoPXZhbHVlcy5sZW5ndGgscmVzdWx0PXt9O3doaWxlKCsraW5kZXg8bGVuZ3RoKXt2YXIgdmFsdWU9aW5kZXg8dmFsc0xlbmd0aD92YWx1ZXNbaW5kZXhdOnVuZGVmaW5lZDthc3NpZ25GdW5jKHJlc3VsdCxwcm9wc1tpbmRleF0sdmFsdWUpO31yZXR1cm4gcmVzdWx0O30vKipcbiAgICAgKiBDYXN0cyBgdmFsdWVgIHRvIGFuIGVtcHR5IGFycmF5IGlmIGl0J3Mgbm90IGFuIGFycmF5IGxpa2Ugb2JqZWN0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheXxPYmplY3R9IFJldHVybnMgdGhlIGNhc3QgYXJyYXktbGlrZSBvYmplY3QuXG4gICAgICovZnVuY3Rpb24gY2FzdEFycmF5TGlrZU9iamVjdCh2YWx1ZSl7cmV0dXJuIGlzQXJyYXlMaWtlT2JqZWN0KHZhbHVlKT92YWx1ZTpbXTt9LyoqXG4gICAgICogQ2FzdHMgYHZhbHVlYCB0byBgaWRlbnRpdHlgIGlmIGl0J3Mgbm90IGEgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGNhc3QgZnVuY3Rpb24uXG4gICAgICovZnVuY3Rpb24gY2FzdEZ1bmN0aW9uKHZhbHVlKXtyZXR1cm4gdHlwZW9mIHZhbHVlPT0nZnVuY3Rpb24nP3ZhbHVlOmlkZW50aXR5O30vKipcbiAgICAgKiBDYXN0cyBgdmFsdWVgIHRvIGEgcGF0aCBhcnJheSBpZiBpdCdzIG5vdCBvbmUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkga2V5cyBvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNhc3QgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAgICAgKi9mdW5jdGlvbiBjYXN0UGF0aCh2YWx1ZSxvYmplY3Qpe2lmKGlzQXJyYXkodmFsdWUpKXtyZXR1cm4gdmFsdWU7fXJldHVybiBpc0tleSh2YWx1ZSxvYmplY3QpP1t2YWx1ZV06c3RyaW5nVG9QYXRoKHRvU3RyaW5nKHZhbHVlKSk7fS8qKlxuICAgICAqIEEgYGJhc2VSZXN0YCBhbGlhcyB3aGljaCBjYW4gYmUgcmVwbGFjZWQgd2l0aCBgaWRlbnRpdHlgIGJ5IG1vZHVsZVxuICAgICAqIHJlcGxhY2VtZW50IHBsdWdpbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhcHBseSBhIHJlc3QgcGFyYW1ldGVyIHRvLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqL3ZhciBjYXN0UmVzdD1iYXNlUmVzdDsvKipcbiAgICAgKiBDYXN0cyBgYXJyYXlgIHRvIGEgc2xpY2UgaWYgaXQncyBuZWVkZWQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBUaGUgc3RhcnQgcG9zaXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtlbmQ9YXJyYXkubGVuZ3RoXSBUaGUgZW5kIHBvc2l0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY2FzdCBzbGljZS5cbiAgICAgKi9mdW5jdGlvbiBjYXN0U2xpY2UoYXJyYXksc3RhcnQsZW5kKXt2YXIgbGVuZ3RoPWFycmF5Lmxlbmd0aDtlbmQ9ZW5kPT09dW5kZWZpbmVkP2xlbmd0aDplbmQ7cmV0dXJuIXN0YXJ0JiZlbmQ+PWxlbmd0aD9hcnJheTpiYXNlU2xpY2UoYXJyYXksc3RhcnQsZW5kKTt9LyoqXG4gICAgICogQSBzaW1wbGUgd3JhcHBlciBhcm91bmQgdGhlIGdsb2JhbCBbYGNsZWFyVGltZW91dGBdKGh0dHBzOi8vbWRuLmlvL2NsZWFyVGltZW91dCkuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfE9iamVjdH0gaWQgVGhlIHRpbWVyIGlkIG9yIHRpbWVvdXQgb2JqZWN0IG9mIHRoZSB0aW1lciB0byBjbGVhci5cbiAgICAgKi92YXIgY2xlYXJUaW1lb3V0PWN0eENsZWFyVGltZW91dHx8ZnVuY3Rpb24oaWQpe3JldHVybiByb290LmNsZWFyVGltZW91dChpZCk7fTsvKipcbiAgICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgIGBidWZmZXJgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0J1ZmZlcn0gYnVmZmVyIFRoZSBidWZmZXIgdG8gY2xvbmUuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAgICAgKiBAcmV0dXJucyB7QnVmZmVyfSBSZXR1cm5zIHRoZSBjbG9uZWQgYnVmZmVyLlxuICAgICAqL2Z1bmN0aW9uIGNsb25lQnVmZmVyKGJ1ZmZlcixpc0RlZXApe2lmKGlzRGVlcCl7cmV0dXJuIGJ1ZmZlci5zbGljZSgpO312YXIgbGVuZ3RoPWJ1ZmZlci5sZW5ndGgscmVzdWx0PWFsbG9jVW5zYWZlP2FsbG9jVW5zYWZlKGxlbmd0aCk6bmV3IGJ1ZmZlci5jb25zdHJ1Y3RvcihsZW5ndGgpO2J1ZmZlci5jb3B5KHJlc3VsdCk7cmV0dXJuIHJlc3VsdDt9LyoqXG4gICAgICogQ3JlYXRlcyBhIGNsb25lIG9mIGBhcnJheUJ1ZmZlcmAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGFycmF5QnVmZmVyIFRoZSBhcnJheSBidWZmZXIgdG8gY2xvbmUuXG4gICAgICogQHJldHVybnMge0FycmF5QnVmZmVyfSBSZXR1cm5zIHRoZSBjbG9uZWQgYXJyYXkgYnVmZmVyLlxuICAgICAqL2Z1bmN0aW9uIGNsb25lQXJyYXlCdWZmZXIoYXJyYXlCdWZmZXIpe3ZhciByZXN1bHQ9bmV3IGFycmF5QnVmZmVyLmNvbnN0cnVjdG9yKGFycmF5QnVmZmVyLmJ5dGVMZW5ndGgpO25ldyBVaW50OEFycmF5KHJlc3VsdCkuc2V0KG5ldyBVaW50OEFycmF5KGFycmF5QnVmZmVyKSk7cmV0dXJuIHJlc3VsdDt9LyoqXG4gICAgICogQ3JlYXRlcyBhIGNsb25lIG9mIGBkYXRhVmlld2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhVmlldyBUaGUgZGF0YSB2aWV3IHRvIGNsb25lLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIGRhdGEgdmlldy5cbiAgICAgKi9mdW5jdGlvbiBjbG9uZURhdGFWaWV3KGRhdGFWaWV3LGlzRGVlcCl7dmFyIGJ1ZmZlcj1pc0RlZXA/Y2xvbmVBcnJheUJ1ZmZlcihkYXRhVmlldy5idWZmZXIpOmRhdGFWaWV3LmJ1ZmZlcjtyZXR1cm4gbmV3IGRhdGFWaWV3LmNvbnN0cnVjdG9yKGJ1ZmZlcixkYXRhVmlldy5ieXRlT2Zmc2V0LGRhdGFWaWV3LmJ5dGVMZW5ndGgpO30vKipcbiAgICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgYG1hcGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgVGhlIG1hcCB0byBjbG9uZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjbG9uZUZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNsb25lIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCBtYXAuXG4gICAgICovZnVuY3Rpb24gY2xvbmVNYXAobWFwLGlzRGVlcCxjbG9uZUZ1bmMpe3ZhciBhcnJheT1pc0RlZXA/Y2xvbmVGdW5jKG1hcFRvQXJyYXkobWFwKSxDTE9ORV9ERUVQX0ZMQUcpOm1hcFRvQXJyYXkobWFwKTtyZXR1cm4gYXJyYXlSZWR1Y2UoYXJyYXksYWRkTWFwRW50cnksbmV3IG1hcC5jb25zdHJ1Y3RvcigpKTt9LyoqXG4gICAgICogQ3JlYXRlcyBhIGNsb25lIG9mIGByZWdleHBgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcmVnZXhwIFRoZSByZWdleHAgdG8gY2xvbmUuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIHJlZ2V4cC5cbiAgICAgKi9mdW5jdGlvbiBjbG9uZVJlZ0V4cChyZWdleHApe3ZhciByZXN1bHQ9bmV3IHJlZ2V4cC5jb25zdHJ1Y3RvcihyZWdleHAuc291cmNlLHJlRmxhZ3MuZXhlYyhyZWdleHApKTtyZXN1bHQubGFzdEluZGV4PXJlZ2V4cC5sYXN0SW5kZXg7cmV0dXJuIHJlc3VsdDt9LyoqXG4gICAgICogQ3JlYXRlcyBhIGNsb25lIG9mIGBzZXRgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc2V0IFRoZSBzZXQgdG8gY2xvbmUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2xvbmVGdW5jIFRoZSBmdW5jdGlvbiB0byBjbG9uZSB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgc2V0LlxuICAgICAqL2Z1bmN0aW9uIGNsb25lU2V0KHNldCxpc0RlZXAsY2xvbmVGdW5jKXt2YXIgYXJyYXk9aXNEZWVwP2Nsb25lRnVuYyhzZXRUb0FycmF5KHNldCksQ0xPTkVfREVFUF9GTEFHKTpzZXRUb0FycmF5KHNldCk7cmV0dXJuIGFycmF5UmVkdWNlKGFycmF5LGFkZFNldEVudHJ5LG5ldyBzZXQuY29uc3RydWN0b3IoKSk7fS8qKlxuICAgICAqIENyZWF0ZXMgYSBjbG9uZSBvZiB0aGUgYHN5bWJvbGAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3ltYm9sIFRoZSBzeW1ib2wgb2JqZWN0IHRvIGNsb25lLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCBzeW1ib2wgb2JqZWN0LlxuICAgICAqL2Z1bmN0aW9uIGNsb25lU3ltYm9sKHN5bWJvbCl7cmV0dXJuIHN5bWJvbFZhbHVlT2Y/T2JqZWN0KHN5bWJvbFZhbHVlT2YuY2FsbChzeW1ib2wpKTp7fTt9LyoqXG4gICAgICogQ3JlYXRlcyBhIGNsb25lIG9mIGB0eXBlZEFycmF5YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHR5cGVkQXJyYXkgVGhlIHR5cGVkIGFycmF5IHRvIGNsb25lLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIHR5cGVkIGFycmF5LlxuICAgICAqL2Z1bmN0aW9uIGNsb25lVHlwZWRBcnJheSh0eXBlZEFycmF5LGlzRGVlcCl7dmFyIGJ1ZmZlcj1pc0RlZXA/Y2xvbmVBcnJheUJ1ZmZlcih0eXBlZEFycmF5LmJ1ZmZlcik6dHlwZWRBcnJheS5idWZmZXI7cmV0dXJuIG5ldyB0eXBlZEFycmF5LmNvbnN0cnVjdG9yKGJ1ZmZlcix0eXBlZEFycmF5LmJ5dGVPZmZzZXQsdHlwZWRBcnJheS5sZW5ndGgpO30vKipcbiAgICAgKiBDb21wYXJlcyB2YWx1ZXMgdG8gc29ydCB0aGVtIGluIGFzY2VuZGluZyBvcmRlci5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHNvcnQgb3JkZXIgaW5kaWNhdG9yIGZvciBgdmFsdWVgLlxuICAgICAqL2Z1bmN0aW9uIGNvbXBhcmVBc2NlbmRpbmcodmFsdWUsb3RoZXIpe2lmKHZhbHVlIT09b3RoZXIpe3ZhciB2YWxJc0RlZmluZWQ9dmFsdWUhPT11bmRlZmluZWQsdmFsSXNOdWxsPXZhbHVlPT09bnVsbCx2YWxJc1JlZmxleGl2ZT12YWx1ZT09PXZhbHVlLHZhbElzU3ltYm9sPWlzU3ltYm9sKHZhbHVlKTt2YXIgb3RoSXNEZWZpbmVkPW90aGVyIT09dW5kZWZpbmVkLG90aElzTnVsbD1vdGhlcj09PW51bGwsb3RoSXNSZWZsZXhpdmU9b3RoZXI9PT1vdGhlcixvdGhJc1N5bWJvbD1pc1N5bWJvbChvdGhlcik7aWYoIW90aElzTnVsbCYmIW90aElzU3ltYm9sJiYhdmFsSXNTeW1ib2wmJnZhbHVlPm90aGVyfHx2YWxJc1N5bWJvbCYmb3RoSXNEZWZpbmVkJiZvdGhJc1JlZmxleGl2ZSYmIW90aElzTnVsbCYmIW90aElzU3ltYm9sfHx2YWxJc051bGwmJm90aElzRGVmaW5lZCYmb3RoSXNSZWZsZXhpdmV8fCF2YWxJc0RlZmluZWQmJm90aElzUmVmbGV4aXZlfHwhdmFsSXNSZWZsZXhpdmUpe3JldHVybiAxO31pZighdmFsSXNOdWxsJiYhdmFsSXNTeW1ib2wmJiFvdGhJc1N5bWJvbCYmdmFsdWU8b3RoZXJ8fG90aElzU3ltYm9sJiZ2YWxJc0RlZmluZWQmJnZhbElzUmVmbGV4aXZlJiYhdmFsSXNOdWxsJiYhdmFsSXNTeW1ib2x8fG90aElzTnVsbCYmdmFsSXNEZWZpbmVkJiZ2YWxJc1JlZmxleGl2ZXx8IW90aElzRGVmaW5lZCYmdmFsSXNSZWZsZXhpdmV8fCFvdGhJc1JlZmxleGl2ZSl7cmV0dXJuLTE7fX1yZXR1cm4gMDt9LyoqXG4gICAgICogVXNlZCBieSBgXy5vcmRlckJ5YCB0byBjb21wYXJlIG11bHRpcGxlIHByb3BlcnRpZXMgb2YgYSB2YWx1ZSB0byBhbm90aGVyXG4gICAgICogYW5kIHN0YWJsZSBzb3J0IHRoZW0uXG4gICAgICpcbiAgICAgKiBJZiBgb3JkZXJzYCBpcyB1bnNwZWNpZmllZCwgYWxsIHZhbHVlcyBhcmUgc29ydGVkIGluIGFzY2VuZGluZyBvcmRlci4gT3RoZXJ3aXNlLFxuICAgICAqIHNwZWNpZnkgYW4gb3JkZXIgb2YgXCJkZXNjXCIgZm9yIGRlc2NlbmRpbmcgb3IgXCJhc2NcIiBmb3IgYXNjZW5kaW5nIHNvcnQgb3JkZXJcbiAgICAgKiBvZiBjb3JyZXNwb25kaW5nIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW5bXXxzdHJpbmdbXX0gb3JkZXJzIFRoZSBvcmRlciB0byBzb3J0IGJ5IGZvciBlYWNoIHByb3BlcnR5LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHNvcnQgb3JkZXIgaW5kaWNhdG9yIGZvciBgb2JqZWN0YC5cbiAgICAgKi9mdW5jdGlvbiBjb21wYXJlTXVsdGlwbGUob2JqZWN0LG90aGVyLG9yZGVycyl7dmFyIGluZGV4PS0xLG9iakNyaXRlcmlhPW9iamVjdC5jcml0ZXJpYSxvdGhDcml0ZXJpYT1vdGhlci5jcml0ZXJpYSxsZW5ndGg9b2JqQ3JpdGVyaWEubGVuZ3RoLG9yZGVyc0xlbmd0aD1vcmRlcnMubGVuZ3RoO3doaWxlKCsraW5kZXg8bGVuZ3RoKXt2YXIgcmVzdWx0PWNvbXBhcmVBc2NlbmRpbmcob2JqQ3JpdGVyaWFbaW5kZXhdLG90aENyaXRlcmlhW2luZGV4XSk7aWYocmVzdWx0KXtpZihpbmRleD49b3JkZXJzTGVuZ3RoKXtyZXR1cm4gcmVzdWx0O312YXIgb3JkZXI9b3JkZXJzW2luZGV4XTtyZXR1cm4gcmVzdWx0KihvcmRlcj09J2Rlc2MnPy0xOjEpO319Ly8gRml4ZXMgYW4gYEFycmF5I3NvcnRgIGJ1ZyBpbiB0aGUgSlMgZW5naW5lIGVtYmVkZGVkIGluIEFkb2JlIGFwcGxpY2F0aW9uc1xuLy8gdGhhdCBjYXVzZXMgaXQsIHVuZGVyIGNlcnRhaW4gY2lyY3Vtc3RhbmNlcywgdG8gcHJvdmlkZSB0aGUgc2FtZSB2YWx1ZSBmb3Jcbi8vIGBvYmplY3RgIGFuZCBgb3RoZXJgLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2phc2hrZW5hcy91bmRlcnNjb3JlL3B1bGwvMTI0N1xuLy8gZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBUaGlzIGFsc28gZW5zdXJlcyBhIHN0YWJsZSBzb3J0IGluIFY4IGFuZCBvdGhlciBlbmdpbmVzLlxuLy8gU2VlIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTkwIGZvciBtb3JlIGRldGFpbHMuXG5yZXR1cm4gb2JqZWN0LmluZGV4LW90aGVyLmluZGV4O30vKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IHRoYXQgaXMgdGhlIGNvbXBvc2l0aW9uIG9mIHBhcnRpYWxseSBhcHBsaWVkIGFyZ3VtZW50cyxcbiAgICAgKiBwbGFjZWhvbGRlcnMsIGFuZCBwcm92aWRlZCBhcmd1bWVudHMgaW50byBhIHNpbmdsZSBhcnJheSBvZiBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgVGhlIHByb3ZpZGVkIGFyZ3VtZW50cy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwYXJ0aWFscyBUaGUgYXJndW1lbnRzIHRvIHByZXBlbmQgdG8gdGhvc2UgcHJvdmlkZWQuXG4gICAgICogQHBhcmFtIHtBcnJheX0gaG9sZGVycyBUaGUgYHBhcnRpYWxzYCBwbGFjZWhvbGRlciBpbmRleGVzLlxuICAgICAqIEBwYXJhbXMge2Jvb2xlYW59IFtpc0N1cnJpZWRdIFNwZWNpZnkgY29tcG9zaW5nIGZvciBhIGN1cnJpZWQgZnVuY3Rpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgY29tcG9zZWQgYXJndW1lbnRzLlxuICAgICAqL2Z1bmN0aW9uIGNvbXBvc2VBcmdzKGFyZ3MscGFydGlhbHMsaG9sZGVycyxpc0N1cnJpZWQpe3ZhciBhcmdzSW5kZXg9LTEsYXJnc0xlbmd0aD1hcmdzLmxlbmd0aCxob2xkZXJzTGVuZ3RoPWhvbGRlcnMubGVuZ3RoLGxlZnRJbmRleD0tMSxsZWZ0TGVuZ3RoPXBhcnRpYWxzLmxlbmd0aCxyYW5nZUxlbmd0aD1uYXRpdmVNYXgoYXJnc0xlbmd0aC1ob2xkZXJzTGVuZ3RoLDApLHJlc3VsdD1BcnJheShsZWZ0TGVuZ3RoK3JhbmdlTGVuZ3RoKSxpc1VuY3VycmllZD0haXNDdXJyaWVkO3doaWxlKCsrbGVmdEluZGV4PGxlZnRMZW5ndGgpe3Jlc3VsdFtsZWZ0SW5kZXhdPXBhcnRpYWxzW2xlZnRJbmRleF07fXdoaWxlKCsrYXJnc0luZGV4PGhvbGRlcnNMZW5ndGgpe2lmKGlzVW5jdXJyaWVkfHxhcmdzSW5kZXg8YXJnc0xlbmd0aCl7cmVzdWx0W2hvbGRlcnNbYXJnc0luZGV4XV09YXJnc1thcmdzSW5kZXhdO319d2hpbGUocmFuZ2VMZW5ndGgtLSl7cmVzdWx0W2xlZnRJbmRleCsrXT1hcmdzW2FyZ3NJbmRleCsrXTt9cmV0dXJuIHJlc3VsdDt9LyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlIGBjb21wb3NlQXJnc2AgZXhjZXB0IHRoYXQgdGhlIGFyZ3VtZW50cyBjb21wb3NpdGlvblxuICAgICAqIGlzIHRhaWxvcmVkIGZvciBgXy5wYXJ0aWFsUmlnaHRgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcmdzIFRoZSBwcm92aWRlZCBhcmd1bWVudHMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gcGFydGlhbHMgVGhlIGFyZ3VtZW50cyB0byBhcHBlbmQgdG8gdGhvc2UgcHJvdmlkZWQuXG4gICAgICogQHBhcmFtIHtBcnJheX0gaG9sZGVycyBUaGUgYHBhcnRpYWxzYCBwbGFjZWhvbGRlciBpbmRleGVzLlxuICAgICAqIEBwYXJhbXMge2Jvb2xlYW59IFtpc0N1cnJpZWRdIFNwZWNpZnkgY29tcG9zaW5nIGZvciBhIGN1cnJpZWQgZnVuY3Rpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgY29tcG9zZWQgYXJndW1lbnRzLlxuICAgICAqL2Z1bmN0aW9uIGNvbXBvc2VBcmdzUmlnaHQoYXJncyxwYXJ0aWFscyxob2xkZXJzLGlzQ3VycmllZCl7dmFyIGFyZ3NJbmRleD0tMSxhcmdzTGVuZ3RoPWFyZ3MubGVuZ3RoLGhvbGRlcnNJbmRleD0tMSxob2xkZXJzTGVuZ3RoPWhvbGRlcnMubGVuZ3RoLHJpZ2h0SW5kZXg9LTEscmlnaHRMZW5ndGg9cGFydGlhbHMubGVuZ3RoLHJhbmdlTGVuZ3RoPW5hdGl2ZU1heChhcmdzTGVuZ3RoLWhvbGRlcnNMZW5ndGgsMCkscmVzdWx0PUFycmF5KHJhbmdlTGVuZ3RoK3JpZ2h0TGVuZ3RoKSxpc1VuY3VycmllZD0haXNDdXJyaWVkO3doaWxlKCsrYXJnc0luZGV4PHJhbmdlTGVuZ3RoKXtyZXN1bHRbYXJnc0luZGV4XT1hcmdzW2FyZ3NJbmRleF07fXZhciBvZmZzZXQ9YXJnc0luZGV4O3doaWxlKCsrcmlnaHRJbmRleDxyaWdodExlbmd0aCl7cmVzdWx0W29mZnNldCtyaWdodEluZGV4XT1wYXJ0aWFsc1tyaWdodEluZGV4XTt9d2hpbGUoKytob2xkZXJzSW5kZXg8aG9sZGVyc0xlbmd0aCl7aWYoaXNVbmN1cnJpZWR8fGFyZ3NJbmRleDxhcmdzTGVuZ3RoKXtyZXN1bHRbb2Zmc2V0K2hvbGRlcnNbaG9sZGVyc0luZGV4XV09YXJnc1thcmdzSW5kZXgrK107fX1yZXR1cm4gcmVzdWx0O30vKipcbiAgICAgKiBDb3BpZXMgdGhlIHZhbHVlcyBvZiBgc291cmNlYCB0byBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBzb3VyY2UgVGhlIGFycmF5IHRvIGNvcHkgdmFsdWVzIGZyb20uXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2FycmF5PVtdXSBUaGUgYXJyYXkgdG8gY29weSB2YWx1ZXMgdG8uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICovZnVuY3Rpb24gY29weUFycmF5KHNvdXJjZSxhcnJheSl7dmFyIGluZGV4PS0xLGxlbmd0aD1zb3VyY2UubGVuZ3RoO2FycmF5fHwoYXJyYXk9QXJyYXkobGVuZ3RoKSk7d2hpbGUoKytpbmRleDxsZW5ndGgpe2FycmF5W2luZGV4XT1zb3VyY2VbaW5kZXhdO31yZXR1cm4gYXJyYXk7fS8qKlxuICAgICAqIENvcGllcyBwcm9wZXJ0aWVzIG9mIGBzb3VyY2VgIHRvIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIGZyb20uXG4gICAgICogQHBhcmFtIHtBcnJheX0gcHJvcHMgVGhlIHByb3BlcnR5IGlkZW50aWZpZXJzIHRvIGNvcHkuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3Q9e31dIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIHRvLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvcGllZCB2YWx1ZXMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKi9mdW5jdGlvbiBjb3B5T2JqZWN0KHNvdXJjZSxwcm9wcyxvYmplY3QsY3VzdG9taXplcil7dmFyIGlzTmV3PSFvYmplY3Q7b2JqZWN0fHwob2JqZWN0PXt9KTt2YXIgaW5kZXg9LTEsbGVuZ3RoPXByb3BzLmxlbmd0aDt3aGlsZSgrK2luZGV4PGxlbmd0aCl7dmFyIGtleT1wcm9wc1tpbmRleF07dmFyIG5ld1ZhbHVlPWN1c3RvbWl6ZXI/Y3VzdG9taXplcihvYmplY3Rba2V5XSxzb3VyY2Vba2V5XSxrZXksb2JqZWN0LHNvdXJjZSk6dW5kZWZpbmVkO2lmKG5ld1ZhbHVlPT09dW5kZWZpbmVkKXtuZXdWYWx1ZT1zb3VyY2Vba2V5XTt9aWYoaXNOZXcpe2Jhc2VBc3NpZ25WYWx1ZShvYmplY3Qsa2V5LG5ld1ZhbHVlKTt9ZWxzZXthc3NpZ25WYWx1ZShvYmplY3Qsa2V5LG5ld1ZhbHVlKTt9fXJldHVybiBvYmplY3Q7fS8qKlxuICAgICAqIENvcGllcyBvd24gc3ltYm9scyBvZiBgc291cmNlYCB0byBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IHRvIGNvcHkgc3ltYm9scyBmcm9tLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0PXt9XSBUaGUgb2JqZWN0IHRvIGNvcHkgc3ltYm9scyB0by5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqL2Z1bmN0aW9uIGNvcHlTeW1ib2xzKHNvdXJjZSxvYmplY3Qpe3JldHVybiBjb3B5T2JqZWN0KHNvdXJjZSxnZXRTeW1ib2xzKHNvdXJjZSksb2JqZWN0KTt9LyoqXG4gICAgICogQ29waWVzIG93biBhbmQgaW5oZXJpdGVkIHN5bWJvbHMgb2YgYHNvdXJjZWAgdG8gYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCB0byBjb3B5IHN5bWJvbHMgZnJvbS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29iamVjdD17fV0gVGhlIG9iamVjdCB0byBjb3B5IHN5bWJvbHMgdG8uXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKi9mdW5jdGlvbiBjb3B5U3ltYm9sc0luKHNvdXJjZSxvYmplY3Qpe3JldHVybiBjb3B5T2JqZWN0KHNvdXJjZSxnZXRTeW1ib2xzSW4oc291cmNlKSxvYmplY3QpO30vKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gbGlrZSBgXy5ncm91cEJ5YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gc2V0dGVyIFRoZSBmdW5jdGlvbiB0byBzZXQgYWNjdW11bGF0b3IgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpbml0aWFsaXplcl0gVGhlIGFjY3VtdWxhdG9yIG9iamVjdCBpbml0aWFsaXplci5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhZ2dyZWdhdG9yIGZ1bmN0aW9uLlxuICAgICAqL2Z1bmN0aW9uIGNyZWF0ZUFnZ3JlZ2F0b3Ioc2V0dGVyLGluaXRpYWxpemVyKXtyZXR1cm4gZnVuY3Rpb24oY29sbGVjdGlvbixpdGVyYXRlZSl7dmFyIGZ1bmM9aXNBcnJheShjb2xsZWN0aW9uKT9hcnJheUFnZ3JlZ2F0b3I6YmFzZUFnZ3JlZ2F0b3IsYWNjdW11bGF0b3I9aW5pdGlhbGl6ZXI/aW5pdGlhbGl6ZXIoKTp7fTtyZXR1cm4gZnVuYyhjb2xsZWN0aW9uLHNldHRlcixnZXRJdGVyYXRlZShpdGVyYXRlZSwyKSxhY2N1bXVsYXRvcik7fTt9LyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIGxpa2UgYF8uYXNzaWduYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gYXNzaWduZXIgVGhlIGZ1bmN0aW9uIHRvIGFzc2lnbiB2YWx1ZXMuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYXNzaWduZXIgZnVuY3Rpb24uXG4gICAgICovZnVuY3Rpb24gY3JlYXRlQXNzaWduZXIoYXNzaWduZXIpe3JldHVybiBiYXNlUmVzdChmdW5jdGlvbihvYmplY3Qsc291cmNlcyl7dmFyIGluZGV4PS0xLGxlbmd0aD1zb3VyY2VzLmxlbmd0aCxjdXN0b21pemVyPWxlbmd0aD4xP3NvdXJjZXNbbGVuZ3RoLTFdOnVuZGVmaW5lZCxndWFyZD1sZW5ndGg+Mj9zb3VyY2VzWzJdOnVuZGVmaW5lZDtjdXN0b21pemVyPWFzc2lnbmVyLmxlbmd0aD4zJiZ0eXBlb2YgY3VzdG9taXplcj09J2Z1bmN0aW9uJz8obGVuZ3RoLS0sY3VzdG9taXplcik6dW5kZWZpbmVkO2lmKGd1YXJkJiZpc0l0ZXJhdGVlQ2FsbChzb3VyY2VzWzBdLHNvdXJjZXNbMV0sZ3VhcmQpKXtjdXN0b21pemVyPWxlbmd0aDwzP3VuZGVmaW5lZDpjdXN0b21pemVyO2xlbmd0aD0xO31vYmplY3Q9T2JqZWN0KG9iamVjdCk7d2hpbGUoKytpbmRleDxsZW5ndGgpe3ZhciBzb3VyY2U9c291cmNlc1tpbmRleF07aWYoc291cmNlKXthc3NpZ25lcihvYmplY3Qsc291cmNlLGluZGV4LGN1c3RvbWl6ZXIpO319cmV0dXJuIG9iamVjdDt9KTt9LyoqXG4gICAgICogQ3JlYXRlcyBhIGBiYXNlRWFjaGAgb3IgYGJhc2VFYWNoUmlnaHRgIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBlYWNoRnVuYyBUaGUgZnVuY3Rpb24gdG8gaXRlcmF0ZSBvdmVyIGEgY29sbGVjdGlvbi5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBiYXNlIGZ1bmN0aW9uLlxuICAgICAqL2Z1bmN0aW9uIGNyZWF0ZUJhc2VFYWNoKGVhY2hGdW5jLGZyb21SaWdodCl7cmV0dXJuIGZ1bmN0aW9uKGNvbGxlY3Rpb24saXRlcmF0ZWUpe2lmKGNvbGxlY3Rpb249PW51bGwpe3JldHVybiBjb2xsZWN0aW9uO31pZighaXNBcnJheUxpa2UoY29sbGVjdGlvbikpe3JldHVybiBlYWNoRnVuYyhjb2xsZWN0aW9uLGl0ZXJhdGVlKTt9dmFyIGxlbmd0aD1jb2xsZWN0aW9uLmxlbmd0aCxpbmRleD1mcm9tUmlnaHQ/bGVuZ3RoOi0xLGl0ZXJhYmxlPU9iamVjdChjb2xsZWN0aW9uKTt3aGlsZShmcm9tUmlnaHQ/aW5kZXgtLTorK2luZGV4PGxlbmd0aCl7aWYoaXRlcmF0ZWUoaXRlcmFibGVbaW5kZXhdLGluZGV4LGl0ZXJhYmxlKT09PWZhbHNlKXticmVhazt9fXJldHVybiBjb2xsZWN0aW9uO307fS8qKlxuICAgICAqIENyZWF0ZXMgYSBiYXNlIGZ1bmN0aW9uIGZvciBtZXRob2RzIGxpa2UgYF8uZm9ySW5gIGFuZCBgXy5mb3JPd25gLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBiYXNlIGZ1bmN0aW9uLlxuICAgICAqL2Z1bmN0aW9uIGNyZWF0ZUJhc2VGb3IoZnJvbVJpZ2h0KXtyZXR1cm4gZnVuY3Rpb24ob2JqZWN0LGl0ZXJhdGVlLGtleXNGdW5jKXt2YXIgaW5kZXg9LTEsaXRlcmFibGU9T2JqZWN0KG9iamVjdCkscHJvcHM9a2V5c0Z1bmMob2JqZWN0KSxsZW5ndGg9cHJvcHMubGVuZ3RoO3doaWxlKGxlbmd0aC0tKXt2YXIga2V5PXByb3BzW2Zyb21SaWdodD9sZW5ndGg6KytpbmRleF07aWYoaXRlcmF0ZWUoaXRlcmFibGVba2V5XSxrZXksaXRlcmFibGUpPT09ZmFsc2Upe2JyZWFrO319cmV0dXJuIG9iamVjdDt9O30vKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCB3cmFwcyBgZnVuY2AgdG8gaW52b2tlIGl0IHdpdGggdGhlIG9wdGlvbmFsIGB0aGlzYFxuICAgICAqIGJpbmRpbmcgb2YgYHRoaXNBcmdgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGNyZWF0ZVdyYXBgIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyB3cmFwcGVkIGZ1bmN0aW9uLlxuICAgICAqL2Z1bmN0aW9uIGNyZWF0ZUJpbmQoZnVuYyxiaXRtYXNrLHRoaXNBcmcpe3ZhciBpc0JpbmQ9Yml0bWFzayZXUkFQX0JJTkRfRkxBRyxDdG9yPWNyZWF0ZUN0b3IoZnVuYyk7ZnVuY3Rpb24gd3JhcHBlcigpe3ZhciBmbj10aGlzJiZ0aGlzIT09cm9vdCYmdGhpcyBpbnN0YW5jZW9mIHdyYXBwZXI/Q3RvcjpmdW5jO3JldHVybiBmbi5hcHBseShpc0JpbmQ/dGhpc0FyZzp0aGlzLGFyZ3VtZW50cyk7fXJldHVybiB3cmFwcGVyO30vKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gbGlrZSBgXy5sb3dlckZpcnN0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1ldGhvZE5hbWUgVGhlIG5hbWUgb2YgdGhlIGBTdHJpbmdgIGNhc2UgbWV0aG9kIHRvIHVzZS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjYXNlIGZ1bmN0aW9uLlxuICAgICAqL2Z1bmN0aW9uIGNyZWF0ZUNhc2VGaXJzdChtZXRob2ROYW1lKXtyZXR1cm4gZnVuY3Rpb24oc3RyaW5nKXtzdHJpbmc9dG9TdHJpbmcoc3RyaW5nKTt2YXIgc3RyU3ltYm9scz1oYXNVbmljb2RlKHN0cmluZyk/c3RyaW5nVG9BcnJheShzdHJpbmcpOnVuZGVmaW5lZDt2YXIgY2hyPXN0clN5bWJvbHM/c3RyU3ltYm9sc1swXTpzdHJpbmcuY2hhckF0KDApO3ZhciB0cmFpbGluZz1zdHJTeW1ib2xzP2Nhc3RTbGljZShzdHJTeW1ib2xzLDEpLmpvaW4oJycpOnN0cmluZy5zbGljZSgxKTtyZXR1cm4gY2hyW21ldGhvZE5hbWVdKCkrdHJhaWxpbmc7fTt9LyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIGxpa2UgYF8uY2FtZWxDYXNlYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRvIGNvbWJpbmUgZWFjaCB3b3JkLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNvbXBvdW5kZXIgZnVuY3Rpb24uXG4gICAgICovZnVuY3Rpb24gY3JlYXRlQ29tcG91bmRlcihjYWxsYmFjayl7cmV0dXJuIGZ1bmN0aW9uKHN0cmluZyl7cmV0dXJuIGFycmF5UmVkdWNlKHdvcmRzKGRlYnVycihzdHJpbmcpLnJlcGxhY2UocmVBcG9zLCcnKSksY2FsbGJhY2ssJycpO307fS8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHByb2R1Y2VzIGFuIGluc3RhbmNlIG9mIGBDdG9yYCByZWdhcmRsZXNzIG9mXG4gICAgICogd2hldGhlciBpdCB3YXMgaW52b2tlZCBhcyBwYXJ0IG9mIGEgYG5ld2AgZXhwcmVzc2lvbiBvciBieSBgY2FsbGAgb3IgYGFwcGx5YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gQ3RvciBUaGUgY29uc3RydWN0b3IgdG8gd3JhcC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyB3cmFwcGVkIGZ1bmN0aW9uLlxuICAgICAqL2Z1bmN0aW9uIGNyZWF0ZUN0b3IoQ3Rvcil7cmV0dXJuIGZ1bmN0aW9uKCl7Ly8gVXNlIGEgYHN3aXRjaGAgc3RhdGVtZW50IHRvIHdvcmsgd2l0aCBjbGFzcyBjb25zdHJ1Y3RvcnMuIFNlZVxuLy8gaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1mdW5jdGlvbi1vYmplY3RzLWNhbGwtdGhpc2FyZ3VtZW50LWFyZ3VtZW50c2xpc3Rcbi8vIGZvciBtb3JlIGRldGFpbHMuXG52YXIgYXJncz1hcmd1bWVudHM7c3dpdGNoKGFyZ3MubGVuZ3RoKXtjYXNlIDA6cmV0dXJuIG5ldyBDdG9yKCk7Y2FzZSAxOnJldHVybiBuZXcgQ3RvcihhcmdzWzBdKTtjYXNlIDI6cmV0dXJuIG5ldyBDdG9yKGFyZ3NbMF0sYXJnc1sxXSk7Y2FzZSAzOnJldHVybiBuZXcgQ3RvcihhcmdzWzBdLGFyZ3NbMV0sYXJnc1syXSk7Y2FzZSA0OnJldHVybiBuZXcgQ3RvcihhcmdzWzBdLGFyZ3NbMV0sYXJnc1syXSxhcmdzWzNdKTtjYXNlIDU6cmV0dXJuIG5ldyBDdG9yKGFyZ3NbMF0sYXJnc1sxXSxhcmdzWzJdLGFyZ3NbM10sYXJnc1s0XSk7Y2FzZSA2OnJldHVybiBuZXcgQ3RvcihhcmdzWzBdLGFyZ3NbMV0sYXJnc1syXSxhcmdzWzNdLGFyZ3NbNF0sYXJnc1s1XSk7Y2FzZSA3OnJldHVybiBuZXcgQ3RvcihhcmdzWzBdLGFyZ3NbMV0sYXJnc1syXSxhcmdzWzNdLGFyZ3NbNF0sYXJnc1s1XSxhcmdzWzZdKTt9dmFyIHRoaXNCaW5kaW5nPWJhc2VDcmVhdGUoQ3Rvci5wcm90b3R5cGUpLHJlc3VsdD1DdG9yLmFwcGx5KHRoaXNCaW5kaW5nLGFyZ3MpOy8vIE1pbWljIHRoZSBjb25zdHJ1Y3RvcidzIGByZXR1cm5gIGJlaGF2aW9yLlxuLy8gU2VlIGh0dHBzOi8vZXM1LmdpdGh1Yi5pby8jeDEzLjIuMiBmb3IgbW9yZSBkZXRhaWxzLlxucmV0dXJuIGlzT2JqZWN0KHJlc3VsdCk/cmVzdWx0OnRoaXNCaW5kaW5nO307fS8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHdyYXBzIGBmdW5jYCB0byBlbmFibGUgY3VycnlpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgY3JlYXRlV3JhcGAgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYXJpdHkgVGhlIGFyaXR5IG9mIGBmdW5jYC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyB3cmFwcGVkIGZ1bmN0aW9uLlxuICAgICAqL2Z1bmN0aW9uIGNyZWF0ZUN1cnJ5KGZ1bmMsYml0bWFzayxhcml0eSl7dmFyIEN0b3I9Y3JlYXRlQ3RvcihmdW5jKTtmdW5jdGlvbiB3cmFwcGVyKCl7dmFyIGxlbmd0aD1hcmd1bWVudHMubGVuZ3RoLGFyZ3M9QXJyYXkobGVuZ3RoKSxpbmRleD1sZW5ndGgscGxhY2Vob2xkZXI9Z2V0SG9sZGVyKHdyYXBwZXIpO3doaWxlKGluZGV4LS0pe2FyZ3NbaW5kZXhdPWFyZ3VtZW50c1tpbmRleF07fXZhciBob2xkZXJzPWxlbmd0aDwzJiZhcmdzWzBdIT09cGxhY2Vob2xkZXImJmFyZ3NbbGVuZ3RoLTFdIT09cGxhY2Vob2xkZXI/W106cmVwbGFjZUhvbGRlcnMoYXJncyxwbGFjZWhvbGRlcik7bGVuZ3RoLT1ob2xkZXJzLmxlbmd0aDtpZihsZW5ndGg8YXJpdHkpe3JldHVybiBjcmVhdGVSZWN1cnJ5KGZ1bmMsYml0bWFzayxjcmVhdGVIeWJyaWQsd3JhcHBlci5wbGFjZWhvbGRlcix1bmRlZmluZWQsYXJncyxob2xkZXJzLHVuZGVmaW5lZCx1bmRlZmluZWQsYXJpdHktbGVuZ3RoKTt9dmFyIGZuPXRoaXMmJnRoaXMhPT1yb290JiZ0aGlzIGluc3RhbmNlb2Ygd3JhcHBlcj9DdG9yOmZ1bmM7cmV0dXJuIGFwcGx5KGZuLHRoaXMsYXJncyk7fXJldHVybiB3cmFwcGVyO30vKipcbiAgICAgKiBDcmVhdGVzIGEgYF8uZmluZGAgb3IgYF8uZmluZExhc3RgIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmaW5kSW5kZXhGdW5jIFRoZSBmdW5jdGlvbiB0byBmaW5kIHRoZSBjb2xsZWN0aW9uIGluZGV4LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZpbmQgZnVuY3Rpb24uXG4gICAgICovZnVuY3Rpb24gY3JlYXRlRmluZChmaW5kSW5kZXhGdW5jKXtyZXR1cm4gZnVuY3Rpb24oY29sbGVjdGlvbixwcmVkaWNhdGUsZnJvbUluZGV4KXt2YXIgaXRlcmFibGU9T2JqZWN0KGNvbGxlY3Rpb24pO2lmKCFpc0FycmF5TGlrZShjb2xsZWN0aW9uKSl7dmFyIGl0ZXJhdGVlPWdldEl0ZXJhdGVlKHByZWRpY2F0ZSwzKTtjb2xsZWN0aW9uPWtleXMoY29sbGVjdGlvbik7cHJlZGljYXRlPWZ1bmN0aW9uKGtleSl7cmV0dXJuIGl0ZXJhdGVlKGl0ZXJhYmxlW2tleV0sa2V5LGl0ZXJhYmxlKTt9O312YXIgaW5kZXg9ZmluZEluZGV4RnVuYyhjb2xsZWN0aW9uLHByZWRpY2F0ZSxmcm9tSW5kZXgpO3JldHVybiBpbmRleD4tMT9pdGVyYWJsZVtpdGVyYXRlZT9jb2xsZWN0aW9uW2luZGV4XTppbmRleF06dW5kZWZpbmVkO307fS8qKlxuICAgICAqIENyZWF0ZXMgYSBgXy5mbG93YCBvciBgXy5mbG93UmlnaHRgIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmbG93IGZ1bmN0aW9uLlxuICAgICAqL2Z1bmN0aW9uIGNyZWF0ZUZsb3coZnJvbVJpZ2h0KXtyZXR1cm4gZmxhdFJlc3QoZnVuY3Rpb24oZnVuY3Mpe3ZhciBsZW5ndGg9ZnVuY3MubGVuZ3RoLGluZGV4PWxlbmd0aCxwcmVyZXE9TG9kYXNoV3JhcHBlci5wcm90b3R5cGUudGhydTtpZihmcm9tUmlnaHQpe2Z1bmNzLnJldmVyc2UoKTt9d2hpbGUoaW5kZXgtLSl7dmFyIGZ1bmM9ZnVuY3NbaW5kZXhdO2lmKHR5cGVvZiBmdW5jIT0nZnVuY3Rpb24nKXt0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7fWlmKHByZXJlcSYmIXdyYXBwZXImJmdldEZ1bmNOYW1lKGZ1bmMpPT0nd3JhcHBlcicpe3ZhciB3cmFwcGVyPW5ldyBMb2Rhc2hXcmFwcGVyKFtdLHRydWUpO319aW5kZXg9d3JhcHBlcj9pbmRleDpsZW5ndGg7d2hpbGUoKytpbmRleDxsZW5ndGgpe2Z1bmM9ZnVuY3NbaW5kZXhdO3ZhciBmdW5jTmFtZT1nZXRGdW5jTmFtZShmdW5jKSxkYXRhPWZ1bmNOYW1lPT0nd3JhcHBlcic/Z2V0RGF0YShmdW5jKTp1bmRlZmluZWQ7aWYoZGF0YSYmaXNMYXppYWJsZShkYXRhWzBdKSYmZGF0YVsxXT09KFdSQVBfQVJZX0ZMQUd8V1JBUF9DVVJSWV9GTEFHfFdSQVBfUEFSVElBTF9GTEFHfFdSQVBfUkVBUkdfRkxBRykmJiFkYXRhWzRdLmxlbmd0aCYmZGF0YVs5XT09MSl7d3JhcHBlcj13cmFwcGVyW2dldEZ1bmNOYW1lKGRhdGFbMF0pXS5hcHBseSh3cmFwcGVyLGRhdGFbM10pO31lbHNle3dyYXBwZXI9ZnVuYy5sZW5ndGg9PTEmJmlzTGF6aWFibGUoZnVuYyk/d3JhcHBlcltmdW5jTmFtZV0oKTp3cmFwcGVyLnRocnUoZnVuYyk7fX1yZXR1cm4gZnVuY3Rpb24oKXt2YXIgYXJncz1hcmd1bWVudHMsdmFsdWU9YXJnc1swXTtpZih3cmFwcGVyJiZhcmdzLmxlbmd0aD09MSYmaXNBcnJheSh2YWx1ZSkpe3JldHVybiB3cmFwcGVyLnBsYW50KHZhbHVlKS52YWx1ZSgpO312YXIgaW5kZXg9MCxyZXN1bHQ9bGVuZ3RoP2Z1bmNzW2luZGV4XS5hcHBseSh0aGlzLGFyZ3MpOnZhbHVlO3doaWxlKCsraW5kZXg8bGVuZ3RoKXtyZXN1bHQ9ZnVuY3NbaW5kZXhdLmNhbGwodGhpcyxyZXN1bHQpO31yZXR1cm4gcmVzdWx0O307fSk7fS8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHdyYXBzIGBmdW5jYCB0byBpbnZva2UgaXQgd2l0aCBvcHRpb25hbCBgdGhpc2BcbiAgICAgKiBiaW5kaW5nIG9mIGB0aGlzQXJnYCwgcGFydGlhbCBhcHBsaWNhdGlvbiwgYW5kIGN1cnJ5aW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufHN0cmluZ30gZnVuYyBUaGUgZnVuY3Rpb24gb3IgbWV0aG9kIG5hbWUgdG8gd3JhcC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBjcmVhdGVXcmFwYCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3BhcnRpYWxzXSBUaGUgYXJndW1lbnRzIHRvIHByZXBlbmQgdG8gdGhvc2UgcHJvdmlkZWQgdG9cbiAgICAgKiAgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbaG9sZGVyc10gVGhlIGBwYXJ0aWFsc2AgcGxhY2Vob2xkZXIgaW5kZXhlcy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcGFydGlhbHNSaWdodF0gVGhlIGFyZ3VtZW50cyB0byBhcHBlbmQgdG8gdGhvc2UgcHJvdmlkZWRcbiAgICAgKiAgdG8gdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbaG9sZGVyc1JpZ2h0XSBUaGUgYHBhcnRpYWxzUmlnaHRgIHBsYWNlaG9sZGVyIGluZGV4ZXMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2FyZ1Bvc10gVGhlIGFyZ3VtZW50IHBvc2l0aW9ucyBvZiB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYXJ5XSBUaGUgYXJpdHkgY2FwIG9mIGBmdW5jYC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FyaXR5XSBUaGUgYXJpdHkgb2YgYGZ1bmNgLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHdyYXBwZWQgZnVuY3Rpb24uXG4gICAgICovZnVuY3Rpb24gY3JlYXRlSHlicmlkKGZ1bmMsYml0bWFzayx0aGlzQXJnLHBhcnRpYWxzLGhvbGRlcnMscGFydGlhbHNSaWdodCxob2xkZXJzUmlnaHQsYXJnUG9zLGFyeSxhcml0eSl7dmFyIGlzQXJ5PWJpdG1hc2smV1JBUF9BUllfRkxBRyxpc0JpbmQ9Yml0bWFzayZXUkFQX0JJTkRfRkxBRyxpc0JpbmRLZXk9Yml0bWFzayZXUkFQX0JJTkRfS0VZX0ZMQUcsaXNDdXJyaWVkPWJpdG1hc2smKFdSQVBfQ1VSUllfRkxBR3xXUkFQX0NVUlJZX1JJR0hUX0ZMQUcpLGlzRmxpcD1iaXRtYXNrJldSQVBfRkxJUF9GTEFHLEN0b3I9aXNCaW5kS2V5P3VuZGVmaW5lZDpjcmVhdGVDdG9yKGZ1bmMpO2Z1bmN0aW9uIHdyYXBwZXIoKXt2YXIgbGVuZ3RoPWFyZ3VtZW50cy5sZW5ndGgsYXJncz1BcnJheShsZW5ndGgpLGluZGV4PWxlbmd0aDt3aGlsZShpbmRleC0tKXthcmdzW2luZGV4XT1hcmd1bWVudHNbaW5kZXhdO31pZihpc0N1cnJpZWQpe3ZhciBwbGFjZWhvbGRlcj1nZXRIb2xkZXIod3JhcHBlciksaG9sZGVyc0NvdW50PWNvdW50SG9sZGVycyhhcmdzLHBsYWNlaG9sZGVyKTt9aWYocGFydGlhbHMpe2FyZ3M9Y29tcG9zZUFyZ3MoYXJncyxwYXJ0aWFscyxob2xkZXJzLGlzQ3VycmllZCk7fWlmKHBhcnRpYWxzUmlnaHQpe2FyZ3M9Y29tcG9zZUFyZ3NSaWdodChhcmdzLHBhcnRpYWxzUmlnaHQsaG9sZGVyc1JpZ2h0LGlzQ3VycmllZCk7fWxlbmd0aC09aG9sZGVyc0NvdW50O2lmKGlzQ3VycmllZCYmbGVuZ3RoPGFyaXR5KXt2YXIgbmV3SG9sZGVycz1yZXBsYWNlSG9sZGVycyhhcmdzLHBsYWNlaG9sZGVyKTtyZXR1cm4gY3JlYXRlUmVjdXJyeShmdW5jLGJpdG1hc2ssY3JlYXRlSHlicmlkLHdyYXBwZXIucGxhY2Vob2xkZXIsdGhpc0FyZyxhcmdzLG5ld0hvbGRlcnMsYXJnUG9zLGFyeSxhcml0eS1sZW5ndGgpO312YXIgdGhpc0JpbmRpbmc9aXNCaW5kP3RoaXNBcmc6dGhpcyxmbj1pc0JpbmRLZXk/dGhpc0JpbmRpbmdbZnVuY106ZnVuYztsZW5ndGg9YXJncy5sZW5ndGg7aWYoYXJnUG9zKXthcmdzPXJlb3JkZXIoYXJncyxhcmdQb3MpO31lbHNlIGlmKGlzRmxpcCYmbGVuZ3RoPjEpe2FyZ3MucmV2ZXJzZSgpO31pZihpc0FyeSYmYXJ5PGxlbmd0aCl7YXJncy5sZW5ndGg9YXJ5O31pZih0aGlzJiZ0aGlzIT09cm9vdCYmdGhpcyBpbnN0YW5jZW9mIHdyYXBwZXIpe2ZuPUN0b3J8fGNyZWF0ZUN0b3IoZm4pO31yZXR1cm4gZm4uYXBwbHkodGhpc0JpbmRpbmcsYXJncyk7fXJldHVybiB3cmFwcGVyO30vKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gbGlrZSBgXy5pbnZlcnRCeWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHNldHRlciBUaGUgZnVuY3Rpb24gdG8gc2V0IGFjY3VtdWxhdG9yIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB0b0l0ZXJhdGVlIFRoZSBmdW5jdGlvbiB0byByZXNvbHZlIGl0ZXJhdGVlcy5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBpbnZlcnRlciBmdW5jdGlvbi5cbiAgICAgKi9mdW5jdGlvbiBjcmVhdGVJbnZlcnRlcihzZXR0ZXIsdG9JdGVyYXRlZSl7cmV0dXJuIGZ1bmN0aW9uKG9iamVjdCxpdGVyYXRlZSl7cmV0dXJuIGJhc2VJbnZlcnRlcihvYmplY3Qsc2V0dGVyLHRvSXRlcmF0ZWUoaXRlcmF0ZWUpLHt9KTt9O30vKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBwZXJmb3JtcyBhIG1hdGhlbWF0aWNhbCBvcGVyYXRpb24gb24gdHdvIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gb3BlcmF0b3IgVGhlIGZ1bmN0aW9uIHRvIHBlcmZvcm0gdGhlIG9wZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2RlZmF1bHRWYWx1ZV0gVGhlIHZhbHVlIHVzZWQgZm9yIGB1bmRlZmluZWRgIGFyZ3VtZW50cy5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBtYXRoZW1hdGljYWwgb3BlcmF0aW9uIGZ1bmN0aW9uLlxuICAgICAqL2Z1bmN0aW9uIGNyZWF0ZU1hdGhPcGVyYXRpb24ob3BlcmF0b3IsZGVmYXVsdFZhbHVlKXtyZXR1cm4gZnVuY3Rpb24odmFsdWUsb3RoZXIpe3ZhciByZXN1bHQ7aWYodmFsdWU9PT11bmRlZmluZWQmJm90aGVyPT09dW5kZWZpbmVkKXtyZXR1cm4gZGVmYXVsdFZhbHVlO31pZih2YWx1ZSE9PXVuZGVmaW5lZCl7cmVzdWx0PXZhbHVlO31pZihvdGhlciE9PXVuZGVmaW5lZCl7aWYocmVzdWx0PT09dW5kZWZpbmVkKXtyZXR1cm4gb3RoZXI7fWlmKHR5cGVvZiB2YWx1ZT09J3N0cmluZyd8fHR5cGVvZiBvdGhlcj09J3N0cmluZycpe3ZhbHVlPWJhc2VUb1N0cmluZyh2YWx1ZSk7b3RoZXI9YmFzZVRvU3RyaW5nKG90aGVyKTt9ZWxzZXt2YWx1ZT1iYXNlVG9OdW1iZXIodmFsdWUpO290aGVyPWJhc2VUb051bWJlcihvdGhlcik7fXJlc3VsdD1vcGVyYXRvcih2YWx1ZSxvdGhlcik7fXJldHVybiByZXN1bHQ7fTt9LyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIGxpa2UgYF8ub3ZlcmAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGFycmF5RnVuYyBUaGUgZnVuY3Rpb24gdG8gaXRlcmF0ZSBvdmVyIGl0ZXJhdGVlcy5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBvdmVyIGZ1bmN0aW9uLlxuICAgICAqL2Z1bmN0aW9uIGNyZWF0ZU92ZXIoYXJyYXlGdW5jKXtyZXR1cm4gZmxhdFJlc3QoZnVuY3Rpb24oaXRlcmF0ZWVzKXtpdGVyYXRlZXM9YXJyYXlNYXAoaXRlcmF0ZWVzLGJhc2VVbmFyeShnZXRJdGVyYXRlZSgpKSk7cmV0dXJuIGJhc2VSZXN0KGZ1bmN0aW9uKGFyZ3Mpe3ZhciB0aGlzQXJnPXRoaXM7cmV0dXJuIGFycmF5RnVuYyhpdGVyYXRlZXMsZnVuY3Rpb24oaXRlcmF0ZWUpe3JldHVybiBhcHBseShpdGVyYXRlZSx0aGlzQXJnLGFyZ3MpO30pO30pO30pO30vKipcbiAgICAgKiBDcmVhdGVzIHRoZSBwYWRkaW5nIGZvciBgc3RyaW5nYCBiYXNlZCBvbiBgbGVuZ3RoYC4gVGhlIGBjaGFyc2Agc3RyaW5nXG4gICAgICogaXMgdHJ1bmNhdGVkIGlmIHRoZSBudW1iZXIgb2YgY2hhcmFjdGVycyBleGNlZWRzIGBsZW5ndGhgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGVuZ3RoIFRoZSBwYWRkaW5nIGxlbmd0aC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2NoYXJzPScgJ10gVGhlIHN0cmluZyB1c2VkIGFzIHBhZGRpbmcuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcGFkZGluZyBmb3IgYHN0cmluZ2AuXG4gICAgICovZnVuY3Rpb24gY3JlYXRlUGFkZGluZyhsZW5ndGgsY2hhcnMpe2NoYXJzPWNoYXJzPT09dW5kZWZpbmVkPycgJzpiYXNlVG9TdHJpbmcoY2hhcnMpO3ZhciBjaGFyc0xlbmd0aD1jaGFycy5sZW5ndGg7aWYoY2hhcnNMZW5ndGg8Mil7cmV0dXJuIGNoYXJzTGVuZ3RoP2Jhc2VSZXBlYXQoY2hhcnMsbGVuZ3RoKTpjaGFyczt9dmFyIHJlc3VsdD1iYXNlUmVwZWF0KGNoYXJzLG5hdGl2ZUNlaWwobGVuZ3RoL3N0cmluZ1NpemUoY2hhcnMpKSk7cmV0dXJuIGhhc1VuaWNvZGUoY2hhcnMpP2Nhc3RTbGljZShzdHJpbmdUb0FycmF5KHJlc3VsdCksMCxsZW5ndGgpLmpvaW4oJycpOnJlc3VsdC5zbGljZSgwLGxlbmd0aCk7fS8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHdyYXBzIGBmdW5jYCB0byBpbnZva2UgaXQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmdcbiAgICAgKiBvZiBgdGhpc0FyZ2AgYW5kIGBwYXJ0aWFsc2AgcHJlcGVuZGVkIHRvIHRoZSBhcmd1bWVudHMgaXQgcmVjZWl2ZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgY3JlYXRlV3JhcGAgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKiBAcGFyYW0geyp9IHRoaXNBcmcgVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwYXJ0aWFscyBUaGUgYXJndW1lbnRzIHRvIHByZXBlbmQgdG8gdGhvc2UgcHJvdmlkZWQgdG9cbiAgICAgKiAgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyB3cmFwcGVkIGZ1bmN0aW9uLlxuICAgICAqL2Z1bmN0aW9uIGNyZWF0ZVBhcnRpYWwoZnVuYyxiaXRtYXNrLHRoaXNBcmcscGFydGlhbHMpe3ZhciBpc0JpbmQ9Yml0bWFzayZXUkFQX0JJTkRfRkxBRyxDdG9yPWNyZWF0ZUN0b3IoZnVuYyk7ZnVuY3Rpb24gd3JhcHBlcigpe3ZhciBhcmdzSW5kZXg9LTEsYXJnc0xlbmd0aD1hcmd1bWVudHMubGVuZ3RoLGxlZnRJbmRleD0tMSxsZWZ0TGVuZ3RoPXBhcnRpYWxzLmxlbmd0aCxhcmdzPUFycmF5KGxlZnRMZW5ndGgrYXJnc0xlbmd0aCksZm49dGhpcyYmdGhpcyE9PXJvb3QmJnRoaXMgaW5zdGFuY2VvZiB3cmFwcGVyP0N0b3I6ZnVuYzt3aGlsZSgrK2xlZnRJbmRleDxsZWZ0TGVuZ3RoKXthcmdzW2xlZnRJbmRleF09cGFydGlhbHNbbGVmdEluZGV4XTt9d2hpbGUoYXJnc0xlbmd0aC0tKXthcmdzW2xlZnRJbmRleCsrXT1hcmd1bWVudHNbKythcmdzSW5kZXhdO31yZXR1cm4gYXBwbHkoZm4saXNCaW5kP3RoaXNBcmc6dGhpcyxhcmdzKTt9cmV0dXJuIHdyYXBwZXI7fS8qKlxuICAgICAqIENyZWF0ZXMgYSBgXy5yYW5nZWAgb3IgYF8ucmFuZ2VSaWdodGAgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHJhbmdlIGZ1bmN0aW9uLlxuICAgICAqL2Z1bmN0aW9uIGNyZWF0ZVJhbmdlKGZyb21SaWdodCl7cmV0dXJuIGZ1bmN0aW9uKHN0YXJ0LGVuZCxzdGVwKXtpZihzdGVwJiZ0eXBlb2Ygc3RlcCE9J251bWJlcicmJmlzSXRlcmF0ZWVDYWxsKHN0YXJ0LGVuZCxzdGVwKSl7ZW5kPXN0ZXA9dW5kZWZpbmVkO30vLyBFbnN1cmUgdGhlIHNpZ24gb2YgYC0wYCBpcyBwcmVzZXJ2ZWQuXG5zdGFydD10b0Zpbml0ZShzdGFydCk7aWYoZW5kPT09dW5kZWZpbmVkKXtlbmQ9c3RhcnQ7c3RhcnQ9MDt9ZWxzZXtlbmQ9dG9GaW5pdGUoZW5kKTt9c3RlcD1zdGVwPT09dW5kZWZpbmVkP3N0YXJ0PGVuZD8xOi0xOnRvRmluaXRlKHN0ZXApO3JldHVybiBiYXNlUmFuZ2Uoc3RhcnQsZW5kLHN0ZXAsZnJvbVJpZ2h0KTt9O30vKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBwZXJmb3JtcyBhIHJlbGF0aW9uYWwgb3BlcmF0aW9uIG9uIHR3byB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IG9wZXJhdG9yIFRoZSBmdW5jdGlvbiB0byBwZXJmb3JtIHRoZSBvcGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcmVsYXRpb25hbCBvcGVyYXRpb24gZnVuY3Rpb24uXG4gICAgICovZnVuY3Rpb24gY3JlYXRlUmVsYXRpb25hbE9wZXJhdGlvbihvcGVyYXRvcil7cmV0dXJuIGZ1bmN0aW9uKHZhbHVlLG90aGVyKXtpZighKHR5cGVvZiB2YWx1ZT09J3N0cmluZycmJnR5cGVvZiBvdGhlcj09J3N0cmluZycpKXt2YWx1ZT10b051bWJlcih2YWx1ZSk7b3RoZXI9dG9OdW1iZXIob3RoZXIpO31yZXR1cm4gb3BlcmF0b3IodmFsdWUsb3RoZXIpO307fS8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHdyYXBzIGBmdW5jYCB0byBjb250aW51ZSBjdXJyeWluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBjcmVhdGVXcmFwYCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHdyYXBGdW5jIFRoZSBmdW5jdGlvbiB0byBjcmVhdGUgdGhlIGBmdW5jYCB3cmFwcGVyLlxuICAgICAqIEBwYXJhbSB7Kn0gcGxhY2Vob2xkZXIgVGhlIHBsYWNlaG9sZGVyIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3BhcnRpYWxzXSBUaGUgYXJndW1lbnRzIHRvIHByZXBlbmQgdG8gdGhvc2UgcHJvdmlkZWQgdG9cbiAgICAgKiAgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbaG9sZGVyc10gVGhlIGBwYXJ0aWFsc2AgcGxhY2Vob2xkZXIgaW5kZXhlcy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbYXJnUG9zXSBUaGUgYXJndW1lbnQgcG9zaXRpb25zIG9mIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthcnldIFRoZSBhcml0eSBjYXAgb2YgYGZ1bmNgLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYXJpdHldIFRoZSBhcml0eSBvZiBgZnVuY2AuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgd3JhcHBlZCBmdW5jdGlvbi5cbiAgICAgKi9mdW5jdGlvbiBjcmVhdGVSZWN1cnJ5KGZ1bmMsYml0bWFzayx3cmFwRnVuYyxwbGFjZWhvbGRlcix0aGlzQXJnLHBhcnRpYWxzLGhvbGRlcnMsYXJnUG9zLGFyeSxhcml0eSl7dmFyIGlzQ3Vycnk9Yml0bWFzayZXUkFQX0NVUlJZX0ZMQUcsbmV3SG9sZGVycz1pc0N1cnJ5P2hvbGRlcnM6dW5kZWZpbmVkLG5ld0hvbGRlcnNSaWdodD1pc0N1cnJ5P3VuZGVmaW5lZDpob2xkZXJzLG5ld1BhcnRpYWxzPWlzQ3Vycnk/cGFydGlhbHM6dW5kZWZpbmVkLG5ld1BhcnRpYWxzUmlnaHQ9aXNDdXJyeT91bmRlZmluZWQ6cGFydGlhbHM7Yml0bWFza3w9aXNDdXJyeT9XUkFQX1BBUlRJQUxfRkxBRzpXUkFQX1BBUlRJQUxfUklHSFRfRkxBRztiaXRtYXNrJj1+KGlzQ3Vycnk/V1JBUF9QQVJUSUFMX1JJR0hUX0ZMQUc6V1JBUF9QQVJUSUFMX0ZMQUcpO2lmKCEoYml0bWFzayZXUkFQX0NVUlJZX0JPVU5EX0ZMQUcpKXtiaXRtYXNrJj1+KFdSQVBfQklORF9GTEFHfFdSQVBfQklORF9LRVlfRkxBRyk7fXZhciBuZXdEYXRhPVtmdW5jLGJpdG1hc2ssdGhpc0FyZyxuZXdQYXJ0aWFscyxuZXdIb2xkZXJzLG5ld1BhcnRpYWxzUmlnaHQsbmV3SG9sZGVyc1JpZ2h0LGFyZ1BvcyxhcnksYXJpdHldO3ZhciByZXN1bHQ9d3JhcEZ1bmMuYXBwbHkodW5kZWZpbmVkLG5ld0RhdGEpO2lmKGlzTGF6aWFibGUoZnVuYykpe3NldERhdGEocmVzdWx0LG5ld0RhdGEpO31yZXN1bHQucGxhY2Vob2xkZXI9cGxhY2Vob2xkZXI7cmV0dXJuIHNldFdyYXBUb1N0cmluZyhyZXN1bHQsZnVuYyxiaXRtYXNrKTt9LyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIGxpa2UgYF8ucm91bmRgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWV0aG9kTmFtZSBUaGUgbmFtZSBvZiB0aGUgYE1hdGhgIG1ldGhvZCB0byB1c2Ugd2hlbiByb3VuZGluZy5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyByb3VuZCBmdW5jdGlvbi5cbiAgICAgKi9mdW5jdGlvbiBjcmVhdGVSb3VuZChtZXRob2ROYW1lKXt2YXIgZnVuYz1NYXRoW21ldGhvZE5hbWVdO3JldHVybiBmdW5jdGlvbihudW1iZXIscHJlY2lzaW9uKXtudW1iZXI9dG9OdW1iZXIobnVtYmVyKTtwcmVjaXNpb249cHJlY2lzaW9uPT1udWxsPzA6bmF0aXZlTWluKHRvSW50ZWdlcihwcmVjaXNpb24pLDI5Mik7aWYocHJlY2lzaW9uKXsvLyBTaGlmdCB3aXRoIGV4cG9uZW50aWFsIG5vdGF0aW9uIHRvIGF2b2lkIGZsb2F0aW5nLXBvaW50IGlzc3Vlcy5cbi8vIFNlZSBbTUROXShodHRwczovL21kbi5pby9yb3VuZCNFeGFtcGxlcykgZm9yIG1vcmUgZGV0YWlscy5cbnZhciBwYWlyPSh0b1N0cmluZyhudW1iZXIpKydlJykuc3BsaXQoJ2UnKSx2YWx1ZT1mdW5jKHBhaXJbMF0rJ2UnKygrcGFpclsxXStwcmVjaXNpb24pKTtwYWlyPSh0b1N0cmluZyh2YWx1ZSkrJ2UnKS5zcGxpdCgnZScpO3JldHVybisocGFpclswXSsnZScrKCtwYWlyWzFdLXByZWNpc2lvbikpO31yZXR1cm4gZnVuYyhudW1iZXIpO307fS8qKlxuICAgICAqIENyZWF0ZXMgYSBzZXQgb2JqZWN0IG9mIGB2YWx1ZXNgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byBhZGQgdG8gdGhlIHNldC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgc2V0LlxuICAgICAqL3ZhciBjcmVhdGVTZXQ9IShTZXQmJjEvc2V0VG9BcnJheShuZXcgU2V0KFssLTBdKSlbMV09PUlORklOSVRZKT9ub29wOmZ1bmN0aW9uKHZhbHVlcyl7cmV0dXJuIG5ldyBTZXQodmFsdWVzKTt9Oy8qKlxuICAgICAqIENyZWF0ZXMgYSBgXy50b1BhaXJzYCBvciBgXy50b1BhaXJzSW5gIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBrZXlzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBrZXlzIG9mIGEgZ2l2ZW4gb2JqZWN0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHBhaXJzIGZ1bmN0aW9uLlxuICAgICAqL2Z1bmN0aW9uIGNyZWF0ZVRvUGFpcnMoa2V5c0Z1bmMpe3JldHVybiBmdW5jdGlvbihvYmplY3Qpe3ZhciB0YWc9Z2V0VGFnKG9iamVjdCk7aWYodGFnPT1tYXBUYWcpe3JldHVybiBtYXBUb0FycmF5KG9iamVjdCk7fWlmKHRhZz09c2V0VGFnKXtyZXR1cm4gc2V0VG9QYWlycyhvYmplY3QpO31yZXR1cm4gYmFzZVRvUGFpcnMob2JqZWN0LGtleXNGdW5jKG9iamVjdCkpO307fS8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGVpdGhlciBjdXJyaWVzIG9yIGludm9rZXMgYGZ1bmNgIHdpdGggb3B0aW9uYWxcbiAgICAgKiBgdGhpc2AgYmluZGluZyBhbmQgcGFydGlhbGx5IGFwcGxpZWQgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufHN0cmluZ30gZnVuYyBUaGUgZnVuY3Rpb24gb3IgbWV0aG9kIG5hbWUgdG8gd3JhcC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy5cbiAgICAgKiAgICAxIC0gYF8uYmluZGBcbiAgICAgKiAgICAyIC0gYF8uYmluZEtleWBcbiAgICAgKiAgICA0IC0gYF8uY3VycnlgIG9yIGBfLmN1cnJ5UmlnaHRgIG9mIGEgYm91bmQgZnVuY3Rpb25cbiAgICAgKiAgICA4IC0gYF8uY3VycnlgXG4gICAgICogICAxNiAtIGBfLmN1cnJ5UmlnaHRgXG4gICAgICogICAzMiAtIGBfLnBhcnRpYWxgXG4gICAgICogICA2NCAtIGBfLnBhcnRpYWxSaWdodGBcbiAgICAgKiAgMTI4IC0gYF8ucmVhcmdgXG4gICAgICogIDI1NiAtIGBfLmFyeWBcbiAgICAgKiAgNTEyIC0gYF8uZmxpcGBcbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwYXJ0aWFsc10gVGhlIGFyZ3VtZW50cyB0byBiZSBwYXJ0aWFsbHkgYXBwbGllZC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbaG9sZGVyc10gVGhlIGBwYXJ0aWFsc2AgcGxhY2Vob2xkZXIgaW5kZXhlcy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbYXJnUG9zXSBUaGUgYXJndW1lbnQgcG9zaXRpb25zIG9mIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthcnldIFRoZSBhcml0eSBjYXAgb2YgYGZ1bmNgLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYXJpdHldIFRoZSBhcml0eSBvZiBgZnVuY2AuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgd3JhcHBlZCBmdW5jdGlvbi5cbiAgICAgKi9mdW5jdGlvbiBjcmVhdGVXcmFwKGZ1bmMsYml0bWFzayx0aGlzQXJnLHBhcnRpYWxzLGhvbGRlcnMsYXJnUG9zLGFyeSxhcml0eSl7dmFyIGlzQmluZEtleT1iaXRtYXNrJldSQVBfQklORF9LRVlfRkxBRztpZighaXNCaW5kS2V5JiZ0eXBlb2YgZnVuYyE9J2Z1bmN0aW9uJyl7dGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO312YXIgbGVuZ3RoPXBhcnRpYWxzP3BhcnRpYWxzLmxlbmd0aDowO2lmKCFsZW5ndGgpe2JpdG1hc2smPX4oV1JBUF9QQVJUSUFMX0ZMQUd8V1JBUF9QQVJUSUFMX1JJR0hUX0ZMQUcpO3BhcnRpYWxzPWhvbGRlcnM9dW5kZWZpbmVkO31hcnk9YXJ5PT09dW5kZWZpbmVkP2FyeTpuYXRpdmVNYXgodG9JbnRlZ2VyKGFyeSksMCk7YXJpdHk9YXJpdHk9PT11bmRlZmluZWQ/YXJpdHk6dG9JbnRlZ2VyKGFyaXR5KTtsZW5ndGgtPWhvbGRlcnM/aG9sZGVycy5sZW5ndGg6MDtpZihiaXRtYXNrJldSQVBfUEFSVElBTF9SSUdIVF9GTEFHKXt2YXIgcGFydGlhbHNSaWdodD1wYXJ0aWFscyxob2xkZXJzUmlnaHQ9aG9sZGVycztwYXJ0aWFscz1ob2xkZXJzPXVuZGVmaW5lZDt9dmFyIGRhdGE9aXNCaW5kS2V5P3VuZGVmaW5lZDpnZXREYXRhKGZ1bmMpO3ZhciBuZXdEYXRhPVtmdW5jLGJpdG1hc2ssdGhpc0FyZyxwYXJ0aWFscyxob2xkZXJzLHBhcnRpYWxzUmlnaHQsaG9sZGVyc1JpZ2h0LGFyZ1BvcyxhcnksYXJpdHldO2lmKGRhdGEpe21lcmdlRGF0YShuZXdEYXRhLGRhdGEpO31mdW5jPW5ld0RhdGFbMF07Yml0bWFzaz1uZXdEYXRhWzFdO3RoaXNBcmc9bmV3RGF0YVsyXTtwYXJ0aWFscz1uZXdEYXRhWzNdO2hvbGRlcnM9bmV3RGF0YVs0XTthcml0eT1uZXdEYXRhWzldPW5ld0RhdGFbOV09PT11bmRlZmluZWQ/aXNCaW5kS2V5PzA6ZnVuYy5sZW5ndGg6bmF0aXZlTWF4KG5ld0RhdGFbOV0tbGVuZ3RoLDApO2lmKCFhcml0eSYmYml0bWFzayYoV1JBUF9DVVJSWV9GTEFHfFdSQVBfQ1VSUllfUklHSFRfRkxBRykpe2JpdG1hc2smPX4oV1JBUF9DVVJSWV9GTEFHfFdSQVBfQ1VSUllfUklHSFRfRkxBRyk7fWlmKCFiaXRtYXNrfHxiaXRtYXNrPT1XUkFQX0JJTkRfRkxBRyl7dmFyIHJlc3VsdD1jcmVhdGVCaW5kKGZ1bmMsYml0bWFzayx0aGlzQXJnKTt9ZWxzZSBpZihiaXRtYXNrPT1XUkFQX0NVUlJZX0ZMQUd8fGJpdG1hc2s9PVdSQVBfQ1VSUllfUklHSFRfRkxBRyl7cmVzdWx0PWNyZWF0ZUN1cnJ5KGZ1bmMsYml0bWFzayxhcml0eSk7fWVsc2UgaWYoKGJpdG1hc2s9PVdSQVBfUEFSVElBTF9GTEFHfHxiaXRtYXNrPT0oV1JBUF9CSU5EX0ZMQUd8V1JBUF9QQVJUSUFMX0ZMQUcpKSYmIWhvbGRlcnMubGVuZ3RoKXtyZXN1bHQ9Y3JlYXRlUGFydGlhbChmdW5jLGJpdG1hc2ssdGhpc0FyZyxwYXJ0aWFscyk7fWVsc2V7cmVzdWx0PWNyZWF0ZUh5YnJpZC5hcHBseSh1bmRlZmluZWQsbmV3RGF0YSk7fXZhciBzZXR0ZXI9ZGF0YT9iYXNlU2V0RGF0YTpzZXREYXRhO3JldHVybiBzZXRXcmFwVG9TdHJpbmcoc2V0dGVyKHJlc3VsdCxuZXdEYXRhKSxmdW5jLGJpdG1hc2spO30vKipcbiAgICAgKiBVc2VkIGJ5IGBfLmRlZmF1bHRzYCB0byBjdXN0b21pemUgaXRzIGBfLmFzc2lnbkluYCB1c2UgdG8gYXNzaWduIHByb3BlcnRpZXNcbiAgICAgKiBvZiBzb3VyY2Ugb2JqZWN0cyB0byB0aGUgZGVzdGluYXRpb24gb2JqZWN0IGZvciBhbGwgZGVzdGluYXRpb24gcHJvcGVydGllc1xuICAgICAqIHRoYXQgcmVzb2x2ZSB0byBgdW5kZWZpbmVkYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSBvYmpWYWx1ZSBUaGUgZGVzdGluYXRpb24gdmFsdWUuXG4gICAgICogQHBhcmFtIHsqfSBzcmNWYWx1ZSBUaGUgc291cmNlIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHBhcmVudCBvYmplY3Qgb2YgYG9ialZhbHVlYC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgdmFsdWUgdG8gYXNzaWduLlxuICAgICAqL2Z1bmN0aW9uIGN1c3RvbURlZmF1bHRzQXNzaWduSW4ob2JqVmFsdWUsc3JjVmFsdWUsa2V5LG9iamVjdCl7aWYob2JqVmFsdWU9PT11bmRlZmluZWR8fGVxKG9ialZhbHVlLG9iamVjdFByb3RvW2tleV0pJiYhaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3Qsa2V5KSl7cmV0dXJuIHNyY1ZhbHVlO31yZXR1cm4gb2JqVmFsdWU7fS8qKlxuICAgICAqIFVzZWQgYnkgYF8uZGVmYXVsdHNEZWVwYCB0byBjdXN0b21pemUgaXRzIGBfLm1lcmdlYCB1c2UgdG8gbWVyZ2Ugc291cmNlXG4gICAgICogb2JqZWN0cyBpbnRvIGRlc3RpbmF0aW9uIG9iamVjdHMgdGhhdCBhcmUgcGFzc2VkIHRocnUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gb2JqVmFsdWUgVGhlIGRlc3RpbmF0aW9uIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7Kn0gc3JjVmFsdWUgVGhlIHNvdXJjZSB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIG1lcmdlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHBhcmVudCBvYmplY3Qgb2YgYG9ialZhbHVlYC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBwYXJlbnQgb2JqZWN0IG9mIGBzcmNWYWx1ZWAuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBzb3VyY2UgdmFsdWVzIGFuZCB0aGVpciBtZXJnZWRcbiAgICAgKiAgY291bnRlcnBhcnRzLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gICAgICovZnVuY3Rpb24gY3VzdG9tRGVmYXVsdHNNZXJnZShvYmpWYWx1ZSxzcmNWYWx1ZSxrZXksb2JqZWN0LHNvdXJjZSxzdGFjayl7aWYoaXNPYmplY3Qob2JqVmFsdWUpJiZpc09iamVjdChzcmNWYWx1ZSkpey8vIFJlY3Vyc2l2ZWx5IG1lcmdlIG9iamVjdHMgYW5kIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuc3RhY2suc2V0KHNyY1ZhbHVlLG9ialZhbHVlKTtiYXNlTWVyZ2Uob2JqVmFsdWUsc3JjVmFsdWUsdW5kZWZpbmVkLGN1c3RvbURlZmF1bHRzTWVyZ2Usc3RhY2spO3N0YWNrWydkZWxldGUnXShzcmNWYWx1ZSk7fXJldHVybiBvYmpWYWx1ZTt9LyoqXG4gICAgICogVXNlZCBieSBgXy5vbWl0YCB0byBjdXN0b21pemUgaXRzIGBfLmNsb25lRGVlcGAgdXNlIHRvIG9ubHkgY2xvbmUgcGxhaW5cbiAgICAgKiBvYmplY3RzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgdW5jbG9uZWQgdmFsdWUgb3IgYHVuZGVmaW5lZGAgdG8gZGVmZXIgY2xvbmluZyB0byBgXy5jbG9uZURlZXBgLlxuICAgICAqL2Z1bmN0aW9uIGN1c3RvbU9taXRDbG9uZSh2YWx1ZSl7cmV0dXJuIGlzUGxhaW5PYmplY3QodmFsdWUpP3VuZGVmaW5lZDp2YWx1ZTt9LyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBhcnJheXMgd2l0aCBzdXBwb3J0IGZvclxuICAgICAqIHBhcnRpYWwgZGVlcCBjb21wYXJpc29ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtBcnJheX0gb3RoZXIgVGhlIG90aGVyIGFycmF5IHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3RhY2sgVHJhY2tzIHRyYXZlcnNlZCBgYXJyYXlgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBhcnJheXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9mdW5jdGlvbiBlcXVhbEFycmF5cyhhcnJheSxvdGhlcixiaXRtYXNrLGN1c3RvbWl6ZXIsZXF1YWxGdW5jLHN0YWNrKXt2YXIgaXNQYXJ0aWFsPWJpdG1hc2smQ09NUEFSRV9QQVJUSUFMX0ZMQUcsYXJyTGVuZ3RoPWFycmF5Lmxlbmd0aCxvdGhMZW5ndGg9b3RoZXIubGVuZ3RoO2lmKGFyckxlbmd0aCE9b3RoTGVuZ3RoJiYhKGlzUGFydGlhbCYmb3RoTGVuZ3RoPmFyckxlbmd0aCkpe3JldHVybiBmYWxzZTt9Ly8gQXNzdW1lIGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxudmFyIHN0YWNrZWQ9c3RhY2suZ2V0KGFycmF5KTtpZihzdGFja2VkJiZzdGFjay5nZXQob3RoZXIpKXtyZXR1cm4gc3RhY2tlZD09b3RoZXI7fXZhciBpbmRleD0tMSxyZXN1bHQ9dHJ1ZSxzZWVuPWJpdG1hc2smQ09NUEFSRV9VTk9SREVSRURfRkxBRz9uZXcgU2V0Q2FjaGUoKTp1bmRlZmluZWQ7c3RhY2suc2V0KGFycmF5LG90aGVyKTtzdGFjay5zZXQob3RoZXIsYXJyYXkpOy8vIElnbm9yZSBub24taW5kZXggcHJvcGVydGllcy5cbndoaWxlKCsraW5kZXg8YXJyTGVuZ3RoKXt2YXIgYXJyVmFsdWU9YXJyYXlbaW5kZXhdLG90aFZhbHVlPW90aGVyW2luZGV4XTtpZihjdXN0b21pemVyKXt2YXIgY29tcGFyZWQ9aXNQYXJ0aWFsP2N1c3RvbWl6ZXIob3RoVmFsdWUsYXJyVmFsdWUsaW5kZXgsb3RoZXIsYXJyYXksc3RhY2spOmN1c3RvbWl6ZXIoYXJyVmFsdWUsb3RoVmFsdWUsaW5kZXgsYXJyYXksb3RoZXIsc3RhY2spO31pZihjb21wYXJlZCE9PXVuZGVmaW5lZCl7aWYoY29tcGFyZWQpe2NvbnRpbnVlO31yZXN1bHQ9ZmFsc2U7YnJlYWs7fS8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG5pZihzZWVuKXtpZighYXJyYXlTb21lKG90aGVyLGZ1bmN0aW9uKG90aFZhbHVlLG90aEluZGV4KXtpZighY2FjaGVIYXMoc2VlbixvdGhJbmRleCkmJihhcnJWYWx1ZT09PW90aFZhbHVlfHxlcXVhbEZ1bmMoYXJyVmFsdWUsb3RoVmFsdWUsYml0bWFzayxjdXN0b21pemVyLHN0YWNrKSkpe3JldHVybiBzZWVuLnB1c2gob3RoSW5kZXgpO319KSl7cmVzdWx0PWZhbHNlO2JyZWFrO319ZWxzZSBpZighKGFyclZhbHVlPT09b3RoVmFsdWV8fGVxdWFsRnVuYyhhcnJWYWx1ZSxvdGhWYWx1ZSxiaXRtYXNrLGN1c3RvbWl6ZXIsc3RhY2spKSl7cmVzdWx0PWZhbHNlO2JyZWFrO319c3RhY2tbJ2RlbGV0ZSddKGFycmF5KTtzdGFja1snZGVsZXRlJ10ob3RoZXIpO3JldHVybiByZXN1bHQ7fS8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3IgY29tcGFyaW5nIG9iamVjdHMgb2ZcbiAgICAgKiB0aGUgc2FtZSBgdG9TdHJpbmdUYWdgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgZnVuY3Rpb24gb25seSBzdXBwb3J0cyBjb21wYXJpbmcgdmFsdWVzIHdpdGggdGFncyBvZlxuICAgICAqIGBCb29sZWFuYCwgYERhdGVgLCBgRXJyb3JgLCBgTnVtYmVyYCwgYFJlZ0V4cGAsIG9yIGBTdHJpbmdgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0YWcgVGhlIGB0b1N0cmluZ1RhZ2Agb2YgdGhlIG9iamVjdHMgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gICAgICovZnVuY3Rpb24gZXF1YWxCeVRhZyhvYmplY3Qsb3RoZXIsdGFnLGJpdG1hc2ssY3VzdG9taXplcixlcXVhbEZ1bmMsc3RhY2spe3N3aXRjaCh0YWcpe2Nhc2UgZGF0YVZpZXdUYWc6aWYob2JqZWN0LmJ5dGVMZW5ndGghPW90aGVyLmJ5dGVMZW5ndGh8fG9iamVjdC5ieXRlT2Zmc2V0IT1vdGhlci5ieXRlT2Zmc2V0KXtyZXR1cm4gZmFsc2U7fW9iamVjdD1vYmplY3QuYnVmZmVyO290aGVyPW90aGVyLmJ1ZmZlcjtjYXNlIGFycmF5QnVmZmVyVGFnOmlmKG9iamVjdC5ieXRlTGVuZ3RoIT1vdGhlci5ieXRlTGVuZ3RofHwhZXF1YWxGdW5jKG5ldyBVaW50OEFycmF5KG9iamVjdCksbmV3IFVpbnQ4QXJyYXkob3RoZXIpKSl7cmV0dXJuIGZhbHNlO31yZXR1cm4gdHJ1ZTtjYXNlIGJvb2xUYWc6Y2FzZSBkYXRlVGFnOmNhc2UgbnVtYmVyVGFnOi8vIENvZXJjZSBib29sZWFucyB0byBgMWAgb3IgYDBgIGFuZCBkYXRlcyB0byBtaWxsaXNlY29uZHMuXG4vLyBJbnZhbGlkIGRhdGVzIGFyZSBjb2VyY2VkIHRvIGBOYU5gLlxucmV0dXJuIGVxKCtvYmplY3QsK290aGVyKTtjYXNlIGVycm9yVGFnOnJldHVybiBvYmplY3QubmFtZT09b3RoZXIubmFtZSYmb2JqZWN0Lm1lc3NhZ2U9PW90aGVyLm1lc3NhZ2U7Y2FzZSByZWdleHBUYWc6Y2FzZSBzdHJpbmdUYWc6Ly8gQ29lcmNlIHJlZ2V4ZXMgdG8gc3RyaW5ncyBhbmQgdHJlYXQgc3RyaW5ncywgcHJpbWl0aXZlcyBhbmQgb2JqZWN0cyxcbi8vIGFzIGVxdWFsLiBTZWUgaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXJlZ2V4cC5wcm90b3R5cGUudG9zdHJpbmdcbi8vIGZvciBtb3JlIGRldGFpbHMuXG5yZXR1cm4gb2JqZWN0PT1vdGhlcisnJztjYXNlIG1hcFRhZzp2YXIgY29udmVydD1tYXBUb0FycmF5O2Nhc2Ugc2V0VGFnOnZhciBpc1BhcnRpYWw9Yml0bWFzayZDT01QQVJFX1BBUlRJQUxfRkxBRztjb252ZXJ0fHwoY29udmVydD1zZXRUb0FycmF5KTtpZihvYmplY3Quc2l6ZSE9b3RoZXIuc2l6ZSYmIWlzUGFydGlhbCl7cmV0dXJuIGZhbHNlO30vLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG52YXIgc3RhY2tlZD1zdGFjay5nZXQob2JqZWN0KTtpZihzdGFja2VkKXtyZXR1cm4gc3RhY2tlZD09b3RoZXI7fWJpdG1hc2t8PUNPTVBBUkVfVU5PUkRFUkVEX0ZMQUc7Ly8gUmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG5zdGFjay5zZXQob2JqZWN0LG90aGVyKTt2YXIgcmVzdWx0PWVxdWFsQXJyYXlzKGNvbnZlcnQob2JqZWN0KSxjb252ZXJ0KG90aGVyKSxiaXRtYXNrLGN1c3RvbWl6ZXIsZXF1YWxGdW5jLHN0YWNrKTtzdGFja1snZGVsZXRlJ10ob2JqZWN0KTtyZXR1cm4gcmVzdWx0O2Nhc2Ugc3ltYm9sVGFnOmlmKHN5bWJvbFZhbHVlT2Ype3JldHVybiBzeW1ib2xWYWx1ZU9mLmNhbGwob2JqZWN0KT09c3ltYm9sVmFsdWVPZi5jYWxsKG90aGVyKTt9fXJldHVybiBmYWxzZTt9LyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBvYmplY3RzIHdpdGggc3VwcG9ydCBmb3JcbiAgICAgKiBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3RhY2sgVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL2Z1bmN0aW9uIGVxdWFsT2JqZWN0cyhvYmplY3Qsb3RoZXIsYml0bWFzayxjdXN0b21pemVyLGVxdWFsRnVuYyxzdGFjayl7dmFyIGlzUGFydGlhbD1iaXRtYXNrJkNPTVBBUkVfUEFSVElBTF9GTEFHLG9ialByb3BzPWdldEFsbEtleXMob2JqZWN0KSxvYmpMZW5ndGg9b2JqUHJvcHMubGVuZ3RoLG90aFByb3BzPWdldEFsbEtleXMob3RoZXIpLG90aExlbmd0aD1vdGhQcm9wcy5sZW5ndGg7aWYob2JqTGVuZ3RoIT1vdGhMZW5ndGgmJiFpc1BhcnRpYWwpe3JldHVybiBmYWxzZTt9dmFyIGluZGV4PW9iakxlbmd0aDt3aGlsZShpbmRleC0tKXt2YXIga2V5PW9ialByb3BzW2luZGV4XTtpZighKGlzUGFydGlhbD9rZXkgaW4gb3RoZXI6aGFzT3duUHJvcGVydHkuY2FsbChvdGhlcixrZXkpKSl7cmV0dXJuIGZhbHNlO319Ly8gQXNzdW1lIGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxudmFyIHN0YWNrZWQ9c3RhY2suZ2V0KG9iamVjdCk7aWYoc3RhY2tlZCYmc3RhY2suZ2V0KG90aGVyKSl7cmV0dXJuIHN0YWNrZWQ9PW90aGVyO312YXIgcmVzdWx0PXRydWU7c3RhY2suc2V0KG9iamVjdCxvdGhlcik7c3RhY2suc2V0KG90aGVyLG9iamVjdCk7dmFyIHNraXBDdG9yPWlzUGFydGlhbDt3aGlsZSgrK2luZGV4PG9iakxlbmd0aCl7a2V5PW9ialByb3BzW2luZGV4XTt2YXIgb2JqVmFsdWU9b2JqZWN0W2tleV0sb3RoVmFsdWU9b3RoZXJba2V5XTtpZihjdXN0b21pemVyKXt2YXIgY29tcGFyZWQ9aXNQYXJ0aWFsP2N1c3RvbWl6ZXIob3RoVmFsdWUsb2JqVmFsdWUsa2V5LG90aGVyLG9iamVjdCxzdGFjayk6Y3VzdG9taXplcihvYmpWYWx1ZSxvdGhWYWx1ZSxrZXksb2JqZWN0LG90aGVyLHN0YWNrKTt9Ly8gUmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG5pZighKGNvbXBhcmVkPT09dW5kZWZpbmVkP29ialZhbHVlPT09b3RoVmFsdWV8fGVxdWFsRnVuYyhvYmpWYWx1ZSxvdGhWYWx1ZSxiaXRtYXNrLGN1c3RvbWl6ZXIsc3RhY2spOmNvbXBhcmVkKSl7cmVzdWx0PWZhbHNlO2JyZWFrO31za2lwQ3Rvcnx8KHNraXBDdG9yPWtleT09J2NvbnN0cnVjdG9yJyk7fWlmKHJlc3VsdCYmIXNraXBDdG9yKXt2YXIgb2JqQ3Rvcj1vYmplY3QuY29uc3RydWN0b3Isb3RoQ3Rvcj1vdGhlci5jb25zdHJ1Y3RvcjsvLyBOb24gYE9iamVjdGAgb2JqZWN0IGluc3RhbmNlcyB3aXRoIGRpZmZlcmVudCBjb25zdHJ1Y3RvcnMgYXJlIG5vdCBlcXVhbC5cbmlmKG9iakN0b3IhPW90aEN0b3ImJidjb25zdHJ1Y3RvcidpbiBvYmplY3QmJidjb25zdHJ1Y3RvcidpbiBvdGhlciYmISh0eXBlb2Ygb2JqQ3Rvcj09J2Z1bmN0aW9uJyYmb2JqQ3RvciBpbnN0YW5jZW9mIG9iakN0b3ImJnR5cGVvZiBvdGhDdG9yPT0nZnVuY3Rpb24nJiZvdGhDdG9yIGluc3RhbmNlb2Ygb3RoQ3Rvcikpe3Jlc3VsdD1mYWxzZTt9fXN0YWNrWydkZWxldGUnXShvYmplY3QpO3N0YWNrWydkZWxldGUnXShvdGhlcik7cmV0dXJuIHJlc3VsdDt9LyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlUmVzdGAgd2hpY2ggZmxhdHRlbnMgdGhlIHJlc3QgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICovZnVuY3Rpb24gZmxhdFJlc3QoZnVuYyl7cmV0dXJuIHNldFRvU3RyaW5nKG92ZXJSZXN0KGZ1bmMsdW5kZWZpbmVkLGZsYXR0ZW4pLGZ1bmMrJycpO30vKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scy5cbiAgICAgKi9mdW5jdGlvbiBnZXRBbGxLZXlzKG9iamVjdCl7cmV0dXJuIGJhc2VHZXRBbGxLZXlzKG9iamVjdCxrZXlzLGdldFN5bWJvbHMpO30vKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgYW5kXG4gICAgICogc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMuXG4gICAgICovZnVuY3Rpb24gZ2V0QWxsS2V5c0luKG9iamVjdCl7cmV0dXJuIGJhc2VHZXRBbGxLZXlzKG9iamVjdCxrZXlzSW4sZ2V0U3ltYm9sc0luKTt9LyoqXG4gICAgICogR2V0cyBtZXRhZGF0YSBmb3IgYGZ1bmNgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWV0YWRhdGEgZm9yIGBmdW5jYC5cbiAgICAgKi92YXIgZ2V0RGF0YT0hbWV0YU1hcD9ub29wOmZ1bmN0aW9uKGZ1bmMpe3JldHVybiBtZXRhTWFwLmdldChmdW5jKTt9Oy8qKlxuICAgICAqIEdldHMgdGhlIG5hbWUgb2YgYGZ1bmNgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBuYW1lLlxuICAgICAqL2Z1bmN0aW9uIGdldEZ1bmNOYW1lKGZ1bmMpe3ZhciByZXN1bHQ9ZnVuYy5uYW1lKycnLGFycmF5PXJlYWxOYW1lc1tyZXN1bHRdLGxlbmd0aD1oYXNPd25Qcm9wZXJ0eS5jYWxsKHJlYWxOYW1lcyxyZXN1bHQpP2FycmF5Lmxlbmd0aDowO3doaWxlKGxlbmd0aC0tKXt2YXIgZGF0YT1hcnJheVtsZW5ndGhdLG90aGVyRnVuYz1kYXRhLmZ1bmM7aWYob3RoZXJGdW5jPT1udWxsfHxvdGhlckZ1bmM9PWZ1bmMpe3JldHVybiBkYXRhLm5hbWU7fX1yZXR1cm4gcmVzdWx0O30vKipcbiAgICAgKiBHZXRzIHRoZSBhcmd1bWVudCBwbGFjZWhvbGRlciB2YWx1ZSBmb3IgYGZ1bmNgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBwbGFjZWhvbGRlciB2YWx1ZS5cbiAgICAgKi9mdW5jdGlvbiBnZXRIb2xkZXIoZnVuYyl7dmFyIG9iamVjdD1oYXNPd25Qcm9wZXJ0eS5jYWxsKGxvZGFzaCwncGxhY2Vob2xkZXInKT9sb2Rhc2g6ZnVuYztyZXR1cm4gb2JqZWN0LnBsYWNlaG9sZGVyO30vKipcbiAgICAgKiBHZXRzIHRoZSBhcHByb3ByaWF0ZSBcIml0ZXJhdGVlXCIgZnVuY3Rpb24uIElmIGBfLml0ZXJhdGVlYCBpcyBjdXN0b21pemVkLFxuICAgICAqIHRoaXMgZnVuY3Rpb24gcmV0dXJucyB0aGUgY3VzdG9tIG1ldGhvZCwgb3RoZXJ3aXNlIGl0IHJldHVybnMgYGJhc2VJdGVyYXRlZWAuXG4gICAgICogSWYgYXJndW1lbnRzIGFyZSBwcm92aWRlZCwgdGhlIGNob3NlbiBmdW5jdGlvbiBpcyBpbnZva2VkIHdpdGggdGhlbSBhbmRcbiAgICAgKiBpdHMgcmVzdWx0IGlzIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IFt2YWx1ZV0gVGhlIHZhbHVlIHRvIGNvbnZlcnQgdG8gYW4gaXRlcmF0ZWUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthcml0eV0gVGhlIGFyaXR5IG9mIHRoZSBjcmVhdGVkIGl0ZXJhdGVlLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgY2hvc2VuIGZ1bmN0aW9uIG9yIGl0cyByZXN1bHQuXG4gICAgICovZnVuY3Rpb24gZ2V0SXRlcmF0ZWUoKXt2YXIgcmVzdWx0PWxvZGFzaC5pdGVyYXRlZXx8aXRlcmF0ZWU7cmVzdWx0PXJlc3VsdD09PWl0ZXJhdGVlP2Jhc2VJdGVyYXRlZTpyZXN1bHQ7cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg/cmVzdWx0KGFyZ3VtZW50c1swXSxhcmd1bWVudHNbMV0pOnJlc3VsdDt9LyoqXG4gICAgICogR2V0cyB0aGUgZGF0YSBmb3IgYG1hcGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgVGhlIG1hcCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSByZWZlcmVuY2Uga2V5LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXAgZGF0YS5cbiAgICAgKi9mdW5jdGlvbiBnZXRNYXBEYXRhKG1hcCxrZXkpe3ZhciBkYXRhPW1hcC5fX2RhdGFfXztyZXR1cm4gaXNLZXlhYmxlKGtleSk/ZGF0YVt0eXBlb2Yga2V5PT0nc3RyaW5nJz8nc3RyaW5nJzonaGFzaCddOmRhdGEubWFwO30vKipcbiAgICAgKiBHZXRzIHRoZSBwcm9wZXJ0eSBuYW1lcywgdmFsdWVzLCBhbmQgY29tcGFyZSBmbGFncyBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbWF0Y2ggZGF0YSBvZiBgb2JqZWN0YC5cbiAgICAgKi9mdW5jdGlvbiBnZXRNYXRjaERhdGEob2JqZWN0KXt2YXIgcmVzdWx0PWtleXMob2JqZWN0KSxsZW5ndGg9cmVzdWx0Lmxlbmd0aDt3aGlsZShsZW5ndGgtLSl7dmFyIGtleT1yZXN1bHRbbGVuZ3RoXSx2YWx1ZT1vYmplY3Rba2V5XTtyZXN1bHRbbGVuZ3RoXT1ba2V5LHZhbHVlLGlzU3RyaWN0Q29tcGFyYWJsZSh2YWx1ZSldO31yZXR1cm4gcmVzdWx0O30vKipcbiAgICAgKiBHZXRzIHRoZSBuYXRpdmUgZnVuY3Rpb24gYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIG1ldGhvZCB0byBnZXQuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGZ1bmN0aW9uIGlmIGl0J3MgbmF0aXZlLCBlbHNlIGB1bmRlZmluZWRgLlxuICAgICAqL2Z1bmN0aW9uIGdldE5hdGl2ZShvYmplY3Qsa2V5KXt2YXIgdmFsdWU9Z2V0VmFsdWUob2JqZWN0LGtleSk7cmV0dXJuIGJhc2VJc05hdGl2ZSh2YWx1ZSk/dmFsdWU6dW5kZWZpbmVkO30vKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VHZXRUYWdgIHdoaWNoIGlnbm9yZXMgYFN5bWJvbC50b1N0cmluZ1RhZ2AgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSByYXcgYHRvU3RyaW5nVGFnYC5cbiAgICAgKi9mdW5jdGlvbiBnZXRSYXdUYWcodmFsdWUpe3ZhciBpc093bj1oYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLHN5bVRvU3RyaW5nVGFnKSx0YWc9dmFsdWVbc3ltVG9TdHJpbmdUYWddO3RyeXt2YWx1ZVtzeW1Ub1N0cmluZ1RhZ109dW5kZWZpbmVkO3ZhciB1bm1hc2tlZD10cnVlO31jYXRjaChlKXt9dmFyIHJlc3VsdD1uYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtpZih1bm1hc2tlZCl7aWYoaXNPd24pe3ZhbHVlW3N5bVRvU3RyaW5nVGFnXT10YWc7fWVsc2V7ZGVsZXRlIHZhbHVlW3N5bVRvU3RyaW5nVGFnXTt9fXJldHVybiByZXN1bHQ7fS8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHN5bWJvbHMuXG4gICAgICovdmFyIGdldFN5bWJvbHM9IW5hdGl2ZUdldFN5bWJvbHM/c3R1YkFycmF5OmZ1bmN0aW9uKG9iamVjdCl7aWYob2JqZWN0PT1udWxsKXtyZXR1cm5bXTt9b2JqZWN0PU9iamVjdChvYmplY3QpO3JldHVybiBhcnJheUZpbHRlcihuYXRpdmVHZXRTeW1ib2xzKG9iamVjdCksZnVuY3Rpb24oc3ltYm9sKXtyZXR1cm4gcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChvYmplY3Qsc3ltYm9sKTt9KTt9Oy8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2Ygc3ltYm9scy5cbiAgICAgKi92YXIgZ2V0U3ltYm9sc0luPSFuYXRpdmVHZXRTeW1ib2xzP3N0dWJBcnJheTpmdW5jdGlvbihvYmplY3Qpe3ZhciByZXN1bHQ9W107d2hpbGUob2JqZWN0KXthcnJheVB1c2gocmVzdWx0LGdldFN5bWJvbHMob2JqZWN0KSk7b2JqZWN0PWdldFByb3RvdHlwZShvYmplY3QpO31yZXR1cm4gcmVzdWx0O307LyoqXG4gICAgICogR2V0cyB0aGUgYHRvU3RyaW5nVGFnYCBvZiBgdmFsdWVgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICAgICAqL3ZhciBnZXRUYWc9YmFzZUdldFRhZzsvLyBGYWxsYmFjayBmb3IgZGF0YSB2aWV3cywgbWFwcywgc2V0cywgYW5kIHdlYWsgbWFwcyBpbiBJRSAxMSBhbmQgcHJvbWlzZXMgaW4gTm9kZS5qcyA8IDYuXG5pZihEYXRhVmlldyYmZ2V0VGFnKG5ldyBEYXRhVmlldyhuZXcgQXJyYXlCdWZmZXIoMSkpKSE9ZGF0YVZpZXdUYWd8fE1hcCYmZ2V0VGFnKG5ldyBNYXAoKSkhPW1hcFRhZ3x8UHJvbWlzZSYmZ2V0VGFnKFByb21pc2UucmVzb2x2ZSgpKSE9cHJvbWlzZVRhZ3x8U2V0JiZnZXRUYWcobmV3IFNldCgpKSE9c2V0VGFnfHxXZWFrTWFwJiZnZXRUYWcobmV3IFdlYWtNYXAoKSkhPXdlYWtNYXBUYWcpe2dldFRhZz1mdW5jdGlvbih2YWx1ZSl7dmFyIHJlc3VsdD1iYXNlR2V0VGFnKHZhbHVlKSxDdG9yPXJlc3VsdD09b2JqZWN0VGFnP3ZhbHVlLmNvbnN0cnVjdG9yOnVuZGVmaW5lZCxjdG9yU3RyaW5nPUN0b3I/dG9Tb3VyY2UoQ3Rvcik6Jyc7aWYoY3RvclN0cmluZyl7c3dpdGNoKGN0b3JTdHJpbmcpe2Nhc2UgZGF0YVZpZXdDdG9yU3RyaW5nOnJldHVybiBkYXRhVmlld1RhZztjYXNlIG1hcEN0b3JTdHJpbmc6cmV0dXJuIG1hcFRhZztjYXNlIHByb21pc2VDdG9yU3RyaW5nOnJldHVybiBwcm9taXNlVGFnO2Nhc2Ugc2V0Q3RvclN0cmluZzpyZXR1cm4gc2V0VGFnO2Nhc2Ugd2Vha01hcEN0b3JTdHJpbmc6cmV0dXJuIHdlYWtNYXBUYWc7fX1yZXR1cm4gcmVzdWx0O307fS8qKlxuICAgICAqIEdldHMgdGhlIHZpZXcsIGFwcGx5aW5nIGFueSBgdHJhbnNmb3Jtc2AgdG8gdGhlIGBzdGFydGAgYW5kIGBlbmRgIHBvc2l0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IFRoZSBzdGFydCBvZiB0aGUgdmlldy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZW5kIFRoZSBlbmQgb2YgdGhlIHZpZXcuXG4gICAgICogQHBhcmFtIHtBcnJheX0gdHJhbnNmb3JtcyBUaGUgdHJhbnNmb3JtYXRpb25zIHRvIGFwcGx5IHRvIHRoZSB2aWV3LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGBzdGFydGAgYW5kIGBlbmRgXG4gICAgICogIHBvc2l0aW9ucyBvZiB0aGUgdmlldy5cbiAgICAgKi9mdW5jdGlvbiBnZXRWaWV3KHN0YXJ0LGVuZCx0cmFuc2Zvcm1zKXt2YXIgaW5kZXg9LTEsbGVuZ3RoPXRyYW5zZm9ybXMubGVuZ3RoO3doaWxlKCsraW5kZXg8bGVuZ3RoKXt2YXIgZGF0YT10cmFuc2Zvcm1zW2luZGV4XSxzaXplPWRhdGEuc2l6ZTtzd2l0Y2goZGF0YS50eXBlKXtjYXNlJ2Ryb3AnOnN0YXJ0Kz1zaXplO2JyZWFrO2Nhc2UnZHJvcFJpZ2h0JzplbmQtPXNpemU7YnJlYWs7Y2FzZSd0YWtlJzplbmQ9bmF0aXZlTWluKGVuZCxzdGFydCtzaXplKTticmVhaztjYXNlJ3Rha2VSaWdodCc6c3RhcnQ9bmF0aXZlTWF4KHN0YXJ0LGVuZC1zaXplKTticmVhazt9fXJldHVybnsnc3RhcnQnOnN0YXJ0LCdlbmQnOmVuZH07fS8qKlxuICAgICAqIEV4dHJhY3RzIHdyYXBwZXIgZGV0YWlscyBmcm9tIHRoZSBgc291cmNlYCBib2R5IGNvbW1lbnQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzb3VyY2UgVGhlIHNvdXJjZSB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgd3JhcHBlciBkZXRhaWxzLlxuICAgICAqL2Z1bmN0aW9uIGdldFdyYXBEZXRhaWxzKHNvdXJjZSl7dmFyIG1hdGNoPXNvdXJjZS5tYXRjaChyZVdyYXBEZXRhaWxzKTtyZXR1cm4gbWF0Y2g/bWF0Y2hbMV0uc3BsaXQocmVTcGxpdERldGFpbHMpOltdO30vKipcbiAgICAgKiBDaGVja3MgaWYgYHBhdGhgIGV4aXN0cyBvbiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIGNoZWNrLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhc0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGNoZWNrIHByb3BlcnRpZXMuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBwYXRoYCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9mdW5jdGlvbiBoYXNQYXRoKG9iamVjdCxwYXRoLGhhc0Z1bmMpe3BhdGg9Y2FzdFBhdGgocGF0aCxvYmplY3QpO3ZhciBpbmRleD0tMSxsZW5ndGg9cGF0aC5sZW5ndGgscmVzdWx0PWZhbHNlO3doaWxlKCsraW5kZXg8bGVuZ3RoKXt2YXIga2V5PXRvS2V5KHBhdGhbaW5kZXhdKTtpZighKHJlc3VsdD1vYmplY3QhPW51bGwmJmhhc0Z1bmMob2JqZWN0LGtleSkpKXticmVhazt9b2JqZWN0PW9iamVjdFtrZXldO31pZihyZXN1bHR8fCsraW5kZXghPWxlbmd0aCl7cmV0dXJuIHJlc3VsdDt9bGVuZ3RoPW9iamVjdD09bnVsbD8wOm9iamVjdC5sZW5ndGg7cmV0dXJuISFsZW5ndGgmJmlzTGVuZ3RoKGxlbmd0aCkmJmlzSW5kZXgoa2V5LGxlbmd0aCkmJihpc0FycmF5KG9iamVjdCl8fGlzQXJndW1lbnRzKG9iamVjdCkpO30vKipcbiAgICAgKiBJbml0aWFsaXplcyBhbiBhcnJheSBjbG9uZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNsb25lLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgaW5pdGlhbGl6ZWQgY2xvbmUuXG4gICAgICovZnVuY3Rpb24gaW5pdENsb25lQXJyYXkoYXJyYXkpe3ZhciBsZW5ndGg9YXJyYXkubGVuZ3RoLHJlc3VsdD1hcnJheS5jb25zdHJ1Y3RvcihsZW5ndGgpOy8vIEFkZCBwcm9wZXJ0aWVzIGFzc2lnbmVkIGJ5IGBSZWdFeHAjZXhlY2AuXG5pZihsZW5ndGgmJnR5cGVvZiBhcnJheVswXT09J3N0cmluZycmJmhhc093blByb3BlcnR5LmNhbGwoYXJyYXksJ2luZGV4Jykpe3Jlc3VsdC5pbmRleD1hcnJheS5pbmRleDtyZXN1bHQuaW5wdXQ9YXJyYXkuaW5wdXQ7fXJldHVybiByZXN1bHQ7fS8qKlxuICAgICAqIEluaXRpYWxpemVzIGFuIG9iamVjdCBjbG9uZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNsb25lLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGluaXRpYWxpemVkIGNsb25lLlxuICAgICAqL2Z1bmN0aW9uIGluaXRDbG9uZU9iamVjdChvYmplY3Qpe3JldHVybiB0eXBlb2Ygb2JqZWN0LmNvbnN0cnVjdG9yPT0nZnVuY3Rpb24nJiYhaXNQcm90b3R5cGUob2JqZWN0KT9iYXNlQ3JlYXRlKGdldFByb3RvdHlwZShvYmplY3QpKTp7fTt9LyoqXG4gICAgICogSW5pdGlhbGl6ZXMgYW4gb2JqZWN0IGNsb25lIGJhc2VkIG9uIGl0cyBgdG9TdHJpbmdUYWdgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgZnVuY3Rpb24gb25seSBzdXBwb3J0cyBjbG9uaW5nIHZhbHVlcyB3aXRoIHRhZ3Mgb2ZcbiAgICAgKiBgQm9vbGVhbmAsIGBEYXRlYCwgYEVycm9yYCwgYE51bWJlcmAsIGBSZWdFeHBgLCBvciBgU3RyaW5nYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNsb25lLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0YWcgVGhlIGB0b1N0cmluZ1RhZ2Agb2YgdGhlIG9iamVjdCB0byBjbG9uZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjbG9uZUZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNsb25lIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGluaXRpYWxpemVkIGNsb25lLlxuICAgICAqL2Z1bmN0aW9uIGluaXRDbG9uZUJ5VGFnKG9iamVjdCx0YWcsY2xvbmVGdW5jLGlzRGVlcCl7dmFyIEN0b3I9b2JqZWN0LmNvbnN0cnVjdG9yO3N3aXRjaCh0YWcpe2Nhc2UgYXJyYXlCdWZmZXJUYWc6cmV0dXJuIGNsb25lQXJyYXlCdWZmZXIob2JqZWN0KTtjYXNlIGJvb2xUYWc6Y2FzZSBkYXRlVGFnOnJldHVybiBuZXcgQ3Rvcigrb2JqZWN0KTtjYXNlIGRhdGFWaWV3VGFnOnJldHVybiBjbG9uZURhdGFWaWV3KG9iamVjdCxpc0RlZXApO2Nhc2UgZmxvYXQzMlRhZzpjYXNlIGZsb2F0NjRUYWc6Y2FzZSBpbnQ4VGFnOmNhc2UgaW50MTZUYWc6Y2FzZSBpbnQzMlRhZzpjYXNlIHVpbnQ4VGFnOmNhc2UgdWludDhDbGFtcGVkVGFnOmNhc2UgdWludDE2VGFnOmNhc2UgdWludDMyVGFnOnJldHVybiBjbG9uZVR5cGVkQXJyYXkob2JqZWN0LGlzRGVlcCk7Y2FzZSBtYXBUYWc6cmV0dXJuIGNsb25lTWFwKG9iamVjdCxpc0RlZXAsY2xvbmVGdW5jKTtjYXNlIG51bWJlclRhZzpjYXNlIHN0cmluZ1RhZzpyZXR1cm4gbmV3IEN0b3Iob2JqZWN0KTtjYXNlIHJlZ2V4cFRhZzpyZXR1cm4gY2xvbmVSZWdFeHAob2JqZWN0KTtjYXNlIHNldFRhZzpyZXR1cm4gY2xvbmVTZXQob2JqZWN0LGlzRGVlcCxjbG9uZUZ1bmMpO2Nhc2Ugc3ltYm9sVGFnOnJldHVybiBjbG9uZVN5bWJvbChvYmplY3QpO319LyoqXG4gICAgICogSW5zZXJ0cyB3cmFwcGVyIGBkZXRhaWxzYCBpbiBhIGNvbW1lbnQgYXQgdGhlIHRvcCBvZiB0aGUgYHNvdXJjZWAgYm9keS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNvdXJjZSBUaGUgc291cmNlIHRvIG1vZGlmeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IGRldGFpbHMgVGhlIGRldGFpbHMgdG8gaW5zZXJ0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIG1vZGlmaWVkIHNvdXJjZS5cbiAgICAgKi9mdW5jdGlvbiBpbnNlcnRXcmFwRGV0YWlscyhzb3VyY2UsZGV0YWlscyl7dmFyIGxlbmd0aD1kZXRhaWxzLmxlbmd0aDtpZighbGVuZ3RoKXtyZXR1cm4gc291cmNlO312YXIgbGFzdEluZGV4PWxlbmd0aC0xO2RldGFpbHNbbGFzdEluZGV4XT0obGVuZ3RoPjE/JyYgJzonJykrZGV0YWlsc1tsYXN0SW5kZXhdO2RldGFpbHM9ZGV0YWlscy5qb2luKGxlbmd0aD4yPycsICc6JyAnKTtyZXR1cm4gc291cmNlLnJlcGxhY2UocmVXcmFwQ29tbWVudCwne1xcbi8qIFt3cmFwcGVkIHdpdGggJytkZXRhaWxzKyddICovXFxuJyk7fS8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgZmxhdHRlbmFibGUgYGFyZ3VtZW50c2Agb2JqZWN0IG9yIGFycmF5LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBmbGF0dGVuYWJsZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqL2Z1bmN0aW9uIGlzRmxhdHRlbmFibGUodmFsdWUpe3JldHVybiBpc0FycmF5KHZhbHVlKXx8aXNBcmd1bWVudHModmFsdWUpfHwhIShzcHJlYWRhYmxlU3ltYm9sJiZ2YWx1ZSYmdmFsdWVbc3ByZWFkYWJsZVN5bWJvbF0pO30vKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgaW5kZXguXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPU1BWF9TQUZFX0lOVEVHRVJdIFRoZSB1cHBlciBib3VuZHMgb2YgYSB2YWxpZCBpbmRleC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGluZGV4LCBlbHNlIGBmYWxzZWAuXG4gICAgICovZnVuY3Rpb24gaXNJbmRleCh2YWx1ZSxsZW5ndGgpe2xlbmd0aD1sZW5ndGg9PW51bGw/TUFYX1NBRkVfSU5URUdFUjpsZW5ndGg7cmV0dXJuISFsZW5ndGgmJih0eXBlb2YgdmFsdWU9PSdudW1iZXInfHxyZUlzVWludC50ZXN0KHZhbHVlKSkmJnZhbHVlPi0xJiZ2YWx1ZSUxPT0wJiZ2YWx1ZTxsZW5ndGg7fS8qKlxuICAgICAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gYXJndW1lbnRzIGFyZSBmcm9tIGFuIGl0ZXJhdGVlIGNhbGwuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHBvdGVudGlhbCBpdGVyYXRlZSB2YWx1ZSBhcmd1bWVudC5cbiAgICAgKiBAcGFyYW0geyp9IGluZGV4IFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgaW5kZXggb3Iga2V5IGFyZ3VtZW50LlxuICAgICAqIEBwYXJhbSB7Kn0gb2JqZWN0IFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgb2JqZWN0IGFyZ3VtZW50LlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYXJndW1lbnRzIGFyZSBmcm9tIGFuIGl0ZXJhdGVlIGNhbGwsXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9mdW5jdGlvbiBpc0l0ZXJhdGVlQ2FsbCh2YWx1ZSxpbmRleCxvYmplY3Qpe2lmKCFpc09iamVjdChvYmplY3QpKXtyZXR1cm4gZmFsc2U7fXZhciB0eXBlPXR5cGVvZiBpbmRleDtpZih0eXBlPT0nbnVtYmVyJz9pc0FycmF5TGlrZShvYmplY3QpJiZpc0luZGV4KGluZGV4LG9iamVjdC5sZW5ndGgpOnR5cGU9PSdzdHJpbmcnJiZpbmRleCBpbiBvYmplY3Qpe3JldHVybiBlcShvYmplY3RbaW5kZXhdLHZhbHVlKTt9cmV0dXJuIGZhbHNlO30vKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHByb3BlcnR5IG5hbWUgYW5kIG5vdCBhIHByb3BlcnR5IHBhdGguXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5IGtleXMgb24uXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwcm9wZXJ0eSBuYW1lLCBlbHNlIGBmYWxzZWAuXG4gICAgICovZnVuY3Rpb24gaXNLZXkodmFsdWUsb2JqZWN0KXtpZihpc0FycmF5KHZhbHVlKSl7cmV0dXJuIGZhbHNlO312YXIgdHlwZT10eXBlb2YgdmFsdWU7aWYodHlwZT09J251bWJlcid8fHR5cGU9PSdzeW1ib2wnfHx0eXBlPT0nYm9vbGVhbid8fHZhbHVlPT1udWxsfHxpc1N5bWJvbCh2YWx1ZSkpe3JldHVybiB0cnVlO31yZXR1cm4gcmVJc1BsYWluUHJvcC50ZXN0KHZhbHVlKXx8IXJlSXNEZWVwUHJvcC50ZXN0KHZhbHVlKXx8b2JqZWN0IT1udWxsJiZ2YWx1ZSBpbiBPYmplY3Qob2JqZWN0KTt9LyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUgZm9yIHVzZSBhcyB1bmlxdWUgb2JqZWN0IGtleS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9mdW5jdGlvbiBpc0tleWFibGUodmFsdWUpe3ZhciB0eXBlPXR5cGVvZiB2YWx1ZTtyZXR1cm4gdHlwZT09J3N0cmluZyd8fHR5cGU9PSdudW1iZXInfHx0eXBlPT0nc3ltYm9sJ3x8dHlwZT09J2Jvb2xlYW4nP3ZhbHVlIT09J19fcHJvdG9fXyc6dmFsdWU9PT1udWxsO30vKipcbiAgICAgKiBDaGVja3MgaWYgYGZ1bmNgIGhhcyBhIGxhenkgY291bnRlcnBhcnQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgZnVuY2AgaGFzIGEgbGF6eSBjb3VudGVycGFydCxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqL2Z1bmN0aW9uIGlzTGF6aWFibGUoZnVuYyl7dmFyIGZ1bmNOYW1lPWdldEZ1bmNOYW1lKGZ1bmMpLG90aGVyPWxvZGFzaFtmdW5jTmFtZV07aWYodHlwZW9mIG90aGVyIT0nZnVuY3Rpb24nfHwhKGZ1bmNOYW1lIGluIExhenlXcmFwcGVyLnByb3RvdHlwZSkpe3JldHVybiBmYWxzZTt9aWYoZnVuYz09PW90aGVyKXtyZXR1cm4gdHJ1ZTt9dmFyIGRhdGE9Z2V0RGF0YShvdGhlcik7cmV0dXJuISFkYXRhJiZmdW5jPT09ZGF0YVswXTt9LyoqXG4gICAgICogQ2hlY2tzIGlmIGBmdW5jYCBoYXMgaXRzIHNvdXJjZSBtYXNrZWQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgZnVuY2AgaXMgbWFza2VkLCBlbHNlIGBmYWxzZWAuXG4gICAgICovZnVuY3Rpb24gaXNNYXNrZWQoZnVuYyl7cmV0dXJuISFtYXNrU3JjS2V5JiZtYXNrU3JjS2V5IGluIGZ1bmM7fS8qKlxuICAgICAqIENoZWNrcyBpZiBgZnVuY2AgaXMgY2FwYWJsZSBvZiBiZWluZyBtYXNrZWQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgZnVuY2AgaXMgbWFza2FibGUsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi92YXIgaXNNYXNrYWJsZT1jb3JlSnNEYXRhP2lzRnVuY3Rpb246c3R1YkZhbHNlOy8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhIHByb3RvdHlwZSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvdG90eXBlLCBlbHNlIGBmYWxzZWAuXG4gICAgICovZnVuY3Rpb24gaXNQcm90b3R5cGUodmFsdWUpe3ZhciBDdG9yPXZhbHVlJiZ2YWx1ZS5jb25zdHJ1Y3Rvcixwcm90bz10eXBlb2YgQ3Rvcj09J2Z1bmN0aW9uJyYmQ3Rvci5wcm90b3R5cGV8fG9iamVjdFByb3RvO3JldHVybiB2YWx1ZT09PXByb3RvO30vKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSBmb3Igc3RyaWN0IGVxdWFsaXR5IGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpZiBzdWl0YWJsZSBmb3Igc3RyaWN0XG4gICAgICogIGVxdWFsaXR5IGNvbXBhcmlzb25zLCBlbHNlIGBmYWxzZWAuXG4gICAgICovZnVuY3Rpb24gaXNTdHJpY3RDb21wYXJhYmxlKHZhbHVlKXtyZXR1cm4gdmFsdWU9PT12YWx1ZSYmIWlzT2JqZWN0KHZhbHVlKTt9LyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBtYXRjaGVzUHJvcGVydHlgIGZvciBzb3VyY2UgdmFsdWVzIHN1aXRhYmxlXG4gICAgICogZm9yIHN0cmljdCBlcXVhbGl0eSBjb21wYXJpc29ucywgaS5lLiBgPT09YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gICAgICogQHBhcmFtIHsqfSBzcmNWYWx1ZSBUaGUgdmFsdWUgdG8gbWF0Y2guXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAgICAgKi9mdW5jdGlvbiBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZShrZXksc3JjVmFsdWUpe3JldHVybiBmdW5jdGlvbihvYmplY3Qpe2lmKG9iamVjdD09bnVsbCl7cmV0dXJuIGZhbHNlO31yZXR1cm4gb2JqZWN0W2tleV09PT1zcmNWYWx1ZSYmKHNyY1ZhbHVlIT09dW5kZWZpbmVkfHxrZXkgaW4gT2JqZWN0KG9iamVjdCkpO307fS8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5tZW1vaXplYCB3aGljaCBjbGVhcnMgdGhlIG1lbW9pemVkIGZ1bmN0aW9uJ3NcbiAgICAgKiBjYWNoZSB3aGVuIGl0IGV4Y2VlZHMgYE1BWF9NRU1PSVpFX1NJWkVgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBoYXZlIGl0cyBvdXRwdXQgbWVtb2l6ZWQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gICAgICovZnVuY3Rpb24gbWVtb2l6ZUNhcHBlZChmdW5jKXt2YXIgcmVzdWx0PW1lbW9pemUoZnVuYyxmdW5jdGlvbihrZXkpe2lmKGNhY2hlLnNpemU9PT1NQVhfTUVNT0laRV9TSVpFKXtjYWNoZS5jbGVhcigpO31yZXR1cm4ga2V5O30pO3ZhciBjYWNoZT1yZXN1bHQuY2FjaGU7cmV0dXJuIHJlc3VsdDt9LyoqXG4gICAgICogTWVyZ2VzIHRoZSBmdW5jdGlvbiBtZXRhZGF0YSBvZiBgc291cmNlYCBpbnRvIGBkYXRhYC5cbiAgICAgKlxuICAgICAqIE1lcmdpbmcgbWV0YWRhdGEgcmVkdWNlcyB0aGUgbnVtYmVyIG9mIHdyYXBwZXJzIHVzZWQgdG8gaW52b2tlIGEgZnVuY3Rpb24uXG4gICAgICogVGhpcyBpcyBwb3NzaWJsZSBiZWNhdXNlIG1ldGhvZHMgbGlrZSBgXy5iaW5kYCwgYF8uY3VycnlgLCBhbmQgYF8ucGFydGlhbGBcbiAgICAgKiBtYXkgYmUgYXBwbGllZCByZWdhcmRsZXNzIG9mIGV4ZWN1dGlvbiBvcmRlci4gTWV0aG9kcyBsaWtlIGBfLmFyeWAgYW5kXG4gICAgICogYF8ucmVhcmdgIG1vZGlmeSBmdW5jdGlvbiBhcmd1bWVudHMsIG1ha2luZyB0aGUgb3JkZXIgaW4gd2hpY2ggdGhleSBhcmVcbiAgICAgKiBleGVjdXRlZCBpbXBvcnRhbnQsIHByZXZlbnRpbmcgdGhlIG1lcmdpbmcgb2YgbWV0YWRhdGEuIEhvd2V2ZXIsIHdlIG1ha2VcbiAgICAgKiBhbiBleGNlcHRpb24gZm9yIGEgc2FmZSBjb21iaW5lZCBjYXNlIHdoZXJlIGN1cnJpZWQgZnVuY3Rpb25zIGhhdmUgYF8uYXJ5YFxuICAgICAqIGFuZCBvciBgXy5yZWFyZ2AgYXBwbGllZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gZGF0YSBUaGUgZGVzdGluYXRpb24gbWV0YWRhdGEuXG4gICAgICogQHBhcmFtIHtBcnJheX0gc291cmNlIFRoZSBzb3VyY2UgbWV0YWRhdGEuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBkYXRhYC5cbiAgICAgKi9mdW5jdGlvbiBtZXJnZURhdGEoZGF0YSxzb3VyY2Upe3ZhciBiaXRtYXNrPWRhdGFbMV0sc3JjQml0bWFzaz1zb3VyY2VbMV0sbmV3Qml0bWFzaz1iaXRtYXNrfHNyY0JpdG1hc2ssaXNDb21tb249bmV3Qml0bWFzazwoV1JBUF9CSU5EX0ZMQUd8V1JBUF9CSU5EX0tFWV9GTEFHfFdSQVBfQVJZX0ZMQUcpO3ZhciBpc0NvbWJvPXNyY0JpdG1hc2s9PVdSQVBfQVJZX0ZMQUcmJmJpdG1hc2s9PVdSQVBfQ1VSUllfRkxBR3x8c3JjQml0bWFzaz09V1JBUF9BUllfRkxBRyYmYml0bWFzaz09V1JBUF9SRUFSR19GTEFHJiZkYXRhWzddLmxlbmd0aDw9c291cmNlWzhdfHxzcmNCaXRtYXNrPT0oV1JBUF9BUllfRkxBR3xXUkFQX1JFQVJHX0ZMQUcpJiZzb3VyY2VbN10ubGVuZ3RoPD1zb3VyY2VbOF0mJmJpdG1hc2s9PVdSQVBfQ1VSUllfRkxBRzsvLyBFeGl0IGVhcmx5IGlmIG1ldGFkYXRhIGNhbid0IGJlIG1lcmdlZC5cbmlmKCEoaXNDb21tb258fGlzQ29tYm8pKXtyZXR1cm4gZGF0YTt9Ly8gVXNlIHNvdXJjZSBgdGhpc0FyZ2AgaWYgYXZhaWxhYmxlLlxuaWYoc3JjQml0bWFzayZXUkFQX0JJTkRfRkxBRyl7ZGF0YVsyXT1zb3VyY2VbMl07Ly8gU2V0IHdoZW4gY3VycnlpbmcgYSBib3VuZCBmdW5jdGlvbi5cbm5ld0JpdG1hc2t8PWJpdG1hc2smV1JBUF9CSU5EX0ZMQUc/MDpXUkFQX0NVUlJZX0JPVU5EX0ZMQUc7fS8vIENvbXBvc2UgcGFydGlhbCBhcmd1bWVudHMuXG52YXIgdmFsdWU9c291cmNlWzNdO2lmKHZhbHVlKXt2YXIgcGFydGlhbHM9ZGF0YVszXTtkYXRhWzNdPXBhcnRpYWxzP2NvbXBvc2VBcmdzKHBhcnRpYWxzLHZhbHVlLHNvdXJjZVs0XSk6dmFsdWU7ZGF0YVs0XT1wYXJ0aWFscz9yZXBsYWNlSG9sZGVycyhkYXRhWzNdLFBMQUNFSE9MREVSKTpzb3VyY2VbNF07fS8vIENvbXBvc2UgcGFydGlhbCByaWdodCBhcmd1bWVudHMuXG52YWx1ZT1zb3VyY2VbNV07aWYodmFsdWUpe3BhcnRpYWxzPWRhdGFbNV07ZGF0YVs1XT1wYXJ0aWFscz9jb21wb3NlQXJnc1JpZ2h0KHBhcnRpYWxzLHZhbHVlLHNvdXJjZVs2XSk6dmFsdWU7ZGF0YVs2XT1wYXJ0aWFscz9yZXBsYWNlSG9sZGVycyhkYXRhWzVdLFBMQUNFSE9MREVSKTpzb3VyY2VbNl07fS8vIFVzZSBzb3VyY2UgYGFyZ1Bvc2AgaWYgYXZhaWxhYmxlLlxudmFsdWU9c291cmNlWzddO2lmKHZhbHVlKXtkYXRhWzddPXZhbHVlO30vLyBVc2Ugc291cmNlIGBhcnlgIGlmIGl0J3Mgc21hbGxlci5cbmlmKHNyY0JpdG1hc2smV1JBUF9BUllfRkxBRyl7ZGF0YVs4XT1kYXRhWzhdPT1udWxsP3NvdXJjZVs4XTpuYXRpdmVNaW4oZGF0YVs4XSxzb3VyY2VbOF0pO30vLyBVc2Ugc291cmNlIGBhcml0eWAgaWYgb25lIGlzIG5vdCBwcm92aWRlZC5cbmlmKGRhdGFbOV09PW51bGwpe2RhdGFbOV09c291cmNlWzldO30vLyBVc2Ugc291cmNlIGBmdW5jYCBhbmQgbWVyZ2UgYml0bWFza3MuXG5kYXRhWzBdPXNvdXJjZVswXTtkYXRhWzFdPW5ld0JpdG1hc2s7cmV0dXJuIGRhdGE7fS8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZVxuICAgICAqIFtgT2JqZWN0LmtleXNgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3Qua2V5cylcbiAgICAgKiBleGNlcHQgdGhhdCBpdCBpbmNsdWRlcyBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0aWVzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAgICAgKi9mdW5jdGlvbiBuYXRpdmVLZXlzSW4ob2JqZWN0KXt2YXIgcmVzdWx0PVtdO2lmKG9iamVjdCE9bnVsbCl7Zm9yKHZhciBrZXkgaW4gT2JqZWN0KG9iamVjdCkpe3Jlc3VsdC5wdXNoKGtleSk7fX1yZXR1cm4gcmVzdWx0O30vKipcbiAgICAgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nIHVzaW5nIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICAgICAqL2Z1bmN0aW9uIG9iamVjdFRvU3RyaW5nKHZhbHVlKXtyZXR1cm4gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7fS8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZVJlc3RgIHdoaWNoIHRyYW5zZm9ybXMgdGhlIHJlc3QgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD1mdW5jLmxlbmd0aC0xXSBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIHJlc3QgcGFyYW1ldGVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHRyYW5zZm9ybSBUaGUgcmVzdCBhcnJheSB0cmFuc2Zvcm0uXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICovZnVuY3Rpb24gb3ZlclJlc3QoZnVuYyxzdGFydCx0cmFuc2Zvcm0pe3N0YXJ0PW5hdGl2ZU1heChzdGFydD09PXVuZGVmaW5lZD9mdW5jLmxlbmd0aC0xOnN0YXJ0LDApO3JldHVybiBmdW5jdGlvbigpe3ZhciBhcmdzPWFyZ3VtZW50cyxpbmRleD0tMSxsZW5ndGg9bmF0aXZlTWF4KGFyZ3MubGVuZ3RoLXN0YXJ0LDApLGFycmF5PUFycmF5KGxlbmd0aCk7d2hpbGUoKytpbmRleDxsZW5ndGgpe2FycmF5W2luZGV4XT1hcmdzW3N0YXJ0K2luZGV4XTt9aW5kZXg9LTE7dmFyIG90aGVyQXJncz1BcnJheShzdGFydCsxKTt3aGlsZSgrK2luZGV4PHN0YXJ0KXtvdGhlckFyZ3NbaW5kZXhdPWFyZ3NbaW5kZXhdO31vdGhlckFyZ3Nbc3RhcnRdPXRyYW5zZm9ybShhcnJheSk7cmV0dXJuIGFwcGx5KGZ1bmMsdGhpcyxvdGhlckFyZ3MpO307fS8qKlxuICAgICAqIEdldHMgdGhlIHBhcmVudCB2YWx1ZSBhdCBgcGF0aGAgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwYXRoIFRoZSBwYXRoIHRvIGdldCB0aGUgcGFyZW50IHZhbHVlIG9mLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBwYXJlbnQgdmFsdWUuXG4gICAgICovZnVuY3Rpb24gcGFyZW50KG9iamVjdCxwYXRoKXtyZXR1cm4gcGF0aC5sZW5ndGg8Mj9vYmplY3Q6YmFzZUdldChvYmplY3QsYmFzZVNsaWNlKHBhdGgsMCwtMSkpO30vKipcbiAgICAgKiBSZW9yZGVyIGBhcnJheWAgYWNjb3JkaW5nIHRvIHRoZSBzcGVjaWZpZWQgaW5kZXhlcyB3aGVyZSB0aGUgZWxlbWVudCBhdFxuICAgICAqIHRoZSBmaXJzdCBpbmRleCBpcyBhc3NpZ25lZCBhcyB0aGUgZmlyc3QgZWxlbWVudCwgdGhlIGVsZW1lbnQgYXRcbiAgICAgKiB0aGUgc2Vjb25kIGluZGV4IGlzIGFzc2lnbmVkIGFzIHRoZSBzZWNvbmQgZWxlbWVudCwgYW5kIHNvIG9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcmVvcmRlci5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBpbmRleGVzIFRoZSBhcnJhbmdlZCBhcnJheSBpbmRleGVzLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqL2Z1bmN0aW9uIHJlb3JkZXIoYXJyYXksaW5kZXhlcyl7dmFyIGFyckxlbmd0aD1hcnJheS5sZW5ndGgsbGVuZ3RoPW5hdGl2ZU1pbihpbmRleGVzLmxlbmd0aCxhcnJMZW5ndGgpLG9sZEFycmF5PWNvcHlBcnJheShhcnJheSk7d2hpbGUobGVuZ3RoLS0pe3ZhciBpbmRleD1pbmRleGVzW2xlbmd0aF07YXJyYXlbbGVuZ3RoXT1pc0luZGV4KGluZGV4LGFyckxlbmd0aCk/b2xkQXJyYXlbaW5kZXhdOnVuZGVmaW5lZDt9cmV0dXJuIGFycmF5O30vKipcbiAgICAgKiBTZXRzIG1ldGFkYXRhIGZvciBgZnVuY2AuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogSWYgdGhpcyBmdW5jdGlvbiBiZWNvbWVzIGhvdCwgaS5lLiBpcyBpbnZva2VkIGEgbG90IGluIGEgc2hvcnRcbiAgICAgKiBwZXJpb2Qgb2YgdGltZSwgaXQgd2lsbCB0cmlwIGl0cyBicmVha2VyIGFuZCB0cmFuc2l0aW9uIHRvIGFuIGlkZW50aXR5XG4gICAgICogZnVuY3Rpb24gdG8gYXZvaWQgZ2FyYmFnZSBjb2xsZWN0aW9uIHBhdXNlcyBpbiBWOC4gU2VlXG4gICAgICogW1Y4IGlzc3VlIDIwNzBdKGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTIwNzApXG4gICAgICogZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXNzb2NpYXRlIG1ldGFkYXRhIHdpdGguXG4gICAgICogQHBhcmFtIHsqfSBkYXRhIFRoZSBtZXRhZGF0YS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGZ1bmNgLlxuICAgICAqL3ZhciBzZXREYXRhPXNob3J0T3V0KGJhc2VTZXREYXRhKTsvKipcbiAgICAgKiBBIHNpbXBsZSB3cmFwcGVyIGFyb3VuZCB0aGUgZ2xvYmFsIFtgc2V0VGltZW91dGBdKGh0dHBzOi8vbWRuLmlvL3NldFRpbWVvdXQpLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBkZWxheS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd2FpdCBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byBkZWxheSBpbnZvY2F0aW9uLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ8T2JqZWN0fSBSZXR1cm5zIHRoZSB0aW1lciBpZCBvciB0aW1lb3V0IG9iamVjdC5cbiAgICAgKi92YXIgc2V0VGltZW91dD1jdHhTZXRUaW1lb3V0fHxmdW5jdGlvbihmdW5jLHdhaXQpe3JldHVybiByb290LnNldFRpbWVvdXQoZnVuYyx3YWl0KTt9Oy8qKlxuICAgICAqIFNldHMgdGhlIGB0b1N0cmluZ2AgbWV0aG9kIG9mIGBmdW5jYCB0byByZXR1cm4gYHN0cmluZ2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdHJpbmcgVGhlIGB0b1N0cmluZ2AgcmVzdWx0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBgZnVuY2AuXG4gICAgICovdmFyIHNldFRvU3RyaW5nPXNob3J0T3V0KGJhc2VTZXRUb1N0cmluZyk7LyoqXG4gICAgICogU2V0cyB0aGUgYHRvU3RyaW5nYCBtZXRob2Qgb2YgYHdyYXBwZXJgIHRvIG1pbWljIHRoZSBzb3VyY2Ugb2YgYHJlZmVyZW5jZWBcbiAgICAgKiB3aXRoIHdyYXBwZXIgZGV0YWlscyBpbiBhIGNvbW1lbnQgYXQgdGhlIHRvcCBvZiB0aGUgc291cmNlIGJvZHkuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHdyYXBwZXIgVGhlIGZ1bmN0aW9uIHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSByZWZlcmVuY2UgVGhlIHJlZmVyZW5jZSBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBjcmVhdGVXcmFwYCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBgd3JhcHBlcmAuXG4gICAgICovZnVuY3Rpb24gc2V0V3JhcFRvU3RyaW5nKHdyYXBwZXIscmVmZXJlbmNlLGJpdG1hc2spe3ZhciBzb3VyY2U9cmVmZXJlbmNlKycnO3JldHVybiBzZXRUb1N0cmluZyh3cmFwcGVyLGluc2VydFdyYXBEZXRhaWxzKHNvdXJjZSx1cGRhdGVXcmFwRGV0YWlscyhnZXRXcmFwRGV0YWlscyhzb3VyY2UpLGJpdG1hc2spKSk7fS8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0J2xsIHNob3J0IG91dCBhbmQgaW52b2tlIGBpZGVudGl0eWAgaW5zdGVhZFxuICAgICAqIG9mIGBmdW5jYCB3aGVuIGl0J3MgY2FsbGVkIGBIT1RfQ09VTlRgIG9yIG1vcmUgdGltZXMgaW4gYEhPVF9TUEFOYFxuICAgICAqIG1pbGxpc2Vjb25kcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcmVzdHJpY3QuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc2hvcnRhYmxlIGZ1bmN0aW9uLlxuICAgICAqL2Z1bmN0aW9uIHNob3J0T3V0KGZ1bmMpe3ZhciBjb3VudD0wLGxhc3RDYWxsZWQ9MDtyZXR1cm4gZnVuY3Rpb24oKXt2YXIgc3RhbXA9bmF0aXZlTm93KCkscmVtYWluaW5nPUhPVF9TUEFOLShzdGFtcC1sYXN0Q2FsbGVkKTtsYXN0Q2FsbGVkPXN0YW1wO2lmKHJlbWFpbmluZz4wKXtpZigrK2NvdW50Pj1IT1RfQ09VTlQpe3JldHVybiBhcmd1bWVudHNbMF07fX1lbHNle2NvdW50PTA7fXJldHVybiBmdW5jLmFwcGx5KHVuZGVmaW5lZCxhcmd1bWVudHMpO307fS8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5zaHVmZmxlYCB3aGljaCBtdXRhdGVzIGFuZCBzZXRzIHRoZSBzaXplIG9mIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzaHVmZmxlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc2l6ZT1hcnJheS5sZW5ndGhdIFRoZSBzaXplIG9mIGBhcnJheWAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICovZnVuY3Rpb24gc2h1ZmZsZVNlbGYoYXJyYXksc2l6ZSl7dmFyIGluZGV4PS0xLGxlbmd0aD1hcnJheS5sZW5ndGgsbGFzdEluZGV4PWxlbmd0aC0xO3NpemU9c2l6ZT09PXVuZGVmaW5lZD9sZW5ndGg6c2l6ZTt3aGlsZSgrK2luZGV4PHNpemUpe3ZhciByYW5kPWJhc2VSYW5kb20oaW5kZXgsbGFzdEluZGV4KSx2YWx1ZT1hcnJheVtyYW5kXTthcnJheVtyYW5kXT1hcnJheVtpbmRleF07YXJyYXlbaW5kZXhdPXZhbHVlO31hcnJheS5sZW5ndGg9c2l6ZTtyZXR1cm4gYXJyYXk7fS8qKlxuICAgICAqIENvbnZlcnRzIGBzdHJpbmdgIHRvIGEgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICAgICAqL3ZhciBzdHJpbmdUb1BhdGg9bWVtb2l6ZUNhcHBlZChmdW5jdGlvbihzdHJpbmcpe3ZhciByZXN1bHQ9W107aWYocmVMZWFkaW5nRG90LnRlc3Qoc3RyaW5nKSl7cmVzdWx0LnB1c2goJycpO31zdHJpbmcucmVwbGFjZShyZVByb3BOYW1lLGZ1bmN0aW9uKG1hdGNoLG51bWJlcixxdW90ZSxzdHJpbmcpe3Jlc3VsdC5wdXNoKHF1b3RlP3N0cmluZy5yZXBsYWNlKHJlRXNjYXBlQ2hhciwnJDEnKTpudW1iZXJ8fG1hdGNoKTt9KTtyZXR1cm4gcmVzdWx0O30pOy8qKlxuICAgICAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcga2V5IGlmIGl0J3Mgbm90IGEgc3RyaW5nIG9yIHN5bWJvbC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfHN5bWJvbH0gUmV0dXJucyB0aGUga2V5LlxuICAgICAqL2Z1bmN0aW9uIHRvS2V5KHZhbHVlKXtpZih0eXBlb2YgdmFsdWU9PSdzdHJpbmcnfHxpc1N5bWJvbCh2YWx1ZSkpe3JldHVybiB2YWx1ZTt9dmFyIHJlc3VsdD12YWx1ZSsnJztyZXR1cm4gcmVzdWx0PT0nMCcmJjEvdmFsdWU9PS1JTkZJTklUWT8nLTAnOnJlc3VsdDt9LyoqXG4gICAgICogQ29udmVydHMgYGZ1bmNgIHRvIGl0cyBzb3VyY2UgY29kZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzb3VyY2UgY29kZS5cbiAgICAgKi9mdW5jdGlvbiB0b1NvdXJjZShmdW5jKXtpZihmdW5jIT1udWxsKXt0cnl7cmV0dXJuIGZ1bmNUb1N0cmluZy5jYWxsKGZ1bmMpO31jYXRjaChlKXt9dHJ5e3JldHVybiBmdW5jKycnO31jYXRjaChlKXt9fXJldHVybicnO30vKipcbiAgICAgKiBVcGRhdGVzIHdyYXBwZXIgYGRldGFpbHNgIGJhc2VkIG9uIGBiaXRtYXNrYCBmbGFncy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybnMge0FycmF5fSBkZXRhaWxzIFRoZSBkZXRhaWxzIHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBjcmVhdGVXcmFwYCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgZGV0YWlsc2AuXG4gICAgICovZnVuY3Rpb24gdXBkYXRlV3JhcERldGFpbHMoZGV0YWlscyxiaXRtYXNrKXthcnJheUVhY2god3JhcEZsYWdzLGZ1bmN0aW9uKHBhaXIpe3ZhciB2YWx1ZT0nXy4nK3BhaXJbMF07aWYoYml0bWFzayZwYWlyWzFdJiYhYXJyYXlJbmNsdWRlcyhkZXRhaWxzLHZhbHVlKSl7ZGV0YWlscy5wdXNoKHZhbHVlKTt9fSk7cmV0dXJuIGRldGFpbHMuc29ydCgpO30vKipcbiAgICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgYHdyYXBwZXJgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gd3JhcHBlciBUaGUgd3JhcHBlciB0byBjbG9uZS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgd3JhcHBlci5cbiAgICAgKi9mdW5jdGlvbiB3cmFwcGVyQ2xvbmUod3JhcHBlcil7aWYod3JhcHBlciBpbnN0YW5jZW9mIExhenlXcmFwcGVyKXtyZXR1cm4gd3JhcHBlci5jbG9uZSgpO312YXIgcmVzdWx0PW5ldyBMb2Rhc2hXcmFwcGVyKHdyYXBwZXIuX193cmFwcGVkX18sd3JhcHBlci5fX2NoYWluX18pO3Jlc3VsdC5fX2FjdGlvbnNfXz1jb3B5QXJyYXkod3JhcHBlci5fX2FjdGlvbnNfXyk7cmVzdWx0Ll9faW5kZXhfXz13cmFwcGVyLl9faW5kZXhfXztyZXN1bHQuX192YWx1ZXNfXz13cmFwcGVyLl9fdmFsdWVzX187cmV0dXJuIHJlc3VsdDt9LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qLy8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgZWxlbWVudHMgc3BsaXQgaW50byBncm91cHMgdGhlIGxlbmd0aCBvZiBgc2l6ZWAuXG4gICAgICogSWYgYGFycmF5YCBjYW4ndCBiZSBzcGxpdCBldmVubHksIHRoZSBmaW5hbCBjaHVuayB3aWxsIGJlIHRoZSByZW1haW5pbmdcbiAgICAgKiBlbGVtZW50cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBwcm9jZXNzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc2l6ZT0xXSBUaGUgbGVuZ3RoIG9mIGVhY2ggY2h1bmtcbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGNodW5rcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5jaHVuayhbJ2EnLCAnYicsICdjJywgJ2QnXSwgMik7XG4gICAgICogLy8gPT4gW1snYScsICdiJ10sIFsnYycsICdkJ11dXG4gICAgICpcbiAgICAgKiBfLmNodW5rKFsnYScsICdiJywgJ2MnLCAnZCddLCAzKTtcbiAgICAgKiAvLyA9PiBbWydhJywgJ2InLCAnYyddLCBbJ2QnXV1cbiAgICAgKi9mdW5jdGlvbiBjaHVuayhhcnJheSxzaXplLGd1YXJkKXtpZihndWFyZD9pc0l0ZXJhdGVlQ2FsbChhcnJheSxzaXplLGd1YXJkKTpzaXplPT09dW5kZWZpbmVkKXtzaXplPTE7fWVsc2V7c2l6ZT1uYXRpdmVNYXgodG9JbnRlZ2VyKHNpemUpLDApO312YXIgbGVuZ3RoPWFycmF5PT1udWxsPzA6YXJyYXkubGVuZ3RoO2lmKCFsZW5ndGh8fHNpemU8MSl7cmV0dXJuW107fXZhciBpbmRleD0wLHJlc0luZGV4PTAscmVzdWx0PUFycmF5KG5hdGl2ZUNlaWwobGVuZ3RoL3NpemUpKTt3aGlsZShpbmRleDxsZW5ndGgpe3Jlc3VsdFtyZXNJbmRleCsrXT1iYXNlU2xpY2UoYXJyYXksaW5kZXgsaW5kZXgrPXNpemUpO31yZXR1cm4gcmVzdWx0O30vKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IHdpdGggYWxsIGZhbHNleSB2YWx1ZXMgcmVtb3ZlZC4gVGhlIHZhbHVlcyBgZmFsc2VgLCBgbnVsbGAsXG4gICAgICogYDBgLCBgXCJcImAsIGB1bmRlZmluZWRgLCBhbmQgYE5hTmAgYXJlIGZhbHNleS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBjb21wYWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5jb21wYWN0KFswLCAxLCBmYWxzZSwgMiwgJycsIDNdKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKi9mdW5jdGlvbiBjb21wYWN0KGFycmF5KXt2YXIgaW5kZXg9LTEsbGVuZ3RoPWFycmF5PT1udWxsPzA6YXJyYXkubGVuZ3RoLHJlc0luZGV4PTAscmVzdWx0PVtdO3doaWxlKCsraW5kZXg8bGVuZ3RoKXt2YXIgdmFsdWU9YXJyYXlbaW5kZXhdO2lmKHZhbHVlKXtyZXN1bHRbcmVzSW5kZXgrK109dmFsdWU7fX1yZXR1cm4gcmVzdWx0O30vKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGFycmF5IGNvbmNhdGVuYXRpbmcgYGFycmF5YCB3aXRoIGFueSBhZGRpdGlvbmFsIGFycmF5c1xuICAgICAqIGFuZC9vciB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gY29uY2F0ZW5hdGUuXG4gICAgICogQHBhcmFtIHsuLi4qfSBbdmFsdWVzXSBUaGUgdmFsdWVzIHRvIGNvbmNhdGVuYXRlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGNvbmNhdGVuYXRlZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWzFdO1xuICAgICAqIHZhciBvdGhlciA9IF8uY29uY2F0KGFycmF5LCAyLCBbM10sIFtbNF1dKTtcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKG90aGVyKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgMywgWzRdXVxuICAgICAqXG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFsxXVxuICAgICAqL2Z1bmN0aW9uIGNvbmNhdCgpe3ZhciBsZW5ndGg9YXJndW1lbnRzLmxlbmd0aDtpZighbGVuZ3RoKXtyZXR1cm5bXTt9dmFyIGFyZ3M9QXJyYXkobGVuZ3RoLTEpLGFycmF5PWFyZ3VtZW50c1swXSxpbmRleD1sZW5ndGg7d2hpbGUoaW5kZXgtLSl7YXJnc1tpbmRleC0xXT1hcmd1bWVudHNbaW5kZXhdO31yZXR1cm4gYXJyYXlQdXNoKGlzQXJyYXkoYXJyYXkpP2NvcHlBcnJheShhcnJheSk6W2FycmF5XSxiYXNlRmxhdHRlbihhcmdzLDEpKTt9LyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBgYXJyYXlgIHZhbHVlcyBub3QgaW5jbHVkZWQgaW4gdGhlIG90aGVyIGdpdmVuIGFycmF5c1xuICAgICAqIHVzaW5nIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gICAgICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLiBUaGUgb3JkZXIgYW5kIHJlZmVyZW5jZXMgb2YgcmVzdWx0IHZhbHVlcyBhcmVcbiAgICAgKiBkZXRlcm1pbmVkIGJ5IHRoZSBmaXJzdCBhcnJheS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBVbmxpa2UgYF8ucHVsbEFsbGAsIHRoaXMgbWV0aG9kIHJldHVybnMgYSBuZXcgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbdmFsdWVzXSBUaGUgdmFsdWVzIHRvIGV4Y2x1ZGUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgZmlsdGVyZWQgdmFsdWVzLlxuICAgICAqIEBzZWUgXy53aXRob3V0LCBfLnhvclxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRpZmZlcmVuY2UoWzIsIDFdLCBbMiwgM10pO1xuICAgICAqIC8vID0+IFsxXVxuICAgICAqL3ZhciBkaWZmZXJlbmNlPWJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5LHZhbHVlcyl7cmV0dXJuIGlzQXJyYXlMaWtlT2JqZWN0KGFycmF5KT9iYXNlRGlmZmVyZW5jZShhcnJheSxiYXNlRmxhdHRlbih2YWx1ZXMsMSxpc0FycmF5TGlrZU9iamVjdCx0cnVlKSk6W107fSk7LyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5kaWZmZXJlbmNlYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBpdGVyYXRlZWAgd2hpY2hcbiAgICAgKiBpcyBpbnZva2VkIGZvciBlYWNoIGVsZW1lbnQgb2YgYGFycmF5YCBhbmQgYHZhbHVlc2AgdG8gZ2VuZXJhdGUgdGhlIGNyaXRlcmlvblxuICAgICAqIGJ5IHdoaWNoIHRoZXkncmUgY29tcGFyZWQuIFRoZSBvcmRlciBhbmQgcmVmZXJlbmNlcyBvZiByZXN1bHQgdmFsdWVzIGFyZVxuICAgICAqIGRldGVybWluZWQgYnkgdGhlIGZpcnN0IGFycmF5LiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDpcbiAgICAgKiAodmFsdWUpLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFVubGlrZSBgXy5wdWxsQWxsQnlgLCB0aGlzIG1ldGhvZCByZXR1cm5zIGEgbmV3IGFycmF5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW3ZhbHVlc10gVGhlIHZhbHVlcyB0byBleGNsdWRlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBmaWx0ZXJlZCB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZGlmZmVyZW5jZUJ5KFsyLjEsIDEuMl0sIFsyLjMsIDMuNF0sIE1hdGguZmxvb3IpO1xuICAgICAqIC8vID0+IFsxLjJdXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmRpZmZlcmVuY2VCeShbeyAneCc6IDIgfSwgeyAneCc6IDEgfV0sIFt7ICd4JzogMSB9XSwgJ3gnKTtcbiAgICAgKiAvLyA9PiBbeyAneCc6IDIgfV1cbiAgICAgKi92YXIgZGlmZmVyZW5jZUJ5PWJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5LHZhbHVlcyl7dmFyIGl0ZXJhdGVlPWxhc3QodmFsdWVzKTtpZihpc0FycmF5TGlrZU9iamVjdChpdGVyYXRlZSkpe2l0ZXJhdGVlPXVuZGVmaW5lZDt9cmV0dXJuIGlzQXJyYXlMaWtlT2JqZWN0KGFycmF5KT9iYXNlRGlmZmVyZW5jZShhcnJheSxiYXNlRmxhdHRlbih2YWx1ZXMsMSxpc0FycmF5TGlrZU9iamVjdCx0cnVlKSxnZXRJdGVyYXRlZShpdGVyYXRlZSwyKSk6W107fSk7LyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5kaWZmZXJlbmNlYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjb21wYXJhdG9yYFxuICAgICAqIHdoaWNoIGlzIGludm9rZWQgdG8gY29tcGFyZSBlbGVtZW50cyBvZiBgYXJyYXlgIHRvIGB2YWx1ZXNgLiBUaGUgb3JkZXIgYW5kXG4gICAgICogcmVmZXJlbmNlcyBvZiByZXN1bHQgdmFsdWVzIGFyZSBkZXRlcm1pbmVkIGJ5IHRoZSBmaXJzdCBhcnJheS4gVGhlIGNvbXBhcmF0b3JcbiAgICAgKiBpcyBpbnZva2VkIHdpdGggdHdvIGFyZ3VtZW50czogKGFyclZhbCwgb3RoVmFsKS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBVbmxpa2UgYF8ucHVsbEFsbFdpdGhgLCB0aGlzIG1ldGhvZCByZXR1cm5zIGEgbmV3IGFycmF5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW3ZhbHVlc10gVGhlIHZhbHVlcyB0byBleGNsdWRlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJhdG9yXSBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbeyAneCc6IDEsICd5JzogMiB9LCB7ICd4JzogMiwgJ3knOiAxIH1dO1xuICAgICAqXG4gICAgICogXy5kaWZmZXJlbmNlV2l0aChvYmplY3RzLCBbeyAneCc6IDEsICd5JzogMiB9XSwgXy5pc0VxdWFsKTtcbiAgICAgKiAvLyA9PiBbeyAneCc6IDIsICd5JzogMSB9XVxuICAgICAqL3ZhciBkaWZmZXJlbmNlV2l0aD1iYXNlUmVzdChmdW5jdGlvbihhcnJheSx2YWx1ZXMpe3ZhciBjb21wYXJhdG9yPWxhc3QodmFsdWVzKTtpZihpc0FycmF5TGlrZU9iamVjdChjb21wYXJhdG9yKSl7Y29tcGFyYXRvcj11bmRlZmluZWQ7fXJldHVybiBpc0FycmF5TGlrZU9iamVjdChhcnJheSk/YmFzZURpZmZlcmVuY2UoYXJyYXksYmFzZUZsYXR0ZW4odmFsdWVzLDEsaXNBcnJheUxpa2VPYmplY3QsdHJ1ZSksdW5kZWZpbmVkLGNvbXBhcmF0b3IpOltdO30pOy8qKlxuICAgICAqIENyZWF0ZXMgYSBzbGljZSBvZiBgYXJyYXlgIHdpdGggYG5gIGVsZW1lbnRzIGRyb3BwZWQgZnJvbSB0aGUgYmVnaW5uaW5nLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuNS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbj0xXSBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIGRyb3AuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZHJvcChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IFsyLCAzXVxuICAgICAqXG4gICAgICogXy5kcm9wKFsxLCAyLCAzXSwgMik7XG4gICAgICogLy8gPT4gWzNdXG4gICAgICpcbiAgICAgKiBfLmRyb3AoWzEsIDIsIDNdLCA1KTtcbiAgICAgKiAvLyA9PiBbXVxuICAgICAqXG4gICAgICogXy5kcm9wKFsxLCAyLCAzXSwgMCk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICovZnVuY3Rpb24gZHJvcChhcnJheSxuLGd1YXJkKXt2YXIgbGVuZ3RoPWFycmF5PT1udWxsPzA6YXJyYXkubGVuZ3RoO2lmKCFsZW5ndGgpe3JldHVybltdO31uPWd1YXJkfHxuPT09dW5kZWZpbmVkPzE6dG9JbnRlZ2VyKG4pO3JldHVybiBiYXNlU2xpY2UoYXJyYXksbjwwPzA6bixsZW5ndGgpO30vKipcbiAgICAgKiBDcmVhdGVzIGEgc2xpY2Ugb2YgYGFycmF5YCB3aXRoIGBuYCBlbGVtZW50cyBkcm9wcGVkIGZyb20gdGhlIGVuZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW249MV0gVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byBkcm9wLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRyb3BSaWdodChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IFsxLCAyXVxuICAgICAqXG4gICAgICogXy5kcm9wUmlnaHQoWzEsIDIsIDNdLCAyKTtcbiAgICAgKiAvLyA9PiBbMV1cbiAgICAgKlxuICAgICAqIF8uZHJvcFJpZ2h0KFsxLCAyLCAzXSwgNSk7XG4gICAgICogLy8gPT4gW11cbiAgICAgKlxuICAgICAqIF8uZHJvcFJpZ2h0KFsxLCAyLCAzXSwgMCk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICovZnVuY3Rpb24gZHJvcFJpZ2h0KGFycmF5LG4sZ3VhcmQpe3ZhciBsZW5ndGg9YXJyYXk9PW51bGw/MDphcnJheS5sZW5ndGg7aWYoIWxlbmd0aCl7cmV0dXJuW107fW49Z3VhcmR8fG49PT11bmRlZmluZWQ/MTp0b0ludGVnZXIobik7bj1sZW5ndGgtbjtyZXR1cm4gYmFzZVNsaWNlKGFycmF5LDAsbjwwPzA6bik7fS8qKlxuICAgICAqIENyZWF0ZXMgYSBzbGljZSBvZiBgYXJyYXlgIGV4Y2x1ZGluZyBlbGVtZW50cyBkcm9wcGVkIGZyb20gdGhlIGVuZC5cbiAgICAgKiBFbGVtZW50cyBhcmUgZHJvcHBlZCB1bnRpbCBgcHJlZGljYXRlYCByZXR1cm5zIGZhbHNleS4gVGhlIHByZWRpY2F0ZSBpc1xuICAgICAqIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXgsIGFycmF5KS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICAnYWN0aXZlJzogdHJ1ZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWN0aXZlJzogZmFsc2UgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLmRyb3BSaWdodFdoaWxlKHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiAhby5hY3RpdmU7IH0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnYmFybmV5J11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5kcm9wUmlnaHRXaGlsZSh1c2VycywgeyAndXNlcic6ICdwZWJibGVzJywgJ2FjdGl2ZSc6IGZhbHNlIH0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnYmFybmV5JywgJ2ZyZWQnXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZHJvcFJpZ2h0V2hpbGUodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2Jhcm5leSddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmRyb3BSaWdodFdoaWxlKHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydiYXJuZXknLCAnZnJlZCcsICdwZWJibGVzJ11cbiAgICAgKi9mdW5jdGlvbiBkcm9wUmlnaHRXaGlsZShhcnJheSxwcmVkaWNhdGUpe3JldHVybiBhcnJheSYmYXJyYXkubGVuZ3RoP2Jhc2VXaGlsZShhcnJheSxnZXRJdGVyYXRlZShwcmVkaWNhdGUsMyksdHJ1ZSx0cnVlKTpbXTt9LyoqXG4gICAgICogQ3JlYXRlcyBhIHNsaWNlIG9mIGBhcnJheWAgZXhjbHVkaW5nIGVsZW1lbnRzIGRyb3BwZWQgZnJvbSB0aGUgYmVnaW5uaW5nLlxuICAgICAqIEVsZW1lbnRzIGFyZSBkcm9wcGVkIHVudGlsIGBwcmVkaWNhdGVgIHJldHVybnMgZmFsc2V5LiBUaGUgcHJlZGljYXRlIGlzXG4gICAgICogaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleCwgYXJyYXkpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWN0aXZlJzogdHJ1ZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8uZHJvcFdoaWxlKHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiAhby5hY3RpdmU7IH0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsncGViYmxlcyddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZHJvcFdoaWxlKHVzZXJzLCB7ICd1c2VyJzogJ2Jhcm5leScsICdhY3RpdmUnOiBmYWxzZSB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2ZyZWQnLCAncGViYmxlcyddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5kcm9wV2hpbGUodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ3BlYmJsZXMnXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5kcm9wV2hpbGUodXNlcnMsICdhY3RpdmUnKTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2Jhcm5leScsICdmcmVkJywgJ3BlYmJsZXMnXVxuICAgICAqL2Z1bmN0aW9uIGRyb3BXaGlsZShhcnJheSxwcmVkaWNhdGUpe3JldHVybiBhcnJheSYmYXJyYXkubGVuZ3RoP2Jhc2VXaGlsZShhcnJheSxnZXRJdGVyYXRlZShwcmVkaWNhdGUsMyksdHJ1ZSk6W107fS8qKlxuICAgICAqIEZpbGxzIGVsZW1lbnRzIG9mIGBhcnJheWAgd2l0aCBgdmFsdWVgIGZyb20gYHN0YXJ0YCB1cCB0bywgYnV0IG5vdFxuICAgICAqIGluY2x1ZGluZywgYGVuZGAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMi4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZpbGwuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gZmlsbCBgYXJyYXlgIHdpdGguXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD0wXSBUaGUgc3RhcnQgcG9zaXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtlbmQ9YXJyYXkubGVuZ3RoXSBUaGUgZW5kIHBvc2l0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbMSwgMiwgM107XG4gICAgICpcbiAgICAgKiBfLmZpbGwoYXJyYXksICdhJyk7XG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFsnYScsICdhJywgJ2EnXVxuICAgICAqXG4gICAgICogXy5maWxsKEFycmF5KDMpLCAyKTtcbiAgICAgKiAvLyA9PiBbMiwgMiwgMl1cbiAgICAgKlxuICAgICAqIF8uZmlsbChbNCwgNiwgOCwgMTBdLCAnKicsIDEsIDMpO1xuICAgICAqIC8vID0+IFs0LCAnKicsICcqJywgMTBdXG4gICAgICovZnVuY3Rpb24gZmlsbChhcnJheSx2YWx1ZSxzdGFydCxlbmQpe3ZhciBsZW5ndGg9YXJyYXk9PW51bGw/MDphcnJheS5sZW5ndGg7aWYoIWxlbmd0aCl7cmV0dXJuW107fWlmKHN0YXJ0JiZ0eXBlb2Ygc3RhcnQhPSdudW1iZXInJiZpc0l0ZXJhdGVlQ2FsbChhcnJheSx2YWx1ZSxzdGFydCkpe3N0YXJ0PTA7ZW5kPWxlbmd0aDt9cmV0dXJuIGJhc2VGaWxsKGFycmF5LHZhbHVlLHN0YXJ0LGVuZCk7fS8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZmluZGAgZXhjZXB0IHRoYXQgaXQgcmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGZpcnN0XG4gICAgICogZWxlbWVudCBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3IgaW5zdGVhZCBvZiB0aGUgZWxlbWVudCBpdHNlbGYuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMS4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtmcm9tSW5kZXg9MF0gVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBmb3VuZCBlbGVtZW50LCBlbHNlIGAtMWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWN0aXZlJzogdHJ1ZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8uZmluZEluZGV4KHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLnVzZXIgPT0gJ2Jhcm5leSc7IH0pO1xuICAgICAqIC8vID0+IDBcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maW5kSW5kZXgodXNlcnMsIHsgJ3VzZXInOiAnZnJlZCcsICdhY3RpdmUnOiBmYWxzZSB9KTtcbiAgICAgKiAvLyA9PiAxXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maW5kSW5kZXgodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiAwXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbmRJbmRleCh1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+IDJcbiAgICAgKi9mdW5jdGlvbiBmaW5kSW5kZXgoYXJyYXkscHJlZGljYXRlLGZyb21JbmRleCl7dmFyIGxlbmd0aD1hcnJheT09bnVsbD8wOmFycmF5Lmxlbmd0aDtpZighbGVuZ3RoKXtyZXR1cm4tMTt9dmFyIGluZGV4PWZyb21JbmRleD09bnVsbD8wOnRvSW50ZWdlcihmcm9tSW5kZXgpO2lmKGluZGV4PDApe2luZGV4PW5hdGl2ZU1heChsZW5ndGgraW5kZXgsMCk7fXJldHVybiBiYXNlRmluZEluZGV4KGFycmF5LGdldEl0ZXJhdGVlKHByZWRpY2F0ZSwzKSxpbmRleCk7fS8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZmluZEluZGV4YCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIGVsZW1lbnRzXG4gICAgICogb2YgYGNvbGxlY3Rpb25gIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2Zyb21JbmRleD1hcnJheS5sZW5ndGgtMV0gVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBmb3VuZCBlbGVtZW50LCBlbHNlIGAtMWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgICdhY3RpdmUnOiB0cnVlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAncGViYmxlcycsICdhY3RpdmUnOiBmYWxzZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8uZmluZExhc3RJbmRleCh1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gby51c2VyID09ICdwZWJibGVzJzsgfSk7XG4gICAgICogLy8gPT4gMlxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbmRMYXN0SW5kZXgodXNlcnMsIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FjdGl2ZSc6IHRydWUgfSk7XG4gICAgICogLy8gPT4gMFxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmluZExhc3RJbmRleCh1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICAgICAqIC8vID0+IDJcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmluZExhc3RJbmRleCh1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+IDBcbiAgICAgKi9mdW5jdGlvbiBmaW5kTGFzdEluZGV4KGFycmF5LHByZWRpY2F0ZSxmcm9tSW5kZXgpe3ZhciBsZW5ndGg9YXJyYXk9PW51bGw/MDphcnJheS5sZW5ndGg7aWYoIWxlbmd0aCl7cmV0dXJuLTE7fXZhciBpbmRleD1sZW5ndGgtMTtpZihmcm9tSW5kZXghPT11bmRlZmluZWQpe2luZGV4PXRvSW50ZWdlcihmcm9tSW5kZXgpO2luZGV4PWZyb21JbmRleDwwP25hdGl2ZU1heChsZW5ndGgraW5kZXgsMCk6bmF0aXZlTWluKGluZGV4LGxlbmd0aC0xKTt9cmV0dXJuIGJhc2VGaW5kSW5kZXgoYXJyYXksZ2V0SXRlcmF0ZWUocHJlZGljYXRlLDMpLGluZGV4LHRydWUpO30vKipcbiAgICAgKiBGbGF0dGVucyBgYXJyYXlgIGEgc2luZ2xlIGxldmVsIGRlZXAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gZmxhdHRlbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmbGF0dGVuZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZmxhdHRlbihbMSwgWzIsIFszLCBbNF1dLCA1XV0pO1xuICAgICAqIC8vID0+IFsxLCAyLCBbMywgWzRdXSwgNV1cbiAgICAgKi9mdW5jdGlvbiBmbGF0dGVuKGFycmF5KXt2YXIgbGVuZ3RoPWFycmF5PT1udWxsPzA6YXJyYXkubGVuZ3RoO3JldHVybiBsZW5ndGg/YmFzZUZsYXR0ZW4oYXJyYXksMSk6W107fS8qKlxuICAgICAqIFJlY3Vyc2l2ZWx5IGZsYXR0ZW5zIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gZmxhdHRlbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmbGF0dGVuZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZmxhdHRlbkRlZXAoWzEsIFsyLCBbMywgWzRdXSwgNV1dKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgMywgNCwgNV1cbiAgICAgKi9mdW5jdGlvbiBmbGF0dGVuRGVlcChhcnJheSl7dmFyIGxlbmd0aD1hcnJheT09bnVsbD8wOmFycmF5Lmxlbmd0aDtyZXR1cm4gbGVuZ3RoP2Jhc2VGbGF0dGVuKGFycmF5LElORklOSVRZKTpbXTt9LyoqXG4gICAgICogUmVjdXJzaXZlbHkgZmxhdHRlbiBgYXJyYXlgIHVwIHRvIGBkZXB0aGAgdGltZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC40LjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gZmxhdHRlbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2RlcHRoPTFdIFRoZSBtYXhpbXVtIHJlY3Vyc2lvbiBkZXB0aC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmbGF0dGVuZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFsxLCBbMiwgWzMsIFs0XV0sIDVdXTtcbiAgICAgKlxuICAgICAqIF8uZmxhdHRlbkRlcHRoKGFycmF5LCAxKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgWzMsIFs0XV0sIDVdXG4gICAgICpcbiAgICAgKiBfLmZsYXR0ZW5EZXB0aChhcnJheSwgMik7XG4gICAgICogLy8gPT4gWzEsIDIsIDMsIFs0XSwgNV1cbiAgICAgKi9mdW5jdGlvbiBmbGF0dGVuRGVwdGgoYXJyYXksZGVwdGgpe3ZhciBsZW5ndGg9YXJyYXk9PW51bGw/MDphcnJheS5sZW5ndGg7aWYoIWxlbmd0aCl7cmV0dXJuW107fWRlcHRoPWRlcHRoPT09dW5kZWZpbmVkPzE6dG9JbnRlZ2VyKGRlcHRoKTtyZXR1cm4gYmFzZUZsYXR0ZW4oYXJyYXksZGVwdGgpO30vKipcbiAgICAgKiBUaGUgaW52ZXJzZSBvZiBgXy50b1BhaXJzYDsgdGhpcyBtZXRob2QgcmV0dXJucyBhbiBvYmplY3QgY29tcG9zZWRcbiAgICAgKiBmcm9tIGtleS12YWx1ZSBgcGFpcnNgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gcGFpcnMgVGhlIGtleS12YWx1ZSBwYWlycy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmZyb21QYWlycyhbWydhJywgMV0sIFsnYicsIDJdXSk7XG4gICAgICogLy8gPT4geyAnYSc6IDEsICdiJzogMiB9XG4gICAgICovZnVuY3Rpb24gZnJvbVBhaXJzKHBhaXJzKXt2YXIgaW5kZXg9LTEsbGVuZ3RoPXBhaXJzPT1udWxsPzA6cGFpcnMubGVuZ3RoLHJlc3VsdD17fTt3aGlsZSgrK2luZGV4PGxlbmd0aCl7dmFyIHBhaXI9cGFpcnNbaW5kZXhdO3Jlc3VsdFtwYWlyWzBdXT1wYWlyWzFdO31yZXR1cm4gcmVzdWx0O30vKipcbiAgICAgKiBHZXRzIHRoZSBmaXJzdCBlbGVtZW50IG9mIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAYWxpYXMgZmlyc3RcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5oZWFkKFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gMVxuICAgICAqXG4gICAgICogXy5oZWFkKFtdKTtcbiAgICAgKiAvLyA9PiB1bmRlZmluZWRcbiAgICAgKi9mdW5jdGlvbiBoZWFkKGFycmF5KXtyZXR1cm4gYXJyYXkmJmFycmF5Lmxlbmd0aD9hcnJheVswXTp1bmRlZmluZWQ7fS8qKlxuICAgICAqIEdldHMgdGhlIGluZGV4IGF0IHdoaWNoIHRoZSBmaXJzdCBvY2N1cnJlbmNlIG9mIGB2YWx1ZWAgaXMgZm91bmQgaW4gYGFycmF5YFxuICAgICAqIHVzaW5nIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gICAgICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLiBJZiBgZnJvbUluZGV4YCBpcyBuZWdhdGl2ZSwgaXQncyB1c2VkIGFzIHRoZVxuICAgICAqIG9mZnNldCBmcm9tIHRoZSBlbmQgb2YgYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtmcm9tSW5kZXg9MF0gVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaW5kZXhPZihbMSwgMiwgMSwgMl0sIDIpO1xuICAgICAqIC8vID0+IDFcbiAgICAgKlxuICAgICAqIC8vIFNlYXJjaCBmcm9tIHRoZSBgZnJvbUluZGV4YC5cbiAgICAgKiBfLmluZGV4T2YoWzEsIDIsIDEsIDJdLCAyLCAyKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICovZnVuY3Rpb24gaW5kZXhPZihhcnJheSx2YWx1ZSxmcm9tSW5kZXgpe3ZhciBsZW5ndGg9YXJyYXk9PW51bGw/MDphcnJheS5sZW5ndGg7aWYoIWxlbmd0aCl7cmV0dXJuLTE7fXZhciBpbmRleD1mcm9tSW5kZXg9PW51bGw/MDp0b0ludGVnZXIoZnJvbUluZGV4KTtpZihpbmRleDwwKXtpbmRleD1uYXRpdmVNYXgobGVuZ3RoK2luZGV4LDApO31yZXR1cm4gYmFzZUluZGV4T2YoYXJyYXksdmFsdWUsaW5kZXgpO30vKipcbiAgICAgKiBHZXRzIGFsbCBidXQgdGhlIGxhc3QgZWxlbWVudCBvZiBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pbml0aWFsKFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gWzEsIDJdXG4gICAgICovZnVuY3Rpb24gaW5pdGlhbChhcnJheSl7dmFyIGxlbmd0aD1hcnJheT09bnVsbD8wOmFycmF5Lmxlbmd0aDtyZXR1cm4gbGVuZ3RoP2Jhc2VTbGljZShhcnJheSwwLC0xKTpbXTt9LyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB1bmlxdWUgdmFsdWVzIHRoYXQgYXJlIGluY2x1ZGVkIGluIGFsbCBnaXZlbiBhcnJheXNcbiAgICAgKiB1c2luZyBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICAgICAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy4gVGhlIG9yZGVyIGFuZCByZWZlcmVuY2VzIG9mIHJlc3VsdCB2YWx1ZXMgYXJlXG4gICAgICogZGV0ZXJtaW5lZCBieSB0aGUgZmlyc3QgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXlzXSBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgaW50ZXJzZWN0aW5nIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pbnRlcnNlY3Rpb24oWzIsIDFdLCBbMiwgM10pO1xuICAgICAqIC8vID0+IFsyXVxuICAgICAqL3ZhciBpbnRlcnNlY3Rpb249YmFzZVJlc3QoZnVuY3Rpb24oYXJyYXlzKXt2YXIgbWFwcGVkPWFycmF5TWFwKGFycmF5cyxjYXN0QXJyYXlMaWtlT2JqZWN0KTtyZXR1cm4gbWFwcGVkLmxlbmd0aCYmbWFwcGVkWzBdPT09YXJyYXlzWzBdP2Jhc2VJbnRlcnNlY3Rpb24obWFwcGVkKTpbXTt9KTsvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmludGVyc2VjdGlvbmAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgXG4gICAgICogd2hpY2ggaXMgaW52b2tlZCBmb3IgZWFjaCBlbGVtZW50IG9mIGVhY2ggYGFycmF5c2AgdG8gZ2VuZXJhdGUgdGhlIGNyaXRlcmlvblxuICAgICAqIGJ5IHdoaWNoIHRoZXkncmUgY29tcGFyZWQuIFRoZSBvcmRlciBhbmQgcmVmZXJlbmNlcyBvZiByZXN1bHQgdmFsdWVzIGFyZVxuICAgICAqIGRldGVybWluZWQgYnkgdGhlIGZpcnN0IGFycmF5LiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDpcbiAgICAgKiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5c10gVGhlIGFycmF5cyB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBpbnRlcnNlY3RpbmcgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmludGVyc2VjdGlvbkJ5KFsyLjEsIDEuMl0sIFsyLjMsIDMuNF0sIE1hdGguZmxvb3IpO1xuICAgICAqIC8vID0+IFsyLjFdXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmludGVyc2VjdGlvbkJ5KFt7ICd4JzogMSB9XSwgW3sgJ3gnOiAyIH0sIHsgJ3gnOiAxIH1dLCAneCcpO1xuICAgICAqIC8vID0+IFt7ICd4JzogMSB9XVxuICAgICAqL3ZhciBpbnRlcnNlY3Rpb25CeT1iYXNlUmVzdChmdW5jdGlvbihhcnJheXMpe3ZhciBpdGVyYXRlZT1sYXN0KGFycmF5cyksbWFwcGVkPWFycmF5TWFwKGFycmF5cyxjYXN0QXJyYXlMaWtlT2JqZWN0KTtpZihpdGVyYXRlZT09PWxhc3QobWFwcGVkKSl7aXRlcmF0ZWU9dW5kZWZpbmVkO31lbHNle21hcHBlZC5wb3AoKTt9cmV0dXJuIG1hcHBlZC5sZW5ndGgmJm1hcHBlZFswXT09PWFycmF5c1swXT9iYXNlSW50ZXJzZWN0aW9uKG1hcHBlZCxnZXRJdGVyYXRlZShpdGVyYXRlZSwyKSk6W107fSk7LyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5pbnRlcnNlY3Rpb25gIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGNvbXBhcmF0b3JgXG4gICAgICogd2hpY2ggaXMgaW52b2tlZCB0byBjb21wYXJlIGVsZW1lbnRzIG9mIGBhcnJheXNgLiBUaGUgb3JkZXIgYW5kIHJlZmVyZW5jZXNcbiAgICAgKiBvZiByZXN1bHQgdmFsdWVzIGFyZSBkZXRlcm1pbmVkIGJ5IHRoZSBmaXJzdCBhcnJheS4gVGhlIGNvbXBhcmF0b3IgaXNcbiAgICAgKiBpbnZva2VkIHdpdGggdHdvIGFyZ3VtZW50czogKGFyclZhbCwgb3RoVmFsKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheXNdIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcGFyYXRvcl0gVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBpbnRlcnNlY3RpbmcgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFt7ICd4JzogMSwgJ3knOiAyIH0sIHsgJ3gnOiAyLCAneSc6IDEgfV07XG4gICAgICogdmFyIG90aGVycyA9IFt7ICd4JzogMSwgJ3knOiAxIH0sIHsgJ3gnOiAxLCAneSc6IDIgfV07XG4gICAgICpcbiAgICAgKiBfLmludGVyc2VjdGlvbldpdGgob2JqZWN0cywgb3RoZXJzLCBfLmlzRXF1YWwpO1xuICAgICAqIC8vID0+IFt7ICd4JzogMSwgJ3knOiAyIH1dXG4gICAgICovdmFyIGludGVyc2VjdGlvbldpdGg9YmFzZVJlc3QoZnVuY3Rpb24oYXJyYXlzKXt2YXIgY29tcGFyYXRvcj1sYXN0KGFycmF5cyksbWFwcGVkPWFycmF5TWFwKGFycmF5cyxjYXN0QXJyYXlMaWtlT2JqZWN0KTtjb21wYXJhdG9yPXR5cGVvZiBjb21wYXJhdG9yPT0nZnVuY3Rpb24nP2NvbXBhcmF0b3I6dW5kZWZpbmVkO2lmKGNvbXBhcmF0b3Ipe21hcHBlZC5wb3AoKTt9cmV0dXJuIG1hcHBlZC5sZW5ndGgmJm1hcHBlZFswXT09PWFycmF5c1swXT9iYXNlSW50ZXJzZWN0aW9uKG1hcHBlZCx1bmRlZmluZWQsY29tcGFyYXRvcik6W107fSk7LyoqXG4gICAgICogQ29udmVydHMgYWxsIGVsZW1lbnRzIGluIGBhcnJheWAgaW50byBhIHN0cmluZyBzZXBhcmF0ZWQgYnkgYHNlcGFyYXRvcmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gY29udmVydC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3NlcGFyYXRvcj0nLCddIFRoZSBlbGVtZW50IHNlcGFyYXRvci5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBqb2luZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmpvaW4oWydhJywgJ2InLCAnYyddLCAnficpO1xuICAgICAqIC8vID0+ICdhfmJ+YydcbiAgICAgKi9mdW5jdGlvbiBqb2luKGFycmF5LHNlcGFyYXRvcil7cmV0dXJuIGFycmF5PT1udWxsPycnOm5hdGl2ZUpvaW4uY2FsbChhcnJheSxzZXBhcmF0b3IpO30vKipcbiAgICAgKiBHZXRzIHRoZSBsYXN0IGVsZW1lbnQgb2YgYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbGFzdCBlbGVtZW50IG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubGFzdChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IDNcbiAgICAgKi9mdW5jdGlvbiBsYXN0KGFycmF5KXt2YXIgbGVuZ3RoPWFycmF5PT1udWxsPzA6YXJyYXkubGVuZ3RoO3JldHVybiBsZW5ndGg/YXJyYXlbbGVuZ3RoLTFdOnVuZGVmaW5lZDt9LyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5pbmRleE9mYCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mXG4gICAgICogYGFycmF5YCBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZnJvbUluZGV4PWFycmF5Lmxlbmd0aC0xXSBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5sYXN0SW5kZXhPZihbMSwgMiwgMSwgMl0sIDIpO1xuICAgICAqIC8vID0+IDNcbiAgICAgKlxuICAgICAqIC8vIFNlYXJjaCBmcm9tIHRoZSBgZnJvbUluZGV4YC5cbiAgICAgKiBfLmxhc3RJbmRleE9mKFsxLCAyLCAxLCAyXSwgMiwgMik7XG4gICAgICogLy8gPT4gMVxuICAgICAqL2Z1bmN0aW9uIGxhc3RJbmRleE9mKGFycmF5LHZhbHVlLGZyb21JbmRleCl7dmFyIGxlbmd0aD1hcnJheT09bnVsbD8wOmFycmF5Lmxlbmd0aDtpZighbGVuZ3RoKXtyZXR1cm4tMTt9dmFyIGluZGV4PWxlbmd0aDtpZihmcm9tSW5kZXghPT11bmRlZmluZWQpe2luZGV4PXRvSW50ZWdlcihmcm9tSW5kZXgpO2luZGV4PWluZGV4PDA/bmF0aXZlTWF4KGxlbmd0aCtpbmRleCwwKTpuYXRpdmVNaW4oaW5kZXgsbGVuZ3RoLTEpO31yZXR1cm4gdmFsdWU9PT12YWx1ZT9zdHJpY3RMYXN0SW5kZXhPZihhcnJheSx2YWx1ZSxpbmRleCk6YmFzZUZpbmRJbmRleChhcnJheSxiYXNlSXNOYU4saW5kZXgsdHJ1ZSk7fS8qKlxuICAgICAqIEdldHMgdGhlIGVsZW1lbnQgYXQgaW5kZXggYG5gIG9mIGBhcnJheWAuIElmIGBuYCBpcyBuZWdhdGl2ZSwgdGhlIG50aFxuICAgICAqIGVsZW1lbnQgZnJvbSB0aGUgZW5kIGlzIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMTEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW249MF0gVGhlIGluZGV4IG9mIHRoZSBlbGVtZW50IHRvIHJldHVybi5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbnRoIGVsZW1lbnQgb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWydhJywgJ2InLCAnYycsICdkJ107XG4gICAgICpcbiAgICAgKiBfLm50aChhcnJheSwgMSk7XG4gICAgICogLy8gPT4gJ2InXG4gICAgICpcbiAgICAgKiBfLm50aChhcnJheSwgLTIpO1xuICAgICAqIC8vID0+ICdjJztcbiAgICAgKi9mdW5jdGlvbiBudGgoYXJyYXksbil7cmV0dXJuIGFycmF5JiZhcnJheS5sZW5ndGg/YmFzZU50aChhcnJheSx0b0ludGVnZXIobikpOnVuZGVmaW5lZDt9LyoqXG4gICAgICogUmVtb3ZlcyBhbGwgZ2l2ZW4gdmFsdWVzIGZyb20gYGFycmF5YCB1c2luZ1xuICAgICAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gICAgICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFVubGlrZSBgXy53aXRob3V0YCwgdGhpcyBtZXRob2QgbXV0YXRlcyBgYXJyYXlgLiBVc2UgYF8ucmVtb3ZlYFxuICAgICAqIHRvIHJlbW92ZSBlbGVtZW50cyBmcm9tIGFuIGFycmF5IGJ5IHByZWRpY2F0ZS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHsuLi4qfSBbdmFsdWVzXSBUaGUgdmFsdWVzIHRvIHJlbW92ZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWydhJywgJ2InLCAnYycsICdhJywgJ2InLCAnYyddO1xuICAgICAqXG4gICAgICogXy5wdWxsKGFycmF5LCAnYScsICdjJyk7XG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFsnYicsICdiJ11cbiAgICAgKi92YXIgcHVsbD1iYXNlUmVzdChwdWxsQWxsKTsvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnB1bGxgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYW4gYXJyYXkgb2YgdmFsdWVzIHRvIHJlbW92ZS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBVbmxpa2UgYF8uZGlmZmVyZW5jZWAsIHRoaXMgbWV0aG9kIG11dGF0ZXMgYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gcmVtb3ZlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbJ2EnLCAnYicsICdjJywgJ2EnLCAnYicsICdjJ107XG4gICAgICpcbiAgICAgKiBfLnB1bGxBbGwoYXJyYXksIFsnYScsICdjJ10pO1xuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbJ2InLCAnYiddXG4gICAgICovZnVuY3Rpb24gcHVsbEFsbChhcnJheSx2YWx1ZXMpe3JldHVybiBhcnJheSYmYXJyYXkubGVuZ3RoJiZ2YWx1ZXMmJnZhbHVlcy5sZW5ndGg/YmFzZVB1bGxBbGwoYXJyYXksdmFsdWVzKTphcnJheTt9LyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5wdWxsQWxsYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBpdGVyYXRlZWAgd2hpY2ggaXNcbiAgICAgKiBpbnZva2VkIGZvciBlYWNoIGVsZW1lbnQgb2YgYGFycmF5YCBhbmQgYHZhbHVlc2AgdG8gZ2VuZXJhdGUgdGhlIGNyaXRlcmlvblxuICAgICAqIGJ5IHdoaWNoIHRoZXkncmUgY29tcGFyZWQuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFVubGlrZSBgXy5kaWZmZXJlbmNlQnlgLCB0aGlzIG1ldGhvZCBtdXRhdGVzIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgdmFsdWVzIHRvIHJlbW92ZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFt7ICd4JzogMSB9LCB7ICd4JzogMiB9LCB7ICd4JzogMyB9LCB7ICd4JzogMSB9XTtcbiAgICAgKlxuICAgICAqIF8ucHVsbEFsbEJ5KGFycmF5LCBbeyAneCc6IDEgfSwgeyAneCc6IDMgfV0sICd4Jyk7XG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFt7ICd4JzogMiB9XVxuICAgICAqL2Z1bmN0aW9uIHB1bGxBbGxCeShhcnJheSx2YWx1ZXMsaXRlcmF0ZWUpe3JldHVybiBhcnJheSYmYXJyYXkubGVuZ3RoJiZ2YWx1ZXMmJnZhbHVlcy5sZW5ndGg/YmFzZVB1bGxBbGwoYXJyYXksdmFsdWVzLGdldEl0ZXJhdGVlKGl0ZXJhdGVlLDIpKTphcnJheTt9LyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5wdWxsQWxsYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjb21wYXJhdG9yYCB3aGljaFxuICAgICAqIGlzIGludm9rZWQgdG8gY29tcGFyZSBlbGVtZW50cyBvZiBgYXJyYXlgIHRvIGB2YWx1ZXNgLiBUaGUgY29tcGFyYXRvciBpc1xuICAgICAqIGludm9rZWQgd2l0aCB0d28gYXJndW1lbnRzOiAoYXJyVmFsLCBvdGhWYWwpLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFVubGlrZSBgXy5kaWZmZXJlbmNlV2l0aGAsIHRoaXMgbWV0aG9kIG11dGF0ZXMgYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjYuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gcmVtb3ZlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJhdG9yXSBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbeyAneCc6IDEsICd5JzogMiB9LCB7ICd4JzogMywgJ3knOiA0IH0sIHsgJ3gnOiA1LCAneSc6IDYgfV07XG4gICAgICpcbiAgICAgKiBfLnB1bGxBbGxXaXRoKGFycmF5LCBbeyAneCc6IDMsICd5JzogNCB9XSwgXy5pc0VxdWFsKTtcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gW3sgJ3gnOiAxLCAneSc6IDIgfSwgeyAneCc6IDUsICd5JzogNiB9XVxuICAgICAqL2Z1bmN0aW9uIHB1bGxBbGxXaXRoKGFycmF5LHZhbHVlcyxjb21wYXJhdG9yKXtyZXR1cm4gYXJyYXkmJmFycmF5Lmxlbmd0aCYmdmFsdWVzJiZ2YWx1ZXMubGVuZ3RoP2Jhc2VQdWxsQWxsKGFycmF5LHZhbHVlcyx1bmRlZmluZWQsY29tcGFyYXRvcik6YXJyYXk7fS8qKlxuICAgICAqIFJlbW92ZXMgZWxlbWVudHMgZnJvbSBgYXJyYXlgIGNvcnJlc3BvbmRpbmcgdG8gYGluZGV4ZXNgIGFuZCByZXR1cm5zIGFuXG4gICAgICogYXJyYXkgb2YgcmVtb3ZlZCBlbGVtZW50cy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBVbmxpa2UgYF8uYXRgLCB0aGlzIG1ldGhvZCBtdXRhdGVzIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7Li4uKG51bWJlcnxudW1iZXJbXSl9IFtpbmRleGVzXSBUaGUgaW5kZXhlcyBvZiBlbGVtZW50cyB0byByZW1vdmUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgcmVtb3ZlZCBlbGVtZW50cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWydhJywgJ2InLCAnYycsICdkJ107XG4gICAgICogdmFyIHB1bGxlZCA9IF8ucHVsbEF0KGFycmF5LCBbMSwgM10pO1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFsnYScsICdjJ11cbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKHB1bGxlZCk7XG4gICAgICogLy8gPT4gWydiJywgJ2QnXVxuICAgICAqL3ZhciBwdWxsQXQ9ZmxhdFJlc3QoZnVuY3Rpb24oYXJyYXksaW5kZXhlcyl7dmFyIGxlbmd0aD1hcnJheT09bnVsbD8wOmFycmF5Lmxlbmd0aCxyZXN1bHQ9YmFzZUF0KGFycmF5LGluZGV4ZXMpO2Jhc2VQdWxsQXQoYXJyYXksYXJyYXlNYXAoaW5kZXhlcyxmdW5jdGlvbihpbmRleCl7cmV0dXJuIGlzSW5kZXgoaW5kZXgsbGVuZ3RoKT8raW5kZXg6aW5kZXg7fSkuc29ydChjb21wYXJlQXNjZW5kaW5nKSk7cmV0dXJuIHJlc3VsdDt9KTsvKipcbiAgICAgKiBSZW1vdmVzIGFsbCBlbGVtZW50cyBmcm9tIGBhcnJheWAgdGhhdCBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3JcbiAgICAgKiBhbmQgcmV0dXJucyBhbiBhcnJheSBvZiB0aGUgcmVtb3ZlZCBlbGVtZW50cy4gVGhlIHByZWRpY2F0ZSBpcyBpbnZva2VkXG4gICAgICogd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXgsIGFycmF5KS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBVbmxpa2UgYF8uZmlsdGVyYCwgdGhpcyBtZXRob2QgbXV0YXRlcyBgYXJyYXlgLiBVc2UgYF8ucHVsbGBcbiAgICAgKiB0byBwdWxsIGVsZW1lbnRzIGZyb20gYW4gYXJyYXkgYnkgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiByZW1vdmVkIGVsZW1lbnRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbMSwgMiwgMywgNF07XG4gICAgICogdmFyIGV2ZW5zID0gXy5yZW1vdmUoYXJyYXksIGZ1bmN0aW9uKG4pIHtcbiAgICAgKiAgIHJldHVybiBuICUgMiA9PSAwO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFsxLCAzXVxuICAgICAqXG4gICAgICogY29uc29sZS5sb2coZXZlbnMpO1xuICAgICAqIC8vID0+IFsyLCA0XVxuICAgICAqL2Z1bmN0aW9uIHJlbW92ZShhcnJheSxwcmVkaWNhdGUpe3ZhciByZXN1bHQ9W107aWYoIShhcnJheSYmYXJyYXkubGVuZ3RoKSl7cmV0dXJuIHJlc3VsdDt9dmFyIGluZGV4PS0xLGluZGV4ZXM9W10sbGVuZ3RoPWFycmF5Lmxlbmd0aDtwcmVkaWNhdGU9Z2V0SXRlcmF0ZWUocHJlZGljYXRlLDMpO3doaWxlKCsraW5kZXg8bGVuZ3RoKXt2YXIgdmFsdWU9YXJyYXlbaW5kZXhdO2lmKHByZWRpY2F0ZSh2YWx1ZSxpbmRleCxhcnJheSkpe3Jlc3VsdC5wdXNoKHZhbHVlKTtpbmRleGVzLnB1c2goaW5kZXgpO319YmFzZVB1bGxBdChhcnJheSxpbmRleGVzKTtyZXR1cm4gcmVzdWx0O30vKipcbiAgICAgKiBSZXZlcnNlcyBgYXJyYXlgIHNvIHRoYXQgdGhlIGZpcnN0IGVsZW1lbnQgYmVjb21lcyB0aGUgbGFzdCwgdGhlIHNlY29uZFxuICAgICAqIGVsZW1lbnQgYmVjb21lcyB0aGUgc2Vjb25kIHRvIGxhc3QsIGFuZCBzbyBvbi5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBhcnJheWAgYW5kIGlzIGJhc2VkIG9uXG4gICAgICogW2BBcnJheSNyZXZlcnNlYF0oaHR0cHM6Ly9tZG4uaW8vQXJyYXkvcmV2ZXJzZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbMSwgMiwgM107XG4gICAgICpcbiAgICAgKiBfLnJldmVyc2UoYXJyYXkpO1xuICAgICAqIC8vID0+IFszLCAyLCAxXVxuICAgICAqXG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFszLCAyLCAxXVxuICAgICAqL2Z1bmN0aW9uIHJldmVyc2UoYXJyYXkpe3JldHVybiBhcnJheT09bnVsbD9hcnJheTpuYXRpdmVSZXZlcnNlLmNhbGwoYXJyYXkpO30vKipcbiAgICAgKiBDcmVhdGVzIGEgc2xpY2Ugb2YgYGFycmF5YCBmcm9tIGBzdGFydGAgdXAgdG8sIGJ1dCBub3QgaW5jbHVkaW5nLCBgZW5kYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyB1c2VkIGluc3RlYWQgb2ZcbiAgICAgKiBbYEFycmF5I3NsaWNlYF0oaHR0cHM6Ly9tZG4uaW8vQXJyYXkvc2xpY2UpIHRvIGVuc3VyZSBkZW5zZSBhcnJheXMgYXJlXG4gICAgICogcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2xpY2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD0wXSBUaGUgc3RhcnQgcG9zaXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtlbmQ9YXJyYXkubGVuZ3RoXSBUaGUgZW5kIHBvc2l0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKi9mdW5jdGlvbiBzbGljZShhcnJheSxzdGFydCxlbmQpe3ZhciBsZW5ndGg9YXJyYXk9PW51bGw/MDphcnJheS5sZW5ndGg7aWYoIWxlbmd0aCl7cmV0dXJuW107fWlmKGVuZCYmdHlwZW9mIGVuZCE9J251bWJlcicmJmlzSXRlcmF0ZWVDYWxsKGFycmF5LHN0YXJ0LGVuZCkpe3N0YXJ0PTA7ZW5kPWxlbmd0aDt9ZWxzZXtzdGFydD1zdGFydD09bnVsbD8wOnRvSW50ZWdlcihzdGFydCk7ZW5kPWVuZD09PXVuZGVmaW5lZD9sZW5ndGg6dG9JbnRlZ2VyKGVuZCk7fXJldHVybiBiYXNlU2xpY2UoYXJyYXksc3RhcnQsZW5kKTt9LyoqXG4gICAgICogVXNlcyBhIGJpbmFyeSBzZWFyY2ggdG8gZGV0ZXJtaW5lIHRoZSBsb3dlc3QgaW5kZXggYXQgd2hpY2ggYHZhbHVlYFxuICAgICAqIHNob3VsZCBiZSBpbnNlcnRlZCBpbnRvIGBhcnJheWAgaW4gb3JkZXIgdG8gbWFpbnRhaW4gaXRzIHNvcnQgb3JkZXIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgc29ydGVkIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gZXZhbHVhdGUuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggYXQgd2hpY2ggYHZhbHVlYCBzaG91bGQgYmUgaW5zZXJ0ZWRcbiAgICAgKiAgaW50byBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNvcnRlZEluZGV4KFszMCwgNTBdLCA0MCk7XG4gICAgICogLy8gPT4gMVxuICAgICAqL2Z1bmN0aW9uIHNvcnRlZEluZGV4KGFycmF5LHZhbHVlKXtyZXR1cm4gYmFzZVNvcnRlZEluZGV4KGFycmF5LHZhbHVlKTt9LyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5zb3J0ZWRJbmRleGAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgXG4gICAgICogd2hpY2ggaXMgaW52b2tlZCBmb3IgYHZhbHVlYCBhbmQgZWFjaCBlbGVtZW50IG9mIGBhcnJheWAgdG8gY29tcHV0ZSB0aGVpclxuICAgICAqIHNvcnQgcmFua2luZy4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgc29ydGVkIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gZXZhbHVhdGUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IGF0IHdoaWNoIGB2YWx1ZWAgc2hvdWxkIGJlIGluc2VydGVkXG4gICAgICogIGludG8gYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbeyAneCc6IDQgfSwgeyAneCc6IDUgfV07XG4gICAgICpcbiAgICAgKiBfLnNvcnRlZEluZGV4Qnkob2JqZWN0cywgeyAneCc6IDQgfSwgZnVuY3Rpb24obykgeyByZXR1cm4gby54OyB9KTtcbiAgICAgKiAvLyA9PiAwXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnNvcnRlZEluZGV4Qnkob2JqZWN0cywgeyAneCc6IDQgfSwgJ3gnKTtcbiAgICAgKiAvLyA9PiAwXG4gICAgICovZnVuY3Rpb24gc29ydGVkSW5kZXhCeShhcnJheSx2YWx1ZSxpdGVyYXRlZSl7cmV0dXJuIGJhc2VTb3J0ZWRJbmRleEJ5KGFycmF5LHZhbHVlLGdldEl0ZXJhdGVlKGl0ZXJhdGVlLDIpKTt9LyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5pbmRleE9mYCBleGNlcHQgdGhhdCBpdCBwZXJmb3JtcyBhIGJpbmFyeVxuICAgICAqIHNlYXJjaCBvbiBhIHNvcnRlZCBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNvcnRlZEluZGV4T2YoWzQsIDUsIDUsIDUsIDZdLCA1KTtcbiAgICAgKiAvLyA9PiAxXG4gICAgICovZnVuY3Rpb24gc29ydGVkSW5kZXhPZihhcnJheSx2YWx1ZSl7dmFyIGxlbmd0aD1hcnJheT09bnVsbD8wOmFycmF5Lmxlbmd0aDtpZihsZW5ndGgpe3ZhciBpbmRleD1iYXNlU29ydGVkSW5kZXgoYXJyYXksdmFsdWUpO2lmKGluZGV4PGxlbmd0aCYmZXEoYXJyYXlbaW5kZXhdLHZhbHVlKSl7cmV0dXJuIGluZGV4O319cmV0dXJuLTE7fS8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uc29ydGVkSW5kZXhgIGV4Y2VwdCB0aGF0IGl0IHJldHVybnMgdGhlIGhpZ2hlc3RcbiAgICAgKiBpbmRleCBhdCB3aGljaCBgdmFsdWVgIHNob3VsZCBiZSBpbnNlcnRlZCBpbnRvIGBhcnJheWAgaW4gb3JkZXIgdG9cbiAgICAgKiBtYWludGFpbiBpdHMgc29ydCBvcmRlci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBzb3J0ZWQgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBldmFsdWF0ZS5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBhdCB3aGljaCBgdmFsdWVgIHNob3VsZCBiZSBpbnNlcnRlZFxuICAgICAqICBpbnRvIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc29ydGVkTGFzdEluZGV4KFs0LCA1LCA1LCA1LCA2XSwgNSk7XG4gICAgICogLy8gPT4gNFxuICAgICAqL2Z1bmN0aW9uIHNvcnRlZExhc3RJbmRleChhcnJheSx2YWx1ZSl7cmV0dXJuIGJhc2VTb3J0ZWRJbmRleChhcnJheSx2YWx1ZSx0cnVlKTt9LyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5zb3J0ZWRMYXN0SW5kZXhgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGl0ZXJhdGVlYFxuICAgICAqIHdoaWNoIGlzIGludm9rZWQgZm9yIGB2YWx1ZWAgYW5kIGVhY2ggZWxlbWVudCBvZiBgYXJyYXlgIHRvIGNvbXB1dGUgdGhlaXJcbiAgICAgKiBzb3J0IHJhbmtpbmcuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIHNvcnRlZCBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGV2YWx1YXRlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBhdCB3aGljaCBgdmFsdWVgIHNob3VsZCBiZSBpbnNlcnRlZFxuICAgICAqICBpbnRvIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW3sgJ3gnOiA0IH0sIHsgJ3gnOiA1IH1dO1xuICAgICAqXG4gICAgICogXy5zb3J0ZWRMYXN0SW5kZXhCeShvYmplY3RzLCB7ICd4JzogNCB9LCBmdW5jdGlvbihvKSB7IHJldHVybiBvLng7IH0pO1xuICAgICAqIC8vID0+IDFcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uc29ydGVkTGFzdEluZGV4Qnkob2JqZWN0cywgeyAneCc6IDQgfSwgJ3gnKTtcbiAgICAgKiAvLyA9PiAxXG4gICAgICovZnVuY3Rpb24gc29ydGVkTGFzdEluZGV4QnkoYXJyYXksdmFsdWUsaXRlcmF0ZWUpe3JldHVybiBiYXNlU29ydGVkSW5kZXhCeShhcnJheSx2YWx1ZSxnZXRJdGVyYXRlZShpdGVyYXRlZSwyKSx0cnVlKTt9LyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5sYXN0SW5kZXhPZmAgZXhjZXB0IHRoYXQgaXQgcGVyZm9ybXMgYSBiaW5hcnlcbiAgICAgKiBzZWFyY2ggb24gYSBzb3J0ZWQgYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zb3J0ZWRMYXN0SW5kZXhPZihbNCwgNSwgNSwgNSwgNl0sIDUpO1xuICAgICAqIC8vID0+IDNcbiAgICAgKi9mdW5jdGlvbiBzb3J0ZWRMYXN0SW5kZXhPZihhcnJheSx2YWx1ZSl7dmFyIGxlbmd0aD1hcnJheT09bnVsbD8wOmFycmF5Lmxlbmd0aDtpZihsZW5ndGgpe3ZhciBpbmRleD1iYXNlU29ydGVkSW5kZXgoYXJyYXksdmFsdWUsdHJ1ZSktMTtpZihlcShhcnJheVtpbmRleF0sdmFsdWUpKXtyZXR1cm4gaW5kZXg7fX1yZXR1cm4tMTt9LyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy51bmlxYCBleGNlcHQgdGhhdCBpdCdzIGRlc2lnbmVkIGFuZCBvcHRpbWl6ZWRcbiAgICAgKiBmb3Igc29ydGVkIGFycmF5cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGR1cGxpY2F0ZSBmcmVlIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNvcnRlZFVuaXEoWzEsIDEsIDJdKTtcbiAgICAgKiAvLyA9PiBbMSwgMl1cbiAgICAgKi9mdW5jdGlvbiBzb3J0ZWRVbmlxKGFycmF5KXtyZXR1cm4gYXJyYXkmJmFycmF5Lmxlbmd0aD9iYXNlU29ydGVkVW5pcShhcnJheSk6W107fS8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8udW5pcUJ5YCBleGNlcHQgdGhhdCBpdCdzIGRlc2lnbmVkIGFuZCBvcHRpbWl6ZWRcbiAgICAgKiBmb3Igc29ydGVkIGFycmF5cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZHVwbGljYXRlIGZyZWUgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc29ydGVkVW5pcUJ5KFsxLjEsIDEuMiwgMi4zLCAyLjRdLCBNYXRoLmZsb29yKTtcbiAgICAgKiAvLyA9PiBbMS4xLCAyLjNdXG4gICAgICovZnVuY3Rpb24gc29ydGVkVW5pcUJ5KGFycmF5LGl0ZXJhdGVlKXtyZXR1cm4gYXJyYXkmJmFycmF5Lmxlbmd0aD9iYXNlU29ydGVkVW5pcShhcnJheSxnZXRJdGVyYXRlZShpdGVyYXRlZSwyKSk6W107fS8qKlxuICAgICAqIEdldHMgYWxsIGJ1dCB0aGUgZmlyc3QgZWxlbWVudCBvZiBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50YWlsKFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gWzIsIDNdXG4gICAgICovZnVuY3Rpb24gdGFpbChhcnJheSl7dmFyIGxlbmd0aD1hcnJheT09bnVsbD8wOmFycmF5Lmxlbmd0aDtyZXR1cm4gbGVuZ3RoP2Jhc2VTbGljZShhcnJheSwxLGxlbmd0aCk6W107fS8qKlxuICAgICAqIENyZWF0ZXMgYSBzbGljZSBvZiBgYXJyYXlgIHdpdGggYG5gIGVsZW1lbnRzIHRha2VuIGZyb20gdGhlIGJlZ2lubmluZy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW249MV0gVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byB0YWtlLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRha2UoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiBbMV1cbiAgICAgKlxuICAgICAqIF8udGFrZShbMSwgMiwgM10sIDIpO1xuICAgICAqIC8vID0+IFsxLCAyXVxuICAgICAqXG4gICAgICogXy50YWtlKFsxLCAyLCAzXSwgNSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICpcbiAgICAgKiBfLnRha2UoWzEsIDIsIDNdLCAwKTtcbiAgICAgKiAvLyA9PiBbXVxuICAgICAqL2Z1bmN0aW9uIHRha2UoYXJyYXksbixndWFyZCl7aWYoIShhcnJheSYmYXJyYXkubGVuZ3RoKSl7cmV0dXJuW107fW49Z3VhcmR8fG49PT11bmRlZmluZWQ/MTp0b0ludGVnZXIobik7cmV0dXJuIGJhc2VTbGljZShhcnJheSwwLG48MD8wOm4pO30vKipcbiAgICAgKiBDcmVhdGVzIGEgc2xpY2Ugb2YgYGFycmF5YCB3aXRoIGBuYCBlbGVtZW50cyB0YWtlbiBmcm9tIHRoZSBlbmQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtuPTFdIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gdGFrZS5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50YWtlUmlnaHQoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiBbM11cbiAgICAgKlxuICAgICAqIF8udGFrZVJpZ2h0KFsxLCAyLCAzXSwgMik7XG4gICAgICogLy8gPT4gWzIsIDNdXG4gICAgICpcbiAgICAgKiBfLnRha2VSaWdodChbMSwgMiwgM10sIDUpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqXG4gICAgICogXy50YWtlUmlnaHQoWzEsIDIsIDNdLCAwKTtcbiAgICAgKiAvLyA9PiBbXVxuICAgICAqL2Z1bmN0aW9uIHRha2VSaWdodChhcnJheSxuLGd1YXJkKXt2YXIgbGVuZ3RoPWFycmF5PT1udWxsPzA6YXJyYXkubGVuZ3RoO2lmKCFsZW5ndGgpe3JldHVybltdO31uPWd1YXJkfHxuPT09dW5kZWZpbmVkPzE6dG9JbnRlZ2VyKG4pO249bGVuZ3RoLW47cmV0dXJuIGJhc2VTbGljZShhcnJheSxuPDA/MDpuLGxlbmd0aCk7fS8qKlxuICAgICAqIENyZWF0ZXMgYSBzbGljZSBvZiBgYXJyYXlgIHdpdGggZWxlbWVudHMgdGFrZW4gZnJvbSB0aGUgZW5kLiBFbGVtZW50cyBhcmVcbiAgICAgKiB0YWtlbiB1bnRpbCBgcHJlZGljYXRlYCByZXR1cm5zIGZhbHNleS4gVGhlIHByZWRpY2F0ZSBpcyBpbnZva2VkIHdpdGhcbiAgICAgKiB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXgsIGFycmF5KS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICAnYWN0aXZlJzogdHJ1ZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWN0aXZlJzogZmFsc2UgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLnRha2VSaWdodFdoaWxlKHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiAhby5hY3RpdmU7IH0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnZnJlZCcsICdwZWJibGVzJ11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy50YWtlUmlnaHRXaGlsZSh1c2VycywgeyAndXNlcic6ICdwZWJibGVzJywgJ2FjdGl2ZSc6IGZhbHNlIH0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsncGViYmxlcyddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy50YWtlUmlnaHRXaGlsZSh1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnZnJlZCcsICdwZWJibGVzJ11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8udGFrZVJpZ2h0V2hpbGUodXNlcnMsICdhY3RpdmUnKTtcbiAgICAgKiAvLyA9PiBbXVxuICAgICAqL2Z1bmN0aW9uIHRha2VSaWdodFdoaWxlKGFycmF5LHByZWRpY2F0ZSl7cmV0dXJuIGFycmF5JiZhcnJheS5sZW5ndGg/YmFzZVdoaWxlKGFycmF5LGdldEl0ZXJhdGVlKHByZWRpY2F0ZSwzKSxmYWxzZSx0cnVlKTpbXTt9LyoqXG4gICAgICogQ3JlYXRlcyBhIHNsaWNlIG9mIGBhcnJheWAgd2l0aCBlbGVtZW50cyB0YWtlbiBmcm9tIHRoZSBiZWdpbm5pbmcuIEVsZW1lbnRzXG4gICAgICogYXJlIHRha2VuIHVudGlsIGBwcmVkaWNhdGVgIHJldHVybnMgZmFsc2V5LiBUaGUgcHJlZGljYXRlIGlzIGludm9rZWQgd2l0aFxuICAgICAqIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleCwgYXJyYXkpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWN0aXZlJzogdHJ1ZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8udGFrZVdoaWxlKHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiAhby5hY3RpdmU7IH0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnYmFybmV5JywgJ2ZyZWQnXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnRha2VXaGlsZSh1c2VycywgeyAndXNlcic6ICdiYXJuZXknLCAnYWN0aXZlJzogZmFsc2UgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydiYXJuZXknXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8udGFrZVdoaWxlKHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydiYXJuZXknLCAnZnJlZCddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnRha2VXaGlsZSh1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+IFtdXG4gICAgICovZnVuY3Rpb24gdGFrZVdoaWxlKGFycmF5LHByZWRpY2F0ZSl7cmV0dXJuIGFycmF5JiZhcnJheS5sZW5ndGg/YmFzZVdoaWxlKGFycmF5LGdldEl0ZXJhdGVlKHByZWRpY2F0ZSwzKSk6W107fS8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdW5pcXVlIHZhbHVlcywgaW4gb3JkZXIsIGZyb20gYWxsIGdpdmVuIGFycmF5cyB1c2luZ1xuICAgICAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gICAgICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5c10gVGhlIGFycmF5cyB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGNvbWJpbmVkIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy51bmlvbihbMl0sIFsxLCAyXSk7XG4gICAgICogLy8gPT4gWzIsIDFdXG4gICAgICovdmFyIHVuaW9uPWJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5cyl7cmV0dXJuIGJhc2VVbmlxKGJhc2VGbGF0dGVuKGFycmF5cywxLGlzQXJyYXlMaWtlT2JqZWN0LHRydWUpKTt9KTsvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnVuaW9uYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBpdGVyYXRlZWAgd2hpY2ggaXNcbiAgICAgKiBpbnZva2VkIGZvciBlYWNoIGVsZW1lbnQgb2YgZWFjaCBgYXJyYXlzYCB0byBnZW5lcmF0ZSB0aGUgY3JpdGVyaW9uIGJ5XG4gICAgICogd2hpY2ggdW5pcXVlbmVzcyBpcyBjb21wdXRlZC4gUmVzdWx0IHZhbHVlcyBhcmUgY2hvc2VuIGZyb20gdGhlIGZpcnN0XG4gICAgICogYXJyYXkgaW4gd2hpY2ggdGhlIHZhbHVlIG9jY3Vycy4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6XG4gICAgICogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheXNdIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgY29tYmluZWQgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnVuaW9uQnkoWzIuMV0sIFsxLjIsIDIuM10sIE1hdGguZmxvb3IpO1xuICAgICAqIC8vID0+IFsyLjEsIDEuMl1cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8udW5pb25CeShbeyAneCc6IDEgfV0sIFt7ICd4JzogMiB9LCB7ICd4JzogMSB9XSwgJ3gnKTtcbiAgICAgKiAvLyA9PiBbeyAneCc6IDEgfSwgeyAneCc6IDIgfV1cbiAgICAgKi92YXIgdW5pb25CeT1iYXNlUmVzdChmdW5jdGlvbihhcnJheXMpe3ZhciBpdGVyYXRlZT1sYXN0KGFycmF5cyk7aWYoaXNBcnJheUxpa2VPYmplY3QoaXRlcmF0ZWUpKXtpdGVyYXRlZT11bmRlZmluZWQ7fXJldHVybiBiYXNlVW5pcShiYXNlRmxhdHRlbihhcnJheXMsMSxpc0FycmF5TGlrZU9iamVjdCx0cnVlKSxnZXRJdGVyYXRlZShpdGVyYXRlZSwyKSk7fSk7LyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy51bmlvbmAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgY29tcGFyYXRvcmAgd2hpY2hcbiAgICAgKiBpcyBpbnZva2VkIHRvIGNvbXBhcmUgZWxlbWVudHMgb2YgYGFycmF5c2AuIFJlc3VsdCB2YWx1ZXMgYXJlIGNob3NlbiBmcm9tXG4gICAgICogdGhlIGZpcnN0IGFycmF5IGluIHdoaWNoIHRoZSB2YWx1ZSBvY2N1cnMuIFRoZSBjb21wYXJhdG9yIGlzIGludm9rZWRcbiAgICAgKiB3aXRoIHR3byBhcmd1bWVudHM6IChhcnJWYWwsIG90aFZhbCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXlzXSBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmF0b3JdIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgY29tYmluZWQgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFt7ICd4JzogMSwgJ3knOiAyIH0sIHsgJ3gnOiAyLCAneSc6IDEgfV07XG4gICAgICogdmFyIG90aGVycyA9IFt7ICd4JzogMSwgJ3knOiAxIH0sIHsgJ3gnOiAxLCAneSc6IDIgfV07XG4gICAgICpcbiAgICAgKiBfLnVuaW9uV2l0aChvYmplY3RzLCBvdGhlcnMsIF8uaXNFcXVhbCk7XG4gICAgICogLy8gPT4gW3sgJ3gnOiAxLCAneSc6IDIgfSwgeyAneCc6IDIsICd5JzogMSB9LCB7ICd4JzogMSwgJ3knOiAxIH1dXG4gICAgICovdmFyIHVuaW9uV2l0aD1iYXNlUmVzdChmdW5jdGlvbihhcnJheXMpe3ZhciBjb21wYXJhdG9yPWxhc3QoYXJyYXlzKTtjb21wYXJhdG9yPXR5cGVvZiBjb21wYXJhdG9yPT0nZnVuY3Rpb24nP2NvbXBhcmF0b3I6dW5kZWZpbmVkO3JldHVybiBiYXNlVW5pcShiYXNlRmxhdHRlbihhcnJheXMsMSxpc0FycmF5TGlrZU9iamVjdCx0cnVlKSx1bmRlZmluZWQsY29tcGFyYXRvcik7fSk7LyoqXG4gICAgICogQ3JlYXRlcyBhIGR1cGxpY2F0ZS1mcmVlIHZlcnNpb24gb2YgYW4gYXJyYXksIHVzaW5nXG4gICAgICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAgICAgKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGluIHdoaWNoIG9ubHkgdGhlIGZpcnN0IG9jY3VycmVuY2Ugb2YgZWFjaCBlbGVtZW50XG4gICAgICogaXMga2VwdC4gVGhlIG9yZGVyIG9mIHJlc3VsdCB2YWx1ZXMgaXMgZGV0ZXJtaW5lZCBieSB0aGUgb3JkZXIgdGhleSBvY2N1clxuICAgICAqIGluIHRoZSBhcnJheS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGR1cGxpY2F0ZSBmcmVlIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnVuaXEoWzIsIDEsIDJdKTtcbiAgICAgKiAvLyA9PiBbMiwgMV1cbiAgICAgKi9mdW5jdGlvbiB1bmlxKGFycmF5KXtyZXR1cm4gYXJyYXkmJmFycmF5Lmxlbmd0aD9iYXNlVW5pcShhcnJheSk6W107fS8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8udW5pcWAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgIHdoaWNoIGlzXG4gICAgICogaW52b2tlZCBmb3IgZWFjaCBlbGVtZW50IGluIGBhcnJheWAgdG8gZ2VuZXJhdGUgdGhlIGNyaXRlcmlvbiBieSB3aGljaFxuICAgICAqIHVuaXF1ZW5lc3MgaXMgY29tcHV0ZWQuIFRoZSBvcmRlciBvZiByZXN1bHQgdmFsdWVzIGlzIGRldGVybWluZWQgYnkgdGhlXG4gICAgICogb3JkZXIgdGhleSBvY2N1ciBpbiB0aGUgYXJyYXkuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OlxuICAgICAqICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZHVwbGljYXRlIGZyZWUgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udW5pcUJ5KFsyLjEsIDEuMiwgMi4zXSwgTWF0aC5mbG9vcik7XG4gICAgICogLy8gPT4gWzIuMSwgMS4yXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy51bmlxQnkoW3sgJ3gnOiAxIH0sIHsgJ3gnOiAyIH0sIHsgJ3gnOiAxIH1dLCAneCcpO1xuICAgICAqIC8vID0+IFt7ICd4JzogMSB9LCB7ICd4JzogMiB9XVxuICAgICAqL2Z1bmN0aW9uIHVuaXFCeShhcnJheSxpdGVyYXRlZSl7cmV0dXJuIGFycmF5JiZhcnJheS5sZW5ndGg/YmFzZVVuaXEoYXJyYXksZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsMikpOltdO30vKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnVuaXFgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGNvbXBhcmF0b3JgIHdoaWNoXG4gICAgICogaXMgaW52b2tlZCB0byBjb21wYXJlIGVsZW1lbnRzIG9mIGBhcnJheWAuIFRoZSBvcmRlciBvZiByZXN1bHQgdmFsdWVzIGlzXG4gICAgICogZGV0ZXJtaW5lZCBieSB0aGUgb3JkZXIgdGhleSBvY2N1ciBpbiB0aGUgYXJyYXkuVGhlIGNvbXBhcmF0b3IgaXMgaW52b2tlZFxuICAgICAqIHdpdGggdHdvIGFyZ3VtZW50czogKGFyclZhbCwgb3RoVmFsKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJhdG9yXSBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGR1cGxpY2F0ZSBmcmVlIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFt7ICd4JzogMSwgJ3knOiAyIH0sIHsgJ3gnOiAyLCAneSc6IDEgfSwgeyAneCc6IDEsICd5JzogMiB9XTtcbiAgICAgKlxuICAgICAqIF8udW5pcVdpdGgob2JqZWN0cywgXy5pc0VxdWFsKTtcbiAgICAgKiAvLyA9PiBbeyAneCc6IDEsICd5JzogMiB9LCB7ICd4JzogMiwgJ3knOiAxIH1dXG4gICAgICovZnVuY3Rpb24gdW5pcVdpdGgoYXJyYXksY29tcGFyYXRvcil7Y29tcGFyYXRvcj10eXBlb2YgY29tcGFyYXRvcj09J2Z1bmN0aW9uJz9jb21wYXJhdG9yOnVuZGVmaW5lZDtyZXR1cm4gYXJyYXkmJmFycmF5Lmxlbmd0aD9iYXNlVW5pcShhcnJheSx1bmRlZmluZWQsY29tcGFyYXRvcik6W107fS8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uemlwYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGFuIGFycmF5IG9mIGdyb3VwZWRcbiAgICAgKiBlbGVtZW50cyBhbmQgY3JlYXRlcyBhbiBhcnJheSByZWdyb3VwaW5nIHRoZSBlbGVtZW50cyB0byB0aGVpciBwcmUtemlwXG4gICAgICogY29uZmlndXJhdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAxLjIuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSBvZiBncm91cGVkIGVsZW1lbnRzIHRvIHByb2Nlc3MuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgcmVncm91cGVkIGVsZW1lbnRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgemlwcGVkID0gXy56aXAoWydhJywgJ2InXSwgWzEsIDJdLCBbdHJ1ZSwgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiBbWydhJywgMSwgdHJ1ZV0sIFsnYicsIDIsIGZhbHNlXV1cbiAgICAgKlxuICAgICAqIF8udW56aXAoemlwcGVkKTtcbiAgICAgKiAvLyA9PiBbWydhJywgJ2InXSwgWzEsIDJdLCBbdHJ1ZSwgZmFsc2VdXVxuICAgICAqL2Z1bmN0aW9uIHVuemlwKGFycmF5KXtpZighKGFycmF5JiZhcnJheS5sZW5ndGgpKXtyZXR1cm5bXTt9dmFyIGxlbmd0aD0wO2FycmF5PWFycmF5RmlsdGVyKGFycmF5LGZ1bmN0aW9uKGdyb3VwKXtpZihpc0FycmF5TGlrZU9iamVjdChncm91cCkpe2xlbmd0aD1uYXRpdmVNYXgoZ3JvdXAubGVuZ3RoLGxlbmd0aCk7cmV0dXJuIHRydWU7fX0pO3JldHVybiBiYXNlVGltZXMobGVuZ3RoLGZ1bmN0aW9uKGluZGV4KXtyZXR1cm4gYXJyYXlNYXAoYXJyYXksYmFzZVByb3BlcnR5KGluZGV4KSk7fSk7fS8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8udW56aXBgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGl0ZXJhdGVlYCB0byBzcGVjaWZ5XG4gICAgICogaG93IHJlZ3JvdXBlZCB2YWx1ZXMgc2hvdWxkIGJlIGNvbWJpbmVkLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIHRoZVxuICAgICAqIGVsZW1lbnRzIG9mIGVhY2ggZ3JvdXA6ICguLi5ncm91cCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy44LjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgb2YgZ3JvdXBlZCBlbGVtZW50cyB0byBwcm9jZXNzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gdG8gY29tYmluZVxuICAgICAqICByZWdyb3VwZWQgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIHJlZ3JvdXBlZCBlbGVtZW50cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHppcHBlZCA9IF8uemlwKFsxLCAyXSwgWzEwLCAyMF0sIFsxMDAsIDIwMF0pO1xuICAgICAqIC8vID0+IFtbMSwgMTAsIDEwMF0sIFsyLCAyMCwgMjAwXV1cbiAgICAgKlxuICAgICAqIF8udW56aXBXaXRoKHppcHBlZCwgXy5hZGQpO1xuICAgICAqIC8vID0+IFszLCAzMCwgMzAwXVxuICAgICAqL2Z1bmN0aW9uIHVuemlwV2l0aChhcnJheSxpdGVyYXRlZSl7aWYoIShhcnJheSYmYXJyYXkubGVuZ3RoKSl7cmV0dXJuW107fXZhciByZXN1bHQ9dW56aXAoYXJyYXkpO2lmKGl0ZXJhdGVlPT1udWxsKXtyZXR1cm4gcmVzdWx0O31yZXR1cm4gYXJyYXlNYXAocmVzdWx0LGZ1bmN0aW9uKGdyb3VwKXtyZXR1cm4gYXBwbHkoaXRlcmF0ZWUsdW5kZWZpbmVkLGdyb3VwKTt9KTt9LyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBleGNsdWRpbmcgYWxsIGdpdmVuIHZhbHVlcyB1c2luZ1xuICAgICAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gICAgICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFVubGlrZSBgXy5wdWxsYCwgdGhpcyBtZXRob2QgcmV0dXJucyBhIG5ldyBhcnJheS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW3ZhbHVlc10gVGhlIHZhbHVlcyB0byBleGNsdWRlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cbiAgICAgKiBAc2VlIF8uZGlmZmVyZW5jZSwgXy54b3JcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy53aXRob3V0KFsyLCAxLCAyLCAzXSwgMSwgMik7XG4gICAgICogLy8gPT4gWzNdXG4gICAgICovdmFyIHdpdGhvdXQ9YmFzZVJlc3QoZnVuY3Rpb24oYXJyYXksdmFsdWVzKXtyZXR1cm4gaXNBcnJheUxpa2VPYmplY3QoYXJyYXkpP2Jhc2VEaWZmZXJlbmNlKGFycmF5LHZhbHVlcyk6W107fSk7LyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB1bmlxdWUgdmFsdWVzIHRoYXQgaXMgdGhlXG4gICAgICogW3N5bW1ldHJpYyBkaWZmZXJlbmNlXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TeW1tZXRyaWNfZGlmZmVyZW5jZSlcbiAgICAgKiBvZiB0aGUgZ2l2ZW4gYXJyYXlzLiBUaGUgb3JkZXIgb2YgcmVzdWx0IHZhbHVlcyBpcyBkZXRlcm1pbmVkIGJ5IHRoZSBvcmRlclxuICAgICAqIHRoZXkgb2NjdXIgaW4gdGhlIGFycmF5cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjQuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheXNdIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBmaWx0ZXJlZCB2YWx1ZXMuXG4gICAgICogQHNlZSBfLmRpZmZlcmVuY2UsIF8ud2l0aG91dFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnhvcihbMiwgMV0sIFsyLCAzXSk7XG4gICAgICogLy8gPT4gWzEsIDNdXG4gICAgICovdmFyIHhvcj1iYXNlUmVzdChmdW5jdGlvbihhcnJheXMpe3JldHVybiBiYXNlWG9yKGFycmF5RmlsdGVyKGFycmF5cyxpc0FycmF5TGlrZU9iamVjdCkpO30pOy8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ueG9yYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBpdGVyYXRlZWAgd2hpY2ggaXNcbiAgICAgKiBpbnZva2VkIGZvciBlYWNoIGVsZW1lbnQgb2YgZWFjaCBgYXJyYXlzYCB0byBnZW5lcmF0ZSB0aGUgY3JpdGVyaW9uIGJ5XG4gICAgICogd2hpY2ggYnkgd2hpY2ggdGhleSdyZSBjb21wYXJlZC4gVGhlIG9yZGVyIG9mIHJlc3VsdCB2YWx1ZXMgaXMgZGV0ZXJtaW5lZFxuICAgICAqIGJ5IHRoZSBvcmRlciB0aGV5IG9jY3VyIGluIHRoZSBhcnJheXMuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lXG4gICAgICogYXJndW1lbnQ6ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXlzXSBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy54b3JCeShbMi4xLCAxLjJdLCBbMi4zLCAzLjRdLCBNYXRoLmZsb29yKTtcbiAgICAgKiAvLyA9PiBbMS4yLCAzLjRdXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnhvckJ5KFt7ICd4JzogMSB9XSwgW3sgJ3gnOiAyIH0sIHsgJ3gnOiAxIH1dLCAneCcpO1xuICAgICAqIC8vID0+IFt7ICd4JzogMiB9XVxuICAgICAqL3ZhciB4b3JCeT1iYXNlUmVzdChmdW5jdGlvbihhcnJheXMpe3ZhciBpdGVyYXRlZT1sYXN0KGFycmF5cyk7aWYoaXNBcnJheUxpa2VPYmplY3QoaXRlcmF0ZWUpKXtpdGVyYXRlZT11bmRlZmluZWQ7fXJldHVybiBiYXNlWG9yKGFycmF5RmlsdGVyKGFycmF5cyxpc0FycmF5TGlrZU9iamVjdCksZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsMikpO30pOy8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ueG9yYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjb21wYXJhdG9yYCB3aGljaCBpc1xuICAgICAqIGludm9rZWQgdG8gY29tcGFyZSBlbGVtZW50cyBvZiBgYXJyYXlzYC4gVGhlIG9yZGVyIG9mIHJlc3VsdCB2YWx1ZXMgaXNcbiAgICAgKiBkZXRlcm1pbmVkIGJ5IHRoZSBvcmRlciB0aGV5IG9jY3VyIGluIHRoZSBhcnJheXMuIFRoZSBjb21wYXJhdG9yIGlzIGludm9rZWRcbiAgICAgKiB3aXRoIHR3byBhcmd1bWVudHM6IChhcnJWYWwsIG90aFZhbCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXlzXSBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmF0b3JdIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgZmlsdGVyZWQgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFt7ICd4JzogMSwgJ3knOiAyIH0sIHsgJ3gnOiAyLCAneSc6IDEgfV07XG4gICAgICogdmFyIG90aGVycyA9IFt7ICd4JzogMSwgJ3knOiAxIH0sIHsgJ3gnOiAxLCAneSc6IDIgfV07XG4gICAgICpcbiAgICAgKiBfLnhvcldpdGgob2JqZWN0cywgb3RoZXJzLCBfLmlzRXF1YWwpO1xuICAgICAqIC8vID0+IFt7ICd4JzogMiwgJ3knOiAxIH0sIHsgJ3gnOiAxLCAneSc6IDEgfV1cbiAgICAgKi92YXIgeG9yV2l0aD1iYXNlUmVzdChmdW5jdGlvbihhcnJheXMpe3ZhciBjb21wYXJhdG9yPWxhc3QoYXJyYXlzKTtjb21wYXJhdG9yPXR5cGVvZiBjb21wYXJhdG9yPT0nZnVuY3Rpb24nP2NvbXBhcmF0b3I6dW5kZWZpbmVkO3JldHVybiBiYXNlWG9yKGFycmF5RmlsdGVyKGFycmF5cyxpc0FycmF5TGlrZU9iamVjdCksdW5kZWZpbmVkLGNvbXBhcmF0b3IpO30pOy8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgZ3JvdXBlZCBlbGVtZW50cywgdGhlIGZpcnN0IG9mIHdoaWNoIGNvbnRhaW5zIHRoZVxuICAgICAqIGZpcnN0IGVsZW1lbnRzIG9mIHRoZSBnaXZlbiBhcnJheXMsIHRoZSBzZWNvbmQgb2Ygd2hpY2ggY29udGFpbnMgdGhlXG4gICAgICogc2Vjb25kIGVsZW1lbnRzIG9mIHRoZSBnaXZlbiBhcnJheXMsIGFuZCBzbyBvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheXNdIFRoZSBhcnJheXMgdG8gcHJvY2Vzcy5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBncm91cGVkIGVsZW1lbnRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnppcChbJ2EnLCAnYiddLCBbMSwgMl0sIFt0cnVlLCBmYWxzZV0pO1xuICAgICAqIC8vID0+IFtbJ2EnLCAxLCB0cnVlXSwgWydiJywgMiwgZmFsc2VdXVxuICAgICAqL3ZhciB6aXA9YmFzZVJlc3QodW56aXApOy8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZnJvbVBhaXJzYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIHR3byBhcnJheXMsXG4gICAgICogb25lIG9mIHByb3BlcnR5IGlkZW50aWZpZXJzIGFuZCBvbmUgb2YgY29ycmVzcG9uZGluZyB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC40LjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcHJvcHM9W11dIFRoZSBwcm9wZXJ0eSBpZGVudGlmaWVycy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbdmFsdWVzPVtdXSBUaGUgcHJvcGVydHkgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uemlwT2JqZWN0KFsnYScsICdiJ10sIFsxLCAyXSk7XG4gICAgICogLy8gPT4geyAnYSc6IDEsICdiJzogMiB9XG4gICAgICovZnVuY3Rpb24gemlwT2JqZWN0KHByb3BzLHZhbHVlcyl7cmV0dXJuIGJhc2VaaXBPYmplY3QocHJvcHN8fFtdLHZhbHVlc3x8W10sYXNzaWduVmFsdWUpO30vKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnppcE9iamVjdGAgZXhjZXB0IHRoYXQgaXQgc3VwcG9ydHMgcHJvcGVydHkgcGF0aHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcHJvcHM9W11dIFRoZSBwcm9wZXJ0eSBpZGVudGlmaWVycy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbdmFsdWVzPVtdXSBUaGUgcHJvcGVydHkgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uemlwT2JqZWN0RGVlcChbJ2EuYlswXS5jJywgJ2EuYlsxXS5kJ10sIFsxLCAyXSk7XG4gICAgICogLy8gPT4geyAnYSc6IHsgJ2InOiBbeyAnYyc6IDEgfSwgeyAnZCc6IDIgfV0gfSB9XG4gICAgICovZnVuY3Rpb24gemlwT2JqZWN0RGVlcChwcm9wcyx2YWx1ZXMpe3JldHVybiBiYXNlWmlwT2JqZWN0KHByb3BzfHxbXSx2YWx1ZXN8fFtdLGJhc2VTZXQpO30vKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnppcGAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgIHRvIHNwZWNpZnlcbiAgICAgKiBob3cgZ3JvdXBlZCB2YWx1ZXMgc2hvdWxkIGJlIGNvbWJpbmVkLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIHRoZVxuICAgICAqIGVsZW1lbnRzIG9mIGVhY2ggZ3JvdXA6ICguLi5ncm91cCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy44LjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXlzXSBUaGUgYXJyYXlzIHRvIHByb2Nlc3MuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiB0byBjb21iaW5lXG4gICAgICogIGdyb3VwZWQgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGdyb3VwZWQgZWxlbWVudHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uemlwV2l0aChbMSwgMl0sIFsxMCwgMjBdLCBbMTAwLCAyMDBdLCBmdW5jdGlvbihhLCBiLCBjKSB7XG4gICAgICogICByZXR1cm4gYSArIGIgKyBjO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IFsxMTEsIDIyMl1cbiAgICAgKi92YXIgemlwV2l0aD1iYXNlUmVzdChmdW5jdGlvbihhcnJheXMpe3ZhciBsZW5ndGg9YXJyYXlzLmxlbmd0aCxpdGVyYXRlZT1sZW5ndGg+MT9hcnJheXNbbGVuZ3RoLTFdOnVuZGVmaW5lZDtpdGVyYXRlZT10eXBlb2YgaXRlcmF0ZWU9PSdmdW5jdGlvbic/KGFycmF5cy5wb3AoKSxpdGVyYXRlZSk6dW5kZWZpbmVkO3JldHVybiB1bnppcFdpdGgoYXJyYXlzLGl0ZXJhdGVlKTt9KTsvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovLyoqXG4gICAgICogQ3JlYXRlcyBhIGBsb2Rhc2hgIHdyYXBwZXIgaW5zdGFuY2UgdGhhdCB3cmFwcyBgdmFsdWVgIHdpdGggZXhwbGljaXQgbWV0aG9kXG4gICAgICogY2hhaW4gc2VxdWVuY2VzIGVuYWJsZWQuIFRoZSByZXN1bHQgb2Ygc3VjaCBzZXF1ZW5jZXMgbXVzdCBiZSB1bndyYXBwZWRcbiAgICAgKiB3aXRoIGBfI3ZhbHVlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAxLjMuMFxuICAgICAqIEBjYXRlZ29yeSBTZXFcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byB3cmFwLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBgbG9kYXNoYCB3cmFwcGVyIGluc3RhbmNlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICAnYWdlJzogMzYgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhZ2UnOiA0MCB9LFxuICAgICAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FnZSc6IDEgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiB2YXIgeW91bmdlc3QgPSBfXG4gICAgICogICAuY2hhaW4odXNlcnMpXG4gICAgICogICAuc29ydEJ5KCdhZ2UnKVxuICAgICAqICAgLm1hcChmdW5jdGlvbihvKSB7XG4gICAgICogICAgIHJldHVybiBvLnVzZXIgKyAnIGlzICcgKyBvLmFnZTtcbiAgICAgKiAgIH0pXG4gICAgICogICAuaGVhZCgpXG4gICAgICogICAudmFsdWUoKTtcbiAgICAgKiAvLyA9PiAncGViYmxlcyBpcyAxJ1xuICAgICAqL2Z1bmN0aW9uIGNoYWluKHZhbHVlKXt2YXIgcmVzdWx0PWxvZGFzaCh2YWx1ZSk7cmVzdWx0Ll9fY2hhaW5fXz10cnVlO3JldHVybiByZXN1bHQ7fS8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGludm9rZXMgYGludGVyY2VwdG9yYCBhbmQgcmV0dXJucyBgdmFsdWVgLiBUaGUgaW50ZXJjZXB0b3JcbiAgICAgKiBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OyAodmFsdWUpLiBUaGUgcHVycG9zZSBvZiB0aGlzIG1ldGhvZCBpcyB0b1xuICAgICAqIFwidGFwIGludG9cIiBhIG1ldGhvZCBjaGFpbiBzZXF1ZW5jZSBpbiBvcmRlciB0byBtb2RpZnkgaW50ZXJtZWRpYXRlIHJlc3VsdHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgU2VxXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvdmlkZSB0byBgaW50ZXJjZXB0b3JgLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGludGVyY2VwdG9yIFRoZSBmdW5jdGlvbiB0byBpbnZva2UuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgYHZhbHVlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXyhbMSwgMiwgM10pXG4gICAgICogIC50YXAoZnVuY3Rpb24oYXJyYXkpIHtcbiAgICAgKiAgICAvLyBNdXRhdGUgaW5wdXQgYXJyYXkuXG4gICAgICogICAgYXJyYXkucG9wKCk7XG4gICAgICogIH0pXG4gICAgICogIC5yZXZlcnNlKClcbiAgICAgKiAgLnZhbHVlKCk7XG4gICAgICogLy8gPT4gWzIsIDFdXG4gICAgICovZnVuY3Rpb24gdGFwKHZhbHVlLGludGVyY2VwdG9yKXtpbnRlcmNlcHRvcih2YWx1ZSk7cmV0dXJuIHZhbHVlO30vKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnRhcGAgZXhjZXB0IHRoYXQgaXQgcmV0dXJucyB0aGUgcmVzdWx0IG9mIGBpbnRlcmNlcHRvcmAuXG4gICAgICogVGhlIHB1cnBvc2Ugb2YgdGhpcyBtZXRob2QgaXMgdG8gXCJwYXNzIHRocnVcIiB2YWx1ZXMgcmVwbGFjaW5nIGludGVybWVkaWF0ZVxuICAgICAqIHJlc3VsdHMgaW4gYSBtZXRob2QgY2hhaW4gc2VxdWVuY2UuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU2VxXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvdmlkZSB0byBgaW50ZXJjZXB0b3JgLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGludGVyY2VwdG9yIFRoZSBmdW5jdGlvbiB0byBpbnZva2UuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc3VsdCBvZiBgaW50ZXJjZXB0b3JgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfKCcgIGFiYyAgJylcbiAgICAgKiAgLmNoYWluKClcbiAgICAgKiAgLnRyaW0oKVxuICAgICAqICAudGhydShmdW5jdGlvbih2YWx1ZSkge1xuICAgICAqICAgIHJldHVybiBbdmFsdWVdO1xuICAgICAqICB9KVxuICAgICAqICAudmFsdWUoKTtcbiAgICAgKiAvLyA9PiBbJ2FiYyddXG4gICAgICovZnVuY3Rpb24gdGhydSh2YWx1ZSxpbnRlcmNlcHRvcil7cmV0dXJuIGludGVyY2VwdG9yKHZhbHVlKTt9LyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgdGhlIHdyYXBwZXIgdmVyc2lvbiBvZiBgXy5hdGAuXG4gICAgICpcbiAgICAgKiBAbmFtZSBhdFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDEuMC4wXG4gICAgICogQGNhdGVnb3J5IFNlcVxuICAgICAqIEBwYXJhbSB7Li4uKHN0cmluZ3xzdHJpbmdbXSl9IFtwYXRoc10gVGhlIHByb3BlcnR5IHBhdGhzIHRvIHBpY2suXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IGBsb2Rhc2hgIHdyYXBwZXIgaW5zdGFuY2UuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogW3sgJ2InOiB7ICdjJzogMyB9IH0sIDRdIH07XG4gICAgICpcbiAgICAgKiBfKG9iamVjdCkuYXQoWydhWzBdLmIuYycsICdhWzFdJ10pLnZhbHVlKCk7XG4gICAgICogLy8gPT4gWzMsIDRdXG4gICAgICovdmFyIHdyYXBwZXJBdD1mbGF0UmVzdChmdW5jdGlvbihwYXRocyl7dmFyIGxlbmd0aD1wYXRocy5sZW5ndGgsc3RhcnQ9bGVuZ3RoP3BhdGhzWzBdOjAsdmFsdWU9dGhpcy5fX3dyYXBwZWRfXyxpbnRlcmNlcHRvcj1mdW5jdGlvbihvYmplY3Qpe3JldHVybiBiYXNlQXQob2JqZWN0LHBhdGhzKTt9O2lmKGxlbmd0aD4xfHx0aGlzLl9fYWN0aW9uc19fLmxlbmd0aHx8ISh2YWx1ZSBpbnN0YW5jZW9mIExhenlXcmFwcGVyKXx8IWlzSW5kZXgoc3RhcnQpKXtyZXR1cm4gdGhpcy50aHJ1KGludGVyY2VwdG9yKTt9dmFsdWU9dmFsdWUuc2xpY2Uoc3RhcnQsK3N0YXJ0KyhsZW5ndGg/MTowKSk7dmFsdWUuX19hY3Rpb25zX18ucHVzaCh7J2Z1bmMnOnRocnUsJ2FyZ3MnOltpbnRlcmNlcHRvcl0sJ3RoaXNBcmcnOnVuZGVmaW5lZH0pO3JldHVybiBuZXcgTG9kYXNoV3JhcHBlcih2YWx1ZSx0aGlzLl9fY2hhaW5fXykudGhydShmdW5jdGlvbihhcnJheSl7aWYobGVuZ3RoJiYhYXJyYXkubGVuZ3RoKXthcnJheS5wdXNoKHVuZGVmaW5lZCk7fXJldHVybiBhcnJheTt9KTt9KTsvKipcbiAgICAgKiBDcmVhdGVzIGEgYGxvZGFzaGAgd3JhcHBlciBpbnN0YW5jZSB3aXRoIGV4cGxpY2l0IG1ldGhvZCBjaGFpbiBzZXF1ZW5jZXMgZW5hYmxlZC5cbiAgICAgKlxuICAgICAqIEBuYW1lIGNoYWluXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgU2VxXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IGBsb2Rhc2hgIHdyYXBwZXIgaW5zdGFuY2UuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2IH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIEEgc2VxdWVuY2Ugd2l0aG91dCBleHBsaWNpdCBjaGFpbmluZy5cbiAgICAgKiBfKHVzZXJzKS5oZWFkKCk7XG4gICAgICogLy8gPT4geyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYgfVxuICAgICAqXG4gICAgICogLy8gQSBzZXF1ZW5jZSB3aXRoIGV4cGxpY2l0IGNoYWluaW5nLlxuICAgICAqIF8odXNlcnMpXG4gICAgICogICAuY2hhaW4oKVxuICAgICAqICAgLmhlYWQoKVxuICAgICAqICAgLnBpY2soJ3VzZXInKVxuICAgICAqICAgLnZhbHVlKCk7XG4gICAgICogLy8gPT4geyAndXNlcic6ICdiYXJuZXknIH1cbiAgICAgKi9mdW5jdGlvbiB3cmFwcGVyQ2hhaW4oKXtyZXR1cm4gY2hhaW4odGhpcyk7fS8qKlxuICAgICAqIEV4ZWN1dGVzIHRoZSBjaGFpbiBzZXF1ZW5jZSBhbmQgcmV0dXJucyB0aGUgd3JhcHBlZCByZXN1bHQuXG4gICAgICpcbiAgICAgKiBAbmFtZSBjb21taXRcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjIuMFxuICAgICAqIEBjYXRlZ29yeSBTZXFcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgYGxvZGFzaGAgd3JhcHBlciBpbnN0YW5jZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWzEsIDJdO1xuICAgICAqIHZhciB3cmFwcGVkID0gXyhhcnJheSkucHVzaCgzKTtcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbMSwgMl1cbiAgICAgKlxuICAgICAqIHdyYXBwZWQgPSB3cmFwcGVkLmNvbW1pdCgpO1xuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKlxuICAgICAqIHdyYXBwZWQubGFzdCgpO1xuICAgICAqIC8vID0+IDNcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKi9mdW5jdGlvbiB3cmFwcGVyQ29tbWl0KCl7cmV0dXJuIG5ldyBMb2Rhc2hXcmFwcGVyKHRoaXMudmFsdWUoKSx0aGlzLl9fY2hhaW5fXyk7fS8qKlxuICAgICAqIEdldHMgdGhlIG5leHQgdmFsdWUgb24gYSB3cmFwcGVkIG9iamVjdCBmb2xsb3dpbmcgdGhlXG4gICAgICogW2l0ZXJhdG9yIHByb3RvY29sXShodHRwczovL21kbi5pby9pdGVyYXRpb25fcHJvdG9jb2xzI2l0ZXJhdG9yKS5cbiAgICAgKlxuICAgICAqIEBuYW1lIG5leHRcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBTZXFcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXh0IGl0ZXJhdG9yIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgd3JhcHBlZCA9IF8oWzEsIDJdKTtcbiAgICAgKlxuICAgICAqIHdyYXBwZWQubmV4dCgpO1xuICAgICAqIC8vID0+IHsgJ2RvbmUnOiBmYWxzZSwgJ3ZhbHVlJzogMSB9XG4gICAgICpcbiAgICAgKiB3cmFwcGVkLm5leHQoKTtcbiAgICAgKiAvLyA9PiB7ICdkb25lJzogZmFsc2UsICd2YWx1ZSc6IDIgfVxuICAgICAqXG4gICAgICogd3JhcHBlZC5uZXh0KCk7XG4gICAgICogLy8gPT4geyAnZG9uZSc6IHRydWUsICd2YWx1ZSc6IHVuZGVmaW5lZCB9XG4gICAgICovZnVuY3Rpb24gd3JhcHBlck5leHQoKXtpZih0aGlzLl9fdmFsdWVzX189PT11bmRlZmluZWQpe3RoaXMuX192YWx1ZXNfXz10b0FycmF5KHRoaXMudmFsdWUoKSk7fXZhciBkb25lPXRoaXMuX19pbmRleF9fPj10aGlzLl9fdmFsdWVzX18ubGVuZ3RoLHZhbHVlPWRvbmU/dW5kZWZpbmVkOnRoaXMuX192YWx1ZXNfX1t0aGlzLl9faW5kZXhfXysrXTtyZXR1cm57J2RvbmUnOmRvbmUsJ3ZhbHVlJzp2YWx1ZX07fS8qKlxuICAgICAqIEVuYWJsZXMgdGhlIHdyYXBwZXIgdG8gYmUgaXRlcmFibGUuXG4gICAgICpcbiAgICAgKiBAbmFtZSBTeW1ib2wuaXRlcmF0b3JcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBTZXFcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSB3cmFwcGVyIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHdyYXBwZWQgPSBfKFsxLCAyXSk7XG4gICAgICpcbiAgICAgKiB3cmFwcGVkW1N5bWJvbC5pdGVyYXRvcl0oKSA9PT0gd3JhcHBlZDtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBBcnJheS5mcm9tKHdyYXBwZWQpO1xuICAgICAqIC8vID0+IFsxLCAyXVxuICAgICAqL2Z1bmN0aW9uIHdyYXBwZXJUb0l0ZXJhdG9yKCl7cmV0dXJuIHRoaXM7fS8qKlxuICAgICAqIENyZWF0ZXMgYSBjbG9uZSBvZiB0aGUgY2hhaW4gc2VxdWVuY2UgcGxhbnRpbmcgYHZhbHVlYCBhcyB0aGUgd3JhcHBlZCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBuYW1lIHBsYW50XG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4yLjBcbiAgICAgKiBAY2F0ZWdvcnkgU2VxXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcGxhbnQuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IGBsb2Rhc2hgIHdyYXBwZXIgaW5zdGFuY2UuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIHNxdWFyZShuKSB7XG4gICAgICogICByZXR1cm4gbiAqIG47XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIHdyYXBwZWQgPSBfKFsxLCAyXSkubWFwKHNxdWFyZSk7XG4gICAgICogdmFyIG90aGVyID0gd3JhcHBlZC5wbGFudChbMywgNF0pO1xuICAgICAqXG4gICAgICogb3RoZXIudmFsdWUoKTtcbiAgICAgKiAvLyA9PiBbOSwgMTZdXG4gICAgICpcbiAgICAgKiB3cmFwcGVkLnZhbHVlKCk7XG4gICAgICogLy8gPT4gWzEsIDRdXG4gICAgICovZnVuY3Rpb24gd3JhcHBlclBsYW50KHZhbHVlKXt2YXIgcmVzdWx0LHBhcmVudD10aGlzO3doaWxlKHBhcmVudCBpbnN0YW5jZW9mIGJhc2VMb2Rhc2gpe3ZhciBjbG9uZT13cmFwcGVyQ2xvbmUocGFyZW50KTtjbG9uZS5fX2luZGV4X189MDtjbG9uZS5fX3ZhbHVlc19fPXVuZGVmaW5lZDtpZihyZXN1bHQpe3ByZXZpb3VzLl9fd3JhcHBlZF9fPWNsb25lO31lbHNle3Jlc3VsdD1jbG9uZTt9dmFyIHByZXZpb3VzPWNsb25lO3BhcmVudD1wYXJlbnQuX193cmFwcGVkX187fXByZXZpb3VzLl9fd3JhcHBlZF9fPXZhbHVlO3JldHVybiByZXN1bHQ7fS8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIHRoZSB3cmFwcGVyIHZlcnNpb24gb2YgYF8ucmV2ZXJzZWAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyB0aGUgd3JhcHBlZCBhcnJheS5cbiAgICAgKlxuICAgICAqIEBuYW1lIHJldmVyc2VcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBTZXFcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgYGxvZGFzaGAgd3JhcHBlciBpbnN0YW5jZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWzEsIDIsIDNdO1xuICAgICAqXG4gICAgICogXyhhcnJheSkucmV2ZXJzZSgpLnZhbHVlKClcbiAgICAgKiAvLyA9PiBbMywgMiwgMV1cbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbMywgMiwgMV1cbiAgICAgKi9mdW5jdGlvbiB3cmFwcGVyUmV2ZXJzZSgpe3ZhciB2YWx1ZT10aGlzLl9fd3JhcHBlZF9fO2lmKHZhbHVlIGluc3RhbmNlb2YgTGF6eVdyYXBwZXIpe3ZhciB3cmFwcGVkPXZhbHVlO2lmKHRoaXMuX19hY3Rpb25zX18ubGVuZ3RoKXt3cmFwcGVkPW5ldyBMYXp5V3JhcHBlcih0aGlzKTt9d3JhcHBlZD13cmFwcGVkLnJldmVyc2UoKTt3cmFwcGVkLl9fYWN0aW9uc19fLnB1c2goeydmdW5jJzp0aHJ1LCdhcmdzJzpbcmV2ZXJzZV0sJ3RoaXNBcmcnOnVuZGVmaW5lZH0pO3JldHVybiBuZXcgTG9kYXNoV3JhcHBlcih3cmFwcGVkLHRoaXMuX19jaGFpbl9fKTt9cmV0dXJuIHRoaXMudGhydShyZXZlcnNlKTt9LyoqXG4gICAgICogRXhlY3V0ZXMgdGhlIGNoYWluIHNlcXVlbmNlIHRvIHJlc29sdmUgdGhlIHVud3JhcHBlZCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBuYW1lIHZhbHVlXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAYWxpYXMgdG9KU09OLCB2YWx1ZU9mXG4gICAgICogQGNhdGVnb3J5IFNlcVxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB1bndyYXBwZWQgdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8oWzEsIDIsIDNdKS52YWx1ZSgpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqL2Z1bmN0aW9uIHdyYXBwZXJWYWx1ZSgpe3JldHVybiBiYXNlV3JhcHBlclZhbHVlKHRoaXMuX193cmFwcGVkX18sdGhpcy5fX2FjdGlvbnNfXyk7fS8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi8vKipcbiAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZiBrZXlzIGdlbmVyYXRlZCBmcm9tIHRoZSByZXN1bHRzIG9mIHJ1bm5pbmdcbiAgICAgKiBlYWNoIGVsZW1lbnQgb2YgYGNvbGxlY3Rpb25gIHRocnUgYGl0ZXJhdGVlYC4gVGhlIGNvcnJlc3BvbmRpbmcgdmFsdWUgb2ZcbiAgICAgKiBlYWNoIGtleSBpcyB0aGUgbnVtYmVyIG9mIHRpbWVzIHRoZSBrZXkgd2FzIHJldHVybmVkIGJ5IGBpdGVyYXRlZWAuIFRoZVxuICAgICAqIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC41LjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIHRvIHRyYW5zZm9ybSBrZXlzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNvbXBvc2VkIGFnZ3JlZ2F0ZSBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uY291bnRCeShbNi4xLCA0LjIsIDYuM10sIE1hdGguZmxvb3IpO1xuICAgICAqIC8vID0+IHsgJzQnOiAxLCAnNic6IDIgfVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5jb3VudEJ5KFsnb25lJywgJ3R3bycsICd0aHJlZSddLCAnbGVuZ3RoJyk7XG4gICAgICogLy8gPT4geyAnMyc6IDIsICc1JzogMSB9XG4gICAgICovdmFyIGNvdW50Qnk9Y3JlYXRlQWdncmVnYXRvcihmdW5jdGlvbihyZXN1bHQsdmFsdWUsa2V5KXtpZihoYXNPd25Qcm9wZXJ0eS5jYWxsKHJlc3VsdCxrZXkpKXsrK3Jlc3VsdFtrZXldO31lbHNle2Jhc2VBc3NpZ25WYWx1ZShyZXN1bHQsa2V5LDEpO319KTsvKipcbiAgICAgKiBDaGVja3MgaWYgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yICoqYWxsKiogZWxlbWVudHMgb2YgYGNvbGxlY3Rpb25gLlxuICAgICAqIEl0ZXJhdGlvbiBpcyBzdG9wcGVkIG9uY2UgYHByZWRpY2F0ZWAgcmV0dXJucyBmYWxzZXkuIFRoZSBwcmVkaWNhdGUgaXNcbiAgICAgKiBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgcmV0dXJucyBgdHJ1ZWAgZm9yXG4gICAgICogW2VtcHR5IGNvbGxlY3Rpb25zXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9FbXB0eV9zZXQpIGJlY2F1c2VcbiAgICAgKiBbZXZlcnl0aGluZyBpcyB0cnVlXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9WYWN1b3VzX3RydXRoKSBvZlxuICAgICAqIGVsZW1lbnRzIG9mIGVtcHR5IGNvbGxlY3Rpb25zLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFsbCBlbGVtZW50cyBwYXNzIHRoZSBwcmVkaWNhdGUgY2hlY2ssXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5ldmVyeShbdHJ1ZSwgMSwgbnVsbCwgJ3llcyddLCBCb29sZWFuKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYsICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDAsICdhY3RpdmUnOiBmYWxzZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5ldmVyeSh1c2VycywgeyAndXNlcic6ICdiYXJuZXknLCAnYWN0aXZlJzogZmFsc2UgfSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmV2ZXJ5KHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5ldmVyeSh1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovZnVuY3Rpb24gZXZlcnkoY29sbGVjdGlvbixwcmVkaWNhdGUsZ3VhcmQpe3ZhciBmdW5jPWlzQXJyYXkoY29sbGVjdGlvbik/YXJyYXlFdmVyeTpiYXNlRXZlcnk7aWYoZ3VhcmQmJmlzSXRlcmF0ZWVDYWxsKGNvbGxlY3Rpb24scHJlZGljYXRlLGd1YXJkKSl7cHJlZGljYXRlPXVuZGVmaW5lZDt9cmV0dXJuIGZ1bmMoY29sbGVjdGlvbixnZXRJdGVyYXRlZShwcmVkaWNhdGUsMykpO30vKipcbiAgICAgKiBJdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mIGBjb2xsZWN0aW9uYCwgcmV0dXJuaW5nIGFuIGFycmF5IG9mIGFsbCBlbGVtZW50c1xuICAgICAqIGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvci4gVGhlIHByZWRpY2F0ZSBpcyBpbnZva2VkIHdpdGggdGhyZWVcbiAgICAgKiBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBVbmxpa2UgYF8ucmVtb3ZlYCwgdGhpcyBtZXRob2QgcmV0dXJucyBhIG5ldyBhcnJheS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmaWx0ZXJlZCBhcnJheS5cbiAgICAgKiBAc2VlIF8ucmVqZWN0XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2LCAnYWN0aXZlJzogdHJ1ZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDAsICdhY3RpdmUnOiBmYWxzZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8uZmlsdGVyKHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiAhby5hY3RpdmU7IH0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnZnJlZCddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmlsdGVyKHVzZXJzLCB7ICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydiYXJuZXknXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmlsdGVyKHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydmcmVkJ11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmlsdGVyKHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydiYXJuZXknXVxuICAgICAqL2Z1bmN0aW9uIGZpbHRlcihjb2xsZWN0aW9uLHByZWRpY2F0ZSl7dmFyIGZ1bmM9aXNBcnJheShjb2xsZWN0aW9uKT9hcnJheUZpbHRlcjpiYXNlRmlsdGVyO3JldHVybiBmdW5jKGNvbGxlY3Rpb24sZ2V0SXRlcmF0ZWUocHJlZGljYXRlLDMpKTt9LyoqXG4gICAgICogSXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZiBgY29sbGVjdGlvbmAsIHJldHVybmluZyB0aGUgZmlyc3QgZWxlbWVudFxuICAgICAqIGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvci4gVGhlIHByZWRpY2F0ZSBpcyBpbnZva2VkIHdpdGggdGhyZWVcbiAgICAgKiBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtmcm9tSW5kZXg9MF0gVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXRjaGVkIGVsZW1lbnQsIGVsc2UgYHVuZGVmaW5lZGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWdlJzogMSwgICdhY3RpdmUnOiB0cnVlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5maW5kKHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLmFnZSA8IDQwOyB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3QgZm9yICdiYXJuZXknXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmluZCh1c2VycywgeyAnYWdlJzogMSwgJ2FjdGl2ZSc6IHRydWUgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0IGZvciAncGViYmxlcydcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbmQodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiBvYmplY3QgZm9yICdmcmVkJ1xuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maW5kKHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gb2JqZWN0IGZvciAnYmFybmV5J1xuICAgICAqL3ZhciBmaW5kPWNyZWF0ZUZpbmQoZmluZEluZGV4KTsvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZpbmRgIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2ZcbiAgICAgKiBgY29sbGVjdGlvbmAgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuMC4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2Zyb21JbmRleD1jb2xsZWN0aW9uLmxlbmd0aC0xXSBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1hdGNoZWQgZWxlbWVudCwgZWxzZSBgdW5kZWZpbmVkYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5maW5kTGFzdChbMSwgMiwgMywgNF0sIGZ1bmN0aW9uKG4pIHtcbiAgICAgKiAgIHJldHVybiBuICUgMiA9PSAxO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IDNcbiAgICAgKi92YXIgZmluZExhc3Q9Y3JlYXRlRmluZChmaW5kTGFzdEluZGV4KTsvKipcbiAgICAgKiBDcmVhdGVzIGEgZmxhdHRlbmVkIGFycmF5IG9mIHZhbHVlcyBieSBydW5uaW5nIGVhY2ggZWxlbWVudCBpbiBgY29sbGVjdGlvbmBcbiAgICAgKiB0aHJ1IGBpdGVyYXRlZWAgYW5kIGZsYXR0ZW5pbmcgdGhlIG1hcHBlZCByZXN1bHRzLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZFxuICAgICAqIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmbGF0dGVuZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGR1cGxpY2F0ZShuKSB7XG4gICAgICogICByZXR1cm4gW24sIG5dO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIF8uZmxhdE1hcChbMSwgMl0sIGR1cGxpY2F0ZSk7XG4gICAgICogLy8gPT4gWzEsIDEsIDIsIDJdXG4gICAgICovZnVuY3Rpb24gZmxhdE1hcChjb2xsZWN0aW9uLGl0ZXJhdGVlKXtyZXR1cm4gYmFzZUZsYXR0ZW4obWFwKGNvbGxlY3Rpb24saXRlcmF0ZWUpLDEpO30vKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZsYXRNYXBgIGV4Y2VwdCB0aGF0IGl0IHJlY3Vyc2l2ZWx5IGZsYXR0ZW5zIHRoZVxuICAgICAqIG1hcHBlZCByZXN1bHRzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuNy4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBkdXBsaWNhdGUobikge1xuICAgICAqICAgcmV0dXJuIFtbW24sIG5dXV07XG4gICAgICogfVxuICAgICAqXG4gICAgICogXy5mbGF0TWFwRGVlcChbMSwgMl0sIGR1cGxpY2F0ZSk7XG4gICAgICogLy8gPT4gWzEsIDEsIDIsIDJdXG4gICAgICovZnVuY3Rpb24gZmxhdE1hcERlZXAoY29sbGVjdGlvbixpdGVyYXRlZSl7cmV0dXJuIGJhc2VGbGF0dGVuKG1hcChjb2xsZWN0aW9uLGl0ZXJhdGVlKSxJTkZJTklUWSk7fS8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZmxhdE1hcGAgZXhjZXB0IHRoYXQgaXQgcmVjdXJzaXZlbHkgZmxhdHRlbnMgdGhlXG4gICAgICogbWFwcGVkIHJlc3VsdHMgdXAgdG8gYGRlcHRoYCB0aW1lcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjcuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZGVwdGg9MV0gVGhlIG1heGltdW0gcmVjdXJzaW9uIGRlcHRoLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZsYXR0ZW5lZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gZHVwbGljYXRlKG4pIHtcbiAgICAgKiAgIHJldHVybiBbW1tuLCBuXV1dO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIF8uZmxhdE1hcERlcHRoKFsxLCAyXSwgZHVwbGljYXRlLCAyKTtcbiAgICAgKiAvLyA9PiBbWzEsIDFdLCBbMiwgMl1dXG4gICAgICovZnVuY3Rpb24gZmxhdE1hcERlcHRoKGNvbGxlY3Rpb24saXRlcmF0ZWUsZGVwdGgpe2RlcHRoPWRlcHRoPT09dW5kZWZpbmVkPzE6dG9JbnRlZ2VyKGRlcHRoKTtyZXR1cm4gYmFzZUZsYXR0ZW4obWFwKGNvbGxlY3Rpb24saXRlcmF0ZWUpLGRlcHRoKTt9LyoqXG4gICAgICogSXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZiBgY29sbGVjdGlvbmAgYW5kIGludm9rZXMgYGl0ZXJhdGVlYCBmb3IgZWFjaCBlbGVtZW50LlxuICAgICAqIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICogSXRlcmF0ZWUgZnVuY3Rpb25zIG1heSBleGl0IGl0ZXJhdGlvbiBlYXJseSBieSBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIEFzIHdpdGggb3RoZXIgXCJDb2xsZWN0aW9uc1wiIG1ldGhvZHMsIG9iamVjdHMgd2l0aCBhIFwibGVuZ3RoXCJcbiAgICAgKiBwcm9wZXJ0eSBhcmUgaXRlcmF0ZWQgbGlrZSBhcnJheXMuIFRvIGF2b2lkIHRoaXMgYmVoYXZpb3IgdXNlIGBfLmZvckluYFxuICAgICAqIG9yIGBfLmZvck93bmAgZm9yIG9iamVjdCBpdGVyYXRpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAYWxpYXMgZWFjaFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheXxPYmplY3R9IFJldHVybnMgYGNvbGxlY3Rpb25gLlxuICAgICAqIEBzZWUgXy5mb3JFYWNoUmlnaHRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5mb3JFYWNoKFsxLCAyXSwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKHZhbHVlKTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBMb2dzIGAxYCB0aGVuIGAyYC5cbiAgICAgKlxuICAgICAqIF8uZm9yRWFjaCh7ICdhJzogMSwgJ2InOiAyIH0sIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKGtleSk7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gTG9ncyAnYScgdGhlbiAnYicgKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZCkuXG4gICAgICovZnVuY3Rpb24gZm9yRWFjaChjb2xsZWN0aW9uLGl0ZXJhdGVlKXt2YXIgZnVuYz1pc0FycmF5KGNvbGxlY3Rpb24pP2FycmF5RWFjaDpiYXNlRWFjaDtyZXR1cm4gZnVuYyhjb2xsZWN0aW9uLGdldEl0ZXJhdGVlKGl0ZXJhdGVlLDMpKTt9LyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5mb3JFYWNoYCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mXG4gICAgICogYGNvbGxlY3Rpb25gIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjAuMFxuICAgICAqIEBhbGlhcyBlYWNoUmlnaHRcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl8T2JqZWN0fSBSZXR1cm5zIGBjb2xsZWN0aW9uYC5cbiAgICAgKiBAc2VlIF8uZm9yRWFjaFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmZvckVhY2hSaWdodChbMSwgMl0sIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICogICBjb25zb2xlLmxvZyh2YWx1ZSk7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gTG9ncyBgMmAgdGhlbiBgMWAuXG4gICAgICovZnVuY3Rpb24gZm9yRWFjaFJpZ2h0KGNvbGxlY3Rpb24saXRlcmF0ZWUpe3ZhciBmdW5jPWlzQXJyYXkoY29sbGVjdGlvbik/YXJyYXlFYWNoUmlnaHQ6YmFzZUVhY2hSaWdodDtyZXR1cm4gZnVuYyhjb2xsZWN0aW9uLGdldEl0ZXJhdGVlKGl0ZXJhdGVlLDMpKTt9LyoqXG4gICAgICogQ3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgb2Yga2V5cyBnZW5lcmF0ZWQgZnJvbSB0aGUgcmVzdWx0cyBvZiBydW5uaW5nXG4gICAgICogZWFjaCBlbGVtZW50IG9mIGBjb2xsZWN0aW9uYCB0aHJ1IGBpdGVyYXRlZWAuIFRoZSBvcmRlciBvZiBncm91cGVkIHZhbHVlc1xuICAgICAqIGlzIGRldGVybWluZWQgYnkgdGhlIG9yZGVyIHRoZXkgb2NjdXIgaW4gYGNvbGxlY3Rpb25gLiBUaGUgY29ycmVzcG9uZGluZ1xuICAgICAqIHZhbHVlIG9mIGVhY2gga2V5IGlzIGFuIGFycmF5IG9mIGVsZW1lbnRzIHJlc3BvbnNpYmxlIGZvciBnZW5lcmF0aW5nIHRoZVxuICAgICAqIGtleS4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIHRvIHRyYW5zZm9ybSBrZXlzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNvbXBvc2VkIGFnZ3JlZ2F0ZSBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZ3JvdXBCeShbNi4xLCA0LjIsIDYuM10sIE1hdGguZmxvb3IpO1xuICAgICAqIC8vID0+IHsgJzQnOiBbNC4yXSwgJzYnOiBbNi4xLCA2LjNdIH1cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZ3JvdXBCeShbJ29uZScsICd0d28nLCAndGhyZWUnXSwgJ2xlbmd0aCcpO1xuICAgICAqIC8vID0+IHsgJzMnOiBbJ29uZScsICd0d28nXSwgJzUnOiBbJ3RocmVlJ10gfVxuICAgICAqL3ZhciBncm91cEJ5PWNyZWF0ZUFnZ3JlZ2F0b3IoZnVuY3Rpb24ocmVzdWx0LHZhbHVlLGtleSl7aWYoaGFzT3duUHJvcGVydHkuY2FsbChyZXN1bHQsa2V5KSl7cmVzdWx0W2tleV0ucHVzaCh2YWx1ZSk7fWVsc2V7YmFzZUFzc2lnblZhbHVlKHJlc3VsdCxrZXksW3ZhbHVlXSk7fX0pOy8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGluIGBjb2xsZWN0aW9uYC4gSWYgYGNvbGxlY3Rpb25gIGlzIGEgc3RyaW5nLCBpdCdzXG4gICAgICogY2hlY2tlZCBmb3IgYSBzdWJzdHJpbmcgb2YgYHZhbHVlYCwgb3RoZXJ3aXNlXG4gICAgICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAgICAgKiBpcyB1c2VkIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy4gSWYgYGZyb21JbmRleGAgaXMgbmVnYXRpdmUsIGl0J3MgdXNlZCBhc1xuICAgICAqIHRoZSBvZmZzZXQgZnJvbSB0aGUgZW5kIG9mIGBjb2xsZWN0aW9uYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2Zyb21JbmRleD0wXSBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ucmVkdWNlYC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmluY2x1ZGVzKFsxLCAyLCAzXSwgMSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pbmNsdWRlcyhbMSwgMiwgM10sIDEsIDIpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmluY2x1ZGVzKHsgJ2EnOiAxLCAnYic6IDIgfSwgMSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pbmNsdWRlcygnYWJjZCcsICdiYycpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9mdW5jdGlvbiBpbmNsdWRlcyhjb2xsZWN0aW9uLHZhbHVlLGZyb21JbmRleCxndWFyZCl7Y29sbGVjdGlvbj1pc0FycmF5TGlrZShjb2xsZWN0aW9uKT9jb2xsZWN0aW9uOnZhbHVlcyhjb2xsZWN0aW9uKTtmcm9tSW5kZXg9ZnJvbUluZGV4JiYhZ3VhcmQ/dG9JbnRlZ2VyKGZyb21JbmRleCk6MDt2YXIgbGVuZ3RoPWNvbGxlY3Rpb24ubGVuZ3RoO2lmKGZyb21JbmRleDwwKXtmcm9tSW5kZXg9bmF0aXZlTWF4KGxlbmd0aCtmcm9tSW5kZXgsMCk7fXJldHVybiBpc1N0cmluZyhjb2xsZWN0aW9uKT9mcm9tSW5kZXg8PWxlbmd0aCYmY29sbGVjdGlvbi5pbmRleE9mKHZhbHVlLGZyb21JbmRleCk+LTE6ISFsZW5ndGgmJmJhc2VJbmRleE9mKGNvbGxlY3Rpb24sdmFsdWUsZnJvbUluZGV4KT4tMTt9LyoqXG4gICAgICogSW52b2tlcyB0aGUgbWV0aG9kIGF0IGBwYXRoYCBvZiBlYWNoIGVsZW1lbnQgaW4gYGNvbGxlY3Rpb25gLCByZXR1cm5pbmdcbiAgICAgKiBhbiBhcnJheSBvZiB0aGUgcmVzdWx0cyBvZiBlYWNoIGludm9rZWQgbWV0aG9kLiBBbnkgYWRkaXRpb25hbCBhcmd1bWVudHNcbiAgICAgKiBhcmUgcHJvdmlkZWQgdG8gZWFjaCBpbnZva2VkIG1ldGhvZC4gSWYgYHBhdGhgIGlzIGEgZnVuY3Rpb24sIGl0J3MgaW52b2tlZFxuICAgICAqIGZvciwgYW5kIGB0aGlzYCBib3VuZCB0bywgZWFjaCBlbGVtZW50IGluIGBjb2xsZWN0aW9uYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7QXJyYXl8RnVuY3Rpb258c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBtZXRob2QgdG8gaW52b2tlIG9yXG4gICAgICogIHRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsuLi4qfSBbYXJnc10gVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgZWFjaCBtZXRob2Qgd2l0aC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHJlc3VsdHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaW52b2tlTWFwKFtbNSwgMSwgN10sIFszLCAyLCAxXV0sICdzb3J0Jyk7XG4gICAgICogLy8gPT4gW1sxLCA1LCA3XSwgWzEsIDIsIDNdXVxuICAgICAqXG4gICAgICogXy5pbnZva2VNYXAoWzEyMywgNDU2XSwgU3RyaW5nLnByb3RvdHlwZS5zcGxpdCwgJycpO1xuICAgICAqIC8vID0+IFtbJzEnLCAnMicsICczJ10sIFsnNCcsICc1JywgJzYnXV1cbiAgICAgKi92YXIgaW52b2tlTWFwPWJhc2VSZXN0KGZ1bmN0aW9uKGNvbGxlY3Rpb24scGF0aCxhcmdzKXt2YXIgaW5kZXg9LTEsaXNGdW5jPXR5cGVvZiBwYXRoPT0nZnVuY3Rpb24nLHJlc3VsdD1pc0FycmF5TGlrZShjb2xsZWN0aW9uKT9BcnJheShjb2xsZWN0aW9uLmxlbmd0aCk6W107YmFzZUVhY2goY29sbGVjdGlvbixmdW5jdGlvbih2YWx1ZSl7cmVzdWx0WysraW5kZXhdPWlzRnVuYz9hcHBseShwYXRoLHZhbHVlLGFyZ3MpOmJhc2VJbnZva2UodmFsdWUscGF0aCxhcmdzKTt9KTtyZXR1cm4gcmVzdWx0O30pOy8qKlxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIGtleXMgZ2VuZXJhdGVkIGZyb20gdGhlIHJlc3VsdHMgb2YgcnVubmluZ1xuICAgICAqIGVhY2ggZWxlbWVudCBvZiBgY29sbGVjdGlvbmAgdGhydSBgaXRlcmF0ZWVgLiBUaGUgY29ycmVzcG9uZGluZyB2YWx1ZSBvZlxuICAgICAqIGVhY2gga2V5IGlzIHRoZSBsYXN0IGVsZW1lbnQgcmVzcG9uc2libGUgZm9yIGdlbmVyYXRpbmcgdGhlIGtleS4gVGhlXG4gICAgICogaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgdG8gdHJhbnNmb3JtIGtleXMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY29tcG9zZWQgYWdncmVnYXRlIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gW1xuICAgICAqICAgeyAnZGlyJzogJ2xlZnQnLCAnY29kZSc6IDk3IH0sXG4gICAgICogICB7ICdkaXInOiAncmlnaHQnLCAnY29kZSc6IDEwMCB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8ua2V5QnkoYXJyYXksIGZ1bmN0aW9uKG8pIHtcbiAgICAgKiAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKG8uY29kZSk7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4geyAnYSc6IHsgJ2Rpcic6ICdsZWZ0JywgJ2NvZGUnOiA5NyB9LCAnZCc6IHsgJ2Rpcic6ICdyaWdodCcsICdjb2RlJzogMTAwIH0gfVxuICAgICAqXG4gICAgICogXy5rZXlCeShhcnJheSwgJ2RpcicpO1xuICAgICAqIC8vID0+IHsgJ2xlZnQnOiB7ICdkaXInOiAnbGVmdCcsICdjb2RlJzogOTcgfSwgJ3JpZ2h0JzogeyAnZGlyJzogJ3JpZ2h0JywgJ2NvZGUnOiAxMDAgfSB9XG4gICAgICovdmFyIGtleUJ5PWNyZWF0ZUFnZ3JlZ2F0b3IoZnVuY3Rpb24ocmVzdWx0LHZhbHVlLGtleSl7YmFzZUFzc2lnblZhbHVlKHJlc3VsdCxrZXksdmFsdWUpO30pOy8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdmFsdWVzIGJ5IHJ1bm5pbmcgZWFjaCBlbGVtZW50IGluIGBjb2xsZWN0aW9uYCB0aHJ1XG4gICAgICogYGl0ZXJhdGVlYC4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6XG4gICAgICogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogTWFueSBsb2Rhc2ggbWV0aG9kcyBhcmUgZ3VhcmRlZCB0byB3b3JrIGFzIGl0ZXJhdGVlcyBmb3IgbWV0aG9kcyBsaWtlXG4gICAgICogYF8uZXZlcnlgLCBgXy5maWx0ZXJgLCBgXy5tYXBgLCBgXy5tYXBWYWx1ZXNgLCBgXy5yZWplY3RgLCBhbmQgYF8uc29tZWAuXG4gICAgICpcbiAgICAgKiBUaGUgZ3VhcmRlZCBtZXRob2RzIGFyZTpcbiAgICAgKiBgYXJ5YCwgYGNodW5rYCwgYGN1cnJ5YCwgYGN1cnJ5UmlnaHRgLCBgZHJvcGAsIGBkcm9wUmlnaHRgLCBgZXZlcnlgLFxuICAgICAqIGBmaWxsYCwgYGludmVydGAsIGBwYXJzZUludGAsIGByYW5kb21gLCBgcmFuZ2VgLCBgcmFuZ2VSaWdodGAsIGByZXBlYXRgLFxuICAgICAqIGBzYW1wbGVTaXplYCwgYHNsaWNlYCwgYHNvbWVgLCBgc29ydEJ5YCwgYHNwbGl0YCwgYHRha2VgLCBgdGFrZVJpZ2h0YCxcbiAgICAgKiBgdGVtcGxhdGVgLCBgdHJpbWAsIGB0cmltRW5kYCwgYHRyaW1TdGFydGAsIGFuZCBgd29yZHNgXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIHNxdWFyZShuKSB7XG4gICAgICogICByZXR1cm4gbiAqIG47XG4gICAgICogfVxuICAgICAqXG4gICAgICogXy5tYXAoWzQsIDhdLCBzcXVhcmUpO1xuICAgICAqIC8vID0+IFsxNiwgNjRdXG4gICAgICpcbiAgICAgKiBfLm1hcCh7ICdhJzogNCwgJ2InOiA4IH0sIHNxdWFyZSk7XG4gICAgICogLy8gPT4gWzE2LCA2NF0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JyB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJyB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8ubWFwKHVzZXJzLCAndXNlcicpO1xuICAgICAqIC8vID0+IFsnYmFybmV5JywgJ2ZyZWQnXVxuICAgICAqL2Z1bmN0aW9uIG1hcChjb2xsZWN0aW9uLGl0ZXJhdGVlKXt2YXIgZnVuYz1pc0FycmF5KGNvbGxlY3Rpb24pP2FycmF5TWFwOmJhc2VNYXA7cmV0dXJuIGZ1bmMoY29sbGVjdGlvbixnZXRJdGVyYXRlZShpdGVyYXRlZSwzKSk7fS8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uc29ydEJ5YCBleGNlcHQgdGhhdCBpdCBhbGxvd3Mgc3BlY2lmeWluZyB0aGUgc29ydFxuICAgICAqIG9yZGVycyBvZiB0aGUgaXRlcmF0ZWVzIHRvIHNvcnQgYnkuIElmIGBvcmRlcnNgIGlzIHVuc3BlY2lmaWVkLCBhbGwgdmFsdWVzXG4gICAgICogYXJlIHNvcnRlZCBpbiBhc2NlbmRpbmcgb3JkZXIuIE90aGVyd2lzZSwgc3BlY2lmeSBhbiBvcmRlciBvZiBcImRlc2NcIiBmb3JcbiAgICAgKiBkZXNjZW5kaW5nIG9yIFwiYXNjXCIgZm9yIGFzY2VuZGluZyBzb3J0IG9yZGVyIG9mIGNvcnJlc3BvbmRpbmcgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtBcnJheVtdfEZ1bmN0aW9uW118T2JqZWN0W118c3RyaW5nW119IFtpdGVyYXRlZXM9W18uaWRlbnRpdHldXVxuICAgICAqICBUaGUgaXRlcmF0ZWVzIHRvIHNvcnQgYnkuXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gW29yZGVyc10gVGhlIHNvcnQgb3JkZXJzIG9mIGBpdGVyYXRlZXNgLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLnJlZHVjZWAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgc29ydGVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0OCB9LFxuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzQgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQwIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIFNvcnQgYnkgYHVzZXJgIGluIGFzY2VuZGluZyBvcmRlciBhbmQgYnkgYGFnZWAgaW4gZGVzY2VuZGluZyBvcmRlci5cbiAgICAgKiBfLm9yZGVyQnkodXNlcnMsIFsndXNlcicsICdhZ2UnXSwgWydhc2MnLCAnZGVzYyddKTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbWydiYXJuZXknLCAzNl0sIFsnYmFybmV5JywgMzRdLCBbJ2ZyZWQnLCA0OF0sIFsnZnJlZCcsIDQwXV1cbiAgICAgKi9mdW5jdGlvbiBvcmRlckJ5KGNvbGxlY3Rpb24saXRlcmF0ZWVzLG9yZGVycyxndWFyZCl7aWYoY29sbGVjdGlvbj09bnVsbCl7cmV0dXJuW107fWlmKCFpc0FycmF5KGl0ZXJhdGVlcykpe2l0ZXJhdGVlcz1pdGVyYXRlZXM9PW51bGw/W106W2l0ZXJhdGVlc107fW9yZGVycz1ndWFyZD91bmRlZmluZWQ6b3JkZXJzO2lmKCFpc0FycmF5KG9yZGVycykpe29yZGVycz1vcmRlcnM9PW51bGw/W106W29yZGVyc107fXJldHVybiBiYXNlT3JkZXJCeShjb2xsZWN0aW9uLGl0ZXJhdGVlcyxvcmRlcnMpO30vKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIGVsZW1lbnRzIHNwbGl0IGludG8gdHdvIGdyb3VwcywgdGhlIGZpcnN0IG9mIHdoaWNoXG4gICAgICogY29udGFpbnMgZWxlbWVudHMgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yLCB0aGUgc2Vjb25kIG9mIHdoaWNoXG4gICAgICogY29udGFpbnMgZWxlbWVudHMgYHByZWRpY2F0ZWAgcmV0dXJucyBmYWxzZXkgZm9yLiBUaGUgcHJlZGljYXRlIGlzXG4gICAgICogaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIGdyb3VwZWQgZWxlbWVudHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWdlJzogNDAsICdhY3RpdmUnOiB0cnVlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWdlJzogMSwgICdhY3RpdmUnOiBmYWxzZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8ucGFydGl0aW9uKHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLmFjdGl2ZTsgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgW1snZnJlZCddLCBbJ2Jhcm5leScsICdwZWJibGVzJ11dXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8ucGFydGl0aW9uKHVzZXJzLCB7ICdhZ2UnOiAxLCAnYWN0aXZlJzogZmFsc2UgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgW1sncGViYmxlcyddLCBbJ2Jhcm5leScsICdmcmVkJ11dXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5wYXJ0aXRpb24odXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbWydiYXJuZXknLCAncGViYmxlcyddLCBbJ2ZyZWQnXV1cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8ucGFydGl0aW9uKHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgW1snZnJlZCddLCBbJ2Jhcm5leScsICdwZWJibGVzJ11dXG4gICAgICovdmFyIHBhcnRpdGlvbj1jcmVhdGVBZ2dyZWdhdG9yKGZ1bmN0aW9uKHJlc3VsdCx2YWx1ZSxrZXkpe3Jlc3VsdFtrZXk/MDoxXS5wdXNoKHZhbHVlKTt9LGZ1bmN0aW9uKCl7cmV0dXJuW1tdLFtdXTt9KTsvKipcbiAgICAgKiBSZWR1Y2VzIGBjb2xsZWN0aW9uYCB0byBhIHZhbHVlIHdoaWNoIGlzIHRoZSBhY2N1bXVsYXRlZCByZXN1bHQgb2YgcnVubmluZ1xuICAgICAqIGVhY2ggZWxlbWVudCBpbiBgY29sbGVjdGlvbmAgdGhydSBgaXRlcmF0ZWVgLCB3aGVyZSBlYWNoIHN1Y2Nlc3NpdmVcbiAgICAgKiBpbnZvY2F0aW9uIGlzIHN1cHBsaWVkIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIHByZXZpb3VzLiBJZiBgYWNjdW11bGF0b3JgXG4gICAgICogaXMgbm90IGdpdmVuLCB0aGUgZmlyc3QgZWxlbWVudCBvZiBgY29sbGVjdGlvbmAgaXMgdXNlZCBhcyB0aGUgaW5pdGlhbFxuICAgICAqIHZhbHVlLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIGZvdXIgYXJndW1lbnRzOlxuICAgICAqIChhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBNYW55IGxvZGFzaCBtZXRob2RzIGFyZSBndWFyZGVkIHRvIHdvcmsgYXMgaXRlcmF0ZWVzIGZvciBtZXRob2RzIGxpa2VcbiAgICAgKiBgXy5yZWR1Y2VgLCBgXy5yZWR1Y2VSaWdodGAsIGFuZCBgXy50cmFuc2Zvcm1gLlxuICAgICAqXG4gICAgICogVGhlIGd1YXJkZWQgbWV0aG9kcyBhcmU6XG4gICAgICogYGFzc2lnbmAsIGBkZWZhdWx0c2AsIGBkZWZhdWx0c0RlZXBgLCBgaW5jbHVkZXNgLCBgbWVyZ2VgLCBgb3JkZXJCeWAsXG4gICAgICogYW5kIGBzb3J0QnlgXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFthY2N1bXVsYXRvcl0gVGhlIGluaXRpYWwgdmFsdWUuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGFjY3VtdWxhdGVkIHZhbHVlLlxuICAgICAqIEBzZWUgXy5yZWR1Y2VSaWdodFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnJlZHVjZShbMSwgMl0sIGZ1bmN0aW9uKHN1bSwgbikge1xuICAgICAqICAgcmV0dXJuIHN1bSArIG47XG4gICAgICogfSwgMCk7XG4gICAgICogLy8gPT4gM1xuICAgICAqXG4gICAgICogXy5yZWR1Y2UoeyAnYSc6IDEsICdiJzogMiwgJ2MnOiAxIH0sIGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgICAqICAgKHJlc3VsdFt2YWx1ZV0gfHwgKHJlc3VsdFt2YWx1ZV0gPSBbXSkpLnB1c2goa2V5KTtcbiAgICAgKiAgIHJldHVybiByZXN1bHQ7XG4gICAgICogfSwge30pO1xuICAgICAqIC8vID0+IHsgJzEnOiBbJ2EnLCAnYyddLCAnMic6IFsnYiddIH0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKi9mdW5jdGlvbiByZWR1Y2UoY29sbGVjdGlvbixpdGVyYXRlZSxhY2N1bXVsYXRvcil7dmFyIGZ1bmM9aXNBcnJheShjb2xsZWN0aW9uKT9hcnJheVJlZHVjZTpiYXNlUmVkdWNlLGluaXRBY2N1bT1hcmd1bWVudHMubGVuZ3RoPDM7cmV0dXJuIGZ1bmMoY29sbGVjdGlvbixnZXRJdGVyYXRlZShpdGVyYXRlZSw0KSxhY2N1bXVsYXRvcixpbml0QWNjdW0sYmFzZUVhY2gpO30vKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnJlZHVjZWAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZlxuICAgICAqIGBjb2xsZWN0aW9uYCBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFthY2N1bXVsYXRvcl0gVGhlIGluaXRpYWwgdmFsdWUuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGFjY3VtdWxhdGVkIHZhbHVlLlxuICAgICAqIEBzZWUgXy5yZWR1Y2VcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gW1swLCAxXSwgWzIsIDNdLCBbNCwgNV1dO1xuICAgICAqXG4gICAgICogXy5yZWR1Y2VSaWdodChhcnJheSwgZnVuY3Rpb24oZmxhdHRlbmVkLCBvdGhlcikge1xuICAgICAqICAgcmV0dXJuIGZsYXR0ZW5lZC5jb25jYXQob3RoZXIpO1xuICAgICAqIH0sIFtdKTtcbiAgICAgKiAvLyA9PiBbNCwgNSwgMiwgMywgMCwgMV1cbiAgICAgKi9mdW5jdGlvbiByZWR1Y2VSaWdodChjb2xsZWN0aW9uLGl0ZXJhdGVlLGFjY3VtdWxhdG9yKXt2YXIgZnVuYz1pc0FycmF5KGNvbGxlY3Rpb24pP2FycmF5UmVkdWNlUmlnaHQ6YmFzZVJlZHVjZSxpbml0QWNjdW09YXJndW1lbnRzLmxlbmd0aDwzO3JldHVybiBmdW5jKGNvbGxlY3Rpb24sZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsNCksYWNjdW11bGF0b3IsaW5pdEFjY3VtLGJhc2VFYWNoUmlnaHQpO30vKipcbiAgICAgKiBUaGUgb3Bwb3NpdGUgb2YgYF8uZmlsdGVyYDsgdGhpcyBtZXRob2QgcmV0dXJucyB0aGUgZWxlbWVudHMgb2YgYGNvbGxlY3Rpb25gXG4gICAgICogdGhhdCBgcHJlZGljYXRlYCBkb2VzICoqbm90KiogcmV0dXJuIHRydXRoeSBmb3IuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmlsdGVyZWQgYXJyYXkuXG4gICAgICogQHNlZSBfLmZpbHRlclxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IHRydWUgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLnJlamVjdCh1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gIW8uYWN0aXZlOyB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2ZyZWQnXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnJlamVjdCh1c2VycywgeyAnYWdlJzogNDAsICdhY3RpdmUnOiB0cnVlIH0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnYmFybmV5J11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnJlamVjdCh1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnZnJlZCddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnJlamVjdCh1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnYmFybmV5J11cbiAgICAgKi9mdW5jdGlvbiByZWplY3QoY29sbGVjdGlvbixwcmVkaWNhdGUpe3ZhciBmdW5jPWlzQXJyYXkoY29sbGVjdGlvbik/YXJyYXlGaWx0ZXI6YmFzZUZpbHRlcjtyZXR1cm4gZnVuYyhjb2xsZWN0aW9uLG5lZ2F0ZShnZXRJdGVyYXRlZShwcmVkaWNhdGUsMykpKTt9LyoqXG4gICAgICogR2V0cyBhIHJhbmRvbSBlbGVtZW50IGZyb20gYGNvbGxlY3Rpb25gLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuMC4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBzYW1wbGUuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJhbmRvbSBlbGVtZW50LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNhbXBsZShbMSwgMiwgMywgNF0pO1xuICAgICAqIC8vID0+IDJcbiAgICAgKi9mdW5jdGlvbiBzYW1wbGUoY29sbGVjdGlvbil7dmFyIGZ1bmM9aXNBcnJheShjb2xsZWN0aW9uKT9hcnJheVNhbXBsZTpiYXNlU2FtcGxlO3JldHVybiBmdW5jKGNvbGxlY3Rpb24pO30vKipcbiAgICAgKiBHZXRzIGBuYCByYW5kb20gZWxlbWVudHMgYXQgdW5pcXVlIGtleXMgZnJvbSBgY29sbGVjdGlvbmAgdXAgdG8gdGhlXG4gICAgICogc2l6ZSBvZiBgY29sbGVjdGlvbmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIHNhbXBsZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW249MV0gVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byBzYW1wbGUuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHJhbmRvbSBlbGVtZW50cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zYW1wbGVTaXplKFsxLCAyLCAzXSwgMik7XG4gICAgICogLy8gPT4gWzMsIDFdXG4gICAgICpcbiAgICAgKiBfLnNhbXBsZVNpemUoWzEsIDIsIDNdLCA0KTtcbiAgICAgKiAvLyA9PiBbMiwgMywgMV1cbiAgICAgKi9mdW5jdGlvbiBzYW1wbGVTaXplKGNvbGxlY3Rpb24sbixndWFyZCl7aWYoZ3VhcmQ/aXNJdGVyYXRlZUNhbGwoY29sbGVjdGlvbixuLGd1YXJkKTpuPT09dW5kZWZpbmVkKXtuPTE7fWVsc2V7bj10b0ludGVnZXIobik7fXZhciBmdW5jPWlzQXJyYXkoY29sbGVjdGlvbik/YXJyYXlTYW1wbGVTaXplOmJhc2VTYW1wbGVTaXplO3JldHVybiBmdW5jKGNvbGxlY3Rpb24sbik7fS8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2Ygc2h1ZmZsZWQgdmFsdWVzLCB1c2luZyBhIHZlcnNpb24gb2YgdGhlXG4gICAgICogW0Zpc2hlci1ZYXRlcyBzaHVmZmxlXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9GaXNoZXItWWF0ZXNfc2h1ZmZsZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIHNodWZmbGUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgc2h1ZmZsZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc2h1ZmZsZShbMSwgMiwgMywgNF0pO1xuICAgICAqIC8vID0+IFs0LCAxLCAzLCAyXVxuICAgICAqL2Z1bmN0aW9uIHNodWZmbGUoY29sbGVjdGlvbil7dmFyIGZ1bmM9aXNBcnJheShjb2xsZWN0aW9uKT9hcnJheVNodWZmbGU6YmFzZVNodWZmbGU7cmV0dXJuIGZ1bmMoY29sbGVjdGlvbik7fS8qKlxuICAgICAqIEdldHMgdGhlIHNpemUgb2YgYGNvbGxlY3Rpb25gIGJ5IHJldHVybmluZyBpdHMgbGVuZ3RoIGZvciBhcnJheS1saWtlXG4gICAgICogdmFsdWVzIG9yIHRoZSBudW1iZXIgb2Ygb3duIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnRpZXMgZm9yIG9iamVjdHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGNvbGxlY3Rpb24gc2l6ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zaXplKFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gM1xuICAgICAqXG4gICAgICogXy5zaXplKHsgJ2EnOiAxLCAnYic6IDIgfSk7XG4gICAgICogLy8gPT4gMlxuICAgICAqXG4gICAgICogXy5zaXplKCdwZWJibGVzJyk7XG4gICAgICogLy8gPT4gN1xuICAgICAqL2Z1bmN0aW9uIHNpemUoY29sbGVjdGlvbil7aWYoY29sbGVjdGlvbj09bnVsbCl7cmV0dXJuIDA7fWlmKGlzQXJyYXlMaWtlKGNvbGxlY3Rpb24pKXtyZXR1cm4gaXNTdHJpbmcoY29sbGVjdGlvbik/c3RyaW5nU2l6ZShjb2xsZWN0aW9uKTpjb2xsZWN0aW9uLmxlbmd0aDt9dmFyIHRhZz1nZXRUYWcoY29sbGVjdGlvbik7aWYodGFnPT1tYXBUYWd8fHRhZz09c2V0VGFnKXtyZXR1cm4gY29sbGVjdGlvbi5zaXplO31yZXR1cm4gYmFzZUtleXMoY29sbGVjdGlvbikubGVuZ3RoO30vKipcbiAgICAgKiBDaGVja3MgaWYgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yICoqYW55KiogZWxlbWVudCBvZiBgY29sbGVjdGlvbmAuXG4gICAgICogSXRlcmF0aW9uIGlzIHN0b3BwZWQgb25jZSBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeS4gVGhlIHByZWRpY2F0ZSBpc1xuICAgICAqIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbnkgZWxlbWVudCBwYXNzZXMgdGhlIHByZWRpY2F0ZSBjaGVjayxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNvbWUoW251bGwsIDAsICd5ZXMnLCBmYWxzZV0sIEJvb2xlYW4pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FjdGl2ZSc6IHRydWUgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FjdGl2ZSc6IGZhbHNlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnNvbWUodXNlcnMsIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FjdGl2ZSc6IGZhbHNlIH0pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5zb21lKHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5zb21lKHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL2Z1bmN0aW9uIHNvbWUoY29sbGVjdGlvbixwcmVkaWNhdGUsZ3VhcmQpe3ZhciBmdW5jPWlzQXJyYXkoY29sbGVjdGlvbik/YXJyYXlTb21lOmJhc2VTb21lO2lmKGd1YXJkJiZpc0l0ZXJhdGVlQ2FsbChjb2xsZWN0aW9uLHByZWRpY2F0ZSxndWFyZCkpe3ByZWRpY2F0ZT11bmRlZmluZWQ7fXJldHVybiBmdW5jKGNvbGxlY3Rpb24sZ2V0SXRlcmF0ZWUocHJlZGljYXRlLDMpKTt9LyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBlbGVtZW50cywgc29ydGVkIGluIGFzY2VuZGluZyBvcmRlciBieSB0aGUgcmVzdWx0cyBvZlxuICAgICAqIHJ1bm5pbmcgZWFjaCBlbGVtZW50IGluIGEgY29sbGVjdGlvbiB0aHJ1IGVhY2ggaXRlcmF0ZWUuIFRoaXMgbWV0aG9kXG4gICAgICogcGVyZm9ybXMgYSBzdGFibGUgc29ydCwgdGhhdCBpcywgaXQgcHJlc2VydmVzIHRoZSBvcmlnaW5hbCBzb3J0IG9yZGVyIG9mXG4gICAgICogZXF1YWwgZWxlbWVudHMuIFRoZSBpdGVyYXRlZXMgYXJlIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0gey4uLihGdW5jdGlvbnxGdW5jdGlvbltdKX0gW2l0ZXJhdGVlcz1bXy5pZGVudGl0eV1dXG4gICAgICogIFRoZSBpdGVyYXRlZXMgdG8gc29ydCBieS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBzb3J0ZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQ4IH0sXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDAgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM0IH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5zb3J0QnkodXNlcnMsIFtmdW5jdGlvbihvKSB7IHJldHVybiBvLnVzZXI7IH1dKTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbWydiYXJuZXknLCAzNl0sIFsnYmFybmV5JywgMzRdLCBbJ2ZyZWQnLCA0OF0sIFsnZnJlZCcsIDQwXV1cbiAgICAgKlxuICAgICAqIF8uc29ydEJ5KHVzZXJzLCBbJ3VzZXInLCAnYWdlJ10pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFtbJ2Jhcm5leScsIDM0XSwgWydiYXJuZXknLCAzNl0sIFsnZnJlZCcsIDQwXSwgWydmcmVkJywgNDhdXVxuICAgICAqL3ZhciBzb3J0Qnk9YmFzZVJlc3QoZnVuY3Rpb24oY29sbGVjdGlvbixpdGVyYXRlZXMpe2lmKGNvbGxlY3Rpb249PW51bGwpe3JldHVybltdO312YXIgbGVuZ3RoPWl0ZXJhdGVlcy5sZW5ndGg7aWYobGVuZ3RoPjEmJmlzSXRlcmF0ZWVDYWxsKGNvbGxlY3Rpb24saXRlcmF0ZWVzWzBdLGl0ZXJhdGVlc1sxXSkpe2l0ZXJhdGVlcz1bXTt9ZWxzZSBpZihsZW5ndGg+MiYmaXNJdGVyYXRlZUNhbGwoaXRlcmF0ZWVzWzBdLGl0ZXJhdGVlc1sxXSxpdGVyYXRlZXNbMl0pKXtpdGVyYXRlZXM9W2l0ZXJhdGVlc1swXV07fXJldHVybiBiYXNlT3JkZXJCeShjb2xsZWN0aW9uLGJhc2VGbGF0dGVuKGl0ZXJhdGVlcywxKSxbXSk7fSk7LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qLy8qKlxuICAgICAqIEdldHMgdGhlIHRpbWVzdGFtcCBvZiB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0aGF0IGhhdmUgZWxhcHNlZCBzaW5jZVxuICAgICAqIHRoZSBVbml4IGVwb2NoICgxIEphbnVhcnkgMTk3MCAwMDowMDowMCBVVEMpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuNC4wXG4gICAgICogQGNhdGVnb3J5IERhdGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSB0aW1lc3RhbXAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZGVmZXIoZnVuY3Rpb24oc3RhbXApIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKF8ubm93KCkgLSBzdGFtcCk7XG4gICAgICogfSwgXy5ub3coKSk7XG4gICAgICogLy8gPT4gTG9ncyB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBpdCB0b29rIGZvciB0aGUgZGVmZXJyZWQgaW52b2NhdGlvbi5cbiAgICAgKi92YXIgbm93PWN0eE5vd3x8ZnVuY3Rpb24oKXtyZXR1cm4gcm9vdC5EYXRlLm5vdygpO307LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qLy8qKlxuICAgICAqIFRoZSBvcHBvc2l0ZSBvZiBgXy5iZWZvcmVgOyB0aGlzIG1ldGhvZCBjcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzXG4gICAgICogYGZ1bmNgIG9uY2UgaXQncyBjYWxsZWQgYG5gIG9yIG1vcmUgdGltZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIGNhbGxzIGJlZm9yZSBgZnVuY2AgaXMgaW52b2tlZC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byByZXN0cmljdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyByZXN0cmljdGVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgc2F2ZXMgPSBbJ3Byb2ZpbGUnLCAnc2V0dGluZ3MnXTtcbiAgICAgKlxuICAgICAqIHZhciBkb25lID0gXy5hZnRlcihzYXZlcy5sZW5ndGgsIGZ1bmN0aW9uKCkge1xuICAgICAqICAgY29uc29sZS5sb2coJ2RvbmUgc2F2aW5nIScpO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogXy5mb3JFYWNoKHNhdmVzLCBmdW5jdGlvbih0eXBlKSB7XG4gICAgICogICBhc3luY1NhdmUoeyAndHlwZSc6IHR5cGUsICdjb21wbGV0ZSc6IGRvbmUgfSk7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gTG9ncyAnZG9uZSBzYXZpbmchJyBhZnRlciB0aGUgdHdvIGFzeW5jIHNhdmVzIGhhdmUgY29tcGxldGVkLlxuICAgICAqL2Z1bmN0aW9uIGFmdGVyKG4sZnVuYyl7aWYodHlwZW9mIGZ1bmMhPSdmdW5jdGlvbicpe3Rocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTt9bj10b0ludGVnZXIobik7cmV0dXJuIGZ1bmN0aW9uKCl7aWYoLS1uPDEpe3JldHVybiBmdW5jLmFwcGx5KHRoaXMsYXJndW1lbnRzKTt9fTt9LyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2AsIHdpdGggdXAgdG8gYG5gIGFyZ3VtZW50cyxcbiAgICAgKiBpZ25vcmluZyBhbnkgYWRkaXRpb25hbCBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjYXAgYXJndW1lbnRzIGZvci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW249ZnVuYy5sZW5ndGhdIFRoZSBhcml0eSBjYXAuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjYXBwZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubWFwKFsnNicsICc4JywgJzEwJ10sIF8uYXJ5KHBhcnNlSW50LCAxKSk7XG4gICAgICogLy8gPT4gWzYsIDgsIDEwXVxuICAgICAqL2Z1bmN0aW9uIGFyeShmdW5jLG4sZ3VhcmQpe249Z3VhcmQ/dW5kZWZpbmVkOm47bj1mdW5jJiZuPT1udWxsP2Z1bmMubGVuZ3RoOm47cmV0dXJuIGNyZWF0ZVdyYXAoZnVuYyxXUkFQX0FSWV9GTEFHLHVuZGVmaW5lZCx1bmRlZmluZWQsdW5kZWZpbmVkLHVuZGVmaW5lZCxuKTt9LyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2AsIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIGFuZCBhcmd1bWVudHNcbiAgICAgKiBvZiB0aGUgY3JlYXRlZCBmdW5jdGlvbiwgd2hpbGUgaXQncyBjYWxsZWQgbGVzcyB0aGFuIGBuYCB0aW1lcy4gU3Vic2VxdWVudFxuICAgICAqIGNhbGxzIHRvIHRoZSBjcmVhdGVkIGZ1bmN0aW9uIHJldHVybiB0aGUgcmVzdWx0IG9mIHRoZSBsYXN0IGBmdW5jYCBpbnZvY2F0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiBjYWxscyBhdCB3aGljaCBgZnVuY2AgaXMgbm8gbG9uZ2VyIGludm9rZWQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcmVzdHJpY3QuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcmVzdHJpY3RlZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogalF1ZXJ5KGVsZW1lbnQpLm9uKCdjbGljaycsIF8uYmVmb3JlKDUsIGFkZENvbnRhY3RUb0xpc3QpKTtcbiAgICAgKiAvLyA9PiBBbGxvd3MgYWRkaW5nIHVwIHRvIDQgY29udGFjdHMgdG8gdGhlIGxpc3QuXG4gICAgICovZnVuY3Rpb24gYmVmb3JlKG4sZnVuYyl7dmFyIHJlc3VsdDtpZih0eXBlb2YgZnVuYyE9J2Z1bmN0aW9uJyl7dGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO31uPXRvSW50ZWdlcihuKTtyZXR1cm4gZnVuY3Rpb24oKXtpZigtLW4+MCl7cmVzdWx0PWZ1bmMuYXBwbHkodGhpcyxhcmd1bWVudHMpO31pZihuPD0xKXtmdW5jPXVuZGVmaW5lZDt9cmV0dXJuIHJlc3VsdDt9O30vKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiBgdGhpc0FyZ2BcbiAgICAgKiBhbmQgYHBhcnRpYWxzYCBwcmVwZW5kZWQgdG8gdGhlIGFyZ3VtZW50cyBpdCByZWNlaXZlcy5cbiAgICAgKlxuICAgICAqIFRoZSBgXy5iaW5kLnBsYWNlaG9sZGVyYCB2YWx1ZSwgd2hpY2ggZGVmYXVsdHMgdG8gYF9gIGluIG1vbm9saXRoaWMgYnVpbGRzLFxuICAgICAqIG1heSBiZSB1c2VkIGFzIGEgcGxhY2Vob2xkZXIgZm9yIHBhcnRpYWxseSBhcHBsaWVkIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBVbmxpa2UgbmF0aXZlIGBGdW5jdGlvbiNiaW5kYCwgdGhpcyBtZXRob2QgZG9lc24ndCBzZXQgdGhlIFwibGVuZ3RoXCJcbiAgICAgKiBwcm9wZXJ0eSBvZiBib3VuZCBmdW5jdGlvbnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBiaW5kLlxuICAgICAqIEBwYXJhbSB7Kn0gdGhpc0FyZyBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW3BhcnRpYWxzXSBUaGUgYXJndW1lbnRzIHRvIGJlIHBhcnRpYWxseSBhcHBsaWVkLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJvdW5kIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBncmVldChncmVldGluZywgcHVuY3R1YXRpb24pIHtcbiAgICAgKiAgIHJldHVybiBncmVldGluZyArICcgJyArIHRoaXMudXNlciArIHB1bmN0dWF0aW9uO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICd1c2VyJzogJ2ZyZWQnIH07XG4gICAgICpcbiAgICAgKiB2YXIgYm91bmQgPSBfLmJpbmQoZ3JlZXQsIG9iamVjdCwgJ2hpJyk7XG4gICAgICogYm91bmQoJyEnKTtcbiAgICAgKiAvLyA9PiAnaGkgZnJlZCEnXG4gICAgICpcbiAgICAgKiAvLyBCb3VuZCB3aXRoIHBsYWNlaG9sZGVycy5cbiAgICAgKiB2YXIgYm91bmQgPSBfLmJpbmQoZ3JlZXQsIG9iamVjdCwgXywgJyEnKTtcbiAgICAgKiBib3VuZCgnaGknKTtcbiAgICAgKiAvLyA9PiAnaGkgZnJlZCEnXG4gICAgICovdmFyIGJpbmQ9YmFzZVJlc3QoZnVuY3Rpb24oZnVuYyx0aGlzQXJnLHBhcnRpYWxzKXt2YXIgYml0bWFzaz1XUkFQX0JJTkRfRkxBRztpZihwYXJ0aWFscy5sZW5ndGgpe3ZhciBob2xkZXJzPXJlcGxhY2VIb2xkZXJzKHBhcnRpYWxzLGdldEhvbGRlcihiaW5kKSk7Yml0bWFza3w9V1JBUF9QQVJUSUFMX0ZMQUc7fXJldHVybiBjcmVhdGVXcmFwKGZ1bmMsYml0bWFzayx0aGlzQXJnLHBhcnRpYWxzLGhvbGRlcnMpO30pOy8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgdGhlIG1ldGhvZCBhdCBgb2JqZWN0W2tleV1gIHdpdGggYHBhcnRpYWxzYFxuICAgICAqIHByZXBlbmRlZCB0byB0aGUgYXJndW1lbnRzIGl0IHJlY2VpdmVzLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgZGlmZmVycyBmcm9tIGBfLmJpbmRgIGJ5IGFsbG93aW5nIGJvdW5kIGZ1bmN0aW9ucyB0byByZWZlcmVuY2VcbiAgICAgKiBtZXRob2RzIHRoYXQgbWF5IGJlIHJlZGVmaW5lZCBvciBkb24ndCB5ZXQgZXhpc3QuIFNlZVxuICAgICAqIFtQZXRlciBNaWNoYXV4J3MgYXJ0aWNsZV0oaHR0cDovL3BldGVyLm1pY2hhdXguY2EvYXJ0aWNsZXMvbGF6eS1mdW5jdGlvbi1kZWZpbml0aW9uLXBhdHRlcm4pXG4gICAgICogZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKlxuICAgICAqIFRoZSBgXy5iaW5kS2V5LnBsYWNlaG9sZGVyYCB2YWx1ZSwgd2hpY2ggZGVmYXVsdHMgdG8gYF9gIGluIG1vbm9saXRoaWNcbiAgICAgKiBidWlsZHMsIG1heSBiZSB1c2VkIGFzIGEgcGxhY2Vob2xkZXIgZm9yIHBhcnRpYWxseSBhcHBsaWVkIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEwLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW52b2tlIHRoZSBtZXRob2Qgb24uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBtZXRob2QuXG4gICAgICogQHBhcmFtIHsuLi4qfSBbcGFydGlhbHNdIFRoZSBhcmd1bWVudHMgdG8gYmUgcGFydGlhbGx5IGFwcGxpZWQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYm91bmQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7XG4gICAgICogICAndXNlcic6ICdmcmVkJyxcbiAgICAgKiAgICdncmVldCc6IGZ1bmN0aW9uKGdyZWV0aW5nLCBwdW5jdHVhdGlvbikge1xuICAgICAqICAgICByZXR1cm4gZ3JlZXRpbmcgKyAnICcgKyB0aGlzLnVzZXIgKyBwdW5jdHVhdGlvbjtcbiAgICAgKiAgIH1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogdmFyIGJvdW5kID0gXy5iaW5kS2V5KG9iamVjdCwgJ2dyZWV0JywgJ2hpJyk7XG4gICAgICogYm91bmQoJyEnKTtcbiAgICAgKiAvLyA9PiAnaGkgZnJlZCEnXG4gICAgICpcbiAgICAgKiBvYmplY3QuZ3JlZXQgPSBmdW5jdGlvbihncmVldGluZywgcHVuY3R1YXRpb24pIHtcbiAgICAgKiAgIHJldHVybiBncmVldGluZyArICd5YSAnICsgdGhpcy51c2VyICsgcHVuY3R1YXRpb247XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIGJvdW5kKCchJyk7XG4gICAgICogLy8gPT4gJ2hpeWEgZnJlZCEnXG4gICAgICpcbiAgICAgKiAvLyBCb3VuZCB3aXRoIHBsYWNlaG9sZGVycy5cbiAgICAgKiB2YXIgYm91bmQgPSBfLmJpbmRLZXkob2JqZWN0LCAnZ3JlZXQnLCBfLCAnIScpO1xuICAgICAqIGJvdW5kKCdoaScpO1xuICAgICAqIC8vID0+ICdoaXlhIGZyZWQhJ1xuICAgICAqL3ZhciBiaW5kS2V5PWJhc2VSZXN0KGZ1bmN0aW9uKG9iamVjdCxrZXkscGFydGlhbHMpe3ZhciBiaXRtYXNrPVdSQVBfQklORF9GTEFHfFdSQVBfQklORF9LRVlfRkxBRztpZihwYXJ0aWFscy5sZW5ndGgpe3ZhciBob2xkZXJzPXJlcGxhY2VIb2xkZXJzKHBhcnRpYWxzLGdldEhvbGRlcihiaW5kS2V5KSk7Yml0bWFza3w9V1JBUF9QQVJUSUFMX0ZMQUc7fXJldHVybiBjcmVhdGVXcmFwKGtleSxiaXRtYXNrLG9iamVjdCxwYXJ0aWFscyxob2xkZXJzKTt9KTsvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBhY2NlcHRzIGFyZ3VtZW50cyBvZiBgZnVuY2AgYW5kIGVpdGhlciBpbnZva2VzXG4gICAgICogYGZ1bmNgIHJldHVybmluZyBpdHMgcmVzdWx0LCBpZiBhdCBsZWFzdCBgYXJpdHlgIG51bWJlciBvZiBhcmd1bWVudHMgaGF2ZVxuICAgICAqIGJlZW4gcHJvdmlkZWQsIG9yIHJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGFjY2VwdHMgdGhlIHJlbWFpbmluZyBgZnVuY2BcbiAgICAgKiBhcmd1bWVudHMsIGFuZCBzbyBvbi4gVGhlIGFyaXR5IG9mIGBmdW5jYCBtYXkgYmUgc3BlY2lmaWVkIGlmIGBmdW5jLmxlbmd0aGBcbiAgICAgKiBpcyBub3Qgc3VmZmljaWVudC5cbiAgICAgKlxuICAgICAqIFRoZSBgXy5jdXJyeS5wbGFjZWhvbGRlcmAgdmFsdWUsIHdoaWNoIGRlZmF1bHRzIHRvIGBfYCBpbiBtb25vbGl0aGljIGJ1aWxkcyxcbiAgICAgKiBtYXkgYmUgdXNlZCBhcyBhIHBsYWNlaG9sZGVyIGZvciBwcm92aWRlZCBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgZG9lc24ndCBzZXQgdGhlIFwibGVuZ3RoXCIgcHJvcGVydHkgb2YgY3VycmllZCBmdW5jdGlvbnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjdXJyeS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FyaXR5PWZ1bmMubGVuZ3RoXSBUaGUgYXJpdHkgb2YgYGZ1bmNgLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY3VycmllZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFiYyA9IGZ1bmN0aW9uKGEsIGIsIGMpIHtcbiAgICAgKiAgIHJldHVybiBbYSwgYiwgY107XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIHZhciBjdXJyaWVkID0gXy5jdXJyeShhYmMpO1xuICAgICAqXG4gICAgICogY3VycmllZCgxKSgyKSgzKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKlxuICAgICAqIGN1cnJpZWQoMSwgMikoMyk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICpcbiAgICAgKiBjdXJyaWVkKDEsIDIsIDMpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqXG4gICAgICogLy8gQ3VycmllZCB3aXRoIHBsYWNlaG9sZGVycy5cbiAgICAgKiBjdXJyaWVkKDEpKF8sIDMpKDIpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqL2Z1bmN0aW9uIGN1cnJ5KGZ1bmMsYXJpdHksZ3VhcmQpe2FyaXR5PWd1YXJkP3VuZGVmaW5lZDphcml0eTt2YXIgcmVzdWx0PWNyZWF0ZVdyYXAoZnVuYyxXUkFQX0NVUlJZX0ZMQUcsdW5kZWZpbmVkLHVuZGVmaW5lZCx1bmRlZmluZWQsdW5kZWZpbmVkLHVuZGVmaW5lZCxhcml0eSk7cmVzdWx0LnBsYWNlaG9sZGVyPWN1cnJ5LnBsYWNlaG9sZGVyO3JldHVybiByZXN1bHQ7fS8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uY3VycnlgIGV4Y2VwdCB0aGF0IGFyZ3VtZW50cyBhcmUgYXBwbGllZCB0byBgZnVuY2BcbiAgICAgKiBpbiB0aGUgbWFubmVyIG9mIGBfLnBhcnRpYWxSaWdodGAgaW5zdGVhZCBvZiBgXy5wYXJ0aWFsYC5cbiAgICAgKlxuICAgICAqIFRoZSBgXy5jdXJyeVJpZ2h0LnBsYWNlaG9sZGVyYCB2YWx1ZSwgd2hpY2ggZGVmYXVsdHMgdG8gYF9gIGluIG1vbm9saXRoaWNcbiAgICAgKiBidWlsZHMsIG1heSBiZSB1c2VkIGFzIGEgcGxhY2Vob2xkZXIgZm9yIHByb3ZpZGVkIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBkb2Vzbid0IHNldCB0aGUgXCJsZW5ndGhcIiBwcm9wZXJ0eSBvZiBjdXJyaWVkIGZ1bmN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGN1cnJ5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYXJpdHk9ZnVuYy5sZW5ndGhdIFRoZSBhcml0eSBvZiBgZnVuY2AuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjdXJyaWVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYWJjID0gZnVuY3Rpb24oYSwgYiwgYykge1xuICAgICAqICAgcmV0dXJuIFthLCBiLCBjXTtcbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogdmFyIGN1cnJpZWQgPSBfLmN1cnJ5UmlnaHQoYWJjKTtcbiAgICAgKlxuICAgICAqIGN1cnJpZWQoMykoMikoMSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICpcbiAgICAgKiBjdXJyaWVkKDIsIDMpKDEpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqXG4gICAgICogY3VycmllZCgxLCAyLCAzKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKlxuICAgICAqIC8vIEN1cnJpZWQgd2l0aCBwbGFjZWhvbGRlcnMuXG4gICAgICogY3VycmllZCgzKSgxLCBfKSgyKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKi9mdW5jdGlvbiBjdXJyeVJpZ2h0KGZ1bmMsYXJpdHksZ3VhcmQpe2FyaXR5PWd1YXJkP3VuZGVmaW5lZDphcml0eTt2YXIgcmVzdWx0PWNyZWF0ZVdyYXAoZnVuYyxXUkFQX0NVUlJZX1JJR0hUX0ZMQUcsdW5kZWZpbmVkLHVuZGVmaW5lZCx1bmRlZmluZWQsdW5kZWZpbmVkLHVuZGVmaW5lZCxhcml0eSk7cmVzdWx0LnBsYWNlaG9sZGVyPWN1cnJ5UmlnaHQucGxhY2Vob2xkZXI7cmV0dXJuIHJlc3VsdDt9LyoqXG4gICAgICogQ3JlYXRlcyBhIGRlYm91bmNlZCBmdW5jdGlvbiB0aGF0IGRlbGF5cyBpbnZva2luZyBgZnVuY2AgdW50aWwgYWZ0ZXIgYHdhaXRgXG4gICAgICogbWlsbGlzZWNvbmRzIGhhdmUgZWxhcHNlZCBzaW5jZSB0aGUgbGFzdCB0aW1lIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gd2FzXG4gICAgICogaW52b2tlZC4gVGhlIGRlYm91bmNlZCBmdW5jdGlvbiBjb21lcyB3aXRoIGEgYGNhbmNlbGAgbWV0aG9kIHRvIGNhbmNlbFxuICAgICAqIGRlbGF5ZWQgYGZ1bmNgIGludm9jYXRpb25zIGFuZCBhIGBmbHVzaGAgbWV0aG9kIHRvIGltbWVkaWF0ZWx5IGludm9rZSB0aGVtLlxuICAgICAqIFByb3ZpZGUgYG9wdGlvbnNgIHRvIGluZGljYXRlIHdoZXRoZXIgYGZ1bmNgIHNob3VsZCBiZSBpbnZva2VkIG9uIHRoZVxuICAgICAqIGxlYWRpbmcgYW5kL29yIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIGB3YWl0YCB0aW1lb3V0LiBUaGUgYGZ1bmNgIGlzIGludm9rZWRcbiAgICAgKiB3aXRoIHRoZSBsYXN0IGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uLiBTdWJzZXF1ZW50XG4gICAgICogY2FsbHMgdG8gdGhlIGRlYm91bmNlZCBmdW5jdGlvbiByZXR1cm4gdGhlIHJlc3VsdCBvZiB0aGUgbGFzdCBgZnVuY2BcbiAgICAgKiBpbnZvY2F0aW9uLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIElmIGBsZWFkaW5nYCBhbmQgYHRyYWlsaW5nYCBvcHRpb25zIGFyZSBgdHJ1ZWAsIGBmdW5jYCBpc1xuICAgICAqIGludm9rZWQgb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQgb25seSBpZiB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uXG4gICAgICogaXMgaW52b2tlZCBtb3JlIHRoYW4gb25jZSBkdXJpbmcgdGhlIGB3YWl0YCB0aW1lb3V0LlxuICAgICAqXG4gICAgICogSWYgYHdhaXRgIGlzIGAwYCBhbmQgYGxlYWRpbmdgIGlzIGBmYWxzZWAsIGBmdW5jYCBpbnZvY2F0aW9uIGlzIGRlZmVycmVkXG4gICAgICogdW50aWwgdG8gdGhlIG5leHQgdGljaywgc2ltaWxhciB0byBgc2V0VGltZW91dGAgd2l0aCBhIHRpbWVvdXQgb2YgYDBgLlxuICAgICAqXG4gICAgICogU2VlIFtEYXZpZCBDb3JiYWNobydzIGFydGljbGVdKGh0dHBzOi8vY3NzLXRyaWNrcy5jb20vZGVib3VuY2luZy10aHJvdHRsaW5nLWV4cGxhaW5lZC1leGFtcGxlcy8pXG4gICAgICogZm9yIGRldGFpbHMgb3ZlciB0aGUgZGlmZmVyZW5jZXMgYmV0d2VlbiBgXy5kZWJvdW5jZWAgYW5kIGBfLnRocm90dGxlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRlYm91bmNlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbd2FpdD0wXSBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byBkZWxheS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIFRoZSBvcHRpb25zIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmxlYWRpbmc9ZmFsc2VdXG4gICAgICogIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIGxlYWRpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubWF4V2FpdF1cbiAgICAgKiAgVGhlIG1heGltdW0gdGltZSBgZnVuY2AgaXMgYWxsb3dlZCB0byBiZSBkZWxheWVkIGJlZm9yZSBpdCdzIGludm9rZWQuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50cmFpbGluZz10cnVlXVxuICAgICAqICBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGRlYm91bmNlZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogLy8gQXZvaWQgY29zdGx5IGNhbGN1bGF0aW9ucyB3aGlsZSB0aGUgd2luZG93IHNpemUgaXMgaW4gZmx1eC5cbiAgICAgKiBqUXVlcnkod2luZG93KS5vbigncmVzaXplJywgXy5kZWJvdW5jZShjYWxjdWxhdGVMYXlvdXQsIDE1MCkpO1xuICAgICAqXG4gICAgICogLy8gSW52b2tlIGBzZW5kTWFpbGAgd2hlbiBjbGlja2VkLCBkZWJvdW5jaW5nIHN1YnNlcXVlbnQgY2FsbHMuXG4gICAgICogalF1ZXJ5KGVsZW1lbnQpLm9uKCdjbGljaycsIF8uZGVib3VuY2Uoc2VuZE1haWwsIDMwMCwge1xuICAgICAqICAgJ2xlYWRpbmcnOiB0cnVlLFxuICAgICAqICAgJ3RyYWlsaW5nJzogZmFsc2VcbiAgICAgKiB9KSk7XG4gICAgICpcbiAgICAgKiAvLyBFbnN1cmUgYGJhdGNoTG9nYCBpcyBpbnZva2VkIG9uY2UgYWZ0ZXIgMSBzZWNvbmQgb2YgZGVib3VuY2VkIGNhbGxzLlxuICAgICAqIHZhciBkZWJvdW5jZWQgPSBfLmRlYm91bmNlKGJhdGNoTG9nLCAyNTAsIHsgJ21heFdhaXQnOiAxMDAwIH0pO1xuICAgICAqIHZhciBzb3VyY2UgPSBuZXcgRXZlbnRTb3VyY2UoJy9zdHJlYW0nKTtcbiAgICAgKiBqUXVlcnkoc291cmNlKS5vbignbWVzc2FnZScsIGRlYm91bmNlZCk7XG4gICAgICpcbiAgICAgKiAvLyBDYW5jZWwgdGhlIHRyYWlsaW5nIGRlYm91bmNlZCBpbnZvY2F0aW9uLlxuICAgICAqIGpRdWVyeSh3aW5kb3cpLm9uKCdwb3BzdGF0ZScsIGRlYm91bmNlZC5jYW5jZWwpO1xuICAgICAqL2Z1bmN0aW9uIGRlYm91bmNlKGZ1bmMsd2FpdCxvcHRpb25zKXt2YXIgbGFzdEFyZ3MsbGFzdFRoaXMsbWF4V2FpdCxyZXN1bHQsdGltZXJJZCxsYXN0Q2FsbFRpbWUsbGFzdEludm9rZVRpbWU9MCxsZWFkaW5nPWZhbHNlLG1heGluZz1mYWxzZSx0cmFpbGluZz10cnVlO2lmKHR5cGVvZiBmdW5jIT0nZnVuY3Rpb24nKXt0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7fXdhaXQ9dG9OdW1iZXIod2FpdCl8fDA7aWYoaXNPYmplY3Qob3B0aW9ucykpe2xlYWRpbmc9ISFvcHRpb25zLmxlYWRpbmc7bWF4aW5nPSdtYXhXYWl0J2luIG9wdGlvbnM7bWF4V2FpdD1tYXhpbmc/bmF0aXZlTWF4KHRvTnVtYmVyKG9wdGlvbnMubWF4V2FpdCl8fDAsd2FpdCk6bWF4V2FpdDt0cmFpbGluZz0ndHJhaWxpbmcnaW4gb3B0aW9ucz8hIW9wdGlvbnMudHJhaWxpbmc6dHJhaWxpbmc7fWZ1bmN0aW9uIGludm9rZUZ1bmModGltZSl7dmFyIGFyZ3M9bGFzdEFyZ3MsdGhpc0FyZz1sYXN0VGhpcztsYXN0QXJncz1sYXN0VGhpcz11bmRlZmluZWQ7bGFzdEludm9rZVRpbWU9dGltZTtyZXN1bHQ9ZnVuYy5hcHBseSh0aGlzQXJnLGFyZ3MpO3JldHVybiByZXN1bHQ7fWZ1bmN0aW9uIGxlYWRpbmdFZGdlKHRpbWUpey8vIFJlc2V0IGFueSBgbWF4V2FpdGAgdGltZXIuXG5sYXN0SW52b2tlVGltZT10aW1lOy8vIFN0YXJ0IHRoZSB0aW1lciBmb3IgdGhlIHRyYWlsaW5nIGVkZ2UuXG50aW1lcklkPXNldFRpbWVvdXQodGltZXJFeHBpcmVkLHdhaXQpOy8vIEludm9rZSB0aGUgbGVhZGluZyBlZGdlLlxucmV0dXJuIGxlYWRpbmc/aW52b2tlRnVuYyh0aW1lKTpyZXN1bHQ7fWZ1bmN0aW9uIHJlbWFpbmluZ1dhaXQodGltZSl7dmFyIHRpbWVTaW5jZUxhc3RDYWxsPXRpbWUtbGFzdENhbGxUaW1lLHRpbWVTaW5jZUxhc3RJbnZva2U9dGltZS1sYXN0SW52b2tlVGltZSxyZXN1bHQ9d2FpdC10aW1lU2luY2VMYXN0Q2FsbDtyZXR1cm4gbWF4aW5nP25hdGl2ZU1pbihyZXN1bHQsbWF4V2FpdC10aW1lU2luY2VMYXN0SW52b2tlKTpyZXN1bHQ7fWZ1bmN0aW9uIHNob3VsZEludm9rZSh0aW1lKXt2YXIgdGltZVNpbmNlTGFzdENhbGw9dGltZS1sYXN0Q2FsbFRpbWUsdGltZVNpbmNlTGFzdEludm9rZT10aW1lLWxhc3RJbnZva2VUaW1lOy8vIEVpdGhlciB0aGlzIGlzIHRoZSBmaXJzdCBjYWxsLCBhY3Rpdml0eSBoYXMgc3RvcHBlZCBhbmQgd2UncmUgYXQgdGhlXG4vLyB0cmFpbGluZyBlZGdlLCB0aGUgc3lzdGVtIHRpbWUgaGFzIGdvbmUgYmFja3dhcmRzIGFuZCB3ZSdyZSB0cmVhdGluZ1xuLy8gaXQgYXMgdGhlIHRyYWlsaW5nIGVkZ2UsIG9yIHdlJ3ZlIGhpdCB0aGUgYG1heFdhaXRgIGxpbWl0LlxucmV0dXJuIGxhc3RDYWxsVGltZT09PXVuZGVmaW5lZHx8dGltZVNpbmNlTGFzdENhbGw+PXdhaXR8fHRpbWVTaW5jZUxhc3RDYWxsPDB8fG1heGluZyYmdGltZVNpbmNlTGFzdEludm9rZT49bWF4V2FpdDt9ZnVuY3Rpb24gdGltZXJFeHBpcmVkKCl7dmFyIHRpbWU9bm93KCk7aWYoc2hvdWxkSW52b2tlKHRpbWUpKXtyZXR1cm4gdHJhaWxpbmdFZGdlKHRpbWUpO30vLyBSZXN0YXJ0IHRoZSB0aW1lci5cbnRpbWVySWQ9c2V0VGltZW91dCh0aW1lckV4cGlyZWQscmVtYWluaW5nV2FpdCh0aW1lKSk7fWZ1bmN0aW9uIHRyYWlsaW5nRWRnZSh0aW1lKXt0aW1lcklkPXVuZGVmaW5lZDsvLyBPbmx5IGludm9rZSBpZiB3ZSBoYXZlIGBsYXN0QXJnc2Agd2hpY2ggbWVhbnMgYGZ1bmNgIGhhcyBiZWVuXG4vLyBkZWJvdW5jZWQgYXQgbGVhc3Qgb25jZS5cbmlmKHRyYWlsaW5nJiZsYXN0QXJncyl7cmV0dXJuIGludm9rZUZ1bmModGltZSk7fWxhc3RBcmdzPWxhc3RUaGlzPXVuZGVmaW5lZDtyZXR1cm4gcmVzdWx0O31mdW5jdGlvbiBjYW5jZWwoKXtpZih0aW1lcklkIT09dW5kZWZpbmVkKXtjbGVhclRpbWVvdXQodGltZXJJZCk7fWxhc3RJbnZva2VUaW1lPTA7bGFzdEFyZ3M9bGFzdENhbGxUaW1lPWxhc3RUaGlzPXRpbWVySWQ9dW5kZWZpbmVkO31mdW5jdGlvbiBmbHVzaCgpe3JldHVybiB0aW1lcklkPT09dW5kZWZpbmVkP3Jlc3VsdDp0cmFpbGluZ0VkZ2Uobm93KCkpO31mdW5jdGlvbiBkZWJvdW5jZWQoKXt2YXIgdGltZT1ub3coKSxpc0ludm9raW5nPXNob3VsZEludm9rZSh0aW1lKTtsYXN0QXJncz1hcmd1bWVudHM7bGFzdFRoaXM9dGhpcztsYXN0Q2FsbFRpbWU9dGltZTtpZihpc0ludm9raW5nKXtpZih0aW1lcklkPT09dW5kZWZpbmVkKXtyZXR1cm4gbGVhZGluZ0VkZ2UobGFzdENhbGxUaW1lKTt9aWYobWF4aW5nKXsvLyBIYW5kbGUgaW52b2NhdGlvbnMgaW4gYSB0aWdodCBsb29wLlxudGltZXJJZD1zZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCx3YWl0KTtyZXR1cm4gaW52b2tlRnVuYyhsYXN0Q2FsbFRpbWUpO319aWYodGltZXJJZD09PXVuZGVmaW5lZCl7dGltZXJJZD1zZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCx3YWl0KTt9cmV0dXJuIHJlc3VsdDt9ZGVib3VuY2VkLmNhbmNlbD1jYW5jZWw7ZGVib3VuY2VkLmZsdXNoPWZsdXNoO3JldHVybiBkZWJvdW5jZWQ7fS8qKlxuICAgICAqIERlZmVycyBpbnZva2luZyB0aGUgYGZ1bmNgIHVudGlsIHRoZSBjdXJyZW50IGNhbGwgc3RhY2sgaGFzIGNsZWFyZWQuIEFueVxuICAgICAqIGFkZGl0aW9uYWwgYXJndW1lbnRzIGFyZSBwcm92aWRlZCB0byBgZnVuY2Agd2hlbiBpdCdzIGludm9rZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBkZWZlci5cbiAgICAgKiBAcGFyYW0gey4uLip9IFthcmdzXSBUaGUgYXJndW1lbnRzIHRvIGludm9rZSBgZnVuY2Agd2l0aC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSB0aW1lciBpZC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kZWZlcihmdW5jdGlvbih0ZXh0KSB7XG4gICAgICogICBjb25zb2xlLmxvZyh0ZXh0KTtcbiAgICAgKiB9LCAnZGVmZXJyZWQnKTtcbiAgICAgKiAvLyA9PiBMb2dzICdkZWZlcnJlZCcgYWZ0ZXIgb25lIG1pbGxpc2Vjb25kLlxuICAgICAqL3ZhciBkZWZlcj1iYXNlUmVzdChmdW5jdGlvbihmdW5jLGFyZ3Mpe3JldHVybiBiYXNlRGVsYXkoZnVuYywxLGFyZ3MpO30pOy8qKlxuICAgICAqIEludm9rZXMgYGZ1bmNgIGFmdGVyIGB3YWl0YCBtaWxsaXNlY29uZHMuIEFueSBhZGRpdGlvbmFsIGFyZ3VtZW50cyBhcmVcbiAgICAgKiBwcm92aWRlZCB0byBgZnVuY2Agd2hlbiBpdCdzIGludm9rZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBkZWxheS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd2FpdCBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byBkZWxheSBpbnZvY2F0aW9uLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW2FyZ3NdIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIGBmdW5jYCB3aXRoLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHRpbWVyIGlkLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRlbGF5KGZ1bmN0aW9uKHRleHQpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKHRleHQpO1xuICAgICAqIH0sIDEwMDAsICdsYXRlcicpO1xuICAgICAqIC8vID0+IExvZ3MgJ2xhdGVyJyBhZnRlciBvbmUgc2Vjb25kLlxuICAgICAqL3ZhciBkZWxheT1iYXNlUmVzdChmdW5jdGlvbihmdW5jLHdhaXQsYXJncyl7cmV0dXJuIGJhc2VEZWxheShmdW5jLHRvTnVtYmVyKHdhaXQpfHwwLGFyZ3MpO30pOy8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggYXJndW1lbnRzIHJldmVyc2VkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gZmxpcCBhcmd1bWVudHMgZm9yLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZsaXBwZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBmbGlwcGVkID0gXy5mbGlwKGZ1bmN0aW9uKCkge1xuICAgICAqICAgcmV0dXJuIF8udG9BcnJheShhcmd1bWVudHMpO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogZmxpcHBlZCgnYScsICdiJywgJ2MnLCAnZCcpO1xuICAgICAqIC8vID0+IFsnZCcsICdjJywgJ2InLCAnYSddXG4gICAgICovZnVuY3Rpb24gZmxpcChmdW5jKXtyZXR1cm4gY3JlYXRlV3JhcChmdW5jLFdSQVBfRkxJUF9GTEFHKTt9LyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgbWVtb2l6ZXMgdGhlIHJlc3VsdCBvZiBgZnVuY2AuIElmIGByZXNvbHZlcmAgaXNcbiAgICAgKiBwcm92aWRlZCwgaXQgZGV0ZXJtaW5lcyB0aGUgY2FjaGUga2V5IGZvciBzdG9yaW5nIHRoZSByZXN1bHQgYmFzZWQgb24gdGhlXG4gICAgICogYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZSBtZW1vaXplZCBmdW5jdGlvbi4gQnkgZGVmYXVsdCwgdGhlIGZpcnN0IGFyZ3VtZW50XG4gICAgICogcHJvdmlkZWQgdG8gdGhlIG1lbW9pemVkIGZ1bmN0aW9uIGlzIHVzZWQgYXMgdGhlIG1hcCBjYWNoZSBrZXkuIFRoZSBgZnVuY2BcbiAgICAgKiBpcyBpbnZva2VkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZSBtZW1vaXplZCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGUgY2FjaGUgaXMgZXhwb3NlZCBhcyB0aGUgYGNhY2hlYCBwcm9wZXJ0eSBvbiB0aGUgbWVtb2l6ZWRcbiAgICAgKiBmdW5jdGlvbi4gSXRzIGNyZWF0aW9uIG1heSBiZSBjdXN0b21pemVkIGJ5IHJlcGxhY2luZyB0aGUgYF8ubWVtb2l6ZS5DYWNoZWBcbiAgICAgKiBjb25zdHJ1Y3RvciB3aXRoIG9uZSB3aG9zZSBpbnN0YW5jZXMgaW1wbGVtZW50IHRoZVxuICAgICAqIFtgTWFwYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcHJvcGVydGllcy1vZi10aGUtbWFwLXByb3RvdHlwZS1vYmplY3QpXG4gICAgICogbWV0aG9kIGludGVyZmFjZSBvZiBgY2xlYXJgLCBgZGVsZXRlYCwgYGdldGAsIGBoYXNgLCBhbmQgYHNldGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBoYXZlIGl0cyBvdXRwdXQgbWVtb2l6ZWQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3Jlc29sdmVyXSBUaGUgZnVuY3Rpb24gdG8gcmVzb2x2ZSB0aGUgY2FjaGUga2V5LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG1lbW9pemVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogMiB9O1xuICAgICAqIHZhciBvdGhlciA9IHsgJ2MnOiAzLCAnZCc6IDQgfTtcbiAgICAgKlxuICAgICAqIHZhciB2YWx1ZXMgPSBfLm1lbW9pemUoXy52YWx1ZXMpO1xuICAgICAqIHZhbHVlcyhvYmplY3QpO1xuICAgICAqIC8vID0+IFsxLCAyXVxuICAgICAqXG4gICAgICogdmFsdWVzKG90aGVyKTtcbiAgICAgKiAvLyA9PiBbMywgNF1cbiAgICAgKlxuICAgICAqIG9iamVjdC5hID0gMjtcbiAgICAgKiB2YWx1ZXMob2JqZWN0KTtcbiAgICAgKiAvLyA9PiBbMSwgMl1cbiAgICAgKlxuICAgICAqIC8vIE1vZGlmeSB0aGUgcmVzdWx0IGNhY2hlLlxuICAgICAqIHZhbHVlcy5jYWNoZS5zZXQob2JqZWN0LCBbJ2EnLCAnYiddKTtcbiAgICAgKiB2YWx1ZXMob2JqZWN0KTtcbiAgICAgKiAvLyA9PiBbJ2EnLCAnYiddXG4gICAgICpcbiAgICAgKiAvLyBSZXBsYWNlIGBfLm1lbW9pemUuQ2FjaGVgLlxuICAgICAqIF8ubWVtb2l6ZS5DYWNoZSA9IFdlYWtNYXA7XG4gICAgICovZnVuY3Rpb24gbWVtb2l6ZShmdW5jLHJlc29sdmVyKXtpZih0eXBlb2YgZnVuYyE9J2Z1bmN0aW9uJ3x8cmVzb2x2ZXIhPW51bGwmJnR5cGVvZiByZXNvbHZlciE9J2Z1bmN0aW9uJyl7dGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO312YXIgbWVtb2l6ZWQ9ZnVuY3Rpb24oKXt2YXIgYXJncz1hcmd1bWVudHMsa2V5PXJlc29sdmVyP3Jlc29sdmVyLmFwcGx5KHRoaXMsYXJncyk6YXJnc1swXSxjYWNoZT1tZW1vaXplZC5jYWNoZTtpZihjYWNoZS5oYXMoa2V5KSl7cmV0dXJuIGNhY2hlLmdldChrZXkpO312YXIgcmVzdWx0PWZ1bmMuYXBwbHkodGhpcyxhcmdzKTttZW1vaXplZC5jYWNoZT1jYWNoZS5zZXQoa2V5LHJlc3VsdCl8fGNhY2hlO3JldHVybiByZXN1bHQ7fTttZW1vaXplZC5jYWNoZT1uZXcobWVtb2l6ZS5DYWNoZXx8TWFwQ2FjaGUpKCk7cmV0dXJuIG1lbW9pemVkO30vLyBFeHBvc2UgYE1hcENhY2hlYC5cbm1lbW9pemUuQ2FjaGU9TWFwQ2FjaGU7LyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgbmVnYXRlcyB0aGUgcmVzdWx0IG9mIHRoZSBwcmVkaWNhdGUgYGZ1bmNgLiBUaGVcbiAgICAgKiBgZnVuY2AgcHJlZGljYXRlIGlzIGludm9rZWQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgYW5kIGFyZ3VtZW50cyBvZiB0aGVcbiAgICAgKiBjcmVhdGVkIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBwcmVkaWNhdGUgdG8gbmVnYXRlLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG5lZ2F0ZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGlzRXZlbihuKSB7XG4gICAgICogICByZXR1cm4gbiAlIDIgPT0gMDtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBfLmZpbHRlcihbMSwgMiwgMywgNCwgNSwgNl0sIF8ubmVnYXRlKGlzRXZlbikpO1xuICAgICAqIC8vID0+IFsxLCAzLCA1XVxuICAgICAqL2Z1bmN0aW9uIG5lZ2F0ZShwcmVkaWNhdGUpe2lmKHR5cGVvZiBwcmVkaWNhdGUhPSdmdW5jdGlvbicpe3Rocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTt9cmV0dXJuIGZ1bmN0aW9uKCl7dmFyIGFyZ3M9YXJndW1lbnRzO3N3aXRjaChhcmdzLmxlbmd0aCl7Y2FzZSAwOnJldHVybiFwcmVkaWNhdGUuY2FsbCh0aGlzKTtjYXNlIDE6cmV0dXJuIXByZWRpY2F0ZS5jYWxsKHRoaXMsYXJnc1swXSk7Y2FzZSAyOnJldHVybiFwcmVkaWNhdGUuY2FsbCh0aGlzLGFyZ3NbMF0sYXJnc1sxXSk7Y2FzZSAzOnJldHVybiFwcmVkaWNhdGUuY2FsbCh0aGlzLGFyZ3NbMF0sYXJnc1sxXSxhcmdzWzJdKTt9cmV0dXJuIXByZWRpY2F0ZS5hcHBseSh0aGlzLGFyZ3MpO307fS8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGlzIHJlc3RyaWN0ZWQgdG8gaW52b2tpbmcgYGZ1bmNgIG9uY2UuIFJlcGVhdCBjYWxsc1xuICAgICAqIHRvIHRoZSBmdW5jdGlvbiByZXR1cm4gdGhlIHZhbHVlIG9mIHRoZSBmaXJzdCBpbnZvY2F0aW9uLiBUaGUgYGZ1bmNgIGlzXG4gICAgICogaW52b2tlZCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBhbmQgYXJndW1lbnRzIG9mIHRoZSBjcmVhdGVkIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcmVzdHJpY3QuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcmVzdHJpY3RlZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGluaXRpYWxpemUgPSBfLm9uY2UoY3JlYXRlQXBwbGljYXRpb24pO1xuICAgICAqIGluaXRpYWxpemUoKTtcbiAgICAgKiBpbml0aWFsaXplKCk7XG4gICAgICogLy8gPT4gYGNyZWF0ZUFwcGxpY2F0aW9uYCBpcyBpbnZva2VkIG9uY2VcbiAgICAgKi9mdW5jdGlvbiBvbmNlKGZ1bmMpe3JldHVybiBiZWZvcmUoMixmdW5jKTt9LyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCBpdHMgYXJndW1lbnRzIHRyYW5zZm9ybWVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAgICAgKiBAcGFyYW0gey4uLihGdW5jdGlvbnxGdW5jdGlvbltdKX0gW3RyYW5zZm9ybXM9W18uaWRlbnRpdHldXVxuICAgICAqICBUaGUgYXJndW1lbnQgdHJhbnNmb3Jtcy5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gZG91YmxlZChuKSB7XG4gICAgICogICByZXR1cm4gbiAqIDI7XG4gICAgICogfVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gc3F1YXJlKG4pIHtcbiAgICAgKiAgIHJldHVybiBuICogbjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgZnVuYyA9IF8ub3ZlckFyZ3MoZnVuY3Rpb24oeCwgeSkge1xuICAgICAqICAgcmV0dXJuIFt4LCB5XTtcbiAgICAgKiB9LCBbc3F1YXJlLCBkb3VibGVkXSk7XG4gICAgICpcbiAgICAgKiBmdW5jKDksIDMpO1xuICAgICAqIC8vID0+IFs4MSwgNl1cbiAgICAgKlxuICAgICAqIGZ1bmMoMTAsIDUpO1xuICAgICAqIC8vID0+IFsxMDAsIDEwXVxuICAgICAqL3ZhciBvdmVyQXJncz1jYXN0UmVzdChmdW5jdGlvbihmdW5jLHRyYW5zZm9ybXMpe3RyYW5zZm9ybXM9dHJhbnNmb3Jtcy5sZW5ndGg9PTEmJmlzQXJyYXkodHJhbnNmb3Jtc1swXSk/YXJyYXlNYXAodHJhbnNmb3Jtc1swXSxiYXNlVW5hcnkoZ2V0SXRlcmF0ZWUoKSkpOmFycmF5TWFwKGJhc2VGbGF0dGVuKHRyYW5zZm9ybXMsMSksYmFzZVVuYXJ5KGdldEl0ZXJhdGVlKCkpKTt2YXIgZnVuY3NMZW5ndGg9dHJhbnNmb3Jtcy5sZW5ndGg7cmV0dXJuIGJhc2VSZXN0KGZ1bmN0aW9uKGFyZ3Mpe3ZhciBpbmRleD0tMSxsZW5ndGg9bmF0aXZlTWluKGFyZ3MubGVuZ3RoLGZ1bmNzTGVuZ3RoKTt3aGlsZSgrK2luZGV4PGxlbmd0aCl7YXJnc1tpbmRleF09dHJhbnNmb3Jtc1tpbmRleF0uY2FsbCh0aGlzLGFyZ3NbaW5kZXhdKTt9cmV0dXJuIGFwcGx5KGZ1bmMsdGhpcyxhcmdzKTt9KTt9KTsvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIGBwYXJ0aWFsc2AgcHJlcGVuZGVkIHRvIHRoZVxuICAgICAqIGFyZ3VtZW50cyBpdCByZWNlaXZlcy4gVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5iaW5kYCBleGNlcHQgaXQgZG9lcyAqKm5vdCoqXG4gICAgICogYWx0ZXIgdGhlIGB0aGlzYCBiaW5kaW5nLlxuICAgICAqXG4gICAgICogVGhlIGBfLnBhcnRpYWwucGxhY2Vob2xkZXJgIHZhbHVlLCB3aGljaCBkZWZhdWx0cyB0byBgX2AgaW4gbW9ub2xpdGhpY1xuICAgICAqIGJ1aWxkcywgbWF5IGJlIHVzZWQgYXMgYSBwbGFjZWhvbGRlciBmb3IgcGFydGlhbGx5IGFwcGxpZWQgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGRvZXNuJ3Qgc2V0IHRoZSBcImxlbmd0aFwiIHByb3BlcnR5IG9mIHBhcnRpYWxseVxuICAgICAqIGFwcGxpZWQgZnVuY3Rpb25zLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMi4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcGFydGlhbGx5IGFwcGx5IGFyZ3VtZW50cyB0by5cbiAgICAgKiBAcGFyYW0gey4uLip9IFtwYXJ0aWFsc10gVGhlIGFyZ3VtZW50cyB0byBiZSBwYXJ0aWFsbHkgYXBwbGllZC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBwYXJ0aWFsbHkgYXBwbGllZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gZ3JlZXQoZ3JlZXRpbmcsIG5hbWUpIHtcbiAgICAgKiAgIHJldHVybiBncmVldGluZyArICcgJyArIG5hbWU7XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIHNheUhlbGxvVG8gPSBfLnBhcnRpYWwoZ3JlZXQsICdoZWxsbycpO1xuICAgICAqIHNheUhlbGxvVG8oJ2ZyZWQnKTtcbiAgICAgKiAvLyA9PiAnaGVsbG8gZnJlZCdcbiAgICAgKlxuICAgICAqIC8vIFBhcnRpYWxseSBhcHBsaWVkIHdpdGggcGxhY2Vob2xkZXJzLlxuICAgICAqIHZhciBncmVldEZyZWQgPSBfLnBhcnRpYWwoZ3JlZXQsIF8sICdmcmVkJyk7XG4gICAgICogZ3JlZXRGcmVkKCdoaScpO1xuICAgICAqIC8vID0+ICdoaSBmcmVkJ1xuICAgICAqL3ZhciBwYXJ0aWFsPWJhc2VSZXN0KGZ1bmN0aW9uKGZ1bmMscGFydGlhbHMpe3ZhciBob2xkZXJzPXJlcGxhY2VIb2xkZXJzKHBhcnRpYWxzLGdldEhvbGRlcihwYXJ0aWFsKSk7cmV0dXJuIGNyZWF0ZVdyYXAoZnVuYyxXUkFQX1BBUlRJQUxfRkxBRyx1bmRlZmluZWQscGFydGlhbHMsaG9sZGVycyk7fSk7LyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5wYXJ0aWFsYCBleGNlcHQgdGhhdCBwYXJ0aWFsbHkgYXBwbGllZCBhcmd1bWVudHNcbiAgICAgKiBhcmUgYXBwZW5kZWQgdG8gdGhlIGFyZ3VtZW50cyBpdCByZWNlaXZlcy5cbiAgICAgKlxuICAgICAqIFRoZSBgXy5wYXJ0aWFsUmlnaHQucGxhY2Vob2xkZXJgIHZhbHVlLCB3aGljaCBkZWZhdWx0cyB0byBgX2AgaW4gbW9ub2xpdGhpY1xuICAgICAqIGJ1aWxkcywgbWF5IGJlIHVzZWQgYXMgYSBwbGFjZWhvbGRlciBmb3IgcGFydGlhbGx5IGFwcGxpZWQgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGRvZXNuJ3Qgc2V0IHRoZSBcImxlbmd0aFwiIHByb3BlcnR5IG9mIHBhcnRpYWxseVxuICAgICAqIGFwcGxpZWQgZnVuY3Rpb25zLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDEuMC4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcGFydGlhbGx5IGFwcGx5IGFyZ3VtZW50cyB0by5cbiAgICAgKiBAcGFyYW0gey4uLip9IFtwYXJ0aWFsc10gVGhlIGFyZ3VtZW50cyB0byBiZSBwYXJ0aWFsbHkgYXBwbGllZC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBwYXJ0aWFsbHkgYXBwbGllZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gZ3JlZXQoZ3JlZXRpbmcsIG5hbWUpIHtcbiAgICAgKiAgIHJldHVybiBncmVldGluZyArICcgJyArIG5hbWU7XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIGdyZWV0RnJlZCA9IF8ucGFydGlhbFJpZ2h0KGdyZWV0LCAnZnJlZCcpO1xuICAgICAqIGdyZWV0RnJlZCgnaGknKTtcbiAgICAgKiAvLyA9PiAnaGkgZnJlZCdcbiAgICAgKlxuICAgICAqIC8vIFBhcnRpYWxseSBhcHBsaWVkIHdpdGggcGxhY2Vob2xkZXJzLlxuICAgICAqIHZhciBzYXlIZWxsb1RvID0gXy5wYXJ0aWFsUmlnaHQoZ3JlZXQsICdoZWxsbycsIF8pO1xuICAgICAqIHNheUhlbGxvVG8oJ2ZyZWQnKTtcbiAgICAgKiAvLyA9PiAnaGVsbG8gZnJlZCdcbiAgICAgKi92YXIgcGFydGlhbFJpZ2h0PWJhc2VSZXN0KGZ1bmN0aW9uKGZ1bmMscGFydGlhbHMpe3ZhciBob2xkZXJzPXJlcGxhY2VIb2xkZXJzKHBhcnRpYWxzLGdldEhvbGRlcihwYXJ0aWFsUmlnaHQpKTtyZXR1cm4gY3JlYXRlV3JhcChmdW5jLFdSQVBfUEFSVElBTF9SSUdIVF9GTEFHLHVuZGVmaW5lZCxwYXJ0aWFscyxob2xkZXJzKTt9KTsvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIGFyZ3VtZW50cyBhcnJhbmdlZCBhY2NvcmRpbmdcbiAgICAgKiB0byB0aGUgc3BlY2lmaWVkIGBpbmRleGVzYCB3aGVyZSB0aGUgYXJndW1lbnQgdmFsdWUgYXQgdGhlIGZpcnN0IGluZGV4IGlzXG4gICAgICogcHJvdmlkZWQgYXMgdGhlIGZpcnN0IGFyZ3VtZW50LCB0aGUgYXJndW1lbnQgdmFsdWUgYXQgdGhlIHNlY29uZCBpbmRleCBpc1xuICAgICAqIHByb3ZpZGVkIGFzIHRoZSBzZWNvbmQgYXJndW1lbnQsIGFuZCBzbyBvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHJlYXJyYW5nZSBhcmd1bWVudHMgZm9yLlxuICAgICAqIEBwYXJhbSB7Li4uKG51bWJlcnxudW1iZXJbXSl9IGluZGV4ZXMgVGhlIGFycmFuZ2VkIGFyZ3VtZW50IGluZGV4ZXMuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciByZWFyZ2VkID0gXy5yZWFyZyhmdW5jdGlvbihhLCBiLCBjKSB7XG4gICAgICogICByZXR1cm4gW2EsIGIsIGNdO1xuICAgICAqIH0sIFsyLCAwLCAxXSk7XG4gICAgICpcbiAgICAgKiByZWFyZ2VkKCdiJywgJ2MnLCAnYScpXG4gICAgICogLy8gPT4gWydhJywgJ2InLCAnYyddXG4gICAgICovdmFyIHJlYXJnPWZsYXRSZXN0KGZ1bmN0aW9uKGZ1bmMsaW5kZXhlcyl7cmV0dXJuIGNyZWF0ZVdyYXAoZnVuYyxXUkFQX1JFQVJHX0ZMQUcsdW5kZWZpbmVkLHVuZGVmaW5lZCx1bmRlZmluZWQsaW5kZXhlcyk7fSk7LyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlXG4gICAgICogY3JlYXRlZCBmdW5jdGlvbiBhbmQgYXJndW1lbnRzIGZyb20gYHN0YXJ0YCBhbmQgYmV5b25kIHByb3ZpZGVkIGFzXG4gICAgICogYW4gYXJyYXkuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgYmFzZWQgb24gdGhlXG4gICAgICogW3Jlc3QgcGFyYW1ldGVyXShodHRwczovL21kbi5pby9yZXN0X3BhcmFtZXRlcnMpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgYSByZXN0IHBhcmFtZXRlciB0by5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PWZ1bmMubGVuZ3RoLTFdIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgcmVzdCBwYXJhbWV0ZXIuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBzYXkgPSBfLnJlc3QoZnVuY3Rpb24od2hhdCwgbmFtZXMpIHtcbiAgICAgKiAgIHJldHVybiB3aGF0ICsgJyAnICsgXy5pbml0aWFsKG5hbWVzKS5qb2luKCcsICcpICtcbiAgICAgKiAgICAgKF8uc2l6ZShuYW1lcykgPiAxID8gJywgJiAnIDogJycpICsgXy5sYXN0KG5hbWVzKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIHNheSgnaGVsbG8nLCAnZnJlZCcsICdiYXJuZXknLCAncGViYmxlcycpO1xuICAgICAqIC8vID0+ICdoZWxsbyBmcmVkLCBiYXJuZXksICYgcGViYmxlcydcbiAgICAgKi9mdW5jdGlvbiByZXN0KGZ1bmMsc3RhcnQpe2lmKHR5cGVvZiBmdW5jIT0nZnVuY3Rpb24nKXt0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7fXN0YXJ0PXN0YXJ0PT09dW5kZWZpbmVkP3N0YXJ0OnRvSW50ZWdlcihzdGFydCk7cmV0dXJuIGJhc2VSZXN0KGZ1bmMsc3RhcnQpO30vKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGVcbiAgICAgKiBjcmVhdGUgZnVuY3Rpb24gYW5kIGFuIGFycmF5IG9mIGFyZ3VtZW50cyBtdWNoIGxpa2VcbiAgICAgKiBbYEZ1bmN0aW9uI2FwcGx5YF0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLWZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseSkuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgYmFzZWQgb24gdGhlXG4gICAgICogW3NwcmVhZCBvcGVyYXRvcl0oaHR0cHM6Ly9tZG4uaW8vc3ByZWFkX29wZXJhdG9yKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjIuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHNwcmVhZCBhcmd1bWVudHMgb3Zlci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PTBdIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgc3ByZWFkLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgc2F5ID0gXy5zcHJlYWQoZnVuY3Rpb24od2hvLCB3aGF0KSB7XG4gICAgICogICByZXR1cm4gd2hvICsgJyBzYXlzICcgKyB3aGF0O1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogc2F5KFsnZnJlZCcsICdoZWxsbyddKTtcbiAgICAgKiAvLyA9PiAnZnJlZCBzYXlzIGhlbGxvJ1xuICAgICAqXG4gICAgICogdmFyIG51bWJlcnMgPSBQcm9taXNlLmFsbChbXG4gICAgICogICBQcm9taXNlLnJlc29sdmUoNDApLFxuICAgICAqICAgUHJvbWlzZS5yZXNvbHZlKDM2KVxuICAgICAqIF0pO1xuICAgICAqXG4gICAgICogbnVtYmVycy50aGVuKF8uc3ByZWFkKGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgKiAgIHJldHVybiB4ICsgeTtcbiAgICAgKiB9KSk7XG4gICAgICogLy8gPT4gYSBQcm9taXNlIG9mIDc2XG4gICAgICovZnVuY3Rpb24gc3ByZWFkKGZ1bmMsc3RhcnQpe2lmKHR5cGVvZiBmdW5jIT0nZnVuY3Rpb24nKXt0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7fXN0YXJ0PXN0YXJ0PT1udWxsPzA6bmF0aXZlTWF4KHRvSW50ZWdlcihzdGFydCksMCk7cmV0dXJuIGJhc2VSZXN0KGZ1bmN0aW9uKGFyZ3Mpe3ZhciBhcnJheT1hcmdzW3N0YXJ0XSxvdGhlckFyZ3M9Y2FzdFNsaWNlKGFyZ3MsMCxzdGFydCk7aWYoYXJyYXkpe2FycmF5UHVzaChvdGhlckFyZ3MsYXJyYXkpO31yZXR1cm4gYXBwbHkoZnVuYyx0aGlzLG90aGVyQXJncyk7fSk7fS8qKlxuICAgICAqIENyZWF0ZXMgYSB0aHJvdHRsZWQgZnVuY3Rpb24gdGhhdCBvbmx5IGludm9rZXMgYGZ1bmNgIGF0IG1vc3Qgb25jZSBwZXJcbiAgICAgKiBldmVyeSBgd2FpdGAgbWlsbGlzZWNvbmRzLiBUaGUgdGhyb3R0bGVkIGZ1bmN0aW9uIGNvbWVzIHdpdGggYSBgY2FuY2VsYFxuICAgICAqIG1ldGhvZCB0byBjYW5jZWwgZGVsYXllZCBgZnVuY2AgaW52b2NhdGlvbnMgYW5kIGEgYGZsdXNoYCBtZXRob2QgdG9cbiAgICAgKiBpbW1lZGlhdGVseSBpbnZva2UgdGhlbS4gUHJvdmlkZSBgb3B0aW9uc2AgdG8gaW5kaWNhdGUgd2hldGhlciBgZnVuY2BcbiAgICAgKiBzaG91bGQgYmUgaW52b2tlZCBvbiB0aGUgbGVhZGluZyBhbmQvb3IgdHJhaWxpbmcgZWRnZSBvZiB0aGUgYHdhaXRgXG4gICAgICogdGltZW91dC4gVGhlIGBmdW5jYCBpcyBpbnZva2VkIHdpdGggdGhlIGxhc3QgYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZVxuICAgICAqIHRocm90dGxlZCBmdW5jdGlvbi4gU3Vic2VxdWVudCBjYWxscyB0byB0aGUgdGhyb3R0bGVkIGZ1bmN0aW9uIHJldHVybiB0aGVcbiAgICAgKiByZXN1bHQgb2YgdGhlIGxhc3QgYGZ1bmNgIGludm9jYXRpb24uXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogSWYgYGxlYWRpbmdgIGFuZCBgdHJhaWxpbmdgIG9wdGlvbnMgYXJlIGB0cnVlYCwgYGZ1bmNgIGlzXG4gICAgICogaW52b2tlZCBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dCBvbmx5IGlmIHRoZSB0aHJvdHRsZWQgZnVuY3Rpb25cbiAgICAgKiBpcyBpbnZva2VkIG1vcmUgdGhhbiBvbmNlIGR1cmluZyB0aGUgYHdhaXRgIHRpbWVvdXQuXG4gICAgICpcbiAgICAgKiBJZiBgd2FpdGAgaXMgYDBgIGFuZCBgbGVhZGluZ2AgaXMgYGZhbHNlYCwgYGZ1bmNgIGludm9jYXRpb24gaXMgZGVmZXJyZWRcbiAgICAgKiB1bnRpbCB0byB0aGUgbmV4dCB0aWNrLCBzaW1pbGFyIHRvIGBzZXRUaW1lb3V0YCB3aXRoIGEgdGltZW91dCBvZiBgMGAuXG4gICAgICpcbiAgICAgKiBTZWUgW0RhdmlkIENvcmJhY2hvJ3MgYXJ0aWNsZV0oaHR0cHM6Ly9jc3MtdHJpY2tzLmNvbS9kZWJvdW5jaW5nLXRocm90dGxpbmctZXhwbGFpbmVkLWV4YW1wbGVzLylcbiAgICAgKiBmb3IgZGV0YWlscyBvdmVyIHRoZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIGBfLnRocm90dGxlYCBhbmQgYF8uZGVib3VuY2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gdGhyb3R0bGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt3YWl0PTBdIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIHRocm90dGxlIGludm9jYXRpb25zIHRvLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gVGhlIG9wdGlvbnMgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMubGVhZGluZz10cnVlXVxuICAgICAqICBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSBsZWFkaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50cmFpbGluZz10cnVlXVxuICAgICAqICBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHRocm90dGxlZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogLy8gQXZvaWQgZXhjZXNzaXZlbHkgdXBkYXRpbmcgdGhlIHBvc2l0aW9uIHdoaWxlIHNjcm9sbGluZy5cbiAgICAgKiBqUXVlcnkod2luZG93KS5vbignc2Nyb2xsJywgXy50aHJvdHRsZSh1cGRhdGVQb3NpdGlvbiwgMTAwKSk7XG4gICAgICpcbiAgICAgKiAvLyBJbnZva2UgYHJlbmV3VG9rZW5gIHdoZW4gdGhlIGNsaWNrIGV2ZW50IGlzIGZpcmVkLCBidXQgbm90IG1vcmUgdGhhbiBvbmNlIGV2ZXJ5IDUgbWludXRlcy5cbiAgICAgKiB2YXIgdGhyb3R0bGVkID0gXy50aHJvdHRsZShyZW5ld1Rva2VuLCAzMDAwMDAsIHsgJ3RyYWlsaW5nJzogZmFsc2UgfSk7XG4gICAgICogalF1ZXJ5KGVsZW1lbnQpLm9uKCdjbGljaycsIHRocm90dGxlZCk7XG4gICAgICpcbiAgICAgKiAvLyBDYW5jZWwgdGhlIHRyYWlsaW5nIHRocm90dGxlZCBpbnZvY2F0aW9uLlxuICAgICAqIGpRdWVyeSh3aW5kb3cpLm9uKCdwb3BzdGF0ZScsIHRocm90dGxlZC5jYW5jZWwpO1xuICAgICAqL2Z1bmN0aW9uIHRocm90dGxlKGZ1bmMsd2FpdCxvcHRpb25zKXt2YXIgbGVhZGluZz10cnVlLHRyYWlsaW5nPXRydWU7aWYodHlwZW9mIGZ1bmMhPSdmdW5jdGlvbicpe3Rocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTt9aWYoaXNPYmplY3Qob3B0aW9ucykpe2xlYWRpbmc9J2xlYWRpbmcnaW4gb3B0aW9ucz8hIW9wdGlvbnMubGVhZGluZzpsZWFkaW5nO3RyYWlsaW5nPSd0cmFpbGluZydpbiBvcHRpb25zPyEhb3B0aW9ucy50cmFpbGluZzp0cmFpbGluZzt9cmV0dXJuIGRlYm91bmNlKGZ1bmMsd2FpdCx7J2xlYWRpbmcnOmxlYWRpbmcsJ21heFdhaXQnOndhaXQsJ3RyYWlsaW5nJzp0cmFpbGluZ30pO30vKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBhY2NlcHRzIHVwIHRvIG9uZSBhcmd1bWVudCwgaWdub3JpbmcgYW55XG4gICAgICogYWRkaXRpb25hbCBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjYXAgYXJndW1lbnRzIGZvci5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjYXBwZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubWFwKFsnNicsICc4JywgJzEwJ10sIF8udW5hcnkocGFyc2VJbnQpKTtcbiAgICAgKiAvLyA9PiBbNiwgOCwgMTBdXG4gICAgICovZnVuY3Rpb24gdW5hcnkoZnVuYyl7cmV0dXJuIGFyeShmdW5jLDEpO30vKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBwcm92aWRlcyBgdmFsdWVgIHRvIGB3cmFwcGVyYCBhcyBpdHMgZmlyc3RcbiAgICAgKiBhcmd1bWVudC4gQW55IGFkZGl0aW9uYWwgYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZSBmdW5jdGlvbiBhcmUgYXBwZW5kZWRcbiAgICAgKiB0byB0aG9zZSBwcm92aWRlZCB0byB0aGUgYHdyYXBwZXJgLiBUaGUgd3JhcHBlciBpcyBpbnZva2VkIHdpdGggdGhlIGB0aGlzYFxuICAgICAqIGJpbmRpbmcgb2YgdGhlIGNyZWF0ZWQgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byB3cmFwLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFt3cmFwcGVyPWlkZW50aXR5XSBUaGUgd3JhcHBlciBmdW5jdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHAgPSBfLndyYXAoXy5lc2NhcGUsIGZ1bmN0aW9uKGZ1bmMsIHRleHQpIHtcbiAgICAgKiAgIHJldHVybiAnPHA+JyArIGZ1bmModGV4dCkgKyAnPC9wPic7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBwKCdmcmVkLCBiYXJuZXksICYgcGViYmxlcycpO1xuICAgICAqIC8vID0+ICc8cD5mcmVkLCBiYXJuZXksICZhbXA7IHBlYmJsZXM8L3A+J1xuICAgICAqL2Z1bmN0aW9uIHdyYXAodmFsdWUsd3JhcHBlcil7cmV0dXJuIHBhcnRpYWwoY2FzdEZ1bmN0aW9uKHdyYXBwZXIpLHZhbHVlKTt9LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qLy8qKlxuICAgICAqIENhc3RzIGB2YWx1ZWAgYXMgYW4gYXJyYXkgaWYgaXQncyBub3Qgb25lLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuNC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY2FzdCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5jYXN0QXJyYXkoMSk7XG4gICAgICogLy8gPT4gWzFdXG4gICAgICpcbiAgICAgKiBfLmNhc3RBcnJheSh7ICdhJzogMSB9KTtcbiAgICAgKiAvLyA9PiBbeyAnYSc6IDEgfV1cbiAgICAgKlxuICAgICAqIF8uY2FzdEFycmF5KCdhYmMnKTtcbiAgICAgKiAvLyA9PiBbJ2FiYyddXG4gICAgICpcbiAgICAgKiBfLmNhc3RBcnJheShudWxsKTtcbiAgICAgKiAvLyA9PiBbbnVsbF1cbiAgICAgKlxuICAgICAqIF8uY2FzdEFycmF5KHVuZGVmaW5lZCk7XG4gICAgICogLy8gPT4gW3VuZGVmaW5lZF1cbiAgICAgKlxuICAgICAqIF8uY2FzdEFycmF5KCk7XG4gICAgICogLy8gPT4gW11cbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFsxLCAyLCAzXTtcbiAgICAgKiBjb25zb2xlLmxvZyhfLmNhc3RBcnJheShhcnJheSkgPT09IGFycmF5KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovZnVuY3Rpb24gY2FzdEFycmF5KCl7aWYoIWFyZ3VtZW50cy5sZW5ndGgpe3JldHVybltdO312YXIgdmFsdWU9YXJndW1lbnRzWzBdO3JldHVybiBpc0FycmF5KHZhbHVlKT92YWx1ZTpbdmFsdWVdO30vKipcbiAgICAgKiBDcmVhdGVzIGEgc2hhbGxvdyBjbG9uZSBvZiBgdmFsdWVgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb24gdGhlXG4gICAgICogW3N0cnVjdHVyZWQgY2xvbmUgYWxnb3JpdGhtXShodHRwczovL21kbi5pby9TdHJ1Y3R1cmVkX2Nsb25lX2FsZ29yaXRobSlcbiAgICAgKiBhbmQgc3VwcG9ydHMgY2xvbmluZyBhcnJheXMsIGFycmF5IGJ1ZmZlcnMsIGJvb2xlYW5zLCBkYXRlIG9iamVjdHMsIG1hcHMsXG4gICAgICogbnVtYmVycywgYE9iamVjdGAgb2JqZWN0cywgcmVnZXhlcywgc2V0cywgc3RyaW5ncywgc3ltYm9scywgYW5kIHR5cGVkXG4gICAgICogYXJyYXlzLiBUaGUgb3duIGVudW1lcmFibGUgcHJvcGVydGllcyBvZiBgYXJndW1lbnRzYCBvYmplY3RzIGFyZSBjbG9uZWRcbiAgICAgKiBhcyBwbGFpbiBvYmplY3RzLiBBbiBlbXB0eSBvYmplY3QgaXMgcmV0dXJuZWQgZm9yIHVuY2xvbmVhYmxlIHZhbHVlcyBzdWNoXG4gICAgICogYXMgZXJyb3Igb2JqZWN0cywgZnVuY3Rpb25zLCBET00gbm9kZXMsIGFuZCBXZWFrTWFwcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2xvbmUuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGNsb25lZCB2YWx1ZS5cbiAgICAgKiBAc2VlIF8uY2xvbmVEZWVwXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW3sgJ2EnOiAxIH0sIHsgJ2InOiAyIH1dO1xuICAgICAqXG4gICAgICogdmFyIHNoYWxsb3cgPSBfLmNsb25lKG9iamVjdHMpO1xuICAgICAqIGNvbnNvbGUubG9nKHNoYWxsb3dbMF0gPT09IG9iamVjdHNbMF0pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9mdW5jdGlvbiBjbG9uZSh2YWx1ZSl7cmV0dXJuIGJhc2VDbG9uZSh2YWx1ZSxDTE9ORV9TWU1CT0xTX0ZMQUcpO30vKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmNsb25lYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjdXN0b21pemVyYCB3aGljaFxuICAgICAqIGlzIGludm9rZWQgdG8gcHJvZHVjZSB0aGUgY2xvbmVkIHZhbHVlLiBJZiBgY3VzdG9taXplcmAgcmV0dXJucyBgdW5kZWZpbmVkYCxcbiAgICAgKiBjbG9uaW5nIGlzIGhhbmRsZWQgYnkgdGhlIG1ldGhvZCBpbnN0ZWFkLiBUaGUgYGN1c3RvbWl6ZXJgIGlzIGludm9rZWQgd2l0aFxuICAgICAqIHVwIHRvIGZvdXIgYXJndW1lbnRzOyAodmFsdWUgWywgaW5kZXh8a2V5LCBvYmplY3QsIHN0YWNrXSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNsb25lLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNsb25pbmcuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGNsb25lZCB2YWx1ZS5cbiAgICAgKiBAc2VlIF8uY2xvbmVEZWVwV2l0aFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBjdXN0b21pemVyKHZhbHVlKSB7XG4gICAgICogICBpZiAoXy5pc0VsZW1lbnQodmFsdWUpKSB7XG4gICAgICogICAgIHJldHVybiB2YWx1ZS5jbG9uZU5vZGUoZmFsc2UpO1xuICAgICAqICAgfVxuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciBlbCA9IF8uY2xvbmVXaXRoKGRvY3VtZW50LmJvZHksIGN1c3RvbWl6ZXIpO1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2coZWwgPT09IGRvY3VtZW50LmJvZHkpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICogY29uc29sZS5sb2coZWwubm9kZU5hbWUpO1xuICAgICAqIC8vID0+ICdCT0RZJ1xuICAgICAqIGNvbnNvbGUubG9nKGVsLmNoaWxkTm9kZXMubGVuZ3RoKTtcbiAgICAgKiAvLyA9PiAwXG4gICAgICovZnVuY3Rpb24gY2xvbmVXaXRoKHZhbHVlLGN1c3RvbWl6ZXIpe2N1c3RvbWl6ZXI9dHlwZW9mIGN1c3RvbWl6ZXI9PSdmdW5jdGlvbic/Y3VzdG9taXplcjp1bmRlZmluZWQ7cmV0dXJuIGJhc2VDbG9uZSh2YWx1ZSxDTE9ORV9TWU1CT0xTX0ZMQUcsY3VzdG9taXplcik7fS8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uY2xvbmVgIGV4Y2VwdCB0aGF0IGl0IHJlY3Vyc2l2ZWx5IGNsb25lcyBgdmFsdWVgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDEuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byByZWN1cnNpdmVseSBjbG9uZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZGVlcCBjbG9uZWQgdmFsdWUuXG4gICAgICogQHNlZSBfLmNsb25lXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW3sgJ2EnOiAxIH0sIHsgJ2InOiAyIH1dO1xuICAgICAqXG4gICAgICogdmFyIGRlZXAgPSBfLmNsb25lRGVlcChvYmplY3RzKTtcbiAgICAgKiBjb25zb2xlLmxvZyhkZWVwWzBdID09PSBvYmplY3RzWzBdKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL2Z1bmN0aW9uIGNsb25lRGVlcCh2YWx1ZSl7cmV0dXJuIGJhc2VDbG9uZSh2YWx1ZSxDTE9ORV9ERUVQX0ZMQUd8Q0xPTkVfU1lNQk9MU19GTEFHKTt9LyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5jbG9uZVdpdGhgIGV4Y2VwdCB0aGF0IGl0IHJlY3Vyc2l2ZWx5IGNsb25lcyBgdmFsdWVgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byByZWN1cnNpdmVseSBjbG9uZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjbG9uaW5nLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBkZWVwIGNsb25lZCB2YWx1ZS5cbiAgICAgKiBAc2VlIF8uY2xvbmVXaXRoXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGN1c3RvbWl6ZXIodmFsdWUpIHtcbiAgICAgKiAgIGlmIChfLmlzRWxlbWVudCh2YWx1ZSkpIHtcbiAgICAgKiAgICAgcmV0dXJuIHZhbHVlLmNsb25lTm9kZSh0cnVlKTtcbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgZWwgPSBfLmNsb25lRGVlcFdpdGgoZG9jdW1lbnQuYm9keSwgY3VzdG9taXplcik7XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhlbCA9PT0gZG9jdW1lbnQuYm9keSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKiBjb25zb2xlLmxvZyhlbC5ub2RlTmFtZSk7XG4gICAgICogLy8gPT4gJ0JPRFknXG4gICAgICogY29uc29sZS5sb2coZWwuY2hpbGROb2Rlcy5sZW5ndGgpO1xuICAgICAqIC8vID0+IDIwXG4gICAgICovZnVuY3Rpb24gY2xvbmVEZWVwV2l0aCh2YWx1ZSxjdXN0b21pemVyKXtjdXN0b21pemVyPXR5cGVvZiBjdXN0b21pemVyPT0nZnVuY3Rpb24nP2N1c3RvbWl6ZXI6dW5kZWZpbmVkO3JldHVybiBiYXNlQ2xvbmUodmFsdWUsQ0xPTkVfREVFUF9GTEFHfENMT05FX1NZTUJPTFNfRkxBRyxjdXN0b21pemVyKTt9LyoqXG4gICAgICogQ2hlY2tzIGlmIGBvYmplY3RgIGNvbmZvcm1zIHRvIGBzb3VyY2VgIGJ5IGludm9raW5nIHRoZSBwcmVkaWNhdGVcbiAgICAgKiBwcm9wZXJ0aWVzIG9mIGBzb3VyY2VgIHdpdGggdGhlIGNvcnJlc3BvbmRpbmcgcHJvcGVydHkgdmFsdWVzIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGVxdWl2YWxlbnQgdG8gYF8uY29uZm9ybXNgIHdoZW4gYHNvdXJjZWAgaXNcbiAgICAgKiBwYXJ0aWFsbHkgYXBwbGllZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjE0LjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSBwcmVkaWNhdGVzIHRvIGNvbmZvcm0gdG8uXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBvYmplY3RgIGNvbmZvcm1zLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAyIH07XG4gICAgICpcbiAgICAgKiBfLmNvbmZvcm1zVG8ob2JqZWN0LCB7ICdiJzogZnVuY3Rpb24obikgeyByZXR1cm4gbiA+IDE7IH0gfSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5jb25mb3Jtc1RvKG9iamVjdCwgeyAnYic6IGZ1bmN0aW9uKG4pIHsgcmV0dXJuIG4gPiAyOyB9IH0pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovZnVuY3Rpb24gY29uZm9ybXNUbyhvYmplY3Qsc291cmNlKXtyZXR1cm4gc291cmNlPT1udWxsfHxiYXNlQ29uZm9ybXNUbyhvYmplY3Qsc291cmNlLGtleXMoc291cmNlKSk7fS8qKlxuICAgICAqIFBlcmZvcm1zIGFcbiAgICAgKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICAgICAqIGNvbXBhcmlzb24gYmV0d2VlbiB0d28gdmFsdWVzIHRvIGRldGVybWluZSBpZiB0aGV5IGFyZSBlcXVpdmFsZW50LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gICAgICogdmFyIG90aGVyID0geyAnYSc6IDEgfTtcbiAgICAgKlxuICAgICAqIF8uZXEob2JqZWN0LCBvYmplY3QpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uZXEob2JqZWN0LCBvdGhlcik7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uZXEoJ2EnLCAnYScpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uZXEoJ2EnLCBPYmplY3QoJ2EnKSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uZXEoTmFOLCBOYU4pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9mdW5jdGlvbiBlcSh2YWx1ZSxvdGhlcil7cmV0dXJuIHZhbHVlPT09b3RoZXJ8fHZhbHVlIT09dmFsdWUmJm90aGVyIT09b3RoZXI7fS8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGdyZWF0ZXIgdGhhbiBgb3RoZXJgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuOS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZ3JlYXRlciB0aGFuIGBvdGhlcmAsXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAc2VlIF8ubHRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5ndCgzLCAxKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmd0KDMsIDMpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmd0KDEsIDMpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovdmFyIGd0PWNyZWF0ZVJlbGF0aW9uYWxPcGVyYXRpb24oYmFzZUd0KTsvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gYG90aGVyYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjkuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0b1xuICAgICAqICBgb3RoZXJgLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQHNlZSBfLmx0ZVxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmd0ZSgzLCAxKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmd0ZSgzLCAzKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmd0ZSgxLCAzKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL3ZhciBndGU9Y3JlYXRlUmVsYXRpb25hbE9wZXJhdGlvbihmdW5jdGlvbih2YWx1ZSxvdGhlcil7cmV0dXJuIHZhbHVlPj1vdGhlcjt9KTsvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzQXJndW1lbnRzKFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi92YXIgaXNBcmd1bWVudHM9YmFzZUlzQXJndW1lbnRzKGZ1bmN0aW9uKCl7cmV0dXJuIGFyZ3VtZW50czt9KCkpP2Jhc2VJc0FyZ3VtZW50czpmdW5jdGlvbih2YWx1ZSl7cmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkmJmhhc093blByb3BlcnR5LmNhbGwodmFsdWUsJ2NhbGxlZScpJiYhcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh2YWx1ZSwnY2FsbGVlJyk7fTsvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGFuIGBBcnJheWAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXkoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXkoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheSgnYWJjJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheShfLm5vb3ApO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovdmFyIGlzQXJyYXk9QXJyYXkuaXNBcnJheTsvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGFuIGBBcnJheUJ1ZmZlcmAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMy4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheSBidWZmZXIsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5QnVmZmVyKG5ldyBBcnJheUJ1ZmZlcigyKSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5QnVmZmVyKG5ldyBBcnJheSgyKSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi92YXIgaXNBcnJheUJ1ZmZlcj1ub2RlSXNBcnJheUJ1ZmZlcj9iYXNlVW5hcnkobm9kZUlzQXJyYXlCdWZmZXIpOmJhc2VJc0FycmF5QnVmZmVyOy8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UuIEEgdmFsdWUgaXMgY29uc2lkZXJlZCBhcnJheS1saWtlIGlmIGl0J3NcbiAgICAgKiBub3QgYSBmdW5jdGlvbiBhbmQgaGFzIGEgYHZhbHVlLmxlbmd0aGAgdGhhdCdzIGFuIGludGVnZXIgZ3JlYXRlciB0aGFuIG9yXG4gICAgICogZXF1YWwgdG8gYDBgIGFuZCBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYE51bWJlci5NQVhfU0FGRV9JTlRFR0VSYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXlMaWtlKFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5TGlrZShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXlMaWtlKCdhYmMnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXlMaWtlKF8ubm9vcCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9mdW5jdGlvbiBpc0FycmF5TGlrZSh2YWx1ZSl7cmV0dXJuIHZhbHVlIT1udWxsJiZpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpJiYhaXNGdW5jdGlvbih2YWx1ZSk7fS8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uaXNBcnJheUxpa2VgIGV4Y2VwdCB0aGF0IGl0IGFsc28gY2hlY2tzIGlmIGB2YWx1ZWBcbiAgICAgKiBpcyBhbiBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LWxpa2Ugb2JqZWN0LFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheUxpa2VPYmplY3QoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXlMaWtlT2JqZWN0KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheUxpa2VPYmplY3QoJ2FiYycpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXlMaWtlT2JqZWN0KF8ubm9vcCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9mdW5jdGlvbiBpc0FycmF5TGlrZU9iamVjdCh2YWx1ZSl7cmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkmJmlzQXJyYXlMaWtlKHZhbHVlKTt9LyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGJvb2xlYW4gcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBib29sZWFuLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNCb29sZWFuKGZhbHNlKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzQm9vbGVhbihudWxsKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL2Z1bmN0aW9uIGlzQm9vbGVhbih2YWx1ZSl7cmV0dXJuIHZhbHVlPT09dHJ1ZXx8dmFsdWU9PT1mYWxzZXx8aXNPYmplY3RMaWtlKHZhbHVlKSYmYmFzZUdldFRhZyh2YWx1ZSk9PWJvb2xUYWc7fS8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMy4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGJ1ZmZlciwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzQnVmZmVyKG5ldyBCdWZmZXIoMikpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNCdWZmZXIobmV3IFVpbnQ4QXJyYXkoMikpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovdmFyIGlzQnVmZmVyPW5hdGl2ZUlzQnVmZmVyfHxzdHViRmFsc2U7LyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBEYXRlYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZGF0ZSBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0RhdGUobmV3IERhdGUpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNEYXRlKCdNb24gQXByaWwgMjMgMjAxMicpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovdmFyIGlzRGF0ZT1ub2RlSXNEYXRlP2Jhc2VVbmFyeShub2RlSXNEYXRlKTpiYXNlSXNEYXRlOy8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhIERPTSBlbGVtZW50LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIERPTSBlbGVtZW50LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNFbGVtZW50KGRvY3VtZW50LmJvZHkpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNFbGVtZW50KCc8Ym9keT4nKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL2Z1bmN0aW9uIGlzRWxlbWVudCh2YWx1ZSl7cmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkmJnZhbHVlLm5vZGVUeXBlPT09MSYmIWlzUGxhaW5PYmplY3QodmFsdWUpO30vKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhbiBlbXB0eSBvYmplY3QsIGNvbGxlY3Rpb24sIG1hcCwgb3Igc2V0LlxuICAgICAqXG4gICAgICogT2JqZWN0cyBhcmUgY29uc2lkZXJlZCBlbXB0eSBpZiB0aGV5IGhhdmUgbm8gb3duIGVudW1lcmFibGUgc3RyaW5nIGtleWVkXG4gICAgICogcHJvcGVydGllcy5cbiAgICAgKlxuICAgICAqIEFycmF5LWxpa2UgdmFsdWVzIHN1Y2ggYXMgYGFyZ3VtZW50c2Agb2JqZWN0cywgYXJyYXlzLCBidWZmZXJzLCBzdHJpbmdzLCBvclxuICAgICAqIGpRdWVyeS1saWtlIGNvbGxlY3Rpb25zIGFyZSBjb25zaWRlcmVkIGVtcHR5IGlmIHRoZXkgaGF2ZSBhIGBsZW5ndGhgIG9mIGAwYC5cbiAgICAgKiBTaW1pbGFybHksIG1hcHMgYW5kIHNldHMgYXJlIGNvbnNpZGVyZWQgZW1wdHkgaWYgdGhleSBoYXZlIGEgYHNpemVgIG9mIGAwYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZW1wdHksIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0VtcHR5KG51bGwpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNFbXB0eSh0cnVlKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzRW1wdHkoMSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0VtcHR5KFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNFbXB0eSh7ICdhJzogMSB9KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL2Z1bmN0aW9uIGlzRW1wdHkodmFsdWUpe2lmKHZhbHVlPT1udWxsKXtyZXR1cm4gdHJ1ZTt9aWYoaXNBcnJheUxpa2UodmFsdWUpJiYoaXNBcnJheSh2YWx1ZSl8fHR5cGVvZiB2YWx1ZT09J3N0cmluZyd8fHR5cGVvZiB2YWx1ZS5zcGxpY2U9PSdmdW5jdGlvbid8fGlzQnVmZmVyKHZhbHVlKXx8aXNUeXBlZEFycmF5KHZhbHVlKXx8aXNBcmd1bWVudHModmFsdWUpKSl7cmV0dXJuIXZhbHVlLmxlbmd0aDt9dmFyIHRhZz1nZXRUYWcodmFsdWUpO2lmKHRhZz09bWFwVGFnfHx0YWc9PXNldFRhZyl7cmV0dXJuIXZhbHVlLnNpemU7fWlmKGlzUHJvdG90eXBlKHZhbHVlKSl7cmV0dXJuIWJhc2VLZXlzKHZhbHVlKS5sZW5ndGg7fWZvcih2YXIga2V5IGluIHZhbHVlKXtpZihoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLGtleSkpe3JldHVybiBmYWxzZTt9fXJldHVybiB0cnVlO30vKipcbiAgICAgKiBQZXJmb3JtcyBhIGRlZXAgY29tcGFyaXNvbiBiZXR3ZWVuIHR3byB2YWx1ZXMgdG8gZGV0ZXJtaW5lIGlmIHRoZXkgYXJlXG4gICAgICogZXF1aXZhbGVudC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBzdXBwb3J0cyBjb21wYXJpbmcgYXJyYXlzLCBhcnJheSBidWZmZXJzLCBib29sZWFucyxcbiAgICAgKiBkYXRlIG9iamVjdHMsIGVycm9yIG9iamVjdHMsIG1hcHMsIG51bWJlcnMsIGBPYmplY3RgIG9iamVjdHMsIHJlZ2V4ZXMsXG4gICAgICogc2V0cywgc3RyaW5ncywgc3ltYm9scywgYW5kIHR5cGVkIGFycmF5cy4gYE9iamVjdGAgb2JqZWN0cyBhcmUgY29tcGFyZWRcbiAgICAgKiBieSB0aGVpciBvd24sIG5vdCBpbmhlcml0ZWQsIGVudW1lcmFibGUgcHJvcGVydGllcy4gRnVuY3Rpb25zIGFuZCBET01cbiAgICAgKiBub2RlcyBhcmUgY29tcGFyZWQgYnkgc3RyaWN0IGVxdWFsaXR5LCBpLmUuIGA9PT1gLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gICAgICogdmFyIG90aGVyID0geyAnYSc6IDEgfTtcbiAgICAgKlxuICAgICAqIF8uaXNFcXVhbChvYmplY3QsIG90aGVyKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBvYmplY3QgPT09IG90aGVyO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovZnVuY3Rpb24gaXNFcXVhbCh2YWx1ZSxvdGhlcil7cmV0dXJuIGJhc2VJc0VxdWFsKHZhbHVlLG90aGVyKTt9LyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5pc0VxdWFsYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjdXN0b21pemVyYCB3aGljaFxuICAgICAqIGlzIGludm9rZWQgdG8gY29tcGFyZSB2YWx1ZXMuIElmIGBjdXN0b21pemVyYCByZXR1cm5zIGB1bmRlZmluZWRgLCBjb21wYXJpc29uc1xuICAgICAqIGFyZSBoYW5kbGVkIGJ5IHRoZSBtZXRob2QgaW5zdGVhZC4gVGhlIGBjdXN0b21pemVyYCBpcyBpbnZva2VkIHdpdGggdXAgdG9cbiAgICAgKiBzaXggYXJndW1lbnRzOiAob2JqVmFsdWUsIG90aFZhbHVlIFssIGluZGV4fGtleSwgb2JqZWN0LCBvdGhlciwgc3RhY2tdKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGlzR3JlZXRpbmcodmFsdWUpIHtcbiAgICAgKiAgIHJldHVybiAvXmgoPzppfGVsbG8pJC8udGVzdCh2YWx1ZSk7XG4gICAgICogfVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gY3VzdG9taXplcihvYmpWYWx1ZSwgb3RoVmFsdWUpIHtcbiAgICAgKiAgIGlmIChpc0dyZWV0aW5nKG9ialZhbHVlKSAmJiBpc0dyZWV0aW5nKG90aFZhbHVlKSkge1xuICAgICAqICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbJ2hlbGxvJywgJ2dvb2RieWUnXTtcbiAgICAgKiB2YXIgb3RoZXIgPSBbJ2hpJywgJ2dvb2RieWUnXTtcbiAgICAgKlxuICAgICAqIF8uaXNFcXVhbFdpdGgoYXJyYXksIG90aGVyLCBjdXN0b21pemVyKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovZnVuY3Rpb24gaXNFcXVhbFdpdGgodmFsdWUsb3RoZXIsY3VzdG9taXplcil7Y3VzdG9taXplcj10eXBlb2YgY3VzdG9taXplcj09J2Z1bmN0aW9uJz9jdXN0b21pemVyOnVuZGVmaW5lZDt2YXIgcmVzdWx0PWN1c3RvbWl6ZXI/Y3VzdG9taXplcih2YWx1ZSxvdGhlcik6dW5kZWZpbmVkO3JldHVybiByZXN1bHQ9PT11bmRlZmluZWQ/YmFzZUlzRXF1YWwodmFsdWUsb3RoZXIsdW5kZWZpbmVkLGN1c3RvbWl6ZXIpOiEhcmVzdWx0O30vKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhbiBgRXJyb3JgLCBgRXZhbEVycm9yYCwgYFJhbmdlRXJyb3JgLCBgUmVmZXJlbmNlRXJyb3JgLFxuICAgICAqIGBTeW50YXhFcnJvcmAsIGBUeXBlRXJyb3JgLCBvciBgVVJJRXJyb3JgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gZXJyb3Igb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNFcnJvcihuZXcgRXJyb3IpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNFcnJvcihFcnJvcik7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9mdW5jdGlvbiBpc0Vycm9yKHZhbHVlKXtpZighaXNPYmplY3RMaWtlKHZhbHVlKSl7cmV0dXJuIGZhbHNlO312YXIgdGFnPWJhc2VHZXRUYWcodmFsdWUpO3JldHVybiB0YWc9PWVycm9yVGFnfHx0YWc9PWRvbUV4Y1RhZ3x8dHlwZW9mIHZhbHVlLm1lc3NhZ2U9PSdzdHJpbmcnJiZ0eXBlb2YgdmFsdWUubmFtZT09J3N0cmluZycmJiFpc1BsYWluT2JqZWN0KHZhbHVlKTt9LyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBmaW5pdGUgcHJpbWl0aXZlIG51bWJlci5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBiYXNlZCBvblxuICAgICAqIFtgTnVtYmVyLmlzRmluaXRlYF0oaHR0cHM6Ly9tZG4uaW8vTnVtYmVyL2lzRmluaXRlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBmaW5pdGUgbnVtYmVyLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNGaW5pdGUoMyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0Zpbml0ZShOdW1iZXIuTUlOX1ZBTFVFKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzRmluaXRlKEluZmluaXR5KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc0Zpbml0ZSgnMycpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovZnVuY3Rpb24gaXNGaW5pdGUodmFsdWUpe3JldHVybiB0eXBlb2YgdmFsdWU9PSdudW1iZXInJiZuYXRpdmVJc0Zpbml0ZSh2YWx1ZSk7fS8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgRnVuY3Rpb25gIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBmdW5jdGlvbiwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzRnVuY3Rpb24oXyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0Z1bmN0aW9uKC9hYmMvKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL2Z1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpe2lmKCFpc09iamVjdCh2YWx1ZSkpe3JldHVybiBmYWxzZTt9Ly8gVGhlIHVzZSBvZiBgT2JqZWN0I3RvU3RyaW5nYCBhdm9pZHMgaXNzdWVzIHdpdGggdGhlIGB0eXBlb2ZgIG9wZXJhdG9yXG4vLyBpbiBTYWZhcmkgOSB3aGljaCByZXR1cm5zICdvYmplY3QnIGZvciB0eXBlZCBhcnJheXMgYW5kIG90aGVyIGNvbnN0cnVjdG9ycy5cbnZhciB0YWc9YmFzZUdldFRhZyh2YWx1ZSk7cmV0dXJuIHRhZz09ZnVuY1RhZ3x8dGFnPT1nZW5UYWd8fHRhZz09YXN5bmNUYWd8fHRhZz09cHJveHlUYWc7fS8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFuIGludGVnZXIuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgYmFzZWQgb25cbiAgICAgKiBbYE51bWJlci5pc0ludGVnZXJgXShodHRwczovL21kbi5pby9OdW1iZXIvaXNJbnRlZ2VyKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gaW50ZWdlciwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzSW50ZWdlcigzKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzSW50ZWdlcihOdW1iZXIuTUlOX1ZBTFVFKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc0ludGVnZXIoSW5maW5pdHkpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzSW50ZWdlcignMycpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovZnVuY3Rpb24gaXNJbnRlZ2VyKHZhbHVlKXtyZXR1cm4gdHlwZW9mIHZhbHVlPT0nbnVtYmVyJyYmdmFsdWU9PXRvSW50ZWdlcih2YWx1ZSk7fS8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBsZW5ndGguXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvblxuICAgICAqIFtgVG9MZW5ndGhgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy10b2xlbmd0aCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgbGVuZ3RoLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNMZW5ndGgoMyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0xlbmd0aChOdW1iZXIuTUlOX1ZBTFVFKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc0xlbmd0aChJbmZpbml0eSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNMZW5ndGgoJzMnKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL2Z1bmN0aW9uIGlzTGVuZ3RoKHZhbHVlKXtyZXR1cm4gdHlwZW9mIHZhbHVlPT0nbnVtYmVyJyYmdmFsdWU+LTEmJnZhbHVlJTE9PTAmJnZhbHVlPD1NQVhfU0FGRV9JTlRFR0VSO30vKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGVcbiAgICAgKiBbbGFuZ3VhZ2UgdHlwZV0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLWVjbWFzY3JpcHQtbGFuZ3VhZ2UtdHlwZXMpXG4gICAgICogb2YgYE9iamVjdGAuIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc09iamVjdCh7fSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNPYmplY3QoXy5ub29wKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzT2JqZWN0KG51bGwpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpe3ZhciB0eXBlPXR5cGVvZiB2YWx1ZTtyZXR1cm4gdmFsdWUhPW51bGwmJih0eXBlPT0nb2JqZWN0J3x8dHlwZT09J2Z1bmN0aW9uJyk7fS8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxuICAgICAqIGFuZCBoYXMgYSBgdHlwZW9mYCByZXN1bHQgb2YgXCJvYmplY3RcIi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc09iamVjdExpa2Uoe30pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpe3JldHVybiB2YWx1ZSE9bnVsbCYmdHlwZW9mIHZhbHVlPT0nb2JqZWN0Jzt9LyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBNYXBgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjMuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBtYXAsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc01hcChuZXcgTWFwKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTWFwKG5ldyBXZWFrTWFwKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL3ZhciBpc01hcD1ub2RlSXNNYXA/YmFzZVVuYXJ5KG5vZGVJc01hcCk6YmFzZUlzTWFwOy8qKlxuICAgICAqIFBlcmZvcm1zIGEgcGFydGlhbCBkZWVwIGNvbXBhcmlzb24gYmV0d2VlbiBgb2JqZWN0YCBhbmQgYHNvdXJjZWAgdG9cbiAgICAgKiBkZXRlcm1pbmUgaWYgYG9iamVjdGAgY29udGFpbnMgZXF1aXZhbGVudCBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgZXF1aXZhbGVudCB0byBgXy5tYXRjaGVzYCB3aGVuIGBzb3VyY2VgIGlzXG4gICAgICogcGFydGlhbGx5IGFwcGxpZWQuXG4gICAgICpcbiAgICAgKiBQYXJ0aWFsIGNvbXBhcmlzb25zIHdpbGwgbWF0Y2ggZW1wdHkgYXJyYXkgYW5kIGVtcHR5IG9iamVjdCBgc291cmNlYFxuICAgICAqIHZhbHVlcyBhZ2FpbnN0IGFueSBhcnJheSBvciBvYmplY3QgdmFsdWUsIHJlc3BlY3RpdmVseS4gU2VlIGBfLmlzRXF1YWxgXG4gICAgICogZm9yIGEgbGlzdCBvZiBzdXBwb3J0ZWQgdmFsdWUgY29tcGFyaXNvbnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSB2YWx1ZXMgdG8gbWF0Y2guXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBvYmplY3RgIGlzIGEgbWF0Y2gsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6IDIgfTtcbiAgICAgKlxuICAgICAqIF8uaXNNYXRjaChvYmplY3QsIHsgJ2InOiAyIH0pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNNYXRjaChvYmplY3QsIHsgJ2InOiAxIH0pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovZnVuY3Rpb24gaXNNYXRjaChvYmplY3Qsc291cmNlKXtyZXR1cm4gb2JqZWN0PT09c291cmNlfHxiYXNlSXNNYXRjaChvYmplY3Qsc291cmNlLGdldE1hdGNoRGF0YShzb3VyY2UpKTt9LyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5pc01hdGNoYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjdXN0b21pemVyYCB3aGljaFxuICAgICAqIGlzIGludm9rZWQgdG8gY29tcGFyZSB2YWx1ZXMuIElmIGBjdXN0b21pemVyYCByZXR1cm5zIGB1bmRlZmluZWRgLCBjb21wYXJpc29uc1xuICAgICAqIGFyZSBoYW5kbGVkIGJ5IHRoZSBtZXRob2QgaW5zdGVhZC4gVGhlIGBjdXN0b21pemVyYCBpcyBpbnZva2VkIHdpdGggZml2ZVxuICAgICAqIGFyZ3VtZW50czogKG9ialZhbHVlLCBzcmNWYWx1ZSwgaW5kZXh8a2V5LCBvYmplY3QsIHNvdXJjZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSB2YWx1ZXMgdG8gbWF0Y2guXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBvYmplY3RgIGlzIGEgbWF0Y2gsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gaXNHcmVldGluZyh2YWx1ZSkge1xuICAgICAqICAgcmV0dXJuIC9eaCg/Oml8ZWxsbykkLy50ZXN0KHZhbHVlKTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBjdXN0b21pemVyKG9ialZhbHVlLCBzcmNWYWx1ZSkge1xuICAgICAqICAgaWYgKGlzR3JlZXRpbmcob2JqVmFsdWUpICYmIGlzR3JlZXRpbmcoc3JjVmFsdWUpKSB7XG4gICAgICogICAgIHJldHVybiB0cnVlO1xuICAgICAqICAgfVxuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdncmVldGluZyc6ICdoZWxsbycgfTtcbiAgICAgKiB2YXIgc291cmNlID0geyAnZ3JlZXRpbmcnOiAnaGknIH07XG4gICAgICpcbiAgICAgKiBfLmlzTWF0Y2hXaXRoKG9iamVjdCwgc291cmNlLCBjdXN0b21pemVyKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovZnVuY3Rpb24gaXNNYXRjaFdpdGgob2JqZWN0LHNvdXJjZSxjdXN0b21pemVyKXtjdXN0b21pemVyPXR5cGVvZiBjdXN0b21pemVyPT0nZnVuY3Rpb24nP2N1c3RvbWl6ZXI6dW5kZWZpbmVkO3JldHVybiBiYXNlSXNNYXRjaChvYmplY3Qsc291cmNlLGdldE1hdGNoRGF0YShzb3VyY2UpLGN1c3RvbWl6ZXIpO30vKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBgTmFOYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBiYXNlZCBvblxuICAgICAqIFtgTnVtYmVyLmlzTmFOYF0oaHR0cHM6Ly9tZG4uaW8vTnVtYmVyL2lzTmFOKSBhbmQgaXMgbm90IHRoZSBzYW1lIGFzXG4gICAgICogZ2xvYmFsIFtgaXNOYU5gXShodHRwczovL21kbi5pby9pc05hTikgd2hpY2ggcmV0dXJucyBgdHJ1ZWAgZm9yXG4gICAgICogYHVuZGVmaW5lZGAgYW5kIG90aGVyIG5vbi1udW1iZXIgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBgTmFOYCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzTmFOKE5hTik7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc05hTihuZXcgTnVtYmVyKE5hTikpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIGlzTmFOKHVuZGVmaW5lZCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc05hTih1bmRlZmluZWQpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovZnVuY3Rpb24gaXNOYU4odmFsdWUpey8vIEFuIGBOYU5gIHByaW1pdGl2ZSBpcyB0aGUgb25seSB2YWx1ZSB0aGF0IGlzIG5vdCBlcXVhbCB0byBpdHNlbGYuXG4vLyBQZXJmb3JtIHRoZSBgdG9TdHJpbmdUYWdgIGNoZWNrIGZpcnN0IHRvIGF2b2lkIGVycm9ycyB3aXRoIHNvbWVcbi8vIEFjdGl2ZVggb2JqZWN0cyBpbiBJRS5cbnJldHVybiBpc051bWJlcih2YWx1ZSkmJnZhbHVlIT0rdmFsdWU7fS8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgcHJpc3RpbmUgbmF0aXZlIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGNhbid0IHJlbGlhYmx5IGRldGVjdCBuYXRpdmUgZnVuY3Rpb25zIGluIHRoZSBwcmVzZW5jZVxuICAgICAqIG9mIHRoZSBjb3JlLWpzIHBhY2thZ2UgYmVjYXVzZSBjb3JlLWpzIGNpcmN1bXZlbnRzIHRoaXMga2luZCBvZiBkZXRlY3Rpb24uXG4gICAgICogRGVzcGl0ZSBtdWx0aXBsZSByZXF1ZXN0cywgdGhlIGNvcmUtanMgbWFpbnRhaW5lciBoYXMgbWFkZSBpdCBjbGVhcjogYW55XG4gICAgICogYXR0ZW1wdCB0byBmaXggdGhlIGRldGVjdGlvbiB3aWxsIGJlIG9ic3RydWN0ZWQuIEFzIGEgcmVzdWx0LCB3ZSdyZSBsZWZ0XG4gICAgICogd2l0aCBsaXR0bGUgY2hvaWNlIGJ1dCB0byB0aHJvdyBhbiBlcnJvci4gVW5mb3J0dW5hdGVseSwgdGhpcyBhbHNvIGFmZmVjdHNcbiAgICAgKiBwYWNrYWdlcywgbGlrZSBbYmFiZWwtcG9seWZpbGxdKGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL2JhYmVsLXBvbHlmaWxsKSxcbiAgICAgKiB3aGljaCByZWx5IG9uIGNvcmUtanMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbmF0aXZlIGZ1bmN0aW9uLFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNOYXRpdmUoQXJyYXkucHJvdG90eXBlLnB1c2gpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNOYXRpdmUoXyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9mdW5jdGlvbiBpc05hdGl2ZSh2YWx1ZSl7aWYoaXNNYXNrYWJsZSh2YWx1ZSkpe3Rocm93IG5ldyBFcnJvcihDT1JFX0VSUk9SX1RFWFQpO31yZXR1cm4gYmFzZUlzTmF0aXZlKHZhbHVlKTt9LyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYG51bGxgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBgbnVsbGAsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc051bGwobnVsbCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc051bGwodm9pZCAwKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL2Z1bmN0aW9uIGlzTnVsbCh2YWx1ZSl7cmV0dXJuIHZhbHVlPT09bnVsbDt9LyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYG51bGxgIG9yIGB1bmRlZmluZWRgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBudWxsaXNoLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNOaWwobnVsbCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc05pbCh2b2lkIDApO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNOaWwoTmFOKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL2Z1bmN0aW9uIGlzTmlsKHZhbHVlKXtyZXR1cm4gdmFsdWU9PW51bGw7fS8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgTnVtYmVyYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRvIGV4Y2x1ZGUgYEluZmluaXR5YCwgYC1JbmZpbml0eWAsIGFuZCBgTmFOYCwgd2hpY2ggYXJlXG4gICAgICogY2xhc3NpZmllZCBhcyBudW1iZXJzLCB1c2UgdGhlIGBfLmlzRmluaXRlYCBtZXRob2QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbnVtYmVyLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNOdW1iZXIoMyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc051bWJlcihOdW1iZXIuTUlOX1ZBTFVFKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTnVtYmVyKEluZmluaXR5KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTnVtYmVyKCczJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9mdW5jdGlvbiBpc051bWJlcih2YWx1ZSl7cmV0dXJuIHR5cGVvZiB2YWx1ZT09J251bWJlcid8fGlzT2JqZWN0TGlrZSh2YWx1ZSkmJmJhc2VHZXRUYWcodmFsdWUpPT1udW1iZXJUYWc7fS8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgcGxhaW4gb2JqZWN0LCB0aGF0IGlzLCBhbiBvYmplY3QgY3JlYXRlZCBieSB0aGVcbiAgICAgKiBgT2JqZWN0YCBjb25zdHJ1Y3RvciBvciBvbmUgd2l0aCBhIGBbW1Byb3RvdHlwZV1dYCBvZiBgbnVsbGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC44LjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcGxhaW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogfVxuICAgICAqXG4gICAgICogXy5pc1BsYWluT2JqZWN0KG5ldyBGb28pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzUGxhaW5PYmplY3QoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc1BsYWluT2JqZWN0KHsgJ3gnOiAwLCAneSc6IDAgfSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc1BsYWluT2JqZWN0KE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9mdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbHVlKXtpZighaXNPYmplY3RMaWtlKHZhbHVlKXx8YmFzZUdldFRhZyh2YWx1ZSkhPW9iamVjdFRhZyl7cmV0dXJuIGZhbHNlO312YXIgcHJvdG89Z2V0UHJvdG90eXBlKHZhbHVlKTtpZihwcm90bz09PW51bGwpe3JldHVybiB0cnVlO312YXIgQ3Rvcj1oYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3RvLCdjb25zdHJ1Y3RvcicpJiZwcm90by5jb25zdHJ1Y3RvcjtyZXR1cm4gdHlwZW9mIEN0b3I9PSdmdW5jdGlvbicmJkN0b3IgaW5zdGFuY2VvZiBDdG9yJiZmdW5jVG9TdHJpbmcuY2FsbChDdG9yKT09b2JqZWN0Q3RvclN0cmluZzt9LyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBSZWdFeHBgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSByZWdleHAsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc1JlZ0V4cCgvYWJjLyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc1JlZ0V4cCgnL2FiYy8nKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL3ZhciBpc1JlZ0V4cD1ub2RlSXNSZWdFeHA/YmFzZVVuYXJ5KG5vZGVJc1JlZ0V4cCk6YmFzZUlzUmVnRXhwOy8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgc2FmZSBpbnRlZ2VyLiBBbiBpbnRlZ2VyIGlzIHNhZmUgaWYgaXQncyBhbiBJRUVFLTc1NFxuICAgICAqIGRvdWJsZSBwcmVjaXNpb24gbnVtYmVyIHdoaWNoIGlzbid0IHRoZSByZXN1bHQgb2YgYSByb3VuZGVkIHVuc2FmZSBpbnRlZ2VyLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGJhc2VkIG9uXG4gICAgICogW2BOdW1iZXIuaXNTYWZlSW50ZWdlcmBdKGh0dHBzOi8vbWRuLmlvL051bWJlci9pc1NhZmVJbnRlZ2VyKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzYWZlIGludGVnZXIsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc1NhZmVJbnRlZ2VyKDMpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNTYWZlSW50ZWdlcihOdW1iZXIuTUlOX1ZBTFVFKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc1NhZmVJbnRlZ2VyKEluZmluaXR5KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc1NhZmVJbnRlZ2VyKCczJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9mdW5jdGlvbiBpc1NhZmVJbnRlZ2VyKHZhbHVlKXtyZXR1cm4gaXNJbnRlZ2VyKHZhbHVlKSYmdmFsdWU+PS1NQVhfU0FGRV9JTlRFR0VSJiZ2YWx1ZTw9TUFYX1NBRkVfSU5URUdFUjt9LyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTZXRgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjMuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzZXQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc1NldChuZXcgU2V0KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzU2V0KG5ldyBXZWFrU2V0KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL3ZhciBpc1NldD1ub2RlSXNTZXQ/YmFzZVVuYXJ5KG5vZGVJc1NldCk6YmFzZUlzU2V0Oy8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU3RyaW5nYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHN0cmluZywgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzU3RyaW5nKCdhYmMnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzU3RyaW5nKDEpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovZnVuY3Rpb24gaXNTdHJpbmcodmFsdWUpe3JldHVybiB0eXBlb2YgdmFsdWU9PSdzdHJpbmcnfHwhaXNBcnJheSh2YWx1ZSkmJmlzT2JqZWN0TGlrZSh2YWx1ZSkmJmJhc2VHZXRUYWcodmFsdWUpPT1zdHJpbmdUYWc7fS8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU3ltYm9sYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHN5bWJvbCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzU3ltYm9sKFN5bWJvbC5pdGVyYXRvcik7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc1N5bWJvbCgnYWJjJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9mdW5jdGlvbiBpc1N5bWJvbCh2YWx1ZSl7cmV0dXJuIHR5cGVvZiB2YWx1ZT09J3N5bWJvbCd8fGlzT2JqZWN0TGlrZSh2YWx1ZSkmJmJhc2VHZXRUYWcodmFsdWUpPT1zeW1ib2xUYWc7fS8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSB0eXBlZCBhcnJheS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzVHlwZWRBcnJheShuZXcgVWludDhBcnJheSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc1R5cGVkQXJyYXkoW10pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovdmFyIGlzVHlwZWRBcnJheT1ub2RlSXNUeXBlZEFycmF5P2Jhc2VVbmFyeShub2RlSXNUeXBlZEFycmF5KTpiYXNlSXNUeXBlZEFycmF5Oy8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGB1bmRlZmluZWRgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBgdW5kZWZpbmVkYCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzVW5kZWZpbmVkKHZvaWQgMCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc1VuZGVmaW5lZChudWxsKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL2Z1bmN0aW9uIGlzVW5kZWZpbmVkKHZhbHVlKXtyZXR1cm4gdmFsdWU9PT11bmRlZmluZWQ7fS8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgV2Vha01hcGAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMy4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHdlYWsgbWFwLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNXZWFrTWFwKG5ldyBXZWFrTWFwKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzV2Vha01hcChuZXcgTWFwKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL2Z1bmN0aW9uIGlzV2Vha01hcCh2YWx1ZSl7cmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkmJmdldFRhZyh2YWx1ZSk9PXdlYWtNYXBUYWc7fS8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgV2Vha1NldGAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMy4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHdlYWsgc2V0LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNXZWFrU2V0KG5ldyBXZWFrU2V0KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzV2Vha1NldChuZXcgU2V0KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL2Z1bmN0aW9uIGlzV2Vha1NldCh2YWx1ZSl7cmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkmJmJhc2VHZXRUYWcodmFsdWUpPT13ZWFrU2V0VGFnO30vKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsZXNzIHRoYW4gYG90aGVyYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjkuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGxlc3MgdGhhbiBgb3RoZXJgLFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICogQHNlZSBfLmd0XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubHQoMSwgMyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5sdCgzLCAzKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5sdCgzLCAxKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL3ZhciBsdD1jcmVhdGVSZWxhdGlvbmFsT3BlcmF0aW9uKGJhc2VMdCk7LyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGBvdGhlcmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy45LjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG9cbiAgICAgKiAgYG90aGVyYCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBzZWUgXy5ndGVcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5sdGUoMSwgMyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5sdGUoMywgMyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5sdGUoMywgMSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi92YXIgbHRlPWNyZWF0ZVJlbGF0aW9uYWxPcGVyYXRpb24oZnVuY3Rpb24odmFsdWUsb3RoZXIpe3JldHVybiB2YWx1ZTw9b3RoZXI7fSk7LyoqXG4gICAgICogQ29udmVydHMgYHZhbHVlYCB0byBhbiBhcnJheS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50b0FycmF5KHsgJ2EnOiAxLCAnYic6IDIgfSk7XG4gICAgICogLy8gPT4gWzEsIDJdXG4gICAgICpcbiAgICAgKiBfLnRvQXJyYXkoJ2FiYycpO1xuICAgICAqIC8vID0+IFsnYScsICdiJywgJ2MnXVxuICAgICAqXG4gICAgICogXy50b0FycmF5KDEpO1xuICAgICAqIC8vID0+IFtdXG4gICAgICpcbiAgICAgKiBfLnRvQXJyYXkobnVsbCk7XG4gICAgICogLy8gPT4gW11cbiAgICAgKi9mdW5jdGlvbiB0b0FycmF5KHZhbHVlKXtpZighdmFsdWUpe3JldHVybltdO31pZihpc0FycmF5TGlrZSh2YWx1ZSkpe3JldHVybiBpc1N0cmluZyh2YWx1ZSk/c3RyaW5nVG9BcnJheSh2YWx1ZSk6Y29weUFycmF5KHZhbHVlKTt9aWYoc3ltSXRlcmF0b3ImJnZhbHVlW3N5bUl0ZXJhdG9yXSl7cmV0dXJuIGl0ZXJhdG9yVG9BcnJheSh2YWx1ZVtzeW1JdGVyYXRvcl0oKSk7fXZhciB0YWc9Z2V0VGFnKHZhbHVlKSxmdW5jPXRhZz09bWFwVGFnP21hcFRvQXJyYXk6dGFnPT1zZXRUYWc/c2V0VG9BcnJheTp2YWx1ZXM7cmV0dXJuIGZ1bmModmFsdWUpO30vKipcbiAgICAgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgZmluaXRlIG51bWJlci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjEyLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY29udmVydGVkIG51bWJlci5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50b0Zpbml0ZSgzLjIpO1xuICAgICAqIC8vID0+IDMuMlxuICAgICAqXG4gICAgICogXy50b0Zpbml0ZShOdW1iZXIuTUlOX1ZBTFVFKTtcbiAgICAgKiAvLyA9PiA1ZS0zMjRcbiAgICAgKlxuICAgICAqIF8udG9GaW5pdGUoSW5maW5pdHkpO1xuICAgICAqIC8vID0+IDEuNzk3NjkzMTM0ODYyMzE1N2UrMzA4XG4gICAgICpcbiAgICAgKiBfLnRvRmluaXRlKCczLjInKTtcbiAgICAgKiAvLyA9PiAzLjJcbiAgICAgKi9mdW5jdGlvbiB0b0Zpbml0ZSh2YWx1ZSl7aWYoIXZhbHVlKXtyZXR1cm4gdmFsdWU9PT0wP3ZhbHVlOjA7fXZhbHVlPXRvTnVtYmVyKHZhbHVlKTtpZih2YWx1ZT09PUlORklOSVRZfHx2YWx1ZT09PS1JTkZJTklUWSl7dmFyIHNpZ249dmFsdWU8MD8tMToxO3JldHVybiBzaWduKk1BWF9JTlRFR0VSO31yZXR1cm4gdmFsdWU9PT12YWx1ZT92YWx1ZTowO30vKipcbiAgICAgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGFuIGludGVnZXIuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvblxuICAgICAqIFtgVG9JbnRlZ2VyYF0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRvaW50ZWdlcikuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY29udmVydGVkIGludGVnZXIuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udG9JbnRlZ2VyKDMuMik7XG4gICAgICogLy8gPT4gM1xuICAgICAqXG4gICAgICogXy50b0ludGVnZXIoTnVtYmVyLk1JTl9WQUxVRSk7XG4gICAgICogLy8gPT4gMFxuICAgICAqXG4gICAgICogXy50b0ludGVnZXIoSW5maW5pdHkpO1xuICAgICAqIC8vID0+IDEuNzk3NjkzMTM0ODYyMzE1N2UrMzA4XG4gICAgICpcbiAgICAgKiBfLnRvSW50ZWdlcignMy4yJyk7XG4gICAgICogLy8gPT4gM1xuICAgICAqL2Z1bmN0aW9uIHRvSW50ZWdlcih2YWx1ZSl7dmFyIHJlc3VsdD10b0Zpbml0ZSh2YWx1ZSkscmVtYWluZGVyPXJlc3VsdCUxO3JldHVybiByZXN1bHQ9PT1yZXN1bHQ/cmVtYWluZGVyP3Jlc3VsdC1yZW1haW5kZXI6cmVzdWx0OjA7fS8qKlxuICAgICAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYW4gaW50ZWdlciBzdWl0YWJsZSBmb3IgdXNlIGFzIHRoZSBsZW5ndGggb2YgYW5cbiAgICAgKiBhcnJheS1saWtlIG9iamVjdC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBiYXNlZCBvblxuICAgICAqIFtgVG9MZW5ndGhgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy10b2xlbmd0aCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY29udmVydGVkIGludGVnZXIuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udG9MZW5ndGgoMy4yKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICpcbiAgICAgKiBfLnRvTGVuZ3RoKE51bWJlci5NSU5fVkFMVUUpO1xuICAgICAqIC8vID0+IDBcbiAgICAgKlxuICAgICAqIF8udG9MZW5ndGgoSW5maW5pdHkpO1xuICAgICAqIC8vID0+IDQyOTQ5NjcyOTVcbiAgICAgKlxuICAgICAqIF8udG9MZW5ndGgoJzMuMicpO1xuICAgICAqIC8vID0+IDNcbiAgICAgKi9mdW5jdGlvbiB0b0xlbmd0aCh2YWx1ZSl7cmV0dXJuIHZhbHVlP2Jhc2VDbGFtcCh0b0ludGVnZXIodmFsdWUpLDAsTUFYX0FSUkFZX0xFTkdUSCk6MDt9LyoqXG4gICAgICogQ29udmVydHMgYHZhbHVlYCB0byBhIG51bWJlci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBudW1iZXIuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udG9OdW1iZXIoMy4yKTtcbiAgICAgKiAvLyA9PiAzLjJcbiAgICAgKlxuICAgICAqIF8udG9OdW1iZXIoTnVtYmVyLk1JTl9WQUxVRSk7XG4gICAgICogLy8gPT4gNWUtMzI0XG4gICAgICpcbiAgICAgKiBfLnRvTnVtYmVyKEluZmluaXR5KTtcbiAgICAgKiAvLyA9PiBJbmZpbml0eVxuICAgICAqXG4gICAgICogXy50b051bWJlcignMy4yJyk7XG4gICAgICogLy8gPT4gMy4yXG4gICAgICovZnVuY3Rpb24gdG9OdW1iZXIodmFsdWUpe2lmKHR5cGVvZiB2YWx1ZT09J251bWJlcicpe3JldHVybiB2YWx1ZTt9aWYoaXNTeW1ib2wodmFsdWUpKXtyZXR1cm4gTkFOO31pZihpc09iamVjdCh2YWx1ZSkpe3ZhciBvdGhlcj10eXBlb2YgdmFsdWUudmFsdWVPZj09J2Z1bmN0aW9uJz92YWx1ZS52YWx1ZU9mKCk6dmFsdWU7dmFsdWU9aXNPYmplY3Qob3RoZXIpP290aGVyKycnOm90aGVyO31pZih0eXBlb2YgdmFsdWUhPSdzdHJpbmcnKXtyZXR1cm4gdmFsdWU9PT0wP3ZhbHVlOit2YWx1ZTt9dmFsdWU9dmFsdWUucmVwbGFjZShyZVRyaW0sJycpO3ZhciBpc0JpbmFyeT1yZUlzQmluYXJ5LnRlc3QodmFsdWUpO3JldHVybiBpc0JpbmFyeXx8cmVJc09jdGFsLnRlc3QodmFsdWUpP2ZyZWVQYXJzZUludCh2YWx1ZS5zbGljZSgyKSxpc0JpbmFyeT8yOjgpOnJlSXNCYWRIZXgudGVzdCh2YWx1ZSk/TkFOOit2YWx1ZTt9LyoqXG4gICAgICogQ29udmVydHMgYHZhbHVlYCB0byBhIHBsYWluIG9iamVjdCBmbGF0dGVuaW5nIGluaGVyaXRlZCBlbnVtZXJhYmxlIHN0cmluZ1xuICAgICAqIGtleWVkIHByb3BlcnRpZXMgb2YgYHZhbHVlYCB0byBvd24gcHJvcGVydGllcyBvZiB0aGUgcGxhaW4gb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBwbGFpbiBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYiA9IDI7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAgICAgKlxuICAgICAqIF8uYXNzaWduKHsgJ2EnOiAxIH0sIG5ldyBGb28pO1xuICAgICAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIgfVxuICAgICAqXG4gICAgICogXy5hc3NpZ24oeyAnYSc6IDEgfSwgXy50b1BsYWluT2JqZWN0KG5ldyBGb28pKTtcbiAgICAgKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDMgfVxuICAgICAqL2Z1bmN0aW9uIHRvUGxhaW5PYmplY3QodmFsdWUpe3JldHVybiBjb3B5T2JqZWN0KHZhbHVlLGtleXNJbih2YWx1ZSkpO30vKipcbiAgICAgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc2FmZSBpbnRlZ2VyLiBBIHNhZmUgaW50ZWdlciBjYW4gYmUgY29tcGFyZWQgYW5kXG4gICAgICogcmVwcmVzZW50ZWQgY29ycmVjdGx5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBpbnRlZ2VyLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRvU2FmZUludGVnZXIoMy4yKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICpcbiAgICAgKiBfLnRvU2FmZUludGVnZXIoTnVtYmVyLk1JTl9WQUxVRSk7XG4gICAgICogLy8gPT4gMFxuICAgICAqXG4gICAgICogXy50b1NhZmVJbnRlZ2VyKEluZmluaXR5KTtcbiAgICAgKiAvLyA9PiA5MDA3MTk5MjU0NzQwOTkxXG4gICAgICpcbiAgICAgKiBfLnRvU2FmZUludGVnZXIoJzMuMicpO1xuICAgICAqIC8vID0+IDNcbiAgICAgKi9mdW5jdGlvbiB0b1NhZmVJbnRlZ2VyKHZhbHVlKXtyZXR1cm4gdmFsdWU/YmFzZUNsYW1wKHRvSW50ZWdlcih2YWx1ZSksLU1BWF9TQUZFX0lOVEVHRVIsTUFYX1NBRkVfSU5URUdFUik6dmFsdWU9PT0wP3ZhbHVlOjA7fS8qKlxuICAgICAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcuIEFuIGVtcHR5IHN0cmluZyBpcyByZXR1cm5lZCBmb3IgYG51bGxgXG4gICAgICogYW5kIGB1bmRlZmluZWRgIHZhbHVlcy4gVGhlIHNpZ24gb2YgYC0wYCBpcyBwcmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50b1N0cmluZyhudWxsKTtcbiAgICAgKiAvLyA9PiAnJ1xuICAgICAqXG4gICAgICogXy50b1N0cmluZygtMCk7XG4gICAgICogLy8gPT4gJy0wJ1xuICAgICAqXG4gICAgICogXy50b1N0cmluZyhbMSwgMiwgM10pO1xuICAgICAqIC8vID0+ICcxLDIsMydcbiAgICAgKi9mdW5jdGlvbiB0b1N0cmluZyh2YWx1ZSl7cmV0dXJuIHZhbHVlPT1udWxsPycnOmJhc2VUb1N0cmluZyh2YWx1ZSk7fS8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi8vKipcbiAgICAgKiBBc3NpZ25zIG93biBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0aWVzIG9mIHNvdXJjZSBvYmplY3RzIHRvIHRoZVxuICAgICAqIGRlc3RpbmF0aW9uIG9iamVjdC4gU291cmNlIG9iamVjdHMgYXJlIGFwcGxpZWQgZnJvbSBsZWZ0IHRvIHJpZ2h0LlxuICAgICAqIFN1YnNlcXVlbnQgc291cmNlcyBvdmVyd3JpdGUgcHJvcGVydHkgYXNzaWdubWVudHMgb2YgcHJldmlvdXMgc291cmNlcy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgIGFuZCBpcyBsb29zZWx5IGJhc2VkIG9uXG4gICAgICogW2BPYmplY3QuYXNzaWduYF0oaHR0cHM6Ly9tZG4uaW8vT2JqZWN0L2Fzc2lnbikuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gey4uLk9iamVjdH0gW3NvdXJjZXNdIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBzZWUgXy5hc3NpZ25JblxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSAxO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEJhcigpIHtcbiAgICAgKiAgIHRoaXMuYyA9IDM7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5iID0gMjtcbiAgICAgKiBCYXIucHJvdG90eXBlLmQgPSA0O1xuICAgICAqXG4gICAgICogXy5hc3NpZ24oeyAnYSc6IDAgfSwgbmV3IEZvbywgbmV3IEJhcik7XG4gICAgICogLy8gPT4geyAnYSc6IDEsICdjJzogMyB9XG4gICAgICovdmFyIGFzc2lnbj1jcmVhdGVBc3NpZ25lcihmdW5jdGlvbihvYmplY3Qsc291cmNlKXtpZihpc1Byb3RvdHlwZShzb3VyY2UpfHxpc0FycmF5TGlrZShzb3VyY2UpKXtjb3B5T2JqZWN0KHNvdXJjZSxrZXlzKHNvdXJjZSksb2JqZWN0KTtyZXR1cm47fWZvcih2YXIga2V5IGluIHNvdXJjZSl7aWYoaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2Usa2V5KSl7YXNzaWduVmFsdWUob2JqZWN0LGtleSxzb3VyY2Vba2V5XSk7fX19KTsvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmFzc2lnbmAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBvd24gYW5kXG4gICAgICogaW5oZXJpdGVkIHNvdXJjZSBwcm9wZXJ0aWVzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAYWxpYXMgZXh0ZW5kXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gey4uLk9iamVjdH0gW3NvdXJjZXNdIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBzZWUgXy5hc3NpZ25cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gMTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBCYXIoKSB7XG4gICAgICogICB0aGlzLmMgPSAzO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYiA9IDI7XG4gICAgICogQmFyLnByb3RvdHlwZS5kID0gNDtcbiAgICAgKlxuICAgICAqIF8uYXNzaWduSW4oeyAnYSc6IDAgfSwgbmV3IEZvbywgbmV3IEJhcik7XG4gICAgICogLy8gPT4geyAnYSc6IDEsICdiJzogMiwgJ2MnOiAzLCAnZCc6IDQgfVxuICAgICAqL3ZhciBhc3NpZ25Jbj1jcmVhdGVBc3NpZ25lcihmdW5jdGlvbihvYmplY3Qsc291cmNlKXtjb3B5T2JqZWN0KHNvdXJjZSxrZXlzSW4oc291cmNlKSxvYmplY3QpO30pOy8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uYXNzaWduSW5gIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGN1c3RvbWl6ZXJgXG4gICAgICogd2hpY2ggaXMgaW52b2tlZCB0byBwcm9kdWNlIHRoZSBhc3NpZ25lZCB2YWx1ZXMuIElmIGBjdXN0b21pemVyYCByZXR1cm5zXG4gICAgICogYHVuZGVmaW5lZGAsIGFzc2lnbm1lbnQgaXMgaGFuZGxlZCBieSB0aGUgbWV0aG9kIGluc3RlYWQuIFRoZSBgY3VzdG9taXplcmBcbiAgICAgKiBpcyBpbnZva2VkIHdpdGggZml2ZSBhcmd1bWVudHM6IChvYmpWYWx1ZSwgc3JjVmFsdWUsIGtleSwgb2JqZWN0LCBzb3VyY2UpLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAYWxpYXMgZXh0ZW5kV2l0aFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHsuLi5PYmplY3R9IHNvdXJjZXMgVGhlIHNvdXJjZSBvYmplY3RzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGFzc2lnbmVkIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBzZWUgXy5hc3NpZ25XaXRoXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGN1c3RvbWl6ZXIob2JqVmFsdWUsIHNyY1ZhbHVlKSB7XG4gICAgICogICByZXR1cm4gXy5pc1VuZGVmaW5lZChvYmpWYWx1ZSkgPyBzcmNWYWx1ZSA6IG9ialZhbHVlO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciBkZWZhdWx0cyA9IF8ucGFydGlhbFJpZ2h0KF8uYXNzaWduSW5XaXRoLCBjdXN0b21pemVyKTtcbiAgICAgKlxuICAgICAqIGRlZmF1bHRzKHsgJ2EnOiAxIH0sIHsgJ2InOiAyIH0sIHsgJ2EnOiAzIH0pO1xuICAgICAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIgfVxuICAgICAqL3ZhciBhc3NpZ25JbldpdGg9Y3JlYXRlQXNzaWduZXIoZnVuY3Rpb24ob2JqZWN0LHNvdXJjZSxzcmNJbmRleCxjdXN0b21pemVyKXtjb3B5T2JqZWN0KHNvdXJjZSxrZXlzSW4oc291cmNlKSxvYmplY3QsY3VzdG9taXplcik7fSk7LyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5hc3NpZ25gIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGN1c3RvbWl6ZXJgXG4gICAgICogd2hpY2ggaXMgaW52b2tlZCB0byBwcm9kdWNlIHRoZSBhc3NpZ25lZCB2YWx1ZXMuIElmIGBjdXN0b21pemVyYCByZXR1cm5zXG4gICAgICogYHVuZGVmaW5lZGAsIGFzc2lnbm1lbnQgaXMgaGFuZGxlZCBieSB0aGUgbWV0aG9kIGluc3RlYWQuIFRoZSBgY3VzdG9taXplcmBcbiAgICAgKiBpcyBpbnZva2VkIHdpdGggZml2ZSBhcmd1bWVudHM6IChvYmpWYWx1ZSwgc3JjVmFsdWUsIGtleSwgb2JqZWN0LCBzb3VyY2UpLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uT2JqZWN0fSBzb3VyY2VzIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBhc3NpZ25lZCB2YWx1ZXMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAc2VlIF8uYXNzaWduSW5XaXRoXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGN1c3RvbWl6ZXIob2JqVmFsdWUsIHNyY1ZhbHVlKSB7XG4gICAgICogICByZXR1cm4gXy5pc1VuZGVmaW5lZChvYmpWYWx1ZSkgPyBzcmNWYWx1ZSA6IG9ialZhbHVlO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciBkZWZhdWx0cyA9IF8ucGFydGlhbFJpZ2h0KF8uYXNzaWduV2l0aCwgY3VzdG9taXplcik7XG4gICAgICpcbiAgICAgKiBkZWZhdWx0cyh7ICdhJzogMSB9LCB7ICdiJzogMiB9LCB7ICdhJzogMyB9KTtcbiAgICAgKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyIH1cbiAgICAgKi92YXIgYXNzaWduV2l0aD1jcmVhdGVBc3NpZ25lcihmdW5jdGlvbihvYmplY3Qsc291cmNlLHNyY0luZGV4LGN1c3RvbWl6ZXIpe2NvcHlPYmplY3Qoc291cmNlLGtleXMoc291cmNlKSxvYmplY3QsY3VzdG9taXplcik7fSk7LyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB2YWx1ZXMgY29ycmVzcG9uZGluZyB0byBgcGF0aHNgIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDEuMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHsuLi4oc3RyaW5nfHN0cmluZ1tdKX0gW3BhdGhzXSBUaGUgcHJvcGVydHkgcGF0aHMgdG8gcGljay5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHBpY2tlZCB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogW3sgJ2InOiB7ICdjJzogMyB9IH0sIDRdIH07XG4gICAgICpcbiAgICAgKiBfLmF0KG9iamVjdCwgWydhWzBdLmIuYycsICdhWzFdJ10pO1xuICAgICAqIC8vID0+IFszLCA0XVxuICAgICAqL3ZhciBhdD1mbGF0UmVzdChiYXNlQXQpOy8qKlxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IHRoYXQgaW5oZXJpdHMgZnJvbSB0aGUgYHByb3RvdHlwZWAgb2JqZWN0LiBJZiBhXG4gICAgICogYHByb3BlcnRpZXNgIG9iamVjdCBpcyBnaXZlbiwgaXRzIG93biBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0aWVzXG4gICAgICogYXJlIGFzc2lnbmVkIHRvIHRoZSBjcmVhdGVkIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjMuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvdG90eXBlIFRoZSBvYmplY3QgdG8gaW5oZXJpdCBmcm9tLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbcHJvcGVydGllc10gVGhlIHByb3BlcnRpZXMgdG8gYXNzaWduIHRvIHRoZSBvYmplY3QuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gU2hhcGUoKSB7XG4gICAgICogICB0aGlzLnggPSAwO1xuICAgICAqICAgdGhpcy55ID0gMDtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBDaXJjbGUoKSB7XG4gICAgICogICBTaGFwZS5jYWxsKHRoaXMpO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIENpcmNsZS5wcm90b3R5cGUgPSBfLmNyZWF0ZShTaGFwZS5wcm90b3R5cGUsIHtcbiAgICAgKiAgICdjb25zdHJ1Y3Rvcic6IENpcmNsZVxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogdmFyIGNpcmNsZSA9IG5ldyBDaXJjbGU7XG4gICAgICogY2lyY2xlIGluc3RhbmNlb2YgQ2lyY2xlO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIGNpcmNsZSBpbnN0YW5jZW9mIFNoYXBlO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9mdW5jdGlvbiBjcmVhdGUocHJvdG90eXBlLHByb3BlcnRpZXMpe3ZhciByZXN1bHQ9YmFzZUNyZWF0ZShwcm90b3R5cGUpO3JldHVybiBwcm9wZXJ0aWVzPT1udWxsP3Jlc3VsdDpiYXNlQXNzaWduKHJlc3VsdCxwcm9wZXJ0aWVzKTt9LyoqXG4gICAgICogQXNzaWducyBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0aWVzIG9mIHNvdXJjZVxuICAgICAqIG9iamVjdHMgdG8gdGhlIGRlc3RpbmF0aW9uIG9iamVjdCBmb3IgYWxsIGRlc3RpbmF0aW9uIHByb3BlcnRpZXMgdGhhdFxuICAgICAqIHJlc29sdmUgdG8gYHVuZGVmaW5lZGAuIFNvdXJjZSBvYmplY3RzIGFyZSBhcHBsaWVkIGZyb20gbGVmdCB0byByaWdodC5cbiAgICAgKiBPbmNlIGEgcHJvcGVydHkgaXMgc2V0LCBhZGRpdGlvbmFsIHZhbHVlcyBvZiB0aGUgc2FtZSBwcm9wZXJ0eSBhcmUgaWdub3JlZC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gey4uLk9iamVjdH0gW3NvdXJjZXNdIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBzZWUgXy5kZWZhdWx0c0RlZXBcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kZWZhdWx0cyh7ICdhJzogMSB9LCB7ICdiJzogMiB9LCB7ICdhJzogMyB9KTtcbiAgICAgKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyIH1cbiAgICAgKi92YXIgZGVmYXVsdHM9YmFzZVJlc3QoZnVuY3Rpb24oYXJncyl7YXJncy5wdXNoKHVuZGVmaW5lZCxjdXN0b21EZWZhdWx0c0Fzc2lnbkluKTtyZXR1cm4gYXBwbHkoYXNzaWduSW5XaXRoLHVuZGVmaW5lZCxhcmdzKTt9KTsvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmRlZmF1bHRzYCBleGNlcHQgdGhhdCBpdCByZWN1cnNpdmVseSBhc3NpZ25zXG4gICAgICogZGVmYXVsdCBwcm9wZXJ0aWVzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4xMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gey4uLk9iamVjdH0gW3NvdXJjZXNdIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBzZWUgXy5kZWZhdWx0c1xuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRlZmF1bHRzRGVlcCh7ICdhJzogeyAnYic6IDIgfSB9LCB7ICdhJzogeyAnYic6IDEsICdjJzogMyB9IH0pO1xuICAgICAqIC8vID0+IHsgJ2EnOiB7ICdiJzogMiwgJ2MnOiAzIH0gfVxuICAgICAqL3ZhciBkZWZhdWx0c0RlZXA9YmFzZVJlc3QoZnVuY3Rpb24oYXJncyl7YXJncy5wdXNoKHVuZGVmaW5lZCxjdXN0b21EZWZhdWx0c01lcmdlKTtyZXR1cm4gYXBwbHkobWVyZ2VXaXRoLHVuZGVmaW5lZCxhcmdzKTt9KTsvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZpbmRgIGV4Y2VwdCB0aGF0IGl0IHJldHVybnMgdGhlIGtleSBvZiB0aGUgZmlyc3RcbiAgICAgKiBlbGVtZW50IGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvciBpbnN0ZWFkIG9mIHRoZSBlbGVtZW50IGl0c2VsZi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAxLjEuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge3N0cmluZ3x1bmRlZmluZWR9IFJldHVybnMgdGhlIGtleSBvZiB0aGUgbWF0Y2hlZCBlbGVtZW50LFxuICAgICAqICBlbHNlIGB1bmRlZmluZWRgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSB7XG4gICAgICogICAnYmFybmV5JzogIHsgJ2FnZSc6IDM2LCAnYWN0aXZlJzogdHJ1ZSB9LFxuICAgICAqICAgJ2ZyZWQnOiAgICB7ICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICAncGViYmxlcyc6IHsgJ2FnZSc6IDEsICAnYWN0aXZlJzogdHJ1ZSB9XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIF8uZmluZEtleSh1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gby5hZ2UgPCA0MDsgfSk7XG4gICAgICogLy8gPT4gJ2Jhcm5leScgKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maW5kS2V5KHVzZXJzLCB7ICdhZ2UnOiAxLCAnYWN0aXZlJzogdHJ1ZSB9KTtcbiAgICAgKiAvLyA9PiAncGViYmxlcydcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbmRLZXkodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiAnZnJlZCdcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmluZEtleSh1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+ICdiYXJuZXknXG4gICAgICovZnVuY3Rpb24gZmluZEtleShvYmplY3QscHJlZGljYXRlKXtyZXR1cm4gYmFzZUZpbmRLZXkob2JqZWN0LGdldEl0ZXJhdGVlKHByZWRpY2F0ZSwzKSxiYXNlRm9yT3duKTt9LyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5maW5kS2V5YCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mXG4gICAgICogYSBjb2xsZWN0aW9uIGluIHRoZSBvcHBvc2l0ZSBvcmRlci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge3N0cmluZ3x1bmRlZmluZWR9IFJldHVybnMgdGhlIGtleSBvZiB0aGUgbWF0Y2hlZCBlbGVtZW50LFxuICAgICAqICBlbHNlIGB1bmRlZmluZWRgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSB7XG4gICAgICogICAnYmFybmV5JzogIHsgJ2FnZSc6IDM2LCAnYWN0aXZlJzogdHJ1ZSB9LFxuICAgICAqICAgJ2ZyZWQnOiAgICB7ICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICAncGViYmxlcyc6IHsgJ2FnZSc6IDEsICAnYWN0aXZlJzogdHJ1ZSB9XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIF8uZmluZExhc3RLZXkodXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8uYWdlIDwgNDA7IH0pO1xuICAgICAqIC8vID0+IHJldHVybnMgJ3BlYmJsZXMnIGFzc3VtaW5nIGBfLmZpbmRLZXlgIHJldHVybnMgJ2Jhcm5leSdcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maW5kTGFzdEtleSh1c2VycywgeyAnYWdlJzogMzYsICdhY3RpdmUnOiB0cnVlIH0pO1xuICAgICAqIC8vID0+ICdiYXJuZXknXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maW5kTGFzdEtleSh1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICAgICAqIC8vID0+ICdmcmVkJ1xuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maW5kTGFzdEtleSh1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+ICdwZWJibGVzJ1xuICAgICAqL2Z1bmN0aW9uIGZpbmRMYXN0S2V5KG9iamVjdCxwcmVkaWNhdGUpe3JldHVybiBiYXNlRmluZEtleShvYmplY3QsZ2V0SXRlcmF0ZWUocHJlZGljYXRlLDMpLGJhc2VGb3JPd25SaWdodCk7fS8qKlxuICAgICAqIEl0ZXJhdGVzIG92ZXIgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydGllcyBvZiBhblxuICAgICAqIG9iamVjdCBhbmQgaW52b2tlcyBgaXRlcmF0ZWVgIGZvciBlYWNoIHByb3BlcnR5LiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZFxuICAgICAqIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGtleSwgb2JqZWN0KS4gSXRlcmF0ZWUgZnVuY3Rpb25zIG1heSBleGl0XG4gICAgICogaXRlcmF0aW9uIGVhcmx5IGJ5IGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4zLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBzZWUgXy5mb3JJblJpZ2h0XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogICB0aGlzLmIgPSAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gICAgICpcbiAgICAgKiBfLmZvckluKG5ldyBGb28sIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKGtleSk7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gTG9ncyAnYScsICdiJywgdGhlbiAnYycgKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZCkuXG4gICAgICovZnVuY3Rpb24gZm9ySW4ob2JqZWN0LGl0ZXJhdGVlKXtyZXR1cm4gb2JqZWN0PT1udWxsP29iamVjdDpiYXNlRm9yKG9iamVjdCxnZXRJdGVyYXRlZShpdGVyYXRlZSwzKSxrZXlzSW4pO30vKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZvckluYCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIHByb3BlcnRpZXMgb2ZcbiAgICAgKiBgb2JqZWN0YCBpbiB0aGUgb3Bwb3NpdGUgb3JkZXIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBzZWUgXy5mb3JJblxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSAxO1xuICAgICAqICAgdGhpcy5iID0gMjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICAgICAqXG4gICAgICogXy5mb3JJblJpZ2h0KG5ldyBGb28sIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKGtleSk7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gTG9ncyAnYycsICdiJywgdGhlbiAnYScgYXNzdW1pbmcgYF8uZm9ySW5gIGxvZ3MgJ2EnLCAnYicsIHRoZW4gJ2MnLlxuICAgICAqL2Z1bmN0aW9uIGZvckluUmlnaHQob2JqZWN0LGl0ZXJhdGVlKXtyZXR1cm4gb2JqZWN0PT1udWxsP29iamVjdDpiYXNlRm9yUmlnaHQob2JqZWN0LGdldEl0ZXJhdGVlKGl0ZXJhdGVlLDMpLGtleXNJbik7fS8qKlxuICAgICAqIEl0ZXJhdGVzIG92ZXIgb3duIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnRpZXMgb2YgYW4gb2JqZWN0IGFuZFxuICAgICAqIGludm9rZXMgYGl0ZXJhdGVlYCBmb3IgZWFjaCBwcm9wZXJ0eS4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCB0aHJlZVxuICAgICAqIGFyZ3VtZW50czogKHZhbHVlLCBrZXksIG9iamVjdCkuIEl0ZXJhdGVlIGZ1bmN0aW9ucyBtYXkgZXhpdCBpdGVyYXRpb25cbiAgICAgKiBlYXJseSBieSBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMy4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAc2VlIF8uZm9yT3duUmlnaHRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gMTtcbiAgICAgKiAgIHRoaXMuYiA9IDI7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAgICAgKlxuICAgICAqIF8uZm9yT3duKG5ldyBGb28sIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKGtleSk7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gTG9ncyAnYScgdGhlbiAnYicgKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZCkuXG4gICAgICovZnVuY3Rpb24gZm9yT3duKG9iamVjdCxpdGVyYXRlZSl7cmV0dXJuIG9iamVjdCYmYmFzZUZvck93bihvYmplY3QsZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsMykpO30vKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZvck93bmAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBwcm9wZXJ0aWVzIG9mXG4gICAgICogYG9iamVjdGAgaW4gdGhlIG9wcG9zaXRlIG9yZGVyLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAc2VlIF8uZm9yT3duXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogICB0aGlzLmIgPSAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gICAgICpcbiAgICAgKiBfLmZvck93blJpZ2h0KG5ldyBGb28sIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKGtleSk7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gTG9ncyAnYicgdGhlbiAnYScgYXNzdW1pbmcgYF8uZm9yT3duYCBsb2dzICdhJyB0aGVuICdiJy5cbiAgICAgKi9mdW5jdGlvbiBmb3JPd25SaWdodChvYmplY3QsaXRlcmF0ZWUpe3JldHVybiBvYmplY3QmJmJhc2VGb3JPd25SaWdodChvYmplY3QsZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsMykpO30vKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIGZ1bmN0aW9uIHByb3BlcnR5IG5hbWVzIGZyb20gb3duIGVudW1lcmFibGUgcHJvcGVydGllc1xuICAgICAqIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgZnVuY3Rpb24gbmFtZXMuXG4gICAgICogQHNlZSBfLmZ1bmN0aW9uc0luXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IF8uY29uc3RhbnQoJ2EnKTtcbiAgICAgKiAgIHRoaXMuYiA9IF8uY29uc3RhbnQoJ2InKTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSBfLmNvbnN0YW50KCdjJyk7XG4gICAgICpcbiAgICAgKiBfLmZ1bmN0aW9ucyhuZXcgRm9vKTtcbiAgICAgKiAvLyA9PiBbJ2EnLCAnYiddXG4gICAgICovZnVuY3Rpb24gZnVuY3Rpb25zKG9iamVjdCl7cmV0dXJuIG9iamVjdD09bnVsbD9bXTpiYXNlRnVuY3Rpb25zKG9iamVjdCxrZXlzKG9iamVjdCkpO30vKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIGZ1bmN0aW9uIHByb3BlcnR5IG5hbWVzIGZyb20gb3duIGFuZCBpbmhlcml0ZWRcbiAgICAgKiBlbnVtZXJhYmxlIHByb3BlcnRpZXMgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBuYW1lcy5cbiAgICAgKiBAc2VlIF8uZnVuY3Rpb25zXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IF8uY29uc3RhbnQoJ2EnKTtcbiAgICAgKiAgIHRoaXMuYiA9IF8uY29uc3RhbnQoJ2InKTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSBfLmNvbnN0YW50KCdjJyk7XG4gICAgICpcbiAgICAgKiBfLmZ1bmN0aW9uc0luKG5ldyBGb28pO1xuICAgICAqIC8vID0+IFsnYScsICdiJywgJ2MnXVxuICAgICAqL2Z1bmN0aW9uIGZ1bmN0aW9uc0luKG9iamVjdCl7cmV0dXJuIG9iamVjdD09bnVsbD9bXTpiYXNlRnVuY3Rpb25zKG9iamVjdCxrZXlzSW4ob2JqZWN0KSk7fS8qKlxuICAgICAqIEdldHMgdGhlIHZhbHVlIGF0IGBwYXRoYCBvZiBgb2JqZWN0YC4gSWYgdGhlIHJlc29sdmVkIHZhbHVlIGlzXG4gICAgICogYHVuZGVmaW5lZGAsIHRoZSBgZGVmYXVsdFZhbHVlYCBpcyByZXR1cm5lZCBpbiBpdHMgcGxhY2UuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy43LjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gICAgICogQHBhcmFtIHsqfSBbZGVmYXVsdFZhbHVlXSBUaGUgdmFsdWUgcmV0dXJuZWQgZm9yIGB1bmRlZmluZWRgIHJlc29sdmVkIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogW3sgJ2InOiB7ICdjJzogMyB9IH1dIH07XG4gICAgICpcbiAgICAgKiBfLmdldChvYmplY3QsICdhWzBdLmIuYycpO1xuICAgICAqIC8vID0+IDNcbiAgICAgKlxuICAgICAqIF8uZ2V0KG9iamVjdCwgWydhJywgJzAnLCAnYicsICdjJ10pO1xuICAgICAqIC8vID0+IDNcbiAgICAgKlxuICAgICAqIF8uZ2V0KG9iamVjdCwgJ2EuYi5jJywgJ2RlZmF1bHQnKTtcbiAgICAgKiAvLyA9PiAnZGVmYXVsdCdcbiAgICAgKi9mdW5jdGlvbiBnZXQob2JqZWN0LHBhdGgsZGVmYXVsdFZhbHVlKXt2YXIgcmVzdWx0PW9iamVjdD09bnVsbD91bmRlZmluZWQ6YmFzZUdldChvYmplY3QscGF0aCk7cmV0dXJuIHJlc3VsdD09PXVuZGVmaW5lZD9kZWZhdWx0VmFsdWU6cmVzdWx0O30vKipcbiAgICAgKiBDaGVja3MgaWYgYHBhdGhgIGlzIGEgZGlyZWN0IHByb3BlcnR5IG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHBhdGhgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IHsgJ2InOiAyIH0gfTtcbiAgICAgKiB2YXIgb3RoZXIgPSBfLmNyZWF0ZSh7ICdhJzogXy5jcmVhdGUoeyAnYic6IDIgfSkgfSk7XG4gICAgICpcbiAgICAgKiBfLmhhcyhvYmplY3QsICdhJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5oYXMob2JqZWN0LCAnYS5iJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5oYXMob2JqZWN0LCBbJ2EnLCAnYiddKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmhhcyhvdGhlciwgJ2EnKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL2Z1bmN0aW9uIGhhcyhvYmplY3QscGF0aCl7cmV0dXJuIG9iamVjdCE9bnVsbCYmaGFzUGF0aChvYmplY3QscGF0aCxiYXNlSGFzKTt9LyoqXG4gICAgICogQ2hlY2tzIGlmIGBwYXRoYCBpcyBhIGRpcmVjdCBvciBpbmhlcml0ZWQgcHJvcGVydHkgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgcGF0aGAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSBfLmNyZWF0ZSh7ICdhJzogXy5jcmVhdGUoeyAnYic6IDIgfSkgfSk7XG4gICAgICpcbiAgICAgKiBfLmhhc0luKG9iamVjdCwgJ2EnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmhhc0luKG9iamVjdCwgJ2EuYicpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaGFzSW4ob2JqZWN0LCBbJ2EnLCAnYiddKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmhhc0luKG9iamVjdCwgJ2InKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL2Z1bmN0aW9uIGhhc0luKG9iamVjdCxwYXRoKXtyZXR1cm4gb2JqZWN0IT1udWxsJiZoYXNQYXRoKG9iamVjdCxwYXRoLGJhc2VIYXNJbik7fS8qKlxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIHRoZSBpbnZlcnRlZCBrZXlzIGFuZCB2YWx1ZXMgb2YgYG9iamVjdGAuXG4gICAgICogSWYgYG9iamVjdGAgY29udGFpbnMgZHVwbGljYXRlIHZhbHVlcywgc3Vic2VxdWVudCB2YWx1ZXMgb3ZlcndyaXRlXG4gICAgICogcHJvcGVydHkgYXNzaWdubWVudHMgb2YgcHJldmlvdXMgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuNy4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnZlcnQuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IGludmVydGVkIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6IDIsICdjJzogMSB9O1xuICAgICAqXG4gICAgICogXy5pbnZlcnQob2JqZWN0KTtcbiAgICAgKiAvLyA9PiB7ICcxJzogJ2MnLCAnMic6ICdiJyB9XG4gICAgICovdmFyIGludmVydD1jcmVhdGVJbnZlcnRlcihmdW5jdGlvbihyZXN1bHQsdmFsdWUsa2V5KXtyZXN1bHRbdmFsdWVdPWtleTt9LGNvbnN0YW50KGlkZW50aXR5KSk7LyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5pbnZlcnRgIGV4Y2VwdCB0aGF0IHRoZSBpbnZlcnRlZCBvYmplY3QgaXMgZ2VuZXJhdGVkXG4gICAgICogZnJvbSB0aGUgcmVzdWx0cyBvZiBydW5uaW5nIGVhY2ggZWxlbWVudCBvZiBgb2JqZWN0YCB0aHJ1IGBpdGVyYXRlZWAuIFRoZVxuICAgICAqIGNvcnJlc3BvbmRpbmcgaW52ZXJ0ZWQgdmFsdWUgb2YgZWFjaCBpbnZlcnRlZCBrZXkgaXMgYW4gYXJyYXkgb2Yga2V5c1xuICAgICAqIHJlc3BvbnNpYmxlIGZvciBnZW5lcmF0aW5nIHRoZSBpbnZlcnRlZCB2YWx1ZS4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWRcbiAgICAgKiB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjEuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW52ZXJ0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgaW52ZXJ0ZWQgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogMiwgJ2MnOiAxIH07XG4gICAgICpcbiAgICAgKiBfLmludmVydEJ5KG9iamVjdCk7XG4gICAgICogLy8gPT4geyAnMSc6IFsnYScsICdjJ10sICcyJzogWydiJ10gfVxuICAgICAqXG4gICAgICogXy5pbnZlcnRCeShvYmplY3QsIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICogICByZXR1cm4gJ2dyb3VwJyArIHZhbHVlO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IHsgJ2dyb3VwMSc6IFsnYScsICdjJ10sICdncm91cDInOiBbJ2InXSB9XG4gICAgICovdmFyIGludmVydEJ5PWNyZWF0ZUludmVydGVyKGZ1bmN0aW9uKHJlc3VsdCx2YWx1ZSxrZXkpe2lmKGhhc093blByb3BlcnR5LmNhbGwocmVzdWx0LHZhbHVlKSl7cmVzdWx0W3ZhbHVlXS5wdXNoKGtleSk7fWVsc2V7cmVzdWx0W3ZhbHVlXT1ba2V5XTt9fSxnZXRJdGVyYXRlZSk7LyoqXG4gICAgICogSW52b2tlcyB0aGUgbWV0aG9kIGF0IGBwYXRoYCBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIG1ldGhvZCB0byBpbnZva2UuXG4gICAgICogQHBhcmFtIHsuLi4qfSBbYXJnc10gVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgdGhlIG1ldGhvZCB3aXRoLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXN1bHQgb2YgdGhlIGludm9rZWQgbWV0aG9kLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IFt7ICdiJzogeyAnYyc6IFsxLCAyLCAzLCA0XSB9IH1dIH07XG4gICAgICpcbiAgICAgKiBfLmludm9rZShvYmplY3QsICdhWzBdLmIuYy5zbGljZScsIDEsIDMpO1xuICAgICAqIC8vID0+IFsyLCAzXVxuICAgICAqL3ZhciBpbnZva2U9YmFzZVJlc3QoYmFzZUludm9rZSk7LyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy4gU2VlIHRoZVxuICAgICAqIFtFUyBzcGVjXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3Qua2V5cylcbiAgICAgKiBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSAxO1xuICAgICAqICAgdGhpcy5iID0gMjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICAgICAqXG4gICAgICogXy5rZXlzKG5ldyBGb28pO1xuICAgICAqIC8vID0+IFsnYScsICdiJ10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKlxuICAgICAqIF8ua2V5cygnaGknKTtcbiAgICAgKiAvLyA9PiBbJzAnLCAnMSddXG4gICAgICovZnVuY3Rpb24ga2V5cyhvYmplY3Qpe3JldHVybiBpc0FycmF5TGlrZShvYmplY3QpP2FycmF5TGlrZUtleXMob2JqZWN0KTpiYXNlS2V5cyhvYmplY3QpO30vKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogICB0aGlzLmIgPSAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gICAgICpcbiAgICAgKiBfLmtleXNJbihuZXcgRm9vKTtcbiAgICAgKiAvLyA9PiBbJ2EnLCAnYicsICdjJ10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKi9mdW5jdGlvbiBrZXlzSW4ob2JqZWN0KXtyZXR1cm4gaXNBcnJheUxpa2Uob2JqZWN0KT9hcnJheUxpa2VLZXlzKG9iamVjdCx0cnVlKTpiYXNlS2V5c0luKG9iamVjdCk7fS8qKlxuICAgICAqIFRoZSBvcHBvc2l0ZSBvZiBgXy5tYXBWYWx1ZXNgOyB0aGlzIG1ldGhvZCBjcmVhdGVzIGFuIG9iamVjdCB3aXRoIHRoZVxuICAgICAqIHNhbWUgdmFsdWVzIGFzIGBvYmplY3RgIGFuZCBrZXlzIGdlbmVyYXRlZCBieSBydW5uaW5nIGVhY2ggb3duIGVudW1lcmFibGVcbiAgICAgKiBzdHJpbmcga2V5ZWQgcHJvcGVydHkgb2YgYG9iamVjdGAgdGhydSBgaXRlcmF0ZWVgLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZFxuICAgICAqIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGtleSwgb2JqZWN0KS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjguMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgb2JqZWN0LlxuICAgICAqIEBzZWUgXy5tYXBWYWx1ZXNcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5tYXBLZXlzKHsgJ2EnOiAxLCAnYic6IDIgfSwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAqICAgcmV0dXJuIGtleSArIHZhbHVlO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IHsgJ2ExJzogMSwgJ2IyJzogMiB9XG4gICAgICovZnVuY3Rpb24gbWFwS2V5cyhvYmplY3QsaXRlcmF0ZWUpe3ZhciByZXN1bHQ9e307aXRlcmF0ZWU9Z2V0SXRlcmF0ZWUoaXRlcmF0ZWUsMyk7YmFzZUZvck93bihvYmplY3QsZnVuY3Rpb24odmFsdWUsa2V5LG9iamVjdCl7YmFzZUFzc2lnblZhbHVlKHJlc3VsdCxpdGVyYXRlZSh2YWx1ZSxrZXksb2JqZWN0KSx2YWx1ZSk7fSk7cmV0dXJuIHJlc3VsdDt9LyoqXG4gICAgICogQ3JlYXRlcyBhbiBvYmplY3Qgd2l0aCB0aGUgc2FtZSBrZXlzIGFzIGBvYmplY3RgIGFuZCB2YWx1ZXMgZ2VuZXJhdGVkXG4gICAgICogYnkgcnVubmluZyBlYWNoIG93biBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0eSBvZiBgb2JqZWN0YCB0aHJ1XG4gICAgICogYGl0ZXJhdGVlYC4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6XG4gICAgICogKHZhbHVlLCBrZXksIG9iamVjdCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi40LjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIG9iamVjdC5cbiAgICAgKiBAc2VlIF8ubWFwS2V5c1xuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSB7XG4gICAgICogICAnZnJlZCc6ICAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhZ2UnOiA0MCB9LFxuICAgICAqICAgJ3BlYmJsZXMnOiB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWdlJzogMSB9XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIF8ubWFwVmFsdWVzKHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLmFnZTsgfSk7XG4gICAgICogLy8gPT4geyAnZnJlZCc6IDQwLCAncGViYmxlcyc6IDEgfSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5tYXBWYWx1ZXModXNlcnMsICdhZ2UnKTtcbiAgICAgKiAvLyA9PiB7ICdmcmVkJzogNDAsICdwZWJibGVzJzogMSB9IChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAgICovZnVuY3Rpb24gbWFwVmFsdWVzKG9iamVjdCxpdGVyYXRlZSl7dmFyIHJlc3VsdD17fTtpdGVyYXRlZT1nZXRJdGVyYXRlZShpdGVyYXRlZSwzKTtiYXNlRm9yT3duKG9iamVjdCxmdW5jdGlvbih2YWx1ZSxrZXksb2JqZWN0KXtiYXNlQXNzaWduVmFsdWUocmVzdWx0LGtleSxpdGVyYXRlZSh2YWx1ZSxrZXksb2JqZWN0KSk7fSk7cmV0dXJuIHJlc3VsdDt9LyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5hc3NpZ25gIGV4Y2VwdCB0aGF0IGl0IHJlY3Vyc2l2ZWx5IG1lcmdlcyBvd24gYW5kXG4gICAgICogaW5oZXJpdGVkIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnRpZXMgb2Ygc291cmNlIG9iamVjdHMgaW50byB0aGVcbiAgICAgKiBkZXN0aW5hdGlvbiBvYmplY3QuIFNvdXJjZSBwcm9wZXJ0aWVzIHRoYXQgcmVzb2x2ZSB0byBgdW5kZWZpbmVkYCBhcmVcbiAgICAgKiBza2lwcGVkIGlmIGEgZGVzdGluYXRpb24gdmFsdWUgZXhpc3RzLiBBcnJheSBhbmQgcGxhaW4gb2JqZWN0IHByb3BlcnRpZXNcbiAgICAgKiBhcmUgbWVyZ2VkIHJlY3Vyc2l2ZWx5LiBPdGhlciBvYmplY3RzIGFuZCB2YWx1ZSB0eXBlcyBhcmUgb3ZlcnJpZGRlbiBieVxuICAgICAqIGFzc2lnbm1lbnQuIFNvdXJjZSBvYmplY3RzIGFyZSBhcHBsaWVkIGZyb20gbGVmdCB0byByaWdodC4gU3Vic2VxdWVudFxuICAgICAqIHNvdXJjZXMgb3ZlcndyaXRlIHByb3BlcnR5IGFzc2lnbm1lbnRzIG9mIHByZXZpb3VzIHNvdXJjZXMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjUuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHsuLi5PYmplY3R9IFtzb3VyY2VzXSBUaGUgc291cmNlIG9iamVjdHMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHtcbiAgICAgKiAgICdhJzogW3sgJ2InOiAyIH0sIHsgJ2QnOiA0IH1dXG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIHZhciBvdGhlciA9IHtcbiAgICAgKiAgICdhJzogW3sgJ2MnOiAzIH0sIHsgJ2UnOiA1IH1dXG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIF8ubWVyZ2Uob2JqZWN0LCBvdGhlcik7XG4gICAgICogLy8gPT4geyAnYSc6IFt7ICdiJzogMiwgJ2MnOiAzIH0sIHsgJ2QnOiA0LCAnZSc6IDUgfV0gfVxuICAgICAqL3ZhciBtZXJnZT1jcmVhdGVBc3NpZ25lcihmdW5jdGlvbihvYmplY3Qsc291cmNlLHNyY0luZGV4KXtiYXNlTWVyZ2Uob2JqZWN0LHNvdXJjZSxzcmNJbmRleCk7fSk7LyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5tZXJnZWAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgY3VzdG9taXplcmAgd2hpY2hcbiAgICAgKiBpcyBpbnZva2VkIHRvIHByb2R1Y2UgdGhlIG1lcmdlZCB2YWx1ZXMgb2YgdGhlIGRlc3RpbmF0aW9uIGFuZCBzb3VyY2VcbiAgICAgKiBwcm9wZXJ0aWVzLiBJZiBgY3VzdG9taXplcmAgcmV0dXJucyBgdW5kZWZpbmVkYCwgbWVyZ2luZyBpcyBoYW5kbGVkIGJ5IHRoZVxuICAgICAqIG1ldGhvZCBpbnN0ZWFkLiBUaGUgYGN1c3RvbWl6ZXJgIGlzIGludm9rZWQgd2l0aCBzaXggYXJndW1lbnRzOlxuICAgICAqIChvYmpWYWx1ZSwgc3JjVmFsdWUsIGtleSwgb2JqZWN0LCBzb3VyY2UsIHN0YWNrKS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gey4uLk9iamVjdH0gc291cmNlcyBUaGUgc291cmNlIG9iamVjdHMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGFzc2lnbmVkIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBjdXN0b21pemVyKG9ialZhbHVlLCBzcmNWYWx1ZSkge1xuICAgICAqICAgaWYgKF8uaXNBcnJheShvYmpWYWx1ZSkpIHtcbiAgICAgKiAgICAgcmV0dXJuIG9ialZhbHVlLmNvbmNhdChzcmNWYWx1ZSk7XG4gICAgICogICB9XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiBbMV0sICdiJzogWzJdIH07XG4gICAgICogdmFyIG90aGVyID0geyAnYSc6IFszXSwgJ2InOiBbNF0gfTtcbiAgICAgKlxuICAgICAqIF8ubWVyZ2VXaXRoKG9iamVjdCwgb3RoZXIsIGN1c3RvbWl6ZXIpO1xuICAgICAqIC8vID0+IHsgJ2EnOiBbMSwgM10sICdiJzogWzIsIDRdIH1cbiAgICAgKi92YXIgbWVyZ2VXaXRoPWNyZWF0ZUFzc2lnbmVyKGZ1bmN0aW9uKG9iamVjdCxzb3VyY2Usc3JjSW5kZXgsY3VzdG9taXplcil7YmFzZU1lcmdlKG9iamVjdCxzb3VyY2Usc3JjSW5kZXgsY3VzdG9taXplcik7fSk7LyoqXG4gICAgICogVGhlIG9wcG9zaXRlIG9mIGBfLnBpY2tgOyB0aGlzIG1ldGhvZCBjcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZiB0aGVcbiAgICAgKiBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnR5IHBhdGhzIG9mIGBvYmplY3RgIHRoYXQgYXJlIG5vdCBvbWl0dGVkLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGNvbnNpZGVyYWJseSBzbG93ZXIgdGhhbiBgXy5waWNrYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBzb3VyY2Ugb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uKHN0cmluZ3xzdHJpbmdbXSl9IFtwYXRoc10gVGhlIHByb3BlcnR5IHBhdGhzIHRvIG9taXQuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6ICcyJywgJ2MnOiAzIH07XG4gICAgICpcbiAgICAgKiBfLm9taXQob2JqZWN0LCBbJ2EnLCAnYyddKTtcbiAgICAgKiAvLyA9PiB7ICdiJzogJzInIH1cbiAgICAgKi92YXIgb21pdD1mbGF0UmVzdChmdW5jdGlvbihvYmplY3QscGF0aHMpe3ZhciByZXN1bHQ9e307aWYob2JqZWN0PT1udWxsKXtyZXR1cm4gcmVzdWx0O312YXIgaXNEZWVwPWZhbHNlO3BhdGhzPWFycmF5TWFwKHBhdGhzLGZ1bmN0aW9uKHBhdGgpe3BhdGg9Y2FzdFBhdGgocGF0aCxvYmplY3QpO2lzRGVlcHx8KGlzRGVlcD1wYXRoLmxlbmd0aD4xKTtyZXR1cm4gcGF0aDt9KTtjb3B5T2JqZWN0KG9iamVjdCxnZXRBbGxLZXlzSW4ob2JqZWN0KSxyZXN1bHQpO2lmKGlzRGVlcCl7cmVzdWx0PWJhc2VDbG9uZShyZXN1bHQsQ0xPTkVfREVFUF9GTEFHfENMT05FX0ZMQVRfRkxBR3xDTE9ORV9TWU1CT0xTX0ZMQUcsY3VzdG9tT21pdENsb25lKTt9dmFyIGxlbmd0aD1wYXRocy5sZW5ndGg7d2hpbGUobGVuZ3RoLS0pe2Jhc2VVbnNldChyZXN1bHQscGF0aHNbbGVuZ3RoXSk7fXJldHVybiByZXN1bHQ7fSk7LyoqXG4gICAgICogVGhlIG9wcG9zaXRlIG9mIGBfLnBpY2tCeWA7IHRoaXMgbWV0aG9kIGNyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mXG4gICAgICogdGhlIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnRpZXMgb2YgYG9iamVjdGAgdGhhdFxuICAgICAqIGBwcmVkaWNhdGVgIGRvZXNuJ3QgcmV0dXJuIHRydXRoeSBmb3IuIFRoZSBwcmVkaWNhdGUgaXMgaW52b2tlZCB3aXRoIHR3b1xuICAgICAqIGFyZ3VtZW50czogKHZhbHVlLCBrZXkpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgcHJvcGVydHkuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6ICcyJywgJ2MnOiAzIH07XG4gICAgICpcbiAgICAgKiBfLm9taXRCeShvYmplY3QsIF8uaXNOdW1iZXIpO1xuICAgICAqIC8vID0+IHsgJ2InOiAnMicgfVxuICAgICAqL2Z1bmN0aW9uIG9taXRCeShvYmplY3QscHJlZGljYXRlKXtyZXR1cm4gcGlja0J5KG9iamVjdCxuZWdhdGUoZ2V0SXRlcmF0ZWUocHJlZGljYXRlKSkpO30vKipcbiAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZiB0aGUgcGlja2VkIGBvYmplY3RgIHByb3BlcnRpZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgc291cmNlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gey4uLihzdHJpbmd8c3RyaW5nW10pfSBbcGF0aHNdIFRoZSBwcm9wZXJ0eSBwYXRocyB0byBwaWNrLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAnMicsICdjJzogMyB9O1xuICAgICAqXG4gICAgICogXy5waWNrKG9iamVjdCwgWydhJywgJ2MnXSk7XG4gICAgICogLy8gPT4geyAnYSc6IDEsICdjJzogMyB9XG4gICAgICovdmFyIHBpY2s9ZmxhdFJlc3QoZnVuY3Rpb24ob2JqZWN0LHBhdGhzKXtyZXR1cm4gb2JqZWN0PT1udWxsP3t9OmJhc2VQaWNrKG9iamVjdCxwYXRocyk7fSk7LyoqXG4gICAgICogQ3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgb2YgdGhlIGBvYmplY3RgIHByb3BlcnRpZXMgYHByZWRpY2F0ZWAgcmV0dXJuc1xuICAgICAqIHRydXRoeSBmb3IuIFRoZSBwcmVkaWNhdGUgaXMgaW52b2tlZCB3aXRoIHR3byBhcmd1bWVudHM6ICh2YWx1ZSwga2V5KS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBzb3VyY2Ugb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIHByb3BlcnR5LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAnMicsICdjJzogMyB9O1xuICAgICAqXG4gICAgICogXy5waWNrQnkob2JqZWN0LCBfLmlzTnVtYmVyKTtcbiAgICAgKiAvLyA9PiB7ICdhJzogMSwgJ2MnOiAzIH1cbiAgICAgKi9mdW5jdGlvbiBwaWNrQnkob2JqZWN0LHByZWRpY2F0ZSl7aWYob2JqZWN0PT1udWxsKXtyZXR1cm57fTt9dmFyIHByb3BzPWFycmF5TWFwKGdldEFsbEtleXNJbihvYmplY3QpLGZ1bmN0aW9uKHByb3Ape3JldHVybltwcm9wXTt9KTtwcmVkaWNhdGU9Z2V0SXRlcmF0ZWUocHJlZGljYXRlKTtyZXR1cm4gYmFzZVBpY2tCeShvYmplY3QscHJvcHMsZnVuY3Rpb24odmFsdWUscGF0aCl7cmV0dXJuIHByZWRpY2F0ZSh2YWx1ZSxwYXRoWzBdKTt9KTt9LyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5nZXRgIGV4Y2VwdCB0aGF0IGlmIHRoZSByZXNvbHZlZCB2YWx1ZSBpcyBhXG4gICAgICogZnVuY3Rpb24gaXQncyBpbnZva2VkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIGl0cyBwYXJlbnQgb2JqZWN0IGFuZFxuICAgICAqIGl0cyByZXN1bHQgaXMgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byByZXNvbHZlLlxuICAgICAqIEBwYXJhbSB7Kn0gW2RlZmF1bHRWYWx1ZV0gVGhlIHZhbHVlIHJldHVybmVkIGZvciBgdW5kZWZpbmVkYCByZXNvbHZlZCB2YWx1ZXMuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IFt7ICdiJzogeyAnYzEnOiAzLCAnYzInOiBfLmNvbnN0YW50KDQpIH0gfV0gfTtcbiAgICAgKlxuICAgICAqIF8ucmVzdWx0KG9iamVjdCwgJ2FbMF0uYi5jMScpO1xuICAgICAqIC8vID0+IDNcbiAgICAgKlxuICAgICAqIF8ucmVzdWx0KG9iamVjdCwgJ2FbMF0uYi5jMicpO1xuICAgICAqIC8vID0+IDRcbiAgICAgKlxuICAgICAqIF8ucmVzdWx0KG9iamVjdCwgJ2FbMF0uYi5jMycsICdkZWZhdWx0Jyk7XG4gICAgICogLy8gPT4gJ2RlZmF1bHQnXG4gICAgICpcbiAgICAgKiBfLnJlc3VsdChvYmplY3QsICdhWzBdLmIuYzMnLCBfLmNvbnN0YW50KCdkZWZhdWx0JykpO1xuICAgICAqIC8vID0+ICdkZWZhdWx0J1xuICAgICAqL2Z1bmN0aW9uIHJlc3VsdChvYmplY3QscGF0aCxkZWZhdWx0VmFsdWUpe3BhdGg9Y2FzdFBhdGgocGF0aCxvYmplY3QpO3ZhciBpbmRleD0tMSxsZW5ndGg9cGF0aC5sZW5ndGg7Ly8gRW5zdXJlIHRoZSBsb29wIGlzIGVudGVyZWQgd2hlbiBwYXRoIGlzIGVtcHR5LlxuaWYoIWxlbmd0aCl7bGVuZ3RoPTE7b2JqZWN0PXVuZGVmaW5lZDt9d2hpbGUoKytpbmRleDxsZW5ndGgpe3ZhciB2YWx1ZT1vYmplY3Q9PW51bGw/dW5kZWZpbmVkOm9iamVjdFt0b0tleShwYXRoW2luZGV4XSldO2lmKHZhbHVlPT09dW5kZWZpbmVkKXtpbmRleD1sZW5ndGg7dmFsdWU9ZGVmYXVsdFZhbHVlO31vYmplY3Q9aXNGdW5jdGlvbih2YWx1ZSk/dmFsdWUuY2FsbChvYmplY3QpOnZhbHVlO31yZXR1cm4gb2JqZWN0O30vKipcbiAgICAgKiBTZXRzIHRoZSB2YWx1ZSBhdCBgcGF0aGAgb2YgYG9iamVjdGAuIElmIGEgcG9ydGlvbiBvZiBgcGF0aGAgZG9lc24ndCBleGlzdCxcbiAgICAgKiBpdCdzIGNyZWF0ZWQuIEFycmF5cyBhcmUgY3JlYXRlZCBmb3IgbWlzc2luZyBpbmRleCBwcm9wZXJ0aWVzIHdoaWxlIG9iamVjdHNcbiAgICAgKiBhcmUgY3JlYXRlZCBmb3IgYWxsIG90aGVyIG1pc3NpbmcgcHJvcGVydGllcy4gVXNlIGBfLnNldFdpdGhgIHRvIGN1c3RvbWl6ZVxuICAgICAqIGBwYXRoYCBjcmVhdGlvbi5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuNy4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIHNldC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiBbeyAnYic6IHsgJ2MnOiAzIH0gfV0gfTtcbiAgICAgKlxuICAgICAqIF8uc2V0KG9iamVjdCwgJ2FbMF0uYi5jJywgNCk7XG4gICAgICogY29uc29sZS5sb2cob2JqZWN0LmFbMF0uYi5jKTtcbiAgICAgKiAvLyA9PiA0XG4gICAgICpcbiAgICAgKiBfLnNldChvYmplY3QsIFsneCcsICcwJywgJ3knLCAneiddLCA1KTtcbiAgICAgKiBjb25zb2xlLmxvZyhvYmplY3QueFswXS55LnopO1xuICAgICAqIC8vID0+IDVcbiAgICAgKi9mdW5jdGlvbiBzZXQob2JqZWN0LHBhdGgsdmFsdWUpe3JldHVybiBvYmplY3Q9PW51bGw/b2JqZWN0OmJhc2VTZXQob2JqZWN0LHBhdGgsdmFsdWUpO30vKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnNldGAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgY3VzdG9taXplcmAgd2hpY2ggaXNcbiAgICAgKiBpbnZva2VkIHRvIHByb2R1Y2UgdGhlIG9iamVjdHMgb2YgYHBhdGhgLiAgSWYgYGN1c3RvbWl6ZXJgIHJldHVybnMgYHVuZGVmaW5lZGBcbiAgICAgKiBwYXRoIGNyZWF0aW9uIGlzIGhhbmRsZWQgYnkgdGhlIG1ldGhvZCBpbnN0ZWFkLiBUaGUgYGN1c3RvbWl6ZXJgIGlzIGludm9rZWRcbiAgICAgKiB3aXRoIHRocmVlIGFyZ3VtZW50czogKG5zVmFsdWUsIGtleSwgbnNPYmplY3QpLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gc2V0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBhc3NpZ25lZCB2YWx1ZXMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHt9O1xuICAgICAqXG4gICAgICogXy5zZXRXaXRoKG9iamVjdCwgJ1swXVsxXScsICdhJywgT2JqZWN0KTtcbiAgICAgKiAvLyA9PiB7ICcwJzogeyAnMSc6ICdhJyB9IH1cbiAgICAgKi9mdW5jdGlvbiBzZXRXaXRoKG9iamVjdCxwYXRoLHZhbHVlLGN1c3RvbWl6ZXIpe2N1c3RvbWl6ZXI9dHlwZW9mIGN1c3RvbWl6ZXI9PSdmdW5jdGlvbic/Y3VzdG9taXplcjp1bmRlZmluZWQ7cmV0dXJuIG9iamVjdD09bnVsbD9vYmplY3Q6YmFzZVNldChvYmplY3QscGF0aCx2YWx1ZSxjdXN0b21pemVyKTt9LyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBvd24gZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQtdmFsdWUgcGFpcnMgZm9yIGBvYmplY3RgXG4gICAgICogd2hpY2ggY2FuIGJlIGNvbnN1bWVkIGJ5IGBfLmZyb21QYWlyc2AuIElmIGBvYmplY3RgIGlzIGEgbWFwIG9yIHNldCwgaXRzXG4gICAgICogZW50cmllcyBhcmUgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAYWxpYXMgZW50cmllc1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBrZXktdmFsdWUgcGFpcnMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogICB0aGlzLmIgPSAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gICAgICpcbiAgICAgKiBfLnRvUGFpcnMobmV3IEZvbyk7XG4gICAgICogLy8gPT4gW1snYScsIDFdLCBbJ2InLCAyXV0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKi92YXIgdG9QYWlycz1jcmVhdGVUb1BhaXJzKGtleXMpOy8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2Ygb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQtdmFsdWUgcGFpcnNcbiAgICAgKiBmb3IgYG9iamVjdGAgd2hpY2ggY2FuIGJlIGNvbnN1bWVkIGJ5IGBfLmZyb21QYWlyc2AuIElmIGBvYmplY3RgIGlzIGEgbWFwXG4gICAgICogb3Igc2V0LCBpdHMgZW50cmllcyBhcmUgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAYWxpYXMgZW50cmllc0luXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGtleS12YWx1ZSBwYWlycy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gMTtcbiAgICAgKiAgIHRoaXMuYiA9IDI7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAgICAgKlxuICAgICAqIF8udG9QYWlyc0luKG5ldyBGb28pO1xuICAgICAqIC8vID0+IFtbJ2EnLCAxXSwgWydiJywgMl0sIFsnYycsIDNdXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICAgICAqL3ZhciB0b1BhaXJzSW49Y3JlYXRlVG9QYWlycyhrZXlzSW4pOy8qKlxuICAgICAqIEFuIGFsdGVybmF0aXZlIHRvIGBfLnJlZHVjZWA7IHRoaXMgbWV0aG9kIHRyYW5zZm9ybXMgYG9iamVjdGAgdG8gYSBuZXdcbiAgICAgKiBgYWNjdW11bGF0b3JgIG9iamVjdCB3aGljaCBpcyB0aGUgcmVzdWx0IG9mIHJ1bm5pbmcgZWFjaCBvZiBpdHMgb3duXG4gICAgICogZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydGllcyB0aHJ1IGBpdGVyYXRlZWAsIHdpdGggZWFjaCBpbnZvY2F0aW9uXG4gICAgICogcG90ZW50aWFsbHkgbXV0YXRpbmcgdGhlIGBhY2N1bXVsYXRvcmAgb2JqZWN0LiBJZiBgYWNjdW11bGF0b3JgIGlzIG5vdFxuICAgICAqIHByb3ZpZGVkLCBhIG5ldyBvYmplY3Qgd2l0aCB0aGUgc2FtZSBgW1tQcm90b3R5cGVdXWAgd2lsbCBiZSB1c2VkLiBUaGVcbiAgICAgKiBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggZm91ciBhcmd1bWVudHM6IChhY2N1bXVsYXRvciwgdmFsdWUsIGtleSwgb2JqZWN0KS5cbiAgICAgKiBJdGVyYXRlZSBmdW5jdGlvbnMgbWF5IGV4aXQgaXRlcmF0aW9uIGVhcmx5IGJ5IGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMS4zLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFthY2N1bXVsYXRvcl0gVGhlIGN1c3RvbSBhY2N1bXVsYXRvciB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYWNjdW11bGF0ZWQgdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udHJhbnNmb3JtKFsyLCAzLCA0XSwgZnVuY3Rpb24ocmVzdWx0LCBuKSB7XG4gICAgICogICByZXN1bHQucHVzaChuICo9IG4pO1xuICAgICAqICAgcmV0dXJuIG4gJSAyID09IDA7XG4gICAgICogfSwgW10pO1xuICAgICAqIC8vID0+IFs0LCA5XVxuICAgICAqXG4gICAgICogXy50cmFuc2Zvcm0oeyAnYSc6IDEsICdiJzogMiwgJ2MnOiAxIH0sIGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgICAqICAgKHJlc3VsdFt2YWx1ZV0gfHwgKHJlc3VsdFt2YWx1ZV0gPSBbXSkpLnB1c2goa2V5KTtcbiAgICAgKiB9LCB7fSk7XG4gICAgICogLy8gPT4geyAnMSc6IFsnYScsICdjJ10sICcyJzogWydiJ10gfVxuICAgICAqL2Z1bmN0aW9uIHRyYW5zZm9ybShvYmplY3QsaXRlcmF0ZWUsYWNjdW11bGF0b3Ipe3ZhciBpc0Fycj1pc0FycmF5KG9iamVjdCksaXNBcnJMaWtlPWlzQXJyfHxpc0J1ZmZlcihvYmplY3QpfHxpc1R5cGVkQXJyYXkob2JqZWN0KTtpdGVyYXRlZT1nZXRJdGVyYXRlZShpdGVyYXRlZSw0KTtpZihhY2N1bXVsYXRvcj09bnVsbCl7dmFyIEN0b3I9b2JqZWN0JiZvYmplY3QuY29uc3RydWN0b3I7aWYoaXNBcnJMaWtlKXthY2N1bXVsYXRvcj1pc0Fycj9uZXcgQ3RvcigpOltdO31lbHNlIGlmKGlzT2JqZWN0KG9iamVjdCkpe2FjY3VtdWxhdG9yPWlzRnVuY3Rpb24oQ3Rvcik/YmFzZUNyZWF0ZShnZXRQcm90b3R5cGUob2JqZWN0KSk6e307fWVsc2V7YWNjdW11bGF0b3I9e307fX0oaXNBcnJMaWtlP2FycmF5RWFjaDpiYXNlRm9yT3duKShvYmplY3QsZnVuY3Rpb24odmFsdWUsaW5kZXgsb2JqZWN0KXtyZXR1cm4gaXRlcmF0ZWUoYWNjdW11bGF0b3IsdmFsdWUsaW5kZXgsb2JqZWN0KTt9KTtyZXR1cm4gYWNjdW11bGF0b3I7fS8qKlxuICAgICAqIFJlbW92ZXMgdGhlIHByb3BlcnR5IGF0IGBwYXRoYCBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIHVuc2V0LlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcHJvcGVydHkgaXMgZGVsZXRlZCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IFt7ICdiJzogeyAnYyc6IDcgfSB9XSB9O1xuICAgICAqIF8udW5zZXQob2JqZWN0LCAnYVswXS5iLmMnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhvYmplY3QpO1xuICAgICAqIC8vID0+IHsgJ2EnOiBbeyAnYic6IHt9IH1dIH07XG4gICAgICpcbiAgICAgKiBfLnVuc2V0KG9iamVjdCwgWydhJywgJzAnLCAnYicsICdjJ10pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKG9iamVjdCk7XG4gICAgICogLy8gPT4geyAnYSc6IFt7ICdiJzoge30gfV0gfTtcbiAgICAgKi9mdW5jdGlvbiB1bnNldChvYmplY3QscGF0aCl7cmV0dXJuIG9iamVjdD09bnVsbD90cnVlOmJhc2VVbnNldChvYmplY3QscGF0aCk7fS8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uc2V0YCBleGNlcHQgdGhhdCBhY2NlcHRzIGB1cGRhdGVyYCB0byBwcm9kdWNlIHRoZVxuICAgICAqIHZhbHVlIHRvIHNldC4gVXNlIGBfLnVwZGF0ZVdpdGhgIHRvIGN1c3RvbWl6ZSBgcGF0aGAgY3JlYXRpb24uIFRoZSBgdXBkYXRlcmBcbiAgICAgKiBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC42LjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gc2V0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHVwZGF0ZXIgVGhlIGZ1bmN0aW9uIHRvIHByb2R1Y2UgdGhlIHVwZGF0ZWQgdmFsdWUuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiBbeyAnYic6IHsgJ2MnOiAzIH0gfV0gfTtcbiAgICAgKlxuICAgICAqIF8udXBkYXRlKG9iamVjdCwgJ2FbMF0uYi5jJywgZnVuY3Rpb24obikgeyByZXR1cm4gbiAqIG47IH0pO1xuICAgICAqIGNvbnNvbGUubG9nKG9iamVjdC5hWzBdLmIuYyk7XG4gICAgICogLy8gPT4gOVxuICAgICAqXG4gICAgICogXy51cGRhdGUob2JqZWN0LCAneFswXS55LnonLCBmdW5jdGlvbihuKSB7IHJldHVybiBuID8gbiArIDEgOiAwOyB9KTtcbiAgICAgKiBjb25zb2xlLmxvZyhvYmplY3QueFswXS55LnopO1xuICAgICAqIC8vID0+IDBcbiAgICAgKi9mdW5jdGlvbiB1cGRhdGUob2JqZWN0LHBhdGgsdXBkYXRlcil7cmV0dXJuIG9iamVjdD09bnVsbD9vYmplY3Q6YmFzZVVwZGF0ZShvYmplY3QscGF0aCxjYXN0RnVuY3Rpb24odXBkYXRlcikpO30vKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnVwZGF0ZWAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgY3VzdG9taXplcmAgd2hpY2ggaXNcbiAgICAgKiBpbnZva2VkIHRvIHByb2R1Y2UgdGhlIG9iamVjdHMgb2YgYHBhdGhgLiAgSWYgYGN1c3RvbWl6ZXJgIHJldHVybnMgYHVuZGVmaW5lZGBcbiAgICAgKiBwYXRoIGNyZWF0aW9uIGlzIGhhbmRsZWQgYnkgdGhlIG1ldGhvZCBpbnN0ZWFkLiBUaGUgYGN1c3RvbWl6ZXJgIGlzIGludm9rZWRcbiAgICAgKiB3aXRoIHRocmVlIGFyZ3VtZW50czogKG5zVmFsdWUsIGtleSwgbnNPYmplY3QpLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC42LjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gc2V0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHVwZGF0ZXIgVGhlIGZ1bmN0aW9uIHRvIHByb2R1Y2UgdGhlIHVwZGF0ZWQgdmFsdWUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgYXNzaWduZWQgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7fTtcbiAgICAgKlxuICAgICAqIF8udXBkYXRlV2l0aChvYmplY3QsICdbMF1bMV0nLCBfLmNvbnN0YW50KCdhJyksIE9iamVjdCk7XG4gICAgICogLy8gPT4geyAnMCc6IHsgJzEnOiAnYScgfSB9XG4gICAgICovZnVuY3Rpb24gdXBkYXRlV2l0aChvYmplY3QscGF0aCx1cGRhdGVyLGN1c3RvbWl6ZXIpe2N1c3RvbWl6ZXI9dHlwZW9mIGN1c3RvbWl6ZXI9PSdmdW5jdGlvbic/Y3VzdG9taXplcjp1bmRlZmluZWQ7cmV0dXJuIG9iamVjdD09bnVsbD9vYmplY3Q6YmFzZVVwZGF0ZShvYmplY3QscGF0aCxjYXN0RnVuY3Rpb24odXBkYXRlciksY3VzdG9taXplcik7fS8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0eSB2YWx1ZXMgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogICB0aGlzLmIgPSAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gICAgICpcbiAgICAgKiBfLnZhbHVlcyhuZXcgRm9vKTtcbiAgICAgKiAvLyA9PiBbMSwgMl0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKlxuICAgICAqIF8udmFsdWVzKCdoaScpO1xuICAgICAqIC8vID0+IFsnaCcsICdpJ11cbiAgICAgKi9mdW5jdGlvbiB2YWx1ZXMob2JqZWN0KXtyZXR1cm4gb2JqZWN0PT1udWxsP1tdOmJhc2VWYWx1ZXMob2JqZWN0LGtleXMob2JqZWN0KSk7fS8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnR5XG4gICAgICogdmFsdWVzIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSAxO1xuICAgICAqICAgdGhpcy5iID0gMjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICAgICAqXG4gICAgICogXy52YWx1ZXNJbihuZXcgRm9vKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKi9mdW5jdGlvbiB2YWx1ZXNJbihvYmplY3Qpe3JldHVybiBvYmplY3Q9PW51bGw/W106YmFzZVZhbHVlcyhvYmplY3Qsa2V5c0luKG9iamVjdCkpO30vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovLyoqXG4gICAgICogQ2xhbXBzIGBudW1iZXJgIHdpdGhpbiB0aGUgaW5jbHVzaXZlIGBsb3dlcmAgYW5kIGB1cHBlcmAgYm91bmRzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IE51bWJlclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBudW1iZXIgVGhlIG51bWJlciB0byBjbGFtcC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xvd2VyXSBUaGUgbG93ZXIgYm91bmQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHVwcGVyIFRoZSB1cHBlciBib3VuZC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjbGFtcGVkIG51bWJlci5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5jbGFtcCgtMTAsIC01LCA1KTtcbiAgICAgKiAvLyA9PiAtNVxuICAgICAqXG4gICAgICogXy5jbGFtcCgxMCwgLTUsIDUpO1xuICAgICAqIC8vID0+IDVcbiAgICAgKi9mdW5jdGlvbiBjbGFtcChudW1iZXIsbG93ZXIsdXBwZXIpe2lmKHVwcGVyPT09dW5kZWZpbmVkKXt1cHBlcj1sb3dlcjtsb3dlcj11bmRlZmluZWQ7fWlmKHVwcGVyIT09dW5kZWZpbmVkKXt1cHBlcj10b051bWJlcih1cHBlcik7dXBwZXI9dXBwZXI9PT11cHBlcj91cHBlcjowO31pZihsb3dlciE9PXVuZGVmaW5lZCl7bG93ZXI9dG9OdW1iZXIobG93ZXIpO2xvd2VyPWxvd2VyPT09bG93ZXI/bG93ZXI6MDt9cmV0dXJuIGJhc2VDbGFtcCh0b051bWJlcihudW1iZXIpLGxvd2VyLHVwcGVyKTt9LyoqXG4gICAgICogQ2hlY2tzIGlmIGBuYCBpcyBiZXR3ZWVuIGBzdGFydGAgYW5kIHVwIHRvLCBidXQgbm90IGluY2x1ZGluZywgYGVuZGAuIElmXG4gICAgICogYGVuZGAgaXMgbm90IHNwZWNpZmllZCwgaXQncyBzZXQgdG8gYHN0YXJ0YCB3aXRoIGBzdGFydGAgdGhlbiBzZXQgdG8gYDBgLlxuICAgICAqIElmIGBzdGFydGAgaXMgZ3JlYXRlciB0aGFuIGBlbmRgIHRoZSBwYXJhbXMgYXJlIHN3YXBwZWQgdG8gc3VwcG9ydFxuICAgICAqIG5lZ2F0aXZlIHJhbmdlcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjMuMFxuICAgICAqIEBjYXRlZ29yeSBOdW1iZXJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbnVtYmVyIFRoZSBudW1iZXIgdG8gY2hlY2suXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD0wXSBUaGUgc3RhcnQgb2YgdGhlIHJhbmdlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgVGhlIGVuZCBvZiB0aGUgcmFuZ2UuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBudW1iZXJgIGlzIGluIHRoZSByYW5nZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBzZWUgXy5yYW5nZSwgXy5yYW5nZVJpZ2h0XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaW5SYW5nZSgzLCAyLCA0KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmluUmFuZ2UoNCwgOCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pblJhbmdlKDQsIDIpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmluUmFuZ2UoMiwgMik7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaW5SYW5nZSgxLjIsIDIpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaW5SYW5nZSg1LjIsIDQpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmluUmFuZ2UoLTMsIC0yLCAtNik7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL2Z1bmN0aW9uIGluUmFuZ2UobnVtYmVyLHN0YXJ0LGVuZCl7c3RhcnQ9dG9GaW5pdGUoc3RhcnQpO2lmKGVuZD09PXVuZGVmaW5lZCl7ZW5kPXN0YXJ0O3N0YXJ0PTA7fWVsc2V7ZW5kPXRvRmluaXRlKGVuZCk7fW51bWJlcj10b051bWJlcihudW1iZXIpO3JldHVybiBiYXNlSW5SYW5nZShudW1iZXIsc3RhcnQsZW5kKTt9LyoqXG4gICAgICogUHJvZHVjZXMgYSByYW5kb20gbnVtYmVyIGJldHdlZW4gdGhlIGluY2x1c2l2ZSBgbG93ZXJgIGFuZCBgdXBwZXJgIGJvdW5kcy5cbiAgICAgKiBJZiBvbmx5IG9uZSBhcmd1bWVudCBpcyBwcm92aWRlZCBhIG51bWJlciBiZXR3ZWVuIGAwYCBhbmQgdGhlIGdpdmVuIG51bWJlclxuICAgICAqIGlzIHJldHVybmVkLiBJZiBgZmxvYXRpbmdgIGlzIGB0cnVlYCwgb3IgZWl0aGVyIGBsb3dlcmAgb3IgYHVwcGVyYCBhcmVcbiAgICAgKiBmbG9hdHMsIGEgZmxvYXRpbmctcG9pbnQgbnVtYmVyIGlzIHJldHVybmVkIGluc3RlYWQgb2YgYW4gaW50ZWdlci5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBKYXZhU2NyaXB0IGZvbGxvd3MgdGhlIElFRUUtNzU0IHN0YW5kYXJkIGZvciByZXNvbHZpbmdcbiAgICAgKiBmbG9hdGluZy1wb2ludCB2YWx1ZXMgd2hpY2ggY2FuIHByb2R1Y2UgdW5leHBlY3RlZCByZXN1bHRzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuNy4wXG4gICAgICogQGNhdGVnb3J5IE51bWJlclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbG93ZXI9MF0gVGhlIGxvd2VyIGJvdW5kLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbdXBwZXI9MV0gVGhlIHVwcGVyIGJvdW5kLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zsb2F0aW5nXSBTcGVjaWZ5IHJldHVybmluZyBhIGZsb2F0aW5nLXBvaW50IG51bWJlci5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSByYW5kb20gbnVtYmVyLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnJhbmRvbSgwLCA1KTtcbiAgICAgKiAvLyA9PiBhbiBpbnRlZ2VyIGJldHdlZW4gMCBhbmQgNVxuICAgICAqXG4gICAgICogXy5yYW5kb20oNSk7XG4gICAgICogLy8gPT4gYWxzbyBhbiBpbnRlZ2VyIGJldHdlZW4gMCBhbmQgNVxuICAgICAqXG4gICAgICogXy5yYW5kb20oNSwgdHJ1ZSk7XG4gICAgICogLy8gPT4gYSBmbG9hdGluZy1wb2ludCBudW1iZXIgYmV0d2VlbiAwIGFuZCA1XG4gICAgICpcbiAgICAgKiBfLnJhbmRvbSgxLjIsIDUuMik7XG4gICAgICogLy8gPT4gYSBmbG9hdGluZy1wb2ludCBudW1iZXIgYmV0d2VlbiAxLjIgYW5kIDUuMlxuICAgICAqL2Z1bmN0aW9uIHJhbmRvbShsb3dlcix1cHBlcixmbG9hdGluZyl7aWYoZmxvYXRpbmcmJnR5cGVvZiBmbG9hdGluZyE9J2Jvb2xlYW4nJiZpc0l0ZXJhdGVlQ2FsbChsb3dlcix1cHBlcixmbG9hdGluZykpe3VwcGVyPWZsb2F0aW5nPXVuZGVmaW5lZDt9aWYoZmxvYXRpbmc9PT11bmRlZmluZWQpe2lmKHR5cGVvZiB1cHBlcj09J2Jvb2xlYW4nKXtmbG9hdGluZz11cHBlcjt1cHBlcj11bmRlZmluZWQ7fWVsc2UgaWYodHlwZW9mIGxvd2VyPT0nYm9vbGVhbicpe2Zsb2F0aW5nPWxvd2VyO2xvd2VyPXVuZGVmaW5lZDt9fWlmKGxvd2VyPT09dW5kZWZpbmVkJiZ1cHBlcj09PXVuZGVmaW5lZCl7bG93ZXI9MDt1cHBlcj0xO31lbHNle2xvd2VyPXRvRmluaXRlKGxvd2VyKTtpZih1cHBlcj09PXVuZGVmaW5lZCl7dXBwZXI9bG93ZXI7bG93ZXI9MDt9ZWxzZXt1cHBlcj10b0Zpbml0ZSh1cHBlcik7fX1pZihsb3dlcj51cHBlcil7dmFyIHRlbXA9bG93ZXI7bG93ZXI9dXBwZXI7dXBwZXI9dGVtcDt9aWYoZmxvYXRpbmd8fGxvd2VyJTF8fHVwcGVyJTEpe3ZhciByYW5kPW5hdGl2ZVJhbmRvbSgpO3JldHVybiBuYXRpdmVNaW4obG93ZXIrcmFuZCoodXBwZXItbG93ZXIrZnJlZVBhcnNlRmxvYXQoJzFlLScrKChyYW5kKycnKS5sZW5ndGgtMSkpKSx1cHBlcik7fXJldHVybiBiYXNlUmFuZG9tKGxvd2VyLHVwcGVyKTt9LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qLy8qKlxuICAgICAqIENvbnZlcnRzIGBzdHJpbmdgIHRvIFtjYW1lbCBjYXNlXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DYW1lbENhc2UpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY2FtZWwgY2FzZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmNhbWVsQ2FzZSgnRm9vIEJhcicpO1xuICAgICAqIC8vID0+ICdmb29CYXInXG4gICAgICpcbiAgICAgKiBfLmNhbWVsQ2FzZSgnLS1mb28tYmFyLS0nKTtcbiAgICAgKiAvLyA9PiAnZm9vQmFyJ1xuICAgICAqXG4gICAgICogXy5jYW1lbENhc2UoJ19fRk9PX0JBUl9fJyk7XG4gICAgICogLy8gPT4gJ2Zvb0JhcidcbiAgICAgKi92YXIgY2FtZWxDYXNlPWNyZWF0ZUNvbXBvdW5kZXIoZnVuY3Rpb24ocmVzdWx0LHdvcmQsaW5kZXgpe3dvcmQ9d29yZC50b0xvd2VyQ2FzZSgpO3JldHVybiByZXN1bHQrKGluZGV4P2NhcGl0YWxpemUod29yZCk6d29yZCk7fSk7LyoqXG4gICAgICogQ29udmVydHMgdGhlIGZpcnN0IGNoYXJhY3RlciBvZiBgc3RyaW5nYCB0byB1cHBlciBjYXNlIGFuZCB0aGUgcmVtYWluaW5nXG4gICAgICogdG8gbG93ZXIgY2FzZS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBjYXBpdGFsaXplLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNhcGl0YWxpemVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5jYXBpdGFsaXplKCdGUkVEJyk7XG4gICAgICogLy8gPT4gJ0ZyZWQnXG4gICAgICovZnVuY3Rpb24gY2FwaXRhbGl6ZShzdHJpbmcpe3JldHVybiB1cHBlckZpcnN0KHRvU3RyaW5nKHN0cmluZykudG9Mb3dlckNhc2UoKSk7fS8qKlxuICAgICAqIERlYnVycnMgYHN0cmluZ2AgYnkgY29udmVydGluZ1xuICAgICAqIFtMYXRpbi0xIFN1cHBsZW1lbnRdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xhdGluLTFfU3VwcGxlbWVudF8oVW5pY29kZV9ibG9jaykjQ2hhcmFjdGVyX3RhYmxlKVxuICAgICAqIGFuZCBbTGF0aW4gRXh0ZW5kZWQtQV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGF0aW5fRXh0ZW5kZWQtQSlcbiAgICAgKiBsZXR0ZXJzIHRvIGJhc2ljIExhdGluIGxldHRlcnMgYW5kIHJlbW92aW5nXG4gICAgICogW2NvbWJpbmluZyBkaWFjcml0aWNhbCBtYXJrc10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29tYmluaW5nX0RpYWNyaXRpY2FsX01hcmtzKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBkZWJ1cnIuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZGVidXJyZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRlYnVycignZMOpasOgIHZ1Jyk7XG4gICAgICogLy8gPT4gJ2RlamEgdnUnXG4gICAgICovZnVuY3Rpb24gZGVidXJyKHN0cmluZyl7c3RyaW5nPXRvU3RyaW5nKHN0cmluZyk7cmV0dXJuIHN0cmluZyYmc3RyaW5nLnJlcGxhY2UocmVMYXRpbixkZWJ1cnJMZXR0ZXIpLnJlcGxhY2UocmVDb21ib01hcmssJycpO30vKipcbiAgICAgKiBDaGVja3MgaWYgYHN0cmluZ2AgZW5kcyB3aXRoIHRoZSBnaXZlbiB0YXJnZXQgc3RyaW5nLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFt0YXJnZXRdIFRoZSBzdHJpbmcgdG8gc2VhcmNoIGZvci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3Bvc2l0aW9uPXN0cmluZy5sZW5ndGhdIFRoZSBwb3NpdGlvbiB0byBzZWFyY2ggdXAgdG8uXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBzdHJpbmdgIGVuZHMgd2l0aCBgdGFyZ2V0YCxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmVuZHNXaXRoKCdhYmMnLCAnYycpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uZW5kc1dpdGgoJ2FiYycsICdiJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uZW5kc1dpdGgoJ2FiYycsICdiJywgMik7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL2Z1bmN0aW9uIGVuZHNXaXRoKHN0cmluZyx0YXJnZXQscG9zaXRpb24pe3N0cmluZz10b1N0cmluZyhzdHJpbmcpO3RhcmdldD1iYXNlVG9TdHJpbmcodGFyZ2V0KTt2YXIgbGVuZ3RoPXN0cmluZy5sZW5ndGg7cG9zaXRpb249cG9zaXRpb249PT11bmRlZmluZWQ/bGVuZ3RoOmJhc2VDbGFtcCh0b0ludGVnZXIocG9zaXRpb24pLDAsbGVuZ3RoKTt2YXIgZW5kPXBvc2l0aW9uO3Bvc2l0aW9uLT10YXJnZXQubGVuZ3RoO3JldHVybiBwb3NpdGlvbj49MCYmc3RyaW5nLnNsaWNlKHBvc2l0aW9uLGVuZCk9PXRhcmdldDt9LyoqXG4gICAgICogQ29udmVydHMgdGhlIGNoYXJhY3RlcnMgXCImXCIsIFwiPFwiLCBcIj5cIiwgJ1wiJywgYW5kIFwiJ1wiIGluIGBzdHJpbmdgIHRvIHRoZWlyXG4gICAgICogY29ycmVzcG9uZGluZyBIVE1MIGVudGl0aWVzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIE5vIG90aGVyIGNoYXJhY3RlcnMgYXJlIGVzY2FwZWQuIFRvIGVzY2FwZSBhZGRpdGlvbmFsXG4gICAgICogY2hhcmFjdGVycyB1c2UgYSB0aGlyZC1wYXJ0eSBsaWJyYXJ5IGxpa2UgW19oZV9dKGh0dHBzOi8vbXRocy5iZS9oZSkuXG4gICAgICpcbiAgICAgKiBUaG91Z2ggdGhlIFwiPlwiIGNoYXJhY3RlciBpcyBlc2NhcGVkIGZvciBzeW1tZXRyeSwgY2hhcmFjdGVycyBsaWtlXG4gICAgICogXCI+XCIgYW5kIFwiL1wiIGRvbid0IG5lZWQgZXNjYXBpbmcgaW4gSFRNTCBhbmQgaGF2ZSBubyBzcGVjaWFsIG1lYW5pbmdcbiAgICAgKiB1bmxlc3MgdGhleSdyZSBwYXJ0IG9mIGEgdGFnIG9yIHVucXVvdGVkIGF0dHJpYnV0ZSB2YWx1ZS4gU2VlXG4gICAgICogW01hdGhpYXMgQnluZW5zJ3MgYXJ0aWNsZV0oaHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2FtYmlndW91cy1hbXBlcnNhbmRzKVxuICAgICAqICh1bmRlciBcInNlbWktcmVsYXRlZCBmdW4gZmFjdFwiKSBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqXG4gICAgICogV2hlbiB3b3JraW5nIHdpdGggSFRNTCB5b3Ugc2hvdWxkIGFsd2F5c1xuICAgICAqIFtxdW90ZSBhdHRyaWJ1dGUgdmFsdWVzXShodHRwOi8vd29ua28uY29tL3Bvc3QvaHRtbC1lc2NhcGluZykgdG8gcmVkdWNlXG4gICAgICogWFNTIHZlY3RvcnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gZXNjYXBlLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGVzY2FwZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmVzY2FwZSgnZnJlZCwgYmFybmV5LCAmIHBlYmJsZXMnKTtcbiAgICAgKiAvLyA9PiAnZnJlZCwgYmFybmV5LCAmYW1wOyBwZWJibGVzJ1xuICAgICAqL2Z1bmN0aW9uIGVzY2FwZShzdHJpbmcpe3N0cmluZz10b1N0cmluZyhzdHJpbmcpO3JldHVybiBzdHJpbmcmJnJlSGFzVW5lc2NhcGVkSHRtbC50ZXN0KHN0cmluZyk/c3RyaW5nLnJlcGxhY2UocmVVbmVzY2FwZWRIdG1sLGVzY2FwZUh0bWxDaGFyKTpzdHJpbmc7fS8qKlxuICAgICAqIEVzY2FwZXMgdGhlIGBSZWdFeHBgIHNwZWNpYWwgY2hhcmFjdGVycyBcIl5cIiwgXCIkXCIsIFwiXFxcIiwgXCIuXCIsIFwiKlwiLCBcIitcIixcbiAgICAgKiBcIj9cIiwgXCIoXCIsIFwiKVwiLCBcIltcIiwgXCJdXCIsIFwie1wiLCBcIn1cIiwgYW5kIFwifFwiIGluIGBzdHJpbmdgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGVzY2FwZS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBlc2NhcGVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5lc2NhcGVSZWdFeHAoJ1tsb2Rhc2hdKGh0dHBzOi8vbG9kYXNoLmNvbS8pJyk7XG4gICAgICogLy8gPT4gJ1xcW2xvZGFzaFxcXVxcKGh0dHBzOi8vbG9kYXNoXFwuY29tL1xcKSdcbiAgICAgKi9mdW5jdGlvbiBlc2NhcGVSZWdFeHAoc3RyaW5nKXtzdHJpbmc9dG9TdHJpbmcoc3RyaW5nKTtyZXR1cm4gc3RyaW5nJiZyZUhhc1JlZ0V4cENoYXIudGVzdChzdHJpbmcpP3N0cmluZy5yZXBsYWNlKHJlUmVnRXhwQ2hhciwnXFxcXCQmJyk6c3RyaW5nO30vKipcbiAgICAgKiBDb252ZXJ0cyBgc3RyaW5nYCB0b1xuICAgICAqIFtrZWJhYiBjYXNlXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MZXR0ZXJfY2FzZSNTcGVjaWFsX2Nhc2Vfc3R5bGVzKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGtlYmFiIGNhc2VkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5rZWJhYkNhc2UoJ0ZvbyBCYXInKTtcbiAgICAgKiAvLyA9PiAnZm9vLWJhcidcbiAgICAgKlxuICAgICAqIF8ua2ViYWJDYXNlKCdmb29CYXInKTtcbiAgICAgKiAvLyA9PiAnZm9vLWJhcidcbiAgICAgKlxuICAgICAqIF8ua2ViYWJDYXNlKCdfX0ZPT19CQVJfXycpO1xuICAgICAqIC8vID0+ICdmb28tYmFyJ1xuICAgICAqL3ZhciBrZWJhYkNhc2U9Y3JlYXRlQ29tcG91bmRlcihmdW5jdGlvbihyZXN1bHQsd29yZCxpbmRleCl7cmV0dXJuIHJlc3VsdCsoaW5kZXg/Jy0nOicnKSt3b3JkLnRvTG93ZXJDYXNlKCk7fSk7LyoqXG4gICAgICogQ29udmVydHMgYHN0cmluZ2AsIGFzIHNwYWNlIHNlcGFyYXRlZCB3b3JkcywgdG8gbG93ZXIgY2FzZS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGxvd2VyIGNhc2VkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5sb3dlckNhc2UoJy0tRm9vLUJhci0tJyk7XG4gICAgICogLy8gPT4gJ2ZvbyBiYXInXG4gICAgICpcbiAgICAgKiBfLmxvd2VyQ2FzZSgnZm9vQmFyJyk7XG4gICAgICogLy8gPT4gJ2ZvbyBiYXInXG4gICAgICpcbiAgICAgKiBfLmxvd2VyQ2FzZSgnX19GT09fQkFSX18nKTtcbiAgICAgKiAvLyA9PiAnZm9vIGJhcidcbiAgICAgKi92YXIgbG93ZXJDYXNlPWNyZWF0ZUNvbXBvdW5kZXIoZnVuY3Rpb24ocmVzdWx0LHdvcmQsaW5kZXgpe3JldHVybiByZXN1bHQrKGluZGV4PycgJzonJykrd29yZC50b0xvd2VyQ2FzZSgpO30pOy8qKlxuICAgICAqIENvbnZlcnRzIHRoZSBmaXJzdCBjaGFyYWN0ZXIgb2YgYHN0cmluZ2AgdG8gbG93ZXIgY2FzZS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubG93ZXJGaXJzdCgnRnJlZCcpO1xuICAgICAqIC8vID0+ICdmcmVkJ1xuICAgICAqXG4gICAgICogXy5sb3dlckZpcnN0KCdGUkVEJyk7XG4gICAgICogLy8gPT4gJ2ZSRUQnXG4gICAgICovdmFyIGxvd2VyRmlyc3Q9Y3JlYXRlQ2FzZUZpcnN0KCd0b0xvd2VyQ2FzZScpOy8qKlxuICAgICAqIFBhZHMgYHN0cmluZ2Agb24gdGhlIGxlZnQgYW5kIHJpZ2h0IHNpZGVzIGlmIGl0J3Mgc2hvcnRlciB0aGFuIGBsZW5ndGhgLlxuICAgICAqIFBhZGRpbmcgY2hhcmFjdGVycyBhcmUgdHJ1bmNhdGVkIGlmIHRoZXkgY2FuJ3QgYmUgZXZlbmx5IGRpdmlkZWQgYnkgYGxlbmd0aGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gcGFkLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPTBdIFRoZSBwYWRkaW5nIGxlbmd0aC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2NoYXJzPScgJ10gVGhlIHN0cmluZyB1c2VkIGFzIHBhZGRpbmcuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcGFkZGVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5wYWQoJ2FiYycsIDgpO1xuICAgICAqIC8vID0+ICcgIGFiYyAgICdcbiAgICAgKlxuICAgICAqIF8ucGFkKCdhYmMnLCA4LCAnXy0nKTtcbiAgICAgKiAvLyA9PiAnXy1hYmNfLV8nXG4gICAgICpcbiAgICAgKiBfLnBhZCgnYWJjJywgMyk7XG4gICAgICogLy8gPT4gJ2FiYydcbiAgICAgKi9mdW5jdGlvbiBwYWQoc3RyaW5nLGxlbmd0aCxjaGFycyl7c3RyaW5nPXRvU3RyaW5nKHN0cmluZyk7bGVuZ3RoPXRvSW50ZWdlcihsZW5ndGgpO3ZhciBzdHJMZW5ndGg9bGVuZ3RoP3N0cmluZ1NpemUoc3RyaW5nKTowO2lmKCFsZW5ndGh8fHN0ckxlbmd0aD49bGVuZ3RoKXtyZXR1cm4gc3RyaW5nO312YXIgbWlkPShsZW5ndGgtc3RyTGVuZ3RoKS8yO3JldHVybiBjcmVhdGVQYWRkaW5nKG5hdGl2ZUZsb29yKG1pZCksY2hhcnMpK3N0cmluZytjcmVhdGVQYWRkaW5nKG5hdGl2ZUNlaWwobWlkKSxjaGFycyk7fS8qKlxuICAgICAqIFBhZHMgYHN0cmluZ2Agb24gdGhlIHJpZ2h0IHNpZGUgaWYgaXQncyBzaG9ydGVyIHRoYW4gYGxlbmd0aGAuIFBhZGRpbmdcbiAgICAgKiBjaGFyYWN0ZXJzIGFyZSB0cnVuY2F0ZWQgaWYgdGhleSBleGNlZWQgYGxlbmd0aGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gcGFkLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPTBdIFRoZSBwYWRkaW5nIGxlbmd0aC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2NoYXJzPScgJ10gVGhlIHN0cmluZyB1c2VkIGFzIHBhZGRpbmcuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcGFkZGVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5wYWRFbmQoJ2FiYycsIDYpO1xuICAgICAqIC8vID0+ICdhYmMgICAnXG4gICAgICpcbiAgICAgKiBfLnBhZEVuZCgnYWJjJywgNiwgJ18tJyk7XG4gICAgICogLy8gPT4gJ2FiY18tXydcbiAgICAgKlxuICAgICAqIF8ucGFkRW5kKCdhYmMnLCAzKTtcbiAgICAgKiAvLyA9PiAnYWJjJ1xuICAgICAqL2Z1bmN0aW9uIHBhZEVuZChzdHJpbmcsbGVuZ3RoLGNoYXJzKXtzdHJpbmc9dG9TdHJpbmcoc3RyaW5nKTtsZW5ndGg9dG9JbnRlZ2VyKGxlbmd0aCk7dmFyIHN0ckxlbmd0aD1sZW5ndGg/c3RyaW5nU2l6ZShzdHJpbmcpOjA7cmV0dXJuIGxlbmd0aCYmc3RyTGVuZ3RoPGxlbmd0aD9zdHJpbmcrY3JlYXRlUGFkZGluZyhsZW5ndGgtc3RyTGVuZ3RoLGNoYXJzKTpzdHJpbmc7fS8qKlxuICAgICAqIFBhZHMgYHN0cmluZ2Agb24gdGhlIGxlZnQgc2lkZSBpZiBpdCdzIHNob3J0ZXIgdGhhbiBgbGVuZ3RoYC4gUGFkZGluZ1xuICAgICAqIGNoYXJhY3RlcnMgYXJlIHRydW5jYXRlZCBpZiB0aGV5IGV4Y2VlZCBgbGVuZ3RoYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBwYWQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9MF0gVGhlIHBhZGRpbmcgbGVuZ3RoLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY2hhcnM9JyAnXSBUaGUgc3RyaW5nIHVzZWQgYXMgcGFkZGluZy5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBwYWRkZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnBhZFN0YXJ0KCdhYmMnLCA2KTtcbiAgICAgKiAvLyA9PiAnICAgYWJjJ1xuICAgICAqXG4gICAgICogXy5wYWRTdGFydCgnYWJjJywgNiwgJ18tJyk7XG4gICAgICogLy8gPT4gJ18tX2FiYydcbiAgICAgKlxuICAgICAqIF8ucGFkU3RhcnQoJ2FiYycsIDMpO1xuICAgICAqIC8vID0+ICdhYmMnXG4gICAgICovZnVuY3Rpb24gcGFkU3RhcnQoc3RyaW5nLGxlbmd0aCxjaGFycyl7c3RyaW5nPXRvU3RyaW5nKHN0cmluZyk7bGVuZ3RoPXRvSW50ZWdlcihsZW5ndGgpO3ZhciBzdHJMZW5ndGg9bGVuZ3RoP3N0cmluZ1NpemUoc3RyaW5nKTowO3JldHVybiBsZW5ndGgmJnN0ckxlbmd0aDxsZW5ndGg/Y3JlYXRlUGFkZGluZyhsZW5ndGgtc3RyTGVuZ3RoLGNoYXJzKStzdHJpbmc6c3RyaW5nO30vKipcbiAgICAgKiBDb252ZXJ0cyBgc3RyaW5nYCB0byBhbiBpbnRlZ2VyIG9mIHRoZSBzcGVjaWZpZWQgcmFkaXguIElmIGByYWRpeGAgaXNcbiAgICAgKiBgdW5kZWZpbmVkYCBvciBgMGAsIGEgYHJhZGl4YCBvZiBgMTBgIGlzIHVzZWQgdW5sZXNzIGB2YWx1ZWAgaXMgYVxuICAgICAqIGhleGFkZWNpbWFsLCBpbiB3aGljaCBjYXNlIGEgYHJhZGl4YCBvZiBgMTZgIGlzIHVzZWQuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgYWxpZ25zIHdpdGggdGhlXG4gICAgICogW0VTNSBpbXBsZW1lbnRhdGlvbl0oaHR0cHM6Ly9lczUuZ2l0aHViLmlvLyN4MTUuMS4yLjIpIG9mIGBwYXJzZUludGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMS4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtyYWRpeD0xMF0gVGhlIHJhZGl4IHRvIGludGVycHJldCBgdmFsdWVgIGJ5LlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY29udmVydGVkIGludGVnZXIuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucGFyc2VJbnQoJzA4Jyk7XG4gICAgICogLy8gPT4gOFxuICAgICAqXG4gICAgICogXy5tYXAoWyc2JywgJzA4JywgJzEwJ10sIF8ucGFyc2VJbnQpO1xuICAgICAqIC8vID0+IFs2LCA4LCAxMF1cbiAgICAgKi9mdW5jdGlvbiBwYXJzZUludChzdHJpbmcscmFkaXgsZ3VhcmQpe2lmKGd1YXJkfHxyYWRpeD09bnVsbCl7cmFkaXg9MDt9ZWxzZSBpZihyYWRpeCl7cmFkaXg9K3JhZGl4O31yZXR1cm4gbmF0aXZlUGFyc2VJbnQodG9TdHJpbmcoc3RyaW5nKS5yZXBsYWNlKHJlVHJpbVN0YXJ0LCcnKSxyYWRpeHx8MCk7fS8qKlxuICAgICAqIFJlcGVhdHMgdGhlIGdpdmVuIHN0cmluZyBgbmAgdGltZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gcmVwZWF0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbj0xXSBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIHJlcGVhdCB0aGUgc3RyaW5nLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcmVwZWF0ZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnJlcGVhdCgnKicsIDMpO1xuICAgICAqIC8vID0+ICcqKionXG4gICAgICpcbiAgICAgKiBfLnJlcGVhdCgnYWJjJywgMik7XG4gICAgICogLy8gPT4gJ2FiY2FiYydcbiAgICAgKlxuICAgICAqIF8ucmVwZWF0KCdhYmMnLCAwKTtcbiAgICAgKiAvLyA9PiAnJ1xuICAgICAqL2Z1bmN0aW9uIHJlcGVhdChzdHJpbmcsbixndWFyZCl7aWYoZ3VhcmQ/aXNJdGVyYXRlZUNhbGwoc3RyaW5nLG4sZ3VhcmQpOm49PT11bmRlZmluZWQpe249MTt9ZWxzZXtuPXRvSW50ZWdlcihuKTt9cmV0dXJuIGJhc2VSZXBlYXQodG9TdHJpbmcoc3RyaW5nKSxuKTt9LyoqXG4gICAgICogUmVwbGFjZXMgbWF0Y2hlcyBmb3IgYHBhdHRlcm5gIGluIGBzdHJpbmdgIHdpdGggYHJlcGxhY2VtZW50YC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBiYXNlZCBvblxuICAgICAqIFtgU3RyaW5nI3JlcGxhY2VgXShodHRwczovL21kbi5pby9TdHJpbmcvcmVwbGFjZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7UmVnRXhwfHN0cmluZ30gcGF0dGVybiBUaGUgcGF0dGVybiB0byByZXBsYWNlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258c3RyaW5nfSByZXBsYWNlbWVudCBUaGUgbWF0Y2ggcmVwbGFjZW1lbnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgbW9kaWZpZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnJlcGxhY2UoJ0hpIEZyZWQnLCAnRnJlZCcsICdCYXJuZXknKTtcbiAgICAgKiAvLyA9PiAnSGkgQmFybmV5J1xuICAgICAqL2Z1bmN0aW9uIHJlcGxhY2UoKXt2YXIgYXJncz1hcmd1bWVudHMsc3RyaW5nPXRvU3RyaW5nKGFyZ3NbMF0pO3JldHVybiBhcmdzLmxlbmd0aDwzP3N0cmluZzpzdHJpbmcucmVwbGFjZShhcmdzWzFdLGFyZ3NbMl0pO30vKipcbiAgICAgKiBDb252ZXJ0cyBgc3RyaW5nYCB0b1xuICAgICAqIFtzbmFrZSBjYXNlXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TbmFrZV9jYXNlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHNuYWtlIGNhc2VkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zbmFrZUNhc2UoJ0ZvbyBCYXInKTtcbiAgICAgKiAvLyA9PiAnZm9vX2JhcidcbiAgICAgKlxuICAgICAqIF8uc25ha2VDYXNlKCdmb29CYXInKTtcbiAgICAgKiAvLyA9PiAnZm9vX2JhcidcbiAgICAgKlxuICAgICAqIF8uc25ha2VDYXNlKCctLUZPTy1CQVItLScpO1xuICAgICAqIC8vID0+ICdmb29fYmFyJ1xuICAgICAqL3ZhciBzbmFrZUNhc2U9Y3JlYXRlQ29tcG91bmRlcihmdW5jdGlvbihyZXN1bHQsd29yZCxpbmRleCl7cmV0dXJuIHJlc3VsdCsoaW5kZXg/J18nOicnKSt3b3JkLnRvTG93ZXJDYXNlKCk7fSk7LyoqXG4gICAgICogU3BsaXRzIGBzdHJpbmdgIGJ5IGBzZXBhcmF0b3JgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGJhc2VkIG9uXG4gICAgICogW2BTdHJpbmcjc3BsaXRgXShodHRwczovL21kbi5pby9TdHJpbmcvc3BsaXQpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIHNwbGl0LlxuICAgICAqIEBwYXJhbSB7UmVnRXhwfHN0cmluZ30gc2VwYXJhdG9yIFRoZSBzZXBhcmF0b3IgcGF0dGVybiB0byBzcGxpdCBieS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xpbWl0XSBUaGUgbGVuZ3RoIHRvIHRydW5jYXRlIHJlc3VsdHMgdG8uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzdHJpbmcgc2VnbWVudHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc3BsaXQoJ2EtYi1jJywgJy0nLCAyKTtcbiAgICAgKiAvLyA9PiBbJ2EnLCAnYiddXG4gICAgICovZnVuY3Rpb24gc3BsaXQoc3RyaW5nLHNlcGFyYXRvcixsaW1pdCl7aWYobGltaXQmJnR5cGVvZiBsaW1pdCE9J251bWJlcicmJmlzSXRlcmF0ZWVDYWxsKHN0cmluZyxzZXBhcmF0b3IsbGltaXQpKXtzZXBhcmF0b3I9bGltaXQ9dW5kZWZpbmVkO31saW1pdD1saW1pdD09PXVuZGVmaW5lZD9NQVhfQVJSQVlfTEVOR1RIOmxpbWl0Pj4+MDtpZighbGltaXQpe3JldHVybltdO31zdHJpbmc9dG9TdHJpbmcoc3RyaW5nKTtpZihzdHJpbmcmJih0eXBlb2Ygc2VwYXJhdG9yPT0nc3RyaW5nJ3x8c2VwYXJhdG9yIT1udWxsJiYhaXNSZWdFeHAoc2VwYXJhdG9yKSkpe3NlcGFyYXRvcj1iYXNlVG9TdHJpbmcoc2VwYXJhdG9yKTtpZighc2VwYXJhdG9yJiZoYXNVbmljb2RlKHN0cmluZykpe3JldHVybiBjYXN0U2xpY2Uoc3RyaW5nVG9BcnJheShzdHJpbmcpLDAsbGltaXQpO319cmV0dXJuIHN0cmluZy5zcGxpdChzZXBhcmF0b3IsbGltaXQpO30vKipcbiAgICAgKiBDb252ZXJ0cyBgc3RyaW5nYCB0b1xuICAgICAqIFtzdGFydCBjYXNlXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MZXR0ZXJfY2FzZSNTdHlsaXN0aWNfb3Jfc3BlY2lhbGlzZWRfdXNhZ2UpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMS4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc3RhcnQgY2FzZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnN0YXJ0Q2FzZSgnLS1mb28tYmFyLS0nKTtcbiAgICAgKiAvLyA9PiAnRm9vIEJhcidcbiAgICAgKlxuICAgICAqIF8uc3RhcnRDYXNlKCdmb29CYXInKTtcbiAgICAgKiAvLyA9PiAnRm9vIEJhcidcbiAgICAgKlxuICAgICAqIF8uc3RhcnRDYXNlKCdfX0ZPT19CQVJfXycpO1xuICAgICAqIC8vID0+ICdGT08gQkFSJ1xuICAgICAqL3ZhciBzdGFydENhc2U9Y3JlYXRlQ29tcG91bmRlcihmdW5jdGlvbihyZXN1bHQsd29yZCxpbmRleCl7cmV0dXJuIHJlc3VsdCsoaW5kZXg/JyAnOicnKSt1cHBlckZpcnN0KHdvcmQpO30pOy8qKlxuICAgICAqIENoZWNrcyBpZiBgc3RyaW5nYCBzdGFydHMgd2l0aCB0aGUgZ2l2ZW4gdGFyZ2V0IHN0cmluZy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbdGFyZ2V0XSBUaGUgc3RyaW5nIHRvIHNlYXJjaCBmb3IuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwb3NpdGlvbj0wXSBUaGUgcG9zaXRpb24gdG8gc2VhcmNoIGZyb20uXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBzdHJpbmdgIHN0YXJ0cyB3aXRoIGB0YXJnZXRgLFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc3RhcnRzV2l0aCgnYWJjJywgJ2EnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLnN0YXJ0c1dpdGgoJ2FiYycsICdiJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uc3RhcnRzV2l0aCgnYWJjJywgJ2InLCAxKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovZnVuY3Rpb24gc3RhcnRzV2l0aChzdHJpbmcsdGFyZ2V0LHBvc2l0aW9uKXtzdHJpbmc9dG9TdHJpbmcoc3RyaW5nKTtwb3NpdGlvbj1wb3NpdGlvbj09bnVsbD8wOmJhc2VDbGFtcCh0b0ludGVnZXIocG9zaXRpb24pLDAsc3RyaW5nLmxlbmd0aCk7dGFyZ2V0PWJhc2VUb1N0cmluZyh0YXJnZXQpO3JldHVybiBzdHJpbmcuc2xpY2UocG9zaXRpb24scG9zaXRpb24rdGFyZ2V0Lmxlbmd0aCk9PXRhcmdldDt9LyoqXG4gICAgICogQ3JlYXRlcyBhIGNvbXBpbGVkIHRlbXBsYXRlIGZ1bmN0aW9uIHRoYXQgY2FuIGludGVycG9sYXRlIGRhdGEgcHJvcGVydGllc1xuICAgICAqIGluIFwiaW50ZXJwb2xhdGVcIiBkZWxpbWl0ZXJzLCBIVE1MLWVzY2FwZSBpbnRlcnBvbGF0ZWQgZGF0YSBwcm9wZXJ0aWVzIGluXG4gICAgICogXCJlc2NhcGVcIiBkZWxpbWl0ZXJzLCBhbmQgZXhlY3V0ZSBKYXZhU2NyaXB0IGluIFwiZXZhbHVhdGVcIiBkZWxpbWl0ZXJzLiBEYXRhXG4gICAgICogcHJvcGVydGllcyBtYXkgYmUgYWNjZXNzZWQgYXMgZnJlZSB2YXJpYWJsZXMgaW4gdGhlIHRlbXBsYXRlLiBJZiBhIHNldHRpbmdcbiAgICAgKiBvYmplY3QgaXMgZ2l2ZW4sIGl0IHRha2VzIHByZWNlZGVuY2Ugb3ZlciBgXy50ZW1wbGF0ZVNldHRpbmdzYCB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogSW4gdGhlIGRldmVsb3BtZW50IGJ1aWxkIGBfLnRlbXBsYXRlYCB1dGlsaXplc1xuICAgICAqIFtzb3VyY2VVUkxzXShodHRwOi8vd3d3Lmh0bWw1cm9ja3MuY29tL2VuL3R1dG9yaWFscy9kZXZlbG9wZXJ0b29scy9zb3VyY2VtYXBzLyN0b2Mtc291cmNldXJsKVxuICAgICAqIGZvciBlYXNpZXIgZGVidWdnaW5nLlxuICAgICAqXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24gb24gcHJlY29tcGlsaW5nIHRlbXBsYXRlcyBzZWVcbiAgICAgKiBbbG9kYXNoJ3MgY3VzdG9tIGJ1aWxkcyBkb2N1bWVudGF0aW9uXShodHRwczovL2xvZGFzaC5jb20vY3VzdG9tLWJ1aWxkcykuXG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBDaHJvbWUgZXh0ZW5zaW9uIHNhbmRib3hlcyBzZWVcbiAgICAgKiBbQ2hyb21lJ3MgZXh0ZW5zaW9ucyBkb2N1bWVudGF0aW9uXShodHRwczovL2RldmVsb3Blci5jaHJvbWUuY29tL2V4dGVuc2lvbnMvc2FuZGJveGluZ0V2YWwpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgdGVtcGxhdGUgc3RyaW5nLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gVGhlIG9wdGlvbnMgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7UmVnRXhwfSBbb3B0aW9ucy5lc2NhcGU9Xy50ZW1wbGF0ZVNldHRpbmdzLmVzY2FwZV1cbiAgICAgKiAgVGhlIEhUTUwgXCJlc2NhcGVcIiBkZWxpbWl0ZXIuXG4gICAgICogQHBhcmFtIHtSZWdFeHB9IFtvcHRpb25zLmV2YWx1YXRlPV8udGVtcGxhdGVTZXR0aW5ncy5ldmFsdWF0ZV1cbiAgICAgKiAgVGhlIFwiZXZhbHVhdGVcIiBkZWxpbWl0ZXIuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmltcG9ydHM9Xy50ZW1wbGF0ZVNldHRpbmdzLmltcG9ydHNdXG4gICAgICogIEFuIG9iamVjdCB0byBpbXBvcnQgaW50byB0aGUgdGVtcGxhdGUgYXMgZnJlZSB2YXJpYWJsZXMuXG4gICAgICogQHBhcmFtIHtSZWdFeHB9IFtvcHRpb25zLmludGVycG9sYXRlPV8udGVtcGxhdGVTZXR0aW5ncy5pbnRlcnBvbGF0ZV1cbiAgICAgKiAgVGhlIFwiaW50ZXJwb2xhdGVcIiBkZWxpbWl0ZXIuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnNvdXJjZVVSTD0nbG9kYXNoLnRlbXBsYXRlU291cmNlc1tuXSddXG4gICAgICogIFRoZSBzb3VyY2VVUkwgb2YgdGhlIGNvbXBpbGVkIHRlbXBsYXRlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy52YXJpYWJsZT0nb2JqJ11cbiAgICAgKiAgVGhlIGRhdGEgb2JqZWN0IHZhcmlhYmxlIG5hbWUuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIGNvbXBpbGVkIHRlbXBsYXRlIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAvLyBVc2UgdGhlIFwiaW50ZXJwb2xhdGVcIiBkZWxpbWl0ZXIgdG8gY3JlYXRlIGEgY29tcGlsZWQgdGVtcGxhdGUuXG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnaGVsbG8gPCU9IHVzZXIgJT4hJyk7XG4gICAgICogY29tcGlsZWQoeyAndXNlcic6ICdmcmVkJyB9KTtcbiAgICAgKiAvLyA9PiAnaGVsbG8gZnJlZCEnXG4gICAgICpcbiAgICAgKiAvLyBVc2UgdGhlIEhUTUwgXCJlc2NhcGVcIiBkZWxpbWl0ZXIgdG8gZXNjYXBlIGRhdGEgcHJvcGVydHkgdmFsdWVzLlxuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJzxiPjwlLSB2YWx1ZSAlPjwvYj4nKTtcbiAgICAgKiBjb21waWxlZCh7ICd2YWx1ZSc6ICc8c2NyaXB0PicgfSk7XG4gICAgICogLy8gPT4gJzxiPiZsdDtzY3JpcHQmZ3Q7PC9iPidcbiAgICAgKlxuICAgICAqIC8vIFVzZSB0aGUgXCJldmFsdWF0ZVwiIGRlbGltaXRlciB0byBleGVjdXRlIEphdmFTY3JpcHQgYW5kIGdlbmVyYXRlIEhUTUwuXG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnPCUgXy5mb3JFYWNoKHVzZXJzLCBmdW5jdGlvbih1c2VyKSB7ICU+PGxpPjwlLSB1c2VyICU+PC9saT48JSB9KTsgJT4nKTtcbiAgICAgKiBjb21waWxlZCh7ICd1c2Vycyc6IFsnZnJlZCcsICdiYXJuZXknXSB9KTtcbiAgICAgKiAvLyA9PiAnPGxpPmZyZWQ8L2xpPjxsaT5iYXJuZXk8L2xpPidcbiAgICAgKlxuICAgICAqIC8vIFVzZSB0aGUgaW50ZXJuYWwgYHByaW50YCBmdW5jdGlvbiBpbiBcImV2YWx1YXRlXCIgZGVsaW1pdGVycy5cbiAgICAgKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCc8JSBwcmludChcImhlbGxvIFwiICsgdXNlcik7ICU+IScpO1xuICAgICAqIGNvbXBpbGVkKHsgJ3VzZXInOiAnYmFybmV5JyB9KTtcbiAgICAgKiAvLyA9PiAnaGVsbG8gYmFybmV5ISdcbiAgICAgKlxuICAgICAqIC8vIFVzZSB0aGUgRVMgdGVtcGxhdGUgbGl0ZXJhbCBkZWxpbWl0ZXIgYXMgYW4gXCJpbnRlcnBvbGF0ZVwiIGRlbGltaXRlci5cbiAgICAgKiAvLyBEaXNhYmxlIHN1cHBvcnQgYnkgcmVwbGFjaW5nIHRoZSBcImludGVycG9sYXRlXCIgZGVsaW1pdGVyLlxuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJ2hlbGxvICR7IHVzZXIgfSEnKTtcbiAgICAgKiBjb21waWxlZCh7ICd1c2VyJzogJ3BlYmJsZXMnIH0pO1xuICAgICAqIC8vID0+ICdoZWxsbyBwZWJibGVzISdcbiAgICAgKlxuICAgICAqIC8vIFVzZSBiYWNrc2xhc2hlcyB0byB0cmVhdCBkZWxpbWl0ZXJzIGFzIHBsYWluIHRleHQuXG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnPCU9IFwiXFxcXDwlLSB2YWx1ZSAlXFxcXD5cIiAlPicpO1xuICAgICAqIGNvbXBpbGVkKHsgJ3ZhbHVlJzogJ2lnbm9yZWQnIH0pO1xuICAgICAqIC8vID0+ICc8JS0gdmFsdWUgJT4nXG4gICAgICpcbiAgICAgKiAvLyBVc2UgdGhlIGBpbXBvcnRzYCBvcHRpb24gdG8gaW1wb3J0IGBqUXVlcnlgIGFzIGBqcWAuXG4gICAgICogdmFyIHRleHQgPSAnPCUganEuZWFjaCh1c2VycywgZnVuY3Rpb24odXNlcikgeyAlPjxsaT48JS0gdXNlciAlPjwvbGk+PCUgfSk7ICU+JztcbiAgICAgKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKHRleHQsIHsgJ2ltcG9ydHMnOiB7ICdqcSc6IGpRdWVyeSB9IH0pO1xuICAgICAqIGNvbXBpbGVkKHsgJ3VzZXJzJzogWydmcmVkJywgJ2Jhcm5leSddIH0pO1xuICAgICAqIC8vID0+ICc8bGk+ZnJlZDwvbGk+PGxpPmJhcm5leTwvbGk+J1xuICAgICAqXG4gICAgICogLy8gVXNlIHRoZSBgc291cmNlVVJMYCBvcHRpb24gdG8gc3BlY2lmeSBhIGN1c3RvbSBzb3VyY2VVUkwgZm9yIHRoZSB0ZW1wbGF0ZS5cbiAgICAgKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCdoZWxsbyA8JT0gdXNlciAlPiEnLCB7ICdzb3VyY2VVUkwnOiAnL2Jhc2ljL2dyZWV0aW5nLmpzdCcgfSk7XG4gICAgICogY29tcGlsZWQoZGF0YSk7XG4gICAgICogLy8gPT4gRmluZCB0aGUgc291cmNlIG9mIFwiZ3JlZXRpbmcuanN0XCIgdW5kZXIgdGhlIFNvdXJjZXMgdGFiIG9yIFJlc291cmNlcyBwYW5lbCBvZiB0aGUgd2ViIGluc3BlY3Rvci5cbiAgICAgKlxuICAgICAqIC8vIFVzZSB0aGUgYHZhcmlhYmxlYCBvcHRpb24gdG8gZW5zdXJlIGEgd2l0aC1zdGF0ZW1lbnQgaXNuJ3QgdXNlZCBpbiB0aGUgY29tcGlsZWQgdGVtcGxhdGUuXG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnaGkgPCU9IGRhdGEudXNlciAlPiEnLCB7ICd2YXJpYWJsZSc6ICdkYXRhJyB9KTtcbiAgICAgKiBjb21waWxlZC5zb3VyY2U7XG4gICAgICogLy8gPT4gZnVuY3Rpb24oZGF0YSkge1xuICAgICAqIC8vICAgdmFyIF9fdCwgX19wID0gJyc7XG4gICAgICogLy8gICBfX3AgKz0gJ2hpICcgKyAoKF9fdCA9ICggZGF0YS51c2VyICkpID09IG51bGwgPyAnJyA6IF9fdCkgKyAnISc7XG4gICAgICogLy8gICByZXR1cm4gX19wO1xuICAgICAqIC8vIH1cbiAgICAgKlxuICAgICAqIC8vIFVzZSBjdXN0b20gdGVtcGxhdGUgZGVsaW1pdGVycy5cbiAgICAgKiBfLnRlbXBsYXRlU2V0dGluZ3MuaW50ZXJwb2xhdGUgPSAve3soW1xcc1xcU10rPyl9fS9nO1xuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJ2hlbGxvIHt7IHVzZXIgfX0hJyk7XG4gICAgICogY29tcGlsZWQoeyAndXNlcic6ICdtdXN0YWNoZScgfSk7XG4gICAgICogLy8gPT4gJ2hlbGxvIG11c3RhY2hlISdcbiAgICAgKlxuICAgICAqIC8vIFVzZSB0aGUgYHNvdXJjZWAgcHJvcGVydHkgdG8gaW5saW5lIGNvbXBpbGVkIHRlbXBsYXRlcyBmb3IgbWVhbmluZ2Z1bFxuICAgICAqIC8vIGxpbmUgbnVtYmVycyBpbiBlcnJvciBtZXNzYWdlcyBhbmQgc3RhY2sgdHJhY2VzLlxuICAgICAqIGZzLndyaXRlRmlsZVN5bmMocGF0aC5qb2luKHByb2Nlc3MuY3dkKCksICdqc3QuanMnKSwgJ1xcXG4gICAgICogICB2YXIgSlNUID0ge1xcXG4gICAgICogICAgIFwibWFpblwiOiAnICsgXy50ZW1wbGF0ZShtYWluVGV4dCkuc291cmNlICsgJ1xcXG4gICAgICogICB9O1xcXG4gICAgICogJyk7XG4gICAgICovZnVuY3Rpb24gdGVtcGxhdGUoc3RyaW5nLG9wdGlvbnMsZ3VhcmQpey8vIEJhc2VkIG9uIEpvaG4gUmVzaWcncyBgdG1wbGAgaW1wbGVtZW50YXRpb25cbi8vIChodHRwOi8vZWpvaG4ub3JnL2Jsb2cvamF2YXNjcmlwdC1taWNyby10ZW1wbGF0aW5nLylcbi8vIGFuZCBMYXVyYSBEb2t0b3JvdmEncyBkb1QuanMgKGh0dHBzOi8vZ2l0aHViLmNvbS9vbGFkby9kb1QpLlxudmFyIHNldHRpbmdzPWxvZGFzaC50ZW1wbGF0ZVNldHRpbmdzO2lmKGd1YXJkJiZpc0l0ZXJhdGVlQ2FsbChzdHJpbmcsb3B0aW9ucyxndWFyZCkpe29wdGlvbnM9dW5kZWZpbmVkO31zdHJpbmc9dG9TdHJpbmcoc3RyaW5nKTtvcHRpb25zPWFzc2lnbkluV2l0aCh7fSxvcHRpb25zLHNldHRpbmdzLGN1c3RvbURlZmF1bHRzQXNzaWduSW4pO3ZhciBpbXBvcnRzPWFzc2lnbkluV2l0aCh7fSxvcHRpb25zLmltcG9ydHMsc2V0dGluZ3MuaW1wb3J0cyxjdXN0b21EZWZhdWx0c0Fzc2lnbkluKSxpbXBvcnRzS2V5cz1rZXlzKGltcG9ydHMpLGltcG9ydHNWYWx1ZXM9YmFzZVZhbHVlcyhpbXBvcnRzLGltcG9ydHNLZXlzKTt2YXIgaXNFc2NhcGluZyxpc0V2YWx1YXRpbmcsaW5kZXg9MCxpbnRlcnBvbGF0ZT1vcHRpb25zLmludGVycG9sYXRlfHxyZU5vTWF0Y2gsc291cmNlPVwiX19wICs9ICdcIjsvLyBDb21waWxlIHRoZSByZWdleHAgdG8gbWF0Y2ggZWFjaCBkZWxpbWl0ZXIuXG52YXIgcmVEZWxpbWl0ZXJzPVJlZ0V4cCgob3B0aW9ucy5lc2NhcGV8fHJlTm9NYXRjaCkuc291cmNlKyd8JytpbnRlcnBvbGF0ZS5zb3VyY2UrJ3wnKyhpbnRlcnBvbGF0ZT09PXJlSW50ZXJwb2xhdGU/cmVFc1RlbXBsYXRlOnJlTm9NYXRjaCkuc291cmNlKyd8Jysob3B0aW9ucy5ldmFsdWF0ZXx8cmVOb01hdGNoKS5zb3VyY2UrJ3wkJywnZycpOy8vIFVzZSBhIHNvdXJjZVVSTCBmb3IgZWFzaWVyIGRlYnVnZ2luZy5cbnZhciBzb3VyY2VVUkw9Jy8vIyBzb3VyY2VVUkw9JysoJ3NvdXJjZVVSTCdpbiBvcHRpb25zP29wdGlvbnMuc291cmNlVVJMOidsb2Rhc2gudGVtcGxhdGVTb3VyY2VzWycrICsrdGVtcGxhdGVDb3VudGVyKyddJykrJ1xcbic7c3RyaW5nLnJlcGxhY2UocmVEZWxpbWl0ZXJzLGZ1bmN0aW9uKG1hdGNoLGVzY2FwZVZhbHVlLGludGVycG9sYXRlVmFsdWUsZXNUZW1wbGF0ZVZhbHVlLGV2YWx1YXRlVmFsdWUsb2Zmc2V0KXtpbnRlcnBvbGF0ZVZhbHVlfHwoaW50ZXJwb2xhdGVWYWx1ZT1lc1RlbXBsYXRlVmFsdWUpOy8vIEVzY2FwZSBjaGFyYWN0ZXJzIHRoYXQgY2FuJ3QgYmUgaW5jbHVkZWQgaW4gc3RyaW5nIGxpdGVyYWxzLlxuc291cmNlKz1zdHJpbmcuc2xpY2UoaW5kZXgsb2Zmc2V0KS5yZXBsYWNlKHJlVW5lc2NhcGVkU3RyaW5nLGVzY2FwZVN0cmluZ0NoYXIpOy8vIFJlcGxhY2UgZGVsaW1pdGVycyB3aXRoIHNuaXBwZXRzLlxuaWYoZXNjYXBlVmFsdWUpe2lzRXNjYXBpbmc9dHJ1ZTtzb3VyY2UrPVwiJyArXFxuX19lKFwiK2VzY2FwZVZhbHVlK1wiKSArXFxuJ1wiO31pZihldmFsdWF0ZVZhbHVlKXtpc0V2YWx1YXRpbmc9dHJ1ZTtzb3VyY2UrPVwiJztcXG5cIitldmFsdWF0ZVZhbHVlK1wiO1xcbl9fcCArPSAnXCI7fWlmKGludGVycG9sYXRlVmFsdWUpe3NvdXJjZSs9XCInICtcXG4oKF9fdCA9IChcIitpbnRlcnBvbGF0ZVZhbHVlK1wiKSkgPT0gbnVsbCA/ICcnIDogX190KSArXFxuJ1wiO31pbmRleD1vZmZzZXQrbWF0Y2gubGVuZ3RoOy8vIFRoZSBKUyBlbmdpbmUgZW1iZWRkZWQgaW4gQWRvYmUgcHJvZHVjdHMgbmVlZHMgYG1hdGNoYCByZXR1cm5lZCBpblxuLy8gb3JkZXIgdG8gcHJvZHVjZSB0aGUgY29ycmVjdCBgb2Zmc2V0YCB2YWx1ZS5cbnJldHVybiBtYXRjaDt9KTtzb3VyY2UrPVwiJztcXG5cIjsvLyBJZiBgdmFyaWFibGVgIGlzIG5vdCBzcGVjaWZpZWQgd3JhcCBhIHdpdGgtc3RhdGVtZW50IGFyb3VuZCB0aGUgZ2VuZXJhdGVkXG4vLyBjb2RlIHRvIGFkZCB0aGUgZGF0YSBvYmplY3QgdG8gdGhlIHRvcCBvZiB0aGUgc2NvcGUgY2hhaW4uXG52YXIgdmFyaWFibGU9b3B0aW9ucy52YXJpYWJsZTtpZighdmFyaWFibGUpe3NvdXJjZT0nd2l0aCAob2JqKSB7XFxuJytzb3VyY2UrJ1xcbn1cXG4nO30vLyBDbGVhbnVwIGNvZGUgYnkgc3RyaXBwaW5nIGVtcHR5IHN0cmluZ3MuXG5zb3VyY2U9KGlzRXZhbHVhdGluZz9zb3VyY2UucmVwbGFjZShyZUVtcHR5U3RyaW5nTGVhZGluZywnJyk6c291cmNlKS5yZXBsYWNlKHJlRW1wdHlTdHJpbmdNaWRkbGUsJyQxJykucmVwbGFjZShyZUVtcHR5U3RyaW5nVHJhaWxpbmcsJyQxOycpOy8vIEZyYW1lIGNvZGUgYXMgdGhlIGZ1bmN0aW9uIGJvZHkuXG5zb3VyY2U9J2Z1bmN0aW9uKCcrKHZhcmlhYmxlfHwnb2JqJykrJykge1xcbicrKHZhcmlhYmxlPycnOidvYmogfHwgKG9iaiA9IHt9KTtcXG4nKStcInZhciBfX3QsIF9fcCA9ICcnXCIrKGlzRXNjYXBpbmc/JywgX19lID0gXy5lc2NhcGUnOicnKSsoaXNFdmFsdWF0aW5nPycsIF9faiA9IEFycmF5LnByb3RvdHlwZS5qb2luO1xcbicrXCJmdW5jdGlvbiBwcmludCgpIHsgX19wICs9IF9fai5jYWxsKGFyZ3VtZW50cywgJycpIH1cXG5cIjonO1xcbicpK3NvdXJjZSsncmV0dXJuIF9fcFxcbn0nO3ZhciByZXN1bHQ9YXR0ZW1wdChmdW5jdGlvbigpe3JldHVybiBGdW5jdGlvbihpbXBvcnRzS2V5cyxzb3VyY2VVUkwrJ3JldHVybiAnK3NvdXJjZSkuYXBwbHkodW5kZWZpbmVkLGltcG9ydHNWYWx1ZXMpO30pOy8vIFByb3ZpZGUgdGhlIGNvbXBpbGVkIGZ1bmN0aW9uJ3Mgc291cmNlIGJ5IGl0cyBgdG9TdHJpbmdgIG1ldGhvZCBvclxuLy8gdGhlIGBzb3VyY2VgIHByb3BlcnR5IGFzIGEgY29udmVuaWVuY2UgZm9yIGlubGluaW5nIGNvbXBpbGVkIHRlbXBsYXRlcy5cbnJlc3VsdC5zb3VyY2U9c291cmNlO2lmKGlzRXJyb3IocmVzdWx0KSl7dGhyb3cgcmVzdWx0O31yZXR1cm4gcmVzdWx0O30vKipcbiAgICAgKiBDb252ZXJ0cyBgc3RyaW5nYCwgYXMgYSB3aG9sZSwgdG8gbG93ZXIgY2FzZSBqdXN0IGxpa2VcbiAgICAgKiBbU3RyaW5nI3RvTG93ZXJDYXNlXShodHRwczovL21kbi5pby90b0xvd2VyQ2FzZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBsb3dlciBjYXNlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udG9Mb3dlcignLS1Gb28tQmFyLS0nKTtcbiAgICAgKiAvLyA9PiAnLS1mb28tYmFyLS0nXG4gICAgICpcbiAgICAgKiBfLnRvTG93ZXIoJ2Zvb0JhcicpO1xuICAgICAqIC8vID0+ICdmb29iYXInXG4gICAgICpcbiAgICAgKiBfLnRvTG93ZXIoJ19fRk9PX0JBUl9fJyk7XG4gICAgICogLy8gPT4gJ19fZm9vX2Jhcl9fJ1xuICAgICAqL2Z1bmN0aW9uIHRvTG93ZXIodmFsdWUpe3JldHVybiB0b1N0cmluZyh2YWx1ZSkudG9Mb3dlckNhc2UoKTt9LyoqXG4gICAgICogQ29udmVydHMgYHN0cmluZ2AsIGFzIGEgd2hvbGUsIHRvIHVwcGVyIGNhc2UganVzdCBsaWtlXG4gICAgICogW1N0cmluZyN0b1VwcGVyQ2FzZV0oaHR0cHM6Ly9tZG4uaW8vdG9VcHBlckNhc2UpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdXBwZXIgY2FzZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRvVXBwZXIoJy0tZm9vLWJhci0tJyk7XG4gICAgICogLy8gPT4gJy0tRk9PLUJBUi0tJ1xuICAgICAqXG4gICAgICogXy50b1VwcGVyKCdmb29CYXInKTtcbiAgICAgKiAvLyA9PiAnRk9PQkFSJ1xuICAgICAqXG4gICAgICogXy50b1VwcGVyKCdfX2Zvb19iYXJfXycpO1xuICAgICAqIC8vID0+ICdfX0ZPT19CQVJfXydcbiAgICAgKi9mdW5jdGlvbiB0b1VwcGVyKHZhbHVlKXtyZXR1cm4gdG9TdHJpbmcodmFsdWUpLnRvVXBwZXJDYXNlKCk7fS8qKlxuICAgICAqIFJlbW92ZXMgbGVhZGluZyBhbmQgdHJhaWxpbmcgd2hpdGVzcGFjZSBvciBzcGVjaWZpZWQgY2hhcmFjdGVycyBmcm9tIGBzdHJpbmdgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIHRyaW0uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtjaGFycz13aGl0ZXNwYWNlXSBUaGUgY2hhcmFjdGVycyB0byB0cmltLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdHJpbW1lZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udHJpbSgnICBhYmMgICcpO1xuICAgICAqIC8vID0+ICdhYmMnXG4gICAgICpcbiAgICAgKiBfLnRyaW0oJy1fLWFiYy1fLScsICdfLScpO1xuICAgICAqIC8vID0+ICdhYmMnXG4gICAgICpcbiAgICAgKiBfLm1hcChbJyAgZm9vICAnLCAnICBiYXIgICddLCBfLnRyaW0pO1xuICAgICAqIC8vID0+IFsnZm9vJywgJ2JhciddXG4gICAgICovZnVuY3Rpb24gdHJpbShzdHJpbmcsY2hhcnMsZ3VhcmQpe3N0cmluZz10b1N0cmluZyhzdHJpbmcpO2lmKHN0cmluZyYmKGd1YXJkfHxjaGFycz09PXVuZGVmaW5lZCkpe3JldHVybiBzdHJpbmcucmVwbGFjZShyZVRyaW0sJycpO31pZighc3RyaW5nfHwhKGNoYXJzPWJhc2VUb1N0cmluZyhjaGFycykpKXtyZXR1cm4gc3RyaW5nO312YXIgc3RyU3ltYm9scz1zdHJpbmdUb0FycmF5KHN0cmluZyksY2hyU3ltYm9scz1zdHJpbmdUb0FycmF5KGNoYXJzKSxzdGFydD1jaGFyc1N0YXJ0SW5kZXgoc3RyU3ltYm9scyxjaHJTeW1ib2xzKSxlbmQ9Y2hhcnNFbmRJbmRleChzdHJTeW1ib2xzLGNoclN5bWJvbHMpKzE7cmV0dXJuIGNhc3RTbGljZShzdHJTeW1ib2xzLHN0YXJ0LGVuZCkuam9pbignJyk7fS8qKlxuICAgICAqIFJlbW92ZXMgdHJhaWxpbmcgd2hpdGVzcGFjZSBvciBzcGVjaWZpZWQgY2hhcmFjdGVycyBmcm9tIGBzdHJpbmdgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIHRyaW0uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtjaGFycz13aGl0ZXNwYWNlXSBUaGUgY2hhcmFjdGVycyB0byB0cmltLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdHJpbW1lZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udHJpbUVuZCgnICBhYmMgICcpO1xuICAgICAqIC8vID0+ICcgIGFiYydcbiAgICAgKlxuICAgICAqIF8udHJpbUVuZCgnLV8tYWJjLV8tJywgJ18tJyk7XG4gICAgICogLy8gPT4gJy1fLWFiYydcbiAgICAgKi9mdW5jdGlvbiB0cmltRW5kKHN0cmluZyxjaGFycyxndWFyZCl7c3RyaW5nPXRvU3RyaW5nKHN0cmluZyk7aWYoc3RyaW5nJiYoZ3VhcmR8fGNoYXJzPT09dW5kZWZpbmVkKSl7cmV0dXJuIHN0cmluZy5yZXBsYWNlKHJlVHJpbUVuZCwnJyk7fWlmKCFzdHJpbmd8fCEoY2hhcnM9YmFzZVRvU3RyaW5nKGNoYXJzKSkpe3JldHVybiBzdHJpbmc7fXZhciBzdHJTeW1ib2xzPXN0cmluZ1RvQXJyYXkoc3RyaW5nKSxlbmQ9Y2hhcnNFbmRJbmRleChzdHJTeW1ib2xzLHN0cmluZ1RvQXJyYXkoY2hhcnMpKSsxO3JldHVybiBjYXN0U2xpY2Uoc3RyU3ltYm9scywwLGVuZCkuam9pbignJyk7fS8qKlxuICAgICAqIFJlbW92ZXMgbGVhZGluZyB3aGl0ZXNwYWNlIG9yIHNwZWNpZmllZCBjaGFyYWN0ZXJzIGZyb20gYHN0cmluZ2AuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gdHJpbS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2NoYXJzPXdoaXRlc3BhY2VdIFRoZSBjaGFyYWN0ZXJzIHRvIHRyaW0uXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB0cmltbWVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50cmltU3RhcnQoJyAgYWJjICAnKTtcbiAgICAgKiAvLyA9PiAnYWJjICAnXG4gICAgICpcbiAgICAgKiBfLnRyaW1TdGFydCgnLV8tYWJjLV8tJywgJ18tJyk7XG4gICAgICogLy8gPT4gJ2FiYy1fLSdcbiAgICAgKi9mdW5jdGlvbiB0cmltU3RhcnQoc3RyaW5nLGNoYXJzLGd1YXJkKXtzdHJpbmc9dG9TdHJpbmcoc3RyaW5nKTtpZihzdHJpbmcmJihndWFyZHx8Y2hhcnM9PT11bmRlZmluZWQpKXtyZXR1cm4gc3RyaW5nLnJlcGxhY2UocmVUcmltU3RhcnQsJycpO31pZighc3RyaW5nfHwhKGNoYXJzPWJhc2VUb1N0cmluZyhjaGFycykpKXtyZXR1cm4gc3RyaW5nO312YXIgc3RyU3ltYm9scz1zdHJpbmdUb0FycmF5KHN0cmluZyksc3RhcnQ9Y2hhcnNTdGFydEluZGV4KHN0clN5bWJvbHMsc3RyaW5nVG9BcnJheShjaGFycykpO3JldHVybiBjYXN0U2xpY2Uoc3RyU3ltYm9scyxzdGFydCkuam9pbignJyk7fS8qKlxuICAgICAqIFRydW5jYXRlcyBgc3RyaW5nYCBpZiBpdCdzIGxvbmdlciB0aGFuIHRoZSBnaXZlbiBtYXhpbXVtIHN0cmluZyBsZW5ndGguXG4gICAgICogVGhlIGxhc3QgY2hhcmFjdGVycyBvZiB0aGUgdHJ1bmNhdGVkIHN0cmluZyBhcmUgcmVwbGFjZWQgd2l0aCB0aGUgb21pc3Npb25cbiAgICAgKiBzdHJpbmcgd2hpY2ggZGVmYXVsdHMgdG8gXCIuLi5cIi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byB0cnVuY2F0ZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIFRoZSBvcHRpb25zIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubGVuZ3RoPTMwXSBUaGUgbWF4aW11bSBzdHJpbmcgbGVuZ3RoLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5vbWlzc2lvbj0nLi4uJ10gVGhlIHN0cmluZyB0byBpbmRpY2F0ZSB0ZXh0IGlzIG9taXR0ZWQuXG4gICAgICogQHBhcmFtIHtSZWdFeHB8c3RyaW5nfSBbb3B0aW9ucy5zZXBhcmF0b3JdIFRoZSBzZXBhcmF0b3IgcGF0dGVybiB0byB0cnVuY2F0ZSB0by5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB0cnVuY2F0ZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRydW5jYXRlKCdoaS1kaWRkbHktaG8gdGhlcmUsIG5laWdoYm9yaW5vJyk7XG4gICAgICogLy8gPT4gJ2hpLWRpZGRseS1obyB0aGVyZSwgbmVpZ2hiby4uLidcbiAgICAgKlxuICAgICAqIF8udHJ1bmNhdGUoJ2hpLWRpZGRseS1obyB0aGVyZSwgbmVpZ2hib3Jpbm8nLCB7XG4gICAgICogICAnbGVuZ3RoJzogMjQsXG4gICAgICogICAnc2VwYXJhdG9yJzogJyAnXG4gICAgICogfSk7XG4gICAgICogLy8gPT4gJ2hpLWRpZGRseS1obyB0aGVyZSwuLi4nXG4gICAgICpcbiAgICAgKiBfLnRydW5jYXRlKCdoaS1kaWRkbHktaG8gdGhlcmUsIG5laWdoYm9yaW5vJywge1xuICAgICAqICAgJ2xlbmd0aCc6IDI0LFxuICAgICAqICAgJ3NlcGFyYXRvcic6IC8sPyArL1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+ICdoaS1kaWRkbHktaG8gdGhlcmUuLi4nXG4gICAgICpcbiAgICAgKiBfLnRydW5jYXRlKCdoaS1kaWRkbHktaG8gdGhlcmUsIG5laWdoYm9yaW5vJywge1xuICAgICAqICAgJ29taXNzaW9uJzogJyBbLi4uXSdcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiAnaGktZGlkZGx5LWhvIHRoZXJlLCBuZWlnIFsuLi5dJ1xuICAgICAqL2Z1bmN0aW9uIHRydW5jYXRlKHN0cmluZyxvcHRpb25zKXt2YXIgbGVuZ3RoPURFRkFVTFRfVFJVTkNfTEVOR1RILG9taXNzaW9uPURFRkFVTFRfVFJVTkNfT01JU1NJT047aWYoaXNPYmplY3Qob3B0aW9ucykpe3ZhciBzZXBhcmF0b3I9J3NlcGFyYXRvcidpbiBvcHRpb25zP29wdGlvbnMuc2VwYXJhdG9yOnNlcGFyYXRvcjtsZW5ndGg9J2xlbmd0aCdpbiBvcHRpb25zP3RvSW50ZWdlcihvcHRpb25zLmxlbmd0aCk6bGVuZ3RoO29taXNzaW9uPSdvbWlzc2lvbidpbiBvcHRpb25zP2Jhc2VUb1N0cmluZyhvcHRpb25zLm9taXNzaW9uKTpvbWlzc2lvbjt9c3RyaW5nPXRvU3RyaW5nKHN0cmluZyk7dmFyIHN0ckxlbmd0aD1zdHJpbmcubGVuZ3RoO2lmKGhhc1VuaWNvZGUoc3RyaW5nKSl7dmFyIHN0clN5bWJvbHM9c3RyaW5nVG9BcnJheShzdHJpbmcpO3N0ckxlbmd0aD1zdHJTeW1ib2xzLmxlbmd0aDt9aWYobGVuZ3RoPj1zdHJMZW5ndGgpe3JldHVybiBzdHJpbmc7fXZhciBlbmQ9bGVuZ3RoLXN0cmluZ1NpemUob21pc3Npb24pO2lmKGVuZDwxKXtyZXR1cm4gb21pc3Npb247fXZhciByZXN1bHQ9c3RyU3ltYm9scz9jYXN0U2xpY2Uoc3RyU3ltYm9scywwLGVuZCkuam9pbignJyk6c3RyaW5nLnNsaWNlKDAsZW5kKTtpZihzZXBhcmF0b3I9PT11bmRlZmluZWQpe3JldHVybiByZXN1bHQrb21pc3Npb247fWlmKHN0clN5bWJvbHMpe2VuZCs9cmVzdWx0Lmxlbmd0aC1lbmQ7fWlmKGlzUmVnRXhwKHNlcGFyYXRvcikpe2lmKHN0cmluZy5zbGljZShlbmQpLnNlYXJjaChzZXBhcmF0b3IpKXt2YXIgbWF0Y2gsc3Vic3RyaW5nPXJlc3VsdDtpZighc2VwYXJhdG9yLmdsb2JhbCl7c2VwYXJhdG9yPVJlZ0V4cChzZXBhcmF0b3Iuc291cmNlLHRvU3RyaW5nKHJlRmxhZ3MuZXhlYyhzZXBhcmF0b3IpKSsnZycpO31zZXBhcmF0b3IubGFzdEluZGV4PTA7d2hpbGUobWF0Y2g9c2VwYXJhdG9yLmV4ZWMoc3Vic3RyaW5nKSl7dmFyIG5ld0VuZD1tYXRjaC5pbmRleDt9cmVzdWx0PXJlc3VsdC5zbGljZSgwLG5ld0VuZD09PXVuZGVmaW5lZD9lbmQ6bmV3RW5kKTt9fWVsc2UgaWYoc3RyaW5nLmluZGV4T2YoYmFzZVRvU3RyaW5nKHNlcGFyYXRvciksZW5kKSE9ZW5kKXt2YXIgaW5kZXg9cmVzdWx0Lmxhc3RJbmRleE9mKHNlcGFyYXRvcik7aWYoaW5kZXg+LTEpe3Jlc3VsdD1yZXN1bHQuc2xpY2UoMCxpbmRleCk7fX1yZXR1cm4gcmVzdWx0K29taXNzaW9uO30vKipcbiAgICAgKiBUaGUgaW52ZXJzZSBvZiBgXy5lc2NhcGVgOyB0aGlzIG1ldGhvZCBjb252ZXJ0cyB0aGUgSFRNTCBlbnRpdGllc1xuICAgICAqIGAmYW1wO2AsIGAmbHQ7YCwgYCZndDtgLCBgJnF1b3Q7YCwgYW5kIGAmIzM5O2AgaW4gYHN0cmluZ2AgdG9cbiAgICAgKiB0aGVpciBjb3JyZXNwb25kaW5nIGNoYXJhY3RlcnMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogTm8gb3RoZXIgSFRNTCBlbnRpdGllcyBhcmUgdW5lc2NhcGVkLiBUbyB1bmVzY2FwZSBhZGRpdGlvbmFsXG4gICAgICogSFRNTCBlbnRpdGllcyB1c2UgYSB0aGlyZC1wYXJ0eSBsaWJyYXJ5IGxpa2UgW19oZV9dKGh0dHBzOi8vbXRocy5iZS9oZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC42LjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gdW5lc2NhcGUuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdW5lc2NhcGVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy51bmVzY2FwZSgnZnJlZCwgYmFybmV5LCAmYW1wOyBwZWJibGVzJyk7XG4gICAgICogLy8gPT4gJ2ZyZWQsIGJhcm5leSwgJiBwZWJibGVzJ1xuICAgICAqL2Z1bmN0aW9uIHVuZXNjYXBlKHN0cmluZyl7c3RyaW5nPXRvU3RyaW5nKHN0cmluZyk7cmV0dXJuIHN0cmluZyYmcmVIYXNFc2NhcGVkSHRtbC50ZXN0KHN0cmluZyk/c3RyaW5nLnJlcGxhY2UocmVFc2NhcGVkSHRtbCx1bmVzY2FwZUh0bWxDaGFyKTpzdHJpbmc7fS8qKlxuICAgICAqIENvbnZlcnRzIGBzdHJpbmdgLCBhcyBzcGFjZSBzZXBhcmF0ZWQgd29yZHMsIHRvIHVwcGVyIGNhc2UuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB1cHBlciBjYXNlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udXBwZXJDYXNlKCctLWZvby1iYXInKTtcbiAgICAgKiAvLyA9PiAnRk9PIEJBUidcbiAgICAgKlxuICAgICAqIF8udXBwZXJDYXNlKCdmb29CYXInKTtcbiAgICAgKiAvLyA9PiAnRk9PIEJBUidcbiAgICAgKlxuICAgICAqIF8udXBwZXJDYXNlKCdfX2Zvb19iYXJfXycpO1xuICAgICAqIC8vID0+ICdGT08gQkFSJ1xuICAgICAqL3ZhciB1cHBlckNhc2U9Y3JlYXRlQ29tcG91bmRlcihmdW5jdGlvbihyZXN1bHQsd29yZCxpbmRleCl7cmV0dXJuIHJlc3VsdCsoaW5kZXg/JyAnOicnKSt3b3JkLnRvVXBwZXJDYXNlKCk7fSk7LyoqXG4gICAgICogQ29udmVydHMgdGhlIGZpcnN0IGNoYXJhY3RlciBvZiBgc3RyaW5nYCB0byB1cHBlciBjYXNlLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy51cHBlckZpcnN0KCdmcmVkJyk7XG4gICAgICogLy8gPT4gJ0ZyZWQnXG4gICAgICpcbiAgICAgKiBfLnVwcGVyRmlyc3QoJ0ZSRUQnKTtcbiAgICAgKiAvLyA9PiAnRlJFRCdcbiAgICAgKi92YXIgdXBwZXJGaXJzdD1jcmVhdGVDYXNlRmlyc3QoJ3RvVXBwZXJDYXNlJyk7LyoqXG4gICAgICogU3BsaXRzIGBzdHJpbmdgIGludG8gYW4gYXJyYXkgb2YgaXRzIHdvcmRzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtSZWdFeHB8c3RyaW5nfSBbcGF0dGVybl0gVGhlIHBhdHRlcm4gdG8gbWF0Y2ggd29yZHMuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHdvcmRzIG9mIGBzdHJpbmdgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLndvcmRzKCdmcmVkLCBiYXJuZXksICYgcGViYmxlcycpO1xuICAgICAqIC8vID0+IFsnZnJlZCcsICdiYXJuZXknLCAncGViYmxlcyddXG4gICAgICpcbiAgICAgKiBfLndvcmRzKCdmcmVkLCBiYXJuZXksICYgcGViYmxlcycsIC9bXiwgXSsvZyk7XG4gICAgICogLy8gPT4gWydmcmVkJywgJ2Jhcm5leScsICcmJywgJ3BlYmJsZXMnXVxuICAgICAqL2Z1bmN0aW9uIHdvcmRzKHN0cmluZyxwYXR0ZXJuLGd1YXJkKXtzdHJpbmc9dG9TdHJpbmcoc3RyaW5nKTtwYXR0ZXJuPWd1YXJkP3VuZGVmaW5lZDpwYXR0ZXJuO2lmKHBhdHRlcm49PT11bmRlZmluZWQpe3JldHVybiBoYXNVbmljb2RlV29yZChzdHJpbmcpP3VuaWNvZGVXb3JkcyhzdHJpbmcpOmFzY2lpV29yZHMoc3RyaW5nKTt9cmV0dXJuIHN0cmluZy5tYXRjaChwYXR0ZXJuKXx8W107fS8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi8vKipcbiAgICAgKiBBdHRlbXB0cyB0byBpbnZva2UgYGZ1bmNgLCByZXR1cm5pbmcgZWl0aGVyIHRoZSByZXN1bHQgb3IgdGhlIGNhdWdodCBlcnJvclxuICAgICAqIG9iamVjdC4gQW55IGFkZGl0aW9uYWwgYXJndW1lbnRzIGFyZSBwcm92aWRlZCB0byBgZnVuY2Agd2hlbiBpdCdzIGludm9rZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGF0dGVtcHQuXG4gICAgICogQHBhcmFtIHsuLi4qfSBbYXJnc10gVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgYGZ1bmNgIHdpdGguXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGBmdW5jYCByZXN1bHQgb3IgZXJyb3Igb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAvLyBBdm9pZCB0aHJvd2luZyBlcnJvcnMgZm9yIGludmFsaWQgc2VsZWN0b3JzLlxuICAgICAqIHZhciBlbGVtZW50cyA9IF8uYXR0ZW1wdChmdW5jdGlvbihzZWxlY3Rvcikge1xuICAgICAqICAgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpO1xuICAgICAqIH0sICc+Xz4nKTtcbiAgICAgKlxuICAgICAqIGlmIChfLmlzRXJyb3IoZWxlbWVudHMpKSB7XG4gICAgICogICBlbGVtZW50cyA9IFtdO1xuICAgICAqIH1cbiAgICAgKi92YXIgYXR0ZW1wdD1iYXNlUmVzdChmdW5jdGlvbihmdW5jLGFyZ3Mpe3RyeXtyZXR1cm4gYXBwbHkoZnVuYyx1bmRlZmluZWQsYXJncyk7fWNhdGNoKGUpe3JldHVybiBpc0Vycm9yKGUpP2U6bmV3IEVycm9yKGUpO319KTsvKipcbiAgICAgKiBCaW5kcyBtZXRob2RzIG9mIGFuIG9iamVjdCB0byB0aGUgb2JqZWN0IGl0c2VsZiwgb3ZlcndyaXRpbmcgdGhlIGV4aXN0aW5nXG4gICAgICogbWV0aG9kLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGRvZXNuJ3Qgc2V0IHRoZSBcImxlbmd0aFwiIHByb3BlcnR5IG9mIGJvdW5kIGZ1bmN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGJpbmQgYW5kIGFzc2lnbiB0aGUgYm91bmQgbWV0aG9kcyB0by5cbiAgICAgKiBAcGFyYW0gey4uLihzdHJpbmd8c3RyaW5nW10pfSBtZXRob2ROYW1lcyBUaGUgb2JqZWN0IG1ldGhvZCBuYW1lcyB0byBiaW5kLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB2aWV3ID0ge1xuICAgICAqICAgJ2xhYmVsJzogJ2RvY3MnLFxuICAgICAqICAgJ2NsaWNrJzogZnVuY3Rpb24oKSB7XG4gICAgICogICAgIGNvbnNvbGUubG9nKCdjbGlja2VkICcgKyB0aGlzLmxhYmVsKTtcbiAgICAgKiAgIH1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogXy5iaW5kQWxsKHZpZXcsIFsnY2xpY2snXSk7XG4gICAgICogalF1ZXJ5KGVsZW1lbnQpLm9uKCdjbGljaycsIHZpZXcuY2xpY2spO1xuICAgICAqIC8vID0+IExvZ3MgJ2NsaWNrZWQgZG9jcycgd2hlbiBjbGlja2VkLlxuICAgICAqL3ZhciBiaW5kQWxsPWZsYXRSZXN0KGZ1bmN0aW9uKG9iamVjdCxtZXRob2ROYW1lcyl7YXJyYXlFYWNoKG1ldGhvZE5hbWVzLGZ1bmN0aW9uKGtleSl7a2V5PXRvS2V5KGtleSk7YmFzZUFzc2lnblZhbHVlKG9iamVjdCxrZXksYmluZChvYmplY3Rba2V5XSxvYmplY3QpKTt9KTtyZXR1cm4gb2JqZWN0O30pOy8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGl0ZXJhdGVzIG92ZXIgYHBhaXJzYCBhbmQgaW52b2tlcyB0aGUgY29ycmVzcG9uZGluZ1xuICAgICAqIGZ1bmN0aW9uIG9mIHRoZSBmaXJzdCBwcmVkaWNhdGUgdG8gcmV0dXJuIHRydXRoeS4gVGhlIHByZWRpY2F0ZS1mdW5jdGlvblxuICAgICAqIHBhaXJzIGFyZSBpbnZva2VkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIGFuZCBhcmd1bWVudHMgb2YgdGhlIGNyZWF0ZWRcbiAgICAgKiBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtBcnJheX0gcGFpcnMgVGhlIHByZWRpY2F0ZS1mdW5jdGlvbiBwYWlycy5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjb21wb3NpdGUgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBmdW5jID0gXy5jb25kKFtcbiAgICAgKiAgIFtfLm1hdGNoZXMoeyAnYSc6IDEgfSksICAgICAgICAgICBfLmNvbnN0YW50KCdtYXRjaGVzIEEnKV0sXG4gICAgICogICBbXy5jb25mb3Jtcyh7ICdiJzogXy5pc051bWJlciB9KSwgXy5jb25zdGFudCgnbWF0Y2hlcyBCJyldLFxuICAgICAqICAgW18uc3R1YlRydWUsICAgICAgICAgICAgICAgICAgICAgIF8uY29uc3RhbnQoJ25vIG1hdGNoJyldXG4gICAgICogXSk7XG4gICAgICpcbiAgICAgKiBmdW5jKHsgJ2EnOiAxLCAnYic6IDIgfSk7XG4gICAgICogLy8gPT4gJ21hdGNoZXMgQSdcbiAgICAgKlxuICAgICAqIGZ1bmMoeyAnYSc6IDAsICdiJzogMSB9KTtcbiAgICAgKiAvLyA9PiAnbWF0Y2hlcyBCJ1xuICAgICAqXG4gICAgICogZnVuYyh7ICdhJzogJzEnLCAnYic6ICcyJyB9KTtcbiAgICAgKiAvLyA9PiAnbm8gbWF0Y2gnXG4gICAgICovZnVuY3Rpb24gY29uZChwYWlycyl7dmFyIGxlbmd0aD1wYWlycz09bnVsbD8wOnBhaXJzLmxlbmd0aCx0b0l0ZXJhdGVlPWdldEl0ZXJhdGVlKCk7cGFpcnM9IWxlbmd0aD9bXTphcnJheU1hcChwYWlycyxmdW5jdGlvbihwYWlyKXtpZih0eXBlb2YgcGFpclsxXSE9J2Z1bmN0aW9uJyl7dGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO31yZXR1cm5bdG9JdGVyYXRlZShwYWlyWzBdKSxwYWlyWzFdXTt9KTtyZXR1cm4gYmFzZVJlc3QoZnVuY3Rpb24oYXJncyl7dmFyIGluZGV4PS0xO3doaWxlKCsraW5kZXg8bGVuZ3RoKXt2YXIgcGFpcj1wYWlyc1tpbmRleF07aWYoYXBwbHkocGFpclswXSx0aGlzLGFyZ3MpKXtyZXR1cm4gYXBwbHkocGFpclsxXSx0aGlzLGFyZ3MpO319fSk7fS8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgdGhlIHByZWRpY2F0ZSBwcm9wZXJ0aWVzIG9mIGBzb3VyY2VgIHdpdGhcbiAgICAgKiB0aGUgY29ycmVzcG9uZGluZyBwcm9wZXJ0eSB2YWx1ZXMgb2YgYSBnaXZlbiBvYmplY3QsIHJldHVybmluZyBgdHJ1ZWAgaWZcbiAgICAgKiBhbGwgcHJlZGljYXRlcyByZXR1cm4gdHJ1dGh5LCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhlIGNyZWF0ZWQgZnVuY3Rpb24gaXMgZXF1aXZhbGVudCB0byBgXy5jb25mb3Jtc1RvYCB3aXRoXG4gICAgICogYHNvdXJjZWAgcGFydGlhbGx5IGFwcGxpZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSBwcmVkaWNhdGVzIHRvIGNvbmZvcm0gdG8uXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbXG4gICAgICogICB7ICdhJzogMiwgJ2InOiAxIH0sXG4gICAgICogICB7ICdhJzogMSwgJ2InOiAyIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5maWx0ZXIob2JqZWN0cywgXy5jb25mb3Jtcyh7ICdiJzogZnVuY3Rpb24obikgeyByZXR1cm4gbiA+IDE7IH0gfSkpO1xuICAgICAqIC8vID0+IFt7ICdhJzogMSwgJ2InOiAyIH1dXG4gICAgICovZnVuY3Rpb24gY29uZm9ybXMoc291cmNlKXtyZXR1cm4gYmFzZUNvbmZvcm1zKGJhc2VDbG9uZShzb3VyY2UsQ0xPTkVfREVFUF9GTEFHKSk7fS8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYHZhbHVlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjQuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcmV0dXJuIGZyb20gdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjb25zdGFudCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBfLnRpbWVzKDIsIF8uY29uc3RhbnQoeyAnYSc6IDEgfSkpO1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2cob2JqZWN0cyk7XG4gICAgICogLy8gPT4gW3sgJ2EnOiAxIH0sIHsgJ2EnOiAxIH1dXG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhvYmplY3RzWzBdID09PSBvYmplY3RzWzFdKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovZnVuY3Rpb24gY29uc3RhbnQodmFsdWUpe3JldHVybiBmdW5jdGlvbigpe3JldHVybiB2YWx1ZTt9O30vKipcbiAgICAgKiBDaGVja3MgYHZhbHVlYCB0byBkZXRlcm1pbmUgd2hldGhlciBhIGRlZmF1bHQgdmFsdWUgc2hvdWxkIGJlIHJldHVybmVkIGluXG4gICAgICogaXRzIHBsYWNlLiBUaGUgYGRlZmF1bHRWYWx1ZWAgaXMgcmV0dXJuZWQgaWYgYHZhbHVlYCBpcyBgTmFOYCwgYG51bGxgLFxuICAgICAqIG9yIGB1bmRlZmluZWRgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMTQuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHBhcmFtIHsqfSBkZWZhdWx0VmFsdWUgVGhlIGRlZmF1bHQgdmFsdWUuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRlZmF1bHRUbygxLCAxMCk7XG4gICAgICogLy8gPT4gMVxuICAgICAqXG4gICAgICogXy5kZWZhdWx0VG8odW5kZWZpbmVkLCAxMCk7XG4gICAgICogLy8gPT4gMTBcbiAgICAgKi9mdW5jdGlvbiBkZWZhdWx0VG8odmFsdWUsZGVmYXVsdFZhbHVlKXtyZXR1cm4gdmFsdWU9PW51bGx8fHZhbHVlIT09dmFsdWU/ZGVmYXVsdFZhbHVlOnZhbHVlO30vKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSByZXN1bHQgb2YgaW52b2tpbmcgdGhlIGdpdmVuIGZ1bmN0aW9uc1xuICAgICAqIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZSBjcmVhdGVkIGZ1bmN0aW9uLCB3aGVyZSBlYWNoIHN1Y2Nlc3NpdmVcbiAgICAgKiBpbnZvY2F0aW9uIGlzIHN1cHBsaWVkIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIHByZXZpb3VzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0gey4uLihGdW5jdGlvbnxGdW5jdGlvbltdKX0gW2Z1bmNzXSBUaGUgZnVuY3Rpb25zIHRvIGludm9rZS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjb21wb3NpdGUgZnVuY3Rpb24uXG4gICAgICogQHNlZSBfLmZsb3dSaWdodFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBzcXVhcmUobikge1xuICAgICAqICAgcmV0dXJuIG4gKiBuO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciBhZGRTcXVhcmUgPSBfLmZsb3coW18uYWRkLCBzcXVhcmVdKTtcbiAgICAgKiBhZGRTcXVhcmUoMSwgMik7XG4gICAgICogLy8gPT4gOVxuICAgICAqL3ZhciBmbG93PWNyZWF0ZUZsb3coKTsvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZsb3dgIGV4Y2VwdCB0aGF0IGl0IGNyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0XG4gICAgICogaW52b2tlcyB0aGUgZ2l2ZW4gZnVuY3Rpb25zIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHsuLi4oRnVuY3Rpb258RnVuY3Rpb25bXSl9IFtmdW5jc10gVGhlIGZ1bmN0aW9ucyB0byBpbnZva2UuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY29tcG9zaXRlIGZ1bmN0aW9uLlxuICAgICAqIEBzZWUgXy5mbG93XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIHNxdWFyZShuKSB7XG4gICAgICogICByZXR1cm4gbiAqIG47XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIGFkZFNxdWFyZSA9IF8uZmxvd1JpZ2h0KFtzcXVhcmUsIF8uYWRkXSk7XG4gICAgICogYWRkU3F1YXJlKDEsIDIpO1xuICAgICAqIC8vID0+IDlcbiAgICAgKi92YXIgZmxvd1JpZ2h0PWNyZWF0ZUZsb3codHJ1ZSk7LyoqXG4gICAgICogVGhpcyBtZXRob2QgcmV0dXJucyB0aGUgZmlyc3QgYXJndW1lbnQgaXQgcmVjZWl2ZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgQW55IHZhbHVlLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIGB2YWx1ZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2coXy5pZGVudGl0eShvYmplY3QpID09PSBvYmplY3QpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9mdW5jdGlvbiBpZGVudGl0eSh2YWx1ZSl7cmV0dXJuIHZhbHVlO30vKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIHRoZSBhcmd1bWVudHMgb2YgdGhlIGNyZWF0ZWRcbiAgICAgKiBmdW5jdGlvbi4gSWYgYGZ1bmNgIGlzIGEgcHJvcGVydHkgbmFtZSwgdGhlIGNyZWF0ZWQgZnVuY3Rpb24gcmV0dXJucyB0aGVcbiAgICAgKiBwcm9wZXJ0eSB2YWx1ZSBmb3IgYSBnaXZlbiBlbGVtZW50LiBJZiBgZnVuY2AgaXMgYW4gYXJyYXkgb3Igb2JqZWN0LCB0aGVcbiAgICAgKiBjcmVhdGVkIGZ1bmN0aW9uIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGNvbnRhaW4gdGhlIGVxdWl2YWxlbnRcbiAgICAgKiBzb3VyY2UgcHJvcGVydGllcywgb3RoZXJ3aXNlIGl0IHJldHVybnMgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHsqfSBbZnVuYz1fLmlkZW50aXR5XSBUaGUgdmFsdWUgdG8gY29udmVydCB0byBhIGNhbGxiYWNrLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgY2FsbGJhY2suXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2LCAnYWN0aXZlJzogdHJ1ZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDAsICdhY3RpdmUnOiBmYWxzZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maWx0ZXIodXNlcnMsIF8uaXRlcmF0ZWUoeyAndXNlcic6ICdiYXJuZXknLCAnYWN0aXZlJzogdHJ1ZSB9KSk7XG4gICAgICogLy8gPT4gW3sgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2LCAnYWN0aXZlJzogdHJ1ZSB9XVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmlsdGVyKHVzZXJzLCBfLml0ZXJhdGVlKFsndXNlcicsICdmcmVkJ10pKTtcbiAgICAgKiAvLyA9PiBbeyAndXNlcic6ICdmcmVkJywgJ2FnZSc6IDQwIH1dXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLm1hcCh1c2VycywgXy5pdGVyYXRlZSgndXNlcicpKTtcbiAgICAgKiAvLyA9PiBbJ2Jhcm5leScsICdmcmVkJ11cbiAgICAgKlxuICAgICAqIC8vIENyZWF0ZSBjdXN0b20gaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICAgKiBfLml0ZXJhdGVlID0gXy53cmFwKF8uaXRlcmF0ZWUsIGZ1bmN0aW9uKGl0ZXJhdGVlLCBmdW5jKSB7XG4gICAgICogICByZXR1cm4gIV8uaXNSZWdFeHAoZnVuYykgPyBpdGVyYXRlZShmdW5jKSA6IGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAqICAgICByZXR1cm4gZnVuYy50ZXN0KHN0cmluZyk7XG4gICAgICogICB9O1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogXy5maWx0ZXIoWydhYmMnLCAnZGVmJ10sIC9lZi8pO1xuICAgICAqIC8vID0+IFsnZGVmJ11cbiAgICAgKi9mdW5jdGlvbiBpdGVyYXRlZShmdW5jKXtyZXR1cm4gYmFzZUl0ZXJhdGVlKHR5cGVvZiBmdW5jPT0nZnVuY3Rpb24nP2Z1bmM6YmFzZUNsb25lKGZ1bmMsQ0xPTkVfREVFUF9GTEFHKSk7fS8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHBlcmZvcm1zIGEgcGFydGlhbCBkZWVwIGNvbXBhcmlzb24gYmV0d2VlbiBhIGdpdmVuXG4gICAgICogb2JqZWN0IGFuZCBgc291cmNlYCwgcmV0dXJuaW5nIGB0cnVlYCBpZiB0aGUgZ2l2ZW4gb2JqZWN0IGhhcyBlcXVpdmFsZW50XG4gICAgICogcHJvcGVydHkgdmFsdWVzLCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhlIGNyZWF0ZWQgZnVuY3Rpb24gaXMgZXF1aXZhbGVudCB0byBgXy5pc01hdGNoYCB3aXRoIGBzb3VyY2VgXG4gICAgICogcGFydGlhbGx5IGFwcGxpZWQuXG4gICAgICpcbiAgICAgKiBQYXJ0aWFsIGNvbXBhcmlzb25zIHdpbGwgbWF0Y2ggZW1wdHkgYXJyYXkgYW5kIGVtcHR5IG9iamVjdCBgc291cmNlYFxuICAgICAqIHZhbHVlcyBhZ2FpbnN0IGFueSBhcnJheSBvciBvYmplY3QgdmFsdWUsIHJlc3BlY3RpdmVseS4gU2VlIGBfLmlzRXF1YWxgXG4gICAgICogZm9yIGEgbGlzdCBvZiBzdXBwb3J0ZWQgdmFsdWUgY29tcGFyaXNvbnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSB2YWx1ZXMgdG8gbWF0Y2guXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbXG4gICAgICogICB7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDMgfSxcbiAgICAgKiAgIHsgJ2EnOiA0LCAnYic6IDUsICdjJzogNiB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8uZmlsdGVyKG9iamVjdHMsIF8ubWF0Y2hlcyh7ICdhJzogNCwgJ2MnOiA2IH0pKTtcbiAgICAgKiAvLyA9PiBbeyAnYSc6IDQsICdiJzogNSwgJ2MnOiA2IH1dXG4gICAgICovZnVuY3Rpb24gbWF0Y2hlcyhzb3VyY2Upe3JldHVybiBiYXNlTWF0Y2hlcyhiYXNlQ2xvbmUoc291cmNlLENMT05FX0RFRVBfRkxBRykpO30vKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBwZXJmb3JtcyBhIHBhcnRpYWwgZGVlcCBjb21wYXJpc29uIGJldHdlZW4gdGhlXG4gICAgICogdmFsdWUgYXQgYHBhdGhgIG9mIGEgZ2l2ZW4gb2JqZWN0IHRvIGBzcmNWYWx1ZWAsIHJldHVybmluZyBgdHJ1ZWAgaWYgdGhlXG4gICAgICogb2JqZWN0IHZhbHVlIGlzIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBQYXJ0aWFsIGNvbXBhcmlzb25zIHdpbGwgbWF0Y2ggZW1wdHkgYXJyYXkgYW5kIGVtcHR5IG9iamVjdFxuICAgICAqIGBzcmNWYWx1ZWAgdmFsdWVzIGFnYWluc3QgYW55IGFycmF5IG9yIG9iamVjdCB2YWx1ZSwgcmVzcGVjdGl2ZWx5LiBTZWVcbiAgICAgKiBgXy5pc0VxdWFsYCBmb3IgYSBsaXN0IG9mIHN1cHBvcnRlZCB2YWx1ZSBjb21wYXJpc29ucy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjIuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAgICAgKiBAcGFyYW0geyp9IHNyY1ZhbHVlIFRoZSB2YWx1ZSB0byBtYXRjaC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzcGVjIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFtcbiAgICAgKiAgIHsgJ2EnOiAxLCAnYic6IDIsICdjJzogMyB9LFxuICAgICAqICAgeyAnYSc6IDQsICdiJzogNSwgJ2MnOiA2IH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5maW5kKG9iamVjdHMsIF8ubWF0Y2hlc1Byb3BlcnR5KCdhJywgNCkpO1xuICAgICAqIC8vID0+IHsgJ2EnOiA0LCAnYic6IDUsICdjJzogNiB9XG4gICAgICovZnVuY3Rpb24gbWF0Y2hlc1Byb3BlcnR5KHBhdGgsc3JjVmFsdWUpe3JldHVybiBiYXNlTWF0Y2hlc1Byb3BlcnR5KHBhdGgsYmFzZUNsb25lKHNyY1ZhbHVlLENMT05FX0RFRVBfRkxBRykpO30vKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIHRoZSBtZXRob2QgYXQgYHBhdGhgIG9mIGEgZ2l2ZW4gb2JqZWN0LlxuICAgICAqIEFueSBhZGRpdGlvbmFsIGFyZ3VtZW50cyBhcmUgcHJvdmlkZWQgdG8gdGhlIGludm9rZWQgbWV0aG9kLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuNy4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgbWV0aG9kIHRvIGludm9rZS5cbiAgICAgKiBAcGFyYW0gey4uLip9IFthcmdzXSBUaGUgYXJndW1lbnRzIHRvIGludm9rZSB0aGUgbWV0aG9kIHdpdGguXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgaW52b2tlciBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbXG4gICAgICogICB7ICdhJzogeyAnYic6IF8uY29uc3RhbnQoMikgfSB9LFxuICAgICAqICAgeyAnYSc6IHsgJ2InOiBfLmNvbnN0YW50KDEpIH0gfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLm1hcChvYmplY3RzLCBfLm1ldGhvZCgnYS5iJykpO1xuICAgICAqIC8vID0+IFsyLCAxXVxuICAgICAqXG4gICAgICogXy5tYXAob2JqZWN0cywgXy5tZXRob2QoWydhJywgJ2InXSkpO1xuICAgICAqIC8vID0+IFsyLCAxXVxuICAgICAqL3ZhciBtZXRob2Q9YmFzZVJlc3QoZnVuY3Rpb24ocGF0aCxhcmdzKXtyZXR1cm4gZnVuY3Rpb24ob2JqZWN0KXtyZXR1cm4gYmFzZUludm9rZShvYmplY3QscGF0aCxhcmdzKTt9O30pOy8qKlxuICAgICAqIFRoZSBvcHBvc2l0ZSBvZiBgXy5tZXRob2RgOyB0aGlzIG1ldGhvZCBjcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzXG4gICAgICogdGhlIG1ldGhvZCBhdCBhIGdpdmVuIHBhdGggb2YgYG9iamVjdGAuIEFueSBhZGRpdGlvbmFsIGFyZ3VtZW50cyBhcmVcbiAgICAgKiBwcm92aWRlZCB0byB0aGUgaW52b2tlZCBtZXRob2QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy43LjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0gey4uLip9IFthcmdzXSBUaGUgYXJndW1lbnRzIHRvIGludm9rZSB0aGUgbWV0aG9kIHdpdGguXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgaW52b2tlciBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gXy50aW1lcygzLCBfLmNvbnN0YW50KSxcbiAgICAgKiAgICAgb2JqZWN0ID0geyAnYSc6IGFycmF5LCAnYic6IGFycmF5LCAnYyc6IGFycmF5IH07XG4gICAgICpcbiAgICAgKiBfLm1hcChbJ2FbMl0nLCAnY1swXSddLCBfLm1ldGhvZE9mKG9iamVjdCkpO1xuICAgICAqIC8vID0+IFsyLCAwXVxuICAgICAqXG4gICAgICogXy5tYXAoW1snYScsICcyJ10sIFsnYycsICcwJ11dLCBfLm1ldGhvZE9mKG9iamVjdCkpO1xuICAgICAqIC8vID0+IFsyLCAwXVxuICAgICAqL3ZhciBtZXRob2RPZj1iYXNlUmVzdChmdW5jdGlvbihvYmplY3QsYXJncyl7cmV0dXJuIGZ1bmN0aW9uKHBhdGgpe3JldHVybiBiYXNlSW52b2tlKG9iamVjdCxwYXRoLGFyZ3MpO307fSk7LyoqXG4gICAgICogQWRkcyBhbGwgb3duIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIGZ1bmN0aW9uIHByb3BlcnRpZXMgb2YgYSBzb3VyY2VcbiAgICAgKiBvYmplY3QgdG8gdGhlIGRlc3RpbmF0aW9uIG9iamVjdC4gSWYgYG9iamVjdGAgaXMgYSBmdW5jdGlvbiwgdGhlbiBtZXRob2RzXG4gICAgICogYXJlIGFkZGVkIHRvIGl0cyBwcm90b3R5cGUgYXMgd2VsbC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBVc2UgYF8ucnVuSW5Db250ZXh0YCB0byBjcmVhdGUgYSBwcmlzdGluZSBgbG9kYXNoYCBmdW5jdGlvbiB0b1xuICAgICAqIGF2b2lkIGNvbmZsaWN0cyBjYXVzZWQgYnkgbW9kaWZ5aW5nIHRoZSBvcmlnaW5hbC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R9IFtvYmplY3Q9bG9kYXNoXSBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBmdW5jdGlvbnMgdG8gYWRkLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gVGhlIG9wdGlvbnMgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuY2hhaW49dHJ1ZV0gU3BlY2lmeSB3aGV0aGVyIG1peGlucyBhcmUgY2hhaW5hYmxlLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbnxPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIHZvd2VscyhzdHJpbmcpIHtcbiAgICAgKiAgIHJldHVybiBfLmZpbHRlcihzdHJpbmcsIGZ1bmN0aW9uKHYpIHtcbiAgICAgKiAgICAgcmV0dXJuIC9bYWVpb3VdL2kudGVzdCh2KTtcbiAgICAgKiAgIH0pO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIF8ubWl4aW4oeyAndm93ZWxzJzogdm93ZWxzIH0pO1xuICAgICAqIF8udm93ZWxzKCdmcmVkJyk7XG4gICAgICogLy8gPT4gWydlJ11cbiAgICAgKlxuICAgICAqIF8oJ2ZyZWQnKS52b3dlbHMoKS52YWx1ZSgpO1xuICAgICAqIC8vID0+IFsnZSddXG4gICAgICpcbiAgICAgKiBfLm1peGluKHsgJ3Zvd2Vscyc6IHZvd2VscyB9LCB7ICdjaGFpbic6IGZhbHNlIH0pO1xuICAgICAqIF8oJ2ZyZWQnKS52b3dlbHMoKTtcbiAgICAgKiAvLyA9PiBbJ2UnXVxuICAgICAqL2Z1bmN0aW9uIG1peGluKG9iamVjdCxzb3VyY2Usb3B0aW9ucyl7dmFyIHByb3BzPWtleXMoc291cmNlKSxtZXRob2ROYW1lcz1iYXNlRnVuY3Rpb25zKHNvdXJjZSxwcm9wcyk7aWYob3B0aW9ucz09bnVsbCYmIShpc09iamVjdChzb3VyY2UpJiYobWV0aG9kTmFtZXMubGVuZ3RofHwhcHJvcHMubGVuZ3RoKSkpe29wdGlvbnM9c291cmNlO3NvdXJjZT1vYmplY3Q7b2JqZWN0PXRoaXM7bWV0aG9kTmFtZXM9YmFzZUZ1bmN0aW9ucyhzb3VyY2Usa2V5cyhzb3VyY2UpKTt9dmFyIGNoYWluPSEoaXNPYmplY3Qob3B0aW9ucykmJidjaGFpbidpbiBvcHRpb25zKXx8ISFvcHRpb25zLmNoYWluLGlzRnVuYz1pc0Z1bmN0aW9uKG9iamVjdCk7YXJyYXlFYWNoKG1ldGhvZE5hbWVzLGZ1bmN0aW9uKG1ldGhvZE5hbWUpe3ZhciBmdW5jPXNvdXJjZVttZXRob2ROYW1lXTtvYmplY3RbbWV0aG9kTmFtZV09ZnVuYztpZihpc0Z1bmMpe29iamVjdC5wcm90b3R5cGVbbWV0aG9kTmFtZV09ZnVuY3Rpb24oKXt2YXIgY2hhaW5BbGw9dGhpcy5fX2NoYWluX187aWYoY2hhaW58fGNoYWluQWxsKXt2YXIgcmVzdWx0PW9iamVjdCh0aGlzLl9fd3JhcHBlZF9fKSxhY3Rpb25zPXJlc3VsdC5fX2FjdGlvbnNfXz1jb3B5QXJyYXkodGhpcy5fX2FjdGlvbnNfXyk7YWN0aW9ucy5wdXNoKHsnZnVuYyc6ZnVuYywnYXJncyc6YXJndW1lbnRzLCd0aGlzQXJnJzpvYmplY3R9KTtyZXN1bHQuX19jaGFpbl9fPWNoYWluQWxsO3JldHVybiByZXN1bHQ7fXJldHVybiBmdW5jLmFwcGx5KG9iamVjdCxhcnJheVB1c2goW3RoaXMudmFsdWUoKV0sYXJndW1lbnRzKSk7fTt9fSk7cmV0dXJuIG9iamVjdDt9LyoqXG4gICAgICogUmV2ZXJ0cyB0aGUgYF9gIHZhcmlhYmxlIHRvIGl0cyBwcmV2aW91cyB2YWx1ZSBhbmQgcmV0dXJucyBhIHJlZmVyZW5jZSB0b1xuICAgICAqIHRoZSBgbG9kYXNoYCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBgbG9kYXNoYCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGxvZGFzaCA9IF8ubm9Db25mbGljdCgpO1xuICAgICAqL2Z1bmN0aW9uIG5vQ29uZmxpY3QoKXtpZihyb290Ll89PT10aGlzKXtyb290Ll89b2xkRGFzaDt9cmV0dXJuIHRoaXM7fS8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHJldHVybnMgYHVuZGVmaW5lZGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi4zLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRpbWVzKDIsIF8ubm9vcCk7XG4gICAgICogLy8gPT4gW3VuZGVmaW5lZCwgdW5kZWZpbmVkXVxuICAgICAqL2Z1bmN0aW9uIG5vb3AoKXt9Ly8gTm8gb3BlcmF0aW9uIHBlcmZvcm1lZC5cbi8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGdldHMgdGhlIGFyZ3VtZW50IGF0IGluZGV4IGBuYC4gSWYgYG5gIGlzIG5lZ2F0aXZlLFxuICAgICAqIHRoZSBudGggYXJndW1lbnQgZnJvbSB0aGUgZW5kIGlzIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW249MF0gVGhlIGluZGV4IG9mIHRoZSBhcmd1bWVudCB0byByZXR1cm4uXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcGFzcy10aHJ1IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgZnVuYyA9IF8ubnRoQXJnKDEpO1xuICAgICAqIGZ1bmMoJ2EnLCAnYicsICdjJywgJ2QnKTtcbiAgICAgKiAvLyA9PiAnYidcbiAgICAgKlxuICAgICAqIHZhciBmdW5jID0gXy5udGhBcmcoLTIpO1xuICAgICAqIGZ1bmMoJ2EnLCAnYicsICdjJywgJ2QnKTtcbiAgICAgKiAvLyA9PiAnYydcbiAgICAgKi9mdW5jdGlvbiBudGhBcmcobil7bj10b0ludGVnZXIobik7cmV0dXJuIGJhc2VSZXN0KGZ1bmN0aW9uKGFyZ3Mpe3JldHVybiBiYXNlTnRoKGFyZ3Msbik7fSk7fS8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGl0ZXJhdGVlc2Agd2l0aCB0aGUgYXJndW1lbnRzIGl0IHJlY2VpdmVzXG4gICAgICogYW5kIHJldHVybnMgdGhlaXIgcmVzdWx0cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHsuLi4oRnVuY3Rpb258RnVuY3Rpb25bXSl9IFtpdGVyYXRlZXM9W18uaWRlbnRpdHldXVxuICAgICAqICBUaGUgaXRlcmF0ZWVzIHRvIGludm9rZS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGZ1bmMgPSBfLm92ZXIoW01hdGgubWF4LCBNYXRoLm1pbl0pO1xuICAgICAqXG4gICAgICogZnVuYygxLCAyLCAzLCA0KTtcbiAgICAgKiAvLyA9PiBbNCwgMV1cbiAgICAgKi92YXIgb3Zlcj1jcmVhdGVPdmVyKGFycmF5TWFwKTsvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBjaGVja3MgaWYgKiphbGwqKiBvZiB0aGUgYHByZWRpY2F0ZXNgIHJldHVyblxuICAgICAqIHRydXRoeSB3aGVuIGludm9rZWQgd2l0aCB0aGUgYXJndW1lbnRzIGl0IHJlY2VpdmVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0gey4uLihGdW5jdGlvbnxGdW5jdGlvbltdKX0gW3ByZWRpY2F0ZXM9W18uaWRlbnRpdHldXVxuICAgICAqICBUaGUgcHJlZGljYXRlcyB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGZ1bmMgPSBfLm92ZXJFdmVyeShbQm9vbGVhbiwgaXNGaW5pdGVdKTtcbiAgICAgKlxuICAgICAqIGZ1bmMoJzEnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBmdW5jKG51bGwpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBmdW5jKE5hTik7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi92YXIgb3ZlckV2ZXJ5PWNyZWF0ZU92ZXIoYXJyYXlFdmVyeSk7LyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgY2hlY2tzIGlmICoqYW55Kiogb2YgdGhlIGBwcmVkaWNhdGVzYCByZXR1cm5cbiAgICAgKiB0cnV0aHkgd2hlbiBpbnZva2VkIHdpdGggdGhlIGFyZ3VtZW50cyBpdCByZWNlaXZlcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHsuLi4oRnVuY3Rpb258RnVuY3Rpb25bXSl9IFtwcmVkaWNhdGVzPVtfLmlkZW50aXR5XV1cbiAgICAgKiAgVGhlIHByZWRpY2F0ZXMgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBmdW5jID0gXy5vdmVyU29tZShbQm9vbGVhbiwgaXNGaW5pdGVdKTtcbiAgICAgKlxuICAgICAqIGZ1bmMoJzEnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBmdW5jKG51bGwpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIGZ1bmMoTmFOKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL3ZhciBvdmVyU29tZT1jcmVhdGVPdmVyKGFycmF5U29tZSk7LyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgdmFsdWUgYXQgYHBhdGhgIG9mIGEgZ2l2ZW4gb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuNC4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFtcbiAgICAgKiAgIHsgJ2EnOiB7ICdiJzogMiB9IH0sXG4gICAgICogICB7ICdhJzogeyAnYic6IDEgfSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8ubWFwKG9iamVjdHMsIF8ucHJvcGVydHkoJ2EuYicpKTtcbiAgICAgKiAvLyA9PiBbMiwgMV1cbiAgICAgKlxuICAgICAqIF8ubWFwKF8uc29ydEJ5KG9iamVjdHMsIF8ucHJvcGVydHkoWydhJywgJ2InXSkpLCAnYS5iJyk7XG4gICAgICogLy8gPT4gWzEsIDJdXG4gICAgICovZnVuY3Rpb24gcHJvcGVydHkocGF0aCl7cmV0dXJuIGlzS2V5KHBhdGgpP2Jhc2VQcm9wZXJ0eSh0b0tleShwYXRoKSk6YmFzZVByb3BlcnR5RGVlcChwYXRoKTt9LyoqXG4gICAgICogVGhlIG9wcG9zaXRlIG9mIGBfLnByb3BlcnR5YDsgdGhpcyBtZXRob2QgY3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJuc1xuICAgICAqIHRoZSB2YWx1ZSBhdCBhIGdpdmVuIHBhdGggb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWzAsIDEsIDJdLFxuICAgICAqICAgICBvYmplY3QgPSB7ICdhJzogYXJyYXksICdiJzogYXJyYXksICdjJzogYXJyYXkgfTtcbiAgICAgKlxuICAgICAqIF8ubWFwKFsnYVsyXScsICdjWzBdJ10sIF8ucHJvcGVydHlPZihvYmplY3QpKTtcbiAgICAgKiAvLyA9PiBbMiwgMF1cbiAgICAgKlxuICAgICAqIF8ubWFwKFtbJ2EnLCAnMiddLCBbJ2MnLCAnMCddXSwgXy5wcm9wZXJ0eU9mKG9iamVjdCkpO1xuICAgICAqIC8vID0+IFsyLCAwXVxuICAgICAqL2Z1bmN0aW9uIHByb3BlcnR5T2Yob2JqZWN0KXtyZXR1cm4gZnVuY3Rpb24ocGF0aCl7cmV0dXJuIG9iamVjdD09bnVsbD91bmRlZmluZWQ6YmFzZUdldChvYmplY3QscGF0aCk7fTt9LyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBudW1iZXJzIChwb3NpdGl2ZSBhbmQvb3IgbmVnYXRpdmUpIHByb2dyZXNzaW5nIGZyb21cbiAgICAgKiBgc3RhcnRgIHVwIHRvLCBidXQgbm90IGluY2x1ZGluZywgYGVuZGAuIEEgc3RlcCBvZiBgLTFgIGlzIHVzZWQgaWYgYSBuZWdhdGl2ZVxuICAgICAqIGBzdGFydGAgaXMgc3BlY2lmaWVkIHdpdGhvdXQgYW4gYGVuZGAgb3IgYHN0ZXBgLiBJZiBgZW5kYCBpcyBub3Qgc3BlY2lmaWVkLFxuICAgICAqIGl0J3Mgc2V0IHRvIGBzdGFydGAgd2l0aCBgc3RhcnRgIHRoZW4gc2V0IHRvIGAwYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBKYXZhU2NyaXB0IGZvbGxvd3MgdGhlIElFRUUtNzU0IHN0YW5kYXJkIGZvciByZXNvbHZpbmdcbiAgICAgKiBmbG9hdGluZy1wb2ludCB2YWx1ZXMgd2hpY2ggY2FuIHByb2R1Y2UgdW5leHBlY3RlZCByZXN1bHRzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PTBdIFRoZSBzdGFydCBvZiB0aGUgcmFuZ2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZCBUaGUgZW5kIG9mIHRoZSByYW5nZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0ZXA9MV0gVGhlIHZhbHVlIHRvIGluY3JlbWVudCBvciBkZWNyZW1lbnQgYnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSByYW5nZSBvZiBudW1iZXJzLlxuICAgICAqIEBzZWUgXy5pblJhbmdlLCBfLnJhbmdlUmlnaHRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5yYW5nZSg0KTtcbiAgICAgKiAvLyA9PiBbMCwgMSwgMiwgM11cbiAgICAgKlxuICAgICAqIF8ucmFuZ2UoLTQpO1xuICAgICAqIC8vID0+IFswLCAtMSwgLTIsIC0zXVxuICAgICAqXG4gICAgICogXy5yYW5nZSgxLCA1KTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgMywgNF1cbiAgICAgKlxuICAgICAqIF8ucmFuZ2UoMCwgMjAsIDUpO1xuICAgICAqIC8vID0+IFswLCA1LCAxMCwgMTVdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlKDAsIC00LCAtMSk7XG4gICAgICogLy8gPT4gWzAsIC0xLCAtMiwgLTNdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlKDEsIDQsIDApO1xuICAgICAqIC8vID0+IFsxLCAxLCAxXVxuICAgICAqXG4gICAgICogXy5yYW5nZSgwKTtcbiAgICAgKiAvLyA9PiBbXVxuICAgICAqL3ZhciByYW5nZT1jcmVhdGVSYW5nZSgpOy8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ucmFuZ2VgIGV4Y2VwdCB0aGF0IGl0IHBvcHVsYXRlcyB2YWx1ZXMgaW5cbiAgICAgKiBkZXNjZW5kaW5nIG9yZGVyLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PTBdIFRoZSBzdGFydCBvZiB0aGUgcmFuZ2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZCBUaGUgZW5kIG9mIHRoZSByYW5nZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0ZXA9MV0gVGhlIHZhbHVlIHRvIGluY3JlbWVudCBvciBkZWNyZW1lbnQgYnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSByYW5nZSBvZiBudW1iZXJzLlxuICAgICAqIEBzZWUgXy5pblJhbmdlLCBfLnJhbmdlXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucmFuZ2VSaWdodCg0KTtcbiAgICAgKiAvLyA9PiBbMywgMiwgMSwgMF1cbiAgICAgKlxuICAgICAqIF8ucmFuZ2VSaWdodCgtNCk7XG4gICAgICogLy8gPT4gWy0zLCAtMiwgLTEsIDBdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlUmlnaHQoMSwgNSk7XG4gICAgICogLy8gPT4gWzQsIDMsIDIsIDFdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlUmlnaHQoMCwgMjAsIDUpO1xuICAgICAqIC8vID0+IFsxNSwgMTAsIDUsIDBdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlUmlnaHQoMCwgLTQsIC0xKTtcbiAgICAgKiAvLyA9PiBbLTMsIC0yLCAtMSwgMF1cbiAgICAgKlxuICAgICAqIF8ucmFuZ2VSaWdodCgxLCA0LCAwKTtcbiAgICAgKiAvLyA9PiBbMSwgMSwgMV1cbiAgICAgKlxuICAgICAqIF8ucmFuZ2VSaWdodCgwKTtcbiAgICAgKiAvLyA9PiBbXVxuICAgICAqL3ZhciByYW5nZVJpZ2h0PWNyZWF0ZVJhbmdlKHRydWUpOy8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHJldHVybnMgYSBuZXcgZW1wdHkgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4xMy4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBlbXB0eSBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5cyA9IF8udGltZXMoMiwgXy5zdHViQXJyYXkpO1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2coYXJyYXlzKTtcbiAgICAgKiAvLyA9PiBbW10sIFtdXVxuICAgICAqXG4gICAgICogY29uc29sZS5sb2coYXJyYXlzWzBdID09PSBhcnJheXNbMV0pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovZnVuY3Rpb24gc3R1YkFycmF5KCl7cmV0dXJuW107fS8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHJldHVybnMgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjEzLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udGltZXMoMiwgXy5zdHViRmFsc2UpO1xuICAgICAqIC8vID0+IFtmYWxzZSwgZmFsc2VdXG4gICAgICovZnVuY3Rpb24gc3R1YkZhbHNlKCl7cmV0dXJuIGZhbHNlO30vKipcbiAgICAgKiBUaGlzIG1ldGhvZCByZXR1cm5zIGEgbmV3IGVtcHR5IG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjEzLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBlbXB0eSBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gXy50aW1lcygyLCBfLnN0dWJPYmplY3QpO1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2cob2JqZWN0cyk7XG4gICAgICogLy8gPT4gW3t9LCB7fV1cbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKG9iamVjdHNbMF0gPT09IG9iamVjdHNbMV0pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovZnVuY3Rpb24gc3R1Yk9iamVjdCgpe3JldHVybnt9O30vKipcbiAgICAgKiBUaGlzIG1ldGhvZCByZXR1cm5zIGFuIGVtcHR5IHN0cmluZy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjEzLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGVtcHR5IHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50aW1lcygyLCBfLnN0dWJTdHJpbmcpO1xuICAgICAqIC8vID0+IFsnJywgJyddXG4gICAgICovZnVuY3Rpb24gc3R1YlN0cmluZygpe3JldHVybicnO30vKipcbiAgICAgKiBUaGlzIG1ldGhvZCByZXR1cm5zIGB0cnVlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjEzLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50aW1lcygyLCBfLnN0dWJUcnVlKTtcbiAgICAgKiAvLyA9PiBbdHJ1ZSwgdHJ1ZV1cbiAgICAgKi9mdW5jdGlvbiBzdHViVHJ1ZSgpe3JldHVybiB0cnVlO30vKipcbiAgICAgKiBJbnZva2VzIHRoZSBpdGVyYXRlZSBgbmAgdGltZXMsIHJldHVybmluZyBhbiBhcnJheSBvZiB0aGUgcmVzdWx0cyBvZlxuICAgICAqIGVhY2ggaW52b2NhdGlvbi4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ7IChpbmRleCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gaW52b2tlIGBpdGVyYXRlZWAuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiByZXN1bHRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRpbWVzKDMsIFN0cmluZyk7XG4gICAgICogLy8gPT4gWycwJywgJzEnLCAnMiddXG4gICAgICpcbiAgICAgKiAgXy50aW1lcyg0LCBfLmNvbnN0YW50KDApKTtcbiAgICAgKiAvLyA9PiBbMCwgMCwgMCwgMF1cbiAgICAgKi9mdW5jdGlvbiB0aW1lcyhuLGl0ZXJhdGVlKXtuPXRvSW50ZWdlcihuKTtpZihuPDF8fG4+TUFYX1NBRkVfSU5URUdFUil7cmV0dXJuW107fXZhciBpbmRleD1NQVhfQVJSQVlfTEVOR1RILGxlbmd0aD1uYXRpdmVNaW4obixNQVhfQVJSQVlfTEVOR1RIKTtpdGVyYXRlZT1nZXRJdGVyYXRlZShpdGVyYXRlZSk7bi09TUFYX0FSUkFZX0xFTkdUSDt2YXIgcmVzdWx0PWJhc2VUaW1lcyhsZW5ndGgsaXRlcmF0ZWUpO3doaWxlKCsraW5kZXg8bil7aXRlcmF0ZWUoaW5kZXgpO31yZXR1cm4gcmVzdWx0O30vKipcbiAgICAgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRvUGF0aCgnYS5iLmMnKTtcbiAgICAgKiAvLyA9PiBbJ2EnLCAnYicsICdjJ11cbiAgICAgKlxuICAgICAqIF8udG9QYXRoKCdhWzBdLmIuYycpO1xuICAgICAqIC8vID0+IFsnYScsICcwJywgJ2InLCAnYyddXG4gICAgICovZnVuY3Rpb24gdG9QYXRoKHZhbHVlKXtpZihpc0FycmF5KHZhbHVlKSl7cmV0dXJuIGFycmF5TWFwKHZhbHVlLHRvS2V5KTt9cmV0dXJuIGlzU3ltYm9sKHZhbHVlKT9bdmFsdWVdOmNvcHlBcnJheShzdHJpbmdUb1BhdGgodG9TdHJpbmcodmFsdWUpKSk7fS8qKlxuICAgICAqIEdlbmVyYXRlcyBhIHVuaXF1ZSBJRC4gSWYgYHByZWZpeGAgaXMgZ2l2ZW4sIHRoZSBJRCBpcyBhcHBlbmRlZCB0byBpdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtwcmVmaXg9JyddIFRoZSB2YWx1ZSB0byBwcmVmaXggdGhlIElEIHdpdGguXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdW5pcXVlIElELlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnVuaXF1ZUlkKCdjb250YWN0XycpO1xuICAgICAqIC8vID0+ICdjb250YWN0XzEwNCdcbiAgICAgKlxuICAgICAqIF8udW5pcXVlSWQoKTtcbiAgICAgKiAvLyA9PiAnMTA1J1xuICAgICAqL2Z1bmN0aW9uIHVuaXF1ZUlkKHByZWZpeCl7dmFyIGlkPSsraWRDb3VudGVyO3JldHVybiB0b1N0cmluZyhwcmVmaXgpK2lkO30vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovLyoqXG4gICAgICogQWRkcyB0d28gbnVtYmVycy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjQuMFxuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGF1Z2VuZCBUaGUgZmlyc3QgbnVtYmVyIGluIGFuIGFkZGl0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhZGRlbmQgVGhlIHNlY29uZCBudW1iZXIgaW4gYW4gYWRkaXRpb24uXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgdG90YWwuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uYWRkKDYsIDQpO1xuICAgICAqIC8vID0+IDEwXG4gICAgICovdmFyIGFkZD1jcmVhdGVNYXRoT3BlcmF0aW9uKGZ1bmN0aW9uKGF1Z2VuZCxhZGRlbmQpe3JldHVybiBhdWdlbmQrYWRkZW5kO30sMCk7LyoqXG4gICAgICogQ29tcHV0ZXMgYG51bWJlcmAgcm91bmRlZCB1cCB0byBgcHJlY2lzaW9uYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjEwLjBcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBudW1iZXIgVGhlIG51bWJlciB0byByb3VuZCB1cC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3ByZWNpc2lvbj0wXSBUaGUgcHJlY2lzaW9uIHRvIHJvdW5kIHVwIHRvLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHJvdW5kZWQgdXAgbnVtYmVyLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmNlaWwoNC4wMDYpO1xuICAgICAqIC8vID0+IDVcbiAgICAgKlxuICAgICAqIF8uY2VpbCg2LjAwNCwgMik7XG4gICAgICogLy8gPT4gNi4wMVxuICAgICAqXG4gICAgICogXy5jZWlsKDYwNDAsIC0yKTtcbiAgICAgKiAvLyA9PiA2MTAwXG4gICAgICovdmFyIGNlaWw9Y3JlYXRlUm91bmQoJ2NlaWwnKTsvKipcbiAgICAgKiBEaXZpZGUgdHdvIG51bWJlcnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC43LjBcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkaXZpZGVuZCBUaGUgZmlyc3QgbnVtYmVyIGluIGEgZGl2aXNpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRpdmlzb3IgVGhlIHNlY29uZCBudW1iZXIgaW4gYSBkaXZpc2lvbi5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBxdW90aWVudC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kaXZpZGUoNiwgNCk7XG4gICAgICogLy8gPT4gMS41XG4gICAgICovdmFyIGRpdmlkZT1jcmVhdGVNYXRoT3BlcmF0aW9uKGZ1bmN0aW9uKGRpdmlkZW5kLGRpdmlzb3Ipe3JldHVybiBkaXZpZGVuZC9kaXZpc29yO30sMSk7LyoqXG4gICAgICogQ29tcHV0ZXMgYG51bWJlcmAgcm91bmRlZCBkb3duIHRvIGBwcmVjaXNpb25gLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMTAuMFxuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG51bWJlciBUaGUgbnVtYmVyIHRvIHJvdW5kIGRvd24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwcmVjaXNpb249MF0gVGhlIHByZWNpc2lvbiB0byByb3VuZCBkb3duIHRvLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHJvdW5kZWQgZG93biBudW1iZXIuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZmxvb3IoNC4wMDYpO1xuICAgICAqIC8vID0+IDRcbiAgICAgKlxuICAgICAqIF8uZmxvb3IoMC4wNDYsIDIpO1xuICAgICAqIC8vID0+IDAuMDRcbiAgICAgKlxuICAgICAqIF8uZmxvb3IoNDA2MCwgLTIpO1xuICAgICAqIC8vID0+IDQwMDBcbiAgICAgKi92YXIgZmxvb3I9Y3JlYXRlUm91bmQoJ2Zsb29yJyk7LyoqXG4gICAgICogQ29tcHV0ZXMgdGhlIG1heGltdW0gdmFsdWUgb2YgYGFycmF5YC4gSWYgYGFycmF5YCBpcyBlbXB0eSBvciBmYWxzZXksXG4gICAgICogYHVuZGVmaW5lZGAgaXMgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1heGltdW0gdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubWF4KFs0LCAyLCA4LCA2XSk7XG4gICAgICogLy8gPT4gOFxuICAgICAqXG4gICAgICogXy5tYXgoW10pO1xuICAgICAqIC8vID0+IHVuZGVmaW5lZFxuICAgICAqL2Z1bmN0aW9uIG1heChhcnJheSl7cmV0dXJuIGFycmF5JiZhcnJheS5sZW5ndGg/YmFzZUV4dHJlbXVtKGFycmF5LGlkZW50aXR5LGJhc2VHdCk6dW5kZWZpbmVkO30vKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLm1heGAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgIHdoaWNoIGlzXG4gICAgICogaW52b2tlZCBmb3IgZWFjaCBlbGVtZW50IGluIGBhcnJheWAgdG8gZ2VuZXJhdGUgdGhlIGNyaXRlcmlvbiBieSB3aGljaFxuICAgICAqIHRoZSB2YWx1ZSBpcyByYW5rZWQuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWF4aW11bSB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbeyAnbic6IDEgfSwgeyAnbic6IDIgfV07XG4gICAgICpcbiAgICAgKiBfLm1heEJ5KG9iamVjdHMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8ubjsgfSk7XG4gICAgICogLy8gPT4geyAnbic6IDIgfVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5tYXhCeShvYmplY3RzLCAnbicpO1xuICAgICAqIC8vID0+IHsgJ24nOiAyIH1cbiAgICAgKi9mdW5jdGlvbiBtYXhCeShhcnJheSxpdGVyYXRlZSl7cmV0dXJuIGFycmF5JiZhcnJheS5sZW5ndGg/YmFzZUV4dHJlbXVtKGFycmF5LGdldEl0ZXJhdGVlKGl0ZXJhdGVlLDIpLGJhc2VHdCk6dW5kZWZpbmVkO30vKipcbiAgICAgKiBDb21wdXRlcyB0aGUgbWVhbiBvZiB0aGUgdmFsdWVzIGluIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgbWVhbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5tZWFuKFs0LCAyLCA4LCA2XSk7XG4gICAgICogLy8gPT4gNVxuICAgICAqL2Z1bmN0aW9uIG1lYW4oYXJyYXkpe3JldHVybiBiYXNlTWVhbihhcnJheSxpZGVudGl0eSk7fS8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ubWVhbmAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgIHdoaWNoIGlzXG4gICAgICogaW52b2tlZCBmb3IgZWFjaCBlbGVtZW50IGluIGBhcnJheWAgdG8gZ2VuZXJhdGUgdGhlIHZhbHVlIHRvIGJlIGF2ZXJhZ2VkLlxuICAgICAqIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuNy4wXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBtZWFuLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFt7ICduJzogNCB9LCB7ICduJzogMiB9LCB7ICduJzogOCB9LCB7ICduJzogNiB9XTtcbiAgICAgKlxuICAgICAqIF8ubWVhbkJ5KG9iamVjdHMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8ubjsgfSk7XG4gICAgICogLy8gPT4gNVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5tZWFuQnkob2JqZWN0cywgJ24nKTtcbiAgICAgKiAvLyA9PiA1XG4gICAgICovZnVuY3Rpb24gbWVhbkJ5KGFycmF5LGl0ZXJhdGVlKXtyZXR1cm4gYmFzZU1lYW4oYXJyYXksZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsMikpO30vKipcbiAgICAgKiBDb21wdXRlcyB0aGUgbWluaW11bSB2YWx1ZSBvZiBgYXJyYXlgLiBJZiBgYXJyYXlgIGlzIGVtcHR5IG9yIGZhbHNleSxcbiAgICAgKiBgdW5kZWZpbmVkYCBpcyByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWluaW11bSB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5taW4oWzQsIDIsIDgsIDZdKTtcbiAgICAgKiAvLyA9PiAyXG4gICAgICpcbiAgICAgKiBfLm1pbihbXSk7XG4gICAgICogLy8gPT4gdW5kZWZpbmVkXG4gICAgICovZnVuY3Rpb24gbWluKGFycmF5KXtyZXR1cm4gYXJyYXkmJmFycmF5Lmxlbmd0aD9iYXNlRXh0cmVtdW0oYXJyYXksaWRlbnRpdHksYmFzZUx0KTp1bmRlZmluZWQ7fS8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ubWluYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBpdGVyYXRlZWAgd2hpY2ggaXNcbiAgICAgKiBpbnZva2VkIGZvciBlYWNoIGVsZW1lbnQgaW4gYGFycmF5YCB0byBnZW5lcmF0ZSB0aGUgY3JpdGVyaW9uIGJ5IHdoaWNoXG4gICAgICogdGhlIHZhbHVlIGlzIHJhbmtlZC4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtaW5pbXVtIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFt7ICduJzogMSB9LCB7ICduJzogMiB9XTtcbiAgICAgKlxuICAgICAqIF8ubWluQnkob2JqZWN0cywgZnVuY3Rpb24obykgeyByZXR1cm4gby5uOyB9KTtcbiAgICAgKiAvLyA9PiB7ICduJzogMSB9XG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLm1pbkJ5KG9iamVjdHMsICduJyk7XG4gICAgICogLy8gPT4geyAnbic6IDEgfVxuICAgICAqL2Z1bmN0aW9uIG1pbkJ5KGFycmF5LGl0ZXJhdGVlKXtyZXR1cm4gYXJyYXkmJmFycmF5Lmxlbmd0aD9iYXNlRXh0cmVtdW0oYXJyYXksZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsMiksYmFzZUx0KTp1bmRlZmluZWQ7fS8qKlxuICAgICAqIE11bHRpcGx5IHR3byBudW1iZXJzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuNy4wXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbXVsdGlwbGllciBUaGUgZmlyc3QgbnVtYmVyIGluIGEgbXVsdGlwbGljYXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG11bHRpcGxpY2FuZCBUaGUgc2Vjb25kIG51bWJlciBpbiBhIG11bHRpcGxpY2F0aW9uLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHByb2R1Y3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubXVsdGlwbHkoNiwgNCk7XG4gICAgICogLy8gPT4gMjRcbiAgICAgKi92YXIgbXVsdGlwbHk9Y3JlYXRlTWF0aE9wZXJhdGlvbihmdW5jdGlvbihtdWx0aXBsaWVyLG11bHRpcGxpY2FuZCl7cmV0dXJuIG11bHRpcGxpZXIqbXVsdGlwbGljYW5kO30sMSk7LyoqXG4gICAgICogQ29tcHV0ZXMgYG51bWJlcmAgcm91bmRlZCB0byBgcHJlY2lzaW9uYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjEwLjBcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBudW1iZXIgVGhlIG51bWJlciB0byByb3VuZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3ByZWNpc2lvbj0wXSBUaGUgcHJlY2lzaW9uIHRvIHJvdW5kIHRvLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHJvdW5kZWQgbnVtYmVyLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnJvdW5kKDQuMDA2KTtcbiAgICAgKiAvLyA9PiA0XG4gICAgICpcbiAgICAgKiBfLnJvdW5kKDQuMDA2LCAyKTtcbiAgICAgKiAvLyA9PiA0LjAxXG4gICAgICpcbiAgICAgKiBfLnJvdW5kKDQwNjAsIC0yKTtcbiAgICAgKiAvLyA9PiA0MTAwXG4gICAgICovdmFyIHJvdW5kPWNyZWF0ZVJvdW5kKCdyb3VuZCcpOy8qKlxuICAgICAqIFN1YnRyYWN0IHR3byBudW1iZXJzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWludWVuZCBUaGUgZmlyc3QgbnVtYmVyIGluIGEgc3VidHJhY3Rpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN1YnRyYWhlbmQgVGhlIHNlY29uZCBudW1iZXIgaW4gYSBzdWJ0cmFjdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBkaWZmZXJlbmNlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnN1YnRyYWN0KDYsIDQpO1xuICAgICAqIC8vID0+IDJcbiAgICAgKi92YXIgc3VidHJhY3Q9Y3JlYXRlTWF0aE9wZXJhdGlvbihmdW5jdGlvbihtaW51ZW5kLHN1YnRyYWhlbmQpe3JldHVybiBtaW51ZW5kLXN1YnRyYWhlbmQ7fSwwKTsvKipcbiAgICAgKiBDb21wdXRlcyB0aGUgc3VtIG9mIHRoZSB2YWx1ZXMgaW4gYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjQuMFxuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBzdW0uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc3VtKFs0LCAyLCA4LCA2XSk7XG4gICAgICogLy8gPT4gMjBcbiAgICAgKi9mdW5jdGlvbiBzdW0oYXJyYXkpe3JldHVybiBhcnJheSYmYXJyYXkubGVuZ3RoP2Jhc2VTdW0oYXJyYXksaWRlbnRpdHkpOjA7fS8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uc3VtYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBpdGVyYXRlZWAgd2hpY2ggaXNcbiAgICAgKiBpbnZva2VkIGZvciBlYWNoIGVsZW1lbnQgaW4gYGFycmF5YCB0byBnZW5lcmF0ZSB0aGUgdmFsdWUgdG8gYmUgc3VtbWVkLlxuICAgICAqIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBzdW0uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW3sgJ24nOiA0IH0sIHsgJ24nOiAyIH0sIHsgJ24nOiA4IH0sIHsgJ24nOiA2IH1dO1xuICAgICAqXG4gICAgICogXy5zdW1CeShvYmplY3RzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLm47IH0pO1xuICAgICAqIC8vID0+IDIwXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnN1bUJ5KG9iamVjdHMsICduJyk7XG4gICAgICogLy8gPT4gMjBcbiAgICAgKi9mdW5jdGlvbiBzdW1CeShhcnJheSxpdGVyYXRlZSl7cmV0dXJuIGFycmF5JiZhcnJheS5sZW5ndGg/YmFzZVN1bShhcnJheSxnZXRJdGVyYXRlZShpdGVyYXRlZSwyKSk6MDt9LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qLy8vIEFkZCBtZXRob2RzIHRoYXQgcmV0dXJuIHdyYXBwZWQgdmFsdWVzIGluIGNoYWluIHNlcXVlbmNlcy5cbmxvZGFzaC5hZnRlcj1hZnRlcjtsb2Rhc2guYXJ5PWFyeTtsb2Rhc2guYXNzaWduPWFzc2lnbjtsb2Rhc2guYXNzaWduSW49YXNzaWduSW47bG9kYXNoLmFzc2lnbkluV2l0aD1hc3NpZ25JbldpdGg7bG9kYXNoLmFzc2lnbldpdGg9YXNzaWduV2l0aDtsb2Rhc2guYXQ9YXQ7bG9kYXNoLmJlZm9yZT1iZWZvcmU7bG9kYXNoLmJpbmQ9YmluZDtsb2Rhc2guYmluZEFsbD1iaW5kQWxsO2xvZGFzaC5iaW5kS2V5PWJpbmRLZXk7bG9kYXNoLmNhc3RBcnJheT1jYXN0QXJyYXk7bG9kYXNoLmNoYWluPWNoYWluO2xvZGFzaC5jaHVuaz1jaHVuaztsb2Rhc2guY29tcGFjdD1jb21wYWN0O2xvZGFzaC5jb25jYXQ9Y29uY2F0O2xvZGFzaC5jb25kPWNvbmQ7bG9kYXNoLmNvbmZvcm1zPWNvbmZvcm1zO2xvZGFzaC5jb25zdGFudD1jb25zdGFudDtsb2Rhc2guY291bnRCeT1jb3VudEJ5O2xvZGFzaC5jcmVhdGU9Y3JlYXRlO2xvZGFzaC5jdXJyeT1jdXJyeTtsb2Rhc2guY3VycnlSaWdodD1jdXJyeVJpZ2h0O2xvZGFzaC5kZWJvdW5jZT1kZWJvdW5jZTtsb2Rhc2guZGVmYXVsdHM9ZGVmYXVsdHM7bG9kYXNoLmRlZmF1bHRzRGVlcD1kZWZhdWx0c0RlZXA7bG9kYXNoLmRlZmVyPWRlZmVyO2xvZGFzaC5kZWxheT1kZWxheTtsb2Rhc2guZGlmZmVyZW5jZT1kaWZmZXJlbmNlO2xvZGFzaC5kaWZmZXJlbmNlQnk9ZGlmZmVyZW5jZUJ5O2xvZGFzaC5kaWZmZXJlbmNlV2l0aD1kaWZmZXJlbmNlV2l0aDtsb2Rhc2guZHJvcD1kcm9wO2xvZGFzaC5kcm9wUmlnaHQ9ZHJvcFJpZ2h0O2xvZGFzaC5kcm9wUmlnaHRXaGlsZT1kcm9wUmlnaHRXaGlsZTtsb2Rhc2guZHJvcFdoaWxlPWRyb3BXaGlsZTtsb2Rhc2guZmlsbD1maWxsO2xvZGFzaC5maWx0ZXI9ZmlsdGVyO2xvZGFzaC5mbGF0TWFwPWZsYXRNYXA7bG9kYXNoLmZsYXRNYXBEZWVwPWZsYXRNYXBEZWVwO2xvZGFzaC5mbGF0TWFwRGVwdGg9ZmxhdE1hcERlcHRoO2xvZGFzaC5mbGF0dGVuPWZsYXR0ZW47bG9kYXNoLmZsYXR0ZW5EZWVwPWZsYXR0ZW5EZWVwO2xvZGFzaC5mbGF0dGVuRGVwdGg9ZmxhdHRlbkRlcHRoO2xvZGFzaC5mbGlwPWZsaXA7bG9kYXNoLmZsb3c9Zmxvdztsb2Rhc2guZmxvd1JpZ2h0PWZsb3dSaWdodDtsb2Rhc2guZnJvbVBhaXJzPWZyb21QYWlycztsb2Rhc2guZnVuY3Rpb25zPWZ1bmN0aW9ucztsb2Rhc2guZnVuY3Rpb25zSW49ZnVuY3Rpb25zSW47bG9kYXNoLmdyb3VwQnk9Z3JvdXBCeTtsb2Rhc2guaW5pdGlhbD1pbml0aWFsO2xvZGFzaC5pbnRlcnNlY3Rpb249aW50ZXJzZWN0aW9uO2xvZGFzaC5pbnRlcnNlY3Rpb25CeT1pbnRlcnNlY3Rpb25CeTtsb2Rhc2guaW50ZXJzZWN0aW9uV2l0aD1pbnRlcnNlY3Rpb25XaXRoO2xvZGFzaC5pbnZlcnQ9aW52ZXJ0O2xvZGFzaC5pbnZlcnRCeT1pbnZlcnRCeTtsb2Rhc2guaW52b2tlTWFwPWludm9rZU1hcDtsb2Rhc2guaXRlcmF0ZWU9aXRlcmF0ZWU7bG9kYXNoLmtleUJ5PWtleUJ5O2xvZGFzaC5rZXlzPWtleXM7bG9kYXNoLmtleXNJbj1rZXlzSW47bG9kYXNoLm1hcD1tYXA7bG9kYXNoLm1hcEtleXM9bWFwS2V5cztsb2Rhc2gubWFwVmFsdWVzPW1hcFZhbHVlcztsb2Rhc2gubWF0Y2hlcz1tYXRjaGVzO2xvZGFzaC5tYXRjaGVzUHJvcGVydHk9bWF0Y2hlc1Byb3BlcnR5O2xvZGFzaC5tZW1vaXplPW1lbW9pemU7bG9kYXNoLm1lcmdlPW1lcmdlO2xvZGFzaC5tZXJnZVdpdGg9bWVyZ2VXaXRoO2xvZGFzaC5tZXRob2Q9bWV0aG9kO2xvZGFzaC5tZXRob2RPZj1tZXRob2RPZjtsb2Rhc2gubWl4aW49bWl4aW47bG9kYXNoLm5lZ2F0ZT1uZWdhdGU7bG9kYXNoLm50aEFyZz1udGhBcmc7bG9kYXNoLm9taXQ9b21pdDtsb2Rhc2gub21pdEJ5PW9taXRCeTtsb2Rhc2gub25jZT1vbmNlO2xvZGFzaC5vcmRlckJ5PW9yZGVyQnk7bG9kYXNoLm92ZXI9b3Zlcjtsb2Rhc2gub3ZlckFyZ3M9b3ZlckFyZ3M7bG9kYXNoLm92ZXJFdmVyeT1vdmVyRXZlcnk7bG9kYXNoLm92ZXJTb21lPW92ZXJTb21lO2xvZGFzaC5wYXJ0aWFsPXBhcnRpYWw7bG9kYXNoLnBhcnRpYWxSaWdodD1wYXJ0aWFsUmlnaHQ7bG9kYXNoLnBhcnRpdGlvbj1wYXJ0aXRpb247bG9kYXNoLnBpY2s9cGljaztsb2Rhc2gucGlja0J5PXBpY2tCeTtsb2Rhc2gucHJvcGVydHk9cHJvcGVydHk7bG9kYXNoLnByb3BlcnR5T2Y9cHJvcGVydHlPZjtsb2Rhc2gucHVsbD1wdWxsO2xvZGFzaC5wdWxsQWxsPXB1bGxBbGw7bG9kYXNoLnB1bGxBbGxCeT1wdWxsQWxsQnk7bG9kYXNoLnB1bGxBbGxXaXRoPXB1bGxBbGxXaXRoO2xvZGFzaC5wdWxsQXQ9cHVsbEF0O2xvZGFzaC5yYW5nZT1yYW5nZTtsb2Rhc2gucmFuZ2VSaWdodD1yYW5nZVJpZ2h0O2xvZGFzaC5yZWFyZz1yZWFyZztsb2Rhc2gucmVqZWN0PXJlamVjdDtsb2Rhc2gucmVtb3ZlPXJlbW92ZTtsb2Rhc2gucmVzdD1yZXN0O2xvZGFzaC5yZXZlcnNlPXJldmVyc2U7bG9kYXNoLnNhbXBsZVNpemU9c2FtcGxlU2l6ZTtsb2Rhc2guc2V0PXNldDtsb2Rhc2guc2V0V2l0aD1zZXRXaXRoO2xvZGFzaC5zaHVmZmxlPXNodWZmbGU7bG9kYXNoLnNsaWNlPXNsaWNlO2xvZGFzaC5zb3J0Qnk9c29ydEJ5O2xvZGFzaC5zb3J0ZWRVbmlxPXNvcnRlZFVuaXE7bG9kYXNoLnNvcnRlZFVuaXFCeT1zb3J0ZWRVbmlxQnk7bG9kYXNoLnNwbGl0PXNwbGl0O2xvZGFzaC5zcHJlYWQ9c3ByZWFkO2xvZGFzaC50YWlsPXRhaWw7bG9kYXNoLnRha2U9dGFrZTtsb2Rhc2gudGFrZVJpZ2h0PXRha2VSaWdodDtsb2Rhc2gudGFrZVJpZ2h0V2hpbGU9dGFrZVJpZ2h0V2hpbGU7bG9kYXNoLnRha2VXaGlsZT10YWtlV2hpbGU7bG9kYXNoLnRhcD10YXA7bG9kYXNoLnRocm90dGxlPXRocm90dGxlO2xvZGFzaC50aHJ1PXRocnU7bG9kYXNoLnRvQXJyYXk9dG9BcnJheTtsb2Rhc2gudG9QYWlycz10b1BhaXJzO2xvZGFzaC50b1BhaXJzSW49dG9QYWlyc0luO2xvZGFzaC50b1BhdGg9dG9QYXRoO2xvZGFzaC50b1BsYWluT2JqZWN0PXRvUGxhaW5PYmplY3Q7bG9kYXNoLnRyYW5zZm9ybT10cmFuc2Zvcm07bG9kYXNoLnVuYXJ5PXVuYXJ5O2xvZGFzaC51bmlvbj11bmlvbjtsb2Rhc2gudW5pb25CeT11bmlvbkJ5O2xvZGFzaC51bmlvbldpdGg9dW5pb25XaXRoO2xvZGFzaC51bmlxPXVuaXE7bG9kYXNoLnVuaXFCeT11bmlxQnk7bG9kYXNoLnVuaXFXaXRoPXVuaXFXaXRoO2xvZGFzaC51bnNldD11bnNldDtsb2Rhc2gudW56aXA9dW56aXA7bG9kYXNoLnVuemlwV2l0aD11bnppcFdpdGg7bG9kYXNoLnVwZGF0ZT11cGRhdGU7bG9kYXNoLnVwZGF0ZVdpdGg9dXBkYXRlV2l0aDtsb2Rhc2gudmFsdWVzPXZhbHVlcztsb2Rhc2gudmFsdWVzSW49dmFsdWVzSW47bG9kYXNoLndpdGhvdXQ9d2l0aG91dDtsb2Rhc2gud29yZHM9d29yZHM7bG9kYXNoLndyYXA9d3JhcDtsb2Rhc2gueG9yPXhvcjtsb2Rhc2gueG9yQnk9eG9yQnk7bG9kYXNoLnhvcldpdGg9eG9yV2l0aDtsb2Rhc2guemlwPXppcDtsb2Rhc2guemlwT2JqZWN0PXppcE9iamVjdDtsb2Rhc2guemlwT2JqZWN0RGVlcD16aXBPYmplY3REZWVwO2xvZGFzaC56aXBXaXRoPXppcFdpdGg7Ly8gQWRkIGFsaWFzZXMuXG5sb2Rhc2guZW50cmllcz10b1BhaXJzO2xvZGFzaC5lbnRyaWVzSW49dG9QYWlyc0luO2xvZGFzaC5leHRlbmQ9YXNzaWduSW47bG9kYXNoLmV4dGVuZFdpdGg9YXNzaWduSW5XaXRoOy8vIEFkZCBtZXRob2RzIHRvIGBsb2Rhc2gucHJvdG90eXBlYC5cbm1peGluKGxvZGFzaCxsb2Rhc2gpOy8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi8vLyBBZGQgbWV0aG9kcyB0aGF0IHJldHVybiB1bndyYXBwZWQgdmFsdWVzIGluIGNoYWluIHNlcXVlbmNlcy5cbmxvZGFzaC5hZGQ9YWRkO2xvZGFzaC5hdHRlbXB0PWF0dGVtcHQ7bG9kYXNoLmNhbWVsQ2FzZT1jYW1lbENhc2U7bG9kYXNoLmNhcGl0YWxpemU9Y2FwaXRhbGl6ZTtsb2Rhc2guY2VpbD1jZWlsO2xvZGFzaC5jbGFtcD1jbGFtcDtsb2Rhc2guY2xvbmU9Y2xvbmU7bG9kYXNoLmNsb25lRGVlcD1jbG9uZURlZXA7bG9kYXNoLmNsb25lRGVlcFdpdGg9Y2xvbmVEZWVwV2l0aDtsb2Rhc2guY2xvbmVXaXRoPWNsb25lV2l0aDtsb2Rhc2guY29uZm9ybXNUbz1jb25mb3Jtc1RvO2xvZGFzaC5kZWJ1cnI9ZGVidXJyO2xvZGFzaC5kZWZhdWx0VG89ZGVmYXVsdFRvO2xvZGFzaC5kaXZpZGU9ZGl2aWRlO2xvZGFzaC5lbmRzV2l0aD1lbmRzV2l0aDtsb2Rhc2guZXE9ZXE7bG9kYXNoLmVzY2FwZT1lc2NhcGU7bG9kYXNoLmVzY2FwZVJlZ0V4cD1lc2NhcGVSZWdFeHA7bG9kYXNoLmV2ZXJ5PWV2ZXJ5O2xvZGFzaC5maW5kPWZpbmQ7bG9kYXNoLmZpbmRJbmRleD1maW5kSW5kZXg7bG9kYXNoLmZpbmRLZXk9ZmluZEtleTtsb2Rhc2guZmluZExhc3Q9ZmluZExhc3Q7bG9kYXNoLmZpbmRMYXN0SW5kZXg9ZmluZExhc3RJbmRleDtsb2Rhc2guZmluZExhc3RLZXk9ZmluZExhc3RLZXk7bG9kYXNoLmZsb29yPWZsb29yO2xvZGFzaC5mb3JFYWNoPWZvckVhY2g7bG9kYXNoLmZvckVhY2hSaWdodD1mb3JFYWNoUmlnaHQ7bG9kYXNoLmZvckluPWZvckluO2xvZGFzaC5mb3JJblJpZ2h0PWZvckluUmlnaHQ7bG9kYXNoLmZvck93bj1mb3JPd247bG9kYXNoLmZvck93blJpZ2h0PWZvck93blJpZ2h0O2xvZGFzaC5nZXQ9Z2V0O2xvZGFzaC5ndD1ndDtsb2Rhc2guZ3RlPWd0ZTtsb2Rhc2guaGFzPWhhcztsb2Rhc2guaGFzSW49aGFzSW47bG9kYXNoLmhlYWQ9aGVhZDtsb2Rhc2guaWRlbnRpdHk9aWRlbnRpdHk7bG9kYXNoLmluY2x1ZGVzPWluY2x1ZGVzO2xvZGFzaC5pbmRleE9mPWluZGV4T2Y7bG9kYXNoLmluUmFuZ2U9aW5SYW5nZTtsb2Rhc2guaW52b2tlPWludm9rZTtsb2Rhc2guaXNBcmd1bWVudHM9aXNBcmd1bWVudHM7bG9kYXNoLmlzQXJyYXk9aXNBcnJheTtsb2Rhc2guaXNBcnJheUJ1ZmZlcj1pc0FycmF5QnVmZmVyO2xvZGFzaC5pc0FycmF5TGlrZT1pc0FycmF5TGlrZTtsb2Rhc2guaXNBcnJheUxpa2VPYmplY3Q9aXNBcnJheUxpa2VPYmplY3Q7bG9kYXNoLmlzQm9vbGVhbj1pc0Jvb2xlYW47bG9kYXNoLmlzQnVmZmVyPWlzQnVmZmVyO2xvZGFzaC5pc0RhdGU9aXNEYXRlO2xvZGFzaC5pc0VsZW1lbnQ9aXNFbGVtZW50O2xvZGFzaC5pc0VtcHR5PWlzRW1wdHk7bG9kYXNoLmlzRXF1YWw9aXNFcXVhbDtsb2Rhc2guaXNFcXVhbFdpdGg9aXNFcXVhbFdpdGg7bG9kYXNoLmlzRXJyb3I9aXNFcnJvcjtsb2Rhc2guaXNGaW5pdGU9aXNGaW5pdGU7bG9kYXNoLmlzRnVuY3Rpb249aXNGdW5jdGlvbjtsb2Rhc2guaXNJbnRlZ2VyPWlzSW50ZWdlcjtsb2Rhc2guaXNMZW5ndGg9aXNMZW5ndGg7bG9kYXNoLmlzTWFwPWlzTWFwO2xvZGFzaC5pc01hdGNoPWlzTWF0Y2g7bG9kYXNoLmlzTWF0Y2hXaXRoPWlzTWF0Y2hXaXRoO2xvZGFzaC5pc05hTj1pc05hTjtsb2Rhc2guaXNOYXRpdmU9aXNOYXRpdmU7bG9kYXNoLmlzTmlsPWlzTmlsO2xvZGFzaC5pc051bGw9aXNOdWxsO2xvZGFzaC5pc051bWJlcj1pc051bWJlcjtsb2Rhc2guaXNPYmplY3Q9aXNPYmplY3Q7bG9kYXNoLmlzT2JqZWN0TGlrZT1pc09iamVjdExpa2U7bG9kYXNoLmlzUGxhaW5PYmplY3Q9aXNQbGFpbk9iamVjdDtsb2Rhc2guaXNSZWdFeHA9aXNSZWdFeHA7bG9kYXNoLmlzU2FmZUludGVnZXI9aXNTYWZlSW50ZWdlcjtsb2Rhc2guaXNTZXQ9aXNTZXQ7bG9kYXNoLmlzU3RyaW5nPWlzU3RyaW5nO2xvZGFzaC5pc1N5bWJvbD1pc1N5bWJvbDtsb2Rhc2guaXNUeXBlZEFycmF5PWlzVHlwZWRBcnJheTtsb2Rhc2guaXNVbmRlZmluZWQ9aXNVbmRlZmluZWQ7bG9kYXNoLmlzV2Vha01hcD1pc1dlYWtNYXA7bG9kYXNoLmlzV2Vha1NldD1pc1dlYWtTZXQ7bG9kYXNoLmpvaW49am9pbjtsb2Rhc2gua2ViYWJDYXNlPWtlYmFiQ2FzZTtsb2Rhc2gubGFzdD1sYXN0O2xvZGFzaC5sYXN0SW5kZXhPZj1sYXN0SW5kZXhPZjtsb2Rhc2gubG93ZXJDYXNlPWxvd2VyQ2FzZTtsb2Rhc2gubG93ZXJGaXJzdD1sb3dlckZpcnN0O2xvZGFzaC5sdD1sdDtsb2Rhc2gubHRlPWx0ZTtsb2Rhc2gubWF4PW1heDtsb2Rhc2gubWF4Qnk9bWF4Qnk7bG9kYXNoLm1lYW49bWVhbjtsb2Rhc2gubWVhbkJ5PW1lYW5CeTtsb2Rhc2gubWluPW1pbjtsb2Rhc2gubWluQnk9bWluQnk7bG9kYXNoLnN0dWJBcnJheT1zdHViQXJyYXk7bG9kYXNoLnN0dWJGYWxzZT1zdHViRmFsc2U7bG9kYXNoLnN0dWJPYmplY3Q9c3R1Yk9iamVjdDtsb2Rhc2guc3R1YlN0cmluZz1zdHViU3RyaW5nO2xvZGFzaC5zdHViVHJ1ZT1zdHViVHJ1ZTtsb2Rhc2gubXVsdGlwbHk9bXVsdGlwbHk7bG9kYXNoLm50aD1udGg7bG9kYXNoLm5vQ29uZmxpY3Q9bm9Db25mbGljdDtsb2Rhc2gubm9vcD1ub29wO2xvZGFzaC5ub3c9bm93O2xvZGFzaC5wYWQ9cGFkO2xvZGFzaC5wYWRFbmQ9cGFkRW5kO2xvZGFzaC5wYWRTdGFydD1wYWRTdGFydDtsb2Rhc2gucGFyc2VJbnQ9cGFyc2VJbnQ7bG9kYXNoLnJhbmRvbT1yYW5kb207bG9kYXNoLnJlZHVjZT1yZWR1Y2U7bG9kYXNoLnJlZHVjZVJpZ2h0PXJlZHVjZVJpZ2h0O2xvZGFzaC5yZXBlYXQ9cmVwZWF0O2xvZGFzaC5yZXBsYWNlPXJlcGxhY2U7bG9kYXNoLnJlc3VsdD1yZXN1bHQ7bG9kYXNoLnJvdW5kPXJvdW5kO2xvZGFzaC5ydW5JbkNvbnRleHQ9cnVuSW5Db250ZXh0O2xvZGFzaC5zYW1wbGU9c2FtcGxlO2xvZGFzaC5zaXplPXNpemU7bG9kYXNoLnNuYWtlQ2FzZT1zbmFrZUNhc2U7bG9kYXNoLnNvbWU9c29tZTtsb2Rhc2guc29ydGVkSW5kZXg9c29ydGVkSW5kZXg7bG9kYXNoLnNvcnRlZEluZGV4Qnk9c29ydGVkSW5kZXhCeTtsb2Rhc2guc29ydGVkSW5kZXhPZj1zb3J0ZWRJbmRleE9mO2xvZGFzaC5zb3J0ZWRMYXN0SW5kZXg9c29ydGVkTGFzdEluZGV4O2xvZGFzaC5zb3J0ZWRMYXN0SW5kZXhCeT1zb3J0ZWRMYXN0SW5kZXhCeTtsb2Rhc2guc29ydGVkTGFzdEluZGV4T2Y9c29ydGVkTGFzdEluZGV4T2Y7bG9kYXNoLnN0YXJ0Q2FzZT1zdGFydENhc2U7bG9kYXNoLnN0YXJ0c1dpdGg9c3RhcnRzV2l0aDtsb2Rhc2guc3VidHJhY3Q9c3VidHJhY3Q7bG9kYXNoLnN1bT1zdW07bG9kYXNoLnN1bUJ5PXN1bUJ5O2xvZGFzaC50ZW1wbGF0ZT10ZW1wbGF0ZTtsb2Rhc2gudGltZXM9dGltZXM7bG9kYXNoLnRvRmluaXRlPXRvRmluaXRlO2xvZGFzaC50b0ludGVnZXI9dG9JbnRlZ2VyO2xvZGFzaC50b0xlbmd0aD10b0xlbmd0aDtsb2Rhc2gudG9Mb3dlcj10b0xvd2VyO2xvZGFzaC50b051bWJlcj10b051bWJlcjtsb2Rhc2gudG9TYWZlSW50ZWdlcj10b1NhZmVJbnRlZ2VyO2xvZGFzaC50b1N0cmluZz10b1N0cmluZztsb2Rhc2gudG9VcHBlcj10b1VwcGVyO2xvZGFzaC50cmltPXRyaW07bG9kYXNoLnRyaW1FbmQ9dHJpbUVuZDtsb2Rhc2gudHJpbVN0YXJ0PXRyaW1TdGFydDtsb2Rhc2gudHJ1bmNhdGU9dHJ1bmNhdGU7bG9kYXNoLnVuZXNjYXBlPXVuZXNjYXBlO2xvZGFzaC51bmlxdWVJZD11bmlxdWVJZDtsb2Rhc2gudXBwZXJDYXNlPXVwcGVyQ2FzZTtsb2Rhc2gudXBwZXJGaXJzdD11cHBlckZpcnN0Oy8vIEFkZCBhbGlhc2VzLlxubG9kYXNoLmVhY2g9Zm9yRWFjaDtsb2Rhc2guZWFjaFJpZ2h0PWZvckVhY2hSaWdodDtsb2Rhc2guZmlyc3Q9aGVhZDttaXhpbihsb2Rhc2gsZnVuY3Rpb24oKXt2YXIgc291cmNlPXt9O2Jhc2VGb3JPd24obG9kYXNoLGZ1bmN0aW9uKGZ1bmMsbWV0aG9kTmFtZSl7aWYoIWhhc093blByb3BlcnR5LmNhbGwobG9kYXNoLnByb3RvdHlwZSxtZXRob2ROYW1lKSl7c291cmNlW21ldGhvZE5hbWVdPWZ1bmM7fX0pO3JldHVybiBzb3VyY2U7fSgpLHsnY2hhaW4nOmZhbHNlfSk7LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qLy8qKlxuICAgICAqIFRoZSBzZW1hbnRpYyB2ZXJzaW9uIG51bWJlci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovbG9kYXNoLlZFUlNJT049VkVSU0lPTjsvLyBBc3NpZ24gZGVmYXVsdCBwbGFjZWhvbGRlcnMuXG5hcnJheUVhY2goWydiaW5kJywnYmluZEtleScsJ2N1cnJ5JywnY3VycnlSaWdodCcsJ3BhcnRpYWwnLCdwYXJ0aWFsUmlnaHQnXSxmdW5jdGlvbihtZXRob2ROYW1lKXtsb2Rhc2hbbWV0aG9kTmFtZV0ucGxhY2Vob2xkZXI9bG9kYXNoO30pOy8vIEFkZCBgTGF6eVdyYXBwZXJgIG1ldGhvZHMgZm9yIGBfLmRyb3BgIGFuZCBgXy50YWtlYCB2YXJpYW50cy5cbmFycmF5RWFjaChbJ2Ryb3AnLCd0YWtlJ10sZnVuY3Rpb24obWV0aG9kTmFtZSxpbmRleCl7TGF6eVdyYXBwZXIucHJvdG90eXBlW21ldGhvZE5hbWVdPWZ1bmN0aW9uKG4pe249bj09PXVuZGVmaW5lZD8xOm5hdGl2ZU1heCh0b0ludGVnZXIobiksMCk7dmFyIHJlc3VsdD10aGlzLl9fZmlsdGVyZWRfXyYmIWluZGV4P25ldyBMYXp5V3JhcHBlcih0aGlzKTp0aGlzLmNsb25lKCk7aWYocmVzdWx0Ll9fZmlsdGVyZWRfXyl7cmVzdWx0Ll9fdGFrZUNvdW50X189bmF0aXZlTWluKG4scmVzdWx0Ll9fdGFrZUNvdW50X18pO31lbHNle3Jlc3VsdC5fX3ZpZXdzX18ucHVzaCh7J3NpemUnOm5hdGl2ZU1pbihuLE1BWF9BUlJBWV9MRU5HVEgpLCd0eXBlJzptZXRob2ROYW1lKyhyZXN1bHQuX19kaXJfXzwwPydSaWdodCc6JycpfSk7fXJldHVybiByZXN1bHQ7fTtMYXp5V3JhcHBlci5wcm90b3R5cGVbbWV0aG9kTmFtZSsnUmlnaHQnXT1mdW5jdGlvbihuKXtyZXR1cm4gdGhpcy5yZXZlcnNlKClbbWV0aG9kTmFtZV0obikucmV2ZXJzZSgpO307fSk7Ly8gQWRkIGBMYXp5V3JhcHBlcmAgbWV0aG9kcyB0aGF0IGFjY2VwdCBhbiBgaXRlcmF0ZWVgIHZhbHVlLlxuYXJyYXlFYWNoKFsnZmlsdGVyJywnbWFwJywndGFrZVdoaWxlJ10sZnVuY3Rpb24obWV0aG9kTmFtZSxpbmRleCl7dmFyIHR5cGU9aW5kZXgrMSxpc0ZpbHRlcj10eXBlPT1MQVpZX0ZJTFRFUl9GTEFHfHx0eXBlPT1MQVpZX1dISUxFX0ZMQUc7TGF6eVdyYXBwZXIucHJvdG90eXBlW21ldGhvZE5hbWVdPWZ1bmN0aW9uKGl0ZXJhdGVlKXt2YXIgcmVzdWx0PXRoaXMuY2xvbmUoKTtyZXN1bHQuX19pdGVyYXRlZXNfXy5wdXNoKHsnaXRlcmF0ZWUnOmdldEl0ZXJhdGVlKGl0ZXJhdGVlLDMpLCd0eXBlJzp0eXBlfSk7cmVzdWx0Ll9fZmlsdGVyZWRfXz1yZXN1bHQuX19maWx0ZXJlZF9ffHxpc0ZpbHRlcjtyZXR1cm4gcmVzdWx0O307fSk7Ly8gQWRkIGBMYXp5V3JhcHBlcmAgbWV0aG9kcyBmb3IgYF8uaGVhZGAgYW5kIGBfLmxhc3RgLlxuYXJyYXlFYWNoKFsnaGVhZCcsJ2xhc3QnXSxmdW5jdGlvbihtZXRob2ROYW1lLGluZGV4KXt2YXIgdGFrZU5hbWU9J3Rha2UnKyhpbmRleD8nUmlnaHQnOicnKTtMYXp5V3JhcHBlci5wcm90b3R5cGVbbWV0aG9kTmFtZV09ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc1t0YWtlTmFtZV0oMSkudmFsdWUoKVswXTt9O30pOy8vIEFkZCBgTGF6eVdyYXBwZXJgIG1ldGhvZHMgZm9yIGBfLmluaXRpYWxgIGFuZCBgXy50YWlsYC5cbmFycmF5RWFjaChbJ2luaXRpYWwnLCd0YWlsJ10sZnVuY3Rpb24obWV0aG9kTmFtZSxpbmRleCl7dmFyIGRyb3BOYW1lPSdkcm9wJysoaW5kZXg/Jyc6J1JpZ2h0Jyk7TGF6eVdyYXBwZXIucHJvdG90eXBlW21ldGhvZE5hbWVdPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX19maWx0ZXJlZF9fP25ldyBMYXp5V3JhcHBlcih0aGlzKTp0aGlzW2Ryb3BOYW1lXSgxKTt9O30pO0xhenlXcmFwcGVyLnByb3RvdHlwZS5jb21wYWN0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZmlsdGVyKGlkZW50aXR5KTt9O0xhenlXcmFwcGVyLnByb3RvdHlwZS5maW5kPWZ1bmN0aW9uKHByZWRpY2F0ZSl7cmV0dXJuIHRoaXMuZmlsdGVyKHByZWRpY2F0ZSkuaGVhZCgpO307TGF6eVdyYXBwZXIucHJvdG90eXBlLmZpbmRMYXN0PWZ1bmN0aW9uKHByZWRpY2F0ZSl7cmV0dXJuIHRoaXMucmV2ZXJzZSgpLmZpbmQocHJlZGljYXRlKTt9O0xhenlXcmFwcGVyLnByb3RvdHlwZS5pbnZva2VNYXA9YmFzZVJlc3QoZnVuY3Rpb24ocGF0aCxhcmdzKXtpZih0eXBlb2YgcGF0aD09J2Z1bmN0aW9uJyl7cmV0dXJuIG5ldyBMYXp5V3JhcHBlcih0aGlzKTt9cmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uKHZhbHVlKXtyZXR1cm4gYmFzZUludm9rZSh2YWx1ZSxwYXRoLGFyZ3MpO30pO30pO0xhenlXcmFwcGVyLnByb3RvdHlwZS5yZWplY3Q9ZnVuY3Rpb24ocHJlZGljYXRlKXtyZXR1cm4gdGhpcy5maWx0ZXIobmVnYXRlKGdldEl0ZXJhdGVlKHByZWRpY2F0ZSkpKTt9O0xhenlXcmFwcGVyLnByb3RvdHlwZS5zbGljZT1mdW5jdGlvbihzdGFydCxlbmQpe3N0YXJ0PXRvSW50ZWdlcihzdGFydCk7dmFyIHJlc3VsdD10aGlzO2lmKHJlc3VsdC5fX2ZpbHRlcmVkX18mJihzdGFydD4wfHxlbmQ8MCkpe3JldHVybiBuZXcgTGF6eVdyYXBwZXIocmVzdWx0KTt9aWYoc3RhcnQ8MCl7cmVzdWx0PXJlc3VsdC50YWtlUmlnaHQoLXN0YXJ0KTt9ZWxzZSBpZihzdGFydCl7cmVzdWx0PXJlc3VsdC5kcm9wKHN0YXJ0KTt9aWYoZW5kIT09dW5kZWZpbmVkKXtlbmQ9dG9JbnRlZ2VyKGVuZCk7cmVzdWx0PWVuZDwwP3Jlc3VsdC5kcm9wUmlnaHQoLWVuZCk6cmVzdWx0LnRha2UoZW5kLXN0YXJ0KTt9cmV0dXJuIHJlc3VsdDt9O0xhenlXcmFwcGVyLnByb3RvdHlwZS50YWtlUmlnaHRXaGlsZT1mdW5jdGlvbihwcmVkaWNhdGUpe3JldHVybiB0aGlzLnJldmVyc2UoKS50YWtlV2hpbGUocHJlZGljYXRlKS5yZXZlcnNlKCk7fTtMYXp5V3JhcHBlci5wcm90b3R5cGUudG9BcnJheT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRha2UoTUFYX0FSUkFZX0xFTkdUSCk7fTsvLyBBZGQgYExhenlXcmFwcGVyYCBtZXRob2RzIHRvIGBsb2Rhc2gucHJvdG90eXBlYC5cbmJhc2VGb3JPd24oTGF6eVdyYXBwZXIucHJvdG90eXBlLGZ1bmN0aW9uKGZ1bmMsbWV0aG9kTmFtZSl7dmFyIGNoZWNrSXRlcmF0ZWU9L14oPzpmaWx0ZXJ8ZmluZHxtYXB8cmVqZWN0KXxXaGlsZSQvLnRlc3QobWV0aG9kTmFtZSksaXNUYWtlcj0vXig/OmhlYWR8bGFzdCkkLy50ZXN0KG1ldGhvZE5hbWUpLGxvZGFzaEZ1bmM9bG9kYXNoW2lzVGFrZXI/J3Rha2UnKyhtZXRob2ROYW1lPT0nbGFzdCc/J1JpZ2h0JzonJyk6bWV0aG9kTmFtZV0scmV0VW53cmFwcGVkPWlzVGFrZXJ8fC9eZmluZC8udGVzdChtZXRob2ROYW1lKTtpZighbG9kYXNoRnVuYyl7cmV0dXJuO31sb2Rhc2gucHJvdG90eXBlW21ldGhvZE5hbWVdPWZ1bmN0aW9uKCl7dmFyIHZhbHVlPXRoaXMuX193cmFwcGVkX18sYXJncz1pc1Rha2VyP1sxXTphcmd1bWVudHMsaXNMYXp5PXZhbHVlIGluc3RhbmNlb2YgTGF6eVdyYXBwZXIsaXRlcmF0ZWU9YXJnc1swXSx1c2VMYXp5PWlzTGF6eXx8aXNBcnJheSh2YWx1ZSk7dmFyIGludGVyY2VwdG9yPWZ1bmN0aW9uKHZhbHVlKXt2YXIgcmVzdWx0PWxvZGFzaEZ1bmMuYXBwbHkobG9kYXNoLGFycmF5UHVzaChbdmFsdWVdLGFyZ3MpKTtyZXR1cm4gaXNUYWtlciYmY2hhaW5BbGw/cmVzdWx0WzBdOnJlc3VsdDt9O2lmKHVzZUxhenkmJmNoZWNrSXRlcmF0ZWUmJnR5cGVvZiBpdGVyYXRlZT09J2Z1bmN0aW9uJyYmaXRlcmF0ZWUubGVuZ3RoIT0xKXsvLyBBdm9pZCBsYXp5IHVzZSBpZiB0aGUgaXRlcmF0ZWUgaGFzIGEgXCJsZW5ndGhcIiB2YWx1ZSBvdGhlciB0aGFuIGAxYC5cbmlzTGF6eT11c2VMYXp5PWZhbHNlO312YXIgY2hhaW5BbGw9dGhpcy5fX2NoYWluX18saXNIeWJyaWQ9ISF0aGlzLl9fYWN0aW9uc19fLmxlbmd0aCxpc1Vud3JhcHBlZD1yZXRVbndyYXBwZWQmJiFjaGFpbkFsbCxvbmx5TGF6eT1pc0xhenkmJiFpc0h5YnJpZDtpZighcmV0VW53cmFwcGVkJiZ1c2VMYXp5KXt2YWx1ZT1vbmx5TGF6eT92YWx1ZTpuZXcgTGF6eVdyYXBwZXIodGhpcyk7dmFyIHJlc3VsdD1mdW5jLmFwcGx5KHZhbHVlLGFyZ3MpO3Jlc3VsdC5fX2FjdGlvbnNfXy5wdXNoKHsnZnVuYyc6dGhydSwnYXJncyc6W2ludGVyY2VwdG9yXSwndGhpc0FyZyc6dW5kZWZpbmVkfSk7cmV0dXJuIG5ldyBMb2Rhc2hXcmFwcGVyKHJlc3VsdCxjaGFpbkFsbCk7fWlmKGlzVW53cmFwcGVkJiZvbmx5TGF6eSl7cmV0dXJuIGZ1bmMuYXBwbHkodGhpcyxhcmdzKTt9cmVzdWx0PXRoaXMudGhydShpbnRlcmNlcHRvcik7cmV0dXJuIGlzVW53cmFwcGVkP2lzVGFrZXI/cmVzdWx0LnZhbHVlKClbMF06cmVzdWx0LnZhbHVlKCk6cmVzdWx0O307fSk7Ly8gQWRkIGBBcnJheWAgbWV0aG9kcyB0byBgbG9kYXNoLnByb3RvdHlwZWAuXG5hcnJheUVhY2goWydwb3AnLCdwdXNoJywnc2hpZnQnLCdzb3J0Jywnc3BsaWNlJywndW5zaGlmdCddLGZ1bmN0aW9uKG1ldGhvZE5hbWUpe3ZhciBmdW5jPWFycmF5UHJvdG9bbWV0aG9kTmFtZV0sY2hhaW5OYW1lPS9eKD86cHVzaHxzb3J0fHVuc2hpZnQpJC8udGVzdChtZXRob2ROYW1lKT8ndGFwJzondGhydScscmV0VW53cmFwcGVkPS9eKD86cG9wfHNoaWZ0KSQvLnRlc3QobWV0aG9kTmFtZSk7bG9kYXNoLnByb3RvdHlwZVttZXRob2ROYW1lXT1mdW5jdGlvbigpe3ZhciBhcmdzPWFyZ3VtZW50cztpZihyZXRVbndyYXBwZWQmJiF0aGlzLl9fY2hhaW5fXyl7dmFyIHZhbHVlPXRoaXMudmFsdWUoKTtyZXR1cm4gZnVuYy5hcHBseShpc0FycmF5KHZhbHVlKT92YWx1ZTpbXSxhcmdzKTt9cmV0dXJuIHRoaXNbY2hhaW5OYW1lXShmdW5jdGlvbih2YWx1ZSl7cmV0dXJuIGZ1bmMuYXBwbHkoaXNBcnJheSh2YWx1ZSk/dmFsdWU6W10sYXJncyk7fSk7fTt9KTsvLyBNYXAgbWluaWZpZWQgbWV0aG9kIG5hbWVzIHRvIHRoZWlyIHJlYWwgbmFtZXMuXG5iYXNlRm9yT3duKExhenlXcmFwcGVyLnByb3RvdHlwZSxmdW5jdGlvbihmdW5jLG1ldGhvZE5hbWUpe3ZhciBsb2Rhc2hGdW5jPWxvZGFzaFttZXRob2ROYW1lXTtpZihsb2Rhc2hGdW5jKXt2YXIga2V5PWxvZGFzaEZ1bmMubmFtZSsnJyxuYW1lcz1yZWFsTmFtZXNba2V5XXx8KHJlYWxOYW1lc1trZXldPVtdKTtuYW1lcy5wdXNoKHsnbmFtZSc6bWV0aG9kTmFtZSwnZnVuYyc6bG9kYXNoRnVuY30pO319KTtyZWFsTmFtZXNbY3JlYXRlSHlicmlkKHVuZGVmaW5lZCxXUkFQX0JJTkRfS0VZX0ZMQUcpLm5hbWVdPVt7J25hbWUnOid3cmFwcGVyJywnZnVuYyc6dW5kZWZpbmVkfV07Ly8gQWRkIG1ldGhvZHMgdG8gYExhenlXcmFwcGVyYC5cbkxhenlXcmFwcGVyLnByb3RvdHlwZS5jbG9uZT1sYXp5Q2xvbmU7TGF6eVdyYXBwZXIucHJvdG90eXBlLnJldmVyc2U9bGF6eVJldmVyc2U7TGF6eVdyYXBwZXIucHJvdG90eXBlLnZhbHVlPWxhenlWYWx1ZTsvLyBBZGQgY2hhaW4gc2VxdWVuY2UgbWV0aG9kcyB0byB0aGUgYGxvZGFzaGAgd3JhcHBlci5cbmxvZGFzaC5wcm90b3R5cGUuYXQ9d3JhcHBlckF0O2xvZGFzaC5wcm90b3R5cGUuY2hhaW49d3JhcHBlckNoYWluO2xvZGFzaC5wcm90b3R5cGUuY29tbWl0PXdyYXBwZXJDb21taXQ7bG9kYXNoLnByb3RvdHlwZS5uZXh0PXdyYXBwZXJOZXh0O2xvZGFzaC5wcm90b3R5cGUucGxhbnQ9d3JhcHBlclBsYW50O2xvZGFzaC5wcm90b3R5cGUucmV2ZXJzZT13cmFwcGVyUmV2ZXJzZTtsb2Rhc2gucHJvdG90eXBlLnRvSlNPTj1sb2Rhc2gucHJvdG90eXBlLnZhbHVlT2Y9bG9kYXNoLnByb3RvdHlwZS52YWx1ZT13cmFwcGVyVmFsdWU7Ly8gQWRkIGxhenkgYWxpYXNlcy5cbmxvZGFzaC5wcm90b3R5cGUuZmlyc3Q9bG9kYXNoLnByb3RvdHlwZS5oZWFkO2lmKHN5bUl0ZXJhdG9yKXtsb2Rhc2gucHJvdG90eXBlW3N5bUl0ZXJhdG9yXT13cmFwcGVyVG9JdGVyYXRvcjt9cmV0dXJuIGxvZGFzaDt9Oy8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qLy8vIEV4cG9ydCBsb2Rhc2guXG52YXIgXz1ydW5JbkNvbnRleHQoKTsvLyBTb21lIEFNRCBidWlsZCBvcHRpbWl6ZXJzLCBsaWtlIHIuanMsIGNoZWNrIGZvciBjb25kaXRpb24gcGF0dGVybnMgbGlrZTpcbmlmKHRydWUpey8vIEV4cG9zZSBMb2Rhc2ggb24gdGhlIGdsb2JhbCBvYmplY3QgdG8gcHJldmVudCBlcnJvcnMgd2hlbiBMb2Rhc2ggaXNcbi8vIGxvYWRlZCBieSBhIHNjcmlwdCB0YWcgaW4gdGhlIHByZXNlbmNlIG9mIGFuIEFNRCBsb2FkZXIuXG4vLyBTZWUgaHR0cDovL3JlcXVpcmVqcy5vcmcvZG9jcy9lcnJvcnMuaHRtbCNtaXNtYXRjaCBmb3IgbW9yZSBkZXRhaWxzLlxuLy8gVXNlIGBfLm5vQ29uZmxpY3RgIHRvIHJlbW92ZSBMb2Rhc2ggZnJvbSB0aGUgZ2xvYmFsIG9iamVjdC5cbnJvb3QuXz1fOy8vIERlZmluZSBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlIHNvLCB0aHJvdWdoIHBhdGggbWFwcGluZywgaXQgY2FuIGJlXG4vLyByZWZlcmVuY2VkIGFzIHRoZSBcInVuZGVyc2NvcmVcIiBtb2R1bGUuXG4hKF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fID0gZnVuY3Rpb24oKXtyZXR1cm4gXzt9LmNhbGwoZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXywgZXhwb3J0cywgbW9kdWxlKSxcblx0XHRcdFx0X19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gIT09IHVuZGVmaW5lZCAmJiAobW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXykpO30vLyBDaGVjayBmb3IgYGV4cG9ydHNgIGFmdGVyIGBkZWZpbmVgIGluIGNhc2UgYSBidWlsZCBvcHRpbWl6ZXIgYWRkcyBpdC5cbmVsc2UgaWYoZnJlZU1vZHVsZSl7Ly8gRXhwb3J0IGZvciBOb2RlLmpzLlxuKGZyZWVNb2R1bGUuZXhwb3J0cz1fKS5fPV87Ly8gRXhwb3J0IGZvciBDb21tb25KUyBzdXBwb3J0LlxuZnJlZUV4cG9ydHMuXz1fO31lbHNley8vIEV4cG9ydCB0byB0aGUgZ2xvYmFsIG9iamVjdC5cbnJvb3QuXz1fO319KS5jYWxsKHRoaXMpO1xuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18oMyksIF9fd2VicGFja19yZXF1aXJlX18oMjIpKG1vZHVsZSkpKVxuXG4vKioqLyB9KSxcbi8qIDIyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG1vZHVsZSkge1xuXHRpZiAoIW1vZHVsZS53ZWJwYWNrUG9seWZpbGwpIHtcblx0XHRtb2R1bGUuZGVwcmVjYXRlID0gZnVuY3Rpb24gKCkge307XG5cdFx0bW9kdWxlLnBhdGhzID0gW107XG5cdFx0Ly8gbW9kdWxlLnBhcmVudCA9IHVuZGVmaW5lZCBieSBkZWZhdWx0XG5cdFx0aWYgKCFtb2R1bGUuY2hpbGRyZW4pIG1vZHVsZS5jaGlsZHJlbiA9IFtdO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwibG9hZGVkXCIsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5sO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwiaWRcIiwge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGdldDogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0bW9kdWxlLndlYnBhY2tQb2x5ZmlsbCA9IDE7XG5cdH1cblx0cmV0dXJuIG1vZHVsZTtcbn07XG5cbi8qKiovIH0pLFxuLyogMjMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgcmVuZGVyID0gZnVuY3Rpb24gKCkge3ZhciBfdm09dGhpczt2YXIgX2g9X3ZtLiRjcmVhdGVFbGVtZW50O3ZhciBfYz1fdm0uX3NlbGYuX2N8fF9oO3JldHVybiBfYygnZGl2Jyx7c3RhdGljQ2xhc3M6XCJob3VzZVwifSxbX2MoJ3RyYW5zaXRpb24tZ3JvdXAnLHthdHRyczp7XCJuYW1lXCI6XCJmYWRlXCJ9fSxfdm0uX2woKF92bS5jYWxsb3V0cyksZnVuY3Rpb24oY2FsbG91dCl7cmV0dXJuIF9jKCdjYWxsb3V0Jyx7ZGlyZWN0aXZlczpbe25hbWU6XCJzaG93XCIscmF3TmFtZTpcInYtc2hvd1wiLHZhbHVlOihjYWxsb3V0LnNob3cpLGV4cHJlc3Npb246XCJjYWxsb3V0LnNob3dcIn1dLGtleTpjYWxsb3V0LnNsdWcsc3R5bGU6KChcInRvcDogXCIgKyAoY2FsbG91dC5wb3NpdGlvbi50b3ApICsgXCI7IGxlZnQ6IFwiICsgKGNhbGxvdXQucG9zaXRpb24ubGVmdCkgKyBcIjtcIikpLGF0dHJzOntcInRpdGxlXCI6Y2FsbG91dC50aXRsZSxcImNvbnRlbnRcIjpjYWxsb3V0LnRleHR9fSl9KSksX3ZtLl92KFwiIFwiKSxfYygnZGl2Jyx7c3RhdGljQ2xhc3M6XCJob3VzZS13cmFwcGVyXCJ9LFtfYygnaW1nJyx7YXR0cnM6e1wic3JjXCI6X193ZWJwYWNrX3JlcXVpcmVfXygyNCl9fSksX3ZtLl92KFwiIFwiKSxfdm0uX2woKF92bS5jYWxsb3V0cyksZnVuY3Rpb24oY2FsbG91dCl7cmV0dXJuIF9jKCdkaXYnLHtjbGFzczooXCJob3RzcG90IFwiICsgKGNhbGxvdXQuc2x1ZykpLG9uOntcIm1vdXNlZW50ZXJcIjpmdW5jdGlvbigkZXZlbnQpeyRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtfdm0uc2hvd0NhbGxvdXQoY2FsbG91dC50aXRsZSl9LFwibW91c2VsZWF2ZVwiOmZ1bmN0aW9uKCRldmVudCl7JGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO192bS5oaWRlQ2FsbG91dChjYWxsb3V0LnRpdGxlKX19fSl9KV0sMildLDEpfVxudmFyIHN0YXRpY1JlbmRlckZucyA9IFtdXG52YXIgZXNFeHBvcnRzID0geyByZW5kZXI6IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zOiBzdGF0aWNSZW5kZXJGbnMgfVxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9IChlc0V4cG9ydHMpO1xuXG4vKioqLyB9KSxcbi8qIDI0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBRWpBQUFBaDRDQVlBQUFCeGZFTHJBQUFBQ1hCSVdYTUFBQ3hMQUFBc1N3R2xQWmFwQUFBQUFYTlNSMElBcnM0YzZRQUFBQVJuUVUxQkFBQ3hqd3Y4WVFVQUI1UjFTVVJCVkhnQjdQMTVsRjNYZlIvNC92WTU5OTZhTHFwUVZSaUpBZ2hPb01SQnBFVlJsQ0pib213cnR1VzhPRmJTdHAvekV0bU9vNWQwbW56UGJiVVZtZ1I0S1pKaWxwcnBKUExLNm5SM1ZqcjVJME03U1NkT1BDUng3TURxSlV1MElrdXlLVm9TUlJJVUp3d3NrQ0FLVmFpcWU4L3VmWXVnbzlpV1d4SkpYQXlmRC9TN2V6Z2tDSng5aGxwTGUzMXZCQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBRjdvVUFBQUFBQUFBQUFEQWVhUFg2MVVIRHg2c2JyMzExdTc2K3ZxbW5ITi9PUCtSajN6a3VRQUFBQUFBQUFBQUFEaUxxZ0FBQUFBQUFBQUFBTTRiUzB0TEUrOTR4enQyNVVIKzZWYmQrcTFPcS9OdlMvM3puLzNabjkwWkFBQUFBQUFBQUFBQVoxRUtBQUFBQUFBQUFBRGd2TkRyOVc1Y1gxK2ZicmZiTzVxbStWTXAwdmRIaXVkVFRxdXBUbmYwKy8ybGFyVjZiSzFlVzMzZ2dRZU9CUUFBQUFBQUFBQUF3T3VvRlFBQUFBQUFBQUFBd0RtdjErdnRpQ2IrZHF0dWJXOEd6ZFViazZuOHlqR1h5MGZUYjM2aFN0VmlqTVVEWTNuczZYTDBYd1FBQUFBQUFBQUFBTURyS0FVQUFBQUFBQUFBQUhCTzZ2VjYxK1QxUEozci9KNlVVamR5L0ZDWjd1YWM1OHY0RCs3OWFWS2tsWExzLzhvcHYxREdueW4xU0ZWVlgxaGFXbHA4OE1FSFR3VUFBQUFBQUFBQUFNQnJxQlVBQUFBQUFBQUFBTUM1cVIvWFJCVUxLZEtCeUJzekcvdDkvbkIyMFlZcVI1NktGTjliL3ZtMU1uNTM2Zjk4YVU5MnU5M1RwUlZnQkFBQUFBQUFBQUFBdktaU0FBQUFBQUFBQUFBQTU0UVBmZWhETTkxdWQ5djYrdnF0WlhodHFUZWtTTE01NTV1SHg5UFhTUzc2SXpUbDMxbU5GSWRTVGsrVThaZkw3M09rMWJUKzhhbm0xUElERHp5d0dBQUFBQUFBQUFBQUFLOVNLd0FBQUFBQUFBQUFnSFBDeE1URTJHQXcyRjVGOWU0YytkMWxhcTVVNXh2UExmcDlWZmwzSm5MT2J5aS96eHRLLy9JeWQyUzFXdjNWOG5zL1gvb0NqQUFBQUFBQUFBQUFnRmZ0bTk3WkJBQUFBQUFBQUFBQXZEWjZ2VjVyZlgxOWUxM1hiNmlpK3NzNTUrMlJZbDlwdStYd1ZMd2NSUFNxOXZpVTN5dVgzMkpRdXYzU1BWTDZPVlhwZis3Mys0L2ZkOTk5L3lJQUFBQUFBQUFBQUFDK1JhMEFBQUFBQUFBQUFBQkdxWFdtZGtTSzdUbm5uY1BKVnh0YzlJb3p2ODhyLzQyRmVEblRhTGFxcXRrQUFBQUFBQUFBQUFCNEZWNlRUVTRBQUFBQUFBQUFBTUEzcDlmci9Vek8rZExJOFlIU0RuT0c2amk3K3FXV0lzVi9MUC90djFQNlh5NS9wcU1CQUFBQUFBQUFBQUR3RFJKZ0JBQUFBQUFBQUFBQVo4RnR0OTAyTmprNU9kN3BkQzZ2NjNvcTUveithR0pIanZ4OXcrTm5POENvL1BjSDViKzVrcXIweWRML042VWVyYXJxeU9uVHA1ODhkZXJVOHZ6OC9IcXYxMnNDQUFBQUFBQUFBQURnNjJnRkFBQUFBQUFBQUFEd3VwdWZuOTllbWoxTjAzd2tOL242MHArT0ZGVWEwWGVRblFsTTZwWS95M3RLKzU3eTUvaGlOSEdrMCtrOFVOZjFGdzhlUFBoTW1SZGdCQUFBQUFBQUFBQUFmRjJqMmYwRUFBQUFBQUFBQUFBWHVGNnZWeTB0TFUxMHU5MnRaZmlHVW51R2xYUCtnY2h4ZVdrblVoSG5qc09sWHN5Ui8zMzVzMzIxbFZxZjc2LzFqOS83Tis3OWJBQUFBQUFBQUFBQUFQd1JXZ0VBQUFBQUFBQUFBTHdlcXJHeHNTMU4wN3lqaXVvdjU4aVhscm05cnh3OHQ3S0xOdXpZcUJ4WHAwaWx5VDlmZCtwRFpVNkFFUUFBQUFBQUFBQUE4RWM2NTNaQkFRQUFBQUFBQUFEQStlNmVBL2Y4ZUduR0I4M2czVkhGbGhUcGpXWGNQVlBudkZ5VTVxc3BwUmNpeDI4Tzh1RHBNdlZyWmU2WisrKy8vNWtBQUFBQUFBQUFBQUFvV2dFQUFBQUFBQUFBQUx5bWN1UjN4RENzS01XZmkyRVVVRHEvdm1nc0ZhVzV0TlR1OGlmZlc2ZjZ5K1h2OUhqTytWU1pFMkFFQUFBQUFBQUFBQUJzT0s4MlJnRUFBQUFBQUFBQXdMbW8xK3Z0YTVwbVZ4WFZmNU56M3AwajMxU21PNlhtem9RQm5aZkszeVdYUC80Z1VpeEhqcWZMMyt1cE1uNXFNQmo4Mi9MM2ZlZzNmL00zRnc4ZVBOZ1BBQUFBQUFBQUFBRGdvdFFLQUFBQUFBQUFBQURnVlZsZlg5OWMxL1cyamVDaUZQdFNwTTF4QVRnVHZ0U0tITk9sdmFiOHZlWktmM3NWMVcvbWxNY0RBQUFBQUFBQUFBQzRxSjIzMys0R0FBQUFBQUFBQUFDamN0dHR0NDFOVDAvdnFGUDluYWxLdDVlcFBhWG00aUtSaTJHYkl2MXFhWmJ2dWZlZUh3d0FBQUFBQUFBQUFPQ2lJOEFJQUFBQUFBQUFBQUMrQ2IxZWIxdHBKZ2VEd2E0NjZsdHl5bjhwNTd3cnBUUVRGNG5mRHpCSzZST1JZN25mOUQvUWJyZFh5dlRwK2ZuNTFkdHZ2MzAxQUFBQUFBQUFBQUNBQzE0ckFBQUFBQUFBQUFDQWIxZ2U1UDhsUjU1UGtiNjlpU2JTTU1ZblhWemZJL1kxZitGdkgzNkZXbDNYdjljMHplTXBwNysvZUhUeGtUTC9Id0lBQUFBQUFBQUFBTGpnWFZ3N3B3QUFBQUFBQUFBQTRKdDA5OC9jdlpEcU5OMjBtemZtbkNlcVZQMVVtWjRzL2F1SHh5KzY5S0kvUW82OFZqNWVTSkYrclF3UHBadytVNC9Wbno5eDRzVGhicmU3MHV2MW1nQUFBQUFBQUFBQUFDNDRyUUFBQUFBQUFBQUFBTDYrVGx5VFU3NG1wZlEvbE5Gc3FZbmh0TnlpL3lKRjZwU1A3YVg3bzZWZUt2MWphMnRySHgwYkcvdjNpNHVMaDh2Y2FnQUFBQUFBQUFBQUFCY2N1NmdBQUFBQUFBQUFBT0JyOUhxOTFzckt5bFNuMDdteGp2cUdKamR2U2ludHlwSGZFU25HVTZSMjhIV1Y4N05henRXcFVwOG93NitVZXF6SzFhbmV2YjEvR0FBQUFBQUFBQUFBd0FXbEZRQUFBQUFBQUFBQXdPOWJYRnlzcDZlbk42ZVUzbG1HN3krMUxWSnNTcjRyN0J1U0k0K1ZacXgwL3RSd1hNN2o1OHVwTzFHNi96QUFBQUFBQUFBQUFJQUxpbDFWQUFBQUFBQUFBQUJROUhxOWJqUngzekNzcUdtYU41YXBIU25TampJZUJ2SlV3VGN0RnltbFU2WGJ6NUUvazNKYUtmV1B5dlRUOTl4L3o2Y0NBQUFBQUFBQUFBQTRyN1VDQUFBQUFBQUFBQUFZNnBhNk1lYzhVOW9iTm1hU0x3aDdOVklSTDUvWDRhbDhWL2s0bmlQL1dobStGQUFBQUFBQUFBQUF3SG5QQmlzQUFBQUFBQUFBQUM1YTl4eTQ1LytWYzk3YXBPYXZSSTY1bE5LdTRYeVpHenNUdnNOcnBKelRQR3pMYVgwaFIzNnBpdXBZRTgwdmxlbGZYbGxaZWVUQkJ4ODhGUUFBQUFBQUFBQUF3SG5GSmlzQUFBQUFBQUFBQUM0YXQ5NTZhK3Q5NzN0ZmZmejQ4YW4xOWZXcFR0MzUzaVkzQ3pueVh5Mkhod0ZHZFhBMm5FNlJUa1lWdjFqNnY5enY5MyszMVdxZE9Ianc0UFBEZzZYdEJ3QUFBQUFBQUFBQWNNNFRZQVFBQUFBQUFBQUF3RVdqMSt0dEs4MithT0svelpIZlhmcHpwVHJCU09SaTJLYVVQcDhpblJqa3dVODNUWFA0L3Z2dmZ5WUFBQUFBQUFBQUFJQnpuZ0FqQUFBQUFBQUFBQUF1YUxmZGR0dlkvUHo4Vk9udWFacG1lMHJwcXRML2J5TEhkYVdkTHRVS1J1SnJBb3dlSzgxU3l1bnZsSFY1cVIvOXo3WmFyZFZlci9kc0FBQUFBQUFBQUFBQTV5eWJyd0FBQUFBQUFBQUF1S0JOVDAvdmFKcm1EVlZVZDZSSTIzT1RyeDdPcHlJWXFhOVpneXVISDAwMGZ6OVY2VVNkNnYrMXJObmpaZXAvQ3dBQUFBQUFBQUFBNEp4bEV4WUFBQUFBQUFBQUFCZWsvZnYzdnlPbE5KNXllbTlVc1NWeXZMTk1kM1BPODhLTHpsbE5XWi9Wc2p5ZlNaRVdtMmcrV2NaUDFIWDlxYVdscGNVSEgzendWQUFBQUFBQUFBQUFBT2VNVmdBQUFBQUFBQUFBd0FXb3J1dDM1SnhuUy9mMjNPUmhabEU5bkpkZGRFNnJ5dnBNbFBiYmMrUitpdlN1VktYL1dNYlBkcnZkMDZVVllBUUFBQUFBQUFBQUFPY1F1N0VBQUFBQUFBQUFBTGdnM0hISEhmT1RrNU56cTZ1cjMxMm4rcnFVMGsxTmJpYkxvZXVHeDVQa292TktMc3FTcmFkSVI1cG9IazQ1ZlduWVgrMnYvdXR5K05nRER6eXdHQUFBQUFBQUFBQUF3RWkxQWdBQUFBQUFBQUFBTGdCalkyTlRnOEZnZTEzWDN4azV2anRIbms0cFZjRjU2VXpnVktlczQrNFVhWGVrdUt5TWo3VGI3YytXZFY0cGZRRkdBQUFBQUFBQUFBQXdZcjVWRGdBQUFBQUFBQUNBODFLdjE2dlcxdGEyMW5XOXAwNzFuODg1WDVwVHZqUkZHZ2JkZE1PWGUxMW9sa3IxeXpvL1dkcmx5UEd2b29ybEQzLzR3MzgzQUFBQUFBQUFBQUNBa2JCSkN3QUFBQUFBQUFDQTgxV1ZVaG92TlZmNk4wYUtZWGpSM3VCQzFUM1R6Z3cvcXFwNnBEVFBCd0FBQUFBQUFBQUFNRElwQUFBQUFBQUFBQURnUE5NNzBQc2JwZG5iNU9hSGh1TlVCQmVqcHRSTEtkSW5tMmorVWM3NTRYdnZ2ZmNMQVFBQUFBQUFBQUFBbkJVMmJnRUFBQUFBQUFBQWNNNzd3QWMrMEo2ZW51NTB1OTM1allrbWZpWmVEakI2NzNBb3dPaWlOUXd3V3NxUlA1OXovdm02cmg4cDR5OGVQSGp3NlBCZ2Fmc0JBQUFBQUFBQUFBQzhibG9CQUFBQUFBQUFBQURudU8zYnQrOUxLVjJYbS96ZmwrRytVdE9sS3JsRkY3MnExSFNLOUIzbFd2aU9jbjBjTHVQRDcvd1Q3N3hya0FZUGwvNHpRb3dBQUFBQUFBQUFBT0QxWXdjWEFBQUFBQUFBQUFEbm5GNnZWeTB0TFUyTWo0OXZLOFByVzYzV2xVM1RYSmtpZldjWjc4NDVUeVRwUmZ3QjVibzRVUzZMRTVIajN6VFJQSkVHNmZkeW5ZL2ZlKys5RHdVQUFBQUFBQUFBQVBDYWF3VUFBQUFBQUFBQUFKeDdxckd4c1MxVlZMZW1LdDJlbTd3alJkcnh5a0haUmZ4UnluVXhVNXFaSFBtdmxlc2xVcDErdFh3ZUtuTUNqQUFBQUFBQUFBQUE0SFZnSnhjQUFBQUFBQUFBQU9lVUF3Y08vSENWcTdFbU5UZVc0ZVVwMGkybDdaNHArSCtVYzk1b1NqMmVVbm9oUi83WFplNkZxcWwrTzFyeDlEMzMzUE4wQUFBQUFBQUFBQUFBcjFvckFBQUFBQUFBQUFEZ0hKSnkrcEVjZVRKeXZPZmxDVi9TeFRjbnBZMUxadmh4UlI2bUdhVzR0c3c5SGxYOC9lakhwOHE4QUNNQUFBQUFBQUFBQUhnTjJOd0ZBQUFBQUFBQUFNQkk3ZCsvLzl2cVhGK1I2L3o5T2VlZEtkSk5wVzJYUTlQcFRCSU5mS3ZLOVpTYmFKckljYnBjVHMrVmErdVpNdmZNSUEvK1pkTTBuL2pOMy96TnhZTUhEL1lEQUFBQUFBQUFBQUQ0cHJVQ0FBQUFBQUFBQUFCR3FNclYxcHp5UXNycDVoejU4akkxSWJlSTEwcTVwc3JWbE9wSU1WV0dWNVpyYTY2TUYwcjlSdW1QQndBQUFBQUFBQUFBOEMyejB3c0FBQUFBQUFBQWdMUHF0dHR1RzV1ZW50NVNWZFU3NmxUL3R6bnlyakk5VjJvODV6d01MN0tuaGRkVE02eHlyWjBzN1ZLVnF0OHU3ZW5laDNzL0VnQUFBQUFBQUFBQXdEZkZaaThBQUFBQUFBQUFBTTZhWHErM296U1RnOEZnWjBycFQ2UklmeTNudktYMHB3TE9vbkxkNVdGYnJyM1BsK3R3TmFvWUJoZ3RsK25UOC9QenE3ZmZmdnRxQUFBQUFBQUFBQUFBZjZ4V0FBQUFBQUFBQUFEQVdiQVJYdFRFUDh1UloxS2tHMklZSDVPRytURytnNHV6NzJzdXZCdno4R0pzNHRHYzgyUGxrdng3aTBjWEh5bnoveUVBQUFBQUFBQUFBSUEvbHQxZkFBQUFBQUFBQUFDOGJ1NjQ0NDZ0blVGbkxDYmlrdHpQbDZVNi9mVXkzYzA1WHpFOExyMkljMFc1SmdmbGNud21jdnliMHY5S3E5UDZyYVpwanEyc3JCeDc2S0dIVGgwOGVMQWZBQUFBQUFBQUFBREFmNlVWQUFBQUFBQUFBQUR3T2htcng5NlZXM2toTi9sblU1MW00OHgrRmJsRm5HdktOVm1YWmsraytPOUt1ekxvRDA0MHVmbTdFeE1UQjIrNTVaYmZQWGp3NElrQUFBQUFBQUFBQUFEK0szYUNBUUFBQUFBQUFBRHdtdm5nQno4NDFlMTI1NXVtdWJZTXJ5bDFVOHBwTmtmK2pwVFNSQmxYQWVlNEZHbTlYTE9ya2VPM3l2QlFsYXZmeVNtZldGNWQvZzlsZlBLakgvM295UUFBQUFBQUFBQUFBRjcrUmpzQUFBQUFBQUFBQUhndGRMdmRxZExzU1NsOWIrVDRvZEtmaXhTZDVIdTJPSS9reU8zU3RFdjc3dUc0cVpyUGwydjR4TmpZMk84MlRUTzhtQVVZQVFBQUFBQUFBQUJBaEoxaEFBQUFBQUFBQUFDOE9uZmNjY2Q4VlZXVDdhcjk1eVBGdHB6ejFUbmx5eUxIM25LNGsxS3FBODVUNVhyTzVSbytVYnFuUzMyNlhOZUxneno0cFRMMzNMMzMzdnVKQUFBQUFBQUFBQUNBaTFnckFBQUFBQUFBQUFEZ1ZhaXFxbHRxUzZUNDNoeDVlNm1ySTBla0l1QThkK1k2M2p6czU1emZPd3d6cXF2NmNPay9YcVlFR0FFQUFBQUFBQUFBY0ZHelNRd0FBQUFBQUFBQWdHOUpyOWY3LzVUbWt0emt2NXB6SHVhOGJDL2pWdW5Yd291NEVKVnJPNS9wdmxTbHFwOGpQMVBxRjhyMHYrMzMrNDgvOE1BRGl3RUFBQUFBQUFBQUFCZVJWZ0FBQUFBQUFBQUF3TGVnYVpxSmxOSnM2UzZjeVN2YTJJc2l1NGdMMWRjRWM4M2t5UDNTRHNPNjVxdXFHcXVMQUFBQUFBQUFBQUNBaTR6ZFlnQUFBQUFBQUFBQWZFTjZ2ZDYyMHV6TE9mLy9Jc2QzbDM0M2ZJRVd2T0tMS2RLUlFSNzhkTk0wejk5Ly8vMVBCZ0FBQUFBQUFBQUFYT0FFR0FFQUFBQUFBQUFBOEhYZGR0dHRZL1B6ODFPbHU2ZHBtdTBwcGF0U1RqK2FJMStmYzU0bzR6b1lpZkh4OFpnWW44aXJhNnRSMWlLdnJxNm1za2IyQTQxSVdZSW55LzN3UXFyUzN5bkQ1WDYvLy9ueFBMNTgxLzEzUFJVQUFBQUFBQUFBQUhDQjhnMTRBQUFBQUFBQUFBQjhYZFBUMHp1YXBubERGZFVkS2RMMnlQR0dYRDZHVXBLVk13cXBTcm1zUlN3c0xEU1hYWFpaZnU2NTUvcXJxNnY1aVNlZUdDOXJGWXhHdVI4dUxjMmx6YUQ1QjhOeHEycjlnN1ZtN1V1bCt6OEdBQUFBQUFBQUFBQmNvT3dpQXdBQUFBQUFBQURnRC9udy9nOS9XOU0wRTROcThMWXFxcTJSNHMrVTZjMmxkZ1FqVVZWVm5wcWFHblM3M2JSOSsvWnE2OWF0dWJUNXhFc25tdlcxOWZ6a2swKzJsNWVYMDlQUFBKMkxhQWFOdlVFanNISHlpeXBWSHkvM3piRlMvNnBNUFo5Uyt2TFMwdEt4Qng5ODhGUUFBQUFBQUFBQUFNQUZvaFVBQUFBQUFBQUFBUEFITktuNTRhaGpTOHJwSjNMa1NKR0U0WXhZVlZXeFk4ZU85VXYzWGxxLzVTMXZxVnV0VmlvMVBGUVBQeFoyTDhSTEw3MlVqLy9LOFVHUmxrOHQxOEZabDlMTDkwcTViOTVWUHZxbHZydmNQNTlzY3ZPUHV0M3VRK1dRQUNNQUFBQUFBQUFBQUM0WU5wWUJBQUFBQUFBQUFCQjMzbm5ucnRMc1NpbTl2VTcxdmtqeDlweHp0OHhkT1R6K1NpZ0xaOWZZMkZoVDFpTGYvSmFiNjNhN25YZnYyVDJZbXB5cXRtemRVZzBEamI1MldaYVhsK1AwNmRQeDdMUFA1dEp2bm4zbTJYejB5TkYwK01qaHVxeGxESXV6cTV6elhOWm92Wno5eGNqeDViS1dYeXpqSTRQQjRKK1ZPdnJBQXc4c0JnQUFBQUFBQUFBQW5NZGFBUUFBQUFBQUFBREFSYStxcXMwcHBjc2l4L2NNdzR2SzFIUVpWOEZJMWEwNjEzV2RyN3pxeW1pMVdtbGhZZUhyN3ZlWm5KemNxTG01dWJTMHRKVEt2emRZT2IxU0h6bDZSSGpSaUp3Si91cWtTRHZMZmJXejlJZjMyUEdxcVg0clYzbTVqQVVZQVFBQUFBQUFBQUJ3WHZQTmVBQUFBQUFBQUFBQUY2RmVyMWV0cmExdGJiZmJsNVhoWDhvNTcwNlJkbSswS1UyRUw4WWFpV0hlemJEMjd0MDcyTEZqUjNQcDNrdnJ5Y25KdEhYcjFsUlZWWFE2blcvbzl4a01CbmxsWlNXZlBIa3lEZXZRb1VQOXc4OGRIanoxMUZPZDlmVjFlNFpHWjZYVW9OVGo1VjQ3VlZiNzE1cG9UdDE3NzcxL0l3QUFBQUFBQUFBQTREeGtveGtBQUFBQUFBQUF3TVdwU2ltTjU1em5VNlMzbE5wUjVuWU13M01ZcmVFYXpHeWV5Zk5iNXZNbGwxeVNObTNhOUUwdlNsM1hxZHZ0cHZIeDhaaWRuWTBUSjA0MHA1Wk9OY0dvRGNQQm90eDMxNThaSDZtaU9ob0FBQUFBQUFBQUFIQ2VzdU1NQUFBQUFBQUFBT0FpYy9mK3UvK1gwdXpOa2Q4ekhDZXBSU00zTlRYVlhIbmxsYXNMdXhmcTY2Ky92dE51dDRjaFJQRmFPM2JzV0F3R2cvam5QLy9QMS9yOWZqcHg0a1E3R0tsY1JJclRLZEpuSXNlL2pDWStkYy85OTN3cUFBQUFBQUFBQUFEZ1BOQUtBQUFBQUFBQUFBQXVhQi83Mk1mR0ZoY1h4L3I5L3V5WnFjbVUwc1F3TjRYUnFhcHFZd0dtcHFiUzVPUmtURTVOcGs2bk13eVVpdGNyVStxVlVLVHA2ZW0wdHJZV3BYSzVMbUlZWmpTY2QwMk14a2FJV0k3SjBwM05rYmZmL1ROM0wvekdiLzNHNGVHeGd3Y1A5Z01BQUFBQUFBQUFBTTVSdmowUEFBQUFBQUFBQU9BQ2QvZGRkLy9KU0hGTlN1a25tMmd1anh6ajZmVkt5T0ViTmpzN3U3NXAwNlo0Ny9lL3R6ME1McHFibTR1emFXbHBxZm5TbDc3VWYrYVpaOUlqWDNpa1hsdGJTMDNUdUM1RzczaUs5RUsvNmYvM09lZlBmK0lUbjNoR2lCRUFBQUFBQUFBQUFPZXFWZ0FBQUFBQUFBQUFjRUhwOVhyVjR1SmllK2ZPbmQzK1N2L0tKamZYNThoN1MwMlZ3MVdWcWlqOTRPeDZKVE5xMDZaTnVkMXV4L2J0MjJQejVzMXBHRjdVYXAzOWJUeDFYUS8vTEdsMmRyWmEyTDBRU3llWFlubDV1VGwxNmxRYURBYUNqRVpuZURFTVE4YXVLOWZGK0x2ZTlhNUR0OTU2NjFxNXJ6OFhBQUFBQUFBQUFBQndqaEZnQkFBQUFBQUFBQUJ3Z1JtR0YwMVBUKzlZV1ZuNW5qclZQOU5Fc3kybHRHbDRMSlZmd290R282cXFZWEJSdnY1TjF3L201dWJ5OWRkZjMrNTBPaU1MQ3BxWW1LajI3ZHRYWFhIRkZYSHp6VGZIbDc3MHBmWERodzgzWDNqNEMrMlhYbnBKZ05Ib1RKZDdkTHJjcS9jMWd5YXFWUDFXdVdWUGwvbGJBd0FBQUFBQUFBQUF6akUyR2dFQUFBQUFBQUFBWEVCNiszcy9saU4zYzhxWGwrR1ZLZEk3U2syVnViRmdKQ1luSi9QYzNOd3d0S2lhbTU5TGUzYnZhU1ltSjJMYnRtMVZYZGNqMzcrVGM0N0JZQkRIang4Zm5EeDVNai85OU5QMXl2SksrdUlYdjlpc3JhM2w1ZVhsT2pqcmh1c3liRkpLejVTMlgrN2hmMURtWHFpYTZqKzNVdXZZL3Z2MlB4WUFBQUFBQUFBQUFEQmlyUUFBQUFBQUFBQUE0TUtSNHNmSzUwemt1T0hNT09YSXdlaE1UVTAxdS9mc0h1emR1emN1dmZUU1ZxZlRxYXVxaW5ORlNpbGFyZFl3VUtrdUZkdTNiNDkrdngrSGp4eHVUcjUwVW9EUmlBelhKVjcrZ3JxRmx6dnBRR2tlaXlyK1hqLzNIOW5vQXdBQUFBQUFBQURBaUkzOEc5d0FBQUFBQUFBQUFQalc5WHE5YTNJL0wrUXEvK21xcXNaems3Ky9UTGR5enZQcFRBSUtaOSttVFp2Nm5VNG4zWFRUVGZWVWR5cHYyN2F0bVp5Y3JMcmRiaHFHRjUzTFN6TU1MMnFhSnA1Kyt1bG1lWGs1RGoxeGFIRGl4SWwwNk5DaGFqQVlwSExNZFRVQzVaN081YnBaS2QySEk4WHpaZmhvdVpZTzFuWDloYU5IajM3MTUzN3U1MVlEQUFBQUFBQUFBQURPc2xZQUFBQUFBQUFBQUhEZUdvWVhSWXBySXNjUDVTYlB4cG45SUxLTFJtdGlZaUlQZzR1dXVmYWFlaGhrTkRrNVdjZDVvdFY2ZVV2UjVaZGZYcTJ2citjVXFYbisrZWZUVTA4OVZRMkRqUmlOTTRGa2s2WGVXdTcxbFRKODgyQXdlTDZNbnkvWDE5SFNDakFDQUFBQUFBQUFBT0NzczFNTkFBQUFBQUFBQU9BODhxRVBmV2ltMCtuc1N5bTl0NHJxKzV0b3RxWkkwemx2aEJlOUVuTENXVmJYZFc2MVd2bm1tMi91VDA5UHh4dXZlV043T0Q4MU5iV3hKT2Z6c3F5dHJlVmh1N0t5RW9jT0hXcEtEWjU4OHNuNmhjVVhxaHpaOVRZQzVYNGZyc2t3VFdxcFhGdW5Jc2Z2bFBiRSttRDlwOHVoL2tjKzhwRWpBUUFBQUFBQUFBQUFaMEVyQUFBQUFBQUFBQUE0cjlSMVBaWnpuaXUxTzNMTVJJb0p1VVdqOVVwSVVidmRIb1lXNVUyYk5sMHdDOUxwZE5LWk5ycmRiaDRmSHgrR05VVlU4WEtFRG1mZG1hQ3l1andEaHVGbDAyVjR0SXduU3JVOEN3QUFBQUFBQUFBQU9KdnNWZ0VBQUFBQUFBQUFPTWZkZWVlZHU2cXEybEduK20vbXlETTU1eHVHODBsU3lVaWxLdVd0VzdZMlYxeDVSZjlOYjNwVGErZk9uWFZjSkphWGwyTnRiUzMrM2EvOHUvV1ZsWlg4NUpOUGRvSnpRYi9VUzVIaWZ4ME1CcCs1Nzc3Ny9rVUFBQUFBQUFBQUFNRHJxQlVBQUFBQUFBQUFBSnlUZnZabmYzWm5WVlhqVmE2dXE2TGFQUXd2S3RQZFlLUTZuVTRlR3h2TG0yYzNwN201dVppZm4wOWxmRkdGU1pYck1scXRWbXpidG0wWVpKUldWMWRqZlgwOWpoOC92bkU4NXh5Y2ZlVzh2NXhyMXNTZVZtcWQ3UFY2MzE3VzVtalRORWNlZXVpaFV3Y1BIdXdIQUFBQUFBQUFBQUM4aGdRWUFRQUFBQUFBQUFDY28xcXQxcDlLS1YyZW0veUJuUEowbk5ucnNSRlF3c2pzM0xsemZjdVdMZWs3M3ZrZDdVNm5VMDlPVHRaeGtSa2ZIOTlvdi9PN3ZyTTliQThkT2hSSGpoeUovL1RyLzZucDkvdHBXTUZaVjU0TncydHhMbEw4YUk2OEZrMHNsMnYwbjVUNWYzckxMYmY4N3NHREIwOEVBQUFBQUFBQUFBQzhobXdVQWdBQUFBQUFBQUE0Ujl4MjIyMWo4L1B6TSt2cjY1ZTMyKzNMbTZhNXRZcnFraWFhZDBlT3NUUGhKSnhscVVveC9MVjc5KzRvNnhLWDdyMjAzNTNxeHRWdnVMcFZSS2ZUaVl2ZDg4OC9INmVXVHNYRER6L2NMQzh2eHdzdnZKQ0d0Ykt5RW94TXY5UmFlWFo4S3RYcGs2bEp2NXVyZkdKMWRmVXpwMCtmWHZwYmYrdHZXUndBQUFBQUFBQUFBRjYxVmdBQUFBQUFBQUFBY0U0WWhoZVZabCtyMWZwLzV5Yi9hSXJVelpGYncvQWNYMU0xT25WVjU3SW0rYTIzdkxXYW1wcUt2WHYzMm5QekIyelpzbVdqTHQxN2FYWDB5Tkg4NktPUERuN3Y5MzR2UGZ2c3MxVzVscVA4Y2dXZmZhMk5TdkdkWlEyK3M2ekI1MUtUVHBScithY25KeWNQbDJQUEJBQUFBQUFBQUFBQXZFbzJCZ0VBQUFBQUFBQUFqTkFkZDl3eFgxWFZaTHRxLy9rY2VYdE8rZW9xVlpmbG5DK1Bsd05JcXVDc1MxWEtXN2RzelZ1M2JzM2JkMnhQczdPemFkZXVYYW5UNlVTMzJ3Mit2dFhWMVh6aXhST3h1TGdZcDVaUHhSY2Uva0wvMUtsVCtlalJvNTFnbEY0c2RibzhaejRUVFJ5dnEvby81U1kvMWJ1djl4OERBQUFBQUFBQUFBQytSYjRORGdBQUFBQUFBQUJnaEtxcTZwYmFFaW0rdHd5M3AwaHZ5RGtIbzFYV0lhYW5wL01sbDF5U3I3cnFxbXJiOW0yK0tPd2JORFkybHNyNWl0bTUyUmdNQm5GODhYaHo3Tml4NXVqUm84RkliZDc0elBIZWNua3Y1Y2hyVFRSZktqTUNqQUFBQUFBQUFBQUErSmJaV0FVQUFBQUFBQUFBTUFMNzkrLy9rWlRUN2tqeGcyVTRtVks2dExUalo0b1JxS29xNzl5NWMyMW1acWI2dGpkL1cydHFhaXFHMWUxMm82NXIrMnkrU1UzVGJMUW5UcHhvMXRmWDgrT1BQVjZYTmo3NXFVOE8rdjErcksydTFjRlpsMTlPU0ZzcmRielVVb3IwcFNhYVQ1Wm4wQ2NIZzhHWDc3Ly8vbWNDQUFBQUFBQUFBQUMrUWEwQUFBQUFBQUFBQU9Dc0c0WVhWVlYxZFpPYnQ3MHlGWXhVV1krWW5KeHNObS9lSEx0MzcwNnRWaXVHeGJkbWVENkhabWRuTnpyTHk4dkR5blZkNThGZzRIb2ZrVlNVWnF6VXpsTDlVbHVyWEwyWUl6L1dicmVmQ0FBQUFBQUFBQUFBK0NiWUNBUUFBQUFBQUFBQWNCYjBlcjI5VGRQY0VqbmVuMUo2ZTVucWhpK2ZHcm5KcWNuQk1GRG4rNzd2KytycDZlbTBzTEFRdlA0V0Z4ZWJRNGNPOWIvODVTL1hYM24wSzNXNU55TG5ISXpjVjBzZGIzTHpnYkltUisrLy8vNG5Bd0FBQUFBQUFBQUEvaGcyd1FFQUFBQUFBQUFBdkU1dXZmWFcxaTIzM0RJMU1URXhsWFBlVVdwcmxhcXBjcWdLUmlkRnRPcFdicmZiTVQwOUhYVmRwMWFyRmNQaTdDam5QRHFkVHBxYW5JcnBtZWxZV2xyS2tTUFcxOWQ5SWRzSXBVaDFXWWhPV1o5ZFpkanA5WG9yWlcxT1BmamdnNmNDQUFBQUFBQUFBQUQrQ0RiOEFBQUFBQUFBQUFDOERucTlYbXQ5ZlgxWFhkZlhwVWozbGFtNVVudUNrVW9wUlZWVjhhWWIzdFJmV0Zobzl1M2IxOTYwYVpNOU5DUFM3L2MzNnFHSEhsbzl2bmk4ZWVTUlI4YUZHSTFlTG9adGVYYjlRbWtldnVmZWUvWUhBQUFBQUFBQUFBRDhFV3oyQVFBQUFBQUFBQUI0amUzZnYvK1d1cTVuQjRQQk5XVzR2VXJWajVTMkd5K0hHREVDN1hZN2Q3dmR3ZVRrWkxWbDY1WnE5KzdkZ3kxYnR1UnQyN2JWWmM0ZW1oRXA5MGcwVFJPSERoM3Fueng1c25uOHNjZmJLeXNyOGZUVFQrZmgvUHI2ZWhXY2RiOGZZSlRTWjB2M1NJNzhUMHIvaFdxOWVtSTFWbzg5OE1BRHh3SUFBQUFBQUFBQUFJcFdBQUFBQUFBQUFBRHdtcXFpK29rOHlIdFRwUGVjbVJLUU0yS2RUaWZ2MmJObmZXSDNRbjM5OWRkMzJ1MTJYUVNqTlZ5RFlWMTExVlViKzVoMjc5NGRKMCtlekwvMGk3L1VMOUtKRXljRUdJMUFLczUwMzF5ZVhrMTVsdDFhNmpPNWxmOWxwK2w4cXN3TE1BSUFBQUFBQUFBQVlJUE5jUUFBQUFBQUFNQWYwdXYxM2hEcnNXTlFEVzRzdzgzQmErRjBIZlhocU9OejVmeCtMb0FMeXQxMzM3MFEvVmhvcXViTkthWFp5UEdEOGZMejgvTGg4YThKQStFc21oaWZHS1FxeFRYWFhGTlBURXprWFF1Nyt0UFQwOVcyYmRzMndvc3N5N25uMUtsVHNiYTJsaC85OHFQTnlzcEtQUFBNTThOQW8zVDA2TkhVNUNaeWt5M2FXWmFMU05GUGtaNHJ6N1pIeXRSWFN2L1JmdTcvKy9YMTljUGwzanBaZnJacEFnQUFBQUFBQUFDQWkxSXJBQUFBQUFBQUFQNmdmcndocXJpeFN0WDd5Mmh2OEZwNHNkVG5ZeEQvc0xRQ2pPQkMwNCtGOHR4OFc1M3FuMnlpR1lZV2pRc3RHcjN4aWZHbXFxcjhscHZmVW5jNm5UUTNOOWNPem1sVFUxUERTbSs5NWEzMTB0SlMwOTNVN1QvenpEUHBoUmRlcU5mVzFsS09ISnhkWjU1bHczdG5UNlJTRWNkTHZWQ1c0bENyMVRwOThPREJVMlVzd0FnQUFBQUFBQUFBNENJbHdBZ0FBQUFBQUFBQTRKdlU2L1dxdGJXMXJlMTIrNFpvNHYwNThxNlUwcTRtTnpzalJVZDQwV2dNdzRwYXJWYmV2V2QzM3I1dGUzUFZWVmZWWStOak1UYzNGNWJrL0RNeE1aR3V2dnJxMXNLdWhYVE5OZGZFVjcvNjFXYngrY1hCRTA4ODBWNWVYcmFnSTVJaWJjbzVUMVNwdXE4TWxtNTk1NjIvVStyNTNvZDdkd1VBQUFBQUFBQUFBQmNkQVVZQUFBQUFBQUFBQU4rOEtxVTAzalROM2pyVnQ1VHhiS2s1SVRtak5Uei9WVlhGek14TU03OWxQdTlhMkpVNm5ZNUZPVS9WZFoyNjNXNmFtSmlJbWMwemNlclVxV1o5ZlgwanBDcUdPVHFNUkk3Y0xtZS9YVHJYblptcVNoMEtBQUFBQUFBQUFBQXVTZ0tNQUFBQUFBQUFBQUMrQ2IwRHZYOFdUWXpYVmYzbU11em15SnZpNVFBUFJtUjZlcnE1NHNvcitnc0xDL1dlUFh1cWlmR0pWbWVzRThLTExnekRVS3F4c2JHNDl0cHJXL3YyN1lzYmI3d3hWbGRYNHhmKzlTLzBCNE5CdlBqaWkvWkFqVUFxOGxEa0c4cndUWGNmdVB2UjhteDh2RXovSDRNWWZQYmVlKy85YkFBQUFBQUFBQUFBY01HemVRY0FBQUFBQUFBQTRJL3hzWTk5Ykd4eGNYRXNwVFMzTWRIRTNoeDVyUFFXenZ3alFuSkdvS3FxUEd5NzNXNmE2azdGN096c1JrMVBUNmQydTcwUmVzT0ZvZHg3RzIycjFVcWxZaGlaTXpFeEVUTXpNOUUwVGF5dHJlWDE5ZlhvOS9zYi8rRHdPR2RIZW5seHhsT2szT1Rtc2xTbFRqbi9sNlltTGQ1NTU1M1BsM3Z4MU56YzNLbmJiNzk5TlFBQUFBQUFBQUFBdUNBSk1BSUFBQUFBQUFBQStHTXNIbDE4VjZTNHBvbm1yNlNVcm9neit5MWVDVlZoTkdablp3ZlRNOVA1QjM3Z0I5cXRWcXZxZHJ1ZDRLSXdPVG01MGY3RjkvL0YxdnI2ZXY3eWw3Njg5dFJUVDZYUGZlNXp3M0VhREFadXpyTXNSeDVtR2RXbHU2YzhMdytrT2kyMW9yVlUxdUx2SGo5Ky9PREhQdmF4VHdzeEFnQUFBQUFBQUFDNE1Ba3dBZ0FBQUFBQUFBRDRHcmZlZW12cmxsdHVtWnFZbUppcXF1clMvbHIvaGhScFQwcHBJdWVOa0k3ZzdIdmx2RTlQVCtkT3A1TzM3OWdlbXpkdlRxMVdLK3E2RGk1ZVUxTlRhV2J6VExWbno1NVlXbHJLd3pwMTZwUWdveEVxejhxNjNMT2Q4Z3pkVmZvM3Z2amlpK3U5WG05MWNYSHg5K2JuNTNQcHJ3VUFBQUFBQUFBQUFCY0VBVVlBQUFBQUFBQUFBRi9qVEhqUjlZUEI0TmJjNUw4V0tXWktUUXlQQ1M4YW5hcXFjcnZkem05Kzg1djdXN1pzeWZ1dTN0Y3BZd3R5a1J0ZUEzc3YyOXNwRlc5Lys5dmpzY2NlNjMvbEsxOFpQUExJSTYyWFhucXBLdmV3YTJRRWhvRnZwWmtvNS8vL094dzN1Zm10MHB5ZW5wNSsvOXJhMnVuU1B4SUFBQUFBQUFBQUFGd1FCQmdCQUFBQUFBQUFBQmU5bi9tWm45bVVVcW9tT2hNLzJPUm1KZy95bThyNHNuS29XOXAyTUJJcFVwNmNtc3l6czdQTmxpMWJxaTFidDZUZHUzZlhrNU9UdWE3cmdEOW9ibTZ1dXZMS0syTjhmRHlkUG4wNkh2M3lvNE8xdGJWNDZhV1hYREFqVUo2ZktROUYzbFdHL1ZiVnVyM2MxNHNIRGh4NHFLcXE1M3E5M2lNQkFBQUFBQUFBQU1CNVRZQVJBQUFBQUFBQUFIRFJhN2ZiMHpIY1I1SGl4MUpLTXpubkd5TEhSb0pPTURwVnhOVFVWTjY5Wi9kZ0dFcHp4UlZYRFBlNkNLTGg2NXFkbmEyR3RYMzc5dWozKy9IQzhSZWFreWRQQ2pBYW9XR0lVV2tXWGg3RTdVMXVuaXBUbThyNmZLYk1DREFDQUFBQUFBQUFBRGpQQ1RBQ0FBQUFBQUFBQUM1YXZWN3Z6ZjErLy9JNjFkL2Y1R1l5Ujc0Nnp1eW5PQk82d1FqTXo4LzMyKzEyM0hEakRmWGs1R1MxYmR1MjF0VFVWQlh3RFJvZkg0K21hZUx0ZitMdDljcktTano5MU5QeHdnc3Z4SmUvL09WbU1CaWtjc3o5UFFJNTUyR1ExTTdjNU8rdjYvcXRkKysvKzkzOXB2L3JaYjErNStqUm8xLzl1Wi83dWRVQUFBQUFBQUFBQU9DOElzQUlBQUFBQUFBQUFMaG9iWVFYMWZWTnVjbC91cXFxNmZndjRVWEI2SFM3M1daeWNqSzk4WTF2VEoxT0owcS9EdmdtdEZvdmI0dTY5TkpMcTNLZmJ3UWFIVGx5SkI1NzdMR05ZQ05HNDB3dzNIaXA2eVBIV3FSNGMza0dIeDBNQmtmS2ZYNjB6QXN3QWdBQUFBQUFBQUE0endnd0FnQUFBQUFBQUFBdUdoLzg0QWVucHFlbkwxOWZYLyt1S3FydnlwRXZpeHlieXFIWm5MUGdvaEdwcWlxM1dxMTgwMDAzcFptWm1iVDNzcjJ0ZHJ1ZHV0M3U4RmpBcXpHOGhuYnMyQkh6Yy9PeGMrZk9kUGk1dy9uSWtTUE5VMDg5bFk0OWZ5emxKcnZ4UjJPNGQ2MmJJdjFvMHpRL01ONFovM3p2UU8vRVduL3RnZkk4Ymg1NDRJRmpBUUFBQUFBQUFBREFPVStBRVFBQUFBQUFBQUJ3MGFqcnV0VTB6VXhWVlZkRmptOVBrU2JMZEVkdzBXZ05BMmFHTlRzM0c5dTJiUnVHelVndDRqVXp2TGJHeDhjM2F0UDBwbkszcDd5K3ZqNE1NWXJTVDdrOERCaUo2a3p0SytzUXNmRVJKOHJ6ZUx4VVB3QUFBQUFBQUFBQU9DOElNQUlBQUFBQUFBQUFMbWgzM25ubnJxcXFkdFNwL3BzNThreHU4bzNCeUpVMXlUdDM3c3pYWEhOTmM5VlZWOVhidG04VFdzUlpzWHZQN21wWWI3M2xyVEVZRE9KWGZ2bFhUaTh2TCtkSEgzMTBJaGlsRzRkaFVuVlZQMUg2UzcwRHZaOVBrVDV4OTRmdi90OERBQUFBQUFBQUFJQnpsZ0FqQUFBQUFBQUFBT0NDOUpHUGZHUisySzZ1cnU3S09lOHMzZkVVcVRVTXlHQjBXcTFXN25RNk1UNCtIbFBkcVJnYkcwdDFxdzQ0MjFKS0c5WHRkdE9aTnRiWDEyTnRmVzM0bUVqbHVSR01WTGVzd2RaZXI3ZW45SmVYbHBaV0huend3Vk1CQUFBQUFBQUFBTUE1UllBUkFBQUFBQUFBQUhCQk9yMTgraWVxcXJvNjUveERNUXpDU0RrRkl6VU1MN3Jzc3N0T2I5MjZ0WHJudTk0NVZ0ZDFhcmZiQWFOUXJzZU5lcytmZk0vWWNIem8wS0U0ZHV4WS92akhQejVZVzF0THE2ZFhKV3VOd0VhYVZNU21IUG1ISThVUFJoTjNSSTVmbkp5Yy9NVTc3cmpqMXg5NDRJRmpBUUFBQUFBQUFBREFPVU9BRVFBQUFBQUFBQUJ3UWZqZ0J6ODQxZTEydCthYzk2V1V0a1FUMTVmcFBhVTZ3Y2pVclRvUDI0VmRDMmx5Y2pJdXZmVFNlbkpxTXRWMUhWVlZCWndyeXZOakl6em51dXV1Uzh1bmxtTnhjYkZaUEw2WVZsWldVdVJnTklZUGlVNU8rWXJTdm10c2JHemlycnZ1T3Q1cXRUNjF0TFIwNnNFSEh6d1ZBQUFBQUFBQUFBQ01sQUFqQUFBQUFBQUFBT0NDTUF3dmFwcm1sc2p4L2tqeDl1RlVxVlpLS1JpZHNiR3hwcTdyZk12YmJxbW5wNmZUd3NLQ1FDbk9TVnUyYk5tb1ljaldNTHpvMEtGRC9jOTk3bk90WjU5NU5wVm5TK1FzeFdnRWh2dmJXaW5TOEpuKzl0ems5OVJWdlRRWURENVFuaTFIeTV3QUl3QUFBQUFBQUFDQUVSTmdCQUFBQUFBQUFBQ2N0ejcwb1EvTnROdnRiVlZWZldmTytaS1UweldSNHNweWFMeFVGWngxRzRGUjVYL3pjL1BOM054YzNybHpaNHlOajFWYnQyNU5ZMk5qQWVlRHljbkpkTWtsbDlTUkkrM2R1emVlK3VwVC9aV1ZsWHpzMkxGVzB6UlMwVVpucmxTM2l1b25VNTFPSFRodzRLRXlQdnJoRDMvNFB3VUFBQUFBQUFBQUFDTWh3QWdBQUFBQUFBQUFPRysxV3EzTlZWWHRTNUgrU3VTWWl4UjdncEdyVWhYelcrYnp2bjM3QnFYYW16WnRFdmpDZVdWaVlpS1ZxcmRzMlJLRHdTQWVhajAwT0w1NHZEbCsvUGd3d0NnWW1XR0FVWG5jNTc5Y1Bzb2pQLzFDR1Q1Y1NvQVJBQUFBQUFBQUFNQ0lDREFDQUFBQUFBQUFBTTQ3Qis0NmNGdEthVnVPL0YzUnhGUlVjWG1aN2dRalUxVlYzcnQzNzlyV0xWdXJLNjY2WWhoYVZBMkRpeVltSmdMT1YzVmRiOVNOTjk3WTd2ZjcrZkxMTDArcnE2djVFNS80UkJuMjA2bFRwK3kvR3FVVTMxN2VBemNjT0hEZzV2Sk9lQ0lOMHEvMW8vL1orKzY3NzdFQUFBQUFBQUFBQU9Dc3NJRUdBQUFBQUFBQUFEanZwSlN1SzgyMlVtK0w5UEpVTUZMRGtKZE5telkxVzdadFNYdjI3SWxXcTVXR0ZYQWVxNnBxbzUyWm1kbm9ORTBUSjArZUhGN2ZPUmlaOGc1NDVkbXlwZFJjcVIyUll5cW4vS1ZXdi9WSUFBQUFBQUFBQUFCdzFnZ3dBZ0FBQUFBQUFBRE9lZnYzNy8rMk91cHZ5NUcvUDZkOFRXbDNwMGdwUklpTTFQVDA5UG93dU9pOTczMXZ1N1JweDg0ZDQrMTJleGp1RW5BaG1wdWJHMWI2c1IvL3NmYkpsMDdteHg1N2JQM0pyejVaUGZYVnA5TGErbHJLVFJiYWRaYVZkMEdWY3g0dm5UZVh1aWJhOFJPOUE3M2pVY1dCOWZYMXgrNi8vLzVuQWdBQUFBQUFBQUNBMTQzZFlnQUFBQUFBQUFEQU9lbldXMjl0bGVybTVkek5UZDZUcTN4cHBOaWJVdHBieG1QRDFJb2lPSHRlT2QrdFZpc1BRNHFtcDZkVHU5M09tMmMzeHpESWFISnkwb0p3UVJ0ZTUwT2JObTFLdy90ZzgvSE44ZUtKRitPbG1aZGlaV1VsMXRiVzh1cnFxdnZnTER2ek1wZ2NWbzdjbEhhNnZDZXVyYXBxME92MUJzTi9wclNIQXdBQUFBQUFBQUNBMTV3QUl3QUFBQUFBQUFEZ25OUHI5VnJyNit1N1N2ZUdOSjcrcDlMT2xwcmJPSmovUzVBT1oxYzU3N25UNmVScnJyMW1zR3ZYcnJ4djM3NzJNTWdsNENJME1URlJYWC85OWRVYjMvakc2UGY3OGFVdmZXbjk4T0hEelc5LzVyYzdRb3hHYXN0RzVmaTdLY295TlBIeE1oNkdGLzFJQUFBQUFBQUFBQUR3bWhOZ0JBQUFBQUFBQUFDY1UzcTkzcFdsMmR4dXR5OGZEQVpYMXFrZUQzc2NScXF1Nnp3MU5aWEh4OGJ6OU9icHRIWHIxclJwMDZiaGZNREZiaGlvVmxWVlRFNU9wdm41K1hUSkpaZkUrdnA2SEQ1OE9CZFJubVBDakVZb1I1NHBIeXY3OSs5L1Y5TTBLNjMxMXJNeEVTL2RjODg5THdVQUFBQUFBQUFBQUsrYXpYMEFBQUFBQUFBQXdMbWxpZnZLNTk0bU4yOU5rWWJoRThJL1Jtd1lYblR0ZGRldTc5eTVzOXEzYjErN3FJUVh3Y3VHOThLd3JycnFxbzI5V09VZWlhWnA0cC84NDMvU1gxdGJTeSsrK0tJOVdpT1Foc2xTTDd1eGRITVYxWGVYZGZwMHJ2TFBSejgrVmVZL0ZRQUFBQUFBQUFBQXZHbzJ4d0FBQUFBQUFBQUFJM1gzM1hjdlJEOFdtcXA1UzBwcE5rZSt0a3h2RGtacVltS2lxYW9xWDMvOTlmWEU1RVJhV0Zpb3U5MXVhclZhVWVZRCtLT05qWTFGempsdWZ1dk4xY3JLU2h4KzduRC94SWtUNmZEaHcxV1RtOGlOVUxhejdVd1FYbFhhM2FYOW5takZWUWNPSEhoSGVaNGRiSnJtMk1HREI1OHQxUThBQUFBQUFBQUFBTDVwQW93QUFBQUFBQUFBZ05IcXgwSlU4YllVNmErVXVxSlVQUXliS0lMUm1aeWNiT3E2em05Nys5dnFWcXVWdXQydWZTYndEUmdHR0EzZGZQUE45YWxUcDVwRFR4enFQL1hVVTJseGNUR3RyYTJsOG53TFJtS1l2TFlRcVZTT3BmS3VXV3FhNW1TWmUrUjk3M3ZmRVFGR0FBQUFBQUFBQUFEZkdodkxBQUFBQUFBQUFJQ3pxdGZydGVxNnZtd3dHRnpiTk0ydE9mSkNpclM3aW1wTGs1czZ5aUE0NjZxcXlzUEFvb1dGaFR3L1A5L3N2V3h2M1c2M2gwRkdJVXdLdmpVVEV4TnAxOEt1MXV6YzdMQk5UejMxVkhOODhYano5Tk5QMTZ1blY0ZGhSbTZ1RVNpdm1iSGgreVkzK1Mrbm5JNGVQM2I4MDczOXZlT3IvZFYvWE41TmF4Lzk2RWRQQmdBQUFBQUFBQUFBM3hBQlJnQUFBQUFBQUFEQVdUVTNOMWNmUDM1OCsyQXd1SzVLMVErWHFlNndjbVJCT1NNMFBQZDFYY2YyN2RzSHUzZnZ6dnV1M3RkcXQ5c1dCRjZGcXFyUzVzMmI2MUp4eVNXWERPK3pwdHhuemJIbmoxV3JhNnNwbW1BRXl2dW1YZGFpblhPKzZjeTdaNzVNUDEzVzZ4ZEsvM1RwQ3pBQ0FBQUFBQUFBQVBnR0NUQUNBQUFBQUFBQUFGNTNkOXh4eDlhcXFqcnR1djAzano5L2ZEeEh2amxGbXNvNUQ4T0xLc0ZGbzFIV0lNL016RFNYWFhIWllPL2V2WFdwcWwyMFdxMFFYZ1N2dlRlODRRMnRLNjY0SW02ODhjWllXMXVMWC9ubFgxa2ZEQVp4NU1pUmRuRFdsWGRQeWtPUmJ5akRON1hxMWszbHVmaFVyOWY3eGJJdW43ajMzbnMvRVFBQUFBQUFBQUFBL0xFRUdBRUFBQUFBQUFBQXI3dVVVaFV2NzFQWVVXbzg1N3p6ekx5UW5GRWFya3BaZ2ZIeDhkenRkb2RoUnRZRFhrZXRWaXNOQThLR29VVmpZMlBEb0xEc09UaGFaODcvK0REUUxVZGVhSEtUVTA2elpYbzhBQUFBQUFBQUFBRDRmeVRBQ0FBQUFBQUFBQUI0M2R4MTExMS9ycTdybTFLVGZqaW52RHRIM3RpcklLOWp0QzY1NUpMMW1abVorSjd2L1o1MnE5V3F1OTF1SGNCWlUrNjVqZmJIZitMSE8vMStQNTUrK3VsNDRva244a09mZWlpdnI2K253V0RnSVhtV2xmZlQ4SnkzeXZ2cHNqTDQ2eW5TLy8vdUEzZWZMdk4vdTZxcVg1dWJtL3YwN2JmZnZob0FBQUFBQUFBQUFQeFhCQmdCQUFBQUFBQUFBSytaVzIrOXRYWExMYmRNVFV4TVRKWGg1VG5uNjZPSlBVMDA0NUdIdVVVeU9VYmhsZk0rTnpjWDdYWjdHR0FVbTZZM3BWYXJGWFV0dXdoR2JYeDhQS2FucDJQUG5qMXg2dFNwdkh4cU9VNHVuVXpEY0NOR3BpclZxbEoxU1htWDNmamlpeSt1OTNxOTFjWEZ4ZCtibjUvUHBiOFdBQUFBQUFBQUFBQUlNQUlBQUFBQUFBQUFYanRud291dXp6bC9aK1Q0cVRJMUdTazZLUVFYalZKZDE3blZhdVZiM25aTDJyWnRXMXBZV0dnUHc0dUEwUnZlaXp0MjdCaFd1dW1tbTlKVFgzMnErZXBYdnpyNDdkLys3ZXFGRjE1SVRkTjRnSTVHWjFqbGZmYUI0YURwTncrVjV2VDA5UFQ3MTliV1RwZitrUUFBQUFBQUFBQUFRSUFSQUFBQUFBQUFBUERxL05SUC9kVEUrUGg0ZDJ4czdLYkJZTEM1VEYxWDZ2cDRPZnloQ2tabVltSWlabWRuODdBbUp5ZGpibTR1dXQxdVZKVmxnWFBWVkhjcXRtL2ZudDc0eGpmRzB0SlNETU9NMXRmWDg4bVRKKzMxR3FFY2ViNDAvZkw4L0xOMVhiL1l1N1AzeFRyVmkvdnYyLytsQUFBQUFBQUFBQUM0aU5uVUFnQUFBQUFBQUFDOEtwT1RrM05WVmUySUp2NTZsYXFaM09RYmc1RXJhNUxuNXVieU5kZGMwMXgxMVZYMXR1M2JVZ0RudkhMZlZzT3dzVDJYN29tbWFlSlhmdmxYMXBlWGx3VVlqZDZWdzQ4VTZjSHlubnN1MWVsWG1tZytVYVlFR0FFQUFBQUFBQUFBRnpXYldnQUFBQUFBQUFDQWI4bGRkOTMxcDl0VmV6NUhmbmVUbTduU1hoMzJJb3pjdG0zYjFtWm5aOU5WKzY1cVRVMU9wZm41K1hwbTgwd0E1NWRXcXhVNTU3ajU1cHRiYSt0cnNYMzc5bmp4eEl2NTBVY2ZiWnBCazliWDE2dGdKTXE2RE45OTc2eFN0ZS91L1hlL0phZjh1Y0ZnOFBuVjFkVXZQUGpnZzZjQ0FBQUFBQUFBQU9BaVl0TWdBQUFBQUFBQUFQQXRxYUs2ZWhoYTFPVG16NVJodDFRS1JtNW1abVl3UHo5ZlhYZmRkYW11NjJpMzJ3R2NmNnJxNVh5aWhkMExyVmZHeDQ0ZGl5ZWZmREt2cmExRnJBY2prSXJTakpXNnFyd0RMeTF2dnV0VFR0UGxlZnRTZWQ0K1VlWUZHQUVBQUFBQUFBQUFGeFVCUmdBQUFBQUFBQURBTitUKysrL2Z1cnE2ZWwzTytlMVZWRytQRlB1YTNHeUtsOE9MR0pGMnA5MjAyKzM4bHB2ZVVrMU9UcWJMcjdpODAyNjFVNmZUaVpkek5vQUx3WTRkTzJKK2ZqNlZ0bjdwcFpmeU0wOC9zLzdFRTAvVVI0NGNxY3B6T1liRldUZmNmOWN0Wi84OUtkS2J5N1A0ejk1OTk5MG5tcWI1V0wvZlAvekFBdzhjQ3dBQUFBQUFBQUNBQzV3QUl3QUFBQUFBQUFEZ0c3Syt2ajVWbW0xVlZHK01GTjllK3QyVWtyMEhJMVpWVmE3ck91L1l1U01tSnlkajI3WnRkUUFYblBIeDhZM2F0R2xUV2x4Y3pLZFBuODVQUGYzVVJsQ1o4S0tScVlaVjFtQjdhYmVuU0ozSXNWVDY0K1haM0FrQUFBQUFBQUFBZ0l1QVRZUUFBQUFBQUFBQXdOZDE1NTEzN3FvRzFiYXFYZDNYREpwTHk5UzJISGt5Y2t3T2p3K0RNempMeWltdnF6b3UzWHZwWU4rK2ZZT2RPM2UyWm1kbnEyNjNhekhnSWpFL1AxK1Y2cnpwVFcrS3dXQVFEejMwME9yeHhlUE41ei8vK1lsZ2xLNGNmcVJJRDVYbjlQTGQrKy8rMVRKOCtKNTc3OWtmQUFBQUFBQUFBQUFYS0FGR0FBQUFBQUFBQU1BZjB1djF0ZzNid1dDd045VnAyTjhiT1daU1NsdURrV20zMjdsVWpJMlBwYzB6bTJOcWFpcHQzcnc1cHFlbmhSZkJSV2dZSWplczRiUGc5T25UYWRPbVRSdnpwMDZkeXJrOHRIT1RQUnRHYXpLcTJITG5uWGRlV3A3ZEt6bm4wL1B6ODZ1MzMzNzdhZ0FBQUFBQUFBQUFYQ0FFR0FFQUFBQUFBQUFBZjBnZTVOdEtjMTJLOUFPUlMyOGpJME1PeGlnTnc0dXV1ZWFhMDNQemM5VXR0OXd5MW1xMTZtRUZjTkVxejRDTmVzdGIzdElaam0rNDRZWllYbDdPdi9TTHY3Uyt1cnBhTFMwdDJSODJBbWRlbUZPbC9tVE91YW5yK3YzbHZmcHJaZnhyeDU4Ny9oOUsrMGdBQUFBQUFBQUFBRndnYkZBQkFBQUFBQUFBQU9KakgvdlkyT0xUaTF2VFpObzhHQXhteTlTZVNMRmxJN3lJa2Fuck9nOXpNR1puWjJOcWFpcTJiTjFTemN6TXBLcXFRcUFVOEFkMU9wM285L3V4c0xDUVZsWlcwdUxpWWk1dERQdkQ0emw3cUk5SWxTUFBwMGhYcEhhNi9zUDdQN3hwcGIveWxhWGk1Mzd1NTFZREFBQUFBQUFBQU9BOEpzQUlBQUFBQUFBQUFJamp6eDIvSXNiaVR6YUQ1cytsbE42Y0kzZFNwRnBJem1oMXU5MStxOVhLMy9mZTcydHYyclFwYmQyNmRTd0F2bzY1dWJsaHBZV0ZoZmJpNG1KejZOQ2g5Y2NlZTZ4Ni9MSEhxOVcxMVJRNVBOVFBzdkl1clVvelZqcHZMKzNibTJoK3FMeGJUM1k2blIrZG5wNCtVdWFlREFBQUFBQUFBQUNBODVnQUl3QUFBQUFBQUFDNFNIM29ReCthYWJmYk8xcXA5VDFOYmhaU3BPdFRTcnR6NUZia3FNUmNuSDJwU3JsSzFUQ0FKTS9PenVaZHUzWlZFeE1URzZFa1phMEM0QnMxT1RtWkxybmtrbnFzTTVhMmJkdVdubm42bVdabFpTVS85OXh6OVdBdzhJUWZrZkt1blJxK1ozUE9QMW5YOVZKdmYrOTN5anYzY08rKzNyOExBQUFBQUFBQUFJRHprQUFqQUFBQUFBQUFBTGhJdFZxdHphV3VqaVp1cjFMVnpaRzNEK2ZUTUxsSXRNVklETTk5dTkzT1c3ZHRiYTY0NG9wbTM3NTk3VTJiTmxrTjRKczJNVEdSU3RWYnQyNk5mcjhmdi9NN3Z6TjQ0WVVYOHJGang0WUJSc0ZvbEhmdFZHbW1TdWNuTnlaU2ZMelU1MHBQZ0JFQUFBQUFBQUFBY0Y0U1lBUUFBQUFBQUFBQUY1bTc5OS85MzZWSTNTWTNiMjRHVFRlbHRMVk10NE9ScWVzNlgzYlpaZjNOczV1clN5NjVwSnFabnFtSC9iR3hzUUI0TmNyekpjcHpQcTY4OHNyVzZ1cHFucHViaStXbDVmalBuL25QL2NGZ2tKYVhsK3RnWkhMa3EwdHpTYS9YNjViMWVMeksxWCtPT2g2NTU1NTduZzRBQUFBQUFBQUFnUE9BQUNNQUFBQUFBQUFBdU1pa2xMNjlORHRLdmZPVnFXQ2toZ0VqVzdkdGJYYnUzQm43OXUyclc2MVdsTEl1d0tzMkRDOGFQbVBtNXVhcTRYaHFhaXBPbmp5WnYvRElGL0xhMmxvc0x5OEhaMThhTHN6TGR1U2N0MGNUbDlXcC9uU092SnpXa3ZBaUFBQUFBQUFBQU9DOEljQUlBQUFBQUFBQUFDNXcrL2Z2LzdZNjZtOXJvdm5US2FWcm05d3MvSmZjQkVabFptYW1Qd3dxK29FLzh3T3RxcXJTL1B4OHA5MXVid1NOQUx4ZXV0M3VzTkpmK0l0L29YWHExS25tcTA5K2RlMkpKNTZvSG4vODhXcHRmUzNsSm50Qm5HWERNS09jY3gwcGJpaDFkZE51L21ydlFPOUVWUEhSd1dEdzVMMzMzdnZwQUFBQUFBQUFBQUE0Undrd0FnQUFBQUFBQUlBTFhOVlVZN25LMDFXcXR1WEllMHRibHpZSk1ScXQ0Zm12NnpwUFQwOUhWVlV4TVRGaFFZRFgzZkI1TTdScDA2WTBERStibXBySzdYWjcrRktJNGEveWZnak92ak12NWNtTnlsSG5sS2ZMZXN5Vjk4VGhBQUFBQUFBQUFBQTRod2t3QWdBQUFBQUFBSUFMek1jKzlyR3g0OGVQMzF5NjErUW0zMVBhN3JCZUNhVVFUakVhVlZYbFRxZVRiN3p4eHY3dTNidnozc3YydHFlbXBxb0FHSkhoTStqYTY2NGRLN1V4ZnZqaGg5ZWZlZWFaNXJPZi9XeDdkWFUxbFhlSVlMVVJTQ25ObEdhbUdUUi9iemp1SGVoOXZEVFBydy9XZjdwcG1xVUhIbmhnTVFBQUFBQUFBQUFBemhFQ2pBQUFBQUFBQUFEZ0F2Q0JEM3lnUFRZMlZzM1B6Ny94eFJkZkhNczUzeGc1OXBaRG5kS3ZVNUpCTVNwMVhlZXBxYWs4UGphZU44OXVUbHUyYktuS3VLbXF5cUlBNTVUeDhmRlUzaVBwa3AyWHBQWCtlaHc1ZkNRM1RSUDlmdC96YW9SeTVKbnlzZDZ1MnJkRWl1TjMzWFhYWStVOTh1SWRkOXp4UWdBQUFBQUFBQUFBakpnQUl3QUFBQUFBQUFDNEFHelpzbVV1cFRRZVRmenRwbW5HYzg1dkhjNm5sd1dqa2FxVU4yM2ExTHp4bWpmMmQrM2FWVjEzM1hYdE1sMEZ3RG5veWl1djNOaFB0bS9mdmhnR0YvMnIvL05mclowK2ZUb2RPWEtrSFp4MVgvTUN2N0YwYzQ1OGE2UjR1RTcxdjF0WldmbVBaZjdYQWdBQUFBQUFBQUJneEFRWUFRQUFBQUFBQU1CNXJOZnJYVjZhelRHSU56ZTUyWlFqYncvN0FVWnVZbUtpR1JzYmkxMEx1MUxwcDJGNDBkemNuT0FpNEx6UWJyY2o1eHhYWG5WbHRiYTZGcHMyYllwVHAwN0ZrU05ITnVhSHhkbFZ6bm9xNTMyWWFiUTU1WFQ5TUNDdi9Bd3dmT2QvcXRUU3dZTUhqNWZxQndBQUFBQUFBQURBV1diRElnQUFBQUFBQUFDY3gvcjkvcHZydXI0cFJmcmhWS1hkY1dZdlFFb3BHSjNaMmRuQnpNeE12T2M5NzJtM1dxM1U3WGFGRndIbmpZbUppWTMyTzc3ak8xcW5UNStPdzRjUHh4TlBQSkZmZU9HRnZMNituZ2FEZ1pmTUNKUjNlMTJhdlRueTNtaml1MHIvZEhuMzMxSGFoOS8zdnZkOVdvQVJBQUFBQUFBQUFEQUtBb3dBQUFBQUFBQUE0RHp5d1E5K2NHcG1adWFTd1dCd2ZSN2s3NG9xM3BDYnZEV25QQnM1YXNGRm8xRlZWYTdyT2w5Ly9mVnBjbkl5TGV4ZXFJY0JJS1V2VEFvNHIzVTZuZGl5WlV0TVRrd08yM1RzNkxHOHVMallQUDc0NDlYcDFkTlIza0VlY3FQUkxsV1ZkLzlmYW5KejdQaXg0Ny9WMjk4N3ZkcGYvZC9LendockgvM29SMDhHQUFBQUFBQUFBTUJaSU1BSUFBQUFBQUFBQU00amRWMjNCb1BCOXB6emRaSGlSeVBIWkVxcHMzRlFoTVRJREVPS3l0ckVqcDA3WXR1MmJiR3dzRkMxV3JabEFPZS9xcXFpMiswT0syM2J2aTJlK3VwVGVXeHNMQjgrZkRpdnJxNm1YRjVFakVROXJQTHp3RnZTOEFlQUZITmxmTHFzMXo4dDc2VFRwUy9BQ0FBQUFBQUFBQUE0Syt5VUF3QUFBQUFBQUlCejNCMTMzREdmVW1wMVdwMDdJc1ZNMHpRM1ZGRnR5NUc3T2VkNkdKN0QyWmVxbEdjM3orYkxMcnNzYjkrK1BlM1l1U1BOenM1R3U5ME80VVhBaFdyYjltMXBlbWE2M3JXd0s5YlgxK1BUdi9YcHRhV2xwZnpzczgrT0JTTlRmaWE0ZXRqV1ZmMVBTL1A4Z2JzTy9GOU5ORis2Nzc3Ny9rMEFBQUFBQUFBQUFMeU83SllEQUFBQUFBQUFnSE5jVlZYajhmTC94Mzlqem5rbVJib3hSOTQ0SnJ4b2RNbzZ4TVRFUk16TnplV2RPM2VtM1h0Mld3emdnamMyTnBaS2JUei9tcWFKaDMvMzRXWnRiUzBZdWMxbjJyZVZudzJlSzNXMGp2cjVBQUFBQUFBQUFBQjRuUWt3QWdBQUFBQUFBSUJ6MUQwSDd2bnhIUGtkVFc1K3FBeTdwUzhnNXh4dzFWVlhyVXhPVHFidmUrLzNqZGQxbmRydGRoVUFGNWxPcDdQUi91RDdmbkM4MysvSDAwOC9IY2VPSGNzZi8vakhCNnVycTlYYTZwcG40d2lrbDVNTkx5ay9NL3lsVW4vaDdnTjMvMCtsL1VkbDdwUHI2K3UvL3NBRER4d0xBQUFBQUFBQUFJRFhrQUFqQUFBQUFBQUFBRGhIZk9BREgyaFBUMDkzdXQzdVJCbE81a0hlR2ltNndVaHRaRUdreUZPVFV4c0JVbE5UVTJsWUwyZEVBRERVYXJWaWNuSXl5bnNzblY0NW5aZXI1Ynkrdmg3OVFiODhRWU1SR0FZZnBraFZlVjlOTlUyenRhelJKYjFlcjMzdzRNR2p3K09sN1FjQUFBQUFBQUFBd0tza3dBZ0FBQUFBQUFBQXpoSFQwOU96azVPVDc4NkQvS2NpeGJBbXkzUkhVTTVvZGNZNmcwNm5rOS81em5mV1c3ZHVUWHYzN2gwUEFIN2ZNTHhvWVdGaFdPbmFhNit0bjN2dXVjR3p6ejY3L3JuUGZhNzE3RFBQcGtFekNDRkdaMStLMUM1TnU1ejduNnhTTlp6NlNtN3kwanZlOFk0L1Uvcjlnd2NQUGhNQUFBQUFBQUFBQUsrU0FDTUFBQUFBQUFBQUdLR2YrcW1mbXFqcmV0UDQrUGpiV3EzVzVxWnAzcFpUdmlKRjZwVERWVEFhS1dKaVlpTFB6ODNuK2ZuNW1KeWFUSE56YzlIdGRnT0FQOTdrNUdTVVoyZDExWlZYeGZEWitkeXp6dzNXMTlmekN5KzhZTC9hQ0pXZkxXWnk1RTVWVlg4MnBiUjY0TUNCUjByL1dLL1hlemdBQUFBQUFBQUFBTDVGTm9RQUFBQUFBQUFBd0FoTlRrN09WVlYxU1pXcWUzS1R1eW5TbGNGb3BZaTZxbVBybHEzNWhodHY2Ty9kdTdjMURPSUlBTDRoTXpNemRhbll0V3RYREFhRCtJMkR2N0crdkx3c3dHakVjdVN0dzdiOHJQRmdHU3lYOWxlYmZ2UHJaVXFBRVFBQUFBQUFBQUR3TGJNaEJBQUFBQUFBQUFCRzRQOW01MC9BNURqdis5NzMvOWJhKy9STXp6NER6SURZU0JBQUtYQVZZUkxVWmttV0hhK0puZU9UM0Z3N2pyTWM2L2dvdWs0a0VVQlRTa1RKWnV4emRXOXVuR1BmSlBiSmVhNTlJai9IamkxTFhpUlRvc1hGcEVDS0JBR1NBRWtBQkRBQUJyUDNUSzlWNzMzZkFrQnI0WUlaQU5NemcrK0hmT2Z0cXA3dTZucXIzdXEzTUZXL2ZmdjJ2Y2RVdlVxclcwM2RaVXEvS1lHZ3JmcjYrcHFaVEVZTnJ4djJpc1dpR2h3Y2ROUHB0QklBd0tJNWppTktLZG00YWFQWGFyVzA3L3RpZzR5T0hUc1dtMm5WYURRSWgyc1RzMTE4VTkzb0tNYzNZNUtDZWZ5cWl0UnI0c21oQng5OGNGWUFBQUFBQUFBQUFBQUFBQUF1RXdGR0FBQUFBQUFBQUFBQUFBQzBnZExxdmFiYXJrVi93TlFaSllxUW5CV2d2NysvMVZYcWN1NjY2eTdQZFYzbCs3NHJBSUFsTWNmUnBONjBhVk55blZxeFdKVHo0K2YxMmJObm8zcTk3aEJnMUI1S0pXTU9HNXA0bzFaNmsyaDVyeG1YZkZVYythcFU1YVNaVDRBUkFBQUFBQUFBQUFBQUFBQzRiQVFZQVFBQUFBQUFBQUFBQUFDd0RQYnYzeitzSW5WMzdNUzd6T1F1TFhxTEVwVVhMUmxCMjZSVDZTZ0lnL2lPTys3d01wbU1HaGtkQ1R6UFUwRVFpQ0pUQ2dDdXFxNnVMc25uODZxcjFPVk5UMDNMeVpNbm04ZVBIM2ZHeDhkVnM5VlVPdFljZUplWmFYTlh6SURFakV2ZWJiNzNicFNVdkhmLzN2MXp5bFdmcjlmcll3ODk5TkM0QUFBQUFBQUFBQUFBQUFBQXZBMENqQUFBQUFBQUFBQUFBQUFBV0FhcW9RcmEwOE5LcXgxYTZmdk1yTUFVbDVDYzluSTlWM3VlcHdlSEJpV1R5VWlwVkhJRkFIQk4ySEE0VTFRMm0xVmhHTWJWV2xXUG5SblRqdVB3WmRnbTZzSkF4SVlZbFV4ZFVxTFM1bkZOYTUweTJ5VVFBQUFBQUFBQUFBQUFBQUNBZDBDQUVRQUFBQUFBQUFBQUFBQUExOGluUHZXcG9TaUsrbE5CNnQrSmxpNVJNbVJtcDh6alZQSUx4RFVzTytVb0Nmd2dYcmQrblI1WlB4S1BqSXk0blYyZGJpYVRZV3NBd0RJcUZvdHF4NDRkL3FaTm02VFJhTWpCZ3dlYnM3T3o4c3lCWndqTmFTTXRlc0JVc1k3MUYxM0hyWlgzbFErWW1jK1dQMVArbkFBQUFBQUFBQUFBQUFBQUFMd0pBb3dBQUFBQUFBQUFBQUFBQUxqS3l1Vnl2NjJqS0JyMWZiOVB4M3BVbEdUTnJDNDdYeW15Y3RvaERFTnR0b2RrTWhucDZPaVFZbWRST29vZGtzL24yU0FBc014YzExV21pT000a2txbHBGUXEyV2xkS0JTUzV5dVZpamFVS1lKbDVWd3N3NmJVVEprMFk1aVdHZHVNbXNjTFpudlV6TGFxZi9Takg2MExBQUFBQUFBQUFBQUFBQUNBRUdBRUFBQUFBQUFBQUFBQUFNRFZGOHUvTmo5dlZhTHVpNlBZQmhZUmtOTm1RUkRvWGJmdGFuUjJkcXFkTzNjR251ZUpLYTRBQU5ycTR2Rll6TEhadDlPbWx2bjVlZjFIZi9oSHJXcTFxdWJtNXJqR3JRMHVqbDNTV3ZSZFd1czdWYXgrV3JUOHVabjNGNU5qazdZK0pBQUFBQUFBQUFBQUFBQUFBRUtBRVFBQUFBQUFBQUFBQUFBQVYyei8vdjBGcVVvaER1Tk9NOW1sdFI0U0pSMkN0bkpkVjl2OGhhNnVMcFhQNTZWVUtxbGNMcWNjeHhFeXBRQmdaYm9VYURRME5LUVdGaGJVNU9Sa1BEOC9yMnlZa1gzZWZNY0tscDlwZDV0cDFDVmFOc1orZk11blAvM3BqamlPajV2dE12LzV6MzkrUmdBQUFBQUFBQUFBQUFBQXdIV0xBQ01BQUFBQUFBQUFBQUFBQUs1VVM3WkpLSGU3eXYxN1d2UWRXbXRYMllnY1FuTGFLcC9QUjBFUTZCLzlzUi8xekdOVktCUUNBUUNzYUxsY3poWmxqOTNUMDlQUnFaT25taSs5OUpMejhzc3Z1L1ZHWFlrV3ZseVgyY1VCald2SzNhYjE3emJiNEI5RXJhaHF4anovUEoxT2o1djVmeTBBQUFBQUFBQUFBQUFBQU9DNlJZQVJBQUFBQUFBQUFBQUFBQUNMVkM2WDdkL2JCNk1vNmxGSzNTOUticEJZYnRDaTE1bjVqcUF0Ykw2Q0xhVlNLYzVrTXJxL3YxK0ZxVkN5MmF6eWZWOEFBS3VMT1hhcllySG9yQjlaNzRSaEtHTmpZM0c5WHBmSnlVbkhmQWNUWk5RbTVyczJOSldydFBwN090SUw1YjNsVGFMbGZMVlpmYlN2cjYveHNZOTlyQ29BQUFBQUFBQUFBQUFBQU9DNlFZQVJBQUFBQUFBQUFBQUFBQUNMMU5YVjVVNU9UcTUzWFhlYmp2WEhSVXRPbENrWDJSQWRMRC9UN2pvSUFyMXg0OGJXdW5YcjlPaUdVVCtiemJvQ0FGaVZ6REhjc1dWb2VDaVpmdnJwcHhzVEV4UDZtV2VlOGVONkxPWTdtQy9jOWtqWkgxcjBUOXZhZlA5dUZFY09lOXA3Zm54OHZHSm1FV0FFQUFBQUFBQUFBQUFBQU1CMWhBQWpBQUFBQUFBQUFBQUFBQUF1d3kvLzhpOFgwK20wRzNyaHowNmVuK3pVV3QrcGxjNktsZzVIT1o0MkQ3RDhsSmlOa00zcS9vSCtxS3ZVNWF4YnQ4NHBsVXBlSnBQUmdSOFFiQUVBYThqR2pSdTlvYUVoM2RYVnBWcXRsano5MU5PdFpyT3BabWRuQ2F0ckl6TUcycXEwR2piam9TNC84Rjk5NElFSHZ1VjUzcUZ5dVh4SUFBQUFBQUFBQUFBQUFBREFta2VBRVFBQUFBQUFBQUFBQUFBQWx5R1R5WVJLcVZTczR2c2NjWWExNkR0dFpwR1pwd2d2YWlOSHhQTTkzZFBiRXc4TkRjbjI3ZHR0aUFYQlJRQ3dCblYyZGpxMnptYXpFc2V4dkhqNHhiaFdxeEZnMUNaMkRIVHhZWCtzWSswNHpvalcrcURydW5iN1RKbjVCQmdCQUFBQUFBQUFBQUFBQUhBZElNQUlBQUFBQUFBQUFBQUFBSUMzVVM2WGQ4VnhmSnNqemdkakhmZUxscHUxMHZ5OXZjMUtwVkxMOHp4OTM1Nzd2Q0FJbk83dWJqK1ZTaEZjQkFEWGdVd21rOVFmL3FFUGU5VnFWWjA5YzFiT2paL1RCNTgvcUp1dHB0S3g1dnRnbVNXQmpscTdwaG8xWTZYL3djeDYzLzY5Kzg4cVYvMlc0eml2Rll2Rmx6LzYwWS9XQlFBQUFBQUFBQUFBQUFBQXJEbGNVQWtBQUFBQUFBQUFBQUFBd051STQ3aFRLWFdEeExMTDFPdVVLRmVMdHZmcEM5b25ERVB0Kzc0ZUdocFNudWRKTHBkamd3REFkY0llOTYzKy9uNm5WcXZaOEJ5cDFxcmlPSTZZNzJreDM5T0M1WGR4Y0ZTMHhXeUhYck1wTnB2SFh6SmpxVWtCQUFBQUFBQUFBQUFBQUFCckZnRkdBQUFBQUFBQUFBQUFBQUI4aHk5ODRRdmg1T1RrSFZycjk0cVcvOFhNU3BrNnBkV0ZNQVJDRWRyRGRkMGtzT2l1dSs5U0d6WnNVTVBEdy82bEFBc0F3UFVybFVySjZPaW9MZW85NzNtUE9ucmthSFQyN0ZsOTRNQUJaMnBxU3NWeFRNQmRlNlJzMGJIK0QzWmk4dnpraytWOTVaUE5xUGt2elJpcjl0blBmdmFzQUFBQUFBQUFBQUFBQUFDQU5ZRXIrUUFBQUFBQUFBQUFBQUFBMTczNzc3L2Z1MWgzejg3T2h1Wmh2eWtGVXh3bFNoRmExRDQycE1nVUhZYWh0aUVWbVV4R0NDNENBTHdWK3gxaHZqTlVSMGVIYUszRmZLOG5YK0t0Vm9zZ296WXlZNmxRS1JVNmpqUHN1dTdjWnovNzJWYWowYWlXeStVRkFRQUFBQUFBQUFBQUFBQUFxeHBYOUFFQUFBQUFBQUFBQUFBQXJudjMzSE5QU1NtVmtsaCtwOVZvcGJUb3V5NDlSM2hSK3ppT296czZPdlN1WGJ2aTlldlhPK3ZXcjNNRUFJQzNNYnBoMURWRmR0NnlVK0k0bGovNDRoOVVtODJtT25ic1dFclFUcmRxclc5Vm9qNmlZejNXcURXK2JNWmQvOTNNLys4Q0FBQUFBQUFBQUFBQUFBQldOUUtNQUFBQUFBQUFBQUFBQUFEWHJRY2VlR0NycDcxUzVFVGJ6V1JPaSs0VC9wYmVkdGxzTmtxbFVySnUzVG9ubFU2cHZyNCtsYzFsQlFDQXkrVzZyaWlsWk9QR2phNE5NUEk4VCtibjUrWGMrRG10WTYxc3VCSGFRMnVkTjl0bWsxWjZUN2xjemptTzg1TFpIaE1EQXdPbmZ2RVhmN0VwQUFBQUFBQUFBQUFBQUFCZ1ZlR2lTd0FBQUFBQUFBQUFBQURBZGN0My9IdTA2TjJPT0IvV1dnK1lXVXJRZGowOVBjMk9qZzc1MEljL2xISWNSNElnY0FVQWdFV3dBVWEyM1AzdXU0TldxeVhyMXErVFk4ZU82Y3A4SmFyWDYwNmozbkFFeTA3WlZDbVJ2QmwvN1RHanJydDByR3V0dVBVN1p0N2pZMk5qZjJ4cUFvd0FBQUFBQUFBQUFBQUFBRmhsQ0RBQ0FBQUFBQUFBQUFBQUFGdzNQdjd4ajJmVDZmU281M25EVVJUZEd1djRUbEV5cXJYT0M5ckdkVjN0ZXE0ZUhSbFZtVXhHclI5WjcyWFNHVEhiU1M3a0hBQUFzSFEyREs5WUxNcUdEUnRzS0o0ek16MmpwNmFtb3BNblR6clZXbFhwV0F2YXdsNi9tRktpN2hJdFEzRWM5Ky9idDY5V3I5ZC96NHpUV2c4Ly9QQzhBQUFBQUFBQUFBQUFBQUNBRlk4QUl3QUFBQUFBQUFBQUFBREE5U1NybE5vZVJkRzdsYWovbXlqSm1Ia0JJVG50WmNPTHdqQ01OMi9aN1BiMDlNanc4TEJudzRzQUFMZ2FMZ1VZbWFKR1JrYlUyTmhZZFByMDZXaHFhc3FwMStzU3FVaUVES04yOEM2V3U4Mll6UHl2dHBuSERUTUcrSXJydWpYem1BQWpBQUFBQUFBQUFBQUFBQUJXQWE3MkF3QUFBQUFBQUFBQUFBQ3NhWi80eENkS1NpblA5LzEvWXlZTG9tVzcxcm9rU25LbWRna3ZhZzhiSmxFcWxlTE5temRIM1QzZFRrOVBqMnZESmN4MkVzS0xBQURYa3ZuK2NmTDV2T3J1N2hZYllQVGN0NTlyVkNvVmZlellzVkRRVHV2dEQ5ZHgvMzlLMU5UK3Zmc1B4QksvOEpuUGZPYjNCQUFBQUFBQUFBQUFBQUFBckZoYzhRY0FBQUFBQUFBQUFBQUFXTk1jeDBtSi9mdTRsdHROblRObDA2WFFJc0tMMmtSZGFQdDBPaTJsN3BJZUdCZ1FVOWdZQUlCbEVRU0J1bGdram1ONTdkWFg0aWlLQkcyWHUxamZyVVdmVjZJYVNxdHpBZ0FBQUFBQUFBQUFBQUFBVmpRQ2pBQUFBQUFBQUFBQUFBQUFhMUo1Yi9ubnRPaTdUTmxqSmpPbTlBbmE3cWFiYnFxbE0ybDExMTEzaGFsVVNxWFRhZDkxWFFFQVlMbjV2cC9VOTk1M2IyZ0RqSGJ0MmlYajQrUHhVMDg5RmRXcU5hZGFxL0lGMVQ3ZG91UUhIZVhjdFcvZnZuOHVzWHpKUEQ1VWI5WC8rS0dISGhvWEFBQUFBQUFBQUFBQUFBQ3dZaEJnQkFBQUFBQUFBQUFBQUFCWUU3N3doUytFRXhNVG9WSXExV3cyMDFyMGlKazlhc3F3WEFnd1VvSmxweHlsbFduNmJEYWJ0SCt4c3lqcGRGcUt4YUk0anFNdWhVY0FBTERjekpnaHFUT1pqTElCUnZZN3ludzNKZDlSRmE5aVJ3NjYxV3FKS1VwckxWZ2U2dEtHTVp0R0t4MlljVVNucVVmTjJHNCs3YVZ2MlA4cis4T3YvODNYejloZmVPU1JSMW9DQUFBQUFBQUFBQUFBQUFEYWlnQWpBQUFBQUFBQUFBQUFBTUNhTUhGeW9rZEMrU2t0K24ydTY3N1B6TExKT0o0aXQ2aXRzcGxzRklaaGZQOTc3dmQ3ZW5wVWYzOS9TZ0FBV0dITTJFSE05NVF0enNaTkc1MnhzYkhvOU9uVHpZTUhEenBqcDhlY2VyM3VFR0xVQmpxNXh0RlRTdjJrcVg4eWx2am5WVXJWZHUvZWJjZDZyVWNlZWVTVUFBQUFBQUFBQUFBQUFBQ0F0aUxBQ0FBQUFBQUFBQUFBQUFDd2F2M1NMLzFTYU91ZVlzK3RzWTc3dE9pTnBwVE1MQnN5NENoRmVORnl1OVRtdnUvcmZENHZ4V0pSY3JtY3ltVnpFZ1NCQUFDd0dvUmhLT1o3VE5ud1BSdHVORFU1cFp2TnBwNmRuWFVFYldQR2VhRU5welRqakx2TVpLdGNMcjlxNm9xcGp3b0FBQUFBQUFBQUFBQUFBR2dMQW93QUFBQUFBQUFBQUFBQUFLdFdvVkRvOXp5dkw5YngveUZLVW1iV2tMMnBQVUYyVVh1WWRnK0RNQjRZSE5EYnQyK1BSa2RIdlZLcFJOZ0RBR0JWNmVycWNtM1pzR0dEUkZFa1R6enhSS05lcit2SEgzczhGTFJUdDdZeFJwSCtQZk80NWlqbmI4emtWOHpqendrQUFBQUFBQUFBQUFBQUFHZ0xBb3dBQUFBQUFBQUFBQUFBQUt0T3VWeitrRVRTSDZ0NHA5WTZaMloxQ244RGJ5dlhkZlhBd0VDVVRxZlYwUENRMDFIb2tQNkJmdGRPQ3dBQXE1VGpPS0tVa2cwYk5yaXRWa3ZyV0V1bFVwSFhYbnN0TXRPcVhxOFQwdGMrbmhZOVlyYlBlL2Z0MitlYjZWZFZwRjR4SThKRER6NzQ0S3dBQUFBQUFBQUFBQUFBQUlCbHdjV2JBQUFBQUFBQUFBQUFBSURWSjVZUGlaSmJSY3Q5eWJRU1FuTGF6SFZkV2JkK1hkVFoyYWwyN3R4cEpsM2wrNzRBQUxDYTJlODNhMlJrSkhsUUtwWGszTGx6c1MzVmFwVUFvelpSTmxWS3hBNDBSbU1kMnhDajk1aHg0WitMSTM4aFZUbHA1aE5nQkFBQUFBQUFBQUFBQUFEQU1pSEFDQUFBQUFBQUFBQUFBQUN3NHUzZnYzOVlJdGtXcS9oMjEzVnYwTEhlWldZUENOb3FtODNHanVQRXQ5MTJtNWZMNVdSb2VNZ3p4QVlYWGNnVkFBQmdiY2xrTWpJME9PUzg3LzN2azluWjJmanNtYlBOTTJmT09HZlBubFd0cUtYTUdJVXZ3RGJRV3J0bTdMSFRQT3lXdEx4cjM3NTlVMmFNOGwvTXVIRis3OTY5UndRQUFBQUFBQUFBQUFBQUFGd3pCQmdCQUFBQUFBQUFBQUFBQUZZODFWQUY3ZWx0cm5KL1dNZjZqb3MzcVN0Q2N0ckw5LzA0Q0FLOWVjdG1uYy9uVmFGUWNBVUFnRFhNZk84bFpldldyYzcwOUxUT3BETlJvOUdROCtmUHU2Mm9KVmgrM3pFZ0hFNktsazNLakI3ak9QNjZtUjQzaFFBakFBQUFBQUFBQUFBQUFBQ3VJUUtNQUFBQUFBQUFBQUFBQUFBcjB0NjllKzlRU20xenhQa1hzY1FkU2xTM0ZwMnk0VVdDdGxDTzBvRWY2QnR1dUNIZXNHRkRQTHBoMUV1bjB5cWJ6WklrQlFDNDdoVHlCU2V6SlJOc3VHR0R2Ty85NzVObm5ubW1PVE16STRjUEhmYnF0Ym95NHhhK0g5dkFqQlU3VFJXYmNlVC9XOGRheXZ2S2o1cnB3ODJvK2R0UkZDMTg3bk9mbXhJQUFBQUFBQUFBQUFBQUFIRFZFR0FFQUFBQUFBQUFBQUFBQUZpUlhOY05UUlhxV0s4VExXbFIwbUhuSzBVV1FMc28rNTlwZjkvM2RUYWJ0VVVJTHdJQVhLOGMxMUdCRzBnUUJNbDBMcGVUZXIydXhYNHpPcWJFZ2paUUZ3YUxydFo2NE9KMHY5a21OclRJTTQ4ZEFRQUFBQUFBQUFBQUFBQUFWeFVCUmdBQUFBQUFBQUFBQUFDQUZlRVRuL2hFeVhHY25PdTYvODRScHp1TzR2dnNmSFdCb0QyVW8zUVloUHBkdTk3VkhCb2Fjclp2Mys3TGhWZ0dBQUR3SFc2Ly9mWWt5ZWpkNzM2M1ZDb1YvV2RmK2JOR3JWWlRaOCtlOVFYTDd0SUFVb3ZlbzJOOW4rZDYvMWhjT2JoLy8vNnZtS2YrVzdsY1BpQUFBQUFBQUFBQUFBQUFBT0NLRVdBRUFBQUFBQUFBQUFBQUFHaXJoeDU2cUhOK2ZyNm9sRnJ2aXR0blpnMW8wUmxCVzNtZXB4M0hrYjcrUGdtQ1FFcWxrc3JuOHdRWEFRRHdEbHpYdGQrak1qQXdvR3lBa2MzUk1XTWRHMnFVUEsrMUZpdy8wKzUyVzZRa2x2V3hpbmVVeTJVNzNueTFXcTNPZi83em41OFJBQUFBQUFBQUFBQUFBQUN3SkFRWUFRQUFBQUFBQUFBQUFBRGFxbHF0N25KZDkvMmk1VU5hOUhZbHlqV3prNXY5MFQ2bFVxbVZTcVgwai8vRWp3ZU80NmhDb1JBSUFBQjRSOWxzMWhiMW9ROS95Sy9WYW5MbXpCazVlUENnUHZqOFFkMW9OSlFOMGhFc3E0c0RTenZHdkZHVTNHakdteittWTkxUWp2cEVPcDArYU9iL3RRQUFBQUFBQUFBQUFBQUFnQ1Vod0FnQUFBQUFBQUFBQUFBQXNLeks1Ykw5VzNWWEZFVjlydXZ1TUkrM1N5dzd0TkpGSFdzbDlqOHNPM3RmdnkxOWZYMUo4RUpmZjU5akE0eUNJQkRDcEFBQVdCclA4eVNYeThtNjRYWEpFR2R5Y2xKWHExVVpIeDlYeldaVDBEYkp0Wk54SE4vbk9NNndHWi9tek9SQ3BWTDVsdGxla1ptdUNRQUFBQUFBQUFBQUFBQUF1Q3dFR0FFQUFBQUFBQUFBQUFBQWxsVlhWNWM3T1RtNXhYWGQ3VHJXRDVsWnFhUm9JU2lualV6YjI3QWl2V1hyRnJWaHd3YlYzOS92cGxJcEFRQUFTMmNEakxxN3UyMVJ0OXg2aXpwNjVHaDA5dXpaK0xISEhuT2lLRkp4SERQNGFZL0FGaVhxNzV2eHFBMlgrcnFaUGgrRzRiK3MxK3NWODVnQUl3QUFBQUFBQUFBQUFBQUFMaE1CUmdBQUFBQUFBQUFBQUFDQWErNlhmL21YaStsMDJnMjk4R2NueHllN1loWGZxWlRLbXFjeXByaUN0bENPMHZsY1hxOWJ0MDUzZEhTb2djRUIxZGZiSjVsc0pnbGNBQUFBVjFkUGI0OVRLQlFrbDh0SnM5V1V2M255YnhyMWV0MlptWm5oaTdlTnRPaXRwbHJuS3ZmWFhOODkrZUMrQjU5dk5WclBmdVp6bjNsR0FBQUFBQUFBQUFBQUFBREEyK0tpQndBQUFBQUFBQUFBQUFEQU5aZkpaRUtsVkNwVzhYMk9PTU5LMUYyaUJXMW10b1A0dmkrRGc0TzZyNjlQTm0zZTVBZ0FBTGhtYkdDZ2RKaTYyQ0ZhYTNucHhaZWloWVVGVFlCUjIvVW5QNVZzTU9PakkxcDB3ZlhjQ1RPSEFDTUFBQUFBQUFBQUFBQUFBTjRCRnowQUFBQUFBQUFBQUFBQUFLNlo4cWZLOThRcTNpMUs3aldUM2FMbEpxMDBmNnR1czk3ZTNvYnYrL3IrOTl3Zm1GcDFkbmE2cVZSS0FBREE4ckFCZ3RZSGZ2QURRYlZhVldPbngrVDgrZlA2ME9GRGNiMWVkNkpXcEFSdG9VVVBhSzEveUhHY1cvZnYzZjhManVmOG4xRVVuVFRUVDViTDVRVUJBQUFBQUFBQUFBQUFBQURmaFl0Q0FRQUFBQUFBQUFBQUFBRFhqcEp1eDNHMmF0RzNhYTBIbENGb3Uwd21FOXNBbzNYcjFpbXpmU1FJQWdFQUFNdkhmdjlhdmIyOWJxMVdFek5Pa2xxOUpxN3JhaVVNbDlybDRsZzFielpCM294Zk8wMjlNWXFpdnpIekdnSUFBQUFBQUFBQUFBQUFBTjRVQVVZQUFBQUFBQUFBQUFBQWdLdm00eC8vZURhWHk3MG5qdU5ibEtpL3A1VXU2amk1K1p1RW5EYnlBejhPdzFEdjNMblRHUndZVk92V3J3dGQxeFV6VHdBQVFIdWxVaWtaSGg2V3ZyNCsyYlZybDN2aXhJbG9hbkpLSC9qV0FXOW1ka2FaY1pWZytXbXRRNlZVSUZyK2xabGMwSkgreC92MzdqL1ppbHNQbUcxU2UraWhoeVlFQUFBQUFBQUFBQUFBQUFBUVlBUUFBQUFBQUFBQUFBQUF1REwzMzMrL2Q3SHViYlZhMlNpS1JwVlNHOHlzVWFWVktFb3VwT1Fvd1hJeTdlMjVudlo5WHpLWmpFNmxVMUlzRnFYWVdaUnNOcXM4ajBzR0FBQllLZXozc2lrcW5VNG4zOWRhYXlsMWwwUWNrY3BjUmR2ZmFUYWJqS2FXa1JuUHFvdFYxdFMyaklvV3ozR2NVVi83OCtWeTJhMVVLdk1QUC96d3ZBQUFBQUFBQUFBQUFBQUFjQjNqYWtRQUFBQUFBQUFBQUFBQXdCVzU1NTU3U2txcGxJNzFIN3FPRzVoWjJ5NDlwMFVMMmtDSm1HMGhuWjJkK3U1MzM5MGFIQngwQndZR1hBRUFBQ3ZlOFBDd1o0cHMzYnBWNGppV0wvL3BsMnVOUmtNZFBudzRKV2luVFdhTXRVbHA5V2pzeHVkVnBMNlp5V1Irejh6L2ZRRUFBQUFBQUFBQUFBQUE0RHBHZ0JFQUFBQUFBQUFBQUFBQVlFbktIeS8zU2s1Nlc2M1dxT2Q1R1Izcm5Ka2RDTm9xbTgzR3R1N3A3WEVLaFlMazgza1ZocUdzZHZWV0xJMVdTMnJOU0tyTmxsVHFMV2xGOW5Fa1p0OUxubjhubnF2RWRSekpCSzZrZlU5QzN4WGZUSHV1SThWTUtMNnBBUUJZS1J6bnd2ZFNkMCszMDZnMzFPRGdvRFNiVFQwMU5aVUVHNW1pQkcyaGxQSk4xZTFvNTZhOWUvZmU2N3J1bEY3UTA2WGgwdmhIUC9yUnVnQUFBQUFBQUFBQUFBQUFjQjBod0FnQUFBQUFBQUFBQUFBQXNDUnhKdjVwRmFuM09zclpIVWR4dHpJRWJiZHAwNlo2SnBOUmUrN2ZrM0tNSUFqV1JDclBaS1VxWXpNTGNtaHNNcW0vZVhSTWFzMld2RG8rbXdRYW5USHozbzVqZHMrT2RDRDVsQytiKzRxeW9ic2dOL1IwU0hjdW5jejc4UFlSQW93QUFDdUs1MTI0dk8vZWUrOE5veWlTbTdmZkxNZGVPNmFmZXVxcFZyVmFkUmNXRmx6QnNyczQ1aTJhOGdPeGl1OVNvbjVGWXZtaWhISmdZbUxpUDVuNUJCZ0JBQUFBQUFBQUFBQUFBSzRyQkJnQkFBQUFBQUFBQUFBQUFDN0wvdjM3QzlLU2JkclZHOHprRFk0NDc5WktieFF0R1VIYkJFRVFlNTZuUjBkSEhSdGN0R256SmpQcEtSdDZzSm96cFJxdFNBNmVtcFNaYWoycHh5dFZHWityeW5sVHo5V2FjbUp5VGxxUmxxbUZ1cW5qZDN3L3JYVVNkQlNiMm9ZZTJkZTlkbjVXTW9FdmdlZklNVE12OUYzWk5kSWp1WlF2Vy9xSzRwcjJDenl5SVFBQTdXZS8wM081bkF5dkcxYU80N2lUazVOaVNuVDY5R2xWclZaVkhNZktmdGRoZVNsUnJwYWszWGVhMHFNakhaYjNscXZWUnZWM29paHFQZnp3dy9NQ0FBQUFBQUFBQUFBQUFNQWFSNEFSQUFBQUFBQUFBQUFBQU9EeVZLVWdvZHl0dEhxZlZ2cDlXclJ2NW5xck9TUm5MYkFCUm1FWXhqZHR1OG5wNmVtUi92NStYOWFBZWl1V0F5ZkdrNkNpMy91YkkwbmcwTFFwUzJXakJXck5LQ2t6MVlhOGR2NjduMy95dGJQaU80Nzh3bjAzeTBCSFJ0WjM1U1Z3SFFLTUFBQXJnbU8rbzJ5QWtTbHFlSGpZSFJzYnMrRkYwVnhsem0yMVdsS3YxeG1RdFllalJEbG1YSHlMS0xuRmpJdHZNdk5hbnVmOWtldTZOZk9ZQUNNQUFBQUFBQUFBQUFBQXdKcEhnQkVBQUFBQUFBQUFBQUFBNEMzOTYzLzlyenRkMXkyNHl2MFhvaVJ2eWk2dDlhQlN5dGV4ZGdrdlduNjJ6VDNQaTR1ZFJSa2FISXI3Ky90VnNWajBlbnA3SkpQSnlHcDJlbnBCR3ExSWZ2ZnhGMldpVXBNRHI0OUx2Um5KZUtVcURWTmZTNU5tZVk2ajVJdFBINVZjeXBkdkhUc25Xd2U2NUw3TkEwbWdVV2MySlFBQXJCVG11OThKZ2tCbE0xbTFVRjJRbDE5NnVXbURqSTRlUGJvbWdneFhLek5PN2piajVjaU1uWDlOTzNxdXZMZDhSRng1dGx3dWYwVUFBQUFBQUFBQUFBQUFBRmlqQ0RBQ0FBQUFBQUFBQUFBQUFMd2wxM1V6bnVmMUthMSt3a3ltdE9paEpMUklYd2pTUVJ1b1pMdElMcGZUNjlhdmkwZEhSNzFTcWVUSUdsQ3BONlJTYThxZnZYQkN4cWJuNWZXcGlpeVhoVVlycVErY0dKZVU3OHJya3hXWldLakw1dDRPNmN5RUFnREFTcEpPcDVVdCtYeGU0amlXMmRsWlhhL1g5ZEdqUndYdFk4YkgyUXNQNUtlVXFHbFRQeWNYTWhnSk1BSUFBQUFBQUFBQUFBQUFyRmtFR0FFQUFBQUFBQUFBQUFBQXZrKzVYUDQzRXN1bVdNZTdkS3hUb21SQTBIYnYydld1Umxkbmw3cnhwaHU5TUFoVktwMXliSmpSYW5mdzFJUzhjSHBTL3N0akw4ckp5WXE4ZW41RzRsaEx1OVNha2J3K09TZm5LMVg1MnVHVDhqTjNicFk3Um52bC9UZXRrMUl1SlFBQXJCUys3eWYxWFhmZGxUeTQ2YWFiNU55NWMvSGpqejBlTnhvTk5UYzN0L29IQ3F0WFVZdSt5NHlqYjlxL2IvL1BLMUdQaXBhL3JyZnFmL3pRUXcrTkN3QUFBQUFBQUFBQUFBQUFhd1FCUmdBQUFBQUFBQUFBQUFDQTd4ZEx6dnpzTjJYWUZKdllvZ1J0bDBxbGRKZ0tKWi9QS3h0Y2RDbTBZTFZydEdLWnF6VmxzbEtUczdNTDBvcTB4THA5QVVaV0s5YkpaN0psYXI2ZTFJMVdKQUFBckNSS1hSaWlwZFBwNUVHaFVKQmFyU1ptbk5EZUw5THJuTHEwWWN6d1RXc2Rtc2t1VTc5c3BndEJGSVFDQUFBQUFBQUFBQUFBQU1BYVFvQVJBQUFBQUFBQUFBQUFBRURLbnlodjA1NytRZlB3QTZMa0IyTWR1K29DUWZzVThvVldLcDNTUC9walArcGxzMWxWTEJiWDFBM3Z4eVptNWVsajQvTEZieDJWUC9qV0s3SlMvZTdqTHlabDc0L2NJZHNHdXVTbmJ0c29BQUNzUkdhc1lJdXpaY3NXWjNwNk9qcDE4bFQ5bVdlZWNVK2VQT25VRzNXbFk4M2dicGxkSEZCN1pvejlRNmIrSVVuSjN2Mzc5amUwNkgvdU9NN3I1WEw1YVFFQUFBQUFBQUFBQUFBQVlCVWp3QWdBQUFBQUFBQUFBQUFBcmxQLzZsLzlxdzViWjdQWmJicWxOMm10TjRxU0xsTnpZM3ViWEFxTVNxZlQybXdYYlVNSWNybWNNdFBLODliV24vaHJ6VWhtRmhyeTh0bHBtYWpVWkRWNGZiSWludU1rbjkxSythNEFBTEJTdWE1cngzbXFwNmRIT2ViN2EycHFTdGZyZFQwN08rc0kydW5Tb0c1TEhNZmQ1WEs1WlI0dlRFeE1IQytWU3RIRmFRQUFBQUFBQUFBQUFBQUFWZzBDakFBQUFBQUFBQUFBQUFEZ09wVk9wM2ZFY2R3VHRhTC9qOVk2clpSS0FvMHVoZWlnRFV6VGgwRVliOXEwS2RxNmRXczhORHprRll2Rk5aZVMwNHBpR1p1WmwwZVBuSkwvOVMrZWxXcHpkZHluLzhXbmo0cnZPdkwzNzl5Y0JCbXQ2OG9KQUFBclZUNmZkMjBaM1RDYVRELzk5Tk9OaVlrSi9jUVRUd1IyV3NlRVZyWkpJZm1wNVNIenN5YXgvSTBaQXg0dUZBcWZxMWFyMDJiZWpBQUFBQUFBQUFBQUFBQUFzSW9RWUFRQUFBQUFBQUFBQUFBQTE0a3ZmT0VMNFlrVEo3eGNtTHROZk1tWVdUK2dsTXJxV0tmTjQwRFFOcTdyNnE2dXJqaVR5YWplM2w3cDYrOXppc1dpK0w2L0pvTUZGcG90ZWZ5Vk0zSjRiRnJxclVpaVdNdHEwSXhpaWJXV2J4MC9KL25RSjhBSUFMQ3E5UFQwdUtsVUt0NjJiWnMwR2cwNWRmSlVIRVdSMU90MVI5QXVuaGJkSjlvTUI1WDdFMEVZSEN1WHk4ZkRNSHp0RTUvNHhKUUFBQUFBQUFBQUFBQUFBTEFLRUdBRUFBQUFBQUFBQUFBQUFOZUpzYkd4WEJpR3VkaU4vd2NuZG02TWRYeWZuYThNUWRzb1IybmY5L1dtelp0YXBWSkozWDc3N1pmQ3BGeFpvNnFObHZ6dTR5L0s2ZWtGV1RDUFZ3c2J0bVQ5d2JkZWtaNThXajY0ZlVRQUFGZ3RSa1pHN05qQ0hSNGVsb1dGQmYxblgvbXpWcVZTY1Fnd2FvK0xZM0RmbEJ1MVljYUVkOGNTUHlaYUhqUGI1TCtaK1FRWUFRQUFBQUFBQUFBQUFBQldCUUtNQUFBQUFBQUFBQUFBQUdDTis4eG5Qck9oWHEvZjVybmViVkVVM2VDSWM1TVczU05vcTJLeEdMbXVxMis1NVJZM2s4Mm9vYUVoejVDMTd0RHBTVGs3dTVEVTFXWWtTN1c1dDBNODE1VTlXd2NsRi9xeXZpdHZwcFdFN3ZmblBpMDBXOUpzeGZMeXVXbVpxTlRrNEtsSk9UKzNJT1BtOFZJOGRleXM5T1l6eVRvVU02RU1Gck1DQU1CcWtjbGtKQWdDdWZlK2U3MzV5cnlNajQvTHFkT245TW5YVCtwVzFGSTYxb1JiTGpNYlpxUzFka1hKVm9tbFU3bHE0LzY5KzhkamlYL2JiS3ZLM3IxN2p3Z0FBQUFBQUFBQUFBQUFBQ3NVQVVZQUFBQUFBQUFBQUFBQXNNWkZVZFRwdXU1dFd1c1BPWTZ6UGRheHF5NFF0RThZaG5FcWxkS2JObTl5YzdtY0toUUtybHdIeG1ZV2tnQWpXMStKM2tKYVVyNG5lN1lNSlNGQ3Q0MzBTT0E2a2czOTcvdmRtV3BENWhzdGVlem9tSXhOejh2a2ZFMXF6ZGFTQTR5T1QxVE02K00zMW9FQUl3REFhbUxEaTB4Um16WnRVcFZLUlRxS0hWS3IxMlRzOUppMG9wYWdQUzRPenZ0RVNaK085VVpUTjF6SC9hb1p5NTh6OHdrd0FnQUFBQUFBQUFBQUFBQ3NXQVFZQVFBQUFBQUFBQUFBQU1BYTlPbFBmM3BIbzlIWTRDcjNGK0k0N2xHaUJzenNIcTMxZFJHU3N4SXBSMm5mOC9XR0d6YW9EYU1iMU1EZ2dCdUdvWFIzZDE5WFlWSmZldTQxbVZxb3kxTHQzdFF2TncxMHljL2V0VVVLNlVBR09yTGlPWTdrUWwvY3QyakhUT0JKNkRteVo4dWdORnF4N05rNktGOTc4WlE4WXNvTHB5ZmsyTVNjTEZZeml1VHJMNTJTbmV0S3NtMndTd0FBV0kxU3FaVDA5L2RMSVYrUW5UdDNxbGVPdmhMYlVLUERodytyYXEycWRLeEp2R3dETTJZUHpmZ3dNT1A0Qit4MGVWLzVHNkxsUkNOcS9COVJGTlUrLy9uUHp3Z0FBQUFBQUFBQUFBQUFBQ3NFQVVZQUFBQUFBQUFBQUFBQXNBYkZjZHpoZWQ2Z2p2VVBLRkdCbVpXeDg2K25vSnlWeG13SGNSeEg4dm04OUEvMFMxOWZuMk5EQTY0M1l6TUxNdDlveVZMWndLSWJlanBreDNDM2RLU0R5M3FON3pwSlNma1hMcE1ZNnN6S2ljbUt2SFJtU282Y25aYWxhRVN4akZlcVY3UXVBQUMwbXhrdkpzV01TVlJYcVV0bXBtY2tDQUt0a25oRkpkcjhoK1ZuV2o4SkhUWGI0RjBYWjgyS0k2R0tWY3FNSnhsOEFBQUFBQUFBQUFBQUFBQldGQUtNQUFBQUFBQUFBQUFBQUdBTitNUW5QbEZ5SENmbnV1Ni9jOFRwMXJIZUkyZzdzMDEwT3AzVzk5eHpUOXpYMTZjMmJkN2t5blZxYkdaZWFzMUl2dml0VjJRcDd0bllMN3MzRGNoUDNiWlJkbzMweXBYNjRaMmpTZmtQanp3djMzajV0UHpwd2VPeVVMLzhQQUQ3dTM5ZzFpV09SZjdPTFJzazVidVM5cmtNQXdDd3V1M1l1U01acTl4K3grMHlQeit2di95blg2NHVMQ3c0cDA2ZENnVnRvMFh2c2VONzEzRi8wWE85SStWOTVVY2pIZjNuejN6bU05OFVBQUFBQUFBQUFBQUFBQURhakN2bkFBQUFBQUFBQUFBQUFHQVZLNWZMbVNBSTB0VnF0ZDlNRmgzdGhLSWtKV2dyei9PMHJRdUZncVJTS1FuRFVKbDVjajFiYURTbDJvaGtzWlJTWnBjV1NmbWVGTktCQlA3VnpZQ3k3MXZNTEMyVElkWmFtbkVrdFdaTFBGY0pBQUJyUmZMOWEwbzJtMVdPNDBndWw1Tm1zeW1OWmtPTEZxVzFGaXd2dXowdXRudGdTczVUWHJjNUYxaGZxVlFtN015SEgzNTRYZ0FBQUFBQUFBQUFBQUFBYUFNQ2pBQUFBQUFBQUFBQUFBQmdOV3ZKK3h0eDQrODR5cmxYYTcxWkswMkt5Z3JRMTlmWHlHUXk4VS8rMUUrbWxSR0dTd3ZJV1V1ZWVtMWNYcCtxeUdMWlhLQjhLcERkbXdia0YvZHNsMHh3ZFM5MStPR2RvM0wvMWlINThzSGpzbEJ2WGZicmJIalJUTFVoeHlmbTVKdEh6OGkyZ1U3Wk50Z2xBQUNzQlVFUTJLSis3TWQvTEZXcjFlVE1tVE55Nk5DaCtQRGh3M0Yxb2VxMldpM0duRzFneDVXbUd0V2liZmtSaWNXT09YL2R6SHZabE44WEFBQUFBQUFBQUFBQUFBRGFnQUFqQUFBQUFBQUFBQUFBQUZoRi91Ti8vSS8rMk5qWVVCUkZKZGQxdCtwSTM2WkViVEpQNVFSdDR6aU9LRWZwM3A1ZWxjMW1aWEJvME0ya004cHNJN2x3bnpuRzV4Yms5UFM4TEZZdUZjam0zcUwwNXRNU3VJNjRWN2s5VTc0cll0NnlLNU9TV2lPU2lmbmFvbDdmYUpuWFZLcXkwTWdMQUFCcmtlZDVrc3ZsWk4yNmRXTEdObXB5WWpLZW41OVhaOCtkVmMxbVU0a1d0RWR5L2FjNUY3aERpeDU0NElFSHFtWk1Pcit3c1BDRTJWNVJ1VnhlM0tBR0FBQUFBQUFBQUFBQUFJQWxJc0FJQUFBQUFBQUFBQUFBQUZhUkkwZU9CSmxNNWk2bDFSWWQ2NCtKa3BRV25iTFBFWlRUUHA3dnhXRVl4amZlZEtNN01qS2krdnY3dlZRcUpmaGJyMDlWNVBEWXBDeFdQdVhMbnEyRHNybXZRN0toTDFkYlBoV0lqUjVhWDhxTDd6bUxEakNxMUpweWZHSk9OdlYyQ0FBQWE1RU5NT3J1N3JiRjJiRmpoeHc3ZHF3MU1URVJmZTFyWC9QaktKWW9pZ1J0RVZ3c1A2TE1TWUhydU84V0xlZk1tUFNmMU92MWlwbFBnQkVBQUFBQUFBQUFBQUFBWUZrUVlBUUFBQUFBQUFBQUFBQUFLOXpIUC83eHJPdTZYaGlHUDJNbVUwcXJIOUJLbCt4ajRlKytiYU1jSmVsVVdnOFBEOGVkblozU1VleHdob2FHcEtPakk3blJIOS9OQmdPTnpjekxZZ1d1S3dNZFdjbWxBcm1XMW5YbEpPVzdjdUQ0K0tKZVYyMjJrdldhcXpVRkFJRHJRYkZZZE15NFZOMTkxOTNTYURiazVaZGViallhRFRVMU5jVUFxTDM2dGVpOE9XLzRueDNIT2I5djM3NVhuSmJ6UXZtejVZTUNBQUFBQUFBQUFBQUFBTUExeEFVREFBQUFBQUFBQUFBQUFMRENCVUdRVTBxbGxLaC9haWRGeVRieldOQkdwdmtkNVVnMm05VmJiOXdhRFE0T3VnTURBNDdnTFUzTTFXUnNla0VXSy9RY0dTaG1KUi82Y2kydDY4d3RhUmtMRFJ0Z3RDQ1ZPZ0ZHQUlEcmd3MHdNa1c2dXJwRWF5MnpNN090dWJrNWh3Q2p0dXMzNXd4Mm0veXlPVmM0b2JSNkp2YmkzelB6Q1RBQ0FBQUFBQUFBQUFBQUFGeFRYREFBQUFBQUFBQUFBQUFBQUN0VXVWeitZUjNwdTh6RFhWcDBwNmszYWExZGUyTXkybWZkdW5XTlhEYW4zM1hidTBKRGxVb2xMd2dDTnNwYk9EZTdJTk1MRFptWXI4bGNyU0dMbFV2NXNtdWtSem96Z1Z4THVkQ1hWcXhsc2FZVzZ2S3Q0K1B5M2h1SEJRQ0E2NG52WHdqK3UyL1BmVUd0VmxQYnoyeVg4Zkh4K05DaFE1R1pkdXIxdWl0b0MzTyswR09xSHpEMURmdjI3ZnUvU3l4ZmNzUVowNjcrOHdjZmZIQldBQUFBQUFBQUFBQUFBQUM0aWdnd0FnQUFBQUFBQUFBQUFJQVZLbzdqRFVyVWRpMzZEalBaTGNtOXlPVGt0RnN1bDR1THhhS3NYNzllSE1kUmhCZTl2V3FqSlpWNlV4cXRlRWtCUVo3alNHY21sSlIvYlRNUVhOY1IzNVRGcWpXak53b0FBTmNUTXc1SzZsS3A1RFlhRGZOZDZvcXRQYy9UOWpIYTQrSUpROFlXclhXSHFUYzdydk9TampVYkJRQUFBQUFBQUFBQUFBQndUUkJnQkFBQUFBQUFBQUFBQUFBcnhQNWYyVCtzUXZXRHNZNjNpU01mVVVvVnpleUNJNDV2NWduYUk1MUtSNmwwS3Q2OWU3ZlgwZEdoK2dmNlEzdFRmaGlHZ25jMlVhbkppYW1LTktLbEJmeDRyaU1kNlVDdWRVclU1dDZpMUpvdEFRQUFpeGNFZ2ZUMDlFaG5aNmU2ZWZ2Ti90a3paK094c2JIbXQ3LzliV2R1Yms0MUdnMUg2OFVIR2VJSzZlUWFVVStML3NkbU1GVXowMyszdksvY2JFYk5uNDNqdVBiUVF3OU5DQUFBQUFBQUFBQUFBQUFBVjRnQUl3QUFBQUFBQUFBQUFBQm9vL3Z2dnovNXUrMmVPL2YweDJIYzU0Z3pvcFFhRVNXak90YStlZXhxMFdKcXdmS3g3ZTE1bmpaRmNybGNVaktaakJRN2k3WldOc0FJbDZjWmE2bTJJb21XRUZxUThqM3hYZE1ybG1IL0R6MVhyaVJZb1JYSFNRQ1MvY3dBQUZ5UDdQaklGR1ZESG11MW1sUnJWU2wxbDhSeEhKbWRuZFgyZTdaZXJ6T29YVWJxYjA4aU1yWW9VU1BtM0tKbHRzbW9LUXZsY3RrMzh5dW1yZ2dBQUFBQUFBQUFBQUFBQUV2RVZYTUFBQUFBQUFBQUFBQUEwRWE3ZCsvdU01V25YUFZWVjl5VUZqMlVQS0dGMEtJMnNlMGVobUU4TURpZ3QyL2ZIZzBPRHJvREF3TytZRWttNW10eWNySWl0VWEwcU5lbGZGZDJiK3FYbmNNbFdRMWVOK3Y0emFOblpOZjZIdW5NaGdJQXdQV3NwNmZIdFdYcjFxMFN4N0U4OGNRVGpabVpHWG5td0RPQm9HMHVuV3NvVVkrYWFscGllYzdNL0lwNS9Ea0JBQUFBQUFBQUFBQUFBR0NKQ0RBQ0FBQUFBQUFBQUFBQWdEWW9sOHY5cHJKbDFKUkFZckhoUmFTZXRGbWhVSWlWVXJxbnQwZjE5dlpLUHA5WFljaG1BUUFBV0FySGNaSzZXQ3lLNTNscWVIaFlHbzJHVEU1TzZqaU9sUTAzUXR0NDV2eWp3OVJEZS9mdTNXUHFTYWZ1VEpXR1MrTWYvZWhINndJQUFBQUFBQUFBQUFBQXdHVWl3QWdBQUFBQUFBQUFBQUFBMmlHU2Z5UktQaFRyK0U0emxWS0dvTzF1M241ek13eERkZmZkZHdldTY0cnYrNjRBQUFCZ1NUenZ3aVdLdDk1NmEyRERpclp2M3k3bnpwMkwvL0l2L2pLYW41OTNUR0dzMVFZWHp6M3lwdHlxUmQvaUtPZWY2bGovdm9UeTlNVEppUythK1NjRkFBQUFBQUFBQUFBQUFJRExSSUFSQUFBQUFBQUFBQUFBQUN3REpjbzFKUk5MZk1mZXZYdGplNk93bWQwbi9OMjJyVHpQMDdZTUR3ODdRUkRJME5DUTQ3cXVzdUZGanVNSXJ0ejBRazFPVDg5TEs0NEZpemMrVjVWbXBPVjhaVUhxelpaTVY1dFN0ZlY4L1cxZlovZGZ6MUVTZUs3a1U3NTBaa0lKZlZlR2lqbnhYVWV5b1NmT05jNU5PemRibGJOekM3SVVwV3phZkU0bFBmbjAyLzVlTTRybDFIUkZhbzJXVEMwMFROdEVzdEJvU0tYV2trWXJldFBYaEw0blhkbFFlbkxwcEIxR1N2bWtuUmFqYnQ1N29kNHkyNldhTEhQSzdPZVZha1BxNXZQWStiSFdiL3E2RHJNZGlwbEFScm9LeVRKN0MrbGtPMTJwSTJlbnBmWVc2L3QyUXMrVFhPaExPbkNUZmVUdExOU2JjczZzNzF5dGFkcTNLWE5tdXRFeSsrSkNVK0szNk45RjA4NXAwOTZESFZtenZvNXM3aXZLWXNUbTI3SVp4MiswOVpUWjc2dkpNaHNTbWZuMmM3eVZ3YzVzc3EvYnRyYmIrWjMycFd2aDlQU0MxR3gvTmZ0SHZXVStyMmt6dTYvVUdtKy9yVnp6dVYzVFA0dG1tN2htLytqT1g5aFBSa3VGcEYray9HczNkRGd4V1pHWmFuM1JyN09mczVoT1hkYStsTFJGclM3enB0K2VOOGU0Qy90U25CenZXdEYzNzB1WGptWEZkSkQwbjgxOUhjbCt1eHpITUZ4OU5qUEhqcmVLeGFKejQwMDN4dFBUMHpJelBST2RQMy9lcVZhclNwdGpwMzZMNHlldUxkUHVTamxxbzJoejJwS1dWcmxjUG1kbVAxS3YxNk9ISG5wb1FnQUFBQUFBQUFBQUFBQUFlQnRjQ0FzQUFBQUFBQUFBQUFBQXkwQnI3WW1TTGxQK25pUE9QekhUTnRESUVyUlBKcDJKVXVtVXZ1UE9PMVJmWDU4cUZvdSs0S29hbTFtUXcyT1RTZWdKRnMrR2lVd3YxT1diUjhka3RscVhnNmNuWmNwTUh6ZysvcmF2czRFZitWUWdwVndxQ2VpNWFhQkxCb3RaMmJObE1BbHlTUWQ1Y2E3eDRlZkl1V2w1N0pVenNoUzcxdmRJeW5mZk1YVEdoaFE5Zld4Y3B1WnJjdURFdU5uZjVwTjk3dmo1V1psNGk1Q25nWTZNYkJ2c2t0dEhlNU5BbUkvc0dKRUIwemFMc2RCb3lYaWxLdDk0K1hRUzBHWDM4V1BuNTh3eWE4bG5xRFhmUEtCbTIyQ25iRFBiNGlNN1JwTmxkbVg3emJhNjhzdDN2bVgyaDllbktySllOcnhvUzE4eGFaTjNDcDJ4WVRPMnJWOGRuNUhYVFBzZW43alF4Z2RQVFNUaE0yL21wb0hPaS92ZFVMSXRGeHRnRklsTzJ2clk1Sng4NjlnNU9YUjZJdG0rTDUyWlRzS0E3T2Q0SzN1MkRpWWhWVDk5eHhhejdGUmJBb3pzZm5GcDM3VDd4dkdKT2JNT2s4azZ2QjI3Nzl2Z0p4dldZL3Z4N2swRFNXalJUOTIyTVhsdW9PUGFYZkpsdCtjTDVqTXVsZzJvMmo1WVNrS1hiaHZwZWR2ZnRjRlh4eWNxY3N6c1EwK2I3WHBwWDdMN3NUM2VmZGY3Sm9GcmZySXYyWDc3TTNkdWx2VmQrV1U1aHVIcXMrUGVUQ2FUbFBlKzk3M2UrUGg0Njl6WmM5RXp6enpqbmp4NTBxblg2NlJIdHNIRkV4S2I1SGUzT1ZlNTJ4eDZQMlRPVlJyS1VYODNETU9hbVUrQUVRQUFBQUFBQUFBQUFBRGdiUkZnQkFBQUFBQUFBQUFBQUFETFFVbW9SZHM3K2dNYlhpUm9DM3QvdHVkNWNhbFUwc1BEdzNGdlg2L3E2T2h3ZTN0N2s1dnBnWFlibjZ2S3NmT3pjdWpNbEJ3Nk5TV3ZuWjlKZ2xyT21mbU5aaVRUMWJxMG92Z2QzeWVLdGN5YjF6WGpPS2x0eUk0TlJQbkd5NmRNN2N2N2JocVdZaWFROTVvNmNGM3BTQWR5dGRud2xpOCtmVlNXb3BSTkphRWxiOFlHd05oMStwUG5qOHZNUWtPZVAzVmVXbVk5eDJkcnN0QnNTYlhSU3Ryc3JkZ0FLUHNldHEwelpobm5LOVVrVE9qdjNyWkpNc0hiWDByenhDdG5wTjZLNVErZmVVVXFqYWE4ZUdaYWFvM0l2R2RWNW1vdGFVVFIyMjZmMDFNTHlXYy9PVFV2K1pSdlB1c082YzZsNU82Ti9YSWx2bnI0ZFhudTVPTHpKWWE3Y2hKNmJoSSs4MmErL2ZwNW1hMDI1RStlT3k3empZYlpwbE5TcVRXVFFMSTVzeDQyUU1ydWEyL0ZCdlhZUUpwTGJlMmI1V1RNZnZoM2I5OGtiOGUrNytPdm5KV3pjd3Z5K05FeG1URHZZY09LcGhkcXlmYTkxTlp2NTlEcEtiTTlaNU5sbDNKcHMxMjBxVVBaUGxTU2E4WDJYYnM4dTIvYS9jTHVtMDJ6UDV5My9kZDhYdHR1VXd2MWQzeWZwdG5INHJncHI1eWJUYmFOZlUvUGNlU3AxODVKYno0bGQ5elFKK3ZOdHJQcmtqZnRhc09OcnBablRweVQvLzdzTVZrczIxL3pZWkNzNzV0NWZiS1M3Q3QvY09Cb3NrODhiL1pYRzRwbDIyYXUza2hDc0dxbS8zNnYxc1ZqMmRGek02WWRhdkxxK0t3NVhvWHlqM1p2bFd3UUpFRlZXTDN5dWJ6cis3NEtVNkZUclZibDBBdUhtb2E4Y3ZTVlpLYzJZMmRpcXRvalo4NVh6QUZlUG1FZTE4cDd5MCtaamZGaVBhby8ydFBUcy9DeGozMnNLZ0FBQUFBQUFBQUFBQUFBZkFjQ2pBQUFBQUFBQUFBQUFBQmdlZGgwaUlKOVlFTjAwQ2FtNlYzWGxWd3VwemRzMkJBUERROTV4V0xSRVdDRm1HODA1ZmhrSlFuSytlcmhrekkyTXkrMVpyVG85N0dSTW8wb1Rvb05uTEZCTXQ4cDhCMFpMbWJsemcxOWt2TGpheEpnZEhwNlFRNmNHSmVsbUppdkphRkViOGFHdVl4WGF2TGxnOGZsL0d4VlhwK3F5R0xZOXJUdGNhbE5TcGt3Q1RENjRaMmo3eGhnZEh4eUxnbWgrZEx6eDZYYWJNbVo3Mm5YZDJJRHFHdzVQbkhoTSsvWk9pUWpYZmtyRGpCNjlmenNrdHJhQnNuY2ZVTy9ETlRlUE1ETkJsK2ROT1gvZXVhVnBhMnZlZjlwa1RmYWV2dGdWeEpPOVU0QlJqWWs2c2k1YVRsaDJ0dTI5Vnl0SWVmTk5sOE11NTlZdHEzdE1qK3diWjFVNnBsckdtQms5MHZiZisyK09UMS9JWFJwS1NLdEpZcDAwZytzUysxbnQvRkFSeVo1dmxJcnlXaXBJQ25QTTMxWXJwcFh4K2VXdEM5MW1uNWtQKzliOWFFWnM5L2JrS0svT1BSNkV1SjA0UGpsTFNNMjY5b3diV0ZEM0d5eCs0VjEyMmhQc2wwSk1GcmRVdW1VTXNVMVk3RmtlbXBxU2xlclZmM0txNitZalM5b244Q2VyMml0UDJ3ZTE4empram1UeVRyYWVlYnMyYk0yYVl3QUl3QUFBQUFBQUFBQUFBREFkeUhBQ0FBQUFBQUFBQUFBQUFDd3BpbFJOc3RGdHQyOHJWa29GSnlidHQza3B0TnBONVBKT09sVW1qUXBKR3pvaHU4bzJUWFNJMHN4VXNwTFB2VEZjNWUyU3kwMFd2S2JYejhvcjV5YmtVZVBuRTZDWDJ6SWh3Mzh1QmErOGRJcFNmdWVQSHZpdkF4MVp1VW5kbTJVelgxRjJkSlhsSldtR2NWU2E3YVN3Sk52blJpWHJ4dzhuZ1RwMkhDWU9OWnlwUjUvOWF5RW5pUHYzdGd2Z3gxWmVmKzJkVzg4VjI5RlpodEVTU0ROMDhmT0phRlMxU1FBYWY2cUxQdDNIbnRSdW5NWFFsZ0N6MDBDV2RxcFp0YTFhY3FmUEhjOFdjYy8rTmJSSkFqSUJ1aGNqZlg5MG5QSGtuVzBiZDNma1pIYlJucmZlRzZoMFpUSUxPTS9tSDV3WW1KT3Z2YmlLYW1idGo0M3R5Q3Q2TXI2d1lMWmYzNzlMNTZWVzRhN2t6NmVNMzAxbjdwNm9WMlB2M0xHN0VkbjVKdEh4cEtBbmFVR0YxME9HeEprMi9FSnM3dy9mdlkxZWMrTnc3SjlxQ3NKb2lybDJydi92Qm5iYjQ2YTQ5cC9lZXl3VE0zWGs3Q3R0d29uVzR3dlBuMVVIS1hrdnMyRHlmRjd1Q3NuV1AxMjdOaVJYTTg0UER3czA5UFQ4dHkzbjJ2VzYzVmxIbk9kWS90NFd2UXRPdGFEcnVPK3h3LzlaL2Z0Mi9mdFdxMzJwVi85MVY4OUxRQUFBQUFBQUFBQUFBQUFDQUZHQUFBQUFBQUFBQUFBQUlDMXpybFFGVG9LdWxRcXhldlhyNy8wdDNMQ2kvQUczMVdpdFNPZG1WQ1dJaHQ0NHJtT0xGVzEwWklqWjZmbHlKbHBPVHcySmRlYURhU3g0UjgySkdtcVdwZDNieHlRZ1k2c3JFU3gxdEtLdFl4WHFra2J2V2pheDM3K3EyVnl2cGJVOWowRDEzM1RaZHNBbHVkT1RzakxaMmVTTUtXcnhhN1BRajFyM2pPU2xTQ0s0MlI5WDUrY1MwSjREcCtla3JsNlU2NFcyOFkybE12V3VURDRubVZmYU92blRUdWZNTXUzYlhPMVhPcGZ0bi9idGs3NVYvZVNLUnNxZEduZmZQbmMxZnZjYitaUyswMVVhbkpxYWw1dTZDa2t3VVUyYUdzbE9qZFhsZGVuS2tuNDJQUjhYYTRXdTMvYVkxamxLdTZmYUwvT3pzN2tpMVNaYlJ1R1laeEtwWFNyMVdLODFpYktiZ2d6UkRMRnBodDJtTWtOV25SazZya2dDSlkyWUFJQUFBQUFBQUFBQUFBQXJFa0VHQUVBQUFBQUFBQUFBQUFBMXFTdXJxNVdQcCtQUC9paEQvcVpURVlWaTBWdXRNWmIyajVVU3Vxdi9QTGZrZVgyei83ckl6SlhhOHJ2UDNWRWxwTU41MGtDakk2UHl6ODcvb2o4NUcwYjVhZHUyeVMzai9US2FIZGUyczBHMnRqUDl4ZUhYcGQvOStmUHlOajAvRlVOTHZwZXYvbjFnekxhbFplZnVYT3pOT05ZS21hYi9OY25Ya3JLOGZPek1uRVZ3MWUrMDB5dEliLzZsUU95dWE4b0gvdkFyZElPOVZhY3RMVnRaOXZlTDUrWnZtYkJNSmZXOXlmZXRWSDJiQjJVYXJPVmhBcjl5aGUvbVlSRUhUdzFrWVQwWEFzMm1Na3UreU03UitXSFRibFNMNStkbHQvNGkyZmxnT2xEQjA2TXkzSnFSTEUwekRiN3JVY1BpWml5OTBmdWtHMERYYVlQYjVSMmFzVVg5cVV2ZnV1by9NRzNYcEZEcHlldlNiK2RxVGFTK3JjZWZlRkMzK2x2VDkvQnRXSEdiTFk0bXpadENpcVZpcHcvZjE2ZWZQSkovZHFycitsNm82NTByQWsxV21ZWHc0enM5YWIzaVpiN1hNZjluL2J2Mjk5U2p2cDVNKzlFdVZ4K1dnQUFBQUFBQUFBQUFBQUExeTBDakFBQUFBQUFBQUFBQUFBQWE4S0YrNnBGZ2lBUTMvY2xuODlMTHBkVGp1T0lMY0JLTTFPOUVJaGp3NHRzV0U2N0xUUmFNakZmay9sR1ExcXhGczlwWHo1RWJKWnYvcGV6c3d0Sk85VmJVUktNY2kyMW9qaFpobDJXM1I3amxlcDNMRnZMdFZScnRwTGxMemU3Uk52V2xYcmpZbHMza3ZXOTFteEFWQ09La21YTm1tWGF3SnRHSzdybXk3YmJNV25ycTdBdjJYMWp6bngyMjMrWG84M2V5VVNsbHZUZlMvdHFPL3B2MCt6RHM2WTk3TDQwYmJicDFXcnJ0NU8wZnpOS0F0bnNHbDhhQzJEdHNHTTR6L01razg1SVIwZUh6TTNObWVOV3JHdTFHaHU3dlp5THBkOXNqMmE1WE83WFdpOTgvZXRmWDdqLy92dGpNNzM4WDJvQUFBQUFBQUFBQUFBQWdMWWh3QWdBQUFBQUFBQUFBQUFBc0RZb2tUQUk0KzA3dHF2dDI3ZXI3dTV1TDVmTENiQlNmZm41RS9MNlZFVisvNmtqc2hMODFZc241WWxYenNqZUg3NURNb0V2NjdyeWJRc3hzdUV3WjJibjVYY2ZQNXdFc3h5Zm1KTnI3Y3pNUWhLQThzS3BTWG41N0xUOHhsOCtLMlBUOHpKbTVsOUx0V1lrM3p4NlJwclJ0UTFKZWpOUkhDZHRmZmpNbFB5L3Z2YWNIRDgvS3hQemRibVdiRkRUeWNtS3ZIcCtKbW5yUDNudW1IenArV1B5OHBscHFkU3ZiWkRYWEsyUnRQV3U5YjF5Sld6UTAvLzJqVVB5NnZqTWl1bS92L3ZZaStLN2p2emd0bldtM3pxbS95N3Y5NThOcFhwOWNrNE9uWjZRMzNuczhMTDBIY3UyL3owYisrV2YzcjlkQXJQKzJkQVhyQzJaVENZcHc4UERTVWJWODg4OUg4M096dXF2ZnZXcnJuMCtqbU9Dak5valkzL29XUDk3SmFvbXNUeXBsRHE4ZS9mdXoxV3IxV256MUl3QUFBQUFBQUFBQUFBQUFLNGJCQmdCQUFBQUFBQUFBQUFBQUZZMXovT2t0N2RYcDFJcEtaVks5Z1ozc2NGRmRqNndFaldqV0dLdGs1Q2NvK01yNS83K0tOWlNiMFZ5ZkhKT25qODFJYjM1dEhodENnT3h5Mi9Gc1V4VXFqSlh1N2FoTnQrcDJtako0Nitja2JHWitXVFpDMmI2V290TnU5dGduZmxHTTJsLzExRkpBTTF5c0VFOHRxMm5GK3JKK3RybEw1ZUpTajFwNnlPbUg5aGwyLzN2V3JQaFNiYXQ3WGExNjJvRGZ4eTF1T3lUUmhSSnBYNmgzU1lyTlZrcExoMVg3T2ZLaGY2eUJ4ZzFUSHNlT1RNdGRkTSt5OVYzM2xoMmRPRllrVGZyVFlEUjJ0ZmQzYTNTNmJUczNMbFRHbzJHZnYzMTE2TldxK1ZVcTlYbE9YRGl6WGhhZEo5bzh4WG1PRDhaaHVHcDhxZktyd2ZaNEtWUGZ2S1RFd0lBQUFBQUFBQUFBQUFBV1BPNFdoTUFBQUFBQUFBQUFBQUFzR281anFQRE1OUTMzM3h6WENnVTFJNmRPMXdCVmpnYmdOSm94ZkkzcjUxTnlrcGhBMUJzZWViRXVNelhtN0o3MDBEYndrQytjdkNFdE1OQ3N5Vy8rOFNMU2NqTjhZbUtMQWNiT25PK1VrdkNjR3pvUytBNjRvWExrOE14VzIyMHJhMXRjSkZ0NjdIcGVSbWJXWkRsMElvdnRQVk10WjYwZFNid0pQUVc5N1ZSYlVReU5XL2E3Zm5qU1g5WktTNkZUMzNaZks1U05pWHZ2WEZZbHBNOXBuMzl5R2xwQnh1ZVpQdnJRRWRHK2pxeWdyVnRZSEFnT1VBT3J4dVdoWVVGK2ZLZmZyazVNelBqVnF2VlFOQXU5anJVRzdYNVBsT2lkcHZ5akxqeWpOa20vOW5NLzZZQUFBQUFBQUFBQUFBQUFOWThBb3dBQUFBQUFBQUFBQUFBQUt0T1BwOXYrYjZ2dDIvZjdobHEvZnIxVHBnS0JWZ05qay9NeWRqMGdrek0xNlRhYk1sS1l6OWZwZGFVOGJtcU9FcEpaK2I2NlZ0UnJKTkFuVXRoTU11cEVjWEpzb3VtdmRzVkhMV2NGcHJOWkgzbjZrMVpibmFaZHRtRHhleWlBNHdPbnBxVUU1TnpTZCtOemY2eTBodzRQaTU5aFl4TUxkUWxkQjNKWEFmN2t0ME9kbnMwVmxDZ0ZLNDlNLzZUVERvak8yL1o2YzNOempubnpwMlQ4K2ZQNjNQajUzU3oyVlE2MWtxd3JKUVpNOWdRSTFNR1JDVkJvODE5Ky9iOWdKbittbmw2NFRPZitjd0xBZ0FBQUFBQUFBQUFBQUJZa3dnd0FnQUFBQUFBQUFBQUFBQ3NPb1ZDSWNwa012RTl1Ky94N2MzU1lSaHlrenBXaldQbjUrU0YwNU15VWFsSnJibjhRVG52eEFZWTJYSitycGFFdTF4M0FVWXpDOUlPalZiMHhySnRzTTVhVjIxRXByU25yVzFBbDIxcnUyOFhGN2wvSHp3OWtmU1BsZGgzclFNbnhtWEk3RC9UQzNYSnBmenJJOEJJNjJSN05LT1Z1VTF3YmRnQUl4dGl1V1BIRHI5U3FkandJamwwNkpDZW1aMkpXNjJXcTJYbEJZeGRENVFkbUlzTUpFWExqVXBVd3hGbkxsYnhoSmxIZ0JFQUFBQUFBQUFBQUFBQXJGRUVHQUVBQUFBQUFBQUFBQUFBVmp6WGRYV1lDdU5ObXpZNWd3T0RhbUJ3d0UrbjB6b0lBcmx3bnpTd2VodzhOU0ZmZXU2WVRNelhaQ2w2ODJsNXo0MURzbjJvbEJRYk1oUzR6aHZQMjJDVzQ1Tno4cnVQSFphNWkwRXRTL0hVc2JOeTlGd29HN29Mc2hKczZlMlF6WDJkY3ZmR1BpbGxVekpheWt0ZzF0Mkt0SmFGUmt2KzR0RHI4cGVIVHNpNTJhcE1WeHR5dFd3ZjdKS1JVa0cyRFhaS3l2ZGt6NWJCTjU1cnhuRVNudktIejd3cWo3OHlKcTlQelV2VmZKYlY3TzRiYkJ1bmsvVzBBVDgzOVB6dFBsQ1A0aVJzNmRMNkhwdVlNOU94WEMxN05wdGxaa1BaT2R4dGxoM0lMYWErcE5heUlUV3gvT2JYRDhwcjR6UHk4dGtaV1c1ZmYrbVVIRGs3TFV0MTIvb2UyZFRYSWUrN2NaMzBGTktTLzQ2QW9hclpqMnp3ME5kZlBpWGZNR1dwKzVKdEkvczVSMDNmdlgvcmtMUkR5V3pEVWk0bHUwWjZaWE52VVc0M2RUYjg3a3ZWcHN5NnZuWitWdjcwK2VQeTlMRnp5YnJhdnJ4WWR2OGJtNW1YUWpvUVhKOVNxWlQwOS9mYmdFc2JhT1FlUDM0OFdwaGYwTi8rOXJlOWFyV3E0dmpxSGFOdytiVFdvUm1uQjFycGY2RkV5Zjc5KzkrdnRKcHZ0Qm9QUlZGVSsvem5QNy84QjNFQUFBQUFBQUFBQUFBQXdEVkJnQkVBQUFBQUFBQUFBQUFBWU9WVEYwS01TcVdTOUEvMFMxOWZuMk52VmdkV284bEtMUWtWc2lFd1N4SDZycXp2eWlmaFJiczNEVWdtOEpJUW8wdHNJRWcrNVVzdUZVajlDb0psenM5VnBSVXZQa3prV3JIck0xRE15UGJCa2d3V3MyYjl1OTRJTUxJaFFwVmFNMW4zSjE0TlpLS3l0SENvdDlLVlN5WEwzamJZZFNIQTZEdENZZXBtTzlyd3BDZGVQWk44UmxjdExUQnFKYkVCVVhaOWJmaE1LUmNtKzlvbDFXWXJDV3k2dEw1WFczOW5WbnBNZTl1MnR2VjN0dlY4bzVtRTFmelJzNi9LdU5rLzIyRnNldjZLOXEvZVFqcnB2N3RHZTVLNk14Tys4ZHhjclNIbnpYdS9QalVuQjA2TUwzbGZzZ0ZHNCtaOStnb1phUmZiTiszK3NiR25JOW1XZGp0K2I0RFI2ZWtGYzZ3SzVKdEh4OFIzSGFuWlBNSWxISEppclpOOU1vb0lxYmxlZVo2WEZETTJWRjFkWFZLdFZ2WGMzSnkyNDBlQ0x0dkh0UDJsd2NtMjVLZVdodGI2bkptZmNoeG5kU2Y5QVFBQUFBQUFBQUFBQUFDK0N3RkdBQUFBQUFBQUFBQUFBSUFWeVhFY0taVks4YzZkTzZQT3JrNjFmdjE2MS9kOXNjVStCNncyTm54bE1na25xY2pyazNPeTJHeWdUT2pKbmkyRGN0TkFwL3cvUHZndUNYMVBVcjRyM3h2TnNLNHJKLzBkR2RuWTJ5RmZPL3k2L05xZlA1c3MxNGJzTE1Zakw1OUtncEhzc3RyQnJ0dHRJejJ5YzdoYi91N3RtNlVubnpJbExZSHJTdUE1YjRRWFdiNDVKblNrQTltOXNWK3lnU2YvNlp1SFplTFZzN0pVK2RDWGtlNjgzTE54SUFtSnVubW9TNFk3YzVMeXZ2OVNtOEIxeERmTC91QzI5WEpEZDBGKzlTc0hwRExlbE5Xa0o1ZVdMZjBkOGxPM2JaSmIxdlVrKzFBU2dtWGE0WHVsVEx2Yi9lTFMrajd3aDA5ZVVaaFFyOW11dllXTS9JOTNiNVdCanF6Y3QzVkkwbWJidjFsYlo4dytuellmNmFkMmJaUjMzOUF2di9pL1B5TEw1ZXpzaGRDeGs2Yi9qczNNeTJMWjBLMWIxcFhrbjl4N2M3SlBYZXEvM3lscjJqdHQ5dDkvZU0rTjhpTzNiSkIvK1gvK3RSd2FtNUl6MC9PTENoT3p4NW92UDMvTXZDYVdEKzhZa2VWazk0bWZ2RzJqM0xtaFQrNHl4UWF1aFdaYmZtOTRrZFZiU0VsWHRsOG01MnR5b3ptdS9lK1B2eVNucHhmZnRzRDMycmh4b3hkRmtheGJ0MDVwcmVXUnYzcWtWcWxVbk5kZmYvM3FwNjVoTWJhWlFjczIxM0VmZFpWN2F2L2UvYzhwVi8xeHVWeitFd0VBQUFBQUFBQUFBQUFBckdvRUdBRUFBQUFBQUFBQUFBQUFWaFRmOTVPVWhsdytwN0xackJRN2k5TFIwU0dGUWtFSnNJbzFXckZVNmsycE5sdUxDaVA1VGtQRm5IUm4wOUtaVGIzbDczaU9rNFFhMlRBWUcvalRsUTZsYXBhNzJBQ2pxWVg2ZDRVRUxTY2IxbVJEYkVaS0JSbE5TazRLWmoxc1NORmJjWlNTZE9CTE1aT1NsTC8wUzJMc3NqdXpvYXpyeXB2bDU1UFBZTnV5OUJadHJzeHliWHZiNEJtNzdNQmZXcHZGV2tzemppVmE0cjZ4Rkw0TlgvSWM2VGI3aVYxUEc5cGsyOXBPcDkraURiOTNmYTk0MmJsMDB0YTkrVXp5R2JwTjI2ZmVZZG1aaTl0NXFlTDRZbHN2b3FubjZ5MnB0MXJKNjViU2Z3dHBQK20vUFlYTVcvWmZ1dy9iMG1IMmRSdmdaUGU3TTlNTFNZRFJZazJhL2x0ckxxN1BYNm1DNlo5NVUreDJ0SUZmQThYczIvNitQVlo1U2ZoWW1CeXJ3allkYjdEMnVLNnJUSkZpc1NnMndNaU9KWU1nME5QVDA5SnNObldqMFJCdC80czFZOHZsZGVsTGZOZ2N6MjJIbjQzamVPUlRuL3JVaU9kNVUvYUpCeDk4Y0ZZQUFBQUFBQUFBQUFBQUFLc09BVVlBQUFBQUFBQUFBQUFBZ0JWbDA2Wk5kWHVUK1lkLzZNTnB4ekNQSFFIV2dQTnpWZm5tMFRNeVBsZVRwZWhNaC9Jckg5b2xxY3NJeUhHVFVKQkFiaHJva3ArNWE0dDg4VnRIWldKK1hCYmp5TmtaYVpjZjJqNlNCSnA4NGUvZnQ2algyUUFVdTk2QnU3VERoZzB2c3N2ZTNGZVUvK1VEdHladG5iN01NS1JNNENYTDlwMmxMYnZlaXVYa1pFWFMzdkpkemxQTUJMSm55NURjdDJWUS90bjlPeGIxMmt2cmF3TjNsbUt3bUpFN1J2dmtJenRIazVJUGZmRXVjN3Rsek85MlJMRXMxVXl0a2JUMXh1N0NaYi9tOE5pa2pNMHNTSzBSeVZKczZ5OGwvZGNHTnIyVGxObVBiWG4vVGV0a2EzK24vT3FmSFpEcCticGNMaHVXOXNLcFNibHRmYThzRnh0ZTlJdjMzU3diVEp2K2dxa1hZN2d6YTQ1WlN2SXBYNENyeVl3aGsvcURIL3hneW9ZV1RVNU95ckhYanVtbm5ucXFWYWxVdkhxOVRvQlJHeWlWZkhFTVhpenZjVjMzMTVTbzM5S3hmbTMvL3YzL2lSQWpBQUFBQUFBQUFBQUFBRmg5Q0RBQ0FBQUFBQUFBQUFBQUFMU1Y0emphRk1sbXM3YW9udDRleC9mOVpKNVMzRmVPdFNNV0xjMG9sbGhyV2F6QWN5UVZlRW1nVHVDK2M0RFJKVFlVSkJmNmkzck45NXFhcnlmQk1zc1pMbUkvc3kyTFpkc3BXVjl2NmJsbjl2VlowOWFlYWJ2RmhQTUVucHU4MXJiNVVtaDlZZitJOU5LRGVSYkxCbDNaejJ6RGlCYnJTdGYzMHJMdFBtM2JXaGJSMXBuQWxWYTA5UDB4amkrMTllVy9KcnI0R2kyTDY3OTJIL3JPL3V1N2w3K2VhZk9hcEkyWCtGM1lNcC9YOXQvMHhXVmZhNTdacGt2Wkgyd2IyWDJBcjN4Y1MzWk1hUU9OY3JtY0RBOFBxNm1wS1ptZm45ZXpzN1BTYXJXVVhzSjNNNjZjN2ZubXVPcm9XQStiU2Nkc2g5cyt2ZmZUQytQVDQ4K1dTaVZkTHBjYkFnQUFBQUFBQUFBQUFBQlk4UWd3QWdBQUFBQUFBQUFBQUFDMFZTcVZpdFBwZEhUSEhYZDRveHRHVlU5UFQrQzYxejVvQVZodXpWWXNsWHBUV3ZIaUEycDZDeGtac0tVanU2alhkYVJUc3FXdmVFWGhRd2RPakVzeEU4cHRJejJ5WExiMGQ1clBIc2hpbFhJcHlZYSs1TVBGdjlZS3piSEhMbnRkWjg2MDJlTGVZNkNZU1phZjlwZDJPWTROMWJIN1I3MFp5WExKbU05cTE3YzNuNUhGdXJTK1N3MHdLcWJEWk5sMm4xNXNXdytiN2RQcVdIcllTQ09LTHZURjZQTGJlcUhSU2w2ejJONXJ3NHZzT2k2bC85cjF0QUZHTmhob0tjWXIxYVQvYnVndXlBMDlCYm1XYk1oUzN2VFpUTEQ0WTAzYWQ1Tjl3RlZMRHg0RDNvbnYrOUxWMVdXTHMzM0hkdWZZc1dPdGlZbUorT21ubjNhbkpxZFVyVlpqQjJ3UFQ0bnlSTWxQMkFueitFZGlGWjhzRkFvLzIyZzBhbWJXV1FFQUFBQUFBQUFBQUFBQXJIZ0VHQUVBQUFBQUFBQUFBQUFBbHBWU1NoekgwZWwwV2c4T0R1cUxONU83ZzBPREtwZkwyZWNFV0lzcXRhYThPajZUMUl0VlRBVkxDdlRKcDd3a3ZPUktBb3ltRnVyaUxUR2tacm41OXZoaFZ0VnR3K2NOekxJZDN4N2ZWa2RiWGFsTDYydVA2Y3UrYk04VlR5ODl3R2dweG1ibWsvNGJ0UllYWVdUM3ljNU1LSmx3OGNGOEF4Mlo1TFdldTdRMmJyU2lwUDhPTkZ1eWtuV1lkYlRiMUJaZ3VSU0xSU2NNUTNYcnJiZXFhcldxamg0NTJvcWlTTWJHeHJpbXNyMDZ0R2psdXU3L2JCNVh5bnZMcjRvcno1Ykw1V2NGQUFBQUFBQUFBQUFBQUxCaThjZDJBQUFBQUFBQUFBQUFBTUN5ODMxZjUvTjV2ZlhHcmRIZzRLQTdNREJBYWdIV3ZMbDZVMTQ3UHl0enRZWXNWa2NtU0VJK0ZpdWZDcEtTQ3hjZmZuVEo5RUpkMHY3cTZLS2U2eVRGYlVNUW11KzVOanRKSEhWOUJCaTlzYjZ5L01JMkJOM1lBQ1BiZjV2eDRvS1RYTE0vZG1aRHlZYUxEeEViTEdhVDJsL2kvbHlQNHFULzFwcVJyR1JGYzJ3ckppRkdCQmhpK2RnQUkxT2tWQ3BKSE1kU3I5ZWpXcTJteHNiR0JHMVZUSXFXWHpiMXRDaDVUaUw1TCtZeEFVWUFBQUFBQUFBQUFBQUFzSUlSWUFRQUFBQUFBQUFBQUFBQVdEYWpvNlBOVkpoU1cyN2M0Z1orb0FZR0IxUW1rN2srMGo2QVZXcSszcFJhYTJVSG9BRDRmcTBvVHZwdkk2TC9BbS9GOHp6Uldzdk9uVHU5WnJNcFBkMDljdmJzV2YzcXE2OUdqVWJEcWRmckpHdTFUMDZMM3FxVStybHl1ZndEY1J4L1M4WHFsVkp2NmVzZi9laEg2d0lBQUFBQUFBQUFBQUFBV0RFSU1BSUFBQUFBQUFBQUFBQUFMSnZPcms3ZDBkR2h0MjNiNWptT0kwRVFFRjRFckhDTktKWm1LeFlBcTBzYzY2VC9ScVlHOE9ic2VOUWFHQmh3NHppV1FxRWc2VXhhajQyTmFUT3Q2M1Z5Y3RwQkdhYnlUZW5Yb25zbGxuZWJraElsNGNURXhCTm1QaHNHQUFBQUFBQUFBQUFBQUZZUUFvd0FBQUFBQUFBQUFBQUFBTmRNT3AyT001bE1mTitlKzl6T3prN1YzZDN0Mi91Und6QVU0SHJUaUNLWnFUYVNRSkhGeW9XQktiNEFhSTlLdlpYMDMxZ3Zydi82cnBLT1ZDRHBnTXUwZ0pYT2hoblpBS050MjdhcFRaczJlZVBqNDlINThmT05wNTkrMnAyWm1WR05Sc1BSbWtDdzVXYmEzSVladWNwUlAyN3FENHVXZjFEZVY0NGlIZjJMSUFpbTkrN2RlMFFBQUFBQUFBQUFBQUFBQUczRmxURUFBQUFBQUFBQUFBQUFnR3ZHY1J6dHVxNU9wVkxKRGVHbVZ2Ym1jT0I2WkVNUFlodDhzSVR3QTl0dFhFY0pnUFo0by84dWdXUDZMcjBYV0Izc09EVU1RMlhETm11MW1sUVhxdHIzZmExc0FpZmE0anZhUG1PTE9hSkdXblJrempGQ2MyeE9DUUFBQUFBQUFBQUFBQUNnN1Fnd0FnQUFBQUFBQUFBQUFBQmNOZmIrNGpBTTQrSGg0ZmhkNzNwWDFOdlg2L2IwOVBnQ1FDWXJkVGx3ZkZ5V1lzZGdTVWE2Q3dLZ1BWNCtPNzJrL3BzUEE5azEwaXVqSmZvdnNOcVlNYXhueTgzYmIwNm12L0dOYnpTbXBxYmsyV2VmOVNVVzBhSUpOV29EMCs0OXRvNmorQnVtVEpmM2xaOFRKWTgyVzgzZnJ0ZnI1eDkrK09GNUFRQUFBQUFBQUFBQUFBQXNLd0tNQUFBQUFBQUFBQUFBQUFCWFJhRlFpSlZTdXErdlQvWDM5MHMybTFXKzczTmpOd0FBQUZhOWpvNE9jUnhIRFE4UFM2dlIwaE9URXhKRmtTMk1kOXZIMDZJN1REM29PLzVkWVRvOC9zQURENXp6UEcrc1hDN1hCQUFBQUFBQUFBQUFBQUN3TEFnd0FnQUFBQUFBQUFBQUFBQmNFU1ZLaXlOeTgvYWJtNmxVU3UzWnN5Y3dzeDBCQUFBQTFvaGJicmtsaU9OWXRtL2ZMdWZQbjllUGZ1UFI1dlQwdERzek0rTUtscDB5VEpVMzVWWWQ2MXZNU2NrL2pDVDZzdXU0TDdSYXJmL056SDlOQUFBQUFBQUFBQUFBQUFETGdnQWpBQUFBQUFBQUFBQUFBTUNTaEdFWXU2NHJROE5ES2dnQ0dSb2FjanpQVXdJQUFBQ3NRVFl6eDQ1N2k4V2kyclI1a3pNelBTUFQwOU55OXV4Wm1aK2ZGNjExVXJEOFRMc3JSem5yUll0ai9FUzVYQjR6cy8reVhxOUhEejMwMElRQUFBQUFBQUFBQUFBQUFLNFpBb3dBQUFBQUFBQUFBQUFBQUV1U3pXYmpmRDRmMzNubm5YNVBUNDhxRm91K0FBQUFBR3VVRFRES1pESzJxSHZ2dmRlejRVVzJQUG5ray9xMVYxL1Q5WHJkRVN3N1pUZU1pS3RGMzJMcVc1U29QVHJXTGVXb0h3bkRzR2JtRVdBRUFBQUFBQUFBQUFBQUFOY1FBVVlBQUFBQUFBQUFBQUFBZ010aTd3djJQQzhlWGplc2hnYUhWSGRQdDVQTDVaenU3dTdrUm00QUFBRGdlbUxId0daOExIZmVjYWRzMjdaTkhUMXlOR3ExV25MbzhLRWt5RWpIV2duYUlXVktiSHpTMUxYeTN2TGZpSllYNjFIOTBaNmVub1dQZmV4alZRRUFBQUFBQUFBQUFBQUFYRFVFR0FFQUFBQUFBQUFBQUFBQUxvOFNjVjFYU3FXU2JOcThTYnE3a3dBakFRQUFBSzVIUVJBa3hZeUprNkNpZXEwdTlYcGRIejU4V0xUNUQyMlRYQnVyUkgzWVZEWHpvRXNjeVRyYWVlYnMyYk10TTQ4QUl3QUFBQUFBQUFBQUFBQzRpZ2d3QWdBQUFBQUFBQUFBQUFDOEplVW83Ym1lN055NU03WmhSUnMzYlhSeTJaeGtzcG5rWm0wQUFBQUFGMnplc3RteGRXOWZyMHhOVGVsdlAvdnRSclZhZFNZbkozMUJ1M2hhOUMwNjFvT3U0NzdQQzd6RCt4N1k5Nkp1NmIvOHpPYys4NHdBQUFBQUFBQUFBQUFBQUs0WUFVWUFBQUFBQUFBQUFBQUFnTGVrekg5QkVPaXVyaTVkS0JUVSt2WHJsUUFBQUFENFBoMGRIY2xZT1F4RFNhZlQrc2pMUitKbXM4bjR1YjNzZGJKRlV6cE0yV1JPYjBKSE9UcnlvOGNFQUFBQUFBQUFBQUFBQUhCVkVHQUVBQUFBQUFBQUFBQUFBUGcrQXdNRDlUQU05Wjc3OTRTNVhFNFZDZ1ZYQUFBQUFMd2pHMkEwTkRUay9PaVAvV2hxZm41ZXhzK055NUdqUitKWFhubEZtMmxIeDVwUW8yV21ERzJKdnRuODNPdzY3dnYyNzlzL2E2Wi8zWEdjaVhLNS9DY0NBQUFBQUFBQUFBQUFBRmdTQW93QUFBQUFBQUFBQUFBQUFQYUdYdk5EZE9BSHl2ZDlLUlFLS3AxTzY0Nk9EckVCUmtFUUNBQUFBSUIzbG95dERUdU9kaHhIbXMybWRIWjJpaDFiR3pwcVJWS3RWUy84a2hZc0UzVmh3NFRtdkNmVVd0dnJaN3RNR1kyaUtGOHVsd2VyMWVyOGswOCtPWC8vL2ZmSFpqb1dBQUFBQUFBQUFBQUFBTUJsSWNBSUFBQUFBQUFBQUFBQUFDQ082K2hNSmhQZGROTk56clp0MjV6Ky92NGdsVW9KQUFBQWdLVXpZK3lrREE4UE8vZmZmNys4L1BMTHpibTVPZjIxcjMzTnIxYXJLbzdJeVdtVHRDMUtWTm5tR3VsWS8zd3FTQjNjdlh2M0EvVjZ2V0tlbXhBQUFBQUFBQUFBQUFBQXdHVWh3QWdBQUFBQUFBQUFBQUFBcmxmcVFsWHFLdWt3RmNiRllsR1ZTaVd4d1VXTzR3aHdQV2xwTFdMS1hMVXBTeEY0cm9TK0k2NVNZbStDQndBQWVET1pUQ1laS0F3TkRrbWoyWkR4YytOeEZFV3FWcXN4Z0dpdm5CbkQ5Zm0rZjFlcjFab3RsOHNucFNMbnlnK1h6d2tBQUFBQUFBQUFBQUFBNEcwUllBUUFBQUFBQUFBQUFBQUExeW5YY1NXVlR1bDdkdC9UTEpWS3p1am9LSDlEeG5WcnZ0YVVXR3M1Y0dKY2xtS2dJeU1EeGF6a1ExODhsL3dCQUFEdzVvYUhoNU14OThqSWlDd3NMT2hIL3VxUit0emNuUFBxcTYrR2duYmFGT3Q0azBUeWZrYzVKM1NrbjlFWi9RVXpud0FqQUFBQUFBQUFBQUFBQUhnSFhId0tBQUFBQUFBQUFBQUFBTmVaenM3T1ZoQUVlc3ZXTGI2cFpYQncwRTJuMHlTdTRMcDJiblpCbWxFcy8vV0psMlFwN3RrMElMczM5a3RRS29qbk9nSUFBUEIyUE04VE13YVhtN2JkNUZXclZkWFYxU1hqNCtPeEticGVyenRSRkRFK1gyWktLZEZhMjdyRFRONG9zZnlEZmZ2MjNTTXRPV0RtVFQzNGJ4OThRZ0FBQUFBQUFBQUFBQUFBMzRjQUl3QUFBQUFBQUFBQUFBQzR6blIxZFVXNVhDN2V2WHUzcjR3d0RGMEJyblBuNW1wU2E3YVdIR0JrM2RCZGtJR09yR1JETHNjQUFBQnZ6M1ZkVzlTTk45N29OeG9OR1JnWWtFTXZITktWU2lXeTRVVUVHTFdIUFQ4eVZkRVc1YW9idE5hUjR6dS9wV1A5bXBsSGdCRUFBQUFBQUFBQUFBQUF2QW11bUFNQUFBQUFBQUFBQUFDQU5jNzMvVGdNdzNoMGROVHA2ZWx4K2dmNi9YUTZIWnY1QWdBQUFLQzlQTStUam80T3VXbmJUYzdnNEtBYUd4dlRNek16clpkZWVzbHB0VnJTYkRZZHdiTFRXbnRLS1NlTzR3K2JlbXJmQS9zR3RkSVZzMDMrdmRrbXRZY2ZmbmhlQUFBQUFBQUFBQUFBQUFBRUdBRUFBQUFBQUFBQUFBREFXdWM0anRnQW8rSGhZV2QwdzZoMGRYVTVRUkJ3RXpRQUFBQ3dBdGp4ZWpxZHRrVU5EQXlvVkRyVm1waVlpSThmUDY2cTFhcHFOcHVDNWFkRU9hTEZVVXB0dHRObU81Vk1kU1oyNHQrNUdBWkxnQkVBQUFBQUFBQUFBQUFBQ0FGR0FBQUFBQUFBQUFBQUFMQW0yY0NpenM1T2ZmUE5OOGVkWFoxcVpHVEVENEpBUE05TGJwQUdBQUFBc0RLdFc3Zk9IUndjZE5ldlg1OU1QL2JZWTQyNTJUbDE5T2hSWDlBMld2U0kxbnE5NjdpUGVxNDNYdDVYUGlLT2ZMRmNMbjlSQUFBQUFBQUFBQUFBQU9BNlJvQVJBQUFBQUFBQUFBQUFBS3hCU3Fta1pMSVpuY3ZsVkQ2ZlZ3SUFBQUJneFhOZFY1a2loVUpCdE5hU1NxVjBvOTRRdEoxbno3SE1OaGsyWjF2Mit0czVpU1FuQUFBQUFBQUFBQUFBQUhDZEk4QUlBQUFBQUFBQUFBQUFBTmFRZCsxNlY4UGU0THhuejU3UWNSd0pnc0FWQUFBQUFLdE9HSVpKL2NFUGZqQnN0VnJ5Z1IvOGdMejIybXZ4NDQ4OUhzM096cnExV3MwUkxEdGxhTkVENXVHQUtMbDMvNzc5dnlWYWZ0Tk12eUtPL0tjSEgzeHdWZ0FBQUFBQUFBQUFBQURnT2tLQUVRQUFBQUFBQUFBQUFBQ3NZamFreUJTZHkrV1VLZExYMXllZTV5azdYeWtsUUx0NVpsOU0rYTY0N0k0QUFBQkxac2YyWnB3dm1YUkdob2FHVkRxVGxvWDVoWGhtWmtZMW0wMmx0UmEwaDJsN3MzWFVvSDBjUmRIdG4vNzBwNnZ6OC9PSHpPUFd3dzgvUEM4QUFBQUFBQUFBQUFBQXNNWVJZQVFBQUFBQUFBQUFBQUFBcTFnNm5ZNnkyV3o4N252ZTdXN1lzTUVwRkFxQkRTOENWb3BpSnBTQmpxd0VuaXNBQUFCWUd0ZDF4UWFXYnIxeHEyUExxVk9ubXROVDAvRmpqejNtVGt4TU9MVmFqWk9BOW5BdUJzZitoUDNoS2Urbm8xWTBaczdUL29VNUw1c3hzNTRYQUFBQUFBQUFBQUFBQUZqakNEQUNBQUFBQUFBQUFBQUFnRlhFM2h4clN6cWQxdDNkM1hGSHNVT0t4YUt5SlFnQ3VYanpMTEJpcEgxUGNpbGZIR2R4KzJhc3RjeFZHMUp0dGdRQUFBRGZMWnZOT3FKRmJyenBSalU3TXl2SGpoMkxESm1jbkNRMXNvMjA2TkJVM2FaOHFOVm96WlRMNVNHcHk0bEtzM0k4bDh2VnpUU0RXd0FBQUFBQUFBQUFBQUJyRGdGR0FBQUFBQUFBQUFBQUFMREtCRUVRRjR2RitNNDc3NHg2KzNyZG5wNGUvdmFMRmN1R0YvWG1NeEs0aTd1WFB0WWk0NVdhVE0wM0JBQUFBTi9ObkErNHRnd05EeVhUZi9abmYxYXYxV3BxYW5yS2tUZ0owaUhadEQwS3RzUlIvRWxSTW0yMnhYT3hILzlmb1JQK1lhVlNPVytlSThBSUFBQUFBQUFBQUFBQXdKckRSYXdBQUFBQUFBQUFBQUFBM3ZEcnYvN3I2Zkh4OFl3bzJXN0tENWhaT2NHS29FVHBqWnMydG56ZlY5dHUzdVo2bnVjT0RBeW9WSmh5QkZpRDRsakxlS1VxTTlXNkxJZUZSbE9xamFYZlQ1NEpQT25KcDhSenlRb0FBQURMYitmT25WNnoyWlRlM2w0NWQrNmNQbkg4UkZTcjF0VDh3dnppVWlSeE5lVzA2SzNtWE81bkhPWGNrOHZsbm5yZ2dRZU9tWE81UHltWHl6VUJBQUFBQUFBQUFBQUFnRFdDQUNNQUFBQUFBQUFBQUFBQWJ6aDc5bXpnZVY0dVZ2R3dFclZKQ0RCYUVXeDRrVGdpUGIwOWNTcVZVanQyN0xqMHQxNXVSc2FhRldzdGxWcFRGcTRnVkdneFdsRXNEVk9XS3ZSY3lhY0M4Vnd5eFFBQXdQSWJHQmh3NHppV1FxRWdtVXhHVDA1TXhxMVdpL09GTmxHR3FYeFQrazNwZFJ6bmRoM3J0T3U2SlRQOWw2WVFZQVFBQUFBQUFBQUFBQUJnelNEQUNBQUFBQUFBQUFBQUFJQjg4cE9mSFBBODc0Y2RjVzZKZFh5cmFOa2lTdkxtcVVEUU5vVkNJVXFuMC9IT1czYTZ4V0pSRFE0TytxN3JLZ0ZXa2I1Q1docXREc2tFUzd0RW9kcG95Y3RucHFXVVN5WGxXaG12VkdXbTJwQ2x5b1crOUhka2tpQ2p0MkxEamV6djFWc3RhVVphRnFOU2IwbWx0dlRQQitES1pId3Y2YjgyVk0wR3JGMnVWaHpMbkRtMlZKdkxFOFlHNFBwbU0zTnl1WnhzMkxCQjlmWDFlZFBUMDJwNmFscWVlZWFaZUdwcVNwck5wcVAxNHNZZ3VIS216ZTA1bk9zbzUwN3orQllkNjUzNzkrNlBYZC85cEpuZjJyZHYzMkVCQUFBQUFBQUFBQUFBZ0ZXTUFDTUFBQUFBQUFBQUFBQUE0amhPU2lsMWc5WjZoNm52TXJWTjRDQW9wODA4ejlPcFZFcjM5dmFxbnA0ZVpVT01CRmhsMHI0bitWUmc3OWlXcFloaUxaVjYwN3lITDlkU3RSbEp6WlNsc3VGRWRsM2ZqcU9VK09iM0dwRnRpOFdGQjlnUUZOc1dBTnJESHNOcy8xMHMyMnR0LzQzcHZ3Q1dnUTB3TXVjUU5naFYyV0xPSmNTVzhGQm96L2tFN2FIc2hoSDduYUQ3THN5UW92a1pHeDJtcmdrQUFBQUFBQUFBQUFBQXJISUVHQUVBQUFBQUFBQUFBQURYcWIxNzk5N2h1dTQ2SGV2L3I5aS9IV3JKWFhydTR2MlZXR2JLVVJJR1liemhoZzNxcnJ2dVV0M2QzVjR1bHhOZ05SdnB6c3RBTVN1NWNHa0JSSFAxcGh3NE1TNjcxdmNrNzNPdFBIWjBUTTdPTHNoaWxiS3BpK3VZZWVmZnphVmsxMGlQSERvOUtXTXppMXZXQzZjbmtpQW5BTzJ4cGI4b3RWWWszeng2Um1yTjFtVy9icTUyNFJobSt6OEFMTGRpc1ppVW4vdjVuMHZTaTU1KzZ1bW9YcS9ycjM3MXE2NjJjVHF4NXNTdlBRcjJoMm4vUjAxVksrOHJQeWxLSG0yMm1yL2RhcldtUC8vNXo4OElBQUFBQUFBQUFBQUFBS3dpQkJnQkFBQUFBQUFBQUFBQTE0bHl1ZXc4OHNnanp2MzMzOTk5Y1ZhZktmMm1PRnByUldoUmU2VlNLZTM3dm1ReUdVbW4wK0o1bmppT0k4QnFwOHgvamptK0JKNHJvZWRJdlJVdjZ2VlJGQ2RoSWMxNGNhOWJyRVlyTXA4dGtzVnlIYnR1VGxJREFBQ3NaR0VZMmtyWlVLTkdvNkZydFpyRVpveGxDZ09aOWtwcDBWM20vRy9ZbkJPbVB2dlp6M3FmL09Rbkp3UUFBQUFBQUFBQUFBQUFWZ2tDakFBQUFBQUFBQUFBQUlEclJMVmF6ZS9ldmJzWXgvRW5ISEZ1MUtMdk1yTlQ5am5DaTlySGNSeHQ2M3Z2dlRjcUZBcHF4ODRkcmdCclNDYTRjR25DcHQ0T21hMDE1TUR4OGNXOFhPYnFEZm5tMFRIcDc4aklYUnY2NUZwNStleTB2RDVaa2NYcVNJZXlmYkFrdmZtTUFBQUFyR1NYempXMjc5Z3U1OCtmMTE5LzVPdTFtWmtaOTl5NWM0R2dYV3g0MFYwNjFuY3FVZi9NbkI4KzA2ZzFubm5nZ1FkKzdkLzhtMy96a2dBQUFBQUFBQUFBQUFEQUtrQ0FFUUFBQUFBQUFBQUFBTERHZmZhem55MDE1aHRiWXpkZXA3VWVVbHB0MEVyYkZCRCtYdGhHcVZRcTluMC9YcmR1blJNRWdlcnI2MU5tbmdCclZVOCtMUU1kaXcvNW1hKzM1TmpFbkp5YnJjcGNyU25wd0JYUGNlUnFHWityeW55am1TeW4zb3Brc1R4UFNTN2xTK2krYy9hWTUxejRYYys5ZXAvL25iVGlXS3FOU0ZyUjR0ZnRrcTVzU3ZMbWN3UFhNeHZHWnZ1dnMzemRWeFlhTFlsaUxaSFdzaFNCNXliOU54M1Fmd0Y4TjllTVcvSzV2TnE0Y2FNN096ZnJGQW9GR1I4ZjE1WDVpc1JSclBRU2p6dTRLcnBNMmVRNTNvK1Z5K1hYemVObm04M216TC85dC8vMmxBQUFBQUFBQUFBQUFBREFDc1VGeVFBQUFBQUFBQUFBQU1BYVo4T0x4SldmVTZMZVpTYmZwVVdMZWF3RWJWVW9GRm9kSFIzUit6L3cvbFFtazdIaFJlK2NmZ0tzWXVzNmM5S0tZdm5TYzhjWDlUb2I0UEgwc1hQeTdodjY1WHlsS3QyNXRPUlRWeTlCeElZakhUZGx0dFpJbHJWWWFjK1QzbnhHTXVFN1g0S1I4ajNwTVovZnZtYTVWTTA2bmEvVXBOWmFlb0RSYUNrdnhVd293UFdzSXgwbS9kZVY1UnRDelZUclVtdEdFaTh4U01RR2p5WDlOeDBJQUh3bjMvZWxvOWloN243MzNVR2xVcEh6NTgvTDAwOC9IUjgvZmx6UHo4KzdPdEtjTHk0enBkNDRSeDgxNSt5anByNU5ZbWtwclQ1bHR0Y0pNMDJBRVFBQUFBQUFBQUFBQUlBVml3QWpBQUFBQUFBQUFBQUFZQTNhdTNmdnphYktLS1hlSzBwR3RkYnZNbVhBUHZjZE4wWmlHU2xIMlJ1RjQ5NmVYdFhkM2ExNmUzdmRmQ0d2TXVtTWVCNS91c1hhVjhxbGtpQ09wWHIxL0t4ODlmRHJzbWZMa09SVFJibGFiSGpSZ2VQbnBMN0VnQjhiN0xOdG9GTjY4dWwzL04zQWM2WFQvSDdnTHo2djdNUmtSWlp5K0s0MUlqazlQUzhMamFXM3ZmM011WlF2d1BVc0YvcEpYN0RmNTR0UmI3YmsxZkZaR1orcnlXSk5WR295VTIxSUZDOHR3Q2p3bk9RenB3TXlFZ0c4dFNBSXBGZ3N5czAzMyt3TURnN3FNMk5uNGxxdEprZU9Ia2tPSG5xSnh5QmNNWnMrNTBVNitvZ1RPWlA3OXUwYk10UG42dlg2MTlMcGRMMWNMaS8raXdVQUFBQUFBQUFBQUFBQXJoR3VnZ1VBQUFBQUFBQUFBQURXSUtYVWRrYzdKUzM2WDJ1dDdZMlBHWEtMMnN1MHZ3N0RNQjRjR25TMmJkdG1RNHpjWEM1SG9nQ3VHNlZzU3E3ay92Zlh6cy9JVncrZmxNMTl4YVJjTGNjblp1WEFpWEZwdEdKWmltSTZsRzJEWFVtUTBUc0piWmlJYVFjYktySllyMDlXeEZuQ2NYeSsyWlN4bVFWWmFEUmxxVHF6b2FSOERsZTR2dVZUUWRKL25VVUdHRldia1RsKzJRQ2pxaXlXRFRBYU4yV3BBVWFoNjEzc3Yxd2lCdUN0MlFDaml5Rkc5Z0NuWG43NTVlYmMzSngrNVpWWFhITSttZnlIdHJEbjhlWjd4L2toVXpXVXFPMW1VeHowUE85QXRWcWROdk1JTUFJQUFBQUFBQUFBQUFDd1luQjFDZ0FBQUFBQUFBQUFBTEFHL01xdi9FcmU4N3hNNEFZL3J4MjlRYlRjSTByUzVxbWNLWXRQeXNCVjRUaU9tTzJpYjcvOTlsWW1tMUVqSXlOdU5wdVZUQ2FUM0NRTVhFOXVXZGN0elNpVy9vNk14RnJMdWRuRmhYa2NPeitYQklEYzBOTWhsVnBUN3RzeUpQbVVMMHQxOE5TRUtaUHl0UmRQeWJlT2owdXQyVnJVNjExSHljYWVnbXpveVNmcjVEdnZmS2pOcFFMWjNOc2hIZWwzRGp0Nk00MVdKRjk2N2xnU0JuWDN4djdMZXMzNXVacDgvYVZUTWpZOUw0dVZDYndrTk1tdW4wTUlIcTV6dzUzWkpNZ3JkSmNXNW5WNlpqN3B2emNQbG1TME8zOVpyL24yeWZOeTVPeU16Qzh5Z016MjFtem9TekViWFBieENRQXVXYmR1blJ0RmtlVHplV20xV3ZycHA1NXV6TS9QTzJmUG5sMzZ3QXRYUkd2dEtxVTJtUU44dit1NEcxM2ZmWFgvM3Yydm1UUDlQMzd3d1FmL1JnQUFBQUFBQUFBQUFBQ2d6UWd3QWdBQUFBQUFBQUFBQU5ZQTEzVURwVlJLaTc1SnRHdzNzN2FaeDRJMlV5Sis0RXVwdTZUdERjRHIxcTBqQVFUWHJXTG1RbWhQMnZla0ZjV3lXQXVOVmxMT3pDekltQ2xYYXFiYWtOZW5LbksrVXBYcGhib3NsZzB3c29GRW1kQkwxdWx5Qks0cmVmTWF6MW5hb2FEUmloZTk3amI0eEs1amN3bHQ3cnRPRWx4MHVlc0hyR1ZwODMyZVR5MitIMTFTcVRlVC9ydWxyM2pacjdISEp0dC9GOHVNQ1pQK2E4T1c2TDhBRml1ZFRpZXBaK3ZYcjVkcXRXcURqT0ptczhsNVRCdVo0N3BOejh0cHJXMUFjWjg1ejdSZkpsa3ovVFVCQUFBQUFBQUFBQUFBZ0JXQUsxUUFBQUFBQUFBQUFBQ0FWZXhUbi9yVW5aN2ovYnpXZXFjb0dkS2ljMHBVVnRCV0l5TWo5VXdtbysrNis2N1ExS3BZTFBvQ0lQRXpkMjZScWZtYS9PYlhEOHBTZlBIcG8vS2w1NDdKUktVcXhVekt2Ti9tSkJBb0c3NTlONHUxbHJsYVU4YW01K1hyTDUrV3YzcnBwSHoxOEVtcE5TTlppbndZeU0vY3NVVzJEM1ZkOW10NkN5bnB5dmJMN3o2ZWxxV1lXcWpMcjMzbGdMeHJwRWQyRHBla2tBNmxJeDI4NmUrT1RTL0lONDZja3NkZU9TTi9ldkM0TkZ1TEQxN1paWmFURGJpMEJMQnVXVmRLd3RmU3ZpdExjZmowWk5KL2JYNVp5cnhIWHlFamdmZm03M1h3MUlTOFlINy9UOHl4N3FXejA3SlFiOGxpcEFKWGRtL3FsODM5SFFJQVN4V0dvUzNxZ3gvNllHcGhZVUdtSnFma3lKRWprU254N095c0YwVVJvVWJMekFiVW1YTi84MTNpYkRMbi9pTm0rczU5Ky9iTk9ySHoyK2JmQTZiS255bi9Kd0VBQUFBQUFBQUFBQUNBTnVBcU13QUFBQUFBQUFBQUFHQ1YyYjkvZjBFcGxXbzJtMm5mOFVlMTZGRlJzdDQ4TlhEeFY3aVJkSmtwUjJsbG1qMElBdkY5WHhVS0JaWEw1M1N4V0pSTUptUG5zMDJBaXdZN01ra0FpR052d0RiVDlpYnN4VmhvdHBKeWJHSk9PcXNOT1RGWlNkNnZNeHVLYS9xaGNyNy9OYTFZUzJ6S21kbHFFbngwZkdKV3pzek15L1JDWFpiQ0JpYTVycExCWWtaeTRlWG5rM21Pa3hRYkNwUTNyNXVyTjJXeEp1WnJjc0tzdTEzdm5ud2tPbzd0M2V6Mi96Zlk5YlcvWjl0bzNLenpZc05QTHVuS3BnZ3dBaTY2MUg5dG4xOUsvMTFvWFBqOU16TUxTZisxNzJXUFhjcjUyODZyVFhjMnZWckd6Ty9ZL2p0dit1NlY5TiswVC84RnNIVHE0dURDQnJJNjVwaGx4MnoyL01hV0tJcTBPUitWV3EyVy9OSml4M05ZT3JOZGxQazNBRHNBOVUyNysyYXlTeXZ6YndJaWhmMi9zbjlZWlZUbGtVY2VxZHgvLy8xeHVWeGVmSUlsQUFBQUFBQUFBQUFBQUN3QlY2a0FBQUFBQUFBQUFBQUFxMDBzUDZkRmIzQmQ5eGRpaVYwbEtsQmtGclZWNEFjNmw4dTFicjc1Wm5mYnpkdmNycTZ1d0lZWkFmaCtQMzNuWmprMU5TKy84UmZQU3IwVnlVSmphZUVjdi8zb29UZnFubnhLN3RzeUpMbVVMNzM1elBmOTdvbUpXWm1wTnVRckIwOUlNNHFsc29UZ29PKzByaXN2UThXcy9QUWRtMlVwN3JxaFB3bHYrdEp6eDVLZ2tzc1ZhNTJzeHpNbnh1WEgvLzJmeXE3MVBiSnJwRWN5Z1MraDc3N3hlNitPejhqWTlJSjg2ZmxqY2lYMm1EYnR5YWNGd04vNnlNN1JKRnpvOTU4NnNxalhOYU1ML2Zmelh6a2cvK3RmZmxzK3NtTlVCb29aNmN5bTN2aWR1VnBEeHVlcWN1RDR1Qnd3L1h5cHN1YVk4R0h6L2lPbG5BREExWkJLcFpMUzA5UGozclA3SHZmbGwxOXV6czNONmI5KzlLL2RoWVVGVmEvWEhjR3lNLzhPNEp0QnBXOGUvRS9KZEVyOXJQbjNnbWQzNzk3OUw4MDJxWmhaRXdJQUFBQUFBQUFBQUFBQXk0QUFJd0FBQUFBQUFBQUFBR0NGSzVmTDNzVEVoRnZLbHpZN3JwT05KTnBvWmcrYTRpaFIzQ2phSmtwZENJM3E2dXJTbVV4R20xcDFkbmFLRFM1eUhEWUw4Rlk4YytSeVhTVWJlZ295dTFDWG8rT3pjaVZzSUpFTlFScWJuaytDZkNxMTd3OG5PanU3a015M3Z4dHBMVmRxUTNkQmhqcVhIZ3lTRFQzcHlhWEZkMTFaQ3JzR2RsMm1UUHVkbUp5VHRGbHYyNjZYMkxhWW1LL0pVdG4zOGx4SHVyS2grWndwQWZDM09qS21YOVNYRnJ4bTJTQXkyMy9QbU9OU000NlNmbnpKdkhuZjJXbzlDVEphcXBUdkpzWDIzV0k2RkFDNEZzejVUekx3Nk8vdlY0MW1ROGJQamNldFZrdlpNQ05CTzZXMDZCN2Y5KzlxTkJwejV0OFN4c3k4TTZZK0l3QUFBQUFBQUFBQUFBQndEUkZnQkFBQUFBQUFBQUFBQUt4dzlYcTlvMUFvNU1TVjM0d2w3amV6YklDUktPSGUwSFlLd3pCT3A5UDZudDMzUktWU3lSa2RIZlVGd0R2S3B3SVpMaXI1aFh0dmxzZGZPWFBGQVVhVmVqTXBKNmZtWmJuOHduMDNTeVpZK2lVWDJ3YTZwRE9Ua2k4OWYweE9UTXFpUmJGTzF2bkFpZkdrWEcxRjg5bnlLVjkrWVBPZ0RCV3pBdUJ2M2JOeFFJNVBtT1BXWDhtUzFKcVIrUm5KWHg1K1hhNkZnWTVzMG0vM2JCMFNBTGhXaG9lSGs0SFF5TWlJVkt0Vi9lU1RUelptWjJiVkN5KzhFQWphUm9zZTB0cVVTTjhiZU1FWmllVmxVejVubnZxS0FBQUFBQUFBQUFBQUFNQTFSSUFSQUFBQUFBQUFBQUFBc0VLVnkrVk5wckpsTUlxaW9xbHRlRkZPMEZaZFhWMlI2N3F5YnYwNjVYbWVzdUZGaFVLQk5DbGdFVUxQa2MyOVJUazNWNVdSVWs1bUZwb3lYYTNMU2pkU3lrdGcrdjlJVnk2cGw2cVlDWk82dnlNcjQ2WU54bVlXWkNWWmI5WnZxRE5ydHRQUzF4RllxN3J6S1dtMFdqTFFrVW5DaUtZV1Z0YXhhL3RRbDNUblVnSUF5OEZ4SEVtbFVqSTBOT1IwZG5ZcXJiVk1UVTNaRWpjYURTZU9ZOEh5VWtxSjNRN212N1NaN0ZPTytzRzllL2YybXNjdnVDMjNXbjZvZkVnQUFBQUFBQUFBQUFBQTRDb2p3QWdBQUFBQUFBQUFBQUJZcVNMNUFWSHlqN1RvclVwVW42a0p5VmtCQmdZR29rSkhRZS9ac3llME40ZUdZZWdJZ0VVSlBGZjJiQjBVVVZxZVAzbGVEbzFOcm9vQW8rMkRYVEpRek1vZEcvcmtTZ3lhOTdEbDVzRk9pZUo0eFFVWWJSOHF5YnMzOWhOZ0JMeUpyWDFGS2FZRDJXYU9CemE4YU9yNHVLd2tQN1JqVkhLaEx3Q3dISHpmdDBWdDM3N2RiN1Zhc21YTEZubisrZWVqNTU5N1BwNmRuWlZhcmNhNVVoc29lNklxWWtPUWkrYmZFVFk3eXJHSlJyK3BQZjJLbVVlQUVRQUFBQUFBQUFBQUFJQ3JqZ0FqQUFBQUFBQUFBQUFBWUlYNHBWLzZwYkNybzJ1UDh0UU5adkoyaVdXTHZkblFQTzRRdEUwWWhuRVFCUEhHalJ2ZDN0NWUxZGZmNTJVeUdXMXYxZ1Z3WlRiM0ZlVWZ2dnRHK2ZMengyV2gzcFRUTXd2U2FNV3kwcFN5b2VSVHZueDQ1NGhzN0xsNmgrU1A3QnlWVzlmMXlPT3ZuQkd0dFZTYmtiUlRFcXpVbVpWN052WExmWnNISmZUSUhBRGVURHJ3a21PWERWOTdjV3hLbWxHY2xIYXlnVXFaMEpNOVd3WWxjQWtmQTdEOFhIUHNNZWRKc25YTFZzZWVONTA5ZXphZW5abU5YbmpoQmRlR0d6V2JUUVlXYldER21FbTdLNlUrYUtxcGZmdjJqWnA2d1p6UC91ZHF0VHI3MmM5Kzlxd0FBQUFBQUFBQUFBQUF3QlVpd0FnQUFBQUFBQUFBQUFCWUlicTZ1a0tKWlpzcHQydlJQMjFtT1JlTHZkbFEwQjZlNStsME9xMUhSa2YwaGcwYlZDNlhjOHc4QVhEbFN0bVUzTDJ4WDQ2T3o4aVR4OUp5dmxKZmtRRkd1VlFnWGJtVTNOamZLVHVIdStWcTJkSlhsUFZkZVFrOVYrSVZFR0JVekFReWFqN1BwdDZPSkZ3S3dKdkwrSjY4Mnh5N0FzOTVvLysydWZ0S1R6NGxQYmswZlJkQTI5aHoxaUFJcExldlY5bGl6cHVpNmFucCtOVlhYM1VXRmhaVXM5a1VMRC8xdC8rWXNEbVpGclhlVk9laUtQcFRjNTVyWnhGZ0JBQUFBQUFBQUFBQUFPQ0tjVlV0QUFBQUFBQUFBQUFBMEVibGN2a0d4M0d5VVJTVnpXUktsR3d4ZGFmVzJyWFBFMXkwL0d5Yis3NGZkM1IwNkczYnRrV2w3cExUM2QzdGRuWjJLak5mWE5jVkFGZUg3emlTQzMzNXlJNFIyVGxja3YvMjlDdHljcklpMzNqNWxNelYyMytUZTA4K0xkc0dPK1dIZG96S2JTTTljdk5nVi9KNXI1YXViQ29KUHZuVm45b3RjN1dHN1B1ako2VVZ4VkpyTFc4U1NpWndaYmd6WjdiRHFQem91MjZRcmYwRW9BQnZ4M0dVOUhkazVNN1J2cVQvL3RuQjQvS1ZGMDVJdmRXU1pxUmxPZlhtVTFMTWhQSVA3NzVSdGc1MENnQ3NGTjJsYnJkWUxMby85dU0vbHB6VVB2bkVrNDFLcGVLY09IN0MxYUk1MFcyZkxpVXExTEgrZjBaeGRMYThyL3l5eFBMWGpianhhTFZhbmYyTjMvaU5xZ0FBQUFBQUFBQUFBQURBSWhGZ0JBQUFBQUFBQUFBQUFMUlJGRVZaVTNXSWxudHNhSkZTcWtlYkNZS0wyc3R4SEFtQ1FQZjI5dXJldmw3cDZlbHhCTUJWWjBOQUhGRXlVTXhLWnpZbFQ3NTZWcUk0bHBYQ0J2djA1Tkp5VTMrbjdCenVsbnpvaStkZXZjTkI2RjBJUkxQaFRXZG5GOFEzNzIwRGpaYWJxeHpKcFlKa08yenBLMHJhNTNJUzRPMDRacHhtKzBsbk5rejY3M01uenlmOXR4SFo4ZHZ5OXVGMDRDZjlkNlE3bi9SZkFGZ3B3bFRvaEJKS05wdE5wZzhmUG14T2RDVTJnejlYeFVvVFl0UTJnV243d1B6N1E5SDh1OE1aTTUySm5mZzFwVlhLZGQyS0FBQUFBQUFBQUFBQUFNQVNjTVVaQUFBQUFBQUFBQUFBc0l3Ky92R1BaOE13N1BZODd4OHJyZTZOZGJ3emptSjc0NkFpdEtoOWxDZ3Rqc2l0dDk3YUxCYUxzbWZQbnNETXRpa2wvRTBWV0FZMkNNU1dYL25Rcm1UNi9xMURjbkpxWHY3ajF3OUt0ZG1TTXpNTHNsdzJkQmVTOGd2MzNTd2pwWnpjTWRvbjE5cXVrUjVwdENMNXlpLy9IWG44bFRQeXUwKzhLR1BUOHpKMmpkZTdrQTdrRjgxNnJ1dkt5Yy9jdVVWU3ZrdDRFYkFJK1ZTUTlOK0Jqb3o4ajNkdmxkOTUvRVY1NHRVemN2RFVoT25UMXphTWJmdGdsM3g0eDBoU3RnK1ZybnJBR2dCY2JSLzg0QWZEVnFzbEgvakFCK1Q0OGVQeGdXOGRhRTVQVDdzek16T3VZTm5aZjREUW9nZk13d0Z6UG55djUzb1BleG52eS92MzczL0JQUFg1Y3JrOExRQUFBQUFBQUFBQUFBQndtYmpxREFBQUFBQUFBQUFBQUZnRzVYSTVaYXBVcTlYcVZKRWFWRnAxMm1sQld5bEhhVWM1a3MxbWJZcVJaREtaQzQ4QnRGWHUvOC9lbjhESmRkMTEzdi92M0h0cjMzdHZ0YVRXTGt1V1pNZDJ2RVRlNGhCQ0V1QVpJRHdKRE1QMkI0Wmw0Qm5tU1lDRTJPNHNyekNFTU13ZlhqUE1FQjcrTS96NVA4QU1BenlFSlNFNGtaUFkyV3pGcTJSTHNxWFcxdnRlZTlXOTUzL09sZVNZeEl1cXBPN3FibjNlOXRHOWRhdXF1KzY5NTU1ejYxVGRiOGNpWVJqSFVENGx4VnBER3MxQW1rRWdEVnZNZk1PL2VzRWdFZGVSaU9kSXdydndGUW9iUk5LVmlra3E2a25VWGRucjZhUG1kZVNTVWZNYVV1TDdPZ3hBS2RXYjRYM1ZSbE91aEEzSnN6RjVkcjJzclBrOTJYaFU4c2xZR0ZyazJQc0owZ1BhNGpvcVBIN3ppVmg0L0k3UGw2UjI4Zmh0K3I1cHY3UmNDZWZpc1JtMlN4RTNEQnZyelNULzJmRUxBR3VCUGRkd0hFZmk4YmlrMDJubG16YlNsbEtwRk42djlaVzFsMmlmMmZibTdiRVRGeTA1UC9DSHpSaEd0cXVyYStJdi8vSXYvVU9IRGwzWmlTZ0FBQUFBQUFBQUFBQ0FkWThBSXdBQUFBQUFBQUFBQUdBRk5Kdk5RZGQxZjhaVjdqNkp5SGNGT25EVkJZTE95V2F5UVQ2ZjkrKzg2ODVJYjIrdnltYXpVWHRCTFlET2V1ZUJMZUgwWis2NVhzYm15L0ozVDUrU0Y2Y1c1T1Qwb2p4MmFsSk96U3pKMVhMRHBtN1owcDJWZ3pzR0pSN3g1QWR1M2k2ZW95UVRqOHBLaW5xdTdCdnFEc3VQM0w1YkRvOU95ZUhUVS9MdzgrZGtxbGlSUjA2TVgxR0lVU0xpU3N6OGpydDNiWkRlVEVMKzlUMzdwRHNWbDAxZGFRRndaZnF5eWJEWTQ5ZjY4NjhmbDZWcVEvN2k4Uk15VjY2RngvT1Z5TVFqWVVpUmJaL3NNZnREdCs2U3RGbldtMDRJQUt3bDVqMnhtUGRjdGppN2QrOTI1dWZueFpiUFBmUzVZSEp5VW1xMW1rT0lVVWM0ZG14Q2kzNnJtWCtybzV4L3FjMmd4ZXpzN1BmY2Q5OTlDNGNPSFhwYUFBQUFBQUFBQUFBQUFPQTFFR0FFQUFBQUFBQUFBQUFBTEpQM3YvLzkzYkZZekRXejM2RzE3bEphN2RkS2J6THpwQloxaUwwbzA1WjBPaTE5ZlgyU3orY2xsODg1NlZSYW90R29FQ2dGckQ3cHVDYzcrL0tTVDhUQzRJN04zUm1aWHFxR29UNU5QNUNsV2tNQ1gwc3pDRjd6NTlqak8rSTVFbkZVR0ZTVWprWERVSkRobm96MHB1T3lxejh2bnVOSzFIWEVjVHJmRm5TWjEyVFgyNzZTK1VwTk51UlNVbWswWmFGU2wxclRsMksxY1ZrL3h3WWoyZlhzenlZbEUvTmt1MW5QZkRJbVBlYm5KNkt1TENjYkR2V2pkMXduN2RpM29Tc01YR3JYUGJzMlNEdmlacHZZMzUxTHRCOWc5Yi9kdUMwTXhXcVYzUy8yZDdjVEt0V0ozM25KOTl5NFZSYktkV25WVm5QczJkL2RuMmsvaEtmZCtyVjNRMEgyRGw3WmZuNHR3MTBaYzV3Rzh0YTltNlJVYThxdXZwelVUSHRsajFzYmJGUTN4L0Rsc1B2SE5lMlIvWGtSVjhuTlcvdkQxMnpEaStMZThoeS8xOXF4QTZDejdIc3crOTVzOTNXN1ZYOS92NTRZbjlEVldsVW1KeWQ1WTlaQlpzd2lZczZkYlpMVWR6V2J6WVdSa1pFaGFjaDBzVlk4YXZaWHpkeHVQMVVUQUFBQUFBQUFBQUFBd0xyRWg3d0FBQUFBQUFBQUFBREFNcm4vL3Z2ZjZMcHVUQWY2VTNMaGo0dHdWWFdIMlFDVFdDd1diTjIyVmQxMjIyM0tCaGpaQW1EdGVlVEV1RlFiVFRrNXZmaFNrTkZyY2N6eGI0TTE0aEZYQm5NcDJkcVRsVzI5clFkbGRJb05MckxyKzh5NTJUQUE1ZmprL0dVOXJ6c1ZsK0h1ak93ZExNaGdQaVVBVmxZanVCQmNORk9zeXVqTVVsaG1TdFhMZXU3T3ZweGs0bEU1dUdNZ0RGNERnUFh1c2E4LzVpOHNMT2hISG5uRTFXTCtDd2ovWFFYbWxhZ25SY2tYRzgzR0g5WnF0ZWxQZk9JVEpRRUFBQUFBQUFBQUFBQ0FsK0hEWFFBQUFBQUFBQUFBQU9BcUdSa1ppVmNxbFZnaWtyalpmQkszV1R2NmpXWnhYTFQ4c0prNnBrUUZLMDdaajBVZDBWdTNiTldlNThubTRjMnFVQ2pJME5DUWlzZmpZZ3VBdGVmMDdKSTBmUzN6NVpvRVdrdXQ2Yi9tNDVWcEN1S21EZkFjSmVsNFZBcXBtQlNTTVZrcnFtYjliRkRUNUdKRjZtYitjZ05Ra3RGSUdOelVtMGxJSmg0UkFDc3JDRXo3NVB0U3FUZE5lMVVQdzhqSzljWmxQYmM3SFplbzY4cm03a3pZZGdIQWVqZDJmaXd3NzZubDFLbFRxbGdzYWpQMXpXM1hGRWZRS2Zha2M5eVUwMXIwNDQ1Mm5qTmpIT00xdi9iSWIvekdiOHdJQUFBQUFBQUFBQUFBQU1pRnYvSUtBQUFBQUFBQUFBQUE0Q3F3NFVXZTUrVzFxOStzdExwTHROd21Oc0FJbmVXSXRpRkcyN2R2RDJ4WTBjMjMzTXpucE1BNnNMa3JJOWVTdU9lS21KTHVKWVFJV0VzY1IwbkM4U1FSOGFRcnhXa2hBTHlXd1EyRGp0WmFOZ3h0a09ucGFiMjB0TlNjbVprUkFvdzZ5blplVzh4K0dUYlR1N1RTWDFSS0hYZkZmZDdjSnNBSUFBQUFBQUFBQUFBQVFJZy96UVVBQUFBQUFBQUFBQUJjb1YvLzlWL2Y1Q3IzUFVxcDY3VG9QV2JSWmpPZk10TzhvR055dVZ3em5VNzdiM2pERzd4Y1B1ZjA5ZldKNTNtU1NxWDRuQlFBQUFBQVZpRWJZR1JMczlIVTh3dnp3ZHpzbkRNM042ZU9uemdlakkyTmFSdG1wQVBOZTdvTzBIYkhLSmtWTFhWSE9jZk16U1d0OUg4dzc3UHJEenp3d0NNQ0FBQUFBQUFBQUFBQTRKckZYeFlGQUFBQUFBQUFBQUFBcnBCU0t1azR6bTR0K2tiUjhvWkxpd1VkRll2RmdtUXlHUXdNRGtoUFQ0K0t4K01DQUFBQUFGaTl6UHZyc0VSalVkWFgxK2RHbzFHSnhXTnk5dHhaN2JxdUZuU01zanRHcE51T2RwanhqNHlaTnMzdFB3bUNvQ1FBQUFBQUFBQUFBQUFBcm1sOGFSb0FBQUFBQUFBQUFBQm93d01QUFBCbU05bXNSUDA3TS9XMDFwdk1wMjlSMFJLOWVGRWZWcGpqT3RvR0ZtM1lzRUVPN0QvZzl2YjI2bFE2SmZhQzEwZ2t3bTRCQUFBQWdEVW1DSUt3TkJvTmJZbzg5OXh6elZxMUpwLy8vT2NqbCs3SHlqTmpJTnE4eDdhVEdYT3pic1pHbmpUVHJ6YUQ1djlsOXRQaXh6Lys4U1VCQUFBQUFBQUFBQUFBY00xd0JRQUFBQUFBQUFBQUFNRHJHaGtaY2N6RS9mRWYvL0dCZSsrOU42TzF2c1hjSGxhaTNtN21DMHFwdEpuM1NNbFpZZXBDU1NRU09oRlBTRGFYMVgxOWZUSzhaZGpKNS9NcWxVb3AxM1haTFFBQUFBQ3dCdG4zY283amhLRzBzVmhNbFVxbHdNekwyTmlZZWF2bjJnQ2Q4SEUyVDBld1lpNit5YmFUbENseDg3NDhNTk9TbVo2TVNjeTc5enZ1ZFE0ZE9sUVNBQUFBQUFBQUFBQUFBTmNFUHJBRkFBQUFBQUFBQUFBQUxzT3YvdXF2NWp6UHkzdU85MUh6S2RzK3MyaXZLVkZCUnptdVkzYUhrbmU4OHgzMVRDYWpkdTNhRlJFQUFBQUF3THBXclZabGRuWTIrT3BYdmxvelUvZk1tVE84UCsrd2w5S2tSSjR6NzlPZmIvaU4rei8yc1k4OUl3QUFBQUFBQUFBQUFBRFdQVThBQUFBQUFBQUFBQUFBdktyM3Z2ZTlxWFE2dlRXb0I3MU94T2tOL0tCZmlVcHJyVjJsK0hzaG5SS0pSSFEwR3RXRnJvTHlQRS9aOEtKRUlzRU9BUUFBQUlCcmdPTTRFb3ZGcEtlM3gvRWludVA3dnBSS0pXMksrSUV2T3RDOFAreWNwQ2pwTWUvVmI3Ny8vdnNMcnV1TzZiS3VmdWpqSHpvckFBQUFBQUFBQUFBQUFOWWxBb3dBQUFBQUFBQUFBQUNBMTVCTUptL1Z2djRsY1dWMzRBZlhYVnlzQ0MvcXJJR0JnVVpYVjVkLzc1dnZqU2NTQ1luSDR4RUJBQUFBQUZ3VG90R29kSGQzTzNmZGRWZXNVcW5Jd3NLQ1BQYjF4L3lUSjA4R1pqN1NESnFDbGZXeWdaTGhpK1dOWmxFZ3ZueGN4ZFJwYy91UEJBQUFBQUFBQUFBQUFNQzZ4TGVxQVFBQUFBQUFBQUFBZ0cveDRLOC9lTHNTRlEvYzRLQzV1ZDNNMzJHbVBWcnJicEtMT3NOeEhCMlB4NFBlM2w1bGl0UFgzK2RuczlsZ3k1WXRucUZNRVFBQUFBREF0YWZSYUVpdFZwUHo1ODhIODNQeit0eTVjMkpEalY1NDRRWEgzdS83UHUvak82T3BSV3VsMVNObU91ZUljOGdzRzYvVUs1OUpKQksxa1pHUnFnQUFBQUFBQUFBQUFBQllGL2dXTHdBQUFBQUFBQUFBQVBDdEhMbGRpeTZZdWZlWjRwb1N0WXZKTHVvYzEzVjFJcEh3aDRlSDNiM1g3NVZjTHVlYTI2NEFBQUFBQUs1cGtVZ2tMTHQyN1FvRGk0NGRPOVpZV2xyU3AwK2ZWbHByQW93NngxUDI3NndxdWRjUnAyRnVIekRsQ2MvenZscXBWT2JOUEFGR0FBQUFBQUFBQUFBQXdEckJoN0lBQUFBQUFBQUFBQUM0NXIzM3ZlOU5SU0tSdU9kNHY2Q1VTaXRIM1dNV3g4Mm5hWHUxMW80UzVRaFduTmtuZ2VkNXNudjM3aUNaVEtyTm16ZXJYRDZuOHZtOGlrYWpOdFJJQUFBQUFBQjR1V0t4R05ScU5Sa2RIVlhOUnRNR0dqVVhGaGFjcWFrcDNrUjJUbUJLMFJZZDZFZVVxOFpVb01iRWxVK1BqSXc4SVFBQUFBQUFBQUFBQUFEV05FOEFBQUFBQUFBQUFBQ0FhNXdOTDNJY0orMjY3bmVhbXdOYTlQYndEbTMvSWdoL0U2UlRiRUJSUEI3WG16WnZDaktaak5xMWExZEVBQUFBQUFCNERlbDAyakZGVXFtVVZLdFZQVGMvWjhOemhBQ2pqckxCMEZtdGRkWU1zN3pMakxlTW11bW9OSVh3SWdBQUFBQUFBQUFBQUdBZDROdldBQUFBQUFBQUFBQUF1R2FOakl5OFN3SjVsNW5kRWVpZ3owd0hsUW8vUXVNUGdYVFE3dXQyMTVQSnBMenBUVytLMlAyUnpXYkQ1ZEZvbE04M0FRQUFBQUNYUldzZFRtMklrU215dExTa25udnV1ZUQ1NTU0UHpMeGJyOWQ1ajlrQlpyOW84MTdmTjdOTkpXcEJpMTVTZ2Zvdm9tUnU1Q01qZnlRQUFBQUFBQUFBQUFBQTFoeStlQTBBQUFBQUFBQUFBSUJybHk5cFVUS2dSUStaVy8zcVlub1JPc3R6UFluSDR6cVR5WVM3SkJxTkNnQUFBQUFBcmJqMEZqK1JTQ2pYZGNQYlpsNmJlZTA0amswM1lneWdBeTZPdmRqdkwzdG1QQ1ppcHQxYWFadGM3QXNBQUFBQUFBQUFBQUNBTllrUFh3RUFBQUFBQUFBQUFIRE5lUERCQjdNU3lFOHFwYlpwMFQ5bkZqa1hDem9vSG84SDJXeld2K05OZDdoYnQyNTEwdW0wZUI1L2l3VUFBQUFBc0R6T25UdlhtSitiRHg1NjZDR3ZYQzZyYXJYSzJNRHFNRzdLcEhMVUw3aXVPM0gvL2ZjZkZ3QUFBQUFBQUFBQUFBQ3JIdC82QlFBQUFBQUFBQUFBd0xyMjN2ZStOK1c2cmhlTlJyYzQyaGtJSk5ndVdqWm8wY29RZEliZDlwRklST2R5T1oxSUpIUjNkN2ZLWnJQS0JoZXhYd0FBQUFBQXk4bU1FYWhVS3FVR0JnWlVzOW1VOGZIeHdFeVZEVE1TZEZMVUZxMzFqVUVRVEl5TWpLUjBXVS9QVm1hbnpMaEJ3OXdPQkFBQUFBQUFBQUFBQU1DcVE0QVJBQUFBQUFBQUFBQUExclZFSXJITmRkMmNhUGxQZnVBUEtxVjZ0Ym1oaEdzU095a1dpd1hkM2QzQm05NzBKajlmeUR0RFEwTVJBUUFBQUFCZ0JmVDI5bnFteUphdFc4TGJuL25NWjJxTGk0dnF5SkVqRVFsRWJPaXhvQk82Yk5HQi9sMnQ5YmlaUDZiaitxK3lrZXhmejh6TTJOczFBUUFBQUFBQUFBQUFBTERxOEFFckFBQUFBQUFBQUFBQTFwV1JrUkd2V0N6RzBwSDBzTVJrczkvd0Q3Z1JONnNEL1JQbTdyUXBXVUhIZEhWMSthN3J5cFl0VzFRaWtaRGR1M2Y3cVhUS3llZnpyZ0FBQUFBQTBBSFBQUE5NbzF3dXE5SFJVYmRjTE91SnlRbXAxV3JLOTMyK1o5c0IybEJLTFpqWmNTWHE4U0FJSG5lVmUxaTdlc2tzTzJMR2Zxb0NBQUFBQUFBQUFBQUFZTlh3QkFBQUFBQUFBQUFBQUZoSGJIaVIwUk80d1Z1ZHdQays1YWdEZ1Iva2xTSG9HQ1ZLaXlNeXZHWFlqOGZqK20xdmUxdnM0bDJPQUFBQUFBRFFRZnYyN1lzMG0wM1p0V3VYakk2TzZzT1BIMjVPVDA5N3BWS0pzWVFPdURpR2s3ZEZpOTVseG5iZTdZdi81MHFyTSthdTN6VExDVEFDQUFBQUFBQUFBQUFBVmhFK1dBVUFBQUFBQUFBQUFNQzZNREl5RW04Mm05L3RPTTVXSGVoYnpIU3pXYnpGbEp6V09rNkFVV2Vra2lrL25vanI0UzNEcXJlMzF4a2FHZ29pa1lnTURnNjZBZ0FBQUFEQUttSEdEcVRSYUVpNVhOYlQwOU8ycU9KU1VUM3p6RE5CcVZTeTl4SEEyd0hhN2hoTHlXblJzcWdjOWJoWk5HWEdGajdwKzM3SmpBZWRGd0FBQUFBQUFBQUFBQUFkNVFrQUFBQUFBQUFBQUFDd0RsU3IxVVFzRnJ0WkF0bW5IUFZkWnBGenNRalpSWjNqUlR4SnA5UEJsaTFidk0yYk42dHNOdXM2RHRkOEFnQUFBQUJXRnp0MkVJMUdiVkg1Zk40V0tSYUxjdnIwYVR2bUVJWWJZZVc5TEpCNk9QeXpyVnFHbGFneDMvZi94b3d2TEpnbEJCZ0JBQUFBQUFBQUFBQUFIY1kzdFFFQUFBQUFBQUFBQUxCbWpZeU1iSE1jSitVMy9JOHBwUkphOUU2ek9LdTF6dG43RmNsRks4NXU4a2drRXRpTFBXKzY2U2FWTCtTMW1kZTVYRTZaNWNyeitCc3JBQUFBQUlEVnIxNnZTeEFFTWo4L3IrMzhrMDg4R1RTYlRYbnE2YWNjMGFMTTJJT2dJNXBtN0tFWTZPQ2syUWNMcm5LZmxFQytWQS9xWDZ4VUtvdS84enUvVXhFQUFBQUFBQUFBQUFBQUs0cHZCd01BQUFBQUFBQUFBR0ROOG4wL1pTWTVVWEtuRnUyWStheGRUbTVSWnptT0kvRjRYQThNRGlnYlpHU0xBQUFBQUFDd2hrU2owWEE2TURBUXZxYzljL3FNcmxhclpnaENpVlphMnhBalFTZDRXbXN6MEtEZVlNWi81czF0RlRqQlNhVlYzSFhkb2dBQUFBQUFBQUFBQUFCWWNYeDRDZ0FBQUFBQUFBQUFnRFhqbDMvNWx4UEpaTElyNGtUK3BmbWs2eVl0K2daVGNrcFUvOFdIT0lJVkZ3WkdLZEUzMzNSemtNdmw1TUFOQjhMOWtFcWxsQTB6c2dVQUFBQUFnTFdzVnF0cFF4WVhGK1hjdVhQK2swODgyWnlibS9NV0ZoYjRZNktkVlRYN3BXU21aVE0rOUdVelJuRXlHby8rMWdjKzhJRVpBUUFBQUFBQUFBQUFBTEFpK05BVUFBQUFBQUFBQUFBQXE5N0l5RWd5R28wbWZOL1AxK3YxQVMxNldJbmFZdTRhTU5POG9DTWN4OUUybkNpVHpvaHlsTmp3b253K2I2ZjhJUlVBQUFBQXdMb1NpOFdVRFRDeTczM0w1WEw0L3RlTVU0U2xWQzVwK3hnZGFONFByN3k0S1RGVHVrVEpaalBWeldaenN4bExTaFdMeFpuRnhjWDZIL3pCSHpRRUFBQUFBQUFBQUFBQXdMSWh3QWdBQUFBQUFBQUFBQUNyWHJQWjNDU0J2RStMM3FsRTNXV21kakVYQlhaWVBwOXZkbmQzTisrNTk1NW9UMCtQRzR2RlhLWFlMUUFBQUFDQTljbSs1elh2ZldYTGxpMmVMZlB6ODJMTEY3N3doV0JxYWtvWGkwV1hFS09WcDc0NUdIRzdHVE82M1cvNmJ6ZnpRVEtaL0ZsVEpzMzg1d1VBQUFBQUFBQUFBQURBc2lIQUNBQUFBQUFBQUFBQUFLdlN5TWhJdmxnc1J0UHA5QzdmOXplYlJRT21kQWs2eW5FZEhZMUViWGlSNnVycXNzV0p4V0xLY1J3QkFBQUFBT0JhNG5tZXhPTnhHUmdZc0ZNMU16MWpRNWoxek96TWhVQWRMZWdBcmJVTldIWk0yYXNDMVcvR21KYk1maWt0TEN5ODJOM2Q3WnZiVFFFQUFBQUFBQUFBQUFCdzFSQmdCQUFBQUFBQUFBQUFnTlhxem1ReW1kS0IvaStPY2p3dE9tMFhLcVVFbmFFY3BWT3BsRDg4UEt4dXVlVVdONS9QZTdZSUFBQUFBQURYb0hRNkhaYUJnUUhYM243NjZhY2I4L1B6Y3Vqemh5SmFhd2wwSUZoNVp1d29GYzVvZVVBclhaUkFUcmpLL1Z3Mm0vM2RZckU0YmU0aHdBZ0FBQUFBQUFBQUFBQzRpdmgyTndBQUFBQUFBQUFBQUZhRmtaR1JlS1ZTaVVVaWtkc2N4OW1xdGI3VEVTZHVQdEg2Ym5PM1kwcFVzT0xDd0Nqei84NGRPMzNQODJUanBvMnFVQ2lvd2NGQkZZL0h4UllBQUFBQUFDQXlOVFhsbTdFTk9YNzh1RnNwVi9TWk0yZWF4V0xSTFpWS2pxQlQ2cWJNbW5HbWsyWjg0eXRtK3FJWjY1aHl5czduUno0eE1pa0FBQUFBQUFBQUFBQUFyaGgvRFJVQUFBQUFBQUFBQUFDcmdnMHY4and2N3lyM2JlYm1mVXFwdlVKb1VjZlpBQ05iZGwrMzI0OUdvMnIvL3YwUkFRQUFBQUFBMzZhM3Q5ZlZXa3RmWDUvTXpzN3FScVBSSEI4ZkZ3S01Pc3FPTFEyWTBpOWFiamVqSEllVlZtZnEwZnF6WmhrQlJnQUFBQUFBQUFBQUFNQlZvQVFBQUFBQUFBQUFBQURvb1B2dnYvOTZwZFY5Wm5iWWxNMk80K3pUb3Z1MTFqbWxsQ3ZvaUVLaDBFeW4wOEhPWFRzamlVUkNiZHUyTFhCZFYvTDVQQmRkQWdBQUFBRHdLbXlBVVJBRTBtdzI5Y1RFaEQ4M04rZk96ODJyMGRGUmYzSnlVcGZLSlZjSG11L3Zkb0RaTjlxTU5jMlkyYklTOVkxQWdra1ZxTDhJL0tEMmtkLzR5TU1DQUFBQUFBQUFBQUFBb0MyZUFBQUFBQUFBQUFBQUFCMmtsT3BUb3U3VG9uZWJtOWNGT3JETExFSG4yUENpcnE0dWYrZk9uVzZoVUhEajhUakJSUUFBQUFBQXZBNDdubUVEZ0UxUm16ZHY5c3g3YXlrV2k3SzB0S1FYRmhhQ2NybnNtakVRd2NxN09OalVZK2NEQ2ZyRGlaSWpydWN1bW5rQ2pBQUFBQUFBQUFBQUFJQTI4YTF2QUFBQUFBQUFBQUFBckxpUiswZCswa3p5Z1FwKzJrd3pTbFRCbEVpZ0E0L2tvczZJUkNKQk9wMjJnVVZPR0ZyVVZkREpaTkl1Rjg5anR3QUFBQUFBMEE2dHRRUkJJTTFtVTlmcmRUbDY5R2l6VnEzSmw3NzBKZGZlWjVZUkdOd0IybTU4Q1VPTjVzeVlWTVBNUHFlVmZzVHNwLy9jYURRV1AvN3hqeThKQUFBQUFBQUFBQUFBZ012aUNRQUFBQUFBQUFBQUFMREN0T2lzbWVSTUdUYkZOU1ZxbGdraE9aM2xPSTZPeCtPU3lXWWtsVXFwUkNJaEFBQUFBQUNnZlhhc3czVmRXMVFzRmhQN1h0dk1hOFpBT3V0bFNjMWRwdGdBbzQybTVFMnhLYzZFU2dFQUFBQUFBQUFBQUFBdDROTlBBQUFBQUFBQUFBQUFMTHYzdi8vOTNZN2pwQ051NUxmTnpSdTE2TzJDam92RllrRXltZFIzM25Xbm44bGsxSzVkdXlJQ0FBQUFBQUNXWGJWYXRVVi85YXRmclU5TlRqa25UcHpnUFhtSGFjTk9sVktqU3RTb0JQTHZSejQ2OG1rQkFBQUFBQUFBQUFBQThKbzhBUUFBQUFBQUFBQUFBSmJKeU1oSTJreDJCRUhRN3poT1RnZTZWNG1LQ3pyS2hoWjVucWNMaFlKa2MxbXg0VVdKUklJL2ZnSUFBQUFBd0FveDR5VGl1cTUwZDNjck0xN2kyRUNqWXJGb2kvWjlYMTNNMGtGbnhMWG9uSGIwN3Z2dnY3OWk5c1Y1dCs1V1B2VHhENTBWQUFBQUFBQUFBQUFBQU4rR0FDTUFBQUFBQUFBQUFBQXNuNmJjS1k3OG1oSzFPL0NEL25DWnVTSG9xSzFidHpheXVheSsvZmJiby9GNDNJbkZZcTRBQUFBQUFJQVZFNDFHYlZHMzNISkx0RjZ2UzdsY2xxZWZmdHAvK3Ftbmc5blpXYS9aYkRKK3NzS1VjWEYyd0JZemhQWGJacEZOa3ZxWXhHVE9UUCtqQUFBQUFBQUFBQUFBQVBnMmZMZ0pBQUFBQUFBQUFBQ0FxMnJrL1NON2ZjOHZtTm50cm5KdjFLTGZyclcyRjM3bDdQMHZ1eGdNSzhSeEhIdFJaRkFvRkJ4VFpQUG16WDQ2a3c1MjdOamhHY29VQWRhejBla2xxZnUrVkp0K1M4OXpUWE1WY1IzcFNzZWtPNVVRNEhJY241aHZ1YTVacnFNa240aExJdXBLSVJrVHZMNXl2U2sxczYybmx5cmhkS25ha0VyRE44dnJVcXcycFg2Wis2RTNreERQSE92SnFHZU9lYnY5bzJZL1JNenl1SGltRDdYN0JnQUFZRGsxbStiY3haekRuRHQ3TGpoejlrd3dQall1dFZwTmpZK1BPNDFHUXdWQklPaUl3SXhwYVZIeU4wcXJpbkxWLzJQMnhaUVpaM20yVXFuVWZ2TTNmM05CQUFBQUFBQUFBQUFBQUFqZlJBWUFBQUFBQUFBQUFNQlZwVDM5bmE1eXQyblJQMmVLdmVMZkpiT29zMng0VVRhYjlmZGV2MWZ2MzcvZlRhZlRydWQ1cmdEWGlLK2NIQStEVGViS3RaYWVGM1VkU2NVaWN0UG1YZ0tNY05rZUg1MlNNM05GYVZYVWMyVGZobTRaekNVSk1McE1NOFdLTE5VYTh1Z0plNHpYNWRqRXZJd3RsRXdweStqMG9zeVVMdStZdDhkNElSV1RqVjFwU1VVanNuK29XM295Y2JsbjE1REVJNjRrSEw1ZUF3QUFscGNORnJabDU2NmRqaTJuVHA2cWwwb2wvZEJERDNsbXFtcTFtaVBvQk9maW1OYjMyVDhacXdOOW41bC8xcFFSTTdZeVlhWUVHQUVBQUFBQUFBQUFBQUFHM3hRSEFBQUFBQUFBQUFEQUZSa1pHZWx6WFRmWGFEUit3dHhNS2xGM2FLMXQwc2MrZTc4aXZhZ2pJcEZJWUM5K3ZQNzY2LzFzTHF2NisvdWRRcjZnOG9XOHNzc2RoMnNmY2UxNC8vLzZzc3lXYXZMRW1hbVdudGVWanN2bVFrYSs1NFl0OHQybUFKZmpwLy83NStTcHN6UFNLaHVXOVNPMzc1YWQvVG01YStjR3diY3IxeHBTYWpUbGtSTmpzbENweStlT25nM0R5YWFLRmZHRFFPWkxkU21iK3l2MXBoUnJkYWszZzh2NnVmbGtUQklSMSt3RFR6ekhsWHdxRmdhWWJjZ2xaVk5YeHBTMDdPclB5MkF1SmJzR0N1WXhuTm9BQUlEbFZTNlZnM3FqcnNmSHg1MXl1U3hIbmozU3RFRkc0MlBqN3NXd2FIU0FHZStxbUVuUmpIMTkzUXgzVFlpV1k0Mmc4YVVnQ0k3R1lyRUZNMGJXRkFBQUFBQUFBQUFBQU9BYXhKK0lBd0FBQUFBQUFBQUF3Qld4NFVXKzcvYzd5bm1uMXJyUExCb2dzNmp6ekg2UlJDS2h0MjdkR3VRTGVXZG9hSWpFSWx5enppK1VaR0t4TElkUHR4WmdOSmhMMmd0VVpiNVNFK0J5dlRpOTJISmRzd3JKbU15VXFqSllUUXBlV2MwUHBGaHR5Skh6czNKbXRpaWZldUtrTE5VYWNxWG15eldaZjVYNzltNG95TjdCTHJud044S1ViT3ZOaXVmd2RSc0FBTEM4a3Fta2s1U2s1UE41cVZRcWVtcHFLb2d0eHRUNHhMaXJBcVVKTWVvTU05NlZzS0hkWnZ1L1hZa2F0NmVIWnZ6bGpMbnJ6TXpNVE5GTUNUQUNBQUFBQUFBQUFBREFOWWx2VkFFQUFBQUFBQUFBQUtBbFAvaURQeGpkdVhObkllcEU3eEpIN3ZRYi9pNHR1dC9jZFoyZ281UW9QYngxdUpsS3B2UnR0OThXOFR4UDVYSzVTRFFTNWNKR0FNQ2FZd1BFaXJXR25KNHR5cU1ueHVTSk05TmhtVndxUzYzaFg1WHdvdGR6YW5wSnBwWXE4dlM1R1lsNXJuekgzbzJTaWtYa2w3L2pSbkVkUjVKUnZub0RBQUNXVnlRU2tWdHZ2VFZTcTlYVTNyMTdaZlRVYURBNk9ob3NMaTY2bFVxRnNPSVZaa083N1htcSthOWdidDVneG1MZTZ6cnV6eFVLaGM4ODhNQUQ0eC8rOEljL0tRQUFBQUFBQUFBQUFNQTFobTlSQVFBQUFBQUFBQUFBb0NVREF3UEtpQWRPTU9TSWM2TVd2VnRyM1c4WENqckdoaGVKSTVKS3BYUTJtOVdiTjI5V0w5MEZBTUFhcEUxcEJscG1TMVU1T2Iwb3o1eWJrYStkbkpDVlZLNDN3eksxVkExdkR4VlNrb3BHd3RjbEVnZ0FBTUJ5cytIRWhVSkJOWnROaWNmanNyaTRLQk1URTdwWUxBbzY0K0lZV1B4aTJXOXUya2lqVTJhYUZBQUFBQUFBQUFBQUFPQWFSSUFSQUFBQUFBQUFBQUFBTHN1di9kcXZGV0t4Mks5b3JUY3BVZTgyaXh3dDJySDNrVjNVT2FsVUt1anA2V25lZk12TjN1Yk5tNTEwT2gzMVBENEdCQUNzYlhQbG1rd3NsdVhIL3VpZlpLWllsZEdaSlZrTi91SHAwK0gwb2FObjVjREdIdm40dTk0azNhbTREUGRrQkFBQVlEblo5L3I1ZkY3dXVPTU8xNWJwNldteElVYWYrcHRQQmFWU1NhclZxaVBvQk5mK1k4YksvcVZONEh6d2dRZC8xdHljVUk3NktkZDFKKzYvLy83akFnQUFBQUFBQUFBQUFLeHpmSE1aQUFBQUFBQUFBQUFBcitwM2YvZDNZM1k2T3p2YjcvdCtRV21WRXlVeEhXaEZhRkhuMkcwZmpVWWxFb25ZQUNOSnA5TXFGbzJKNDNDdElnQmdiUXUwRHFjMnZNaVdXdE1YUHdoa3RiR3ZjNmxTay9QekpYSE1LVkYvSXlHZTY0cm5jSDRFQUFCV2hoMERzS0ZHdVZ4T0xnWVo2MmF6cVV3UmRKUU4vSGFWcUlFZ0NOVEl5TWlTMXJyODhNTVBsdzhkT3NUT0FRQUFBQUFBQUFBQXdMcEVnQkVBQUFBQUFBQUFBQUJlMWRUVTFDN1hkWE02MEgvb0tHZFFpODdhdnlaUGVGRm54V0t4b0srdlQrNTd5MzFPT3AxMmVucDZTQzRDQUt3THBWcERtb0dXSC91amY1SjYwNWRuejgzS2FyUlFxY3ZoTTlQeWZmLzU3K1d0ZXpmSi8vbWRiNUM5Z3dVWnpLY0VBQUJnSlhSMWRZWGxSMy9zUjhNeGdVZSs5RWh6Zm41ZUhuLzhjZGVNMzRnTm54WjBRbGFKeXBydC96L05YaGczODgrYjZWOGRQSGp3ci9mdjN6LytlNy8zZXpVQkFBQUFBQUFBQUFBQTFoa0NqQUFBQUFBQUFBQUFBUENTa1pFUnIxZ3N4dEtSOUxERVpMUHYrd2ZNNHF3cEJWTWlnbzdxN2UzVmtVaEVob2FHSkpWT1NUcWRsbmc4TGdBQXJCZFBucG1XcFdwRFpvb1Y4UU10YThIVVVrVWVQblpPNGhGWG9wNGorV1JjWEllOEFBQUFzTEw2Ky90VkpwT1JScU1oUzB0TGVuSnkwcTlVS202ejJlVEVwSFBpV25TLzB1cFd4M0hjcmx6WE15Ty9QbEk4UDNYK2lULzRnejhvQ3dBQUFBQUFBQUFBQUxCT0VHQUVBQUFBQUFBQUFBQ0FsOWp3SXFNbmNJTzNPb0h6Zlk1eWJ0Q0J6Z3M2U2psS0sxRnkzWFhYK1RhdzZPQ2RCL21jRHdDd0xuM3V1Yk55ZEd4T1JtZUtzbFljT1Q5clh1K1NwS0lSU1VROGlYcXVaT0pSQVFBQVdFazdkdTV3Z3lDUVhidDN5ZWpvcVAvWTF4OXJqSStQMnpBanhoQTZ4NDZwNWJYbzNXWmM1NGZNK003Zm05dmpXN1pzK1ZVekpjQUlBQUFBQUFBQUFBQUE2d1lmU2dJQUFBQUFBQUFBQUVCR1JrYVMwcFR2RUNVRGdRcXVVMXJ0MFVvUG03dmlnbzVKSkJLQktmN0dqUnVkZkQ3dmJOMnkxZkVpZk1RSEFGaC96cytYWkw1Y0M4T0xqb3pOeWxyaUIxb3FqYVljUGowcHRhWXZQL3FtNndnd0FnQUFIYUdVRXMvenBMdTcyejF3d3dFOU1ERGdMaTB0MlVDam9GUXVTYjFXZHdRcnp1d1hwUzNSTzgzTndWcXQ5a3YzMzMvL2pKbC95SFhka2htWE95VUFBQUFBQUFBQUFBREFHc2EzbXdFQUFBQUFBQUFBQUNEUldqUlJqOVMvMTh6dVVLTHUwcUtWbVNwQlI5bndvdTd1N3ViMSs2NlBEQThQcTFnc1pxOTVFd0FBMXB0ejh5VVpuVm1TWjhkbTVlajVPVmxMZkszRmIvankrT2lVbkRMcjhNNER3N0tsT3lNQUFBQXI3VktBVVU5UGp6SWxNajA0TGNWaVVSYVhGblhUYjJvQ2pEcm40b0RPcnZDR2xoMnVjcWNDQ1NhQ0lKZzBTMDRKQUFBQUFBQUFBQUFBc0lZUllBUUFBQUFBQUFBQUFIQ04rdlZmLy9WYlhkZE5LYTMrWFZXcUtkRnluU2hKbTZseWxHTW1XckN5N0xWc2lXVEM3KzN0bFQzWDdYRUxoWUpYNkNvNHVWek9pVVFpUW5nUkFHQzlldlRFbVB6OTA2TXlObCtXZHJpMkQ0MTZzbStvMjVRdTJkU1ZrZDUwUEF3U2lucnVQM3RzSXdpazJ2RGx4T1NDbko4dnlSTm5wbVNoVXBjajUrZk04cWEwYTNLcExEUEZxdno5VTZmaytNU0N2T2ZXblFJQUFOQkoyV3hXMHVtMGZPZDNmcWZUYURUazZKR2padEpRanovK2VQajk0Y0NjRjZFamtscnBYak1tOTRDWlgzend3UWVmMFZwL3J0bHNmcTVTcVN6K3p1LzhUa1VBQUFBQUFBQUFBQUNBTllRQUl3QUFBQUFBQUFBQWdHdFVKQkxwQzRJZ0pVcnVWS0ljc3lnYjNxR0U4S0pPVWFKZDE5V1pURVlOREE1SVBwOVhwcmdDQU1BNk56WmZrcFBUaTIwSENObU12NGpyU0hjNkx0dDZjN0puc0NBYmNxa3d6T2hiQTR4cVRWL0s5YWJFelBKMExCTCtidWNxaEFSVzZyNzUxNWZ6QzJXSlJ5TUNBQURRYWRGb05Kd09EQXlFSnp1VGs1TzZYQzZIQWNsYU0vYlRRWjRaZXJQamNIdE5LWnI1dUFSeXd1eVh1QmtYS2dvQUFBQUFBQUFBQUFDd3hoQmdCQUFBQUFBQUFBQUFjSTM0bFYvNWxVd2tFc2s2anZQL2NzUzVMZkNERzh6aXFLaUx3VVhvQ0xNL3d1bWIzL3ptUml3V2srdjJYT2VaL1dRRHBsNjZEd0NBOWVyOGZFbWVQRE10VDUrZmxUT3pTeEswZUIyOURSN0t4Q095ZjJPMy9NcmJicEpOWGVtd2VJNHJucXUrTGJ6SWlycU9SQkpSdVd2WEJybTlHY2ozMzdSTkduNGcvKzJSbzNKcVprbis4SXRINUVyODllRVhKV1ZlMDgvY2ZiMTVmV0plWDFRQUFBQldnLzM3OTBkc2NOR3VYYnRzbUZIenlMTkhtbE5UVTk3MDlEVGZKKzZjdENsN2xhTit4ZFh1THlUaWlTY2Z2UC9CODZWSzZmNVBmT0lUa3dJQUFBQUFBQUFBQUFDc0FYemdDQUFBQUFBQUFBQUFzTTZOakl3a3pTUlpxOVY2SE1mcFZscHRFVWUyS0ZHOVlnT00wQkZtWDJqWGRTV1ZUaWxEOG9XODJBQ2piRGFyQkFDQWEwUzUzcENaVWxXS3RibzBXMDB2dXFndm01QkNJaFlHRi9WbEVwSXo4Ni9GOXJ1MnM0MTdibGhFSXVIeTRlNnNhSE5QSVJtVFNzT1hhcU1wN1NpYjV6V0NRSmFxOVlzQlM1eHVBUUNBMVNFYWpTb2JZSlRQNTZWZXI0ZGpFV2E4S0N5TlJrUGJaVUVRTUM2eDhxSm12eFRNdEdER2krYk1TV2swa1VnTS8vcXYvM3JDODd3NSs0QVBmZWhEaXdJQUFBQUFBQUFBQUFDc1VnUVlBUUFBQUFBQUFBQUFySFBOWm5QWWM3ejdJMTVrbjdtNVR5NWNoc2JGYUIwMk5EVFU2T3JxOG0rLzQvWm9vVkJ3NC9GNFJBQUF1TVpNTFZYbGtSTmpNcjFZbFhiMFpoTHllejkwaitTVE1kazMxQzFYNGoyMzdwU0ZTbDFjUjhtTFV3dnloMTg4SXUwbzF5OEVIMzM2bWRPU2prWENud3NBQUxCYTJEQkhHNkM4YWRNbXo1WmlzU2kyUFBiMXgveVRKMDhHYzNOekVVS01WbDZZYm4zQkFUTnFkOEJSenQxbWtaWkFQcUJFMmZDaVB4SUFBQUFBQUFBQUFBQmdsU0xBQ0FBQUFBQUFBQUFBWUIxNi8vdmYzeHYxbzdFZ0ZteFZTbTB4aS9yTU5LVzFGblNHY3BSMkhWZWkwYWprODNuVjM5K3Zjdm1jWTI0cngzRUVBSUJyVVRNSVpLNVVrMHFqMmVwVHczQ2dmRElhaGhkbHJtSU80S1pDV3FybTlkaWZXelBUU3NPWGRzeVZxdEx3QXdFQUFGak5YUGZDV0VXaFVKQkdvNkU4ejdOaDJIcDJkallNMUdFc3FXUHNZSkhkK051MTZNVVAzLy9oMndJM0tNM016Qnp2N3U3MlIwWkdXaitCQmdBQUFBQUFBQUFBQUpZSkFVWUFBQUFBQUFBQUFBRHJVTXlMZlkvMjlMQlM2bjNtcHFORngrenliLzR4ZDZ3MHovVjBOcHR0YnQyNjFibmxqYmQ0dVZ3dWtrZ2tCQUNBYTluVVlrVU9uNTZTdVhKTlduWERwbTRaN3M3S3pjTzljclhrRWxGNXo2MDc1YW16MC9MSWlURjVjV3BSVGs0dlNqdnNldlZtNk9zQkFNRHFac2NtYkRsNDU4SHdPOFZQUC8xMG8xNnY2OC8rNDJlOUlBakV6Sk82M0FsYW9rck1PSjZTZjJPbWpVQ0NkMnV0UDJQR2xqNWVxVlRtelNNV0JBQUFBQUFBQUFBQUFGZ2xDREFDQUFBQUFBQUFBQUJZQjBaR1JxTEZZakdTakNidmRCd25GZWpnVFVxcGdybkxGUzNoOVU1WWVjcFI0Y2Jmc0dGRFlDOEdIQmdZY0hwN2U1V2RkMTFYQUFDNDFqV0RRSmFxOVhEYXFwNTBRbnJUY1ZrT05zaG8zNFl1S1ZZYmJRY1luWnBaa3JyZitub0JBQUIwVWo2ZlY3N3ZxNzNYNzVWS3VTTFQwOU4rclZaVGk0dUxCQmwxaUJidG12R2x0Sm5kWWNiOWZpQVdpMDJac2NBcGMvdExabG9VQUFBQUFBQUFBQUFBb01NSU1BSUFBQUFBQUFBQUFGZ0hLcFZLSWhhTDVSM1grV2x6ODBZbGF0aE12WXQvcVIwZEVvMUVBNldVdk9HbU56UXptWXphdFd0WFJBQUF3RXVxRFYrbWkxVnB4KzcrdkF6M1pHVTVaQk14ZWZ2K0xUSlRxc2xYVDA1SU94NDdOU25EM1JrQkFBQllTelp0MmhSK3QzaGdZRUFXRmhhQ0o1NTRvamsxT2VVUVlOUlJqaGJkcndQOVZqUFdaOHVvQkRJcVRmbTM1cjRuQkFBQUFBQUFBQUFBQU9nd0Fvd0FBQUFBQUFBQUFBRFdzSkdSa1FOQk0zaXI0emxEWnJwUks3MWZ0UFNhdTdpb3JJTjZlM3Y5WEM0WDdOcTF5L01pbmd3UEQzdXU2d29BQUxoZ3FWcVhNN05GT2I5UWxuWU5GZEttcEdRNVpHSVIyVFBZSmNQZGFlbEp4NlZZYTRSaFM2MXErb0VjT1Q4citXUk1OdVNYNTdVQ0FBQXNoMGdrSXZsOFhoMDRjTUFyRm90cTI3WnQ4dUtMTHdZVEV4TkJxVlJ5Z3lBZ01udUZLVU1iWnJaSGk0NDdVZWVqWm14d1BHZ0VuOUtCbnYvSWIzemtZUUVBQUFBQUFBQUFBQUE2Z0FBakFBQUFBQUFBQUFDQU5Vd0ZxdDl4bkxmcVFHOFhKZHZOTkx5WVNkQlIyVncyNk8zckRYWmZ0MXRpc1ppS3grUHNFd0FBWHFacHpsbkdGc295WDY1SnUyd29VRDRSaytYZ3VZNXN5Q2VsTzVXUVREeDZNYnlvalFDamkrdHBFV0FFQUFEV0VodkViSW9hSEJ4MDYvVzZEV3VXeGFYRllIRnhVVmNxRlFtQ1FMRHlMbzc3cFczeGZmKzdiS2FSY3RRNU16NDRhcFlSWUFRQUFBQUFBQUFBQUlDT0lNQUlBQUFBQUFBQUFBQmdqUm41NE1pN3pLYzg4U0FJZnR6WC9vQlNhbEMwSk94OWhCZDFodXU2T3BQSitOdTJiWE5zNmVydWNoT0poR3VXc1Q4QUFGakRkdmJuNVowSHRzaWg1OC9KTStkbXBGVitFTWp4aWZsd2Z1K0dMZ0VBQUZpTFBNK1RkRG90dDl4eWkzUGd3QUU1YytaTXMxd3E2eTkvK2N2aDk1RHI5Ym9qNkFSSDZ6RE0vSWZOZk9YQkJ4OThwNW1lTXVOVS82MWFyVTUrN0dNZm14QUFBQUFBQUFBQUFBQmdCUkJnQkFBQUFBQUFBQUFBc01ab3BUZUtMd1dsMUQyaXhBYmt1UGJmQzdQb0JNZHhkRFFhMVlXdWd0NjRhYU1razBuSDNCWUFBTEMyWmVJUjJaQlBTZFJyNzVwOFA5Q3lWR3RJdmVrTEFBREFXbVhHUGNMUzA5TVRuaFRWYS9WbXFWVFNkcGtOMEVGbnZDeklmRWVnQTkrTURmWnEwYmtnQ0hKbVhHcEJBQUFBQUFBQUFBQUFnQlZDZ0JFQUFBQUFBQUFBQU1BcTk1R1BmR1NuNy92OVFSQ01LRkhYbTBVRGdvNkx4V0pCS3BYU2IzbkxXNXBtcXJaczNVSmlFUUFBSzJpaFVnL0xjaHJNcGVTbXpiM3krZWZPQ2dBQUFDNjROQVp5L2I3cnBWS3A2Qzk4NFF1MXFha3A1NFVYWHZBa0VOR2lTZGxlWVVvcFYreVlvWmFCd0EvdU03ZEhSeDRZR1EwaytLUVpWL3pTSTQ4OGN1N1FvVU5OQVFBQUFBQUFBQUFBQUpZQkFVWUFBQUFBQUFBQUFBQ3JqTlphZmVoREgxS0pSQ0pWcVZSU3Z1OFBtc1Y5U2l2WFhveWtoYjlzMzBteFdDemNBYmxjVGxLcGxFUWlFZVc2cmdBQWdKWFZESUt3TENmWFVSTDFuSEI2dVJ4MTRiSHhxQ3ZKbUNlZWVhNVNYTU1QQUFEV0x6T0dwV3k0Y3lhVGtXYTlxV3YxbXBqeExFNkFPc0NlZDVxeFJUdHJ2eU1lTitPSkJTZHdOdDU3NzcwbFU1b2pJeVB6QWdBQUFBQUFBQUFBQUZ4bEJCZ0JBQUFBQUFBQUFBQ3NNaC82MElkc0drNjZzbFM1VHh6NUpTMTZ0OWE2LytMZFhQelZJVXFVTnZ0RGR1emMwY2htcy9ydXUrK09KaElKczBSSUx3SUFvQVBHNTBzUzg1YTNHKzdMSmlTYmlFbytFYnZzNXlTam5rUmNSOTZ5WjZPWmo4aW1yb3gwcHkvLytRQUFBR3VKRFMreVl5VDFlbDNLNWJJY1BYbzBlTzdvYzgyeHNiR0lXY1k0Vmdlb0MrbVpHODJZNGtZem9IV0xFM0ZzSHZvZm1IOFd6ZkwzQ3dBQUFBQUFBQUFBQUhDVkVXQUVBQUFBQUFBQUFBQ3dpb3lNak53VUJFSEJjWnlkNHNnK0xicGZheDBYZEl6cnVqb1dpK211UXBma0NqbTFhZE1tTjUxT0I5Rm9WQUFBUUhzY3BTVHFPdUk1anJUcjNIeEp2R1VPTUhJdnZzNXZmWmwyV1R6aVNpRVZNL091Wk9MUmNENXVYazkvTmlreHo1RTlHN3JDSUtQaHJyVDBwaE1DQUFDd25wbXhMTEZqSlFOOUE5SnNOcDFNSmlQVmFsWE9uamtyOVVaZHpIaVhvQ09VR1ZzVVUzWTd5cW1hc2NjZk52dGl3dXl2cHl1VlN1MDNmL00zRndRQUFBQUFBQUFBQUFDNFFnUVlBUUFBQUFBQUFBQUFyQ0phNng4MGswMDYwTzgyVS92WDB0MExmelFkblJLUHgzVlBUMC96dWozWHVYdjI3SEhTNmJUckxYZGFBZ0FBNjV4alRtOVNzWWpFdlBiUGM1NDhPeTN6bFpvc3A2anA4bTN4bkgvZTlkdlhuay9HNU9iaFh1bE94V1c0Snl0N0JndXlJWmVTbmYyNU1OQUlBQURnV21MR1NzS3lkZnRXMXhRWkh4OFBBNHcrOVRlZkNuUlJTNjFXYXorNUVsZkN1VGkyK0JZdFdpU1FnMmIrYVZNK1lNYTRKc3lVQUNNQUFBQUFBQUFBQUFCY01RS01BQUFBQUFBQUFBQUFPdWo5NzM5L2R5d1dTMm10djllVWxHaTVVNG5LbXJzY2Mxc1JYdFFacnV2cWFEUXF1M2Z2VnVsMFduWDNkTHQ5dlgwcUhvK0w0M0M5SFlEVmFhbGFsMmFnNWNqNVdXbjZnWnlaSzBxdDZjdHNzUm91YjVobHI4UnpWQmkya295NmtrdkdwRGVkTkxjak10eWRrV1RNazBTa00xOHQ4TTFybmx3c1M2bmVrTkdaSmJOK0RTbldHaksxVkFublgwcytHWlZFMUF1RFpXejR6S2F1dENUTmV1enN6OHUxb05Kb2h0dm8rTVM4dEtNM25RanJRRjgyS2E2elBPY2lVYytUd1Z6UzdLdTR0TXZXajVqWnYzUGwya3YxZUxuczNWQ1F0K3paR05ZbHo1d0xiT3ZKU2p6aXltQStaWTRkVDNLSjJFdmJMYnFDT1lkMjNlZEtOUmxiS0VuVjdQZEpjM3pVR3I2Y25pMis3bk1Ua1F2aFROM3B1S1RONjdhdmY0TlpIeHZNbElsRnhIT1g1NXpIdGsvMjlWWHF6YllEcVBZTmRadHQzdnIrcnBwdGMzNitGTFlsdHMxc3g4MWIraVRleGo2ZVdxeklzY24yanNtK2JFSmNaZXBkYi9aVkgyUGIrMEJyT1R3NkZiYjN4ODN2Q3JkeCtkdlg4NWZlY2lEY3orMnlkYTFpdHVXcDZTVXBtemI2N095U1ZKdEJlRXphMTFCckJxLzYzRmVxZDVlT25TNnpMTmFobk5DRlNqM2NocmJkdE9zM3RsQyswTytZZW1LM3ArMUhYMG5NSENkSmM3elkxMi9YWnpDWER0ZHhSMzlPb3VhK2VJZjYwTUM4M3Bydnk0TFovN2JPaDMxbnJSNnVVek1JWkd5Ky9Mby9veTlyOTRjbm0yMGZhdHE1TGQxWnM0N1JjRjBCNEhLWThSUWJDaTIzM1hhYktwZkxjdnIwNmNBR0dvMk5qeWtKUklWaE91aUV1Qmw3SERiampqL1JiRFluUis0ZmVWNThPVnp4SzZPSlJLSTBNakxTRkFBQUFBQUFBQUFBQUtCRkJCZ0JBQUFBQUFBQUFBQjBVREtaN1BKOXYxKzAvQnNscXQ4c2VpbFpnZkNpem9sRUl0cnNHN254RFRlR0FVWTlQVDJkdVpJYUFGcGdBemxzT01lakw0eUg0UXVQbkJnTHd3cU9qeStFZ1RiMnZsY1NockRrVW1IWXo1YWVqT3daN0FwRFRHd1FnK01rT2hoZ0ZJUUJFalowNGVGajU4S0FGbnZiQmpUWjZXdXg0VXMySEdObmYwNHlzYWdjM0RFb1hhbjROUk5nWlBmMXRObHV0aTYwWTg5Z1FUYllPbUcyb2Vzc1R4Y1k4NXd3L0tlZEVKcExKcGVxRW5GZG1TL1h3bnE4bkFGRzlyaXcrU1VIdHcrRWdTUTNEZmZLYW1ERGkwNU9MOHJqbzVQaGRuam0vRXdZeFBMb2lkZmY5d1ViVkdTT2MzdGMyRENwdlJ1NjVSYXpYbHN1aGpNdFY0QlJ3eHpiOWpYUGxLcGhPRms3YkpCVU8zWEh0b1gyZDE5cVQ5cGh3NVBhQ1RDYVdDcTNmVXp1MjlBVmh2NjhWb0JSdmVtSElUdjJkNVJOZi9EM3o0ektUUEdWdC9HUDNuSGRGUVVZMmZBaVc5K2VQRE1sVStaMzJQNW1zV0xxMzduWk1Pekg5a2V2NXBYcTNhVTJ4L1k3blFvd3NxOC9QSGJNOXBzemRmUHc2YWtMOVdUK1FwQmUvVlZDbVM2Rk1ObDFzWDNuVFp0N3BXRDZHeHM2WmR1a1RtWDkrT1lOcHUwTHhoYkw0Ym9jTVcyRHJmUG53N0F6UHd5NmVqMzdocm9rYTQ2emc5c0h3M1cwWVVhRFpqa0JSZ0F1bHcwd3NtNjk3VlpWcTlXMEdXc0o1dWZuWlh4ODNOV08xamJFU05BSk5rRjBzK2txZnRKTXg4MWVlRDd3Z29hbnZJV1ptWm1xV1VhQUVRQUFBQUFBQUFBQUFGcEdnQkVBQUFBQUFBQUFBTUFLK3NWZi9NVllKcFBKUjUzb1hlTEluWDdEM3hWSU1LQkViUmQwakxMWHpEbWk5KzdaRzhUamNibmh4aHVjYUNRcStVSmVQSStQMUFDc1RqWWs0bEpRMFpHeE9mbkNzZk5oMkk4dFRYUGZVcTBodnRaU01WTWJ2UEpxYkNpRERXa0l3MFJtYlJES1ZCaGM4cWRmT3hhR0YvM0k3YnZEUUludnUybWJMTGRqRS9PeVZHM0lIei82bkl3dmx1VFU5SkxVemJvc2xHdG02a3ZOdk5aaXRmNjZQMmR5cVJ3R2Q1eVpMWXJucUhBYnhTS3UvTjlmUFNaOW1ZUzhaYy9HTUR4ajF6b05OUHFkeno1aHRrRkZQbmYwYkV2UHMwRWNtVmhFdG5TbncvQ242QW9FaWRnZ2pGM21kMDB1Vm1TKzh2cjc5bHZaSUk1UGZ2RloyZGFUbForNjYzcFpMcmNNOTRWaEhvVXJDSDI1R3V4eC82aXB6eTlPTDhwRFp2L2E0MzI2V0FtUG0wdkhmVE1JTHV0bkxabGpxVnh2eXFKNWJzSWNINCtjR0pmL21ZeUdvVkIzNzlvZ3ZlWlllY2YrNFhDZCs3Tkp1VnA4MHlBZE44ZjZjK056OHZkUGowbzc3T3ZiM0pXUlZwWHJqZkIzZi9uRmNmbHltMkZDUDNqempyYkNrMTZjV3BSUGZ1RlphY2RQSE53VDdnZmJkbjJyeDA1TnlvbkpCZm5za1RNeXNWZ08yOUdHYndPRzZtRzdlVFhZZldhMzNhVjZkL1Q4Yk5qdnpGZHEwakR0OHB4cG95LzFOMXEvOXM5NnBYcG4yd0hQY2VTR1RUMlNOM1h3cCs2OFhselRkbS92eThseXFUWDlNUFRwYjU4YURmdkFmM3ptdE15V3ErRjJ1M1FzMVM4K3huK05kYXFhZGJuVWh4NmZuSCtwRC8zTHgxK1FaTXlUZDVuNll2dWQrMTVoMzExdFU4VUwvZitmZnUxNDJDNDhjbndzM05ZbFUyemZhZHNHMjQ4R2diNnNuMmY3WUxzdVoyYUtwbDF3NU0rK2Zqd01DTFJoaHplYk5uRkhYMTZ1MzFBSVE5MEE0UFc0cnF2MjdkL25Oa3gvc212M0xqbDE2cFIvNnVRcGYzNSszaXVWU29SR2QwNWVpNzVCdEx6UGRkeGY2TXAzZmZHQkR6NHcvZUdQZnZpM0JBQUFBQUFBQUFBQUFHZ0IzeDRBQUFBQUFBQUFBQUJZUWJGWXpGTkt4UU1uR0hMRXVWR0wzcTFFRFFnNnl4RnRRNHk2dXJxMERURGF2SG16RWdCWTVRS3RwUmxvT1ROWERBTTVEbzlPeXRoQ1dWcGxmNDROZ2JIRm1scXFodE94K1ZJWVdIRFA3cUcyd2pyYVlVTlk1c3MxK2RySmlUQ0l3NjViT3lwMXV5NitGR3VOOExiZExqYUVZYUZjbDAxZGFkbTdvVXNHY3lsWnIyeDlzTUUySjZjWFczcGVQaGtMUTFKY3g1Rk1mR1gyZWNSekpHMStsdzJjYWtlbDJaU1RVNHNTanl6dmRlOTkyWVNzQmpaTVpjcHNLeHRTWTQ4VEd4eGpqNWwyMlBhakdmaGhrTXY4dDl6WG00N0xmRDRsMWVzMmhpRm5WNU1OdzdIaE1QWVliN1dPWG1KRFl6cjF1OXRsOTFPN3Y5T0d6OWcyN0pYWXNETGJWajV4WmlvTWJadHJzejY4bGtBdTlEYzJJTWUyTDArZG5aSERwNmVrSGE5Vjc2eENLaGEyM1ZIUGtlWDBVaDg2dXhUdUYzczhMVjNzTTFweGFYMit0UStkTkhYTXRxbTNiVnU1dDNyMnVHaGVEQWdibXkvTG8yMkdkRjF5cVE5OWVSdGo2OWVpcVk5RCtiVDBwRmRIdXdoZ2JiRGgwTGxjVGdWQklPbE1Xb3JGb3A2Y21Bd1dGeGN2TDFVTnl5VitzWVNwZ1diTWN0YVVLK3RBQUFBQUFBQUFBQUFBY0UwaXdBZ0FBQUFBQUFBQUFHQUZmT3o5SCt1dVIrcnYwMXB2RlNXM20ybEtLMjJURS9pOHBvTnl1Vnl6VUNnMEQ5eHdJTEp4NDBZbm04MjZTcEZkQkdCMVc2cldaWFJtU1I0OU1TNi9mK2hwbVMxWFphblNrSnJ2eTlWVXFqZkZ0b2dmLy9SaFNVUmNlZVRFbU55eXBVOSs5STdySkdadXg3MnJGeGp6dWFObjVYUFBuWlYvZUdaVUpoWXJNbE9zeU5YVzlJTXdxTUtXWjgvTnl0NmhnbHkvb1V0KzhPWWRjc09tWHNuRUkrS3M4VDdnNGVmUFNkbnN0NzgzMjdFZDkxMjNVWDdnNXUxeXc4WmVXU205NllRYzNENGc1VnBEWmtxdEI2K1VheGZXOThUa2d1enV2N0JQOXcxMXkzcjB3Yi82U2hqeTlUOGVQeTYxdWkrVlJsT0NaYnJrLzdOSHowak1kZVZMeDhha0t4MlRuMy96ZmhuSXB1U2UzUnNFbmRVSWdyRGVIemsvSzMvMzFDazVkT3ljUEQ4K0wzVWJSTmU4dXYyQTljeTVHVGsydmlELzdjdEhaWHloSkNjbUZxNTZmM1BKVTJlbnhUUDE3bC84cDcrVHJsUmMzditPbTJWelYwYnUySDcxUW9Cc0dNL1p1YUw4NWVFWDVhOE92eURUeGFxVVRQdlRUbmpSYTdISHFpMjJEN1hCY0xaL2Uvdit6ZkwyZlZza0VmVWs2bDY5Z0taSFh4Z0xBL3ArNjlQZk1PMW9KUXl5V2k2MkQ3V2hnSStQVGtuTW5BZjg0bjM3SlorTXk3Kys1M29CZ012aE9JNE45NWJycjcvZTI3bHpwemN6UFNOTFMwdnloUzkrd1MrWHkxSmNLaTV2S2lWZWtSa0xVMmFzVWdjU2ZJZG9xVC80d0lOdk5EZG5ITmY1RCtidXN5TWpJMDhJQUFBQUFBQUFBQUFBOEJyNFFqd0FBQUFBQUFBQUFNQXllZTk3MzJzRGlpU2RUbmMzL2FhOWtuNkxLTmxzcGh0TlVSY0xWcGh5bEk1R29pb1NpVWcybTVWOFBpOWRYVjAyekVoRm8xRWh3QWpBYXRZTXRDeFdHMkU0UVZqbWlsS3VONlRoWC8wVUU2MjEySjlxd3g2cUVWZEdaeFpsTUplVWljV3lkS1ZpRWs4bjVFcVZHMDJwMUp0eWZxRWtwMmFXWkdxcEV2Nzg1ZEs4bVBZeVU2cksrSHhaMHRHSTJZWWw2Y3NtSlJYTGhmZXR4UkNqUy92SzFnY2JQR1hEVFZwaEE2bHNFRVZ2Smk1RCtiUmtFaEZaS1VtekQ3cFNDVWxFMnY4S2kxMWZ1MDlQenk3SmhseEthazFmWE1jUnoxa2ZmYnBkTjhzZUkwVnovRTh2VldXNTFadEJXTTdPRjZYU2JJYS8yemZIVDhsc2F4dThFdkd1WHZnS1dtUGJ6S2xpNWFWMmMzeWhITGJUVjF1Z0w3U1h0cSt4djg4ZVh3dm05MXp0b0orWHMyMTBNMmpLMkVJenJIOTIvZUttYmJCQlFGRlQ1MkpYR0p4bmY3N2RWaS92UTIxNFVYTVprc0F1YlQvNyszdy9DUHZRYzZhL3NYMWNiem91MFZSY3JwUnQ2K3gyT2o5Zk12MW5WYzZaNDlXMkZ5dXhqNnFOQy8yTTNVZUZTbDBXS2pYVGwzaFhOZHdRd1BwbHgxM00rRXM0QmxPdjE4VTFiWWNkbTdIak5IN3p3aHViU3JXaVpKbUNHdkhLMUlVQnNaZ1pyWXlKSGNNVXlmaSt2OFV1SHhrWm1heFVLcVd2ZnZXcnBYdnZ2VGN3dHdNQkFBQUFBQUFBQUFBQVhvWUFJd0FBQUFBQUFBQUFnR1dTVENadk5aTStIZWovNGl2Zlh1V2R2WFFmSVRtZFljT0wwdW0wMzl2YnErNisrMjQzbjg5N3RnZ0FyQkZuWnBmazhkRkorZmsvZVRnTUxpalhXd3VxYVZlMTRjc2pKOGJseGFsRmVlTE10UHpJN2J2RGNxV2VQRDB0Zi96bDUrVHc2SlFjUGowbEsrbjQ1RUpZam96TlNYYzZMdi85Sjc5RCtyTkpLU1Jqc3RiWUlDZ2JZdkhibi9tR25Kc3ZTYXY2TWdsNXp4dDN5bHYyYkpTRE93WmtKVzNJcCtRZCs0ZmxzZEVKK1lhcFcrMGFNK3Y5VzUvK1JsZ3ZVN0dJREhkbnd2MjZIdnp4bzgvSnNZbDUrZk92SDVlVlZxdzF3dkxCdi9xSzdCMHNTTlJ6dytuZURWMkN6amc3VzVTUC9PM1h3K0NZeDA1TnluS3hvVUUyaE9mSC91aWZwT0VIWVQxWVNUYUl4OWE3MjdjUGhPRjJOMjN1bFp1R2U2VmRUYk1PTnJEbzc1NDZLUi8rMUdOU2FUVER2bTBsMkVBaDI0ZWVueS9MWjQrY2tmL3pPOThnYjkyN1NhN1VzK2Rtdzc3emR6NzdSTmhHZE1JZmZ2RklPQzJrNHJLcGtKYjMzTHBUQUtBVk5sRGFsaC8rNFI4T0U5QWVmL3p4ZXJsY1ZvYytmeWhpUXpxRGdKeWNEc21hc2N1c0V2VjdabjdXakcyZWprVmlmM2J3NE1FL0t4YUw5cVM5OVRjZEFBQUFBQUFBQUFBQVdOZjRNallBQUFBQUFBQUFBTUJWTWpJeTRzek16RVM2dTd2N3pjMCszL2YzTzQ3VExUcjhUTVlSZE1iRnJLaE1PcU5qc1pqdTYrOVQrWHhlNHZHNGVCNGZsd0ZZVzQ2TXpjcXA2Y1V3VE1MdndNVzhUVi9MWEtrbUU0dGxPVDI3SkgzWnBNUTlWOXB4Y21wQlJtY1d3K0NacFdwZE9zVUdRZG5mYjhOQUZpcDF1VzFydjZ3MU04V3FqQzJVdzVBTVd6ZGFFWSs0a29sSFpWTlhXcktKcUt3MDExR1Nqa2NrRlkyRXI4VUdNZG5RbEZiWlo5aDF0L1hwcWJNWGdwQWNwU1JqMXNsejFtWndwSzJQQzVXYW5Kc3ZodXZWYVRZd3pZYWtkS2Rpc3EwM0o1NnJ6TGJsRkhjbDJYYno5T3hpR09pelVLN0pjckx0c3cweEN2dWJObzdKcStWU3ZSdk1KYzNyeVVuU3RCVnVtOGUwN1VOZm5Gb0sxeWtJVm42ZHFvM21WZWxEbSthMUw1bjI0YXhwRyt5Mldha3d3OWZ5b3FtYk5tVEV0bFUyNkd5OUJNZ0JXSG1aVEVhWnNScTFhZk1tYVRRYWVuNXVYdGZyZFdYbVNRTHZFSzIxcTVSS203SXQ0a1Z1Y3dKbnpJeUJ6aFdMeFpPZitNUW5DRElDQUFBQUFBQUFBQUJBaUc5a0F3QUFBQUFBQUFBQVhDWEZZakdSeldaN3RLOS9TWlRjNXlobmgyaEpDenJLN0FkUlNzbXR0OTNhdE1GRisvZnZqd2dBckZFZi90VFh3N0NkWXEwaG5UQlZySVNsa0lxSnpYNTQ5eHQzeU9hdWpMUnFybHlUVDM3eGlEeHpia2IrNFpuVDBrbmpDMlZUUlA3ejU1OEtRM1QrOUdmZUptdk4zejExU3I1dzdIeTRiOHExeXcreThGeEhCbk1wMlROUWtQZmN1aXNNRUZwcCtXUXNMSnNLNmZDMWpDMlVwTnJ3cFZXK3FaRDJ1UGpicDAvSlE4K2RsWis5ZDUvY3MydElEdTRZRU05Wm0xK1BlZVRFbUR4N2ZsYis1b2xUY25KNlVUcnQ3RnhSL3VObm41RGlYWHRsUzA5V2V0SUp5Y1FKTUZwSnR0MjB3VGNQbStOOXVmMzJQejRSQnUxMHFyKzU1S2t6MDJHeGZaOXRJM2IyNThMUXRWYlo5dEgyb1Rid3JWUHJaSVBtYkxGdHRwMyt6TjNYdHhWZ05MbFlrYU5qcy9KWGgxK1VQL25LODdJYS9LR3BtenY3ODlKdDJvV2RmWG01Wi9jR0FZQjI3TnExSzZLMWx0MjdkOHU1YytmOHA1NThxakUrUHU1TlRFd3dsdE1oWmt3dFp5WTVMWHE3R2ZQOGFlV3B3Mlo2eGl6NzE2WVFZQVFBQUFBQUFBQUFBSUFRQVVZQUFBQUFBQUFBQUFCWGFHUmtwQ2NJZ251MHIvdVZxM1lvVWJkcjBRUG1ydGF2ck1WVmswcWxnblE2N1cvYXRNbExKQk5xeS9BV0p4YVBDUUNzUlRib3A5NE1aR3krSkxWbTYrRXVWOXVMVXpaTTVZeThhZnRBR0NTUlMwVEZVZXF5bnp0ZHJJVGhMRk5MRlZrdFRrd3VTTVIxNVBEb2xLVGpFZG5WbjVmVnpvYjlqTTJYNWVsenMzSmtiRllhcG82MHdnWVd2V1hQUnRuZW13dm5JMDdud21oMm1PMTljTWVnZlBiSWFhazIycThYVFY5TFJacnlwV1BuNWN4c1VScCtZT3BvSlB6WmE0VU5ZNnI3dmp3L1BoY2VKNHVWdXF3R05yU3MwbWlHWVVyMmRkMFJIdjg1d2ZJYm5TdktiTGttUjg3UHlzSXkxNGZSbVVXWktkYkNObkUxdGRHMjNqMTA5SXowWk9JdEJ4alpkbjNTckl2dFE4djF5dzk1V3k0Mm1Nd0crZjF2TjI0MXg1V1dRcksxOXlqblRIMzQyNmRPeWJHSmVWbE41czA2Mlgxa1EraHUzZFlYOWlrMktBOEEydUY1bmhRS0JYZlAzajI2cjcvUG5adWRrOUhSVWI5VUtrbWxXbkYwb0MvdnpRZXVHbVZvbXk2bHhLYlVwZExKOUw5OTRJRUhTc3BYRDZsQUxZNzh4c2dSQVFBQUFBQUFBQUFBd0RXTEFDTUFBQUFBQUFBQUFJQXIxR3cyZXozSCt3SHQ2cTFhNjlzQ0NjS0xlZ1FkWmNPTEJnWUdtamZmY3JOakwzcUx4V0l1dXdYQVdtWEREcGFxRFJsYktNdHFZSU1rYlBueE4rMlJEZmxVR0NiaFhHWVRhNTgzc1ZpV1IxOFlsOVhrK01SQ09EMThla29HYzhtMUVXQTBYdzVmNzlOblorVEkrVGxwVlNMaXlWdjJiSkxlZER5Yzc2U2RmUmUyOTlkT1RwajZjUVVCUmtFZ05zZnBpeWZHd3JMQjdNdDhLcjZtQW96c090Z0FrT2ZHNXVSUnN3NUwxZFVTWUtURDEyVkR5R3lBa1EyK3NnWEw3K3pza3NUTk1ib1M3ZWFwNmFJY241eVhGeVlYWktaVWxkWGlRbkRlV1huYnZzMnl1U3ZUMG5OdE96bFRySzZhUHZTb09iWnRtVFJ0blEzT2F6WEE2SXlwRDMvMzFLa3dCR2sxbVRQMTVhR2paeVViajRWdGhVU0VBQ01BYmJGak56YkFxS3VyUzVrU0tSYUxZa3VwVkFvTVhhMVdIUzFhc1BJdWpuZmFFK3RCcmZRdmk5MFJqcFJFbVU1YWhBQWpBQUFBQUFBQUFBQ0FheGdCUmdBQUFBQUFBQUFBQUczNDBQMGZ1aWZRUVV3NytsMUtxWlFOTGxKaXBxSUpMK29RNVNpZFNxYjh2cjQrTlR3ODdPWUxlYTlRS0toTUp1TkVJaEVCZ0xYc29hTm5aTHE0ZW9Ja0xyRWhKak9sU2hoazVNVXVyNjM5aDZkUHlmd1ZoQzVFWFNjTVJMaDkyNEJFUFVmUzV2YzJBeHVzMHBUcHBZcWNtbG1TWXExeElUeWhEWDl2WHQ4Tm0zcmtuUWUyeUdwVmIvcXlVSzNMMTA5TnlGOGRmakVNaFdyVkRadTZ3L0NwVzdiMG1tM3FTcWZ0R3NpWjE1T1V2M2o4aE15V3FsZXR2bi9xcVZOaE9GTmZOaUdEMlpRYzNERVExcCtZMS9sMWZqVTJaT1dKMDlOeWFuWkpTcVl1QjZ2cytueDdqTmxBdFR1MkQ4aU8vcHgwcCtMaWNQcTdySjRmWDVDSXV6TGIrSmx6TS9MUWMyZWsybXhLTzVKUlYvb3k1bmpMcDJYSXRERTEwMTQxL0VDZVBEc2pEVFBmN3JFOVZheUU3YndOTXJJQk9adTYwdUplWm5LZWJkZnRzYlRhMk8zY2s0N0xMN3o1d0dVOTNtN0hKMDVQeWZNVDgrSDJxTGZaenkwWDN6UldkanMvUHo0cmYvSFlDYmw1dUZkdUd1NFRBTGhTc1ZoTVhITysrcWFEYjNKTHhaS2NPSEhDcjFhcjh2enp6enRCRUNqZjl6a1I2UXp2NGhEb0Q1bngwTVVIUHZqQXJWcnBKNXJONW1jR0J3ZUx2L1JMdjdTNmt2WUFBQUFBQUFBQUFBQ3dyQWd3QWdBQUFBQUFBQUFBYUlNV3ZWMlVaTTNzajJpdEhTVXFkakc4U05BWlpoL1lpOXFDcnE0dVovZDF1eVdkVGl0VCtEd013THB3ZkdKQnpzMlhaTFU1TTdza3pTQ1FhdE9YMUdVR0dEMXpmbFlxamZhQ01heEw0VE83K3ZPU2lVZWtrSXFIb1E3RmFsMU96U3pLVEtsMk1ieW92V0NIWjg3TlNqSzZ1b1B2YktCTnNkcVEwWmtsT1h4NlNrcjExb001YkhqUmx1NXNXRmFEd1Z4S0pDZlNrMDZZL1JxOWFnRkdSOGZtd3VsWFhoaVhyVDFaZWVQV0MyRWFxem5BeU5ibDQ1UHpZZEJYM2RUdDFjWUdUTmt5dFZRSjYyRWhhUU9NQk10b3VsaVJsV0xiZGRzTzF0b014M0dWSTEzbU9ON2VtNU85RzdyQ1FCc2J1blptdGlSbDAxYTFlMnpidW1hTHJYZTIvdG5BTTllNXZPUFlyazl6RlI1THh5Y1haSHloZk5tUHQ5dHhkTFlvNXhkSzRiWlliV3pXbW0yekpwZXFZZDgwYVBxWm13UUFycHdOcGJabDA2Wk5qcjNkYURiOGhZVUZmZUxFQ2NlTXcya0NqRHBFdi9RZDlGdE5xVGlPczFVcm5UTFRSMDZmUG0wN2ZBS01BQUFBQUFBQUFBQUFyaUY4WVJzQUFBQUFBQUFBQU9BeS9NcXYvRW9tRW9sa1BjZjdlYVhVUWJQb09sTWlvaVVlUG9CTHBUb2lHbzBHTmpUcXpqdnY5R094bU96WnV5ZGlsb25uZWVJNGpnREFXdmZrbVdrNVAxK1NGNllXd3RDR1Z1V1RNYmwrUTBIZWZOMUd1ZSs2VGRLZGpra3k4czF3bmtkZkdKTWo1MmZsdnp6OGpOU2JRY3ZCUWw5K2NVSVNFVmMrOEk2YnBUc1ZmODNIVGl5V3cvQ0ZSMDZNU3p2Nk1uSHB5eWJsWisvWkwyL2FNU2lEdWFTNHB2OTFMaWFuQklHV1JoQ1kzNkhsejc5K1hMNXhla3IrNmNqcE1OQ29GVGE4SXhIMXdwK3h1U3NqZDJ3ZmtOWG0yTVNjL09ZL0hKWm54K1prb1ZJUFF5TXVWem9XRWRkc3MzLzMxamZJNXU2MHJEWS9lODgrK2Q0YnQ4cS8vT1EveXRYMDUxODdMdWw0Ukw1MFlremV1S1ZQZnZ4TjEwbFhLaUdwMk9yNzZzeXBtU1g1czY4ZWszUHpSV2xITmhHVjk3eHhoMnd5OWZjZCs0Y2w2cmtTOTc2NW51T0xKV240V243cFR4K1dwWXRCV08ydzdWTWk0c20vdkgyMzVNenZ4Tm8yYWRyb1NkUFB2REM5ZURHY3JwV1dSY0xqNjUzN3Q4aXUvcHo4OUYzWFM4VFV1NGhwcExYNU1kcjg4Nk52MmkwMlErZzMvdjV4R1RmOTJzUEh6MHM3dnZ6Q3VPbFBLckt0SnhQVzdkZGkrN2lGY2oxY24zWnM2a3FiZmlBdDc3cDVoOXl3cVRmc2Q3eUw3ekhteTFVNVl0cmdyNSthbFAvdmw1K1RxdWsvYTgzV1FwSys4UHc1Y1ZvSXdMWGhmSStZTnV6NCtMeTBxeStUbEdqRWtWOTUyMDJTTk8zZlBUdUh2dTB4WDM1eFBBeFErN092SDVOcFV5ZU9UU3hJSzBabkYwMmJXd3JEelc3WTJDMzlwdStPcnVMUU9BQnJ6KzdkdXozYnQ1aXB6TS9QQjBlT0hLbVBuUjl6eDhmSGFXdzZSVWxDaXg3V2dmNGgxM0cvSjUxSUh4OTVZR1JLSFBuZ3lNaklDUUVBQUFBQUFBQUFBTUM2UjRBUkFBQUFBQUFBQUFEQVpWQksyU3RWUFhFa0wxbzJhdEhkOXJaU0pCZDFtdDBIeVZSU1I2TlJsY2xrMkNFQTFwVzZIMGlwM2d5REpGb05rN2drSHZHa0t4V1hqWVdVOUtRVGtvbC9NOERJQmlQTkZLdGhnRUk3WFpvTkpMSVhEMStPUUY5WWgycUxJVW1YdUk0VEJpQVVVckZ3WFd4Z3lxc0ZQL1NrNCtGNnRoT1lZRjlqdzJ4M0creFNiekdNWWlYTmxLcFNyalhDN2RvcXU5MXNYZWhPSldTMXNlRlJyeGVHMVk0bHM2MHNHNlMxVksySCs3bWRiYmNTNmcwL2ZMMjFLNmgvdVVRc1BFWnNpRkU4NG9aQlE1ZTR6b1Y2Ym8rUHFPZEx1eG9YMnllc0Q3NnBFN2JOYS9oKzIvMk5iWGZUOGFnTTVsUGZkcDhORjdYSG5IMU1NZDUrNEZYZHZMNXl2WEZaajIwMHY5bUh0c09HRmIyOEQ3WEhrM2N4TkcrdUhBMEQ4dXo2WE9oRFcrOUV5K2ExT1MwK3ovYWhUYi85dHNIbUwwWE1QNzJaaENSTmU3dWxKL050anhtZFdaU0k2MXhzSTFydlIyMDlzaVY4cldiYis2dTByUVd3ZHRueEgvc2V4SXdCU1JBRUtoNlBhOC96YUd3Nno1NXc1bTNSU3BkTTcraEtYVlpmWWlvQUFBQUFBQUFBQUFDV0JRRkdBQUFBQUFBQUFBQUFyMkhrQXlNSHpDY3FIOWVpdDJ0dGlyMzRWUWtoT1IyMmZjZjJSbDlmWDNEampUZEdjcm1jRTQ5ZndWWFFBTENLSFRrL0sxOTVjVnlxTFlhRWVLNGptd3BwdVdsenIveit2N3IzMndKTUxubkxubzF5MDNDdjdOM1FKWjg5Y2taKyt4Ky9JYTBvWGd5RitkdW5SbVc0T3lQdjJELzhxbzk5K1BuemNtYXVLTzE2MTgwNzVCZmZjdURiUXBoZThiRzNiSmZ2dlhHcm5Ka3RTclV4SVF1VmVrdGhOZlBscWp4MDlFd1k1SEhQN2cyeVd0ajErSU12UENzdlRpMlkxM2RXMnZIVGQxOHZ1L3J6NGY1NnZlM1lDVGViK21oOTdQdnZrTGx5VFg3cjA0ZmxhckdoUUlkSHArU1pzelB5M3g1NVRuNzIzbjF5ejY2aDhEaXh3VmlkVm0zNE1yWlFrcFBUaTJGcHg5djNiNVl0M2Rsdys3MGFHOEppZmZyZmZxODhQam9wUC84bkQ0ZWhUdFBGcXJUaTY2Y201VVh6T24vazlsMWhXQkk2WTg5Z1FUYmtVeGZyOFlYd0w5dmVMWmpqeHdhZGpjNHNoZlZxYlA2YjRWMnY1TWpZYk5pdWpFNHZTYXMyZHFWbGk2bFh2LzhqOTc3cVl5N1ZFVnMzdi9yaWhEejZ3cGpVbW40WTR0T0toNCtkRC91elg3anZRSmlROEZvT241NlNZeFB6MGlyYlp3N21VdkpUZCswTjIwd2I5QlA3bGlDZlFqSVc5cUY3QnJ2Q2R1UlB2dko4V0ZwaDIzVHJMeDUvUVhyVGNkUGZETDNtNDIwZ2tOMUhkaisyNnRJNi9NNjc3elR0Yko5czdjbSs2bU12dlk1MzNidzlESDM3c1QvNnA3QTl0dTFuSzJ6NzhrblRaOW50dUswM0p3QndOZG5nT0RNV1pJdnp0cmU5TFZhdFZzV1dyM3psSzgwWFgzaFJUMDlQZXpiY1NMQ2kxRGNUL2E0elk2blhhVmMvOXVBREQ1cFplWjhaVGwwYytjaklId2tBQUFBQUFBQUFBQURXSlFLTUFBQUFBQUFBQUFBQXZzWDczLy8rM3FnZmpRV3hZSHVnZ20xS1ZFRnJuUkIwakwzK3lYVmRIWTFHcGF1clN3ME1ES2hDb2FBaWtZaHlIRWNBWUwyeVlRVnpwWm8wZ3NzUDM3bGtNSmNNdzM0OFI0bWpYdjNhM1locFIvUEptT1FUVWNuRUlsTHpmYWszQTJsRnVkNlE0dXNFS2l6VjZtWmRXZ3RJc1Z6eitwTVJUMUxSU0JncUVYRmYvenBrUjFTNDNqM3BlTGdkS2cwLzNKYVhxK25yY0x0ZkNtaGFEZXcrc1FFM3AyZVhaSEtwSXExS21HMFhNOXV4UDVzSXQwbk1XOTM5cHczZ1NwdjZhRjlydmVuTGpOa2ZWNHU5Z3JyaEJ6STJYNUtuenM2WStoK1YzbHBDK3JKSmlYOUxTTWxLc29GWnR0NHRYVUc5czZFcnJ4Vk04bkwyR0xHaEpuWWJSODE2dHhwZ1pNTm5iSkNLMzBiN2hQWkZYQ2Vzcy9HSUYrN3ZYZjA1NmMwa1pHdHYxclRoRjBLQ2JJQlJsMm5YdTFLeE1EaG9xSkNTbWFXcWpDMld3N1l3RmZ2MnI0elpkdEtHMUZTYXJRVUtXZjJacEd6cVNsL1dZMTllNzVhcURkTi90QlpzZDZGL2FvYlRaaENZbi9mcWJabXRuM050dEIzMmVMQ3Z6MjQ3KzNyZDEreERWZGlINWk3Mm9XV3pmVnM5SnV6cmZLVjk4a29xNXVmWC9kYjZhQ3RsdHJrTmFrdkZMdlNscmJBaFdXTUw1VEJVc2VrSHJ4cUM5YTFLOWFaTW1mNnE0ZE5HQUZoK2Rtekk4enpKWlhOcWFHaElITk5mK3FiUm1wNmVEanNLcldtTE9zR081NWx0Yi81VjI4MDUrT0tIUC96aE94cU5ScmxlcjU4cWw4dlYzL3U5Mzd0Nkova0FBQUFBQUFBQUFBRG9LQUtNQUFBQUFBQUFBQUFBdmtYTWkzMlA5dlN3bzV3UDJJdHNKTHhtbFQvYTNrbWU1d1dGUXNIZnZuMjd1dTMyMjd4a011blpNQ01BV085T1RpM0s0ZE5UMHZUOWxwNW5ReFMrKzRhdFlRaE1KdjdhN1dVNkhwR2JoM3RsYktFb093ZnlNanE5S0RQTjFxNGpmZEc4enVCMUFnMk9UOHlIWVRHdHN1RkY5blZ0N2ttSFlSMlhJeEc5OEhXSWd6c0daVU0rSmYvMUM4OUt0WVZNR0JzbVliZjdydjY4ckJZVGl5VTVNMXVVUC8vYThUQjhwMVZiZXJMaHRuanIzazF5WUdPUHJIYnZ1WFduekJTcnBzNU15L0h4ZVhuNCtIbTVXbXlZUnNOdnlIOTc5TG53OWsvZHRWZTI5ZWJrWis2K3ZxTUJSc1ZxTTZ4M2RqKzM2MS9kZnAwTWQyY3U2N0cyYmRobzJnamJWaHdlblpUbngrZWtGZU1MWlZNdUJINWg1ZGp3b250MkRjbE5tM3ZsWGJmc0NJUHFNcVlkdnh3UFAzOU9wc3h4bFl4KysrUEhGa3BoL1p0dkkvRG4rMjdhSnNOZGwxL3ZOaFZTOHM0RFcrU1pjek55WnE2MStqNTdNUWh2cVZvekpTcUZaT3hWSDN0c1lpRmNwMWIxcE9MaGNiRnZxUHQxKzlEZWJDSXNoMDlQaG4zVk1kTmV0UnArWi92SDVtVzA2emJNMEI1MzdkaXpvU3ZzMDdhYnR1NXkrMUxMaG1NOThEMjN5dU9talRnOE9oV0dYTTJYTDYrT2pNNHN5V0tsYnRyWTZ3VUFscHNkSTdMbGpqZmRFWjdNSFh2K1dMM1JhT2hQZmVwVGtTQUlwRjZ2azM3ZEdaZkdWUCtOR1dQMS9hYi9rMmIrVUNLUitFK21uRGJ6cHdVQUFBQUFBQUFBQUFEckFnRkdBQUFBQUFBQUFBRGdtdmZlOTc0M2xVNm5VMHFwTjJxdFU3N3ZIMVNpQ3FLRjFLSU9VbzdOamxLeWFkTW1QeDZQcS82QmZ0WGYxKy9ZQzlJY2grdk9BS3h2OWFZdnRXWWdpN1ZHR0tZVHRKZ1BFbkVkR2U1S1MzYzZmdG5Qc1lFV05vQmlhckVpTXkwR1dDellRSVBrYTRjOFRDNVY1Zng4NjhFTHlaZ1h2cTU4SXRieWMxTlJMd3hvY3B6V3VuUzd2V3RtSDVRYlRiUDlHNUtJdXVKMXVPOTU4c3kwak00V3c5Y1Y2TXV2RUk1UzVyVXJ1VzZnSUh1SHVpUVJXVHRmRmJGQlZMZHZINUIwTENMbkY4cGhjTW5NeGZDU3Erbm8yR3dZeVBHVkY3dWxMNU9VdlJzSzRqcHF4ZmU1M2E5Mi96YmJDS2hLbW0xbDYzbktIQy9KMk9XSE1NVThUN3BTY2JPTjJ3K0duQ3BXSk9xNXNpR2ZGQ3l2blgxNTJXemE5cnQzYlpCdFBibXdmWXU0bDkrKzJSQXpXMWVpM2pmcnRnMmZhd1NCRkUxZk0yUDJwYTJEcmVveGZZME51cmxjMFV2MUx0NSt2WnN2MTgyNlZGNHh3S2hxMm00YlZHYmJiOXVIdHVwQ3Y1TnVxZCt4ajdWOTFjbnBSZE9CU0V0bVNwWFgzWDUydnpUODF2Zk5KZkhJeGY2d3hXQmUrK2lvT2Fmb3p5YkQ5dmpwc3pPWEhXQmt6MlhzOXA4clY4TzZsVS9HdzdZVkFGWkNOcHRWWm54UDdkKy9YOHJsc2t4T1R2cTFXazB0TGk0eW9OUWhadHhWbVhIWGhKbHNOamUveTVUVEl5TWpwODErZWJ6UmFKVE4yR3pGM0c3OVJCZ0FBQUFBQUFBQUFBQ3JBZ0ZHQUFBQUFBQUFBQURnbXBkT3A3dk5aTFB2Kzcrc1JGMXZTcTlTNnZLdi9NYXlpRWFpZ2YwcjdiZmVlbXN6bFVxcExWdTN0SCtGTXdDc01hVjZNd3dJc0JmOFR4ZGJEMnl4QVVadjNOb3Y4Y2psZDJkOW1VVDRuTkhaSlRrelY1UlduSjB2aXV1KzlyWEFaOHpQdFVFeHJVcEZJK0hyc3NFYnJjb2xZOUxYOE1XVlZnT010SlROUGxpcU5NejJyMGhQT2lHWmVHZXZkZjZmajc4Z3AyWVd3OWZWQ2k4TXRZbklYVHMzeUhmZnNFVUdjbXNuWk1ZR3JmellIZGZKbDE4WWwyS3RJWWRIcDVZbHdPaVJFK1BoMU5iaHpZVzB2Tys3YmdxM1d5YStzcWNldmc3Qy9WdHZJNlFrbTRpRzRWUjkyYVIwcDFvSmtuRmtTM2RHamsvTVM3dnNjeGNyZFFLTVZzQTl1emZJenY2OC9OeTkrNlVkOXJuZnlwY0w3ZDNVVWxWR1oxcHIreS9aM1YrUVlWT1BMbGRZNzNxeVlYL1Ryck9tbjJyNGdlem8rL1oxc3NGRnRzMllick1QVFY3c2QvTEp5dzh3c24yVWZjNFRaNlpscnNVUVFMdmRjNjhUbG1UM1VhWGVmb0JSTmg0SkE5cGVIbDUxT2V6N01kdUhiRFJ0bzIyUC8rUXJ6OHN6NTJZdTY3bjJOZHR5WnJZWS9tN2Jwcm9PYjdNQnJJeUJ3WUdJblE1dEhKSzV1Ym5nYTEvN1duTnFhc3BaS2k0cENjVDBmcHBFdFpYbm1INGxwN1crSS9DRE84ejhxQm1ESFkxRUlyL2hPTTV6aHc0ZE9tY2VRNEFSQUFBQUFBQUFBQURBR2tXQUVRQUFBQUFBQUFBQXVCYXBrWkdSaE5aNm53clVmUkxJWmpNL0xFcDJtR25PM005ZlkrOFFKVXIzOVBVRXVXd3UySHY5WGk4U2lkaUx6VHpYNVVKWEFOZVdjcTBoazB1VnRzSUtiT2lMRFJ2b1NjZnRGYUtYL2J4MFBDckQzV2xKeHlMU3F1ZkhGNlRXV0gzWG10cndDUnR3NFRqdFhaOWNhVGJEL1dDM1NTYmUrbmE1R2g0OU1TWUxsYm84ZFhaR0poWkswcXJOWFJsNTQ3WisyVHRZQ090RXhGbDdwem03K3ZQeW8zZGNKL3MyZE11K29XNzV1NmRPTFV1UTBWZGVHSmRqcVZoWVg3WjBaK1YvZThOV1NVVThTY1pXWnQ4WHF3MDVjbjVHenJleG43dk02MDVISTlKcVZjK1lkZHN6MkhYWmdTU3Z4TzZMZG84eFhCNGJUbVdiOHgrNGVmdFZEOWFxMUp0eWFucEo1azA3MC9ycmNzT0FtKzUwTEt5RGw4djJVMXRNZi9OTUtpN3RlcTE2dDJUNjBDblRkamY5MXZvbCs5TVM1clhac0IvYlhzYTh5MzhQWXZzYjI0ZEd2ZGJmdHh3NVA5dFNXRkluWEdvckxwVXgwMDdab01WWDBwdEp5SEJQUm5wVGlYQitlMS91d2puSkd1eC9BS3dQbVV4R0hUaHd3Q3NXaTJyNzl1MHllbW8wbUpxYTB2UHo4Njd2KzV6RXJEQno3cURNK0tzMnN6MWFkRnhwOVN1T2NxYmZmUGViLy9iT08rK2MrK2hIUC9xM0FnQUFBQUFBQUFBQWdEV0hBQ01BQUFBQUFBQUFBSEROR1JrWnNSY25SWld2Tm9vajM2VkZEOXNpK3NKRk5JS09zT0ZGTmpvcW04MEd2WDI5d1o0OWV5U1JTTmo5UVhvUmdHdE9yUm1FWVNiTm9QVlFJQnU0RUkrNExZZGNSRjFYdWxPSmxnSWJMcGt1VmlRVlczMWZRWWhIdkhBN09HMTI3emI4SXR3UGZ1ZkNtVTdQRnVYTVhGSE96aGRsdmxScitmblpSRlQyRDNWTGZ5NTUxWU5QVmtwM09pNTNwQWZDdWhremRmc3JMNDR2UzREUjZNeFNHTXBoVHdkdDROTmI5bXdVejNFa0tTdkRIdTlqQzJXWks3VWVKQlAzVEYxUHRGN1hQZGVSRGZta0ZLNGdQS1ZjYjRiSENaWlAxSFBDZlh2emNKK3BrMWYzN1lvZmFKazF4NU1OTW1xVmE0NlBpS2xETnVRdDFVTFFsMzFlZHpvUmh1SzA2N1hxWGZYaWZhMzJvZmJZRDlzWnIvVSsxSVpNWGVoRFd3L3BzY2U5RFZ4YXpTNjFGWmZLZkxrcTg2L3kyR1RVbFMxZEdkbmFrNVZ0dlRuWldFaGZiSjhFQURyQzh6dzFPRGpvMXV0MTZlM3RsWEs1ckN1VlNyQzB0R1FEakFRcjcrTDRhOW9XTXliYjZ6aU8xa3BQbThXalpoa0JSZ0FBQUFBQUFBQUFBR3NRQVVZQUFBQUFBQUFBQU9DYThzQUREL3gwRUFSeFI1d2YwSTd1TjRzR1RJbmIrd2d2Nm94NFBCN2tjamwvZUhqWUdkNHk3QlFLQlRlUlNMZ1h3NHNBNEpwa3cxbU9UOHpMZkxuMXdKcWRBem5aa0V0SnF3cXBxTncwM0N1OW1ZUzBJOUE2REgrSmVqWUlLZjdTOHNuRnNsbVBlbHZoR0ZZaTZzbk92bHdZWW5NdFdhcldwVmhyeUtlZkdaV256ODNJWXJtMVVCc2JJR0ZESTI3ZDFpL3ZmdU1PNmN1dVZBelA4dG5abjVOQlU3ZTdVekdaTGxibFAvempFMkh3UjZsKzljSnpiSmpMc2ZGNUdUZDFlV3krTFBmdDJTaHYyYk5KTm5XbHBhL05ZMk85SzVsNkduVmJEMjNCNWJQQlJabDRKQXdLY3E3eVc1YXlPWDVzZnpOVGJEMFViS001THJLSlNOanV0OElHTWcza2twSlB0UitjOVZyMWJuS3BFcTVUdWQ1YUtJWHJxTEFQdGV2VnFrRWJCR2JXSngxckx5aXUzdlREUHRRR0VCYVMzOTdmWFFpSmF2K3JmZ3VWdXB5Zkw1cmZjMldCZkR2Nzh2TE8vVnZNOW0rRzdlOHRXL3NrWmZycG16YjNTUzRabFJzMjlrZ3VFUTNQQTJ5SW9BMTJzc3R0MEpYRDIyMEFIZVo1bnFUVGFYbkRHOTdnWEgvOTljN0UrSVJVS2hYNTNPYytGemFPOVhxZEU1ck9jTFI1TDJsOHQ2T2M4b1AzUDNpWHVYM1NpM3FmckZhcmt4LzcyTWNtQkFBQUFBQUFBQUFBQUtzZUFVWUFBQUFBQUFBQUFPQ2FvcFRhWmlaWnJmVkJlOU1VOStKeVFXZTRybXREakhTaHF5QkRRME1xbVV5cWFMUzlDMzhCWUwyd1FRWkx0WWI0Rnk3a2JFa21GcFZrTkNLdFNsd01HdkNjOXE3YkRRSXQxY2EzaDBYWTRDSWJ4R09EWWRwaEF5VXk4YWhFM2RZQ010YTY1c1h0T2I1UWxqT3pSV21WcXh4Sm0rM1dtNG5MNXE2TXJBZTJIdGh5L1ZDM0ZLc044VnpIbEt0N0RtZnJxYTJ2MVViVDFOMHAyZHFiRFlQRU51VFdmZ0RVY3ZIOUlLeXZXRDY5MllScDJ5TmhDTXpWWnV1ODdXL3FmbXRoUDFiUzlCbVpOZ0o3YkpDTjdXOGlUdnZyODFyMXJtejZuYkFQRFZvTDZ3bjdtN0FQYmYwcmRTLzFvVzIyU1haVmJKdnZ2Y28rdHZ2ZXZZTHRWVFBuRmZibkIvcktqbFVicERXWVQ0VWhWRlp2T2k0cGM4Nnhxejh2UGFhL09iaGpNQXlXU3NWYVB3OEJnT1htbUhiVWxxNnVycGNhMUdxMUdpN1Rtbk9aVG5sWm9QeG1Vd0l6V2p0Z1NpNElncHdaSDF3UUFBQUFBQUFBQUFBQXJBa0VHQUVBQUFBQUFBQUFnSFh0MTM3dDE3WkZJcEZ1UjV5UGlaSStIZWpoaTNjUlhOUkJzVmdzU0tWU2N0OTk5em1aYkVaMWQzZWIzUlFSVzlnbkFMQTIyU0NKMHpOTFVrakdaVENYZW1sNVZ6b3V5VmhFUHZwOXQ4dlVVa1ZhbFRiUHZYNm95MHl2cmE4NGZQN29XZmxmaDErUTV5Ym1aS0ZTYnpsMFltZC9Yajc2TDI2WGpZV1VyRGZiZW5OaE1NbWYvZXUzeWRoQ1dkNzNQNzhrUzlXR2pKcjZkN1hZK215Mys1OS83Ymg4NnNsVDhwNWJkOG9idC9USk8vWnZDUU04bGtQVEQ4TGZXYTAzcEZYMk9NbkZvMkV3RE5hZkRkbVU1Rk14d2ZwbFE5TnNIOXFmVFVwdk92R0tqNGs0U2paMnBhVmNhOHBzcVNxdCtNcUw0L0tOMFNsNXc2WmUweGRYNWVDT0FXbkh6cjY4REhkbncvWndvVklMWDY5dGQrS1JDMzEweXZUVnRFSUExb3Erdmo0SnpEbmx6LzM4ejZsYXRTWlBQZldVUHowOUxjOGZlOTZ4TVRwYUNEWHFBQnN1bFZXaURwcDk4ei9NZEhUa2daSFJadEQ4djdYV2p6L3l5Q01UaHc0ZGFnb0FBQUFBQUFBQUFBQldIUUtNQUFBQUFBQUFBQURBdWpJeU11SWNPblRJdWVlZWU1SktxYVJadE5HVXZpQUl0aWhSZldaWlZ0QXg4WGc4dlBvcmw4dUpEVERLRi9LU1RDWlZPcDBXQU1BM05ZTWdERE93MDFaNWpncExKOVNiZ2RSOS81OHRjeDFIb3A1SWZ5WWh5V2pyd1MrSmlHdUtKNTdyeXJXZzJ2RERVSWlwWWtYT3pSZWxWR3UySEY1VVNNYkNRSnZCWEZJeXNhaXNOeGZxdUN1YnU5SVNjWjB3VEdQV2JLL1pZaldzZjdWbTY4Zk5LN0hiZmFuV0NNdTUrWkwweml6SnpNWGYwWjJLeTlYbW05OVhNY2Q5bzQzalBoWnhKQjY5Tm82UmExSEVWV0ZkWHhhbWVRa0NMVnEzSHRJUU4rM3pwZUNhMWNTLzJJZTJ3N1l2blFnQ3M1dmY5cUgrNit3SDI2YmJzTE5XaGYyekthZE1PNVpOUkUzZjBoTXVUN1VZRGhqeG5MQW9sWkM4Nld0c29CdkJhUURXS3NlOFQ3SEZqRkdwV3J5bTgvbThOSm9OS2VRTFVxdlZBbE9VRFRneWhZWnVaWVVuUFdZY2Q5Qk03SnRMWmZiVXNIYjB6RnZmOU5ibWQzN25kelkvOElFUHpBZ0FBQUFBQUFBQUFBQldGUUtNQUFBQUFBQUFBQURBdWpJek14TTVlUERnZ05iNlh5aXR2aytMM20wV0R5amhXcU5PVW83WkcyWWY3TisvMzdjWGhCMjg4eUNmVXdIQWF6Z3pXNVJIVG96SjFHSkZXcldwSzdNczRTcXZ4NGE5TEZUckV2WCtlY2hHTW5xaHlUK3dxVWZ3K2s1TUxZVGxvYU5uVEIwWWwzYTg3N3R1a2syRnRPd2I2cGIxTEJPUGh1V3ZmK0VkY214aVhuN25zMC9JNGRFcE9YeDZTcTYydjNqc1JGaWVQamNqbVZoRWZ2OUg3cFdyclZ6ejVkbHpzOUlPRytLMHJUZG5qajlDak5BYUcvWmpROU5zZUZxcjltN29DdXZkYWdzeHN1MkI3VVBueXJXV251ZTVUdGlIOW1XVHN0TEMvV0Q2MEh6OTFVUG43SFkrdUdOQWpvL1B5L2hDV2RyeCs0ZWVEc093N0xyYS92a2QrNGVsSFpmNmRnQllMMkt4bUxybGpiZTR2dS9MbTkvOFpqbDY5R2p6eUxOSG11UGo0NUdscFNVYXZjN1phTVoyTjVvaHhWdnR1R0xEYS93UHFVclJMUDhwQVFBQUFBQUFBQUFBd0tyQ2gyb0FBQUFBQUFBQUFHRGQrT0FIUDdnN3FxTHB3QTIyYTEvdjBFcm56T0tWVDNEQVN4ekgwYkZZVEtkU0tjbGtNcXFycTB1bDAya0JBQ3lmZU1TVmVMUXpJU2FWUmxQcXpVRFFucVZxWFJwK0lQUGxtc3lWV2d2ZWVMbkJYRks2MGpHNWxpU2ludXpxejV0dDJKQmlyU0V6eGFyTWxLcHl0YzBVSzFLczFNT0FGQnZnc2JIQWVRM1d0cWJXWWR0VGI3WWVZSFNsYkgrMXJTY3I3U2lrNHBLS1JlUnFzNjhwNWpxeTBueDlzUTl0dkhZZnVxa3JMUXZsOXZzSFB6Qy9TQUk1TWpZYnRtSDdocm9rRnZHa1A1TVFBTUFGWml4THpOaVY2dS92ZDdUV2poM1RtcCtmMS9WR1hRSS9JQ0c5Zzh6KzZGWktwVWRHUnU2MHQ0dkY0ckZtczFuL2ovL3hQODRMQUFBQUFBQUFBQUFBT29vQUl3QUFBQUFBQUFBQXNDNTg3UDBmNjY0NzlmY0ZFZ3pvUUw5ZGkxWktGQmNWZFZncWxmSUhCZ1lhdDd6eGxzanc4TEFYalVaZGV5RVlBR0Q1Yk1pbkpaZUl5a3ByK29HTUw1UWxRanZmbHBydnkvR0plVGsxc3lTUG5acVVLL0hPQTF2RWM2NnQwNkJOaGJUODhsdHZsTU9qVTNMNDlKVDg5MGVmazVrWHgrVnErNmNqWjhQcFlENGxPL3Z6OHUvTTd3VFdza3E5S2NjbkYyVG1Da0xUMnJWM1E1ZjgxTjNYU3p1dU44K05lbGMzck0vMlg3WVA3VTZ2ZkpoUG8rbUhmV2hQNnRYemQyM2Yva08zN3BLL2RGK1EvL240QzlJT0c1SmtmZVJUWDVkQ01pWmFpK3d6Mi9MdCs0Y0ZBQ0RpdW01WWR1N2M2ZGt5UFQxdFEzTGswNS8rZEZBcWxmVFM0aExmdSs0QXBWNGE0LzBPTStacnMvZ09tbkhmbVdReStldSs3NTgweTc4bUFBQUFBQUFBQUFBQTZDZytTQU1BQUFBQUFBQUFBR3ZXeU1qSUZ0LzNVMHFwKytwUzc5V2kzMkFXcDdYV3lsR09oQmUwWU1WRlk5RWdsVXpKOFBDd2s4bGszTDcrUHQzZDNlMTZuaWVLVENrQXdBb28xeHRTYXdieXd1UzhUQ3hXcE9IN3N0bzF6T3M5TWpZcjgrVzZYS2tqNTJmRG9JdDlROTF5clJuTUorVW02WldsYXQyc2Y1ZjgxVGRlbEZLdElkWEcxYTBETmlocG9WS1hSMDZNU1g4bUtUdjZjd0tnTmZiWWVkUDJBV2xIWHpZaHJycTJBdk1jUjBrK0daTXRQZGx3dTUyWks4cVoyYUsweTRZWlBYVDBqSnlhWHBTWlVsWDJEbmJKbmcwRmlYbXVPTHh2QTRCUU1wa1VPNTUxeXkyM3FIcTlyazZkUE9WWEtoVTVlKzZzYTRjZHRXYnNzVVBpWnR5M29MUjZsOWsvNXg5NDRJRTNtSDN4ak5sSHp5UVNpWklaTTI0S0FBQUFBQUFBQUFBQVZoUUJSZ0FBQUFBQUFBQUFZTTBLZ21DclVxcFB0UHdmV3VsZXN5aHJsOXVRSE1LTE9pY1dpd1dGcm9LNjhRMDNTanFkVmowOVBSRUJBR0FGbFdwTktkWWFjbUpxSVF4M3NPRkFxMTNERCtUSStUbTVHbzZPemNsZ0xubHRCaGpsVW1IcFRzVmtwbFNUTHgwZk0rZU0rdW9IR0oyZWt2bHlUUjU5WVZ6MmJlZ2l3QWhvUTI4MkVSWmNIaHNxVkxnWVlIUnd4MkFZb0hZbEFVYTJYWHpvNk5rdzlPNEYwMS8rd00zYlpXdHZWaUtPSTQ1TGdCRUFXRGJBeUpaYmJya2xUTTB6WTE3MW1aa1pkZjc4ZWRlT1BSSmcxREh4c0NoNWw5a05zMHJVYVRQOU04L3p6cHI5VXpYM0VXQUVBQUFBQUFBQUFBQ3d3Z2d3QWdBQUFBQUFBQUFBYThZdi91SXZ4dEpHTEJhN1RXdDlXeEFFQjVTb2dsS3EyOXhPMk9BaXJEeTczVzNadTNkdjAvNVYraDA3ZDdqUmFGUjZlbnJDdjFJUEFGaFpSODdQU0NvV2tYOTRlbFRhY1hwdVNkYWFtV0pWbmprM0syTUxKVGsyTVNmbjVzc3lWNnJKNmRrbFdhelVwZVpmM2ZDYTFjN1dBUnVJZEMzclNzY2xIWS9JL2Q5OWl5elZHdkx2Ly80eEtkZDltVnlxeU5WeTN0UzN2M2pzaEp6YTBpZkphRVIyRGVUQzhDUUFhMU1qQ01MMmMyS3hMTGxFVk5waCs1emx0cWtyTGQrMWZ6anMyODdQRjAxYlZKYjZGUVQxelpWcllZaFJ2ZW5MWXllbjVOMjM3cENCYk5LMGFRWHhITjVqQThETGJkbXl4ZHV3WVlNVUNnV1puWjMxejU0NTY1dXBWeXFWSEVHbnBFM1pyQnoxTGpkd2J5N2tDazgrOE1FSEZzdlY4aDk5NGhPZktBa0FBQUFBQUFBQUFBQldCTjhZQndBQUFBQUFBQUFBYTBZc0Z2TWN4MGtIeldDL2N0VDNPc3JaSVJjdVVoSENpenBJWGRqKy9RUDlPcGxNNm4zNzl2RVpGQUIwME5oQ1dlSVJWNTQ1UHl2dFdJbndoYXZOQmpjY241d1B3NHNlUG5aZVJxY1haYVpVazJ1VnJRUDVWRXl1WlpuNGhmQ1J0KzBibGtCcitZTXZQQ3VSYXYycUJoaFZHNzRjUGowbFVYTzh2V0Z6cjJ6SUowVnlBbUNOYXZwQjJINVd6TEhkYmgrNnNBSjlxQTFYMmovVUxVK2VtWmF1ZEVLbWk3VXJDakN5YlpsZGJ4dGtaTU1BOXcxMWlXazJaVnR2Vmp5SHQzWUE4SExkM2QxT0VBUmhnTkc1YytkMHVWVDJpOFdpUTRCUlI5a1QveTZ0ZGNHTVVkNHNXZ2JOT09XMFdmYm5waEJnQkFBQUFBQUFBQUFBc0VMNGhnRUFBQUFBQUFBQUFGajEzdi8rOS9mR29yRVA2a0J2MXFKdlZrcWx6T0swMXRvbHVLaHplbnA2bXIyOXZjMDllL2RFK3Z2NzNYdys3N0UvQUtEekhqa3gvcyttcmJKQkJxdlpUTEVxNVhvakRDb3ExWnJ5Qnc4L0k4MGdrSW5GaXRTYnZ0UjhYL3hBeTdYczc1OFpEVU0wYkltNGppU2oxKzdYUXpMeFNEajk2NTkvaHh5Ym1KZFBmdkdJbko1WmxDKy9PQ0ZYeTlIenMvSmJuejRzamprTnN1RmgvZG1rUkQxWEFLd3R0dis3MUhjK2RQU3N0R01sK3RDb2FkY2ppYWk4KzQwNzVhMTdOOGtELzg5WDVmakVmTmpHWFVtUVVjMDh0OTZzeTRQbTV5VmpFZm5GKy9iTGNIZFczblByVGdFQWZKUGpPRFprWFRadjN1d09EZzY2OC9QelVpcVc1TkZISDIzWStibTV1WWhneFpreFNXWEdpclhaUDdlWjhlTkdNcG44d2dNUFBERHJhT2NQemVLekgvcm9oLzVSQUFBQUFBQUFBQUFBc0d3SU1BSUFBQUFBQUFBQUFHdURsbDVSTW1DbUc3WFc0VVVwaE9WMGx1dTZPaHFONmxRcXBYTzVuSmg1OWdrQXJBTFZSdk9mVGRlYndKd0hOQU10aTVXNmxPcE5PVE5YbElZZlNMSFdFRnhRcmpXbFpMYUgzVmIydk9sYTVsdzhOeG5NcDJUSmJCTWJhQlIxcjI2NFVNWFV3emxWQ3dPMWJOMzByL0Z0RHF4bGE2RVB0ZSs1Yk10bTJ6TWJVcGRMUks5S2FKcnRMMnpyWmR0S1cydy91MWl0Q3dEZzI5bTJPQktKS0ZPazBXaUVvVWJ4ZU54T09SSHNvRERFU0xRTmtJcVkyV0hUc1dYTTdhenBPYk1DQUFBQUFBQUFBQUNBWlVXQUVRQUFBQUFBQUFBQVdKVkdQamp5THEzMFJsTStabTdhaTAvaWRqa0JPWjFqTDhJcUZBcU52cjQrZGMrOTkwVFM2WFJZQkFCdzFiMDR0U2dQSFQwckVHa0VnUlNyRGJNOXpvVGI1QXZQbjVkamsvT0MxelpWck1yL2V2d0YyZG1YbDN0MmJ4Q0k3T3JQeSsvL3lMMXlmR0plSGo1Mlh2NzdvOC9KVjE0Y2x5dFY5d09wbDJ2eXlTOCtLMy8zOUNuNStMdmVKQWMyOWdpd0ZqUk4vWjB6OVhjOWhkNGRPVDkzVGZTaGlZZ1hsdi93djk4WmhxZjkwcDkrUWFhV0tsZHQzVC8rbVc5SVBPTEtYeDUrUWZZTUZ1U0I3N2sxdkcxL0p3RGdtMnlvdHkzdmZzKzd3ekd5eHg5L3ZGNnBWT1JMWC95UzEydzJsUzJDbGFmRmppVnZFQ1cvWThhVkt5TVBqUHo3UUlMLzd2ditIOWRxdGVsUGZPSVRKUUVBQUFBQUFBQUFBTUJWdzdjSkFBQUFBQUFBQUFEQXFqQXlNbUkvdDhqV2FyV2VoSmZvYnVybUhpV3F6eXh6VE9GQ253NjVGQmlWeVdSMExCYlRHelpzVUlWQ1FVV2pVWEZkVndBQVdFNm5aNWVrWEd2S3Faa2xlVzVzVHNibVM3SlVxd3RlWDczcHkzbXp2YnFTY2NFL0YvVWNHY3dsWlVkdlRzcjFocHlhWGdxbnZoYlJXa3U3cWcxZjVrcTFsMG9oRlJOZ3RmTk5uVitxMXFWbTJneXNUWjVqM3pJSHN0MjBhYlp0T3ptMUtKVkdVOFlXeW5JMTJQYk05aWRmZlhGQ2hnb3AyWmhQU3lMcWhXRkdBSUJ2WjhiUWxPZDVhdU9talZLcjF2VEN3b0t1VnF1cVhxOHp2dGtoWm56VGRwWnhNOTBTaVVSdU0rT2FFMllzZXNFc08yR21SUUVBQUFBQUFBQUFBTUFWSThBSUFBQUFBQUFBQUFDc0NvMUdvejhTaWV5UFJXSS82WXQvMEN6cUZpVXhSWFpSUjVsOUVqaU9JN2ZlZHF0di81cjgvdjM3SXdJQXdBcFlxTlRsejc5K0lnd3grdk92SFEvREdHeEFEQzdQYkxFcWYvZjBLUkdsNWZ0bG0rQ2JocnV6WWRuYWt3MERQajc4cWEvSjBiRzVzTTYxSDE4a2NuSjZVVTZhNmVIVDA5SU10THhsejBZQlZydHl6WmZqRXd1Q3RjdUdDVmtqMzN0ck9PM05KT1hGcVFYNXd5OGVrU3RsKzkzRHA2ZmtxYlBUOHZubnpza1AzTHhkM25YekR0azdXSkRCZkVvQUFOOXUxNjVkRVJ1S3VYdjNicG1ZbVBDZmUrNjU1cG5UWjl5elo4L3luZTBPMGFKdHN1aVFEdlJQbVBtZlVFbzliOGFjSjhTUjk1amxCQmdCQUFBQUFBQUFBQUJjQlh3WUJnQUFBQUFBQUFBQU9tcGtaR1RBVEc0VVh6Wm9yZmVhK1UxYWRNSk1IVUhISkJJSm5VNm5nLzZCZmljYWplcUIvZ0VWVDhRRkFMRDZwZU1SY1pSSUtycXltWE9aZUZTaXJpT2UyMzRYUGwrdWlSOEU4dVRaYVpsZXFzcmgwVWxack5TbDF2VE44aXVKbHJuMjFIeGZab29WbVMvVlphbmFrRVRVRmMvaDlPcmw4c2xZT0wxNzE1QnNMS1RsbjQ2ZUNiZFZ3dy9rU2h5Zm5CT2xGQUZHd0Jyam1PTTJHZk1rWXRyS2VNU1ZsZFNWamw5eEgzckp2ZzFkVWtoRTVmaXVEYVlmcU1xeGlma3dWQzNRN2ZlanRndTJmZkh4OFhuNTdKRXpVcW8zWld1cEtqdjc4eEwzVm5aYkFjQmE0YnF1cEZJcE5UUTBaTWZXVkRhYmxiTm56d2IxdW5sL1U2czVXdlArcG9QeVp2eFpsSysrLy83Nzd5KzZUZmN4SGRXTEgvclFoODRLQUFBQUFBQUFBQUFBMmtLQUVRQUFBQUFBQUFBQTZMUUJDZVRYdE5MOW91VTZ1MENaLyt6LzZKenU3bTUvMCtaTi9vMDMzaGpKNVhKT0xCWno3SVg0QUlEVnJ6ZWRDSU5xTm5lblpTV2xvcDZrWWhGSlhFSG93K1JTUllyVmhuemlNMC9JMkVKSm5qazNLMmhQdlJuSTZFeFJ6czJWWkxwWWtSNVRMekp4QW94ZWJrTStGWlovZGNmdXNONDlkWFpHL0tBa0M1VzZYSW5IVDAzSmkxT0w4bSsvNDRBQVdEc2NSNFY5YUR6aW1iWWhLU3ZKL2w3YmgwYmRLdzhEZXZ2K1laa3kvV2srRlpldnZEQXU1K1pMVXFvM1RMOXdKUUZHV3NyMXBqeDgvSHhZUm1jVzVhYmhQdG5jbFNIQUNBQmVnUjFEaTBRaTB0UFQ0OWhTclZiRmxvZis2YUZnWW1KQ1QwOVBLNjAxQTIwclRIMXpjTk1HNmc4RUV2eXVveHl0UGYwKzVTc2JYdlFYQWdBQUFBQUFBQUFBZ0xZUVlBUUFBQUFBQUFBQUFGYmNoKzcvMEQyQkRtTEtVLzk3RUFSWkpXcTNXUndYZEl5OWZpZWRUamY3Ky91ZGJkdTJPYmw4enUzcTZsSm1tYklYWEFFQTFvNTdkbTJRUk5TVDc3bGhxNnlraU92SVVEN1ZWdmpDcVprbEdaMWVrai83K25FWm15L0swZk96c2xSclNMdjJiZWlTalYxcDJaQXpyeWZpeWg5LytUa3AxNXF5bG0wc3BNSjh4ek56cFphZU4xa3N5OWRQVHNndFcvb2xFNmRQZnlXRHVhVFVVNzc4L0pzUHlQbjVKZm5kaDU0U1A5QlNhL3JTamhlbkZ5V3g0TW9wVTZkZFI4bW1ycFVORXdQUW5xam5oSDFvdjJrVDd0azFKQ3ZwVWgrYWpsMmRkanFmakpsMnZ6ZHMzNFo3MHZMUTBYUHk3TGxwT2I5UURnUHVydFRqb3hlQzJteG9ZU1lSbFIrNzR6b0JBTHc2TzdibU9JN2Nmc2Z0VHJGWWxGTW5UelhMNWJJNmN1U0lZOFpHbGUvN2hCbDFocU8xdHVPaVA2UWRYWHpnZ1FmdU5NdWVOZnZya05sUGs3LzVtNys1SUFBQUFBQUFBQUFBQUxnc0JCZ0JBQUFBQUFBQUFJQVZwMFZ2RnlWWkhlZ2ZNemVVK2EvMXBBTmNWVW9wblVna2RHOXZiN0QzK3IxT1BCNVhwckJmQUdBTjJqVlFrRndpS20vZHUwbldpdGxpVlk1UHpzc1hqcDJUWXhQemNxVnNZTXkrb1c3WjJaK1hURHdxLyt2eEY5WjhnSkVObzdCYURUQ3k2ejA2VzVTOUc3b0VyOHpXRWV1dW5RTnlaall0Ly9YaFo2WGhCMjBIR00yWGEySnI4V3lwR2dhaWJCSUNqSUMxSU9hNllSKzZxWkJlVTMzb0s3R0JTRnU2czlLZGlzdUdmTXEwYlVVWld5akpkTEYyVlFLTVRrNHZ5a2t6M1RsZyt0bFloQUFqQUhnZHJ1bGpiQmthR25Mc2JUTVkybHhZV0FpZWYvNTV4NDdKRVdEVUdjb211bDl3cXhtanJwdjlzamZRd1NHelA0NmFjVkxDaXdBQUFBQUFBQUFBQUZwQWdCRUFBQUFBQUFBQUFGaDJIL2pBQi9yajhYaGZzOWw4aDFMcTFpQUlyamRUVjJ0TlFFNEhSU0tSd0Y2bmM4Y2RkelM5aUtlMmI5L3VwbElwWlVyNFYrRUJBSjB6bUUvS1RjTzljbVoyU2FhV3FySmUyVENGdzZOVDhvOUh6c2huVFRrM1c1UjJKS091YkN5a1pXdFBUdDZ5WjZQWmRuMnlxWkNTczdNbEtUZWE0cWkxZXozd1JyTWV5YWduLzhkMzNDQ2U2WjkvNHYvelVFdlBueXFXNWVIbno4bUJqZDFocUJOZTNYQjNSdktwbUh6OFhRZmwrWWs1K2NSbnZpRlg0bStmT2htR0k3SGRzWnA1NXJRL0hZdEl2ZWxMM2IveVlKdlZZRk5YS3V4RGo0M1BTN0hXa0d0Wkl1TEpRQzRwUDNubkhubjNHM2ZLWHp4MlFzN01GZVhQdjM1Q3JvWXZtUDdGK2crZmZTSU1mdnJCVzNZSUFPRDFEVzBjOG5yN2VsWC9RTDhzTFMzcEk4OGVxVTlPVGJyVGs5T09GazJZVVdmWTc5UjNtVEhSTzNXZ2Q0bVdZeU1QakV6NDJ2Ly8rYjUvK21NZis5aUVBQUFBQUFBQUFBQUE0RlVSWUFRQUFBQUFBQUFBQUpaZE5CcU5CVUdRYzhTNVFXdjlKck9vMXhSWHJlRXdnZlhBaGhUWmZkRFgxNmNqa1loczJMQ0IxQ0lBV0NWczRFQWhHWk94K1pLc1o4VnFROFlXeWpJNnN5VEhKK2FsWGE1eUpCMlB5cWF1dEJ6WTJDTzcrbkl5bUUvSlhMa3VqV0J0QjNMWThDSzdibnNIdThLQWtWYVZhNzVNRlN2U1dDZkJKTXZKaGczRlBEY01lMnI0clcvcmIyWHJkcjNKZHNmcVp0OFBSRnhIbXJhdHZQSnF2eXJZWTluMm9aN0wyeHU3RFd5NWJxQXJ2RzFEQTYvbSszRGJ6bGxYMG9jRHdMVW9sVW81TmtDOFVDakkzTnljUG52MnJGNVlYTkJpdWk0VktFMklVVWZZRTRlb0R2U1FtUTZaL2pKcHBoTm0rZyttVEFvQUFBQUFBQUFBQUFCZUV3RkdBQUFBQUFBQUFBRGdxaHNaR2ZFYWpjYVE2N3AzT3VMOHRBNzBzTlo2Mk42bkxoQ3NQQ1VxdkJCcTI3WnR6YjYrdnVEdXUrK09KaElKdXpOaUFnREFDcW8wbXZMb2lYSDU3SkV6OHR2LytBMjVFdTk3Mnh0a2EwOVdmdnJ1NjJVOWlVZmNNTWpxZlcrN0tReGwyamZVSlF1VnVyenI1dTB5dFZTUmg0K2R2NnlmTTFPcWh1WDU4VG01ZmtPWERPU1M0YzlkQzJ4ZzB6UG5adVg4UWxtT2pzMkdnVjVqQzZVd2dHT3VYSlBmL2FHN3c5Q3FnenNHNVdxSmVxN2NOTndyUFptNGZPejc3NUNIanA0eDVheTA0Mzg5L2tMNCtqNzZmYmNMc0ZxbDQ1R3d6cjg0dFNnbnB4Y0Y2OXVsdnZLbTRUNlpLVmJsL3IvK2l0Uk1XMXV1TitWSy9PRVhqOGcyMHhmN2daWjlwcTk1Ky81aEFRQmNua0toNEx6dGJXK0xWYXRWc2VYeHh4OXZuaDQ5SFp3OWV6YmkrejZEcUN2c1pRUFgxMm5SMTRtV096M1gwdzgrK09BbmdpQ1krOGhIUHZKeEFRQUFBQUFBQUFBQXdMY2h3QWdBQUFBQUFBQUFBRnhWSXlNamVUUHhuTURaS0VxNnhKRzQ4SmxFUnlsSGFVYzVFb3ZHdEJmMVZEcWRWaGVEaXdBQVdIR0IxcVpJR01KVHJqV2tYZDJwZURqTkoyTmgyTTk2RTQ5NFVrakZKT3E2RXZXY2w1YmJlZGRwdlJ0ditJR1VybUI3TDVlbXFReCtFRWpUMTJiZWwzb3pDSmRYRzgwd3dPajhmRW1taWxXWksxVmxxVm9QMThFR1pOaDZWRE9QclYxOC9OVVc5enpKeHFQaGZuQ1VFbE5sUld2ZDBzOEk2M3FndzNBUTEzSE1DVEtuWHdCV2gxVFVrNm9wZy9ta3pKZHFGOXJoc0QxdXJaMTd1VXJEdjloV044STIzRFA5RiswZUFGdyttNXZqbUhQR2VDd3VkdXpPRlBGOVgwcWxVbmgvcStlaXVEcnNmakhiM295c09qbFRBalAydmJsV3E1VUdCd2VMZi9tWGYra2ZPblRveWxJQUFRQUFBQUFBQUFBQTFna3VGZ0FBQUFBQUFBQUFBRmVWMXZwWHpTVHJSSnlmTVZPbFJZZUpBdC84NDlWWWFkRklWQThNRERTdjIzT2R1MmZQSGllWlRIclJhRlFBQU9pRWhVcGR6czJWNUpmKzlBdGhzRXU3ZnZrN2J3eERqSDdxcnIyeUhoM2NNU2pmZldDTHZQbTZJUm5NcDhKbFVjK1ZmVU05a293dXlPZWVPOWZLajVNbnoweUhJVHJ2ZnVNTzJkeVZrZFZpb1Z5VDBaa2xPVEkySzJNTFpUazJQaS9GV2wwZU9ubzJEQUN5OWVYVkhCdWZOWFdvS2ZlWmJYUzE5V1VUOHEvdnVWNFdLelY1OU1TWWxPb05xVGRidTJqY3Z2Wmt0Q3JQbnBzTjYrcHd6K3JaN2dDdWJXL2ZQeXhOUDVDRE93Zmw0V1BuNVBjUFBTTmo4Nld3SFc3WDJFSkpmdXN6MzVDMzd0MGszZW00Yk8zSnlyYmVyQUFBTGs4c0Zndkx3VHNQaHQvdFBudjJyRFROdWU2Zi9lbWZCVGE4cUZhck9ZSk9jTU1RSTlFL0o4cThSUW4wejV0eDFYK2FuWjM5Zjk5Nzc3Mm5EeDA2ZEZvQUFBQUFBQUFBQUFCQWdCRUFBQUFBQUFBQUFMZ3l2L3FydjVwTEpCSXhNM3U3S1drSlpML1dPcVpGSzBWcVVjY29SMGtzR3BPTkd6ZEtQQjVYL1FQOXprRGZnTmpnSXZ2WDNBRUE2SlNuejgzSTFGSWxEQyt5NFFtdDJ0bWZENE1Scmhzb1NENDhCVmxmTXJHSURPUlM0WHJ1N011SG9VV1hSRnhIaHJ2U1VxeldXLzY1ZHB1UHppeEtvNDF0dmh5cURWOW1TelY1WVdwZVB2L2MyVEEwWTc1Y2s4bWxzcFRyZmxnLzdJWGFuZFpsNnByZER5Zk02NXh0MXFSVmZxQmxwbFNScU12NUY0RFZ4VEh2R2RQeFNCZzA5TTc5dzNKMGJGNmVHNStWNDVNTFVtdTBIekE0VTZ6SmwxOFlsNGg1MzBtQUVRQzBMNWxNU2hDWWdkYjkrOE1nbzRtSkNWMHBWMlJ1Zm83eDFnNHg3MC9zY0hmVVREZVo2WGVaUmFkSFJrWk9ldzN2Nkh4dGZqcWRUbGZNN2RYeGhnc0FBQUFBQUFBQUFHQ0ZFV0FFQUFBQUFBQUFBQUN1U0RxZDd2Tjl2ejhJZ3ZjcVVmdk5vcndvTWY5ekxVMG5SU1BSSUpWS3laMTMzZW5ZQUtPQmdRRStGd0lBckFxZmZucFVGaXAxS2RlYjBvNDd0ZzNJSGRzSDVMN3JOa29tSHBIMXhvWVgzYk43Zzl5emEwTTRmVGtiZ3ZQR3JmMFN0SkhyYzJwbVNaWnFqVEFrYURXb05KcHlkR3hXUG52a2pQejJQMzVEVnFzdDNabHdQNVRyalRCd3FWVTJ3R2gwcG1qMkhhZGlBRllYUnlucFRTZE1mek1VbG9lT25qSGxyQ3g4N2JpY21TdEt1NDVOenNrZmY3a3F1VVJVN3Y2V2Znd0FjUG02dXJyQzZUdS8rNTFPclZiVGozMzlNWDlzYkV3dExDNDRXc3gvZ1did2RZVmRET3RQbW5IdjI4ejJ2ODNNbnpMem8zVzMvc2xZTFBhbFE0Y09uVFBMQ0RBQ0FBQUFBQUFBQUFEWEpMNGRCUUFBQUFBQUFBQUFXakl5TXVKVktwVlV3azBNaXlzMytiNi9TMnZkcjBSdE5uZkhCUjBSQmtZNW9nY0hCblU4SHBmTnc1dFZNcEdVZkQ0dm5zZEhRZ0NBenFzMWZRbTBsc09qVTJGNFRhdTI5bVJsVzI4MkRDKzZhWE92eER4SDFoUFhVZEtYU2NpZURYbDV5NTZOc3Myczc3ZHl6R1B5eVpoMHArTXltRXVHZ1VURmF1T3lmdjU4cFNaMXN3L0c1c3N5bGl0Slh6WVovczVPaWJsT3VBNjVaRlRhTmJsVWtVUjBlYzl6Q3NsNFdQZlM4ZlplcDcyNDNOYjNSdUFMQUt4bVczdHlwdis1RURBM3RsQ1dmM2htVk1xMTF2dnJlc09YdVhKTlRrNHZobjMrenY2Y1pPTHR0L1VBQVBOZXdYWFY1czJiblZ3dXAyeXcwZVRrWkdETDR1S2kxMncyQ1RMcW5MdzkzMWRhZmIvWlJ6ZmZlOWU5WDduM3pudXJJeDhkK1JzQkFBQUFBQUFBQUFDNHh2QnRkUUFBQUFBQUFBQUEwSktabVJrM204M21BemZZNzRqejR6clF1ODNpQVVGbk9hSnRpTkhRMEZCZ1E0dHVlZU10Yml3VzR3SW1BTUNxWWNOem1vR1d3NmVud2lDalZ0bndvcmZzMlNTM2IrdVhmVVBkc3Q3WU1LSEJmRXIyREhhRjZ4bVB1Ti8yR0VjcEtkZ0FvMVFzZkt6TWx5NDd3R2loWEpjRnFjdllRc21VVkJpQzVEcXVkRXJFcko5ZGgzd2lKdTJhV0NvdmU0Q1JEWXphMW12RE55TFNEbHZWcXcxZkdzMUFBR0Excy8yc0xaN2p5RlN4S2w4NGRyNjlBQ00va0hxNUppL2FBQ1BUNTl1d09nS01BT0RLMkhEeVRaczNPUnY4RGJKajV3NDVldlJvNFB0K3MxcXRPczFtczNNbjljakxoUkNqWWJGdmNaWDhEMU9LWm80QUl3QUFBQUFBQUFBQWNNMGh3QWdBQUFBQUFBQUFBRnkyQno3NHdQdVVVajFhOUYyaXBVY3IzV3NXcHdVZGs0Z24vSzd1cnVhV3JWdmNMVnUydUlWOHdZMUVJMEo0RVFDc2JlbFlSQVp5U1RrMXN5UXI3YSsrOFlKOCtZVnhhVlhFZGVWTjJ3ZWtPeFdYMjdkL2U3YmhVMmRtWktwWWthVnFYVnJKTDNLVkNrTnFidHJjSys5KzR3N3B5eVpsUGJMYjc1NWRRM0pnWTArNC8rMTZ2NXBjTWhZKzlzc3ZqTW5ZUWxsYThlU1o2VEQwYUZ0UFJxSmU1NjUxOXN6NjJmVk1STnAvRFZOTEZZbEhsdmVyTDRQNXBCUlNNZW5OSkFSWWoxekhDWS9GbU9mSVNudnE3TFQ4eVZlZWwzYThjYmhma2pGUDNubGd5N2ZkbDQxSHd6NjBFK3YwWHg5K1JsNllXcEJXMlRDM0d6YjFoSy83NXVFKzZTVDdPaHArSUQ5Nzd6NlpXcXpJZnpIcjFBNGJtUGY0NktUY3ZXdUREQW9BNEdwd1RMOGRqVVpsNTQ2ZDN0RFFrRE4yZnN5cFZDcnkyT09QK2VWU1djcmxNbUZHSFdER3k1VTJBaDNjYlc4L2VQK0RuektUczJicy9IOTRuamY1d0FNUFBDc0FBQUFBQUFBQUFBRHJIQUZHQUFBQUFBQUFBQURnc2ptT3M5dE1CclRXdDE5Y1JFaE9oM2tSVHllVHlhQ25wOGZadEdtVHNoY3gyWXVaQUFCcm0rYzZrb2g0NG5hZ3EzMXhhbEdlT2pzanJVcEZQZG5hazMzVisrY3JOWmt1VnFVWnRKQmVKUFppVUJ2dTQwZ2hHWlBOWFJsWnI2Sm1IVzFJVGlZV0NkZjN0VVF1UGpabEh0c3F1eDlza0ZTbktiTmpJNjRTUjdWZng2c05YK3BOWDVhVFBRNXQ4VGkvd2pwbGowRGJwampPeXZjM0U0dVZ0dm9iYXlpZmZ0VTIwSWF6MmVQMlN0cVhkdG53b25iV3FUZWRDQVA2MHJHb2RGcmU5TGZXN3Y2OHhOejJjekNxamFiTWwydW0zdzhFQUhCMTJITm9XOUtadERMRkRVd2JXNjFXeGZOTXYrYzZyYjNSd2xWbFE0ek01RkptMzUybUhEUGxVSzFXS3drQUFBQUFBQUFBQU1BMWdBQWpBQUFBQUFBQUFBRHdxdTYvLy80M3VLNDdGUGpCdjFOS2RRYzYySHJwdm9zWFphQUQwcG0wbjB3bTVlNjc3bll6Mll6YjNkM3QydUNpU0tUMUVBTUF3T3FVaTBkbFUxZEdrckhXUDlaLzVNU1k5R2NUWnU1NmFjZno0L1BtWjR4THEyekEwSnQyYkpCcy9KWERGNTQ2T3kzSEpoYWtWWVA1bEx4ei94YTVmcWhiY0lIZDFnZTNENWp0T1NldCt2SUw0L0xNdVZuNWhmc09TRjQ2TDVlTXlyNmhMams3VzVUNVNyMmw1eDZibUpkSzNaY0Y4enpQVVcwRk9pMDNYMnRaS05la1hHKzg3bU50b0ZNdUVaVjZNNUJLb3ltdEtOWWE0ZS9SQklXZ1JlbDR4QnlEM1JlRHpWcHJVeVlXeStHeDEyNUF6ZVJTcGEzK3hycGxTOStyQnVKMXArTmhIeHJ6V2d2ZnNjZWQ3VU1QYk93eXQzWktPMng0VVR2cnRMVW5JemR1N3BWeWk4ZitjbnFINlh2dFB2NkhaMDdKYktrdVI4ZG1XM3IrY2RQbm41cFprbDk4eXcwQ0FGZ2VmWDE5WWtPTWZ2aUhmOWlwMSt2NjZKR2pqWm5aR2ZYVWswOTUycHlIMm9LT3NNbSt0NGlXM3pOajY5TVAzdi9nU1YvNy81ZlpIMTgxNDdkVEl5TWpyYjN4QVFBQUFBQUFBQUFBV0FNSU1BSUFBQUFBQUFBQUFDOFpHUmx4RGgwNjVOeDIyMjJwUkNLUkNvSmdvKy83dzY1eXQyalIzVXFwaktBemxFZ2luZ2l2T3NybGNwSktwU1JmeUVzeW1WVHBkRm9BQU91TDR5aUp1RTQ0YlZXMTBUVEZsM2I1Z1E1L1J1dS8xNVZBNjdDOGttS3RLUXVWbXJUS05aMmdEZXhKUkZvTG9salBYTWVSYkNKcXRva1hob2ZZREkvZ01pOU9MdGQ5Q2FRdU5WTkhhazIvNVlDUHF5MXFmcjhOVUltMjhUcHMwRS9kOTJXcFdwZGsxRnZlQUNOektEcEtYZloyYm9jOTNtMDl0eGVhVjE0LzcraWZzZnV6c29xQ1Q3QzIyT1BQTSsxS3E4S3dyZVlWOURkKzBGWi9ZK25nMWZzYmU2emFQclNkek4wcjdVTWJiYTZUUFliRDlibUNOcVoyY1Y5VWFnMXhYVGZjRGxHekhTSmU2L3ZXeXBpMnVWeVBTSGNxTGsyLzlkZGx0NFV0UzVWNnVFM2lFYjZxQ0FCWG0rTTRZY2xtczZwZXI0ZGpoYTduNmx3K0p6YlFxRjZybS83V3R5RkhCTkd2ckxEek5lY2l2ZWJjUG1yZVMyZ2xhb3U1UGRGb05Cd3pCbDh6WlZJQUFBQUFBQUFBQUFEV0ViNFZBQUFBQUFBQUFBQUFYakl6TXhNNWVQRGdnS3ZjOStoQXYwZUoycXlVNnRMQ1grdnVKT1VvY1pRamI3anBEYzN1N201OTg4MDNSd1VBZ0RWbWRHWkpuamszSzYyS1JGelozSjJSWENJbXVNQ0c5ZXdiNnBhZGZYbloxSldScWFXS0ZHdVhsM2d6WGF5RTB5TmpzMUt1TjhLZjAwbDVzMS8zYmVpVzJhV2FUQzVWV24yNmxHdE4rZlF6cDJVd2w1UjNIdGdpeXlVVjhVd2RqTXBDcGQ1U2lKR3JsT1NTTWJQUFhqOWN5ZTdYL3o5N2Z3Sm4yWG5YQjk3L2MrK3R2YnFxdXFyM1hWdEwxbVlqcjJEWmtqRWtCa01Hc3lRT0lZUmhNakJKWHZLU0diSXh0bFJld0FGTXdrQm1raEFTU0FZSUJFakNhZ01HWkdQWndyYThTWmFzWGQyU2VxOWVhNjk3NzVubk9iMmdYWFdydDZydTc3Yy9UNSs3bm51ZWM1N2wxcWw3ZjNWRE9oNTdqazdIOGIyZDlaWGN2NDdQenNkY3F4MXdvZVN4cDlsdVIxTzdXeFllMlgrMENwWDZ6WHNmamNHZXJ0aTVZWFZzSHh1TTErOVlIMHVWeDY1dnVtbEhQSnpXL1JkUDdJK2xlR0R2a1dqVWEvSG1xemNJTVFJNGo3cTd1NHViYnJxcHE1M201bHR1dVNVZWZmVFI1aU1QUDlMY3ZYdDMxNUVqUnd6QUYwazZ0ejZjRnNQcFBQdUg4L1YwM3YzdXNsVWVTaGZmRlFBQUFBQUFBSmNRdjVBQ0FBQUFBQUFxNCtQak55NHNMUFIzZFhYdEtGdmxsZW1td1ZRRTVWeEV0VnF0N092ckt3Y0hCNHUrL3I1aTllclZ4YXBWcXdLQVMxOTNvMTZGRDNUWDY5R3BoVlk3bFZZc04vUE5Wc3dzTktOVDlTS2l0NnNlalZvUlBGY092Rms3MkJ2VDg4MUZCeGlkZG14NlBnNTJkeDRZZEs3VjAzRWQ3RTF0dlZHTHBjb2hLbjNuT1JTalZaWlYzeExyeWFVbUI2V2VIR09YM2dlWG05TnphSDBKZGNyOXZObGUzajA5YjkvTS9FSTE5aytuc2Yvb3pIek1wKzErY00vaGF2dDNIejRSUTcwOXNhcTNPMWIxZE1YWnl1M2piTVpvQUM2OGRFNHhCZ1lHaWpWcjE5VG01dVpxNmZ4aUhEMTZ0SnlmbjQ5bXMra0hxNHVvcUJWRGVmbmU5NzczTFhsWm02czlNVitmbi92UWh6NTBNQUFBQUFBQUFGWXdBVVlBQUFBQUFFQU9MMXBYdHNvUDFHdjFzWGFyZld1K3JZakNsMWt1c3VIaDRkYTJiZHNXYm43MXpWMmJOMjl1ZEhkM04ycVgwQmVMQVhocFl3TzlzWFA5U0t6cTdUeDRJQWZackpvLys4Q0NjMjFpYWpiMkhadU9UdVVnaW8zREF6SFlLMWZ4K1hhc1dSVzNYYnM1UG5MZnJ0aC92TE45KzZuSDlzYU9zVlh4dHV1MnhNVzB1cjhucmwyL091NTViSDhzeGRUOFFuejg0V2ZpNWkxajhiZGlaNXd2c3d1dGprT2lZQ1hvYWRST2piSExiOTVZcWszRC9aRi9tTzN2N2l3RXNGMldWVCtmbWU4OGJPOUNPalk5RjdzbVRzUURldzdIQTNzUHg4Y2ZlaVlPVHM3R1U0ZFBuQWxmR2tsajYydTNyNDM1MXRiNHF6ZHVpNlZxMUl1cWZlU2dPQUJXaG56dU1KMURqQ3V1dUtLUnk3Rmp4MkptWmliKzRQZi9vRGsxTlZWT1RFejR3ZW9pS0lvejU5cHZQblg5RDlQNTl5UFJFei9WWFhZL2tHNzZvd0FBQUFBQUFGakJCQmdCQUFBQUFNQmw2ajN2ZWM5VmpWYWpwOTNWZmxXcjFWcGJLMnJiaWlqNnk3SU1McDZlbnA3MndNQkFyRjI3dGpZOE1seHMyTENoUGpnNFdLdlg2MUhJbEFLNGJQUjExMk4wb0RlNkc1MEgxMDFNemtSZlYyZWhEVm03WGNaQ3UxMEZPQ3hGdlZaVTIvejgwS1dGMXVsMUxtMjljODEyRlg2MFlhZy9lSzRjNnJSeHVEOTZ1enIvK01lZW8xUFJYYi80d1loOTNWMnhiV3d3Qm5xVzloR1dITmF4NStoMHJCM3NyWmE1L2EwNmgwRXM4ODFXMVFhYnJWYWNiNDFhclFxUjZWMUMvMTJxWnVyek0vT3RtRmxZZXYyRyszcXF2cy9LMUtpZmJIYzk5YzdiM2NFMDMrUzJjem8wWjdIT2Q3c2I3T21xN3N2elVpZGFxUjU1RHAyY25ZOU81ZWZtZWkxMXJ1dHFuSnozWHlwSWFxNTVNa1F0aHhVZG1aNlBaNDZjcU1ieFoxSTVQRDBYSjlJMlAvc3d6QzAwcXpGeGJ5cDVPVHJRYzBISEZnQ1dqeHhtbEYxenpUWEYvUHg4OGNRVFQ3Um5aMmZqOE9IRDFROEQ3V3IrNGlLb2wxRU9wdlB4cjQ4aTFvNi9aM3l3VmJRZW01bVplVFNkQzU0Wkh4OTNZQUFBQUFBQWdCVkZnQkVBQUFBQUFGeW1HdEg0bXJKUmJpbUs0aCtucTZPcFZOLytGSkp6Y1EwT0RqYlhyVnRYM0hiN2JiVyt2cjc2OFBDd2I1a0NYSVpHK251cVVKcFZQZDJkUGpWMlRVeW0venVmejNONDBmUjhNNXF0cFgxUHNsNnJ4WTZ4VmRXMlA5dDhxeFh6VlFETTBrSWRGcHF0VktjVHNYbGtJSGl1dFlOOWNmMm1zVmc5c0RzNjljV25EOFhSNmJtNDJOYXU2bzNYOTZ5djZySVV1YjArdVBkd2ROV0xhbm5GbXFGekdtQTBsZnBFM2srenpRc1FZRlN2VmZ2aDZPU0ZPeTY1WHg1YVltRExhVnRHQjJPOWdMRVZxMUVyWWwxcWQvMUxDQkY3NnZCa3RWeG9kalp2bk85Mk41YkdsVlY5M2RIWFliaGJEaUhLYytqMnNlbm9WSjdyWm5PWTB4TG51cDdHeVRsMDdDVkNtZkw4dlAvWWRQeXozL3AwRlZaMGFITDJaZGVYdzZIeW1MaGw5VUMxdkg3ajZ0aG9IZ1c0TEtYemkxVjV5MXZmVWsyTTk5NTc3L3lSSTBlS3ozMzJjOUZzTm90MnUrMWs4RVZRUkpGLzJPOU9GNzQ3TFkrbjVjRjAyMy9xNmVuNXp4TVRFL3ZTYlJmL2h6VUFBQUFBQUlBT0NEQUNBQUFBQUlETHhBLzkwQS8xRENhMVd1M1dlbEYvYzFtVU4wVVJvMlZacmlxS29oRkwrNTRsWnlrZGo3SmVyNWZYWG50dHU5Rm94SFhYWGRmSWZ4bDllSGc0MHUwQndPV3BPODBCdGFLb3dvRFdEUGJHNGFtNWFKZUxuNndYV3UzNDdCUDdxK2RmczM1a1VjL0pJUzJQSGpnV2g2ZG5ZeWxxeGNrd21vSHU1NGJIVEp5WWpZbTAvZk5MREVacXR0c3hOYnVRNnRSNWdNenNRak9tNWhhaUxDL05OenA1ZitlZ3F4emkwZC9kcUFJckZsdlh3NU96MVhPZVBIUWlMZXV4N2lJRjBIVFZhdFYyYkIwZGpGZHRISTBuRGgyclFrQTZkZURFVEh6a3ZpZmpHMi9ZRmxldUhZcHpaYytScWZqS25vazRtTmEvRkRtVUtOZHJ3L0FyNzkvdXhza0FvNzE5blllblBIN29lUFFkcTZmKzBsbGJuNTVmU1B2OFJCeGFZci9QeHRJWWxkc2lLMU4vR3JPM2p3MVdiUy8zeGZsbXErTjI5S1duRHNheE5JZThldHVhUlQzK2ZMZTdQSWMyMHRpU0g1UG4wRmNLKzNtK1l6TnoxUnk2ZVdRd05xMWVYT2hQSGlOeW9OTlN4cStzdTFHdjZqUDRFZ0ZzK2RoVXBhZFJoU1V0MWxPSFQxUmpZMTZ2QUNNQXNoMDdkalEyYmRvVW82T2p4ZUhEaDh0OWUvYzFEeHc0VUQ5Ky9IZ3R1Q2lLS1ByS0tOZW04L1B2U3VmdGIwckg1cUh4OTQ1UFJUMys5Zmo0K0dRQUFBQUFBQUNzQUFLTUFBQUFBQURnTXRIVDA5T28xV3FEOVhyOTVsclV2cjFkdGpmbEwwZWtFc0tMTHA1MFRLcWdvZzBiTjVSOWZYM2xkYSs2enU5dkFJaDZyVWlsSGdQZGpWalYyMTJGQzNXU0o1RURqSFlkbm96cCtlYWlBNHhtRnBxeDk5ajBrc01YY3VCUzN0YmVydWNHOEUzT0xjVGhxZGtxRkdNcGNyVnpXRU9yM2ZrYmxtYmFEems0NlZKOXE1UDNkMVY2dXFLblVhK08zV0xybXR2R2labjVVOGVtNjZJRkdOVlNXKzlKYlQwSGpXd2E2VTl0Y0dwSmJUQS81LzQ5aCtNMTI5Ykd1WFIwWnE3cVMxTnBmeTFGSTlWdjAzQi9qUGEvY3NCUDFZZjZ1cU92cS9NUXl6eEdIRTNMaFdablFXRzVYK1UyTURtN0VFdVZROHR5TzJSbHl2UE4yR0JmT29Zbng1RWNHaGNkanJkNzB0elJsWjc3NmxoY2dOSDVibmRkOVpQNUMvMm5IdE5wZ0ZIdVI3bmZENlN4ZGJFQlJya3VlUTZkYVM1dHJEZzloL1oxdi9pUGcvblk5S1N4SVM5ek9OTmlIVXZqZkI0Yi8ycGFBa0EyTmpaV2E2ZjVmdlhxMWJGLy8vNTJxOVZxNS9DaVZJS0xvNHd5SnhqbThwcDBxdjQxNllZdnBlV3hkUDJYVWhGZ0JBQUFBQUFBckFnK0FBOEFBQUFBQUplNDhmSHh3V2pIQjh1aUhDdmI1VlZSeG9ZeXlnMUZVZlFFRjgzYXRXdGI2OWF0YTIzZHRyVytaczJhMnZyMTYrdnBtQVFBUE52V3NjRzRaZHZhT0hSaUprN01MVDdvSVFmMzNMdnJRRnk1WmlodXUzYnpvcDV6WkhxK2VzN0I5RnFkNnU5dXhGQnZkMndZN3E5Q0dKNXRxQys5NVVnM2RkYzdEMlhKY2pETHh4OTZKcmFPRHNZYnJsZ2ZQVjJOdEs2WEQyK1liYlppSVpYZi91SVQ4WlU5aCtQSVZHZmhGU3ZOMWV1RzQ2MDdOOFdmUHZoMFIrMGtCMTNsZmJ0bGRDQjJibGhjME5YNWNzMjZrWmh2dHVPeEE4ZXFZOTZwSEpSMTc2NkRWV0RKZ2RTRzMzN2RsbmoxMXNXRnFieVlITGcxa2RyTlBZL3RpMS83ek1QeHhLRVQwYW5CbnE0WVR1My9tdlhEMGQxNDVmYWZ0LzJhZEN6M0hKMktwZnJFSTgvRW93Y0c0aHV1Mzdxb3grZUFwdHdHSHR4N09EclYwNmhGVityWDY0YjZxcjUvSVUwdk5PUEU3UHlpZzVQS3NxemFTQTZZeWZWOWNzSVg5Sjl2NDBoL05kODh0UDl3UEgxa3VxUG5mdTdKQTZuZFRzWTMzN1I5VVk4L20zYVhBMzdTRDA2TGFuYzV3Qy9QaDA4YzZ1eDRuNmpHa3dNeDB0OGQxMjhhWGRSejloeWJxcDR6T2RONUtGTWVLMGI2VHM2aFhTOFRUcFNEbVc3YnVUbSt1dTl3N0pwWTNKaDBKSTJuZVd6ODZQMjdZMkp5TnQ3MnFpMnhmbFZmTE5icGVXTFg0YzdIUUFDV3Izd09zcnU3TzlLNXlkclEwRkRYMVZkZlhjeE16OFM5OTk3Yk9uTGtTSG4wNkZHZkw3OEkwbkVweXZ6R05mMklsODdmTjl1dDlxL2MrZDQ3cDR1eStFK3RWdXZnQno3MGdZOEhBQUFBQUFEQU11VVhUQUFBQUFBQWNPa2JqS2orY3ZQNnRMeTJ1cVVJU1RrWFdVOVBUemswUEZSdTNMZ3gxcTlmWDZUcmhRQWpBSjV2c0tjN1ZnOTBuam00MEc1WElUQ2RoTm5NemplcjU3UmFaWFFxaHlwME5XclIxL1hDanlIMG5McTlWbHZhUEpmREV3NU96c2FKMllWb3Rzdm9MbDk1KzFxcC92bXhPUWltMCtDS2xXaTR2eWZXZGhCSWNkcDh0VzluWXJDM0t5NjJIUFNUNjdDWW9KOFhrME5LY3Z0OTVzaGtQTEwvYUh6dGxSdmliS1RtRTdNTEowT01uam84R1hQTlpuUXE5NHZ1MVA0WEc3SlRUMzBrUDdabmlmc2d5d0U5bllTRkxUVGJjU2kxZ2FuNXp1dFhyOVdxT3ZaMTFWKzA3NTlQclhTQWNoOWZyUHpJL1BqWmhXYlY1cWZuT3EvdnBhNDNIY004M3pScW5iZS9nNVBUTWRDeitEWndWdTB1L2N5MDJIWTNsTWEycGN5aHA4ZVRQQVlzVm41c2ZrNHp6VCtkcXViUWV1MFY2NU1Edy9JNCtkVGh4WS9aZWJ0eXlRRlRUeDNwajdtRnp2WjVQbGE1enh5Ym5nOEFMaDM1SEdRdWZYMTlSUzdwdkdUTXo4L0hRdzg5VkU1TlRYWCtBeUhuektrVHhJUFY1U2h1Uy85TmxGSCtTYjIrOUo4UkFBQUFBQUFBTGdRQlJnQUFBQUFBY0FrYWYrLzQ5NWRSRGtVUlAxV2UvR0p2OVRzQkFUa1hUNjFXSzllc1dkTzg2cXFyaWplKzZZMk4zdDdlcWdRQXZJenJONDNHUUU5WC9QWVhuK2dvakdoeWRpRis0YzhmaUd2V2o4UlFiM2Zjc20xdDNMSjk3WXMrZHUvUjZmajkrNTZNVHorMkwvN3pwNzhhUy9HT203YkhqdEZWTDNwZkRsdklwYmRyYVYrNHpNRUxPWVRvdCs1OXJGcCs3OWRlRjE5NzFZdUgwOHcxV3pFOTM0eWYvcU12eEI4LzhGUTh2TzlvVEhhdzM1NXZZbkkyUHIvN1lLd2Y2b3VOSXdPeFhKMXRPL202dEQvLzE3ZmVFQmZUYmRkdXFzcGREejFUaFZZdE5YZ3FINjljdnZqVXdkZ3hOaFQvK0s5K1Rhd2U2STByMWd3dDZ2a3pDODM0MUtQNzR1SDlSK05mL2ZFWDQ4ajBYQlZLc2hUZjhkcXJZaXk5OW1LdDd1K0p0NzlxU3hYQ3RGUS85ZEhQeCthUndYampsZXVyUHJkeCtLWGJiVDcydVo2L21mcldVbHkvYVhXMWozdTdMdnhiMms4OHZDZjJIWnVPdi91VzYxL3hzZmMvTTVIMjZWVDgwSC81UkhWODgvTjRvU3ZYREtmMnR6V2VUdnZxeVlrVEhUMzNJL2Z0cnRyNnpWdldwRGJYSCsrOGVjZExQdlpzMjkxdE96ZFY0M0Yvenl1SCtPUzViMnVhbS9KcmRpSUhnZVhuNUdWdUwvazE4M3o2WW5KZzJzZFRlL3k5THo4WnY1L0tVdVN4NHFYVy8yd0QzWTM0enZUWVdycmM2ZjdMajgvbDhZUEg0c3ExdzlYWStFcCsvYk9QeEpPSFRuUzgvNTd2bG0xcjB2aStPUUJZdnZyNys2dnlIZC81SGRVYnU2L2MvNVc1NmVucCtKTS8rWk91WnJOWjVCSmNjT2xjZnY0aGVsMDZ4Lyt2eXFLY3YvT09PMzh1WGY2djZmYmZTTGMvUEQ0K2ZpQUFBQUFBQUFDV0NSK0tCd0FBQUFDQVM4RHR0OS9lK1Badi8vYjY0Y09IQnhZV0ZnYWlIYU5SaTFWbFdWWmZMaEZjZEhHYzN1OTlmWDFsdlY0dkJ3Y0hpKzZlN3FKV3F6a21BQ3RBamdCc3Q4dFlhTFpqZHFFWjUxdWVHK3Bwam1qVS9uS082SzdYcXNDQ0hGWlFTL2UzeTdLamRjN01OMk5pYXZaTXFVY1JSZTB2NzIrbStwMitMejkycVhvYjllanRmdm1QSU9TUWsxeVd1aTl6T05HSjJZVTRORGtiVHgrZGlsVTlmL2w2MVc1Si81MUlkVGc2UFI5SHB1YXJ4MTh1VHJlVHBjaHRhcjdWanFtNVpyV2Vya1l0THFZY2dwTExVZ09NVHN2OWRtcHVJWjVKYldWcXZoV0RQVjFWMzZyVlh2bzkySFRhQjdsOTdqOCtIU2RtNW1PaDNlNjR6ejNiVUY5M1ZUclZuZnJUcXJTOTg2MVdhc2Z0anA3YlNuMDZiL09lM0VkNnU2SXZyU3NOTHZIc3Q1N05rd0duVmIrZlBvdCszMTJ2UjMvM3hmbm8wWkdwdVRneVBYdG1QSGwyaUZLdWY2N2kxTng4ZFgzUDBlblltL2JIeWVNWnZJVGM5L3ZUdU5wOUZtTkFibFA1K1M4MTM1eCt6Tm0wdXh6TXRkalFyQnh5TkpCZXEzYXFBM1RhbjZkUHo2RnAzaGtkbkgzTy9GeW1ydGxLN3hUeW5IVDJkV3BFVjMxeCt6MXZRNTV2bHpwRzVFQzJJMU1uNTlGc3NPdUZZMFFPRHN4TzEyMnB1cGJCbkFMQTBuUjFkUlhkM2QweFBEd2NjM056NWN6TVREUmJ6V2cxVzA1b1hpU25adXY4RmlzbkIyOW90Vm9ueHNmSGEzZmRkZGVoZkg5YW52K1RGZ0FBQUFBQUFDOURnQkVBQUFBQUFGd0Nici85OWsySER4L2VGdTM0KzQxNjQyM3RzcjAyLzRYbUlueW41R0pxTkJwbERpdDY1enZmT1orLytMUHoycDJkZjRNZGdJc21CNkFjbTUyUFJ3NGNqYnNmM1JmblV3NVhHTzdycmtKV2RtNFlPWFA3cTdldXFjcjY0ZjRxWk9iSTlGeDA0dWtqay9HZS8zNVAzTEp0YmR5eWZXMnNYZFVYcTNyL2NqcDYvT0N4Mkh0ME9uNy92aWZqYkx4Mis3cllQcmJxWlI5enc2YlYwV3EzNDA4ZWZEcVc0aXQ3RGxjbFB6OEhzN3o3RFR1clpiYVE5czFrUGxiN2o4YkhIOTRUVS9NTE1kOWhxTU5LZHJxZDVCQ2pneDA4TDRkNUhKdVpqMmRTTy9uSS9idmkrbzJyNC9wTm8zRXhmZS9YWFJkLzdUVlh4RHQrNW5maWJIenA2WW1xZk9UKzNkWDE3M3p0VmFmNjErcVhmTTVIVWovSWZleitadzdIdWZDLzNYWmpOR3FkaDNma3Z2UTMzbkJOZk9LaFBmRndHbjg2TVRtM0VBK25mdkN1Ly9zUFltTWFOOTU1ODQ0cUhLWHZXVUZEdXllT1YyRXl2L0RuRDhUWnVEbTF1ZHQyYm83KzdxNjQwSDd6M2tlcmNKUmJ0cTJyQW0zZWZQWEdNL2ZsTnAxRFdqNyswRE54Y0hJMmZ2SVBQeDlIcHpvYk95OUhWNjhiamkyckIrTWpYOTRWUzVHRGJ2SjhrOXZkcHgvYkY2djdlMkwxUU8rWis4OVZ1N3QrODFnYXEwYWp0L0hLSDN0Ny9ZNTExVExQcjZmSHUwNzgyVmVmcnNwYmQyNktuZXRIWXV2b3FqTkJRem4wYisreHFYaGtYNXAzSHRrVFp5TzMzN1dEdmEvNHVFWjY3YndOZVU3UFk4VG5keDJNeisvdVpOVFBmZWV4TThzY1FQYk5OMjJ2d3NnR2V2K3lIMzkrMTRGcUxNenZmYzRtd1BHYTljUFZzVm83MUJjQXJDeW56MkcrK2pXdmpyMTc5N2ErL09Vdkx6ejkxTlAxWjU1NXBsR21PYlVzcFVKZWFHbXY1OGw2YmRrcXZ5OHR2NjlXMUI1S3Z3dlkvNWEzdk9YL2FMZmJoKzY2NjY2bHZZa0RBQUFBQUFBNFJ3UVlBUUFBQUFEQUNwVC91dkxrNUdUZjRPRGcyblQxdWxTMm5TNWxXZVp2QjNiK1RXbk91YTFidDBaUGIwK01qSXpVNnZXNk5DbUFGV2F1MllxSnlabTQ3NW5EMFQ3UDM4L01nUWpiUmdlcllJSm5CeGlkZHZXNmtTcUE0YzhmMlJ0TE1URTFVNFVzN0RrNkhmM2Q5VE8zSHp3K0V5Zm1PZ3QwZUxZY2ZsQ3JGVlhveGViaGdaZDk3S2FSd1RnMnZSQm42MlNZUWhsZmVlWlFkRGRPMWlVSFUwelBOMlBmc2VucXVMVlBIYkFjNnBPRFc3NzgxS0hxL2t2ZHBwR0IvTVhXMkRVeDJkSHpaaGRhcVcxTXhkWjBIQysydGF0Nm82K3JIdGVrTmovZmFxVzZuSWh6NGNtMG51NUdyUXI0ZVNrNWpDVHZpN09WZzJCeXFNNWdiMWZVbHZBT01QZXI3V2tzNk85WjJzZDY4aGZLY3o4NE5EV1h4cStKNkVuOTVIVG9TblpvY2piS3N4alV1dE82dWxQOWNsRE45alJ1NWYxNm9lWFFzdHp2Ly9pQnA2cTZQWGJnMkpuN3BsSmZuMDdIK1pHRFI5T1lNeCt6ODJkL1RDOEg5YUtvanUzbTFRTlYvOXQxK1BpU2d1QW1aeGVxK2FhdnB5c0duOVdHejFXNzI1TG1razdiM1kyYlI2czU0TjVkbllYOW5MWTNqWTlGZVRLa0tlK25iQ0hWNVdpcTA1NDBiaXpWNlRrMDEyZWdaL0ZCWVBuOVFLN1RVNGM3Ryt1ZjdjVHNmRFhlNVRFaTk2R2V4bCsrTjlpZDFuc2lIY2RtNit6Nnp1aEFiOVdXY2tBU0FDdFhiMjl2c1huejV0clUxRlRzMzcrL3RkQmNxS1VmT1p6bnZQaEc4czkrOWFoL1UxRVVVK24zQlIrdjFXb3pkOXh4eDRNQkFBQUFBQUJ3RVFnd0FnQUFBQUNBbGFuVzA5T3pwdDF1WDF1TDJqOHJvOXhlbHVYMmZFZFJGTDVBc2t6czNMbXoyTEJ4UTJ6ZXNubngzMFlGWU5uSVFTZTU1RENZajk2L0s4Nm5ISGJ5NXFzM3hzMWJ4dUlkTjI1N3dmMWYvNm90Y1h4bWZza0JScmtPblliYUxNWlFYM2YwZFRYaWx1MXJZL1BJeXdjWVhiTnVPQVo3dXVJLzN2MUFuSTNUeCtWM3Z2VGtLejcyNjYvYkVqdlhqOFI3OXQxeldRUVk1Y0NtSEdMVTZiR2VXV2pHZzNzUHg1VnJoK0ppMnphNnFscmVkdTJtS2tEalhBVVlmZTdKQTNHaHZEYjFoMXlQdFlOOXNSUnJWL1hINjY5WUg1OTRaRThzUlk2SXllMDlsNC9ldnp2T3RmN1VqMWYzOThSMUcxWlgyM2t4NUlDbTdLZi82QXZCdVpFRDRYSjUxY2JST0pibW0xLy96TlNTQW94T3BQSDU0MHRzdXkvbmRMdTdZZE5veCszdW0yN2FFVWVtNTVZY1lQVElnV05WT2RkR0IzdWpxMWJydUQ1YlJ3ZmptMU9kSGp0d1BQN3dLMHZyNHpsUUt0dDdGZ0ZNcjJUSDJGQWF5emZIMkVCdkFMQnlyVjY5dXBiTDFPUlVjL2V1M2MycHFhbkdRbnRCT3QxRjhxeHoveHR5YVVkN3ZLZ1Y2VmNENVljWEZoYU9wTnNFR0FFQUFBQUFBQmVGQUNNQUFBQUFBRmhoM3Z2ZTk3NDVtckc2VVd1OExZcFljeXE0YUNUZko3d0lBQzVOTjI0YWk5bUZaaFYwMUc2WE1kL3FQRlRpZkhqdHRyV3hjV1NnMnE1WHNuMXNWWXowOTFTUExjdS9EQ0E1SDRiN3U2Ty9xNUgyMjJqY3VIa3N0cXdlakhxdGlBTW5aanBhVDZ2ZGpwbjVaclR5QnE4QXVaNDVKS3BUVTZtT0QrdzVIRys4U0dFMEwrYnRyOW9TaDZkbTR4TVBQMU1GOGVSQWxlWHVkTHU3WmZ1NktqaHJxVmIxTnVLS05VTm5TZzRZbVYwNGYvMmxVOXRHQitQbUxXdGkzYXIrV0lyY0Z6Y085OGR3WDA5Y2FOMk5XaFdta2tOMkptY1hnaGU2WnYxd2RZdytjdCt1V0VoajRISnBlMWVtdnBERDhsWVBkTjV1YmtselZSNy84L3pUU25Qb3dqS1pRM053NGFvbGpOazlqWG8xbjE2ZjVyZzhWdVpncHFQVGM3RmNEUFoyVlFGdXA4ZXczbTRaRndDWGlqSld5QTlHbDVGVHZ3OG8wc0c1dFJhMTZUdnV1Q09uR1QxUnI5ZnZtWm1aT2ZZVFAvRVQ1ejZGRVFBQUFBQUE0RVVJTUFJQUFBQUFnQldtWHErL3VRb3RLdU1IeW5hWnY2TlFmUnRRZGhFQVhMcHUzRHdhN2JLTXZxNUdGYnl3WEFLTWJ0bXhMcTdmT0JxOWpWZisrRUVPTUdxMlQ5WWgxK1Y4QmhpTjlQWEUyR0J2M0pEMld3NjgyREk2R0syeXZZUUFvN0lLam1vdGsvMzlTdkkrSGgzb2pVNU56eTNFZzN1UHhNRU85OC81OVBaWGJZMzl4NmRqNDhpRE1URTV1eUlDakU2M3U5ZW1OcGNEZnBacVZXOTNWYTVjTzFTVkk5Tnp5eXJBYU92b3FpcDRaZjFRWHl6RnlRQ2pnU3FBNVVMcnFkZXIwTFU0T2lYQTZDVmNzMjZrT2o3RGZkMVZlTmh5YVh0WHBMNlF4NFhWUzJnM2VSNTQ1c2hVTmYva3VXZlpCQmhkdFRIV3J1cThIM1UzNmxWNTFjYlYxVDU1L09EeFpSVmdsRU9aVG85ZnVRQndhU2hEZHRFeVZUdTF2RFdLYUJkUnZLR29GUjlMMS9mMDlmWHRUa3NCUmdBQUFBQUF3QVVod0FnQUFBQUFBSmE1SC8zUkgxM2YyOXU3cnQxcS85MnlYVjZaeW8xbGxIMVJSajBBZ010Q2YvZkpYKy8vOERlK0pwNDhkRHgrOGU0SDQyTGF1VzQ0cmxtL09yNysyczF4N1liVk1kRHp5aDgveUhWb2x4Ri80dzNYeE14OE0vN1RwNzRhNTBzT2hiajFtbzJ4YVhpZ3VyNTJWVy9NTGl6RS9jOUVSMDdNTGNRais0L0cwUlVRbnBPOWR2dTZLaHlxVXptbzZjVHNmRHk4LzFoOC9LRm4wckVkaVUwakEzRXhEZlowUmF6cWo1Lzh6cStMeno1NUlIN3hrdzlVUVVZVFU4c25wT08wSE5heGNhUS8vdVliZDhaYnJ0a1VOMndhUGJuOVorbHQxMjJKR3plUHhmdC85elB4d0o0ak1UbDNjUU4zUnZxNzQ5VmIxOFEzWHI4bDNublRqaGdkWEZvQVVWZXRWZ1hLN0pvNFVlMm4rV2JydklheTViRm5JTDNPOTd6cDJ1cHI5em4yOWRPUDdZMjl4NmFERnhycTY0N0IzcTU0ZHhxclQ4d3V4RS85NFJmaVl0bzQzQiszYkZ1WDJ0M1d1RzNucGlvb3JGTzVuZVY1SU0raDkrK1ppTi80N0tOeE1kMll4b2p0WTBQeHRqU0g1dEN6SmE4bmpROWJSd2Zqd0xHcGVPVEE4ZmpFdzg5VTg5YkZVaStLNkV2OUxRZTQvZERiYjQ2cjFnNEhBSERobEdYMXh3NEdpN0w0Mm5iWnZpb3RkNDNmTWI2clZiWitwZFZxN2Y3VXB6NDFjZGRkZHpVREFBQUFBQURnUEJCZ0JBQUFBQUFBeTF4M2QzZFB1OTBlYnBmdHJ5bUs0cVowMDFBUlJhMzY1aTBBY0Zub3F0ZXE1YzcxSTlFOGowRWZpelhZMjEwRnRxd2I2bysxcS9vVzlaeDZyVmFsTDI0YlhSVkhwczl2Q00zR2tZRzRjdTF3OUhhZC9GaEVYMXAyTnpyL2lFUU9Wc2xoRURuZ1p5WEl4MklwQVViNUdjMGNZalEzSHdjbloyUDcyTVZ2WTduTkQvZDNWMEVZKzQvUFZHMHVoNmtzUjkyTmVyVjlPOWV2cnJZM0J4bzFUdlhaczdGMTlXQ3M3dTlKNitzK013WmNUSGtiMWc3MnhmclU3M1AvWDZxOGIzSzljckJRWG1lem5kcGJLODZiL0JyNW1Kd2VQM09mSGpnSEFWT1hxcDdHeVp6Y1BJWXVoejQzMkhOeXZsbmZ3WHp6ZkxrTkRKNXFBM3VQVGNYRk5qcllXOVZwN1ZCZmpBMHNQY0JvdUsrN0twdlNXREU1Zi9HekNJcmkxRGlSamxQZTF5UDlTd3M1QXdDV0pxY1hwVVdqakhKeit2M0I1dlQ3ZzlYcCt1cDA4MGRTT1JBQUJBQUFBQUJ3L2dnd0FnQUFBQUNBWmVvOTczblBWWTJpY1Z1NzJmNzZxTVhYUnhtRFVjUkF1dXZpZjNzWkFMZ292dW5HN2ZHYXJXdWlwNnNlWDlwOUtIN2oza2ZqUWhycDY0NHRvNFB4cmx1dWpMLyt1cXRqN2FyT1EweCs0SzNYeDhUa2JPeWVPSkhLOGZqMDQvdmpYTGw2N1hCOC9hczJ4enR2M2hhdjM3SCtUSWpNTmV0R3FwQ1pqOXkzcTVQVnhkVDhRcldkVTNQTE16am4rVmIxbmd4bHVYSHphQlU4c2l0dGV5ZWVTbysvKzlHOXNYMXNNSGFzV1JVWFc2MG9xbkNPcjc5dWM5eThaU3crOGZBenFleU5qejJ3T3lhbXptOEkxbUxrVUp6dGFUL2RlczNHK0FkdnV6bldEUFpWMjN1dWNrYkhCbnRqOVVCUGZQQmRiNHFESjJiaWIvK0hQNjdDdENZdmNIdnNidFNxTUpLYjBqRzQ0MXZmVUczVHVYRDF1dUg0Z2R0dWlFK21ObmYzSTN2alhGdVh4cWZ1cmxxOEwyM3o1cEhCZU1PVjYrT3B3eWZpOXpzY0J5NVgzM3pUam1wNTEwUFB4TDZqVS9IeFIvYkVoZFRmMDRqYmRtNktOMSsxTWY3dVcyK29ndWpPUmc2dHluUG9qckZWc1dYMVlQekpnMC9IbjMzMTZiaVExcTNxcllML3Z1ZE5PMVBkTmxkQlh1ZkM5N3pwMmpUbXo4ZnNRaXVOalROcHJ0c2RGMW9lKy9JWThVLys2aTFWK05yVzlGNmhWa2hkQm9DTGJFc1o1WWIwZTRWZnFkZnEwN2ZmZnZ0Yjc3cnJyaWNEQUFBQUFBRGdQQkJnQkFBQUFBQUF5MVgrVG5adjlaZVRCOHF5M0hEcUx5Z0RBSmV4Z1o1R0ZSNlNBeGoySDUrT3NZSGVtR2syWTNhK0ZlMnlqUE5wcUs4NzFnLzF4L2F4b2RndzNCOWpnMzNSMTFXUFRnMzM5VVN6VlZaMXlBRkJ2VjJOZEwwVnpmYlN0NytuVVl2dWVqM1dEZlZWMjVlM3JmZFpZUmM1dUtLL3UvT1BTT1R0bkdtMllxSFZydmJ2Y2c5ak9MMTlPUlNqWEVKN21NbmhGNU16TVpQYTAzS1I2elRVMngxZDZmam1VSXpjYnJhT3JvcEd1cDYzTlR1YnRyT1U3Y2x5V01kSTJzKzV2ZVV3bEkzREE5R1gydGk1YkNONVhibXNIZXhON2JsZXZVWnVoN3NtamxkMWJsMkFldWQrbi90WDN1ZTVYNjFOcFdjSi9mN0Y1SDI0ZFhWYWIvL2g2alhtbXUwNEY3cnF0ZWhLNjl1OGVxQWFvM0tRU2c0d3lnRmZnNmRDdm5obHB3UFJjcC9MSVZaamU5SjhNOStNNllWbW5HOTVEQnRJL1dsN2V1MXF2a2x6M2JtUTU5QzFxM3FyT20wYUdhaldlMlQ2WkJqYStaeERjNS9wYWRTck9YUmJOWWNPVlAzcFhNbGhUem1rTDRmUERmWTJxdjJYeC9QWkMzQ3M4bXRuZVh4ZWsvWm43bThqYVo1djFPUXVBOEF5MERoVjhnOHBnd0VBQUFBQUFIQWVDVEFDQUFBQUFJQmw2b00vOWNISDB1S3hPKzY0WTNNUnhiZVVaVmtYWWdRQTVNQ0Z2L0g2YStLV2JXdmorbzJqOFp2M1BocWYzM1V3VHN6T243Y2dseHhpOG9OdnZhRjZ6ZTk4M2RWeHRzWUdlK09ENzNwVC9QRURUMVdCR0k4ZlBCNVBIRG9lU3pXYTlzazdiOTRSYjdwcVEveWRyNzN1QmZkdkhPNlB1V2Jub1R6VE9hemo4R1FjbXB5Sll6UHpzYXFuS3hyMTVSL0s4RTAzN1VqNzlGaDhaYytSanA3M3lJR2o4ZlNSeWZqbTlQemxKQWR6NUpMcmxjdTdicmtxams3UHhYdisrejFWa05kVGFac3ZsQnpxa2tPRi92RTdicWtDTzk3OWhtdmlmTnUrWnFoYS9xZnYvNGFZbUp5TjkvejJQZFZ5MThTSk9OL2VuY2FhSEVqeWc3ZmRHSTFha2VyZkhlZktOZXRIcXBKelRwNCtPaFVQN3pzYWszTUxjYmF1V1Q5Y2pZMC8vSTJ2aVoxcC9Ua29hYm1IankxbmVhemVlM1E2dnU2cWpmSHB4L2JGZi83MFYrTjh5LzBySDdjZlNQUE91WlpEeDNLNVp0MUkzSHIxeHZqM24vaEtOZi9rTWY1OGhSaXRXOVZYOWFXM3YycExLbHZqWEJ2b1BoazJOZjdYM2xndHQ0ME9WWFBBTC96NUEzRyszYlp6VS9YNi84LzMzSDdPeHdnQTROeEl2MUo0S2kzeUQwM3pBUUFBQUFBQWNKNElNQUlBQUFBQWdHV3VMTXY4emZQSGlxTEkzM1RzRHdDQXlLRXV0U3FZNTlvTnE2TlJxMVZoQlRuODQrQ0ptZXIrcFlZWjVhQ1BXaEV4M044VDNmVmFiQjFkVlFWSlhMRm1LRGFPRE1TNU5ORFRpSnUzaktYWHFVZU9GOWwvWWpybUZsclJLcXYzUUMvNzNIcmF6cHhKY3VYYTRkaVE5a01PS3RrNk12aWlqKzN0YnNSZ2IxY3MxVXphcGlOVGM5SGJWVjhSQVVackIzdlQ5czVHcDlxcHpTeTAybkZzWmk3MkhwMnFncVp5Y05CeXMrclVzYndwdFozdE02dGlWVjlYTkp0bG5KaWJqNmtjT3BYNlFXNys1eUtNSlBlem50UStjL3ZKd1J5YlV4L0kreVNIRitWUWtnc3BiME1PNHNwQllnZFNYK2xKMnpFMXZ4QlRjODJZUE1zQXM1eVRXay85cWIrbkt3WlNmMWs3MUJlOWpVWmNtL3JWK3RTL2NqQkp2WForUW9EV0QvVlg0MEErYmhPcDNSNmRucS9hWVNmV3J1cXQ5a2NPTTdzdWpZblhiaGlKb2JTLzhuYUxManA3M1YwbjU1c3IxcXlLTjF5eHZob2pqcy9NbnpwV2l4dXpYOHhMdGJ2Y3YvSzhjejdsL3BUcjlPcXRhMUw3Nll0SER4eXRRdXZ5SEpxcjBscmkrSEY2Ym5yMkhMcGhxTCthUTBmNmUrTkN5UHN2ZDlkOHJHYWJxVTdIWjg2TWplZnFXUFYzZDFWeitBMGJSNk12WFQrZll3UUFzSFNuNXYwbjBqdVUvVE16TTFNQkFBQUFBQUJ3bmdnd0FnQUFBQUNBWmE3V3JuMHVhdkZ2MDhWL2tNclZBUUNRYkI4YnFzcnQxMjJPK1dZNy92MG52aEpQSERvZXYzWHZZMVZ3eTdHWitWaUtITktUZzBCdXZYcGpGZXJ3VDk1eFN4V1F0SFYwTU02MXI3dHFZMVh1Zm5SdmZPcXhmZkZybjNrNG5qbzhXVzM3SzhVcjVQQ0pITGIwajc3eE5WVUl4VHR2M3ZHU2o3MTY3VkIwblVXd1F0NnZuOTk5TUc3cjNSUjlYY3Yvb3hhM1hiczVIY2ZPdDNPKzFhN0taNTQ0RVBWMHpQL0c2NjlabGdGR09hd3ErL252ZlZ0TXpTM0VSKzdmWFFVMjVXUDB3SjdEOGVEZUkxV3d6M3p6N0FPTXhnWjZxK0N1MjNadVNxKzdPdDV4NDdZWTZPbUsxZjA5Y2FGVjlWNGY4YlZYYlloSDloK05qeis4cDZydkEzc1B4NzI3RHNiUjZibFlxdHcvY3IxZXUyTnQ3RWpqeXJ2ZmNFMXNHMTFWaGE4MHpuTW95VGRldnpYZWNzMm0rSmsvL21JOG5PcjFCL2Z2NmlqQXFMK25rWTdQNXJobTNValY5bk5RekpXcHozUHU1SDZReDlpM3BuN3d0OTUwYlRWbTUvTHhoNTZKUTVPeml4cXpYOHhMdGJ0OERNKzMzSjl5eVhYSzRWOC8rZEhQeHpOSEp1T2phVHpKN1M4SEFpNUZEdlBwcXRmaXI2UjJ2U21OSFQ5NDI0M1Z2THB4K053R0FMNmN2QjluRjFyeDdiZGNGZmMvTXhGL2NOK3UrTnlUQjJMWHhJazRrY1BPbG5Dd2NuaFJEbkY3MWNiVmNmMm0wWGpkOW5XeEl4Mm5OMSs5WVVuekRRQncvcFduMG92S0tIK2gxVzc5UlNMQUNBQUFBQUFBT0c5OGVnQUFBQUFBQUphN1Jqd2R6YmluckpYZlZoVEZhTG9sZjJPN0ZnREFvbnpiMTF3UlUzUE5LaWhudVdyVWE3RnRkRERXRC9WRnA3cHJ0YWgxRmZIbXF6ZFdvUUpYcmhtcXdoY2VPWEFzNXBxdE9EdzF1NmoxNUdDZWtmNmVLbkJocEs4N3RvK3RpdjZlcnVxMkhCUjBQdVhBaXF5M1VZOGowM054LzU2Sm1GdG9WZHYvZlAzZFhkSGRxTVZObThhcTVTM2IxbFpoUmk5bnFLOG50bzVGdlBkYlhoOUw4Ym9kNjJKSDNoL2RYYS80MkwvenRkZFZZU3FkeWdFWFgzZlZobGkvcWovT1ZqNW1OMjRlWFhKOVg3MTFUV3hkUFJnOWplWC9sak1ITEYyL2NYWE1MRFNyb0tFM1hyRStEcDZZaVlPVE0zRmlkcUVLVnNtQlhvc045Nm5YaWxpWGprRnVXem0wWmZWQVQ3VS9jN2hLdmo2VStrWU9KN25ZUmdkN3E3YWZnOFZ1MmI0MmJyMTZVMHpQTDhTQlZQY2NhSGJneFBTaTF0TmRyOGRZV2xmVjk0ZjdxLzQvbkM3bi9qL2NsL3QrbkhkZGFReUwxTFZ1djNaejNMUmxMRFlNRDhUazdIdzhkV1R5Slo4em1vNUZEbHJMNFdXNURlVDJubzlQRG5YTHgreWw1RHJsZnBhZnQ5UTVZYVMvTzViaTFkdldMTGxQTHBlUW1MelBjMXU1T1IybnZMd3B6VGxUODgxcXZzbUJPZWVxM1YxSXVmMDAwaGp4OWxkdHJjSjlidG84VnRYcFpOalBRa3pPTFM0TWNMQ25PMWFsdWVqa1hOR0lxOWVQcE50T3pxR05DOUdSbnFkUkw2clgzcmxoSk5KNWhHcTh5T05ncmxldTM5NWpyNXhma0k5M0RyTWJUdU5lcmxPdVd3NDJYSlBLeWZjS3FXNzE1UmR5QndDY2xONERQRlZHdWF2ZGF1OXBOcHRIYjcvOTl2WmRkOTBWQUFBQUFBQUE1OE9GLzNRRUFBQUFBQUN3SkhlKzk4NWZLWXJpaldXVTI4TWZLVmdSM3ZHT2Q4U0dqUnRpeDQ0ZEFRQVhVZzV6K2RTais2cndoVWNPSEYzVWMwNkdmNnlxd21CeUVNekZrTU1qbXUweVBuTGZycGljT3hrKzgzeHJCdnVxa0lodnVuRjdEUFI0UzhTTDIzWG9lRXhNemNYdXd5ZXFOdlZFdXI0WU9iam94azFqVlNqV3p2VWpWYkJVM3pJSWpua2xwL3ZPL2M5TXhHVHE5L2Z2T2J5bzUrV0FsVnpQSE9pVEE5Q1dnMXlIM1BjLzlkaStsM3pNTmV1RzB6alFYWVUzNVlDMUhMREN4WE4zbW0rT3o4eXQ2SGIzYkRsSTcvTzdEbFloUDN1UExTNlVLZGRsNC9CQUZSVDBjaUZhRjl1OXFWNDV5T2p6dXcrKzRtT0hVeC9MQVU4NUtDMkhJYjAyOVRjQUxsLzMzSE5QODlPZi9uUnplbXE2YTJGaFFZTGR5dkRKS09LVHJWYnI1ei80d1E4K0VRQUFBQUFBQU9lUlQvSUJBQUFBQU1CS1VZdi8xR3EzUGw1RThTL1N0WkVpQ1FDQUY5RlZxOFdyTm81R3E5Mk9xOVlOTGVvNVBZMTZEUFoweDhqQXhRc0M2ZTFxUkxzczQrdXUyaER6elhiTXRWb3ZlRXgvZWt5OVhsUkJNL0JTUmdkN3F4Q2l0V25aaWpLdTNUQ3lxT2ZWYTBXTTlQVkdJeTM3dXh0cHVUTGEyZW0rYyszNmtaaExmV2ZMNk9DaW5uZTZ2bjNkeStjNzZGdFdENmJqMW95aGx3a2xXdFZ6TWxnbEh5TS9GRjE4TzljTngyeXp0YUxiM2JPdDZ1bXE1dEFkYTFiRjlIeHpVYy9KYmJHdnF5dDZsMm1kVHJ0aTdWRE16cmRpM1ZEZkt6NjJ1MTZyeHNDKzdxN29xdXRwQUxDQzVEY3c4K21OOGhmVHJ4QitvOWxzTGk3VkdBQUFBQUFBNEN3SU1BSUFBQUFBZ0JWaVlXSGhTMFZSUEZTdjFkK1RyaTd1RzlnQXdHV3BVYS9GcHBIKzZ2TFdXRnlneEhMUVZUOFpGck5qemVKQ2wrQ2xyT285R1g0enRuS2EvMWs1M1hmV0RhMjhmdjk4SS8wOTZmK2VXRDg4RUt3TWEwK0Y0YXprZHZkc3o1NURMeldqdVgrbHFsMnE5UU1BS3UxVTVzdXlmUHA5NzN2ZjV3TUFBQUFBQU9BQzhPY0lBUUFBQUFCZ2hlanU3ajU0OTkxM1B4TkYzSlhLM1FFQUFBQUFBSkNVSjMyNnFCWC9TN3ZkL3AwQUFBQUFBQUM0UUJvQkFBQUFBQUNzQ09QajQva3ZKN2R2ZTh0dE0yazVIVVVBQUFBQUFBQlVpaWltMHVKQW85R1lDZ0FBQUFBQWdBdEVnQkVBQUFBQUFLd3c3L3ZBKzM1d2ZIeDhXOWt1dnhRbnovVVBCZ0FBQUFBQWNMbWFyUlcxdjRneS9qejkvdUNUQVFBQUFBQUFjQUhWQWdBQUFBQUFXS2tlTHFOOE9nQUFBQUFBZ010UytqMUJPNWQwOFl2cHlxTUJBQUFBQUFCd2dUVUNBQUFBQUFCWWNTWW5KeWY2Ky92L1pWRVUxMGNaZHdRQUFBQUFBSEE1bWt1L0s5Zzkvcjd4SHc0QUFBQUFBSUNMb0JZQUFBQUFBTUNLYzgwMTE4eTNXcTBueXJMY25hN3VTMlV5QUFBQUFBQ0F5MG9SeGIzUmpnY0NBQUFBQUFEZ0lta0VBQUFBQUFDdzR2emdELzdnUWxwOFpueDhmRDdhOFZBWjVmWjBmVEFBQUFBQUFJRExSeG0vVlVSeFBBQUFBQUFBQUM2U1dnQUFBQUFBQUN0V09WMGVha2Y3dnhkUlBKaXV0c3NrQUFBQUFBQ0FTOTNSVkE1SE8rNXBSZXNMQVFBQUFBQUFjSkUwQWdBQUFBQUFXTEVPenh3K09OUTE5RCtLV3JFdGl2akdkRk05QUFBQUFBQ0FTOTJ4SW9ybStJK04zeE1BQUFBQUFBQVhrUUFqQUFBQUFBQll3Y2JHeGhZbUppYjJyVm05NXE0eXlxNG80clowODgwQkFBQUFBQUJjY3NxeXJCYnA5d0UvMFdxM25na0FBQUFBQUlDTHJCWUFBQUFBQU1DS05UNCszdjY1bi91NXVYYXJmYkFzeThmVFRiTUJBQUFBQUFCY3Fxb0VvNFdGaFMrbjN3dDhLUUFBQUFBQUFDNnlSZ0FBQUFBQUFDdmUyUHF4TDB4TVREeFFsdVYxdGFoZDBTN2JvMFZSMUFNQUFBQUFBTGhrcEhQL2YxRkVzU3N0SDczNzdyc25BZ0FBQUFBQTRDS3JCUUFBQUFBQXNPTDl3My80RCtmZTk3NzNIUytLWXFJc3lyMzV0cklzQXdBQUFBQUFXUG5La3lmOTIrbjNBSWZUOHNuQndjSG1YWGZkMVF3QUFBQUFBSUNMckJFQUFBQUFBTUFsbzlGby9GS3IxZnBJR2VWL1RWYzNwRklFQUFBQUFBQ3dvaFZGTVpjV3MrMnkvY3Z2Zi8vNy8wc0FBQUFBQUFBc0V3S01BQUFBQUFEZ0V0SnF0ZVpTT1ZZcmFoTmxXZWJmQTZ3TkFBQUFBQUJncGR0ZlJyazdMUThFQUFBQUFBREFNaUxBQ0FBQUFBQUFMaUhqNCtQNXl3dHg1M3Z2L0ZRUnhicDA4ZHNDQUFBQUFBQlkyWXI0azFwUis4VjA2ZUVBQUFBQUFBQllSZ1FZQVFBQUFBREFKYWlvRjcvYmJyY0gwc1YzNXF0RkZNdjJkd0pwMnhiS0tFK2taU3N0RjlKTkk2bjBCd0FBQUFBQW5COVBwdEpNNTZTM0Yva1UrdkwrWFAxc0t2dktzdHhkRk1YdXljbkpxUUFBQUFBQUFGaEdCQmdCQUFBQUFNQWxhSHg4L1BmeThvNDc3c2gvalhsWmYvbWlMTXRtVVJSSHlpam4wdFhwVkxwRGdCRUFBQUFBQU9mUDdpS0ttWFJlZW5NcXRlWDhSd0NTMmJSOXU0cXkySlhPL2U4T0FBQUFBQUNBWlVhQUVRQUFBQUFBWE5wK29TaUtnU2pqKzJNWkthTmN5SXVpTEg0emJkLythTWNuMC9MbWRNUGJpeWhhNmY0QUFBQUFBSUR6SVoySGZqQ2RoajZSemtYL2NqM3EyOUlOZnlWZDNsaVc1VFg1N2lTV2c3UTlyYlF0RDZkejZQOGlHdkZvQUFBQUFBQUFMRU8xQUFBQUFBQUFMbVYzdDl2dEw4UXlVeFJGS3kxeStXeTA0MVBqSHh6L2IxSEdQYWZDaTZRWEFRQUFBQUJ3UGgxSTU2S2YrY0FIUHZETHpiTDVXK2w2RGdmYWQrcStaWEdPT3Awdkw5TzU5SFRDdkR5UnpxRi9kSHg4WElBUkFBQUFBQUN3TEFrd0FnQUFBQUNBUzFpdFZ2dmRlcjMrMFhUeGdiSXNuNG1McE14ZnNVaUtLTzZOTW40bmJkT3RyVmJyVmVrM0ZmK3hySmQvRkFBQUFBQUFjQkY4OElNZmZLaTd0L3VmOXRaNi8rZUY1c0piMGpuc1g0cVQ1OVJuNGlKS1o5V1BwUDkrdk42dS8zb0FBQUFBQUFBc1k0MEFBQUFBQUFBdVdlUGo0OU81cEl2elJWRzA0dUlwVC81WExxVHRtSnFabWRuOW9ROTk2R0FBQUFBQUFNQkY5cU0vK3FNVFAvSWpQekxiMDlQVFN1ZXdqOFRGUDZkKzJwRXF5QWdBQUFBQUFHQVpFMkFFQUFBQUFBQ1h2Z1BOVnZQYjZrWDkyNHRhOFpQcGV1MVV1UkFPcDdJN3l2aTFWdG42dGJtNXVVTWYvdkNIcHdJQUFBQUFBSmFSVStldWMvay84dlU3N3JqamJXbXhyb2ppMzhiSmMrcERjWUdrMXp6WWp2YVQ3Ly9BKzM4bUFBQUFBQUFBbGprQlJnQUFBQUFBY0Jrb3kzSzJWcXVkYUpmdHA2S0lrU0tLMVhIK05FOHRIMDdsVUhxOWg2T00zWGtidG0zYjFnd0FBQUFBQUZqbTBqbnRvMFZScEF2eHlYUzFWa2I1TlduWm5jcG9La1YxMzdsL3paTVhpbmlrRnJYN0FnQUFBQUFBWUFVUVlBUUFBQUFBQUplNDhmSHhIQnEwUHkwL1g1VEZyMGNadDZicnQ4YjVNMWxFTWRHTzl2dGJyZFlUUC9aalAvYVpBQUFBQUFDQUZlUURIL2pBRjA1ZC9MTWYvK2MvUGpiZk5mOFRaVmxlRlVWMWZyMTJxcHhyVllMUi9NTDhQNm5WYWs4R0FBQUFBQURBQ2lEQUNBQUFBQUFBTGhQMWV2M0kzTnpjdmZXaXZpT0ttQy9Mc3V0Yy9Zbm9VMzhWZWxjcTgwVVVmMXpXeXVsV3MvVkVWMWZYZ1FBQUFBQUFnQlZzdm1kK3BtZ1hkemZMNXE2aUxBN1VhclZ0NmVZZHFZeWswaHZuU0RxL3ZyZU1jaUdkdWovV2FyV21Bd0FBQUFBQVlBVVFZQVFBQUFBQUFKZUo5NzczdlUra3hSTjMzSEhIVlVVVTd5aUtZakRPd2U4S3lpU3RxMHpydkQ5ZDNUZisvdkYvRUFBQUFBQUFjSWtZSHgvUFlVSy8rQ00vOGlNRFBUMDlhOUw1OEcrclJlMWRaWlRYcHRzM3hMbFN4T1BwYlB1aCtmbjVBeC8rOEllUEJBQUFBQUFBd0FvZ3dBZ0FBQUFBQUM0enRWcnRMOHF5L0ZkbHUveUJkSFZUa2NUU0hFMWxYeEhGSjl0bCs4RjZXZjlxbE5WdEFBQUFBQUJ3eVJrY0hKeWJuSnc4Tk5nMStNZFJqNGVLUnJFejNid3VuVy8vWC9QZHFmVEhFcVJ6OWd2cFZQMUNHZVd2UmhGZlRUZE5CUUFBQUFBQXdBb2h3QWdBQUFBQUFDNC9qeGRGMFl3aS9xZXlMRGZGMHMwV1VleHZGKzI3MnEzMko0OGVQN3J2NTM3dTUrWUNBQUFBQUFBdVFlUGo0ODIweU9XQlhEN3dnUTg4MW1xMTFxZkwzNWxLZHl3eHdDaWRzMitseFh3NlovL2x0TTY3QXdBQUFBQUFZQVVSWUFRQUFBQUFBSmVaaVltSi9mMzkvY2Q2dTN1L1hCUkZMZDEwWFNxOWkzejZaQlR4ZUZyKysvVGNBekVmRDUrWU9iRzcyV3hPalkyTkxRUUFBQUFBQUZ3bWpoMDd0cWRlcngvbzd1NytYL0wxV3RUK2ZqdmE2NG9vM3BiT29lZWI2b3RaVDFtV24wN24zditzM1c0L0hRQUFBQUFBQUN1TUFDTUFBQUFBQUxqTS9OelAvZHhjV3N5TjN6RitMQzJQbFZGMjh2Um1XWmJIYXJYYUYrdjErdjczL3ZoN0h3a0FBQUFBQUxnTWZmakRINTQ2ZGZIdS9OK2RkOTc1TFVXWi9rV1JUN3dYaTExUGV2eEVPbGYvY0x2ZG5nNEFBQUFBQUlBVlJvQVJBQUFBQUFCY3BzYmZQLzdEZVhubm5YYytXSmJsamlLSzNoZDVXQ3VWc2lpS255K2pQUDYrOTczdm53Y0FBQUFBQVBBQ3p6cUgvajNqN3hsL1I5VGluNlZ6NjllbWMvRHI4NDNwWFB2elE0ME9wN0s3TE1xUHZmLzk3Ly8xQUFBQUFBQUFXSUVFR0FFQUFBQUF3R1d1TE1zamFUR2N5c1pUMS9PWEtKcnBZak5kUGhGRlRMYmI3YVAxZXYxWUFBQUFBQUFBcjZ5TXlmVC92bFNHMGpuM2RscXVTK2ZjYzRaUnZibzdxUlcxcWJRNFVLdlhwZ0lBQUFBQUFHQ0ZFbUFFQUFBQUFBQ1h1VnBaKzRVb1lrY1o1WHR6ZUZIa3IxVkVQRjFFc2Fzb2k1K05ldnhwdW41OGZIeThIUUFBQUFBQXdDc2EvN0h4VDZiRkp6L3dnUTljMDJxMTFyZmI3ZkdpS0c1SXQyMUk1OS9MZEY2KzFXcTNQdDB1Mi8ra09kODhHZ0FBQUFBQUFDdFVMUUFBQUFBQWdNdGFFY1ZqN1ZiN3diSXNIMGxYdjVDdWZ5U1hLT09qWmIxOE90MDJmK2VkZDVZQkFBQUFBQUIwcE5WcUhhdlg2L3VMb3ZpOU1zcGZUemQ5SmkwL204N0pmemFkaTMrbzNXNVBybCsvZmo0QUFBQUFBQUJXcUVZQUFBQUFBQUNYdFRzL2NPZkhmL3lmLy9qWWZIMys3ZW5xdnFqRlI5Tnk5L2o0K083VGowbVhBd0FBQUFBQTZFdzZ2MzRnTFhMNW1Yejl6dmZlK2NONVdhUi95UU1mK3RDSEpnSUFBQUFBQUdBRkUyQUVBQUFBQUFERWZNLzhURFRqZDlMRnlhakY3cG1abVdNQkFBQUFBQUNjVysyNDUvVEZSdEU0R0FBQUFBQUFBQ3VjQUNNQUFBQUFBQ0QvQmVqcHRQaWRBQUFBQUFBQXpwdjMvZGo3N2drQUFBQUFBSUJMU0MwQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBNkpNQUlBQUFBQUFBQUFBQUFBQUFBQUFBQUFBRG9tQUFqQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUNnWXdLTUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFDQWpna3dBZ0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFPaWJBQ0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBNkpnQUl3QUFBQUFBQUFBQUFBQUFBQUFBQUFBQW9HT05BQUFBQUFBQTRMellzMmRQT1RzM0cxTlRVKzBBQUFEb1FGRVV0YklzaTdpMHRBSUFXSEgyN2RzWEMvTUxsK0o3RXdBQUFBQUFBTTRCQVVZQUFBQUFBQURueWFPUFB0cXVQVjRyNjQxNk13QUFBRHBRUkpFLzIxV0xTMGdaNVVJQUFDdk8vTng4ZlhadXRpdkV0QU1BQUFBQUFQQWlCQmdCQUFBQUFBQ2NKN096czdXaUtLSkkvd2NBQUVBSGF1a0hpYklzTDZtZkpjb291d0lBV0hIYXJYWXRoeGVsdWR4NVRnQUFBQUFBQUY1QWdCRUFBQUFBQU1CNTBtNjNUMzZocHhYMUFBQUF3TTlHQUFBQUFBQUFBQUNYbUZvQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCMFNJQVJBQUFBQUFBQUFBQUFBQUFBQUFBQUFBRFFNUUZHQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJBeHdRWUFRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUhSTmdCQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFkRXlBRVFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBMERFQlJnQUFBQUFBQUFBQUFBQUFBQUFBQUFBQVFNY0VHQUVBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQjBUWUFRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUhSTWdCRUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFOQXhBVVlBQUFBQUFBQUFBQUFBQUFBQUFBQUFBRURIQkJnQkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBZEUyQUVBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQjBUSUFSQUFBQUFBQUFBQUFBQUFBQUFBQUFBQURRTVFGR0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFCQXh3UVlBUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFIUk5nQkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBZEV5QUVRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQTBERUJSZ0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFRTWNFR0FFQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUIwVFlBUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFIUk1nQkVBQUFBQUFBQUFBQUFBQUFBQUFBQUFBTkF4QVVZQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUVESEJCZ0JBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQWRFMkFFQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUIwVElBUkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFEUU1RRkdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQkF4d1FZQVFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBSFJOZ0JBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQWRFeUFFUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUEwREVCUmdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBUU1jRUdBRUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCMFRZQVFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBSFJNZ0JFQUFBQUFBQUFBQUFBQUFBQUFBQUFBQU5BeEFVWUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFFREhCQmdCQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFkRTJBRUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCMFRJQVJBQUFBQUFBQUFBQUFBQUFBQUFBQUFBRFFNUUZHQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJBeHdRWUFRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUhSTmdCQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFkRXlBRVFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBMERFQlJnQUFBQUFBQUFBQUFBQUFBQUFBQUFBQVFNY0VHQUVBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQjBUWUFRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUhSTWdCRUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFOQXhBVVlBQUFBQUFBQUFBQUFBQUFBQUFBQUFBRURIR2dFQUFBQUFBTUI1TVRvNnV0Qm9OTXErdnI1bUFBQUFkR0R2M3IyOTgvUHpsOVFmcU51K2ZmdDBBQUFyenJIanh4cVRKeVliclhhcktOdGxFUUFBQUFBQUFQQXNBb3dBQUFBQUFBRE9rNzYrdm5aL2YzOTcxZENxaFFBQUFPakF4TVJFOTZVV1lEUzJac3pQUmdDd0FqVmJ6V0o2YWpvSEdBVUFBQUFBQUFBOG53QWpBQUFBQUFDQTgrVEtLNi9zV3JOMlRibDE2OWF1QU9DeWNNK243NDZ2UHZoQTdOKzNOK1ptWjEvME1kdDJYQkZYWEhGbDNQeWFyNG5WcTBjREFGN00vbjM3NjVPVGszRXB1ZlhXV3djQ0FGaHh2dkNGTDVRbmpwOVlhTSswRzgxMnN4NEFBQUFBQUFEd0xBS01BQUFBQUFBQXpwT0JnWUhhOFBCd2pJNEtwd0M0WEN3c3pNZlU1SW1ZT0hRb3BxZW5YdlF4WTJ2WFJMdmRpcUZWUStZSUFGNVNWOWVsbDRPYTVqMmZWd09BRlNpZDUyd1d0YUlzb2dnQUFBQUFBQUI0dmxvQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCMFNJQVJBQUFBQUFBQUFBQUFBQUFBQUFBQUFBRFFNUUZHQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJBeHdRWUFRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUhSTmdCQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFkRXlBRVFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBMERFQlJnQUFBQUFBQUFBQUFBQUFBQUFBQUFBQVFNY0VHQUVBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQjBUWUFRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUhSTWdCRUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFOQXhBVVlBQUFBQUFBQUFBQUFBQUFBQUFBQUFBRURIQkJnQkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBZEUyQUVBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQjBUSUFSQUFBQUFBQUFBQUFBQUFBQUFBQUFBQURRTVFGR0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFCQXh3UVlBUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFIUk5nQkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBZEV5QUVRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQTBERUJSZ0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFRTWNFR0FFQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUIwVFlBUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFIUk1nQkVBQUFBQUFBQUFBQUFBQUFBQUFBQUFBTkF4QVVZQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUVESEJCZ0JBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQWRFMkFFQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUIwVElBUkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFEUU1RRkdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQkF4d1FZQVFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBSFJOZ0JBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQWRFeUFFUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUEwREVCUmdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBUU1jRUdBRUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCMFRZQVFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBSFJNZ0JFQUFBQUFBQUFBQUFBQUFBQUFBQUFBQU5BeEFVWUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFFREhCQmdCQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFkRTJBRUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCMFRJQVJBQUFBQUFBQUFBQUFBQUFBQUFBQUFBRFFNUUZHQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJBeHdRWUFRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUhSTmdCQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFkRXlBRVFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBMERFQlJnQUFBQUFBQUFBQUFBQUFBQUFBQUFBQVFNY2FBUUFBQUFBQUFBQUFBSERLOVBSMHRKb0xNVE05RmVkQ2IvOUFOQnFONkU5TGxxYmRia2N6SFpQNStmbVluanp4Z3Z0SFJzZWlLSXJvNnVvT0FBQUFBQUFBQUxpUUJCZ0JBQUFBQUFBQUFBQUFaeHc5ZkNobVoyZGp6OU83NDF6WXRHVnI5UGIyQ1RBNkMrMTJLMmFtcCtQSTRZbDRldmVUTDdqL3B0ZThObXExbWdBakFBQUFBQUFBQUM0NEFVWUFBQUFBQUFBQUFBREFHWTgvOWtnY21UZ1lmL3BIZjlEUjgxN0swTkJ3ZEhYM1ZFRkdBNE9yNHNxcmQ4YjZEWnRpM1lhTlZlQk92VjRQWHQ3Qy9FTHMzN2NuSG5yZy9uUmNmdjhGOTUvY2wxMnhLdTFyQUFBQUFBQUFBTGlRQkJnQkFBQUFBQUFBQUFBQVp6ejUyQ1B4OU80bjQ3LzkydjhiNTBxajBZaE5XN1pWUVR2ZjhJNXZqWnRlODlvWUhsa2R0VnBOZ05FaXpNL1B4WUY5ZStPK0wzN3VSWS9MZDd6N2U2T250emV1dUdwbkFBQUFBQUFBQU1DRkpNQUlBQUFBQUFBQUFBQUFPSy9hN1hiczM3Y25qaHcrVkFYeGJObTJQWlVkOFphdi95dHg0ODFmVTEzdTd1NEpBSmFsSXNxb1ZVc0FBQUFBQUFCNEhnRkdBQUFBQUFBQUFBQUF3SG1WQTR6bVptZXJjdUw0OFppZG5hbVdOOXg4UzB4TlRnWUF5MXVSQkFBQUFBQUFBTHdJQVVZQXdKSzk3NDczZld0WmxtdkxLSWNDdUN3VlVlUlBFcytXdGZMUkFBQUFPS1ZvRlZ2U0R3eU5kTTVnUTJkUGpPdlQvMXRTNlE4QUFBQmdXWHI3Tzc0MWRsNTMvYUllZS9EQXZsaVluNCtQZmZUM1ltcnl4SFB1TzNUd1FCdzVQQkgvOTcvODhWZzFOQncvL2YvOFlxemZzQ2syYmRrV2w0SUg3LzlTL051Zi9hazRmT2hnUFA3b3cyZHVmOVdOTjhmQTRLcDR6d2QvT3RhdVd4OEFLMElaT2J5b0ZoRkNqQUFBQUFBQUFIZ0JBVVlBd0tKOTEzZDlWLzJHRzI2b3g4a3ZFZlpIT3phVVVXNHB5bUk0Z010VExTYmI3ZlpNcmFnMUF3QUE0TFJhYkU3L040cDJzYkdUcDdXTDlwcGFXZXZONFVjQkFBQUFMRXZEdzhPeFpkdjJSVDIycjc4L1ptZG5ZK09tTFZXQTBhRkRCNlBWYWthNzFUcFRqaDg3R2pQVDAzSHd3UDZvMVdxWFRJQlJkaWpWNmNDK1BmSDA3aWZQM0xaNmRDeUdSMVlId0lwU0NDNENBQUFBQUFEZ3Bma0NBQUN3YURmY2NFTU9LdG9XN2ZpN2FYbHJPOXBYUlJHRFpWRUdjUGtxYWtXVWJlTUFBQUR3SW1xZFBUeC9COFo1QmdBQUFGamV2dTYyYjRqdit1Ni8wOUZ6L3ZiMy8yK3hmOS9lZU8rUC9JT1luRHdSVHp6NjhKbjdabWRtcXZMdmZ2YkQwZHZiRzcveVAvNDRBQUFBQUFBQUFJQ1ZRNEFSQVBDS2Z2Wm5mN1puNHVtSnRiRVFHNHJ1NHRWbFVXNHZ5M0lnbFhwUitPTmFBQUFBQUFBQUFNQkw2K3J1cnNLSlhuWGp6WEhvNElIWTgvUlQwV3d1Ukt2WlBQT1lxY2tUTVRjN1V5MXI5WHIwOWZVSEFBQUFBQUFBQUxEOENUQUNBRjVSRlY3VUU5OVpSdm42c2xWKzkrbmJoUmNCQUFBQUFBQUFBSzlrN2JvTk1iWm1YYnpuZ3o4ZDkzM3gzbmowb1FmajJORWpWVG50d2Z1L1ZDMGZmL1RoR0JnY2pDdXZ2allBQUFBQUFBQUFnT1ZQZ0JFQThLSis2SWQrcUdkc2JLeUlWcnc3WFYxWFJ2bTJWRFlYSWJRSUFBQUFBQUFBQU9oTS9pTkpQYjI5TWJwbWJienVUVytPQisvLzhuTUNqRTU3K0t0ZmliWHIxZ3N3QWdBQUFBQUFBSUFWUW9BUkFQQ2lSa2RIZTlLaUZrVjhYeG5sY0xyOEd1RkZBQUFBQUFBQUFNQlM1QUNqM3Q2K0dGdXpObDcvcGx1cjhLSUg3Ly9TQ3g3M3lGY2ZpTG5aMlFBQUFBQUFBQUFBVmdZQlJnREFjNHlQajI5TGl6VmxXZjZkZHJzOVVFU1IvNlNoOXd3QUFBQUFBQUFBd0ZrYkdoNkpWOS95dXJqdlM1OS8wZnUvK1BuUFJLdlZDZ0FBQUFBQUFBQmdaUkJHQUFBODM1cFV0cFZsK2M1VGw0Y0RBQUFBQUFBQUFPQWM2T3JxaWkzYnJvamg0WkVYdmYrWjNidGk3Ym9OQVFBQUFBQUFBQUNzREFLTUFPQXlOejQrM2lqTHNyOVcxbTVyUi91MmRxdjlkVVZSWEZWRXNTWUFBQUFBQUFBQUFNNmhScU1yVmcwTng0NnJyb25YdmVuV2VPTFJoMlBpMElFejkrOTVlbmRzM1hGbEFBQUFBQUFBQUFBcmd3QWpBQ0NLb3FpVjdYSWdMZGRFRVd2VFRlc0NBQUFBQUFBQUFPQThxTlZxMGRYVkZiMjl2VkZ2UFBkampNMW1NMXFwQUFBQUFBQUFBQUFyZ3dBakFMaE1qWStQZDZmRjlkR0tHOHVpL0dBVU1aeXVqd1FBQUFBQUFBQUF3RVUwTlhraTd2dml2YkY2ZEN5MmJOc1JBQUFBQUFBQUFNRHlKY0FJQUM1RDQrUGpPOUtpdXlpSzE1WkZlVVZSRnIxcDZYMEJBQUFBQUFBQUFIQkJOQnFONk8zdGpYcWovb0w3eXJLTVpuTWhXcTFtQUFBQUFBQUFBQURMbTZBQ0FMZ2N0ZUw3b29pUmRyVC8vOVgxSWdBQUFBQUFBQUFBTHBpQndWV3hic09tZVB6UmgxOXdYdzR1bXBxY1RJOFpDZ0FBQUFBQUFBQmdlUk5nQkFDWGdmSHg4ZDdJOC81QzNCSmQwVisyeWxkSEdiMkNpd0FBQUFBQUFBQ0FpNkhkYXNYOC9GeTAydTBBQUFBQUFBQUFBRll1QVVZQWNIa1lyRW85dmp2YWNWMFVjVnNBQUFBQUFBQUFBRndrQ3dzTE1UTTlIYTFtTXdBQUFBQUFBQUNBbFV1QUVRQmN3c2JIeHpmRVFsemRhclhlV2hURmRVVVVyMDQzcndzQUFBQUFBQUFBZ0l0b1lXRStwcWVuWGpUQXFLK3ZQelp2MnhHRGc2dGlxWTRjbm9oMnV4MWYrdnhuWTM1K0xrNGNQeFp6c3pNeE5Ua1pYZDA5MFdqVVk5MkdUZEdkTHIvNmx0ZEhyVmJFNnRFMWNTbkoremVIUkQzODFhOVV5OGNmZmVqTS9oNFlISXhOVzdhbmZiQXhycng2WjdVZkdvMEwrNUhTNDhlT3BISTBkajM1UkRvMnMzSDlUYStPbnA2ZVJSK0hWcXNWYzNPemNmalF3WGg2OTVQVnNaMU54L2pBdnIzVk1jL3E5WHBzM0x3MWVucjdVbnNhakMzYnRxZHlSWnd2TXpQVDFXcy9lTitYVHJXNzQxVWRjemt0YjAvZXJyRTFhNnUyK05vM2ZHMWNTSG03UHYrWlQ2ZDlOWnYyMllrejI1ZmJSTjVQbXpadlNkdlhpRGZkZXZ1aTFwZVB3OTVuZHNmUm8wZXJmVDl4NkVCMVRQSzZjci9hdUhsYjZ0TjljVXVxWjY1M1QwOXZBQUFBQUFBQUFKY1dBVVlBY0NtYmpjSG9pcXVMb3JnOVhYdERLZ05oL2djQUFBQUFBQUFBTHJJY2VySXdQeCt0ZHZzRjk5WHFqUmdkSFl1dTd1NVlxcG5wcVdnMm0vSFFBL2VkQ2JYSllTMFRodzVHWDM5L0ZkaVRnM3NHQmxmRjFUdXZxOEo3Vm8vR0pTWHYzMXpuM1U4K1hnWEtmTzZlVDFhaE5kbnd5T3E0NlRXdlRZK1ppNjNiZHB3S0w3cXdIeW1abVptSkk0Y1B4NjdISDQxalI0L0VwaTFiWTJob2VOSEhvU3piVlIyUEhUMGNqei82Y0hWc2MzMXpVRk1PTThweUc3cnUrcHVxY0o2eE5ldXE0MzArQTR3V0ZoWmllbXFxMnA3VDdXNy92ajNWOHJScnI3K3hhbi9iZGx4WmJjK0ZEakRLK3l4djMrbitjSHI3Y3FCUzNwNnB0TCs2MDM1YmZJQlJzenFPZVQyUGZQV0JxcjNsa3ZkNW85R1Y5ditOTVRLNnBtcHY3ZFRPQkJnQkFBQUFBQURBcFVlQUFRQmNZc2JIeHdmVFlsdTA0N3VqaU8xbFdiNnVGclhOWlpSOTZYSzlLSW9BQUFBQUFBQUFBTGlZY29qSzVPU0pXRmlZZTg3dDZ6WnNpalZyMTFYaEo3VmFQVHIxeVkvL1NVd2NQQkQvN2RmK2N4V0trd05hMnUxMnpNL1BWWUZHclZScTlYcmt6MDk4OGQ2L2lIcTlFWC80ZS84OSt2cjY0MXUvNDkxVnFNeXR0My9Eb2w3cnF3L2NGdzg5Y0g5ODlwNVBWc0V0enpZMU5SVzduM2kwQ3JGNXRoeXVrME5kL24vZi8rNlhYTzg3dnZWZDhibzN2am11dWU2RzZPMWRmTmhMV1piVlBzM2hNWis4NjJOcG03NVNiZGV4WTBlanViQlE3WS9UY21EUmZWKzh0d295K3BWZit2Znh4amUvTmE1OTFZM3gyamU4S1ZhUHJsbjBhK1o5K3VEOVg0cGRUendXLys5LytEY3Z1UDhILytHUHhOcDFHNnJ3bXBQaFFnOVg1V01mL2QwNGVuZ2lqcVNTYjgvcjJYN2wxYkY1eTliWXRHWGJLNzd1cHo5NVYreDVlbmY4OW0vK1dwdzRmclJhVDI1VDdYYXJDa1pxdDFyVjQrcnBXT2NRcTd6UDY2bk82emRzck5yWTEvK1ZkOGFyYjNsZGJObTJvd29UT2x0ZnVlK0xjVHp0NTEvN3ovOGhEdXpiRTN2M1BGMjF1eHdRTlorMksyL2JhYmtOWkQyOWZkWHh6ZnRpNTNYWHh6dS83YnZTdmg5YjlQN1A5Yy90KzkvOTdFL0Z3UVA3bjNQZjlUZmVITi8rN3UrdFFxRnljTk85bi9sVUZUTDBxNy8wNzJKK2JqYWVmbXAzMVJlYXpZVXoyNWZEbm1xMVdyVnZzOXcrTm03ZUV0L3lycjhlZzRPcnF2MTIydDVubmtyN2VUcXQ3K2RqYm00dXZ2RFplNnEyUGpjN2UyWjV1cC9sOWVUUW9vOTk5UGVxNC92WHZ2TnZWdnM5QjJjQkFBQUFBQUFBbHdZQlJnQnc2V21VQytWUVVTOXVMS1BjbXE1Zmw1YlZIY0tMQUFBQUFBQUFBSURsSUllNzVBQ1Zzbnp1N1RuUXBidW5wd3FjV1lvY1hwU0RYYjd3dWI5NFRtRFB5OG1CUDZ1R2h1UFZyMzFERmVpeldDZU9INnRlNjR2cHRYSkl5MkpNVFU1V3kzdE9oY1M4bUJ5c3M5aHRmN1ljWUpUMzZlRkRCK09KUngrT0IrLy84c3R1Vnc2L3lhRTEvZjBEVmJETTZ0V2pNVCsvRUozSUFUaDVXL2M4ODlTTDF1bmQzL3QzendRRTVaQ2kvTmduSDMrMDJtZjU4clBybVVOdjVwOFY5UE55Y2gxUDd2dDdxbkNxbWVucERwNzNWTHp4Njk1NjVsaWNDem04S0svN0MybDc4akszalpmeS9DQ3B2QjI5dlgzVmNtQndWU3hXRHF2SzY4cUJRNGVlRjJEVW5ZNXJ2dTkwNkZBT2VEcXdiMjk4N3A2N3E3NzNjdHNYc2JmNlA0Y1c1ZGZJMi9YOGtLY2NYcFJ2ejIxc05oMjNsMnRuZVgva1lLUUQrL2VtYlRwY0JZU05yVmtiQUFBQUFBQUF3S1ZEZ0JFQVhDTHV2UFBPTnhWRjBWdTJ5MThxNmtWUEdlV0dLQU1BQUFBQUFBQUFZTm5JZ1RjNStDU0hCcjFZNkVrT043bmk2cDNScVk5OTlIZmpUejc2ZTJuNWUzRmczNTduM0pkRFlhNU02endkMWpNOVBSVUw4L1B4K0tNUG5RbXh5WUV1LytabmZxSjYzQ2Z2K2xpOC9SM2ZFdC93am0rTmxTS0gxZVE2Zk9CSC8vY3FyT2JwM1U4dTZubDVQeHhMNVZkLzZlZXI2eC82bVlpYlh2UGFxcHhMZWYxNWYvLzdmLzB2NDJ6ODZSLzlRY3lrNC9mM3YrK3Z2K0MrdnY3K0ttZ250NS9CVTBGQU9SRHBvUWZ1T3hOeWREbzA2Zi84My85ZWRmOS8rTFhmamZVYk5pNjV2ZzkvOVN2eHlGY2ZpSC8xTDhhcjViUFZHNDFxTzlhbDlhOC9GU1NVZlRWdFQ3WGYwM2JrVUtmY0YzTDVyNy84SCtPN3YrOEhxdkxzT3B5TjMvelZYMHh0WWRlTDlvdFhrdnZuQS9kL0tUNytzWS9HTi8yMTc0Z2ZmZjlQeHBjKy81bHFmVC8vcjMrNkNzbGFyQnlhbE91Ymc2dnlzZnYyZC8vdCtJNTNmMjljYzkwTjFmNEhBQUFBQUFBQVZqWUJSZ0N3d3YyamYvU1Arb2FIaC92U3hRMnA5QlpsMFNpTHNoWUFBQUFBQUFBQUFNdE1EcFNabWp4UkJjcThtQncybEVOb0ZxdTVzQkR6QzJtZFUxUFZlcDl2WkhRc2hvWkhZdDJHVGRIVjFZamV2djZZblptSmhmUzhnd2YyUmExV3I0Si8vbkw3NXFyMW5DNERMeE1pMDlQVEc2dUdobUxOdXZXeFpkdU81OXczUFRXWnRta3lXczFtRlZKejVqbTl2ZFZ5N2JvTkw3bmUwYkcxMFh2cWNZdVY2NUJMM3Y1V3ExWGRWcXZYbzE1dm5GbFhyWGJ5NHlTNVhxMTJPOHBVbnU5MHdNKzVrZ09yY3Nucm5KMmRqYVVxeTdJcVJ3NGZxZ0tNbnEwcnRaZnU3dTRZV1QwYWc2dUcwcjVkZithNG5RNEtPaGtXMUVyN3BobnRVL3NuTzN6b1FEUWE5ZWpVNmUzSllWaDVtNTR2di83QXdFQ3NUc2N5dDQ5Y1R0dVF0aVZ2MS9UMDlLbHQvTXUra05jM2tiWnBLU0ZlenpZN08zTXExT3A0ZGJ3YmpVWlZCb2VHcS91ZkU0NlU2dEZPSmJlZDAvdnIyZlhNNFVPVGFSMEhEK3hQMjNhd3FtOXVTMFVxUTZmV2w0UEI4dlhUYlN3NzNhOWVyRDNOemt4WDY4bExBQUFBQUFBQVlPVVRZQVFBSzl6dzRQQzdvaDF2S0tQOG45UFZvU2dDQUFBQUFBQUFBR0JaT25wNEluNzdOLzlMUFBUQS9TOTYvLy8wblg4ekJnWUhZN0gyN1gwNnZ2VDV6OFVmL3U1L2k5Ly9INy94Z3Z2LzZSMC9Yb1VYZmNNN3Z1VUY5LzNxTC8xODdIN3k4ZmczUC9NVFoyNTdldmV1cWt4V0FVYVQ4ZlozZkd1czM3RHhSVi83NXE5NVhWVys1L3YvM2d2dWUvRCtMOFVIMy9NamNXRGZubmo0cXcrY3VYM25kVGZFOE1qcStKbWYvK1VxYU9kYytlWC8rRytyY0tobjc5YzFhOWVsYmQ4VU43M210ZFZycmhvYXJnSm1jcjF6d00yQmZYdGZzSjY4RHo5NTE4ZmkxdHUvSWM2RlhQOGNpcFAzY1E0eVdxcVptZWxxUGYvdVp6OGMrL1k4L1p6N3RtN2JIbSs2OWZaNDU3ZDlWMVhYSEI2VXczcXlITDZUZzNRKzhhZC9XRDEzZjlxZVo5ZjdYLzJMOGZUWXJ2anpMejRXblZoWW1JK1o2ZW40c3ovNlNQeml2LzIvcXZaeVduNzkzSTYzN2JneXZ2djdmcUFLcmVydDdUdHovL0cwUFRrODZtOTkyemVlT21iM25ibnZ6LzdvRCtMem4vbDAvT3d2L0VwOHpldmVGRXYxU0dwemVaOC90ZnZKcXMvbGRyQnB5N2I0ZXovOFQ4OXMzMm01TGN6TnpzWTluN3dySG4vMDRlcDVwME9IY3RoVDNuOTNwemF4Ni9GSHo2d3Y5OUVjWHBUWDE5Yy9FRi8vVjc2NVd1L1ltclZuMXB2NytaNm5kejluZmFmZC9mRS9qZnUvOUlYNDBmZi9aR3kvNHFvQUFBQUFBQUFBVmpZQlJnQ3d3b3lQajNlblJmNmszclpvcGxLTDE1ZnQ4bFZsbEQxRkliMElBQUFBQUFBQUFGaCtXcTFXSEQ5Mk5QYnVlVHErK3NCOU1YRncvM1B1MzdKdFIzUjNkOGZxMGRHMDdGbjBlbzhkUFJyM2ZmSGVLcGptMmRadjNCU05ycTY0OHVxZEx4bUl0UE82NjZ0Z254eThrb051WnFhbnp0eDM1UEJFRmVieTF2bTVXQWtPcCszTlZvK09WWFhLNFRrYk4yOUpaV3RzM3JLdHFtTmZYMTlFVWNUYjMvRXQxWEg0aTA5K1BPWlQvWEpRMDJrVGh3N0UzT3hNVmY5NnZSNUR3eU54TnZidjNaUFdmekxjWjNoa05CMlBhNnRBbjN5NU4yMVBYMS8vbWNkZWNkVTFML2w2aHc4ZFRNZjZjRXluWXpSLzZwamtNS1o2bzFHRjV1VGdvcnpzU20zbzJSK2Z5WitseWJmbEVLb2NjblR2Wno3OW5BQ2o2ZW5wcUtmMTVHTTltTnBKRHJ0YWpCeGU5UFR1SjZyOWxMZW5MTXZxOXYrUHZYOEJrT3NzN1B2djMzUG1QanQ3djJpMVdxMVdsaXpMa29YbEM3WUJBWTR4anBzUTRFOXdHMmliT0NraFRRcUVOR2t1RFVoakF3RmEzb1NHcG1uY05MaHBTdE1DS1FtUUdBZU1BQU0yMk1iR3RyQmwzYnhhU1N2dC9UcXpjem5QK3p4SFhpRlprcjI2em1yMys3RWZQWFBPbVRuenpEbG5kMmJQODh6ditHTXVWMThmdGNmdkMvL2NmanNlTCtIdTQrL3YyK09EZlk0UE1EcTZQeWJWdDI5dnRJMjZlMWFkMGMvRGo5ZFRpbzZKRnRjR1gyNTh6ZXRVNzdhdC8zbEl2R2g5dm4yK25mNW4wTmYrbVBHQlM4Zi9UTTJ0NytqUGFLdGUrYXJYdXRmWm9DczJYQlc5SG45OCtmMTZQTDgvNnh2OGZUWnA4UEFoN2QzOTNFbXYwNzkrdnczOWZuL3hkZ0lBQUFBQUFBQUFBQUJ3NlNEQUNBQ0FTNDhQTU9wUlZXOVZvTGRhYTFmS3FNV0k4Q0lBQUFBQUFBQUFBQUFBQUxBd1Zhc1Y5ZmZ0MCs2ZHoranI5Lys5aXNYQ0NjdXZ1K0ZWVVFoS2Q4OXFuWW0rZlh2MDVTOThOZ3BDT2Q2R1RadVZ6ZFpGSVRHbmMvMU5XNkw2WS9uZlZhVlNPU0hBeUxlMVhDcnBMVzkvUnhUc3N0QWRjTzMxNFRQck4yeUt3bk4rK3ExM1JDRkd2cnpZZFRlOFdqdWVlc0k5NXZrb1BPYjRBS09EL2Z1anV2K0Y5WjFyZ05IVFR6Nmg5QXZCTmo1WXliZkxod1Q1OEtpT3p1VmFOcy9BSU44ZUh6STBPVEVlaFFkNUpnaWlmYnhtM1pYUmVqUFo3RWxoUHo3QXlOOW40eXV1VldmWFNsVXJaVDMydmU4Y1d6NzJRdkRUUXc5dWo5cDE2KzN6YTgvdzBLQ2VlT3lSS01Sb3JqMmVEMlJxYW02TjJ1UERsZnh6djloY2FOUFB2K3ZYTkhDd1gvLzNyLzdpMkRLL0xsK2VmUHlSS09ESEgzOW5FMkRrSCt1TFAvNTlhTkV2ditmZlJ1RlJwNUpJSktPeThSWFhST1Z2UC9lL05YVGs4QWtCUm5Qcjg0RktmcC85czMvNVMyNGZianpsOFRYbkZkZGNIOVhQN25ncTJuL0hCeGpOdlU0ZnBPV1grU0FrQW93QUFBQUFBQUFBQUFDQVN4Y0JSZ0FBWENMZSs5NzNwbG9hV3E1UlJSMWhFTjRpbzZ1TXpESnJiY1lZd29zQUFBQUFBQUFBQUFBQUFNRENVaXJOS2d4RDdkdjlYQlF3ZE44WC8wYUhCdzVGNFVYVlNpVzZqdy9JU1djeXV2RTFyMWRUYzh1ODExMnRWalUwZURncWZ0MHZEa1JhdldiZHZNTjNmQWhMc1ZqVXdmNitZL044cUk4UGNQRUJQMzc5OVEyTkNvSkFDNVVQTGZJQlVEN3d4Z2ZNK05ma0E0Tk9KWlZPcTdXdFhhKzg2VFY2N3RrZFVZRE1pL2xnS0I4STVBT1J6c1hCL3VjVmp5ZjBzei8zTDlYaW52TjY5NXgxdVp4Ny9nN2xYSHZuYStEUVFUMzN6Tk9xbEV2SDVxWFRtZWgxdGkvcmpGNVRMSGI2SWJFK2pNbHZqNDRYdG8wUElQS0JQSFA4NnowVEUrTmpVWHRHM0hxTzE5VzlVaXRXOWtUdGVibmp4YmZISDdlK1BmNTRHeDQ2Y215Wi96bngyNjN5d3MvSm1XcHVhWTJDdDE3eitqZG93NmFyM1hUYnZCL2IxZDF6eXVBbDcvTDFHNk5qd3QvbmRNZlhxZGJuZncrY1NybGNqcmFCdFZZQUFBQUFBQUFBQUFBQUxsMEVHQUVBY0lsb2FXbEpLZFJOTXVwMWszY2FHWDk1dFRUaFJRQUFBQUFBQUFBQUFBQUFZQ0VxbFVwUlVOR1BudjZoQmc0ZTBPZi8rbitxVWlscnRsZzhkcCtHeHNZb1hNVUhHTFYzTEp2M3VxdlZpbzRNSE5MUTRHQVVNUFJpcTlkY0hvWDB6TWZSQUpsSlBYTGNQRC90eStqSVVMUitIdzYwMEFPTWZHak5PKzk4OTh2ZTF3Zi90RVpoUWx1aWdKeHZmZjJySjkzSEIvcjQwS1p6ZGJCL2YxUy83ZWQrUGdvdXVtenRGVG9iQTRjT2FPY3pPNkxBbXprK0pNanZ1NDVseTZQWDlGS1N5VlJVT2pxWEh3dXNlbkdBVWVwbDFuRzhpZkhScUQzREp3VVk5YWg3NWFxWGJZL25BNEI4eUpkdno1R0JneWNFR1BsajIvL3NuRXVBa1Q4bVh2UDZXM1RkRGE4K284ZXVjSytoNFRUN2Z0MzZEZHB5ODYzUmZlWWJZTFNpZTZYQ3NIcktaVDZReXY4K0lMOElBQUFBQUFBQUFBQUF1TFFSWUFRQXdBTDJoMy80aDVtSmlZbVlxbnFmRGUxcUdkMXNaZE5HeGwvbWJPR09pZ01BQUFBQUFBQUFBQUFBQUl2U1gvenBKL1c1ejl3N3IvdjZrQ0ZyYlJUeU1sc3NhR3BxTXByMk9qcTd0S3h6dVg3cUxXL1hOYSs4U1QyOXE4OG9JTWdIdXp6NStLUHEyN2Y3bE10OTBJb1BrNW1QMVd1djBNVDQyQ21Yalk0TVIrRXl2cjN4K01JZGNublRsdGNyVjk4dzcvczNORFpIajNseEFNLzVkdE9XbTZQd3A5VnIxeWtXaStsc0hlenZpL2IzOGVGWG1VeFdsN24xK2xDaStmTDM5Y0UrL25YNy9UckhyL3RNOXUvWTJGajBtS0k3cm8rM3NxZFhxMWF2bWZkNjR2RkUxSjZkejJTaVFLUTVlM1k5RzczbTJSZXRmNzU4UUpYZnY4dVdyOUNaOG8vTlpMTUNBQUFBQUFBQUFBQUFnUGtpd0FnQWdBVXNDaS95NzlkR200MU1qNVZkS3dBQUFBQUFBQUFBQUFBQWdCclo4ZVRqT2gvUzZiUWFtNXExNXZJcnRPR3FxNk1nbHpNSk1LcFdLaG9mR3owaDBPWjRmdDIrekVjdWwxTzVOSHZLWmFWU1NjWFRQTWRDMHRyV29aVGJwdk9WU0NTaXgyU3lkYnFRZkVpVkR6REt1WEl1cHFlbW92MTlQQitJNU5lZFRDYm51eHAzM0dXaTQ4SUhZQjNQcjN2S1BjZDgrZVB1eGUzeGZIdlNtZm1ILy9qUUpOK2U5SXYyM2ZUVTVHbVA3Zm53KzlYdjMwUmkvdHRtVHNwdG96QU1CUUFBQUFBQUFBQUFBQUR6UllBUkFBQUwwSWMrOUtFMWxVcGxqYlgyMTExWlpXUld1OW56SDZVSEFBQUFBQUFBQUFBQUFBQ3dBTVhpY1dXemRlcGRjN211ZmVXcjFOTFdyclBoQTJnTzl2ZHBkR1Q0bE12cmNqblZOelJxUHJxNlY1NDJCT2Y1dmJzVkJERmRmZTByVHdxWndjdGJ2WGFkbWx2YWRMYUdCZys3Y2tRVDQ2Y0tDOHJwaWcxWGFmbUtsVHBUTDk2WEV4UGptcG1aZnRuSGxVcXoyck5ycHc0ZDJIL0s1ZjcxcnV6cDFibWFtWFp0TWFZbVFVSit1L3BnSldDeHM3SS9LYU9TdS9sSkFRQUFBQUFBQUFBQTRKelF3d2dBd0FKVXJWWVR4cGhzR0lhdGJyTGJGVDlxaWdBakFBQUFBQUFBQUFBQUFBQnd5UXVDUUlsRUlncVJpY2NUT2xzK3hPaDBBUzgrZE1nL3ozejROc1JPRTlnU1Zxc3FsMmFGcytPRG9VNFhEalVmMVdqN2wxd2RubWI5S2NWaTV6NFUxcnJqeU00ekxPaG9lNm82WFhzUzUvQjZqN1hIV3YrUGFpSG1mbTdtKzdNRFhPSnlycFFFQUFBQUFBQUFBQUNBYzBhQUVRQUFDMEErbi9lamZocFUxbWJGOUZZYjJodmQ5RTFHUmdBQUFBQUFBQUFBQUFBQUFBdkY1ZXMzYWxubjhqTjZ6TVRFdUdhTFJUMjc0MGxWS3hXTmo0M3FhL2Q5S1NyZFBhdlUzTkttVDk3elYycnZXS2JHcHVaNXJiTXVsOU03NzN5M1NxVlpGV1ptVGxyZTF0R3ArZkxQV1hUdHcvblgxYjBxMnE5bnl4ODMvbmdwbmFjUXFXV2RYZHEwK1RwOTlSKytlTkt5OGJFUlBiajlxK3B3OTFtM2ZzTXBIKzhEczN4N0NqTlRPaDk4MkpGdnorakkwQ21YZi8raGIrdlF3WDY5OHFZdEFuRGVSVC9vVzdkdTlXOGllNHcxZnk2ckhYZDkrSzc3QlFBQUFBQUFBQUFBZ0ROQ2dCRUFBRFdXeitkejF0ckFHSE85QW0xd3QxZklxRUVBQUFBQUFBQUFBQUFBQUFBTGpBK2p1ZktxVjV6UlkyYW1welU3TzZ0c05xdkN6TFQyOXowZkJkS1VTeVZYbHpRMU5hazl1NTdWNEpFQnZXckx6Zk5lcnc4eFNwWlRTaVpUSnkyTHgrYy9QTkt2SitjS0ZoNGZHRlNwbEdYRDZrbkxqQW1pL1J5UHhYUXgrZlpVcTlWVExvdTV0cHpKc1FkZ1FRZ0NCVmtydThZVmUvZmRkMCs2M3oyRGhVSmg4T0dISDU3ZXZuMTdSUUFBQUFBQUFBQUFBSGhKOUpJQ0FGQjdhMTNwc0tHOXh3U21UbFp0QWdBQUFBQUFBQUFBQUFBQVdJRGU5bk0vcnp2ZStRczZVNVZLUlFmNys3VHptYWYxeVkvZHBjTURCM1ZrNEZCVXBFUDZ4SWMvRUFVUmZXbjdJL05hbjcvdlpXdXYwUG5nMTNPcUVDVFVuZys2bXA2YWNzZlB5WUZCUGl5b0xsZXZaT3JpN1RzZnFPVGJVNXFkUGVYeWJGMU9tV3lkQUZ3NmpFekt5cTUyTjk3akpndlZTblU4dE9HZlpES1o3VGZlZU9PVDI3ZHZIeGNBQUFBQUFBQUFBQUJlRWdGR0FBRFVTRDZmWDYrUzBtRVkva3dRQkQ2NHFNNWFteFlBQUFBQUFBQUFBQUFBQU1BaUV3UkJGRGJUM2RPcjE5MXltMzd3NlBlaUlKaGlzYUJxcGFLSjhYRUZzWmllMmZHa0dob2ExZFhkSTZCVUtybmpaTklkSStXVGxpV1NTVFczdExqaktxY3pOVDA5cGJOaG93Q2p5ZWk0UFpXR3hrWTF1Z0xnMG1TTWlWbHJNKzQ5NnpvM21jN0dzeXZ5K2Z5NEsvY0pBQUFBQUFBQUFBQUFwMFdBRVFBQXRWTFZUWXFwMThoc3M2RVZBQUFBQUFBQUFBQUFBQURBWXVVRGpGcmIydFhZMUtSZmVkKy8wMmZ1dlVmOXorL1Y4TkJnRkFoejZNRCs2SDVmdi8vdjFkVzlVbTk1K3pzRkZHYW1vMk9rV0N5ZXRDeVpUS203WjdVdXBqQU1YemhtVHgyQTFMVmlwWmF2SUh3THVJUWxqVEZKRzlxM1dObTNtSmg1d29SbTNNMG53QWdBQUFBQUFBQUFBT0FsRUdBRUFNQkZrcy9uczY3S3FxSXRNbHB2WlYvdjZrNEJBQUFBQUFBQUFBQUFBQUFzRWJGWVhKbHNWcGV2MzZDZnVPMm45SjF2UHFEbm50bHhiUGtEOTM5Wm02NjUvcUlHR00zTVRLdFFtQkdXanJhT1pTZk5xMWJENkZnb2xXYTFVUGpqa21NVHVQaU1ZeDEzczlmS0Z2UDUvSitIWVZnMG9mazdFemY5Ym5xSEFBQUFBQUFBQUFBQWNBd0JSZ0FBWER4SlYzSUtkTDJydDdoeXRTdE5BZ0FBQUFBQUFBQUFBQUFBV0NLTU1Vb21VMXJXMmFYMUd6YnB5Y2NmUFdINXN6dWVVbjNEeFIxT1VTNlZWQ21YaGFYTlo1WDRZNkZhV1RqSGdqOHVPVGFCMnZBaFJucGhmSjhON1M4WW1SRVo3YklWbjJza0Fvd0FBQUFBQUFBQUFBQ09RNEFSQUFBWFdENmZiMUZGTjRSaCtHbzMrV29qczliVmpmSmhSZ0FBQUFBQUFBQUFBQUFBQUV0UWQ4OHExZVZ5K3ViWC8vR0UrVk5Ua3pwMG9FOWZ2ZTlMV3RiWnFVMmJyOWY1TmpFeHJzTE10Qjc5M25jMU5qS3MrNzcwQlUyTWp3bExXN2swcXlNREIxWGYwS0NGWW5qb2lOTHB0QURVbHJVMlpvekp5ZWpmdURLeTdZUGIzaHNxL0ZvaWtmaGFvVkE0K05HUGZuUllBQUFBQUFBQUFBQUFTeGdCUmdBQVhIaEpHWFc2ZXAwcmZsUmRKcG9IQUFBQUFBQUFBQUFBQUFDd1JHV3lkUXFDbUpLSnhBbnpxNVdLQ29WQ0ZDU1R5MTJZYTBPVlN5WE5Gb3NhT0hnZ2VwN0hIM2xJWVJnS1M1cy9Cb3J1dUtpNFkzQ2g4TWRweVIydkFHckxPSzdLdXVJdlhsaVMwVXhnZ2o3M2UrT1JWQ3AxV0FBQUFBQUFBQUFBQUVzY0FVWUFBRndBMjdadGF6REdkQ2pVSjJ4b1cyVzB4Y2dJQUFBQUFBQUFBQUFBQUFBQVVqcWRpY3JxdFZkbzArYnI5TXlPSjZOZ0lXOTZhbEpQUHY2b0VzbWtidEs1ODZFMFBxaklQOGZYNy85N1BmVGdkdTNadGZQWThpMDMzeHJkNTVHSEhoU1doc0wwdEFDY0FlditVMVFZQkhmMDRvVkp0elYrelZyN2ErNzJNL210K2NOVlcvM05NQXlIUHZLUmp6d3ZBQUFBQUFBQUFBQ0FKWVlBSXdBQXpxTjhQcDkrNFdhWHl1b0lZMkZXVm9takYyQUNBQUFBQUFBQUFBQUFBQURBOGZ5UUNoTUVKOHdMdzFDVlNqbXF6OWJjWTMwWTB1VEV1QTRkN05mSThGQTBYUzZYbytkc2FHaU03dFBXc1V5enhhS3crTVZpc1NnWWF5SHg3Zkh0QWhZMEkrdUpFS05UOGVQeDB6RWJXNkZRNlh3K1ArNm1pNjdtalFVQUFBQUFBQUFBQUN3WkJCZ0JBSEIrclhlbFNhRStvWmc2amN3S2htc0FBQUFBQUFBQUFBQUFBQUNjV2pxVGpZS0VndU5Dak1xbGtnNzI3OWZZeUxETzF0VFVwR3dZNmpQMzNxTytmWHVpZWs0bWUvUTUzL3oyZDJoRmQ0OSs5ZjIvby82K2ZmcUh2L3U4c0xpMXRuY29WOStnRlN0NzlNakQzMWF0SlpNcHJkK3dTYy91ZUVyQUFtZGxWSEYxUW5peHRWWjJyVFgyYjRKRTRIT2VQdUhLSGpmL3Z3a0FBQUFBQUFBQUFHQ0pJTUFJQUlEeklKL1BkNnFrVG9WNmd3SzFXOWwyTnpzakFBQUFBQUFBQUFBQUFBQUFuRlpqVTdNNk9yc1VqeWMwcTJJMHIxZ3M2c2pBUVkyTmplcE1EUThOcWxvcDY1SHZmVmVGbVJrOStmaWpHbjloUFlsa1VybGN2YTdZY0pYYU96cDExU3V1Y2MrOVhGaDZKaWJHQlFEbm1iSFdLbEN3S2JSaFZ6NmZuM2JUUThhWW5WTlRVNE9mK01RbnBnVUFBQUFBQUFBQUFMQklFV0FFQU1ENVVOWjZ4WFN6bGYwRmhlb1ZBQUFBQUFBQUFBQUFBQUFBWHRheXp1VmF0MzZEdm5iZkY0L05teTBXdFBPWkhYckZ0VGZvVEIzczc0c0NpLzdySnordTBaRmg5ZTNiYzJ5WkR5L3E3dW5WUDNuejIzWGREYS9TNnJYcm9ua0FBSndyWTB6Z2F5djcwNEVKS2phMGJ6WXkzdzF0K0Q5eXVkekRiaEVCUmdBQUFBQUFBQUFBWU5FaXdBZ0FnTE53eHgxM3hEWnUzTmh1cmUweG9ibFdSbGU1Mnh2ZG9pWUJBQUFBQUFBQUFBQUFBQURnb2pvOGNGQkhCZzdwNy8vdTh4bzQySytCUXdkVkxNeEV5ekxaYkJSY2RObmFkYnBweTgzYXRQazZkWFF1VnpLWkZKYVc2YWtwRFE4ZFViazBxNFdnV3ExR3grN0UrS2dBTENvK3pDZ2RLcnpjV1BOMmErMkdyVnUzSGd6RDhJRnl1WHprNHgvLytMZ0FBQUFBQUFBQUFBQVdFUUtNQUFBNEN4czNib3k1cWxPaGJwRFJ1NnpzTWxkM0NnQUFBQUFBQUFBQUFBQUFBQmVkRHk5Njh2Rkg5UTkvOTNudDNiWHpoR1daYkozV3JkK29hMjk0bFg3MjUzNCtDalJLSmxQQzBqTTlOUmtkSzhWQ1VRdEJ0VnFKMmpNeFBpWUFpMG9VWUdSazFzcG9yYXo2M08yUklBejY0L0Y0eVMwandBZ0FBQUFBQUFBQUFDd3FCQmdCQUhDRzhoL0l2OTJFcHE2cTZpOUtVV2pSQ2xlNEpCOEFBQUFBQUFBQUFJdk1rMzBIOUwrKzg1Q09qRTNxeU1URXZCNHo0TDhNWFN5cUdOUXJ6R1JQdmQ0ajA4cE9QYVY3ZGg1UUlwR1kxM3AvK3BwWHFER1QwVHUzM0NnQUFBRDgyT0dCZzNyeThjZjB6UWUrNHNyOU9uU2cvNFRsYjdqOVo5VFR1MXJ2dlBQZGFtNXBWVjB1cDFpTW9aTkwzZlQwbEFEZ0ltcDNwY1hFelIvRWJHeDY2d2UyL2o4Rm1ybjc3cnYvUkFBQUFBQUFBQUFBQUlzQXZmQUFBSndoYTJ5M3JKcGt0TmtZNDc5VmtCVUFBQUFBQUFBQUFGaDBCaVltb2hDanZxRVI3UjhlT2FQSHluY2h4RThkVGpSU3JFckZDWGRqZnFGSTNxYVYzV3JNWmdRQUFJQVRUVTlONmNqQVFmWDM3ZFBlWFR0UFdyNnNjN202dW51MGJ2MUdBWFBhT3BZSkFDNmk2QTk2YSswbVh3ZEJzTU5WUXdJQUFBQUFBQUFBQUZna0NEQUNBT0JsL01adi9FYW1vYUVoWVVMelBobjFXTm1mZGNYZE5QWFdXdU1JQUFBQUFBQUFBQUFBQUFBQUYwK3BOS3M5dTNicVd3L2NyLy84aHg5VnNWQTRZZm5xdGV1VVRDYjEyMXMvSW1BK1V1bU11cnBYcXJtbFZRdEZSMmVYSzhzRllISHdndzJ0RTlyd243ckpjTnZXYmY5RVZzOFltYTlVVmYzQmh6NzBvUjhJQUFBQUFBQUFBQURnRWtTQUVRQUFwL0h1ZDc4NzBkWFZsWWpINDYyVlNxWFJ5cmE3MG10a1d1YnVRM2dSQUFBQUFBQUFBQUFBQUFEQTJhdFdxeXFYWm5VMmhvY0dOVEk4cExHUjRaT1dMZS9xVmpLWlVuTkxtNEQ1Q0l5VWNNZE1MQmJUUXBGTUpxTGpHTURpOGNJVkUrdGRDVjNwbFZIUldydktoR1o0MjI5dkcvekc5NzR4NE8rM2ZmdjJpZ0FBQUFBQUFBQUFBQzRSQkJnQkFIQWFYVjFkL3ZKbDE1WktwWGU1ZW9zeHBzN0k4TjRKQUFBQUFBQUFBQUFBQUFCd25odzYwSzluZGp5bDBobUdHRTFPVE9oLy9jVi9WWC9mM2xNdS80M2YzYWJPcm00Qjh4WEVZbXBvYUZRNlU2ZUZvaTdYNEVwT0FCYWx3SlVHVjI2UTBRMG1aa1pjR2QyeVpjdS90ZFkrNGVZZklNUUlBQUFBQUFBQUFBQmNLZ2hoQUFEZ09QbDgzcjgzcGwzcGRLVzNXcTFlRlFUQk1sbkZyTFV2WFB3SUFBQUFBQUFBQUFBQUFBQUE1ME1ZVmxXcGxHWHRqK2ZGNDNIVjVlcWo4bEtHaDQ1b2ZIejhoSG4xalUxS0pCTEsxdFVwblU0TGw3WjRQS0dVMjQreCtNbkRYYXVWaXNiSFJvOGRMeGVMYjA4aW1UemxzdW1weWFoTmpVM05Bb0F6RkkxZE5NWmM1WDZ2cFc5NTdTMjdiNzc1NXRsOFB2K1VBQUFBQUFBQUFBQUFGamdDakFBQU9KRy9aRm12UXQxcHJiMHlNTUZ0ZW1HQUhPRkZBQUFBQUFBQUFBQUFBQUFBNTFleFdOVDAxSlNzRFkvTjgyRTBtelpmcHhYZEswLzd1TUxNdEI1NjhCc256ZCs0YWJOYTI5cTFmRVZQVk9QU1ZwZkxhVmxubDlMcHpFbkxwcVltOU9Uamo2ckRMViszZm9QT1JHRjZXbWZEQnluNTlqUTBOSjV5K1k2bmZxaUppWEc5OHFZdEFvQXoxR0JsRzR6TWg4TnFLSGY3SDFYVlBqZi9Wd1FBQUFBQUFBQUFBTERBRVdBRUFJRHplNy8zZSsycFZDcG1xL2JuakRFZHJ2UC9SbGZhalFndEFnQUFBQUFBQUFBQUFBQUF1RkFteHNkMGVPQ2dxdFhxc1hsQkVDaVZUaXVlU0o3eU1mNytRNE9IVDdtc3VhVkZ5enFYS3hhTENaZStlRHdSSFF2bmUzOW02dXAwTnZ3RjBJNGVtd2tCd0FYaUJ5MWFLN3ZHL2M1cDJicDE2KzliYTBlRE1IaE1jZlhmZGRkZC9RSUFBQUFBQUFBQUFGaGdDREFDQU1CSnBWTCtrbnRKMStGL3ArdjQ5eU9VMXZvQlJ3QUFBQUFBQUFBQUFBQUFBTGh3SnNmSGRHVGcwQWtCUmlZSWxFNW5sRGhOU0l5Ly85RGc0Q21YTmJlMHFhT3ppd0NqUlNJZWowZkhRckJBOXFjZlQvUlN4eVlBbktzWHhpMzZmOVpZeDkzYTZPYnRVYUEvVjBVUHVma0VHQUVBQUFBQUFBQUFnQVdIQUNNQXdKS1cvL2Y1emE1anZ6Y013My9xT3ZsOWNORksxK2NmSTd3SUFBQUFBQUFBQUFBQUFBRGd3cGtZSDNWbFRLTWp3NXFabVphc1BiWXNrOG1xdTZkWFRTMnRwM3lzdjMraE1IM0taUjJkeTdYQ1BYYWhCTjdnM1BpZ29FdzJHd1VadlZpMUdrYkhRcWswcS9ueXgxMS8zejZOREowY2dGV1hhOUM2OVJ1VVNtZE8rM2cvcHNpM0o1Rk1uWEo1b1RBVGxma0txOVdvUGFNakk2ZGN2bWJ0NWU1NFhpMEFTMU5nQWxsakU4YWFIbGUvdzhic2xxMWJ0L1lIUWJBOUZvczkvYld2Zlczdjl1M2JLd0lBQUFBQUFBQUFBS2d4QW93QUFFdGJvRjRaYlRZeS8wUldUWDRXNFVVQUFBQUFBQUFBQUFBQUFBQVhWcUZRaUVKYlptWm1WQzZWVGxnV2k4WFUzTktxWEM1M3lzZjYrMWZLNVZNdXE4dlZxOFU5TmhaamVPUmk0SU9va3NtVWd1RGtRQ3ByYlhRc1ZDdmxlYS92NkhFM3JOS0xqam5QaHlSMWRIYTk1T1A5dUNMZm5uZzhjY3JsL3JnODNiRjVLdFZxTldyUDlOVGtLWmUzdEhXb3RhMWRBSlltSzJ2Y1AzRlgxN3ZKRzR6TUJsZFB1ZDhkUTY0ZWV0dmIzdFpIZ0JFQUFBQUFBQUFBQUZnSTZLRUhBQ3dwK1h3K2JhMXRNNkc1VFVhM3VZNzlqVzUydHl0TlFzMDBOemNybTgycXZyNCtHb1FJNE5JeE1URVJEYWdzbjhFQVRBQUFBQUJMU3lhVGlmN21uNC9wNldrTkRnNXFkblpXbFFyZnVRQUFBQUFBWURIYnQvczVQZlR0YjJqZ1VQOUp5eHFibXZYS203YW90YU5ERjhNek81N1VrWUdEd3NMVDF0NFJoVmsxTkRhZXRHeTJXTkRCL2o3Vm5TYm82bFJLN3J6VDVNVDRTYUZIOVEyTnltU3pML3Q0SDE1MHhZYXI5UFNUajU5eXVUK09rc21rNWlzTXc2ZzloY0xNQ2ZPemRibG9ERTBRQkFJV2d2YjJkbnZWaHF2Q1ozYythNGVHaG9UYXNOYld1U3BqWkg3TGh2WlhSNFpHdnAvZm1pL203ODcvbkFBQUFBQUFBQUFBQUdxSUFDTUF3SkpqalBGWEpHcHduZmlkYnJKTmhCZlZuQjlzNWE5aWwwZ2tvZ0xnMHVGL2R2MFZKdjJWTFFFQUFBRGdWUHpmRGFsVWFsNzNMUmFMMGQ4WUFBQUFBQUJnOGZNWFNTbk16S2h5bW91bHBOSnBKZUlYWnd4QnVWUlNxY1JGV3hhaVdDeCtySnlLRDhIMklVRHo1ZnUyL2YyTHhjSUo4LzNZbFNDWTMwVzNmSWpSUzdYblRJTzVvL2EvcU0vZG55SWp2QWdMaVEvVVNpUVRYSnl1eHN6UkUrZ3g5N3Vzd1JjMzZjZEFGZ1VBQUFBQUFBQUFBRkJqQkJnQkFKYUVmRDd2TDVGMlc3VmFYZTg2N1gvWGxaU1ZUUXMxWVFJVERUTHM3dTVXOThwdWRYWjJxcUdoUVFBQUFBQUFZR25yNysvWHpNeU0zRG1jTS82aUZ3RGcwalkyTTZ2eFFrbDl3NU1hY2JkL2RHaEVwY3I4djRSOG9Sd2NIZE5rdFVuSlRFYWQ3VzJxcFIyRFZTWGpSZDM5eGU5cklWalZXcS9ldG5xdGFXOVVMcFZRUXlhcGdDQkNBQUF3RDlOVGs5cXphNmUrL0lYUDZqUDMzblBTOHA3ZXk3UjY3VHB0Mm56ZGFkZlIyTlFjQlNHZnlwT1BQNnFSb2NIbzhlbjBTdzhObVhKdHFicHpFTC8zL2w5UnFWUVNGcTd1bnQ1b256Nno0OGtvY01vYkh4dlZnOXUvR2dYOTNITGJUODlyUFgzNzlrU1A4ZWVnanJmbDVsdDErZnFObXEvbWxwYW9QWWNIRHVySXdLRmo4Ny8vMExkMTZHQy8vc1V2L2V0NXJjY0hLZm4yakk0TW56Qi8wK2JyMWRyV3JsUTZJMkFoNk8zdFRmaHl3NDAzUkw4djcvdUgrOHFGUXNFKy8venpTZUdpZXlISVNGYjJSbDl2MjdyTnAvQ051QmtmZFdYSFhSKys2MzRCQUFBQUFBQUFBQUJjUkFRWUFRQVdyVHZ1dUNPMmNlTkczMUcvM2xxYkRjUHdxbGdzdHRLRzFsOEdpa3VVMVVnOEhsY3ltVlJUVTVNYUd4dVZ5V1NpZVFBQUFBQUFBQUNBcFdWZ2ZFYXpsYXFHSmd0UmFOSG9kREdhTnpWYjF0N2hDWVcxenkvU2tZa1pqUmVyS3BaQ0ZjdXFxYkdaaW9LZ3F1ZUhKN1VRRk1zVmpSZG1OZWoyWHlZUlYxZFRuUkx4bUxxYjZ4UTNnWExwaEFBQUFGN01CODc0b0phZHp6eXQ0YUVqcDd6UFpXdlhxV3ZGeXBkY1QxMHVwNXdyTVQvZXdOb29ESG5PbUZ0L1BKNVFzVERqN2xkL3lqRUpQampabDMyN245UGs1RVFVWk9RRE9VNjF2bEpwTmdxWkNjL3dBMm9zRm92YW1jNWtUNWp2QTV5aTljNFdvall3Wm1KK3N0bXNXdHJhbFVna2p3VVkrZTNuajZtSmlZa28wTXB2eTlOdFQzOWZ2KzBuSjhhUDdlL2orVkFzZjB6TlY5SzF3N2Rud3EzdmVQNDVmSnQ4ZTRMQUtKbE1uWFlkVWR0ZDhlMHBGRTRNVlBMSGptOFR4d2NXR2g4WTVvL0xqbzRPLzNOa1ptZG5WUzZYTlRJeUVpMjM3bmNvTGo2MzNmMDRTV05rMXRqQTJudytQK1AyelJIMzNuWDQ0WWNmbnQ2K2ZUdFhEQUFBQUFBQUFBQUFBQmNVUFpzQWdFVnI0OGFOL2hKa2NZWDZzT3VZendZbWVLTU5HU0JSUzM0QVMwTmpnNXFibTNYOTlkZEhRVWFwVkVvQUFBQUFBQUFBZ0tYRmh4VGQvM1NmK2tlbjlQbkg5dWp3eEV4VUZyYmFYaHZoNE5Sb1ZEKzRlMFFMMGExWGRxdXpvVTUzYmxtdnhreFNtMWUyQ3dBQTRIZytCT2pKeHgvVm5sM1A2ci85NXorTXdsdE81WmZmODV0UmNNdEx1V3p0RlVxbk04cmw2cU9Bb2NMTWp6OUxQdnE5NzBRQlJyL3l2dCtLd29OT3RTNy8zRDVvNXIvLzZTZjEzRE03dEhmWHptaE1RMzFENDBuckd4MFppVUpvd3JDcU0rR2YyN2V6L0tLZ25EM3V1YnlKOFhFMU5EWkh6NG1YZC9uNkRWR0kxT09QUEh4c250K0gvcGpxN2xtbEl3TUgxZHJXcnJnN0prNWxaT2lJZHJwOS9jeU9KNlA5L1dLYk5sK25qczR1elZmSDhpNjlhc3ZOcWxZcWVuN1BybVB6Zi9UVUUrNllHWXJhazBxbnRld2wxdW5iUG5oazRKVHQ4VUZlL3ZnaHdBZ0xUZG9kMTk0dGI3Z2xTcTNkdDIrZkRoOCtySzgvOFBXd1Vxa1lYNFNMemhqakwrcm8veEIvajVFcDJkRE9KSlBKejdqNS8vdkdHMjk4Y3Z2MjdlTUNBQUFBQUFBQUFBQzRnT2paQkFBc092bDh2c2xWYVJPYVYxbHI2NjJ4SzEyZGNKM3hRdTAwTmpaR1lVVmRLN3FVeVdTaUFWYithb01BQUFBQUFBQUFnS1ZoZktha3FnMzFnNzVCalV6TjZ0dTdEbW1pV05MSVRGR0ZVa1c0dEIwYW45RmtzYXl2UE5XbmxseEtvOU1sdGViU1d0L1pwSGdzVUVBL0RRQUFpOGFPcHg3WE54L29QS1BIek16TWFMWlkwRk0vL0lIR1JrYWk0QmtmRkhTODNqV1hLNVZLUnlFeWN3RVpMeVhwN252RmhrMGFIanFpM1R1Zk9UYS9YQzVIUVRmZi9kWjJOVFEyNlpycmIxUVFtR2ljUXFsVWpwN2JoeWdORHczcDBJSDlHaGtaanNKaXZGZzhvY21Kc1JNQ2pBb3pVOUZqd2pPOGFKWVBQV3B1YVZGZExuZks1WTgvOWowZEhqaW9EVmRkZmRLeVZQcm91SXBNdGk0S1ZvS2lJQ0FmQnBXdHEzUEgwL1FKd1ZBalE0TjY2TUh0dXY2bTE2aTdwMWVKUkZKejQ0VDhzVkJ3OXg5dzI5b0hCdmxnb2VQTmJXTi9ESnh1WDUxS1hhNCtlc3lQbnY2aEVzbWtLdTY0cy9ib01lS1BIOStlenE1dWR3eTBLaFk3Y1l5TS8zbXdZVFZxeitURWlaa2lmbDMrMk9ucHZTeGF2NThHRnJLYys3a3g3cjlObXpacGVucmFEZzRPaHVQajQwR3BWT0tQd05yeGJ4eEpoVnF2bUc3UHBySXI4dm44K096czdLUEZZbkhxai83b2p3b0NBQUFBQUFBQUFBQTR6d2d3QWdBc1JuNlVYS2VWL1JWcjdIcDNleFhoUmJXM2N1WEthTURLVlp1dUVnQUFBQUFBQUFCZzZSbWNLbWg2dHF6L2NOOFBkSEJzV3M4TWpBcUx4OU1IUjZMNjRiMkgxVnFYMW12V0x0ZXJYZWxweVNtYmpDc1o1NklHQUFBc0Z0OTY0QisxYzhkVFovU1lnLzE5S2hhTFVYMDZXMTcvQnRVM05HcmQrZzJhRDM4UnBWdHUrNmtvQk9iNEFLUFM3TkZncEhzKzlSOFZqeWYwcSsvL0hjWGljZVZ5OVJvZEdWWi8zNzRvWEdiUHJwMmFtcHBVdFZMUk8rOThkeFIwNDhOayt2djJhdURnZ1dQcm01eVlVQkRFb3VWbklwRk1xTHRudFZ2Zjg2ZGMvcm5QL0tYYU81YnBYL3pTdno1cFdXdGJleFNRMDlXZEljRG9CYXZYcm92Q2lSb2FtelV6UGEzeDR3S01kajZ6UTMvNTUvOUZtV3pXYmJzT0JibFlGQURsK2YwMlBEU29aNTc2b2I3OGhjOUdvVkhIOHlGVC9qaTVhY3ZOT2hQTE9wZXJ3UjJ2Tzl4NnM5bTZZOGVTNXdPV2ZIdXV2T29WdXZyYVZ5cVZUaXNXeXh4NzdOaklrQ3J1dnI0OXBlTmVoK2ZYMWRqVXJFMmJyOU0xMTk4a1lLRnJhMnVMeXFyZVZjR2hRNGVxUC96aER5dTdkKytPRHc0T0JuSy9OcTBzQS9jdXZuaFVqRzZ4b2IzRjdZUEhUV2pHM2UvRjM4eG1zd051MlFFQkFBQUFBQUFBQUFDY1p3UVlBUUFXalh3KzM2bXkxcXVxTFRhd2E5d3NYeHFGbXZCWGp2TmxlZGR5WlRJWmRYWE43d3FKQUFBQUFBQUFBSURGWldCOFJvY25adlNWcC91aTIzdUhKelJaS0F1TFY2RmMwYk1EbzZwVVExWERNQW96V3RQZXFKYTZGRUZHQUFBc0FpTkRSelJiTEp6Ull5WW14bytGdTh6eEFUTStXR2oxbW5WcWErL1FhMjYrTlFxRW1hOUVNaG1GdkJRTE0rcm9YSzdwcVNsWEpvOHRQeG84Rk9pcjkzMHhxcFBKVkhUZjhmRXhIVHA0UUVYM0d0bzdPdDM4cE41dys1dWk2VWNmK3JZbXhzOVAwR1kybTlQbDZ6ZTQ1K28vWmZzTzlqK3ZzZEVSZmY2di8vS2t4NzcySjI3VDVWZGNxYzZ1RldLWTUxR0pSRExhajF0dWZrTVVSUFUzZi8wL2p5MHJGQXBSTU5IZi8rM245ZlFQSDFkM3p5cGxzblhSTWg4UXRIUEhrMUZ3bGIrUDN3L0g4OEZadWZvR25hbFlMQjRGRS9uQUxYLzhmUE9CK3pWMDVIQzBMS3hXbytjS3c2cis5Sk1mandLcFdseVo4K3lPcDFRdXpVYjNxYnI3SHUreXRldDB6ZlUzcXJtbFRjQ2xwcTZ1TGxpN2RtMnN2cjdlVEU1T3F1LzV2cXI3K2JRakl5TUpvWmI4eFNDYkFnWHZpc1ZpdzF1M2J2MjYrMzA2bXMvbkh4TUFBQUFBQUFBQUFNQjVRczgyQUdEeEtLbFRNZDFzalgyTHJEWUxOZVhEaS93Z3Y5N2VYclcwdEtpNXVabXJBZ0lBQUFBQUFBREFFdVREaTU3WVA2VFBQN3BidXdmSE5WRXN5MW9yTEY0enBZcWVQVHltL3JFcFBYMW9STWxZb0Z3cUVSVUNqQUFBdVBRTkR3MUc1Vno1OEtKME9xUDFHemRwL1laTmV1M050NnIrREFLTWZDQ1JEekFhSFJuU3NzNnVGOEpwamc4d0dvL3FyOTMzcGRPdW83MWptUnFibW5YcjdUOFQzWC8vdnIxdVBZZDBQbVN5V2ExYnYxRjkrL2Fjc24wSCsvZEg5YTVuZDV5eVhSM0xPaFdHZkc2ZWswZ2tvckxsNWplcU1ETjlRb0NSRDZieTVlLy85blBSdEQ4dS9INk5saFdMZXVTaEIwKzczbGUvL3Rab2U1K3BveGYyeWtRaFZkNlRqejk2TE1ESWh4SWRjY2VSTHo1UXFhZjNzcWpNK2I1cno2eHIxNm1zWHJ0T2IzREhZM05McTRCTFRVTkRnM0Vsdm56NThpZzh6SWEyT2p3OEhCSmdWSE9kL2g4cis4dXVHamZHeE1JdzNPTnVFMkFFQUFBQUFBQUFBQURPR3dLTUFBQ1h0SHcrdjlaVlBRcjFUbXZ0Q2htdDF3c2Q3cWlOVENhamx0WVdMVnUyTENyTlRjMUtKQk9FRndFQUFBQUFBQURBRWpNd2ZqUzQ2Q3RQOStsK1Z3Nk1UNnRRcWhCZXRJVE1scXZSY2ZBL0gzcFdYM3hpbjM3enRzMWExOW1zdFIzekR5WUFBQUNMUTJ0Ymh4TEpaQlFVVTVlcjEyVnIxMm5OdWl1MWR0MTZkWFd2ak9hZFNYaVJaNHh4ajh0cDgvVTM2ZmMvL0FsOTY0SDc5VTFYOXV6YWVVSlEwS2xzdXVZNnJWNnpUbTk1K3p2YzgvZTg1SDFIUjRaVkxCWlVxWlIxTnZ4ci9lWDMvS1llZW5DN3Z1dktvUVA3VlN3VWhMTno5YlhYUi9Wdi9HNCtDb1g2Nm4xZml2YlB4Tmpvc2Z2czJmV3M0dkdqZVNrdjNtLyttS25MTmVnMXIvOEpiZGgwalY3enVwOVFLcDNSMmVydVdlMk83M2I5cTE5OXZ3NGZPcWd2ZmVHejBURXpkR1RnMkgxOE84ZVBhOS94NFVWK1BFMWJSNmM3VGk2UGdvdXVlc1UxMnVpSy81a0FMbFdwVkNxNjhOMk5OOTZZS0ZmS2RzMmFOU3FYeS9ydVE5K3RWaW9WbFdaTEpOdldSdURPeVdTTnpEdmRlK2pVdGc5dWUzT284THZ1OW5lcjFlck9qM3prSXdjRUFBQUFBQUFBQUFCd2xnZ3dBZ0JjNm5LcXFrTkcxN3ZpTDUzV0k5UlVQQkZYTnB0VlkyT2oydHZiRlkvSENTOENBQUFBQUFBQWdDVm91bFRXNFlrWlBUODhxV2NQandsTFR5VzBybFQxM09GeEplT0JCcWVLV2pGN2RsLzhCd0FBbDdaVU9xVjBPcVBHcHVhbzlQUmVwdlVicnRLbXpkY3BrODBxbVV6cFRQa0FJeDlTczZ4enVSb2FHclYzMTg1bzNYNmN3c3RwYTErbUZkMDlXcmQrWTlTV2wxSXVsYzVwM0VOelMxc1VZdVNEbFhLNWVzVmk1SGFjQ3grRzVWMitmb003cnRMdXVFcXJXcW1jY0ovcHFhblRQdDRmTS80eEc2N2E3TXJWYW1ocWlhYlBsaDhqNDB2dm1zdlYwTmdVcmNzSHR4elBCeFlkSDFwMFBIOXMrY2NzNytxTzJ0UGQweHNkeDhDbGJPNzNYSE5MYy9UTGMyWm14aGZyNXR0cXRXcUVtakQralZQeXYvQjY1UDVjbDFGWFlJTXhLN3M3a1Vqc0ZRQUFBQUFBQUFBQXdEbWdFd2dBY0VuS2Z5RC9kdmN1MWhDYThMZU5qQi94MEdPdGpiaytka1o1MVVBaWNYUncxOVZYWDYxY0xxZTI5clpvUU9EY1lKU2pZeDhBQUFBQUFBQmVXbjkvdjU1NC9BbU5qWTJwVUNob01iajk5dHZWdWJ4VHZiMjlBb0Nsb2xpdTZJbjlRL3I2c3dmMHlYOThRZ1UzUFZPcUNFdlgwVzRDbzh2YTZ0VlNsOVo5NzMrekFqY3ZsMDRLQUhCNjkzNzZYdTNidDArTFNmNnV2SEJwbUp3WWorcnhzVkdkRDdFWFFvVjhlSXpueHhna2txa282TVdQS1RpWGNRWFcycWdVWnFhamtJeUh2djBOalE0UDZjakFRVlVxbGVpMXhOenorcENaWmN1N3RHSFRabGV2VUhOemkxTHB6QW5oTmY2K3hTaHM1c2ZuSlh6QWpISEZCOHljaldxMTRrcFZSWGV1dzUvdjJMdnJXVTFOVGVuSnh4ODk5angxdVp5NmUxWXJtVW9xbGNwbzdib3IxTm0xOHFSZ0hkKzJtZW1wcUx4WVcwZG5WSjlwR00vRStGaFVYbXd1UktlK29mRmwxMUY4SVp4bjZNaUF6bGU3WHM2TTI5K2VQMFlQSGRpdnA1NzRnVVpIaHR4eE1LUHA2V21GYnJzZjMzWWZsQldGU1YyK1Rtc3VYNjlNSnF1MEwrZXBYZVZ5MlpWUzFCNS9MRDY0L1d2Ui9oMGVHdFRzN0t4S3M4WG8rZndZbXpsZDNUMVJ1N2JjZk91eDl2anhOdk1KNGZMODhlM0xxYlo3dGk0WGxUTlozNXlYMnA5bnM5NzVyTzk4SHg5WVdDb3ZoSXo1RUtPaHdTSHQyYk1uM0w5L3YrbmIzMmNVeXJqZjRrSk5oTzc5MDc4UnpiZy8yZmNaYXdaRGhSOEl3L0RJUno3eWtRTUNBQUFBQUFBQUFBQTRBMmZXS3drQVFJMjRqbkp6MTExMytkRnEyYWlVMVd1TnJUZkdMTGRoRkZ5VUpDVG40cHNMS0txcnExTXFsVko5ZmIweTJReURpZ0FBQUFBQUFBQmdpUXF0ZFVYcUc1blV3UGkwaHFlTEFtejBYVlNyc1ptU2lwV3Fqa3dXQ0RBQ0FHQ0Jtd3QrbVU5NFRhM05CU0RWNWVxajByT3FWM1YxT1NXU1NWVXJaVTFPVENpSXhhS3hEVDY0YUdWUHI1cGFXcFhOMXAyMEx2OTZ6L2RyanNYaVVVa21VMnBvYkZLNU5LdXBxY2tvYkdjdXdNZ0gxNnpzV2FWa0t1MUtTaTJ0N2FjY2UrSG4rZExTMnFienhiZkpsM014MTladXQyMHZscm45NTJ1Ly84ZEdSNlA5WDVpWjBzeE1JZHIzOVEwTngrNmZjZmZ6QVVZK05PaHN3NmhlaWc4bThzVzN4NGNyK1czaDk3VVBLSnFkTFIwWFlQVGpZYnRkM2F1aTVXZmJucmtRb2ZPOTNjLzMvcXpGOFlHRlpTN3NxcUdod1pUTFpkdlUxS1FKOTd1NWViTFoxOVl2cTFRcURQNjcrQUwzKzlQL01xMXo3NlFsYTJ4ZExJaXRjdFBaUC9pRFB5aVdTcVZDUHArZkVRQUFBQUFBQUFBQXdEd1FZQVFBdUNUY2RkZGRLVmVsVmRXN1pMVEZ4dXdiNVlPTXJFUndVZTAwTmpaR3dVV3ZlLzNyb3YyUXkrVUVBQUFBQUFBQUFGaTZKZ29sOVk5TzZWZi82aHNxVlVNQng0c0NyYWFsMy9uY2Q5UmVuOUYvL1pjM0N3QUE0SHk3K3RvYnRKRE5oYmlzMzdCSk9EODZsNitJeWtMaFE0eHV1ZTJuQk9Ca3JhMnR4cFhZNW1zMis5QWlmZk1iMzV3ZEhCd005KzdkbXliRXFIYXNyUDhsdWlLc2huOWpaRlFxbHY0aURNTm4zYnovS0FBQUFBQUFBQUFBZ0hrZ3dBZ0FzS0M5KzkzdlRuUjFkZmxMMjNWRnhXaWQ2eXh2ZFoza0NTc3IxSVlQTGZLbHBhVkZxWFJLc1ZpTUlDa0FBQUFBQUFBQWdIWWRHVmYvMkpRcTFWQlZBb3h3R2tOVEJRWEcxMFVsWW9FYU0wa0JBQUFBQUpZT1A5WXNDQUkxdHpRSHZwNmRuWTBDalk0Y09XSWRkMDZoeW1DMDJ1cDArNldVeitlM3VOdEZPMk1IbE5IRVhYZmROU0VBQUFBQUFBQUFBSUJUSU1BSUFMQ2d2UkJldENVTXc3ZTYrcTFHSnVQcUpPRkZ0ZFhkM2EzMmpuYXRYcjFhZFhWMUFnQUFBQUFBQUFEQSs5UHRUMnBxdHF6cFVrWEE2WHhuOTREYTZ6UDY5cTVEV3RtUzA3VTk3UUlBQUFBQUxCMytnbm0rdlBLVnIwejQ2Y0hCUVUxT1R0b3ZmK25MNVVxbFlzYkh4eFBDUldkZXVJcWhsZjFwVjFVVTZoMXU0bkdsOUxlbVpPNTM4M1lJQUFBQUFBQUFBQURnRkFnd0FnQXNPTzk5NzN0VHJhMnRHZGY5ZlpPcTZyU0IvVW5YTDc3ZWRZU25yTFd4Ri9ySWNSSDVxMXlsVWlubGNqbTF0cldxczdOVERRME5TaVFZSndJQUFBQUFBQUFBa0thS1pWWENVRS9zSDFLcEVncDRPY1Z5UlY5NXVrODNYYmFNQUNNQUFBQUFXT0t5MmF6aThiaHV2UEhHV0tGUTBJRURCNm9qSXlObWVHUTQ4TmM2dEpZTEh0WkE0RXBhUnIxdUgveGtHQXU3OGgvTTkxZHM1U3ZsY25uZzR4Ly8rTGdBQUFBQUFBQUFBQUJlUUlBUkFHREJhV2xwU2JtcXlYVi8zMjZ0WGVFNnY5OCt0NHp3b3Ryd0FVYVpiRVp0N1cxYXYzNTlGR1RrQTQwQUFBQUFBQUFBQVBDbVo4c3FWcXA2b245WXdId1VTaFhkLzNTZmNpa3VsZ0FBQUFBQVMxMWRYWjB2NW9ZYmI0aE5UVTJGdWZwY1plZk9uYkhSMFZHRmxxRGtHamthWUNUMStoQWpZOHkxN3Zha3JQYkY0L0dpdTAyQUVRQUFBQUFBQUFBQU9JWUFJd0RBZ3BIUDV6dGRsVlNvWDdDaDdYQ2QzcmRZMlpRUm9VVzF0R0xGaXVnS1Z5dDdWaXFUeVVTRFJmelZyZ0FBQUFBQUFBQUFtUE9OblFjME1ENGpZTDVDS3cxTkZiVDd5SmkrdmV1UVZqYlhxNmMxSndBQUFBREEwcGJKWkV4dmIyKzhzYkhSckYyN1ZnZjZEMVNHaDRmREF3Y09KTUl3WkRCaHJWalZXMlBUZ1FsK3kwME5iUDNBMW0rNTI5UDVEK1gvUWdBQUFBQUFBQUFBWU1ramZRQUFzSkRrWGlpdk44WjBXZGtyWFMzVVZuTnpzM0s1bkxxN3V4VUVBZUZGQUFBQUFBQUFBSUNUN0J1ZTBMTURZd0xtSzdSVzA3TVZEVTNOYXZlUmNlVlNDUUtNQUFBQUFBQ0t4V0ttdGJYVk5EWTJSbVBXRlAwSmFhc0RBd00rd0Vpb0VhT00rOWVYTGY2YWxFWW1ZV1dQdUdrQ2pBQUFBQUFBQUFBQUFBRkdBSURhKytBSFAzaE5UTEZyYkdoLzJVMzJ1TkltMUV3c0ZvdUNpcTUvNWZWS3A5TnpnMENVU0NRRUFBQUFBQUFBQU1EeENxV0t5dFZRWC8xUnY3NjM5N0NBTTdWL1pGS2ZlMnkzRXZGQVY2K2tpd2dBQUFBQWNKUWZ4K2JMNXMyYkV4czNia3k4OHBXdk5LRU45YmRmK050S3RWclYyTmdZNCtCcndEaldrZEZ0dnQ2NmRldnJaTFUzVVBDNXFxby8rTkNIUHZRREFRQUFBQUFBQUFDQUpZZU9Hd0JBelFWaGtMS0JiZERSNEtJdW9hYU1NVkhKWkRKUlNhVlNBZ0FBQUFBQUFBRGdWS3o3TDdSV3MrV3FwbWNyQXM1VXFScTZZNmVzVWlVVUFBQUFBQUJ6L0JnMkw1RklHSC94dlVxbG9qQU1mYWlSRldyS0hOMDVXZmxUUTlJcUdWV3R0UTErTEtnQUFBQUFBQUFBQU1DU1JJQVJBT0NpeStmei92Mm5XMVZ0Y1IzWDc3S3lxOXgwcjFCVGpZMk5hbXBxMGhYcnIxQm5aNmNmK0hGc0VBZ0FBQUFBQUFBQUFLZnlnNzRoN1Q0eXJ1R3Bvb0N6Y1hoaUppcWJWN2JwK2VGSkxXdklLSjFnS0FNQUFBQUE0RVFORFExUi9Xdi81dGNTNVhMWjdueDI1K3orL2Z2TjQ0OC9IbmZUcGxxdE10anRJbnNoeUNqanlrWVovWkZpbXRxMmRkdFVhTU0vaWNWaTIxdGFXcjcvdnZlOWIxWUFBQUFBQUFBQUFHRFJDd1FBd0VXVXorZmJYT1hMOVZaMm95dU43blphcUFrL2ZpQWVqMGVETzN4NFVYTnpzektaRE1GRkFBQUFBQUFBQUlCNUtaWXJHcHVaVlNVTUJaeUxZcmw2OUZpcVdnRUFBQUFBOEhMcTZ1cE1ZMU5qMEwyeVd4MGRIYmFob1NHTXhXTDhVVmxEMXRxWXE1SkJFS3h3dHplUGpZMXR6dWZ6bXdVQUFBQUFBQUFBQUJZOUxsc0lBTGpZdHJqU0ZvYmhKNHd4Q1hjN0s5U0VEeWxLSkJMSzVYSmFkOFU2UDRnaktnQUFBQUFBQUFBQXpOZSs0VWs5MFQra3FkbXlnSE14TUQ2akovWVBhVmxEVnJsMFFnQUFBQUFBbkU0aWtUQzlxM3VUSzN0VzZwcHJydEh6eno5ZjJiZHZYL1hwcDU1T1RFeE1jUFcrR2pIR1pGeVZzYUg5RlQ4ZDJ2QjdyaXE2Y3JNQUFBQUFBQUFBQU1DaVJvQVJBT0NDeXVmei9yMG1DS3JCcGpBTU05YmFuM0RUV2FNb3ZJajNvUnBKcFZLS3grTmF2bnk1MHVtMG1wdWJveG9BQUFBQUFBQUFnRE14UGxPS2dtY3FZU2pnWEV6UHVtTnBnbU1KQUFBQUFEQi8vaUorc1ZoTVRVMU5ac1dLRlVHMVVqVlRVMU02ZVBCZ09EczdxMEtoRUFnMVkyVmJYVlg1NEFjLytQTmhHSTRtd3NSdW03UVRkOTExVjc4QUFBQUFBQUFBQU1DaVFuQUVBT0JDUy9vU0t2d25pbW10NjVIK0JhSG02bkoxVVdEUmRkZGZGdzNneUdhekFnQUFBQUFBQUFEZ1RBMU1UT3ZadzJPYW1xMElPQmREVTBVOU96RHFqcVd5QUFBQUFBQ1lqeUFJb3JKczJiS1lMNzI5dmFwVUtycnZIKzZyVGs1TzZzQ0JBd1FZMVlEeHlWSkhyZlgvQkNiNDd5WXd1MjFnLzZ1cTJ1Rm1FV0FFQUFBQUFBQUFBTUFpUTRBUkFPQ0N5T2Z6YmE1cWM1M05OOHRvZ3pYMk9qZmRJZFRVOHVYTGxVd210ZTZLZFlySDQwcWxVdEVBRGdBQUFBQUFBQUFBenNaVXNhS2hxWUtxMVZEQXVaZ3BIVDJXS2h4TEFBQUFBSUN6NUMvcUY0YWhYdlhxVjhVS2hZTDY5L2RyZEhSVU8zZnVES3ZWcW5ITGpIRFJXV3RqeHBpVjd1WTdYQm5aOXNGdGI2bUVsUWZjL3ZyaGtTTkgrajcxcVUvTkNnQUFBQUFBQUFBQVhOSUlNQUlBWENnNVZ6cGx0TVhLYm5HM2w3bVNGbW9xbDh1cHZyNWVxMWF0RWdBQUFBQUFBQUFBNTJxMlV0WDBiRVhBdVNwVlEwMjVZNmtTV2dFQUFBQUFjRGI4UmYyOFZhdFdCWlZLSlFvME9uejRzSGJ2M2gwRkc2RTJqT09xckNzM3lLams2cHRpc2RpUmFyVjZPSnZOSG5IVEJCZ0JBQUFBQUFBQUFIQ0pJOEFJQUhCZTVmUDVUbFYxdTYzYUcxMUg4MDF1Vm8rT2Rqd25oWXZPZGZJcm1VeHFSZmNLdGJXMWFkbXlaZEdnREFBQUFBQUFBQUFBenNYQStMUUdKbVkwTkZVUWNENk1UQmRWcm9ZcWxnakVBZ0FBQUFDY3V5QUkxTm5acWRhV1ZpMWZ2dHowOS9lSEIvb1BWQThkT2hRYkhSa05yS3dSYXNGL2Z5Rm5aTjRaaHVGYjBzbjBFL210K2ZGU3BmUlJhMjM0MFk5K2RGQUFBQUFBQUFBQUFPQ1NRNEFSQU9CODgrazR2YTZzZDJXelVGUCt3a1UreEtpeHNWR3RyYTFxYUdoUUtwVVNBQUFBQUFBQUFBRG5vbGlwYXJ4UVVpVU1CWndQcFVxbzZkbXlxdFlLQUFBQUFJQno1UU9NL01YK2ZLbHZxRGZsY3RsT1RrN2F3YUZCdDlEZGdWTWF0Uks4VU5ZWkdTbjZSK1BHbUxRcnBCb0RBQUFBQUFBQUFIQ0pJc0FJQUhET3RtM2IxdTJxTG1QTlBUYTBkYTQ3ZWExUVU1bE1SdDBydTlYZTNxNjFhOWNxSG85SEF6SUFBQUFBQUFBQUFBQVdvdGxLTlNxVkt0OGdCUUFBQUFDY2YydldySW43TWpNem8xS3BwSzgvOFBWWmQ5cys5OXh6YWFHV05sdFp4V1B4WGU3MnhMWnQyKzZwVnF1UGZ2akRILzZjQUFBQUFBQUFBQURBSllNQUl3REFXWE1keFEyK3JsUXFYUW1UNkxLQlRSaVptTzlNeHNWbmpJbnFWQ29WWFRYSzE0bEU0dGg4QUFBQUFBQUFBQUFBQUFBQUFBQ1dNaitlemw4TXNLNnV6dmc2bDh1cFhDNnJWQzc1b1kvR1dzWS8xb0xiN3NidkcyTk5vOXN2eS9MNWZJK2JQVE0xTlZYNHhDYytNUzBBQUFBQUFBQUFBTENnRVdBRUFEaHJwbXB1czhaMngyS3g5NGNLVzF6WGNUM2hSYlVUajhlandSV3ZmZTFybFVxbjFOblpLUUFBQUFBQUFBQUFBQUFBQUFBQWNGUW1rNG5LYlQ5NVc5SlA3OXUzVDRPRGcvYWIzL3htdFZRcW1kbmliRXk0Nkl3eGZydTNXTmxmTlRJbEc5b1B5K3BMMld6MlM3LzNlNy8zd0VjLyt0RkJBUUFBQUFBQUFBQ0FCWXNBSXdEQXZPWHorVUJIM3p0NlZGR1BOZlpHZDd2TEJ4ZUo5NVNhU1NhVGlzVmlXclpzV1JSaVZKZXJpMm9BQUFBQUFBQUFBQzZVWENxaFpRMFovZVRHVmVwc3FOT2xwRnd1YTJabVJ0UFRVenA4NUlnV2sxZ1FrekhTaGcwYjVQcHZGTVF1dmU5Y05tVlRBZ0FBQUFEZ1lzbmxjajQ4eDF4MTFWVm1hbXJLREE4TjI5SFJVVk1vRklTYThXTlZrOWJZTmE1K2ZTcVZ5bnpnQXg4WWljZmpENDJQajAvKzBSLzlFVHNIQUFBQUFBQUFBSUFGaG5RREFNQ1o4TzhiV1ZXMXhYVVB2OVhkZm8wcmJVSk4rYXRCWmJOWlhiMzVhcVhUYWRYWDF3c0FBQUFBQUFBQWdBdXBMWmVKeXZyT0ZsMXFmSGhSWDErZjl1N1pxNGNmM3EzRnhGLzBJQWdDdmYrZnY4NS8rVktwRkdGQUFBQUFBQUM4bExhMnRxaXNXclVxZHVUd0VmdmNjODlWZi9Takg1bURCdzhHTnJSeS94bmhZdk5qVmVORzVsV3VmcFhiRDIrTUJiR3Bhclg2N213MmU5RE5PeUFBQUFBQUFBQUFBTENnRUdBRUFIaForWHpldjE5MHU3TFdkUUJ2OFJjYmNoM0RWOGlIR2FGbUdob2FvdExlMFI2RkZ2a1FvM2ljdDNZQUFBQUFBQUFBQUY1S0lwR0l2cGc0TlRXbHpzNU9qWStQcTFBb2FESG82ZWxSTHBlanZ3QUFBQUFBZ0xOUWw2dnpmMXNIeVdUU1hIYlpaZHF6WjA5MVptYkdqb3lNSklSYThnbmF1VURCdTB6TURPYy9rSDlJVmtQNWorUy9Jd0FBQUFBQUFBQUFzQ0F3YWhFQU1CLysvYUkzRE1QWEdXUGVaMlQ4NVhyVFFrMzU4S0x1bGQzcTd1NVdVMU9UQUFBQUFBQUFBQURBeTVzTE1KcVpub2tDakVxbDBxSUtNT3BZMWtHQUVRQUFBQUFBWjZHdXJzNzQwcm04VTlWcVZaVktwVG80T0JnU1lGUnpQc0JJVnZhWDNUOVRDdFFSaHVHemJoWUJSZ0FBQUFBQUFBQUFMQkNNV2dRQW5OSWYvdUVmWmlZbUptSzJhdTkwSGIxMVJ1Ym5YT2x3aStwY0NZU0x6aGlqWEgwdXVuTHltalZyb2dDanhzWkdwZE5rU1FFQUFBQUFBQUFBY0tiYTJ0dTBaY3NXUGZYVVUrcnY3OWVCQXdjdTJTQWozMit3ZlBseVhiN3U4cWp2QUFBQUFBQUFuTDFZTEJhVlY5N3d5a1M1WExaWFhubWxEek95My83MnR5dHUyc3pNekRBR3YzYVNvUTEvU2thdjIvYkJiYThMRlg3WEdQUGRhclc2OHlNZitjZ0JBUUFBQUFBQUFBQ0FtcUR6QkFCd1NqNjh5RlZ4MTdHNzFzZzBXTm5OUWszNUFDTi9WV2dmV05UZTNxNU1KcU5zTmlzQUFBQUFBQUFBQUhEbS9EbDJYL3dGQS96RkEvd1hFeTlWUHJTb3JhMU45Ymw2K2c0QUFBQUFBRGhIUVhEMEdvL056YzNSalRBTU5UTXpvM2c4YnF2VnFoRnF3dmhCbEZMS2xlV3VWRnhwRDJ3d1ptVjNKeEtKdlFJQUFBQUFBQUFBQURWRGdCRUE0QVMvLy91L3Y4SjE1RGJhcXYxMTE5ZTd5blhzdmtxb3VkV3JWMGRmbnJoaS9SWFI0QWgvR3dBQUFBQUFBQUFBbkx0TnI5aWs5ZXZYcTZXbFJhT2pvL3JCRDM2Z2hjNzNGZmlMSGl4YnRpeHFlMjl2YnhSZ0ZJdGZ1aUZNQUFBQUFBQXNWUDZDZzQ2NTh4ZnZUSXlPak5ybm4zKyt2SGZmM21EZjNuMHhhNjE4d1VYbnZ3ZmhMODc1LzhucUp4WHFZSDVyZmt5QnRwYkw1ZDBmK2NoSERnZ0FBQUFBQUFBQUFGdzBCQmdCQUU2UVNDVDh5UGFrTWFiUjFaMnVOQWcxbDB3bW95OGkrS3NtK3k4bHpGM2hDUUFBQUFBQUFBQUFuQnQvL3QyWGREcXRWQ3FsUzRYcnl6bldkK0Ribmt3bEJRQUFBQUFBenI5WTdHaGdjSDE5dlNtVlNqWmJsN1grYjNML3R6bmhSVFVWdUgxUTUrbzZIeU5sWkhLVlNxVkpmRWNDQUFBQUFBQUFBSUNManBQekFJQkkvdmZ5RzJ6YzNtWkQrdzQzZVlOUVUzN0FneTlYWDMyMW1wcWF0S0o3aGVKeDNyWUJBQUFBQUFBQUFMaFFicmp4YVBmSStpdlhhMlptUnZkLzVYNlZTcVhvOWtMUzI5dXJ0clkyYlhudGx1Z0NDRDdBQ0FBQUFBQUFYQnl0cmEyQksway90cTlTcWVqSko1OHM5ZS92cis3WXNTTmRMcGVOVUNzZFZyWWpNTUVYNVBiQ3RnOXUrMXMzNzhoZEg3cnJWd1FBQUFBQUFBQUFBQzQ0a2hBQVlBbkw1L05wVi9sUjdUMG1ORmRZYTllNDJ5MUN6UVJCY096TEJyN1U1ZXFVU3FlaStRQUFBQUFBQUFBQTRNSkxwOU1LdzFEZDNkMHFGb3NhR3h2VDdPeHNWTXJsc2x4L2lpNm1SQ0lSRmQ5djRDOTIwTm5acWNiR3h1aTJ2eGdDQUFBQUFBQzQrSXd4MGJpK3VybzYwOWJlRnZqekNQNjh3Y0RBZ1BYbkRxclZLbUZHdFdUVUpxdndneC84NEd2ZFZER1lEUTRwbzRtNzdycHJRZ0FBQUFBQUFBQUE0THdqd0FnQWxyWk9WYlJlZ1g0M1ZMak1kZGl1RjJvcWs4bEVWMDFlMWJzcXVvS3kvL0lCNFVVQUFBQUFBQUFBQUZ3OFBpREl1K3l5eXpReVBLSyt2ajcxOS9kSFpXUmtSS1ZTU1JlVDd6ZndnVVhYWEhOTmRORUQzMzhBQUFBQUFBQnF5NGNLKzdKaHc0YUVuNzc2NnF1alFPVFAvSy9QVk55NUF6TTJOc1k0L1Jvd1BsbnFxQzFXMXJySmYySmtIbFZLbjFkRkQ3bjVEd2tBQUFBQUFBQUFBSngzZEl3QXdCTDA3Ly85djErZVRDWVQxV3IxelNZd0hhNXpkcG1iM1NUVWhBOG84Z01abXBxYVZGOWZyMlhMbHFtaG9ZSGdJZ0FBQUFBQUFBQUFhc3oxcDZpbHBTVzZYVmRYZHl6QWFHWm1SdVZ5V1ZOVFUzTDlMZEU4L3lWRmE2M09SaUtSaVBvRjB1bDBkRHVielNxVlNrWFR6YzNOMFhNM05qVkdGejRBQUFBQUFBQUxqLzk3M3A4WFdIL2xlbE1zRm5WNDRIRFZuVDh3dzhQRGdaOS90dWNNY1BZQ0V5aFVHSE0zMjF4NXBRbE1MditCZkpmaWVzeE56Mnpmdm4zRWxZb0FBQUFBQUFBQUFNQTVZM1FqQUN4QnJxTjhrNnV5eHBpN2pZenZuTTBKTmVPL2JPQy9BTEZtN1pyb1N3Z3JWcXdRQUFBQUFBQUFBQUNvdlZ4OUxpbzlxM3FpNmJrQW8vNzkvU29VQ3RxOWUzYzA3ZWRYS3BXb25JMU1KaE45MGJHOXZUMEtMK3JwNlZGYlc1dmEydHVpK2Y1Q0NBQUFBQUFBWU9IeWY5dDd0OXh5UzN4NmVqcmN0M2RmZWYvKy9XWnljakx1emgwWWE2MFJMaW9yYTR4TTB0MWNMNlAxYm5yRUdET3FxajZtbUo1NTI5dmU5bjBDakFBQUFBQUFBQUFBT0Q4SU1BS0FKZURQL3V6UEVvY09IVXFvckJzVWFLM3JDSCt6RFcyZDY0ak4rRTV4UjdqNE10bE1kSVdmRFJzM1JDRkdYVjFkVVpBUkFBQUFBQUFBQUFCWW1ISzVuS3JWcWhKeDErMVNMbXY1OHVVS3cxQ3pzN1BIQW94OHNKRVBOWnFQcHFhbXFJOWdMcVFvbFVwRnRYK2VkQ1lkelErQ1FBQUFBQUFBNE5LUnlXVE1pdTRWOGNhbVJ0T3hyTU1jUEhnd0hCc2RDL3Y2K3FJd0k2RW1qRXlkbFkyN0c3K3Nxb1pHQmtlK3YrMkQyNGJ1K3RCZC8xa0FBQUFBQUFBQUFPQ2NFR0FFQUV2QW9VT0gvR1Y1a3dxMHdYVzgzdUJ1LzRTcmMzNFo0VVcxTS9lRmhPN3U3dWpMQjgzTnpRSUFBQUFBQUFBQUFBdlgzSVVJTXBuTVNjdm1Bb3pHeDhlakVLUDU2T3pzVkRxZEZnQUFBQUFBV0R5Q0lEQk5UVTJ4K3ZwNnRiVzErYkRpTUpGSWhFZU9ITEVFR05XT2xVMjVLbVd0ZmFXZk5zYTBHcGw5N2lZQlJnQUFBQUFBQUFBQW5DTUNqQUJnRWZ1TjMvaU5UR05qNHdwVmRhdU1iZzFOdU41MXRyYTZSVG1oWnRyYjI2TXJLdmYyOWlwYmwxVkRRd05CVWdBQUFBQUFBQUFBWE9KaXNkaXhDeGE0L3BsNVBXWXVFQWtBQUFBQUFDdysvanlCLzl2L3Nzc3VpL1gwOU1RdVczMlptWjJkMWJlKzlhMXl0Vm8xUTBORGpPV3ZBZU5ZVC9ZS0k5TzFkZXZXcnlyVXdVREIzeW11SGZsOGZvY0FBQUFBQUFBQUFNQVpvZE1EQUJheHhzYkdtSHhZa1ZHdjYyaTludkNpaFNHYnpjcGZXYW1sdFNXcUFRQUFBQUFBQUFEQXBjOWZyTUFYUW9rQUFBQUFBSUEzZDY2Z3ZyNCs4Tk9KUkVLVlNrWHBkTnI2R3JWampsNTFzc21WUnJlWGxsdGpkMXZaeDFSV3Z3QUFBQUFBQUFBQXdCa2p3QWdBRnFGOFB0K2txdDd2eWlyWHFYcW5VRlAraXN1WlRFYXJlbGVwdDdjM3V1cXlEekVDQUFBQUFBQUFBQUFBQUFBQUFBQkxReTUzOVBxVHYvaEx2NWowQVViOS9mM2F1M2V2ZmZpaGgyMjVYRGJWYXRVSUY1V1Y5ZHM4Ym95NXd0Vi9wSmltdG0zZE5oWGE4RTlpc2RqMmxwYVc3Ny92ZmUrYkZRQUFBQUFBQUFBQWVFa0VHQUhBSXBIUDUrZCtwM2RvVmsydUU3VkpSbW1ocHVMeGVIU2xaUjlZbEVxbG9qQ2pJQWdFQUFBQUFBQUFBQUFBQUFBQUFBQ1dMaisrMEk4dDlCZEZMQmFMMWhYTnpzNFNZbFJEUnNadi8xZ1FCUFd1N2h3WkdWbWV6K2VMMjdkdkg3cjU1cHREZHpzVUFBQUFBQUFBQUFBNENRRkdBTEI0dExtU1ZxZ3ZLS0drbGIxU3FDay91R0RGaWhWcWJHclU1czJiby9BaVh3QUFBQUFBQUFBQUFBQUFBQUFBd05MbHh4ZDJkM2Y3WW02ODhVYXplL2Z1eXE1ZHU2bzdkdXlJVDB4TUJEYTBCQm5WZ0pXdGMxV2R1L0hiMWxvZmFQU3dteTYrNWpXditZVlNxVlIwdHc4TEFBQUFBQUFBQUFDY2hBQWpBTGpFNWZQNVRsZmx3akI4amVzc2JReE0wT3pxbURIMFhkZUNDWXp2c0ZaYlc1dlM2YlM2dXJxVVNxY1VCSUVBQUFBQUFBQUFBQUFBQUFBQUFBQmVyS0dod2F4WXNTSUl3MUJUVTFNNmRQQlF0VlFxK2R0Y05iR0dyR3lycXlveEUzdWJxMGZ5K2Z5VHJoNXo5UjRCQUFBQUFBQUFBSUJqQ0RBQ2dFdGRXV3NWdUdMMEhtUE1XamVua2ZDaTJva0ZzU2lzNklvcnJsQXVsOU9LN2hVQ0FBQUFBQUFBQUFBQUFBQUFBQUE0bmZiMjlwZ3Z2YjI5cWxRcWV1QnJENVFuSmlZSU1LbzlQeTdYWDl6eVAxaHI5N3Z5ZjZyVjZxTnVGZ0ZHQUFBQUFBQUFBQUFjaHdBakFMakU1UFA1d0ZWSlYzcFUxYlZXOWtaM3U5ZklMSGQxU3FpSlpESVpsZVZkeTVYSlpOVFMycUpVaXQwQkFBQUFBQUFBQUFBQUFBQUFBQURteDQ5RGpNZmp1bkxEbGZGQ29hQ21waVpOVDAvcitiN253MnFsYXFyVktsZTRySTFBUmsyeTJtS002ZDI2ZGVzYXR5OGVUaVFTZTRhSGh3OS82bE9mbWhVQUFBQUFBQUFBQUVzWUFVWUFjT254QVVacFZiVE8zZm81ZC9zYStUQWoxSlFmTkZCZlg2L0xMcnNzR2pCUVYxZW5JQWdFQUFBQUFBQUFBQUFBQUFBQUFBQXdIMzRzb25mbGxWZkdLNVdLV2xwYU5EZzRhQWNPRDRTem1nMElNS3Fad01nMHUzcExZSUtTcTIrUHhXS2ZkSFVsbTgyT3U1b0FJd0FBQUFBQUFBREFra2FBRVFCY1F2TDUvR1pYWFJhRzRidE5ZSmE1MjkydVE3VFJ5Z3Exa2N2bHRIejVjblYwZEtoaldVYzA3VHFsQ1M4Q0FBQUFBQUFBQUFBQUFBQUFBQUJuelk5RDdPenNWR3RycTNGMTdQQ2h3L2JRd0tIcS92Mzd6ZURRb0xHaEpjeW9OdngzTUhKRzVwMWhHTDRsblU0L3UyM2J0cWx5dWZ3QmEyMzQwWTkrZEZBQUFBQUFBQUFBQUN3eEJCZ0J3S1dscVZxdGRobGpibkszRTY1a0NTK3FyVlFxcGZyNmVqVTFOZmxCQWdJQUFBQUFBQUFBQUFBQUFBQUFBRGhYUHNBb25VNUhwYjYrM3NqS3pwWm03ZUhEaDJWa0RPTkhheVo0b2F4eiswRnVOOVM3MjFQR21MUXJGUUVBQUFBQUFBQUFzQVFSWUFRQWw0QnRIOXoySGxlMTJORCthbUI4bjZmcXJiV3VuNU9MNTlSQ1UzTlRGRngwOWRWWEs1UEpxS0doUWJGWVRBQUFBQUFBQUFBQUFBQUFBQUFBQUJkQzE0b3UwN0dzSTNiVnBxczBPenVyYjJ6L3h1ejA5TFRkdDI5ZldxZ1phKzFxWTB3MUZzUys1U2FuOGx2emYyZGtudDEyOTdaUEN3QUFBQUFBQUFDQUpZSUFJd0JZZ082NDQ0N1l4bzBiZlNKT05pcFdxK1FEakt6dG5Mc1A0VVVYWHlLUmlPcGNMaGNGR05YWDEwZnovRzBBQUFBQUFBQUFBQUFBQUFBQUFJQUxKUmFMR1greFJWL1M2YlNhbXBxaU1ZeCtMS1BudzR5czNIK2haWURwUldTTThlTjlmZWwyWmNxVlhyY1hnbncrMytOdXoweE5UUlVtSmlaSzk5eHpUMWtBQUFBQUFBQUFBQ3hTQkJnQndBSzBjZVBHZGxkMUt0UzdYTDNGZFdSZTZlcWtVRlBkM2QycXE2dlR0ZGRkR3dWSXpRVWFBUUFBQUFBQUFBQUFBQUFBQUFBQVhBenhlRHdxYjd6dGpkSFZGd2NHQmpRek0yTy8vS1V2bDJkblo0T3BxU20rSTFBRDV1aVZTZXV0N0Q5emRVV2hmbGxXWDhwbXMxL0s1WElQdTNuN0JBQUFBQUFBQUFEQUlrWG5CQUFzSUgvOHgzK2NHdTRmOXVGRmExMC81aHByN0NwcmJaMHJzYVA5bXJpb2pQL2ZSRmNxOHFXeHNWR3VJemtLTDJKL0FBQUFBQUFBQUFBQUFBQUFBQUNBV2tzbWs2cFVLdjRpamFaUUtKamg0V0U3TXpPalFyRmdaSVVhc05iNlBLTzROWGFacXplWTBKVHUvdURkeXdxVndxNHA1MU9mK3RTc0FBQUFBQUFBQUFCWVJBZ3dBb0FGSkFvdlN1bnR0bXAvMG5WYTNqNDNuN0NjMmdoTUVGMmxhTzNhdGVyczdOU3l6bVZSa0JFQUFBQUFBQUFBQUFBQUFBQUFBTUJDME5MUzRvdnA3dTVPREE4UGgvdjI3U3Z2M0xrenR1dTVYYkV3REgyWWpuQnhHV05pcnNvWm1UZks2bzJod2lOdTNtUXltWHhuUTBQRFliZnNlUUVBQUFBQUFBQUFzSWdRWUFRQU5mYmU5NzQzbFhOUzhkVFB1TWtPSy9zVE1sb3IxSXdQTGFxcnExTkRmWVBhTzlxalVsOWZIODBIQUFBQUFBQUFBQUFBQUFBQUFBQllpTExack9ucTZvb2xFMG5UMGRHaC9YMzdLNFZDd1E0T0RzYkRNT1JxbWpWaVpPcXNiTnhhKzY1WUxEYTFkZXZXaDkzc0kzZmZmZmZYQlFBQUFBQUFBQURBSWtBU0F3RFVXRXRMUzhvWTA2cFFkN3JPeVVZM2E3TlFVNjV6V0UxTlRWcld1VXpyMTYrUGdvdUNJQkFBQUFBQUFBQUFBQUFBQUFBQUFNQkNsY2xrakN1eDl2WjJYVjY1WEEvSEg2Nk9ESStFSXlNalBzQklxQTByVytlcU9uZmpYWDdheVB5dHE1NXloUUFqQUFBQUFBQUFBTUNpUUlBUkFOUklQcDlmNzZxc3RmWVhYS2Z3TXRjWmVZWDR2Vnd6UHJUSUdLTlZxMWI1S3hDcGUyVzM3OGlQd292OGZBQUFBQUFBQUFBQUFBQUFBQUFBZ0V2QjNKaklEUnMySkFxRlFyaWllNFVLMHdVOTh1Z2psV3ExYW1abVptSkM3UmhkYTJVdjM3cDE2ekpyN1o3QUJvOHBwaDEzM1hWWHZ3QUFBQUFBQUFBQXVBUVJsQUVBdGRQbWkrdDQvR2xYZDdoU0w5Uk1FQVJSWjMxN1I3dnE2dXEwWXNVS0FRQUFBQUFBQUFBQUFBQUFBQUFBWEdyOGVFZ2ZZdFRlM2g2NHlhQ3BxVW1UazVQMjZSMVAyMUtwcEptWkdlSGlNeisrb21hUEs2RXJsd1VtZU5UVlJWTXloQmNCQUFBQUFBQUFBQzVaQkJnQndFWHk3bmUvTzdGOCtmSk1ZSVBYaHdwZkgxYkQyMXcvNURJajB5YlVUTFl1cTJReXFjMmJOeXVWU3FtenMxTUFBQUFBQUFBQUFBQUFBQUFBQUFDTFJTNlg4OFg4eTUvL2wvSHA2ZW13Ny9tKzB0NjllNE05ZS9ZRXBYTEoyTkFhNGFJeU1vRzFOdTF1WE92S0JpWDBTL210K1JHRit1T3FxZTcvMEljKzlIMEJBQUFBQUFBQUFIQ0pJTUFJQUM2U3JxNHUzN2tidUU3ZU9tTk1tK3RzYkhmVEhVSk51UTVnQlVHZ1RDYWpkRHF0UkNJaEFBQUFBQUFBQUFBQUFBQUFBQUNBeGNLUGsvVHE2K3VOdTIzcTZ1cHNJcEd3eHBob0hLVjEvK0hpTTM0SFNGbGYzRDZvdUgyUmRidWpKUmFMSFJFQUFBQUFBQUFBQUpjUUFvd0E0QUxMNS9OSlYyMVFWYmRZWTkvbk9oWWIzWFNUVUZQTGx5K1B5cXJlVldwdGJSVUFBQUFBQUFBQUFPZlRrWUdES2hhTE90amZwMHFsb25QVjBibGM2WFJHUGIyWENmTzM4NW1uM2I0NGRNSThmMEdEanM0dTFlWHExZHJXTGdBQUFBQUFnS1drcnE0dTJIalZ4dFFWNjYrSXpsczkrK3l6NVlHQmdmQ3hSeDlMenM3T0dxRldPcXlzTC9lb0t1VzM1ci9wNWczazc4Ny9uQUFBQUFBQUFBQUFXT0FJTUFLQUN5aWZ6L2U2S21tTXVjN0c3SHBUTldsckxMOTdheVFXaXlrZWo2c3VWNmZHcGtibGNqa2xFMGtCQUFBQUFBQUFBSEMralkrUGFXcHlRcnQyUHFPWm1XbWRxNEdEL1Vva2t4b2VPbnJ4OVdXZFhXNDZwZWFXVmdWQkVCV2NiT2pJZ0hZODljUUo4eG9hR2hWei9RWFZhcFVBSXdBQUFBQUFzR1FaWTZKelN0bHMxclMydHBxdXJpNlZ5MlVkT1hMRWhtSG93NDBJTTZvaEs5dm8vaWw4OElNZmZMM2JINFY0T1g1UUdVM2NkZGRkRXdJQUFBQUFBQUFBWUlFaFJBTUFMcVNxN3BSUlU2ancxNk5wdW5KcnhnUkdtVXdtQ2k3YXZIbHpGRjVVWDE4dkFBQUFBQUFBQUFBdWhCMVBQcUdEL1gzNjAwOStYT05qb3pwZmVub3ZVMTJ1WG05NSt6dlUwYmxjdDk3K00wcWwwMHFuTThMSlB2L1hmNlhQZmViZUUrYjViZmpPTzkrdEt6WmNwZFZyTGhjQUFBQUFBTUJTNUM4SzZjdmxsMThlZmFkZzNicDE4c0ZGLys5di9sKzVXQ3lhdzRjUEo0U0x6dmhrcWFNMnU1czJVSENyMjAvZnQ0SDl2NnJvSVRmL0lRRUFBQUFBQUFBQXNNQVFZQVFBNTFFK24wKzdLdTQ2Y0c4TXdxRE95bDR0cXpUQlJiVlZWMWVuUkNJaGYzV2dURFlUQlJuNWFRQUFBQUFBQUFBQUxqWFRVNU1xbFdiMTVPT1Bxcm1sVllsa1VxdDZMMU5QN3hyVjVYSktKbE1DQUFBQUlNMlVxZ3F0MVZTcE1xLzd4d09qdGpvK1R3TUFsaTQvcnRLNjk4NjFsNjhOU3JPbDZDS1IwOVBUT256NGNEVGZGMXhjYnFzYnQ5Mk5qRnJkNUNzVnFDR2Z6L2Y0UUtOcXRUcTlmZnYyRVZmbTkyRUhBQUNjdFh4ZXdkUGFFRzllbnNtVWt2WG40Nm9peFh0L2NmdVlBQUFBQUFCWVJBZ3dBb0R6SytkTG9PQjNYQ2RoaDd0OXRWQnpiVzF0U3FmVHV2NlYxeXNJQXNYanZQMEJBQUFBQUFBQUFDNU53ME9EVWYzbEwzeFdkYmw2UGZIWTkvV0cyMzlHdDk3K0puWDNyRkt5aFM5Y0F3QUFBTjVJb2FSS2FMVnZkR1plOTAvSEF3S01BQUJMbXI4NHBQZmExNzQyWGl3V05UQXdvTDE3OTlyUjBWRmJLcFdPQnVuZ29qUEd4RnkxVHNZVmFjcUdkcXFxNmpaM2U4ZmIzdmEyN3hOZ0JBREFoZWZEaTFhczZzaTZOOTNPcE9LZE9tZVZBZmNQQVVZQUFBQUFnRVdGQkFjQU9BL3krWHluU3VvTUsrR05DclRheUt6VzBUQWoxSUFKakFJVHFMMjlYYWxVU3BldHVTd0tMWXJGWWdJQUFBQUFBQUFBb05aNmVpK0x5bnpNekV5clhDcHB6NjVuTlQwMWRjS3lVbWxXaHdjTzZwR0hIdFRFMklodSsrbTNhc09temFwdmFJd0MvUUVBQUlERnFsaXBSdUZFL2VNRlRjMVdORFJUMGxpaHJMRmlPUW91S2xkQ2pidjVvYlhSL1BtSUIwWmYyWGxZaVZpZ2JDS21YQ3F1WERLdXp2cVUwdkdZMXJUV0tlV1dOYVFUQWdCZ3NmTmpMcHVhbXJSNjlXb2xFZ2t6Y0dnZ0hCc2JzME9EUThIczdLeXhJc3lvUnBLdTVHeG8zeVNqRzBlSFJqZm1QNWdmTFpRS1g2bFdxNVZQZk9JVDB3SUFBQy9yemsvZm5DNVBGcEwxOVprV3VWTUE4V3E4TFpESmhncVRzalpuak9KVzZ2UUJqc2FhbFArQ1NpaWJNQXB5a2ozbjd3cFpHNTk2ejMrL1pYaHUycDJTbUhLZnJpcXVnMi9DMm1wRjF0ZXFHR09tRkxvU2xLZmlwZXE0a3JGQzAvTTNUK1R6K1ZBQUFBQUFBQ3d3QkJnQndQbFFVcWM3YWJuWmRRYitySnU2d1pWNlYvaG1RSTNFZ2xqMHhZek81WjFxYUdqUW1qVnJCQUFBQUFBQUFBREFRdUhEaTdiY2ZPdTg3anM4TktqcHFVa2RIamgwVW9DUkR6WTY0dWFQajQzcXljY2YxVXEzM2hVclY2a3VWMCtBRVFBQUFCYTFZaVdNUW95ZUdaelN3RlJSenh5WjFMN1JtYWpzR3A3U2RLbXFzMVdYaktrdG00cUNpenJyMDlxOHZGRk5tVVFVWE5TUWloTmdCQUJZRXVZQ2pGd3h2YjI5ZXVxcHA4SURCdzZFazFPVFpyWThhOFJYNW1zbCtVTDVHVm01LysxR0dmVzcvZlZ3TEJZcnV2a0VHQUVBTUE5TlVycWF5ZVNzNHIyMmFqdGRyOXA2cTdCTi9rTG1ScDJ1VGh1WnpZRXhnVFhSOTRQYys2NkovajBmakxIK24yUFQxdXF3cTRvS3czNjN3TCtuOTd1bks3cDJEWVJCZFVDS0RaUVQxVDUzUm1Ka3U3YjdEa00ralFFQUFBQUFGaHdDakFEZzdKaDhQbC9uNmg1MzJ1K2QxdG9yM2NuQkRZR0NGYTR6TUNQQ2kyb2ltVXdxbDh0cDVjcVZhbTFyVld0THF4SkpCbzBCQUFBQUFBQUFBQmFXS3paczBwdmYvbzU1M2RlSEZJVmhWVys0L1UxUmdORWZmU3l2YXJXcXZyMjdUN2hQcFZMUjlxL2VwejI3ZHVyWGYzdXIyanVXQ1FBQUFGZ3Mrc2NMR3BvdTZSdDdoelE0UGF2dGU0WlVDYTJtU3BVb3lLaFlyaDRMTlNxV3orMDdmTE51UFQ0VWFhUlEwcTdoYVQxK2NFenhXS0MvZnFKZjhjQ291ekdqOW14S3I3K3NUV3RiNjdTMkxhZFVQS1pFWUFRQXdHSzFhdFdxMklvVksyS1hYWGFaS2JselVkLzU5bmRtcmJVNmVQQmdTcWdaSzN1RmtlbU9CYkgvRlpoZ1lPdldyVjhKZ3VEUmZENy9tQUFBV01MdXVPT09XUHZOZ3hrMXFETWV4anVyVmJ2R0dMUGN2WHV1ZDMrOXA5MHBoUldLdWY4VVpnSTM3ZWFuWlUxU3hnYm1XSzA2YTNSUi90ZzNSczN1YkVib25xelJQV1hvUXdvRFY3dFpKVGRka3JVbFk1S0ZxbFRkMUdOSE4zMzZEYUg3TFBhNGE5MlVzZUV1OTByRzRvSDJUYy9FQisvNWxhK09Dd0FBQUFDQUdpREFDQURPZ3V2WTh5Y2g0N1pzRzB6TVhPVk8rbDJoS0hIOS9LU3A0K3pFWWpHbFVpazFOemVydmIxZG1Vd211Z29RQUFBQUFBQUFBQUFMU1gxRG8xWjA5NXpSWTNLNWVoV0x4YWoyWHhJN1hoajY4Y3VoRHZidlY3VlNFUUFBQUxEWStLQ2lzV0paencxTnFYK2lvRzgvUDZ3THhRY2orZUtEakx6aG1hUHpkdzlQUndGRy9lTkZkVGVtdGFhdFRtMTF5ZWkrU2V2SERCRmdCQUJZdk9ycjY2TUxleVlTaVNoSU81dk5odVZ5bVRlLzJtdVNEem93Wmxsb3cvMG1NTSs1YzRWN0JBREFFamU0Y2RDc3lDcnVUaWZrUXRrMlk3UkdzajN1dzh0TmJuSGFHcTN5OTV2TEo3SkhKNDVPbTZNVDlpSiswbkhQbnp6NmRDWjlZcnRlYUlUNWNXTk1FRXhZeDczL1Y2ekNNVGVqYUVJVHQyRXdWSTFOalFnQUFBQUFnQm9oMVFFQXpsQStuOS9zcWg3WHdmY0hKbVppTmpxSmFSS0VGOVZPTHBmelYvZFJTMHVMVnZhc2pEcklmWmlSTWZTTkF3QUFBQUFBQUFBV2g3YU96aWlvNkpQMy9KVU9EeHpVYi8zYUwycTJXTlR3MEpGajk5bTc2MW4xN2R1dEh6MzF1SVk3dTdSK3d5WUJBQUFBbDZLQnlhSWUzRGVpWndZbmRkL09BUTFPbFRSZXFtaTJVbFhwaFdDaFd2QmhSUWNtQ2xIWjRkcFduNHhINWViTDJyUzJOYWUzYjFxaGhuUkNEU21HWmdJQUZxZTZ1anBaYS9XV3Q3NGw3WU9NK3ZmM2EzQm8wRDc2NktQaDdPeXNLWmZLZ1hCUldWbmo5a25NM2V5MW9mMVZZOHc3dG0zZE5oN2E4TCs1ZVE4WENvVWRuL2pFSjZZRkFNQWk5VnQvK1lxNjJiRk1MR3pLYmpHaDJ0eGI0eFlqdFZabHJvOVp4YTFSM01nbTNKdG1RdVpvUU5DbHpJWmhMcXBsM2lnRlB1M29aOXlaa29xMVlTVWJ6MDY5OTlOdm1IVkxIM2JiWWR5OTlnZUR3QXo5OFM5ODlVRUJBQUFBQUhDQjBVc09BUE9VeitkYlhyalo2MHFQNitCYjZUcjZZcTdPRWw1MDhjMkZFMlV5R2FYVGFYOTFuNmhqUEp2TkNnQUFBQUFBQUFDQXhTWUlncWgwZEM2UHBwdGJXalUrUGlZTi9mZysva3Rqdm95UGpTcVZ6Z2dBQUFDNGxNd0ZFNDBVU2pveU5hdDlvOU12bEJrM3I2eEN1YXFGd0ljWWVhTXpaVTNQVmpRYWorbjVzWUxpc1VCOVl6TlJnRkZQWTFhcGVCQVZBQUFXRXo5MjA1ZGNMbWY4ZWFpbTVpYVp3S2l4c1ZFek16TXF6QlNzbXg4dHc4VmpmbnpGejBhM2g5Sld0amtXaTYxeTB3UHBkSG9xbjgrUGI5KytQVXBDZHpVN0J3QndTYnM1ZjNPOGQ1WGk5WWxNY2pZb0pHZUxzWTU0aTRtRlpkdnJ6aHkwU3JiWC9lWGU0TjRjZTJSOHZvOTM3TWFsejVqb1pJTjdPWE5mbnNtYUYyYTQxMTV3aTh2VzJoRTNQYWhBKzhOcUpmZSsvM0ZyWHhERXlqT3gyWEtsMERBN1diOXJWcC9kV1Azc1p6KzdNRTYyQUFBQUFBQVdCUUtNQUdDZWJOVyswL1h2clhXZGVyL29KaHY4dkIvMzkrRmk4MEZGZnZ1LzhiWTNLaDZQUjUzZkFBQUFBQUFBQUFBc2RnME5qWW9GZ2Y3RkwvMXI3ZG4xclA3YmYvN0RrKzd6MElQZlVMMjczNDJ2ZnAwQUFBQ0FTOFd1a1NtVnFsYnYvK0lQTlZZbzY0bUJjUzEwdnIybGFrVmZlbVlnbXY2TFI1NVhZSXp5dDY1WGQwTkdiOSswUWdBQUxGWis3R1ozZDdjdlp1UEdqYkg5ZmZ2RHZyNis2bzkrOUNOejhPREJJQXhEQnRuV2dKVk51U3BsUS90YmZqb1d4SGE1MjFPdmVjMXIzdW9tSzl1M2J6OGdBQUF1WVJ0V3FTMVFmSDFZbWQyU3RMRzExdGlmckpUVjZaY2RDeXRhcXF6SnVNOENHYmNOWHU4blRhaTN5d1NoK3l3d1dRM0xROGxLN01Ga01QVlF3L1NLaHlaL3NyOVBuOVdJQUFBQUFBQTRUd2d3QW9EVHVPT09PMkt1UTlWZm5yak5GOWVSZXBucjFWdmhPL1lJTHFxZFJDS2haREtwNXVibXFQTjdyZ0FBQUFBQUFBQUFzSlMwdExWcmFQRHdLWmROakkrcFZKb1ZBQUFBY0NrWUs1WTFWaWpwaVVQam1pNVZvL0NpcVZKRmw2S3F0UXBkMlRVOHBhblppaDQ1TUthNlJFeXJXK29VRDB4VUFBQllyTkxwdEJvYUdreDdSN3Z4WXoySGhvWnNwVkt4aFVJaEVHckdLQW95OE9OdmIzU1RsUTk4NEFOUHAyMTY1Z01mK2NCK0FRQndpZmkxVDkvY2FhcEJ5cGl3dldyaXkweFZsOXRBYTl4ZjJjdmN1MTFTZURreFkwemFmU1JZNWs1YnJMT0JLV2ROcXUzWFB2M0dvWGd3TTFJSkU2WC84b3ZiQndRQUFBQUF3RGtnOFFFQVRtUGp4bzJOcnVwUlZXOTF2WGR2ZFIxNGExeWRNMHM1algwQjZPam9pTUtMcnJycUtpVlR5U2pNQ0FBQUFBQUFBQUNBcFNTVHJkT3J0dHg4Mm9EL1J4Nyt0bHVXRUFBQUFIQXAyTDU3VUk4Zkd0ZC8rdmJ1S016b1VqWlRxa2IxbjN4M3IzTEptRDczMUVIZHNxWmQ3M3YxR2pXbEUycks4RGtkQUxCNHRYZTBCNjVvL1pYclZhMVc5UTkvL3cvRm1aa1orOXh6ejJXRW1yR3lLM3dkVnNPL2R0VlVQSWovMzZxcTMzYTNQeTBBQUM0Uk1RVzNLMUMzVE96dENXdWJiYUNlZ08vMnpKUHhZWkk1YTVWejlRcGp6TzJoZGVjdmd1Q1ptS3FIclUxOUx1WStJN2hsOXdvQUFBQUFnSE5BZ0JFQXZNaDczL3ZlVkV0RHl6VW1OS3RkQjkyTjdwem1WVVptbVZ0RVVrNHR1SFBLc1NDbXBxWW1OVFkycXJPejAxK2hKd292aXNWaUFnQUFBQUFBQUFCZ3FUSEdLSlZPcTc2aFVUMjlsMmw4YkRRcWN5WW5KaFFFWE5nZUFBQUFDMU5vcFZLMXFxY0dKdlRVNFFrOXVHOVl1NGFuVmF4VXRaaVVxbFlEazBWOWIvK28vdXZEZTdWNWVhTTJkN25QOEkxWlpaT01lUUVBTEY3K3ZKUS9mM1hsbFZmR3k1V3lyYXVyVTZGUXNQdjM3dzhybFlvcGxVcWN1S3FkcEpXOXh0Vk5XN2R1N1hEMVRtdnRUcmQvOW4zaUU1K1lGZ0FBQzhTNy8reTF5NVBKV0tPeHNkZkwySXpySGZOMWcxdTBMSlF5UkJlZE8ydE5tekUyYmEzK2laRXB2ZmZUdHpTNTJXTlZoWTlYZ3ZMSVBiL3c3VDRCQUFBQUFIQUdDREFDZ0JkcGFXbEpLZFJOcm9OdXM1dDhxenNSbDNKMVdxZ0ozNG50ZzRyY2ZsRnZiNjlhMjFxVnkrVUVBQUFBQUFBQUFNQlM1YytkcDlNWk5id1FZTlMzYjgrTEFvekdCUUFBQUN4VW9RMVZySVI2NU1DWS92cUpmajB6T0tYRFUwVXROcVZxNkY3WHJFWUtwU2lvNmEwYmxpdWRpS2t0bXlUQUNBQ3dxTTFkbkhMOWxldWo3eXJVMTlkclpIakVEZzBOVldkblp3TUNqR3JEK0pPS2toOFRmYTJWOVJkM2ZZT3N2aVNqTHlVU2lTTnVQZ0ZHQUlBRnc3MDNMWGZ2WGowbTBLOVlhMXJjckZYUjFiRTE5eS9PbGZ0azBPYitiWFBicy9lRk9kZElkbDlNd2IycUpIYTVHUVFZQVFBQUFBRE9DQUZHQU9Eazgza2ZVQlNvcXZmWjBOYTVNNXEzdWM2NUp0YzVsM0h6R1RGVUF5WXdhcWh2VUgxRHZWYjNybFpEWTBQVWlaMU9reVVGQUFBQUFBQUFBTUI4OVBmdFZUcVRWVnY3TWdFQUFBQzFGbHFya1ptUzlnelA2RzkySE5Eamh5YWk4S0x4WWttTFdUVzBtaWxYOU9DK1lmV05GelJUcXFpbk1hc2JlcHFWakpIZkFBQlkvTnJhMnRUVTFHU3kyV3g4Ykd6TURnd01WUHI3KzRPUmtaSEF1dmRKL3g4dU92ODlrcXpiOXE5eW0zOWxNcDY4WmVzSHRvNVhiZlZQcXRYcXhNYys5ckZSQVFCd0VkM3hoNi9LTEc4TjJxM05iSEtuRHpZRnNodXR0VjN1VTBLM3RTWmpTQzI2NE54MmIzVlZuVEhtWHdXeDJOQjcvK0lOYjdWR0Q3b3pHODlNU2Z2dS9jWHRpeTk5R2dBQUFBQndYaEZnQkFCSHhhTmlkTHVSU2JzT3VSdUVtZ3BNSU5kWkhZVVlyYjVzZFhSRm5ybXI4Z0FBQUFBQUFBQUFnSmMzT2pLaXVseUpBQ01BQUFBc0NLR1Zwa3BWSFptZTFYMDdqMmhnc3FqRFU3TmE3UHpyRHF0V3UwZW1vM0pEZDdOS2JucHpWeU1CUmdDQUpTR1h5L25LK0JDajRlSGhNSkZNVklkSGhnTXphbVNOZTZNa3Y2Z1cvSWVRcERGbWphdlhHSm0xN25iUmxjKzU2WW9yQkJnQkFDNnE5bFFxRm9TSmxvcXFtNHgwZXloZDRkNlhPdjB5d29zdURyZWQzWWMyNHorNGJWR29LUmxkWTYwWk15WSs1ajRlRExqNUJCZ0JBQUFBQUY0U0FVWUFsclM3Nzc1N1U3VmFYVzZ0L1hWWFZya091RFZDemNUamNYZlMwK2p5ZFplclBsZXZOV3VQN281RUlpRUFBQUFBQUFBQUFIQ2lWRHF0cnU2VkdoMFpQdVh5aVlseG1ZQXZSQU1BQUtEMmRnMVBxVytzb1BmODdST3FXS3Q5bzlNS1F5MUpuL3JPYm1VU01SWExWZlUyWjNYN0ZRU09BZ0NXRGg5aXRHblRwc1RhdFd0VkxCYjFnOGQrTURzK1BtNS85S01mcFlXYXNiTEw1WE1YUS91NVdCQ2IyZmJCYmQrdzFqNTE5NGZ2L3BRQUFMaEFmdTFQYnM3RjQrVVdtMHJmYVVPdHFOcndUY1lvWTJVeWh1ODgxcFNSemJwLzA0R3gvODU5VHZnM09RWGZlYytuYnhrMmlmRHVhbG1WLy9LTDJ3Y0VBQUFBQU1DTDhNYzhnQ1V0RE1PRU1TYnI2bFkzMmUwS0hhQTE1Z09NMHFtMGtxbWtzdG1zQUFBQUFBQUFBQURBNmNYakNRV25DU215WVJnVkFBQUFvTlpLMVRBcUJ5ZUxxcmpQcU9XcTFWSTFVNjVHWmFwVWNhVXFBQUNXa2xnc1pseUp4b3FtVWlsbHNoa1ZDb1dsKzhGZzRRaGVLSDRzOVl3ckhXNGZkUWdBZ0Fzb1ZpMEVRVFlUaEZZdE1xNUlYVDQ2eHdnMVo4emNaNE1HdDBjYVhPMC9GOFJpWmNWVkVRQUFBQUFBcDBTQUVZQWxKWi9QKzk5N09aVzFXVEc5MVliMmpXNTZBNmM0YXl1VHlVU2QwRmRmZmJXL3VvNmFtNXRQKzJVTEFBQUFBQUFBQUFCd1ZLVlMxZmpZcUlyRmdnQUFBSUNGeUlmMFZFS3JmL3ZsSjlVM1Z0QjRzU3djOWUvKzRTbTFaWlBSTnVyTXBYVDdGY3NFQU1CU2tVZ2tvdkw2MTc4KzVhZGY5ZXBYYVdabXhuNzVTMTh1ejg3T0JsTlRVM3pQb1FhTVQ1YVM2bHg1cTVWOTg5YXRXMy9UV1BNMU4vMDFVekgzNXorYTN5RUFBTTdSYi96NXpXdHRMSkdyS3J5bkluVzVONThWd2tLM3hmOVRWZXhteFRYMjNrL2Y4a2taN2ZqVW5RL2NMd0FBQUFBQVhzQ0pmUUJMUmo2Zno3bktKMzl2VUtBTjF0b1Y3b1JaZzFBelBxVEloeGZWTjlTcm9hRkI2WFJhOFRodlRRQUFBQUFBQUFBQXpJZTFvU3FWc3NJd1BPWHl1bHhPYVhjZS9seU5qZ3lyVkNxcDZwN0xQOS8wMU5TeFpmRjRRckY0VE1sa0tqcnYzOUhaOWNMODgzZSt2MXlhMWNqSWlNSnFWWVhDdEd0SE5XcEhJbnBPbzhhbTV1aCtyVzBMNjZMd3hjS01xdFdqSVZOZWkydWZiNi9mVnZQaDk2c3ZoWmxwL3dXK2FEdjQ2ZW1weVdQM2ljVmliaDlubyswZGMvdWl1YVZsM3VzL0c1VktSWlZ5U2VQajR5OGNENVZqcjNOT1hhNCtPaGI4L2trbEUycHFhVk10K08wMDVZN1Z1ZTAyMTg2VTY0K0t4ZUxSZHN1NW54SGYzdmtvdWZXVTNjK0JYNmQvN1hQNzFmOE1CRzQvK0Q0dnZ5NWYvSDQ1K24wL0FBQ3dhM2hLWTRXeUJxZmMrK2hzUlRqWk00T1RtaWxYTkZZc0srMCtXNmZqWFBRTEFMRDBKSlBKNkR4RGQzZTNLUlFLWm5SME5KeWVubzV1KytYV1dxRW1BaXZiYW1UV21JVFpkUGNINzY0dlZvdDk3aHpMek1jLy92RnhBUUJ3QnQ3N1Z6YzJTSm1HU3RtOElqQ20yYjNKdHhpckZPL3lsNVNZKzJUbWl0YklkVlArNjcrODdXQlFMUTN0ZUY1RFg5KzJ2ZXE2UnRpZEFBQUFBTENFa1JJQllDbFpxNnF1c3NaKzJBU216cDBXcTgxb2FSelQyTmlvRlN0VytBNW5kYS9zRmdBQUFBQUFBQUFBbUQ4ZjZETWRCYlNVVHJuOHNyVlhLSFllZ29TKytjRDltcHdZajRvUGJYbnk4VWVQTFd0dGE0OENXM3h3a2I5UXdUdnZmSGNVWGxQZjBLanpaV1JrV0YrNzcwdFJrRkovM3o0TkR3MUc0VFFkbmN2ZGMyYTA1ZVpibGNsbWRjdHRQNjJGNU9DQi9kSCtlWEQ3VjEzNzZsejdmaXJhVm42YnpZY1B6Smt0RnZYRVk5OXpyL3Q1SGV6Zkh3VTNIYi85bTF0YTFkM1RlMncvdk9IMm45RXl0MTB1aExud3BQNit2YTVOajBUSGdpOTdkajE3TE5RcWtVeHEvWVpOU3JuOTR0dHgyZHAxdW1uTHphb0Z2NTMyN05xcHd3TUhvKzM0ekk0blpkMXI2T3J1aWJhVmI5dW16ZGRGWlQ2T0RCeUtqa0cvWHYrNi9YNmRPOWJuOXNQYyt2ejZ1V2dIQUFCSC9lZnY3TkVqQjhiMG95TVRLbFg1RHR1TERjMlU5UEZ2N05UbTVZM2EwTkdnM3Vac1ZBQUFXR3BhV2xwOE1kM2QzWW14c2JIcWdmNEQ1V2VmZlRiWXVYTm5iTFkwNjc4S1QxTHdSV1prZktwaXl0MTRsYXRmRlNyOHA4YVl5V1F5K1Z0dWVzaVZCd1VBd0prb1p6Wkl3VTNXNnQrRXFxNFZMa1U1OXluQlgxeitQZTR6UWwraVdyM1Y3ZE12YkY0VmZ1RW43cnJaZFJadEo3MGFBQUFBQUpZd1Jzd0JXUFR5K2Z4NmxaUU93L0JuVEdBNmpEVjExdHEwVUJOK3NMWXZyVzJ0YW14b1ZIdDd1N0oxREx3Q0FBQUFBQUFBQU9CTStVQVpIM0pUclZaUG1PL0Rjbnl3aWcrVDhmV1o4aUUxdmp6OTVPTXFGZ3I2M25lK3FVSmhKcnBkTEJaMVpPRGdDZmYxWVRXRFJ3YVVUS2IwRDMvM04wcG5NbnJGTmRjcmw4dEZ3VVpubzF3dXlmWG5ST0ZKWXlQRGV2UjczNGxDY255QXpQVFVSQlJJTXpNekhUMm43M2RJcGRQUjltaHVhWXVDYVh3Yk1wbHo3My93cjNkaWJFVFA3OTJ0Zlh2M25MQ3NycTVPMTkvNDZ1ajFOelkxSDl0dXUzZnRqTnE4Ly9tOW1wNmUxblBQUEIwdHYvSFZyMVVzSG52WjV5ek16R2g0NkxDZTM3ZFgrMTNadStjNURibnQ2MSs3ZjQzSGIvOHA5M3krNUhMMXg3YUJEelB5b1VHeFdFd05qVTA2SDN4bzBZeHIxMlBmZThqdDYwUGF0MmRYMUU2L0Q0WUhqN2hqWXlhNlh4QTcrdnI4UHVudmE5YkF3ZjZvM1pldjN4aTF5N2NuRm52NWJUQ25VcWxvWk9pSWU4N0QydkhVRDA5YTdyZS8zdy8rT1BQYi92REFvU2hjcUcvZm5taTdIM0xQNzRPM1NxV1NEaDNvZDhkVUdPM1RwUHZaR0IwWjBzVDRXQlJ3dE1ZZE0wM3UyRG0rZmY1bnl4OXo0MjcvKy9YNTF6dzhOS1NEL1gzUmMvbjlZSXlKbHZ2OTdWL251RnVmRDV2YWZQME4wZkhmdWJ4YjhVUkNBQUFzUlFjbUNxNFVOVEJWMU1oTVNkVlFGMTBtRVZOZ3BGd3lvWFE4VUZQbTVQZmw4V0paVmZlNWMzcTI0dHBvTlQ1Ym0rL1pIWjZhMVFPN0J2VzZ5OXJVMVpCVzNIMk9ENGhwQUFBc1VZbEV3alExTlFVclY2NE00b200Kzl2OWNPai90aDhaR1FuY2VURGVJV3ZIajcyMnRtcGZiMkptT3AvUCsvQ0NBVmMvTGdBQVRzM2NrZCtRV0xaeVJWdkZtUFhHVnE0TmphNlJVVWE0NUxuVEtWbTNMMWU2cnBJYktsVVRybDlsdjNuTm43OXFvdjhyM2VPZi9leG5xd0lBQUFBQUxEa0VHQUZZOUZ4SDJlMnVvNnpKeUd5VGRkUGlhbTYxNUsrKzdNdm16WnVWeVdUa09wa0ZBQUFBQUFBQUFBRE9uQStyOFNFeVB1em5lTTB0TFlySEU4cG02M1EyaG9jR284Q1dlLy9zVTlxemEyY1UyT0tEWk9iandlMWZqY0o2ZnZYOXZ4TUZDWjF0Z0ZHaFVKQjFyKytUSDdzckN1alo2OXB4T2c4OXVEMEthM3Jvd1c5b3RYdk9kNy9uTjkzekxqOHZBVVkrdkdqbk16djArYi8rUy8zTlgvL1BFNWExZFN6VGY3cm5yNkxYdTJuemRjZTIyK2MrYzY4ZS9kNTNvMkFjSDdRMGQ5K2ZmdXNkaXNWZlBzeG1abVpLVHp6MmlMNTYzeGYxdGZ1K0ZJVUVsVXNsemNlM0h2akhLTWpvdjl6N2Y2TnRjcjRDakh4N2ZFRFBmN2o3MzBmQlB2NjRPNTFubm43eTJPMjZYRTZ0YlIzNitYZjlXaFNxNVBlUEQxdWFyMHFsSEczL0hVODlvWTk4NExkT1d2NUp0LzNiM2JiMXg1ay9Udnl4OE9UamorckxYL2pzdkxhYlAwNld1Y2UrL1oxMzZyb2JYcVVyTmx4MUxNRElQN2EvYjkreDlmbDJIQjhlZFNxcHFCOHNvMTkrejc5MXgvOFZhcm10Z3dBakFNQ1M5ZVRBaE83YmVWaVBIeHlQZ294cW9TV1RpSUtBZXB1emFrb250TG1yOGFUNzdCcWUwbFNwcW4yak15cFZRNDBmbVZRdEhKbWUxUjkvZDdkOC91ajEzVTNLdW84UXlkaVpoNUVDQUxBWTFOWFZCYjRzNjF5bVRaVk4rdUVQZjFnYUhSMjFqejM2V1BMRlFkNjRxQnFzckMrL2JxdFdnUW0rNmViNThLTDNDd0NBVThqblpjWldkV1N0RGE4MVJ1K3kwaFZHWnIyd0tMaDkydWFxTmxsem1Rbk1UOFd0L1lDTjVaN1NIVS92MEdmRmh6WUFBQUFBV0lJSU1BS3c2T1R6ZVQ4YVBhdUt0c2hvdlRYMnAxMW5XVTZvcWNiR3h1aHF1MWRkZFpYOEZYSG1wZ0VBQUFBQUFBQUF3Sm14MXFwUW1OSDQySWo2Ky9aR1lUL0g4OEVwL21JQ1oycDZhbEtqSTBONjRQNHZSOEU1ZTNZOUc0WFdWTU5ReGhpbE01a29GS2l0dmVQWVkvelY3OHVWU2hUczRnTmZmR2hNTmF6cXM1KzVOd3IxOGJwN1ZybXlXbWZpYS9kOU1Rcko4YTl2UGw5TUM5MTkvSDE5Ky8vc2owTnR1ZmxXVjk0UXZhWUx6VCtuRDg3NTNuZS9wZTkvOThGajIyMitvVTl6eXVXeW5uN3lCOXEzK3puOTcvL3gzM1R3UVAvUjdmbkNldnoyOS90aFpVL3ZzY2RNVDAxcHhEMi8zL2IrK2NiY01lSDdYLzdvWTNkRjRVVy85ZnQzdWNmNWZiWk1aOE9IOXZoQXBiLzg4ejlSMFIxbnZqMCtXTXBMSkJKUk9JOFBBRW9tazlFOHY2OE9IdGdmMWFYWldSV0xSUTBQSFlrQ2dMNzc0RGVpWUorVlozRTh2QngvdlBsajhLdnV1QjBmR3oxaHU3MlVpZkV4dCsxbTlROS85ems5OHRDRCt2MFBmeUlLcFByaFk5L1gvcjU5YnY3ZlJPdmJ2MjlQOVBQMmNpcHVIODY0N2ZQRnYvay9hbTVwalFLU2ZJQ1REL01DQUdDcEdDdVVOVEExcTRmM2oraituWWMxT1h0bW40bk9SaW9lS0plTWEwMUxuZGEwWmJXK3JVSFpSRXpkamVrb3dDaVhpcnZhcUMyYlBPbXhQcnlvVkFrMVZhNm9FbG9OVE01cXJGalN3TVNzK3NabjFEYzJvMmNIcHpSVHZyRGZ1d3ZkYzgrNE52anQ5dWZmMjZ2YjFpM1RLem9iQlFEQVV1WkRodjI1a0xWcjE4Wm5aMmR0UzB1TFpxWm05TWlqajFUY3VRY3pNek1URTJyR3lsN2hxcTU4UHA5eisyTlBZSU5IRk5PT3UrNjZxMThBZ0NYdjNYLzJwbXgvTUZQdmVqWit3MHE5UnZZYUs5Tm9oTVhHeUdSRGErTStwS3FxY0dENTlQSjczM3R2NThpbjduemdld0lBQUFBQUxDa2tSd0JZalB4b281d0NYZS9xTGE3NCtzeEg2ZU84U2tkWG5FMXJWZStxcUVNNXdkVm1BUUFBQUFBQUFBQTRLejdBeUFmVytIQ1kwWkdUUTFWYTI5cFZsNnZYbWZKaFJINTl6KzU0U3Q5ODRQNFRsZ1ZCb0dReUZZWGhkSFIySFp2dmcySjhXOFplQ05HWks0OTk3N3ZSOHZVYk5rVnRPZFBBR2grY016WXlmTXJYZHlvK01NZmZkMkppUXBPdTdlMGR5N1R4RmRkRXIrbEM4OC9SMy9lOEhuLzBleWR0dHpOUkxwZDB3SzNIQnhnOTlPQTNUbHFlU0NTai9YRDg5dmRCU1ZOVGs4ZkNrbWJkTVRHcm93RlFQanpuWC8zcXI3dnRYenJyQUNNZlBqUXlOSGpLOWdTeFdIUk1OTFcwS3ZmQzhlYTN4ZERnRWRlZWNoUmc1RU9FZk1qU0R4NTVPRnArNisxdml1NTd2Z09NL1BGMmVPRFFzZU51dm53b2t5OVBQUGI5NkxXOFoyeFUyV3lkOXV6YUdRVlIrZTE0SnZ4eDZJdi9HZkw4Y2VFUllBUUFXRXFLbGFvR0pvdmFPektqSHcxTzZXTHc0VVErd0doMVMxWTNkTGRveTZwV3RkV2wxTjJZaVpiTlYrZytaMC9NVmpRd1ZkUXpSNmIwK01HeGFIN2ZXT0dDQnhoWlY4cFZxNzJqTTNydytSRmR1NkpaQUFBc2RYNnNxUTh4YW1scENmeDBYVjJkSmljbjdkTTducmFsS0VoN1JyajRqTjh4UjNXNjg1VExGR3Axek1TK2IyVm5UTWtRWGdRQWlHU1RVMG5YYytIK3VJM2Q3djQwYjdZeVBZUVhMVTd1TTBEU2ZUcEl1azhKL3NvbS9nVEs5eFNhdnFnR0FBQUFBQ3dwQkJnQldEVHkrWHluS3RvY2h1R3IzZVNyamN4YVYvdExrUkZlVkFOK0FMMHZ5NWN2VjNOTHMxYXNXS0ZNSmhOZDlmZkhmWmNBQUFBQUFBQUFBT0JNbFVxeit1cDlYOVR1bmMrY2N2bE5XMjZPd212TzFNNW5udFk5Zi93ZnRYdlh6cFBXMTliZW9UdisrUzhxa1V5NjgvNnR4NWFGMVdvVXFPVGJjMlRna0Q1ejd6M0hsdlh0MnhOTnYvMmRkMnIxMm5XdW55QWJmZW5zcFV4TWpLc3dNNjBIdC8rakJnNGVPR0daZjAyYk5sK3YxN3orRm0zWXRQbllmUCs4ZnB2NDhDQWZ0dlBkQjdmckd3LzhZL1Q4UHBqbVFyRmhxTU1EQjZOMi9zUGZmVDY2ZmJaOEVOU3dhL3M5Ly9uL3A2bkppUk9XWGJIaHFpanc1eTF2ZjRjYW01cFAyTGQrVzAxT1RPakxYL2kvK3Y1RDM5YWhBL3VqUUo2ankyYjB5WS9sM2VNMzZiZTMvb0hPeE94c1VlVnlXWC83dWYrdEh6MzF4QW5MNXZiRDFkZjZjb003SGxyY2NaR0tsdmtnSmI4UDl1N1pwZjl4ejZlaThLSWp4MjJYejM3bTNpZ1U2TC8vOVprRkE1Mk9mOTArZU9qN0R6M29yL0FiaFR0MWRhL1VLMjk2alh2ZHIzRGJiZFd4Ky9ydE1Wc3NSTWVKUDJhK2VsdzQwZXpzYkJTKzlLZWYvTGhiWHpMYWxtVjNUTlhsY201OVBXNTlXN1I2elZvdFc5NGRIZi8rNThBcnVlMTAzeGYvWDNTc1BiajlxeWUxNy9QdTliYTZueDMvZUFBQWxvcG5CaWYxc2UwN3RXdDRXaGRTWFRLbVRDS21mM1Y5cjdvYjA3cCtSYk1hVW5FMXBCTnFUQ1dVaUprekNpL3kvT2VKbkZ0dmQzMUdiZG1rTmk5djFOUnNSWHRIcHpWZHF1b3pqKy9YNGVtaXZyZC9UQmZLL3JHQ2hxWkx1cmFyU2NsWW9HdFhOQ21iaUFrQUFFalpiTmFQUVRWdi9mL2VHaXNXaStiSTRTUGF1Mit2M2J0bnJ5MVh5c2FHbHNHcEY1a1BNM0xuQm1PdVd1YytTdjJiTUJHK2FkdTJiZU51M3IxdVgrM2J1blhya3dJQUxDbi8rdDViVm1SaVlhWmNpWDNNVFRiSWFvMk53bTJ3QkdTTWRkMkd4djZ5KzVBdzlyNVB2MkhLbXRMSXArNzhGa0ZHQUFBQUFMQkVFR0FFWVBFb0txZUVPdDB0ZnduVDYxM0p1TUtKemhyeElVVSt3Q2lYeTZtcHFVbk56YzFSNXpFQUFBQUFBQUFBQURnMzVWSXBDbUFaSFJrKzVYSWY0ckxzTEFLTWZQRE16bWQyYUh4czlJVDVmbDAreE9XYTYyOVVMQjUzNS83clQzcnNubDA3bFU1blRwam4xK1BiNnR0WnJWU2lvS09YNCs4L1d5eHFjR0FnZW8zSDg4L3IyN0w1dWh0MDNRMnZQamJmaDhkTVQwMGVDM1R5enpWMFpDQUtvUEdoTlJkS0dJWlJXeWNueHFNMkZJc0ZuUzBmL09QRGZ2YTY3VmlwbEU5WTF0elNGcjF1di8xOWdKRXZjMG92dk1hSHYvUE5hUHNjSHhEbHc0Mzgvc3llWW4rOW5HcTFHbTNIZy8xOVVadU9ON2NmMXE2N01tcFRuWnYyRjdEdy9EYngyeU9WVGtmMzgvdnplQWY2bm5mNzVyRE9GNy9kZllDUlAxWlM3dmp6N1dydldLYkwxbDdoanBGWHVYcmRzZnY2Y0t3cFYvYnQyWFhTZW53UWwrZkRtdno2L0d1ZU85WjlZRkZQNzJXNjZ1cnIxTjNUR3dVNHpSM3Ivclh1ZVBLSmszNW01dXplOWF4bTNUNENBR0FwOGVFN3p3eE9hYXhZMW9VVUR3TFZKeE5hMzE2dnRhMTF1cW1uUmVmS1g0OHJiZ0xsVXE0b3JyWVhocm0wMVNWVnJJUzZmOWNSRmF1aExxU1pjalVxUXpPbHFBQUFnQi96NXg5OHlXYXpRZEdkay9GalZJZUdoNkxhQnhGYVdlSGlpMEtNWkgzaWVhdmJCZTJ1THJoOThoVjNubWhVQUlBbEoxTUpNOVltY2tiaDlkWi9iOUc0UDdHeFZNU094a21hOWE1TGNFakdkaHBMS0RNQUFBQUFMQ1VFR0FHNHBPWHorU1pYdFNuVUo2eXhLMTNIMTdXK0V4SzE0NjlLMjlyYXFsV3JWbWxWN3lxbDAya2xFZ2tCQUFBQUFBQUFBSUJ6OStUamoycnd5SUQrOUpNZlB5bm81cVl0TjBlQkxkZmRjRk1VZWpOZk16UFQrdnI5ZjYrSEh0d2VCY0xNcWN2bEZJOG45R3YvOXZlMG9ydEg5UTJOcDEzSFc5NytqcWorekwzM1JHRThQdmpHaDllTXUvTElRdzlHL1FWdmR2Zng2M2twdmczK05VNU5UUjZiTnhkTTg4YWZlclArL2QzLzhhVEgrSEFaNzhxcnJ0YncwQkhkL3FiL1QxKzk3NHY2Mm4xZmlnSitMaFMvM2I3OGhjOGVhK3VXbTIvVksyL2Fvc3ZYYjR6YXU5cnRpOXc4dzRQODl1L3YyM2RDRUk0UEFmSkJPVy85cC85Y1AvWG1uNDIydi85QzN2RjgySTR2Ny9xMTM5QTdmdjVkZXQrNzNxa2ZQUEp3dE16dkI3OC9mUkNQM3krYk5sOFhsZm40NFdQZmowS3AvT1BuMnVTZjI3ZmhobGUvVHIrYi85aXg5aDNQMzhjSExGMXovVTM2TC9mK1gvM0QzMzFlZjdEMXQ0OHRQenh3TUtwOWUzencwZHh4YzdhZTNmRlVWTC96em5kSDIvdmQ3L25OMDk2M3diWGRsMTk5Lys5RVFVWCt0YzJWRjYvUGJ5ZS9IMy9qZDdkRjdXeHRhei9sT3V0ZldKOC9adjF4K0gxM3JEL3kwTGVQTFQvWXZ6L2FEMzY1LzNueXdVb0FBQ3hXKzBabmRPK2p6K3Z4ZytONmZ1ekNoVWkrWmxXTDJ1cFN1dmVPNnhRWTl4NmZ1dkJqVWpycjAxSDlGejk3YlJRdWRQOXpSL1RNa1VsOTdCczdWYXhVTlZzNS82RkduM2w4di81dXh5RTkrSzlmcDJ4alJnQUE0RVQrWEZOdmI2OHY1azF2ZXBONTZxbW55Z2NPSEFoMzdOZ1JuNWlZQ0d4b0dVeGNBOFlZZndLeDBXMy9QL1BUK2EzNWI3aHFxRnd0LzZhMXR2Z0hmL0FINXkvWkdnQ3dvTHp2Zjl6YUU0U21wYUxxSjZWd3M1dlZ5SnZ4MG1XTVhFZWwrWFNvWU9BOW4zN0RWMnhnSC95VFgzamd6d1VBQUFBQVdOUUlNQUp3U2Nybjgra1hibmFwckxZd0ZtWURHeVM0ZWtwdCtmQWkzeW1jeVdhaTBDTFhFUmtWQUFBQUFBQUFBQUJ3ZHF5MVVTbk1URWZUUTBjT1J5VU13MmkrRjhSaWlzWGl5dGJWUmVFeFo4TmZ0ZjdGZ1VnK3VNVUhHRVZYc1g5UmNNN3ArTWY0d0piaitXbS8vdm53YlpoOTBYMTluME1tbTFVOGtYelp4eWZjZlRMWm85dWhyV09aaGdlUGFLdzBvZ3ZGdjY1VUtoVTlWM05McStvYkdxSzJKcEl2MzlianpjeE1SWUZJeDR2SDQxRklrSDlOTDdmOS9UNDZldjlNOUpqanQySFZiZi9aVSt6ZmwxSXVsMDlxaitmWEhmZDlRUDZZZUlrK29DQXdVWHQ4MzVGL2pHL0Q4Y2VGYjQ5ZmZxN3FYZ2lJYW5MYlBwMloveGY3ZmFpVDc5TTZYUnY4OFJNZGMyNTVNSTlqZjI1Zm5XNTl4Lys4QWdDd0dJWHVmYTdvM3Vzbml1NnpYUFg4aC9sNG1YaWdUREttanB6NzdKVk5LWENmUllJYURVbkpKbUpxemlUVldaL1M4RXhKcGFyL25PVS90K3U4OGR1MDRqNURUTTFXb3BKTE1kUVRBSUNYNHY0bU41bE14alM0Y3pQK2IvRHBxZW5vbmJsYXJUS0l0YmJTTWtvRllkQ3R1Q2J5K2J4UEd5KzZlbjRuQ3dFQUM5NGRkOXdSMHgxUHgyTFRwVWIzMTN0bllFSmpYUThDNThUaEdSbmZZVmFuYXREMDdzL2MzS2JjNU13OWIzNzB3aVZmQXdBQUFBQnFpbDV0QUplcTlhNDAyZERlYTJJbTdrNXFyU0M4cUxiOEFQU3JycnBLdVZ4TzY2NVlKd0FBQUFBQUFBQUFjTzRLaFJtVlN5Vjk5OEh0R2hrYTFNZnl2eHVGb1V4T2pCKzdUMXQ3aDVaMWR1bHQvK3hmNkhXMy9LVHFHeHJQNkRsOG1Nd2pEejJvUGJ1ZU8ySCtUVnR1MW9ydW5tamR1UmVDWWw3T1c5NytEbzJQamVxNVo1NCtOdTlnZjErMC9wOTgwMXVqOWIwVTM0YnZ1L3NXaTRWajh4b2FtM1RMYlQrdGpaczI2K1VjdmU5UGFlTXJOdXRuZis3bjlVY2Z1MHRmdSsrTHVoRG10dHVtemRmcFA5M3pWK3JvWEI1dHE3UHgwSVBmVUgvZjh5Zk02M0xiYXQzNmplcGUyYU9HbDltblBqekpsMDJicjQxQ2RCN2MvdFZqeTZhbUpxTnQ2dHQzemZVM2FUNmVmdkp4ZmV1Qis2TmpibzRQNkhubFRWdDB4WlZYdld4N2tzbFUxUDQxNjlaSGo5bjV6QTRkR1RoNGJMbHZUMnRidS83cHYvZ2xuWXRiYjM5VEZHTDBPMXYvNEl3ZTU0L242MTI3ZkFEVm5sMDdUMXIrcSsvL25TakVxT3RsanRjNS9yWDQxOW0zYjg5SnkrWitYb041aG9BQkFIQXBtcGl0YU45b1FYL3hhSjlLRnlqQTZLMGJ1M1REeW1hOS9hb1Y2bTZjZjNEaCtlYkRpMjY3dkNNS0ZicXhwMW4zUHZxOEszMmFLVmRVcnA2L3NVdWpoWEpVdnZUTWdOcnFVcnJ6dXZsOUxnRUFZS2xhdjM1OTNCVmRlKzIxVVlqeS8vdWIvMWR5dFRsdzRFQkNxQmtyZTZPeHhnYUo0SFpyN1g1WC9vOHIvc1RWMXdRQVdCUzZmN0svMFU2djZLa28vRjJwY3J0QzFjbFl2cStJT1MydXZGMG0zSnljalYwVmxKdi8zRTAvS0FBQUFBREFvc1FKQVFDWGxIdyt2OVoxWExXRVlmajZJQWhhalV5ZDY5eGl0RytOekYxRnRxT2pRNWxNUmkwdExVcW16dXlLd2dBQUFBQUFBQUFBTERVN25ueGNuLzNNLzVqWGZjdWxXVlVxWmUzZC9ad214c2RVY3ROelY2MU5wVE5xYW1yV2hrMVh1N0pablYzZFNpU1RNdWJNTGl6djErL0RaWHp3MFBHeTJib29IT1pNZ2xlYVhWK0J0U2QrYVgxNmFqSmF2Ly95Mk11Wm5wclF5TWl3d21yMTJEemZIK0hia1U3UC80dnF2dC9DdDhWZmdPRkM4ZHQ2WlUrdnVsM3h6K1dmODJ6NW9LQ1JvU01uekp0N0RZa3plQTJ0YlIzcWVGR0lrZzlhT3V5MnY5OFA4elUrTm5MU1BvdkY0bEY3Nm5LNWVhL0hINk8rUFM4TzlqbDhYSmpSdWVoWTNxV201aGFkcVZoMFRPWE9hTnNDQUlEVDZ4dWQwWkhwMlNpOHFCS2Uzd0NqdG14U1Y3VG50TG1yVVJ2YTY1V0tMNHhoUWtuWGpwWk13cldyU1crZUtlczd6dytyYjN6R3ZYNHJleDZ2d2ZiTTRLUnk0d1dKQUNNQUFPWWxrVWhFNTdMV1hyNDJxRmFxMGZtVjZlbnAvejk3ZndJZ3gxblllZisvcDZydnVRL05JWTJrMFdGTGxpOWhHeCt4QVlHQm1NQW1iSUxaYkE0Q0NTOWtuZUN3Yk40bEI4aHR3aTZ3TDMvQ0pwdThDWnVOU1RZa2JDRHZtb1FOSkZ4MmNMQ0RNVFkrNUV1V1pXbXNlelQzVEY5VnovOTVTaHFoWTJUckdFM1A4ZjNZajZxcnVxZTdydTZ1ZnVxcDM2TURCdys0S2l0cjR2akNoQzNpOU56UmtYSDFtY1lFcHNWWWM3a2IybUt4MkIxRjBXTmhHTzYvNTU1N0RydFNFd0JnUWRsUzNKTGF0RW01eW5qUUg4cSswWDNpOTBrbWJZM084aXdWbG9oR3QxK3NVeFJ2Zk45ZnZPcXdEdTk5N3ZkdjMxNFdBQUFBQUdCUkljQUl3TUlTNlZwanpMWHUxays1RTRsOVFsMzVFNzN1NUtHdXVQSUtOVFEwcUsydFRRQUFBQUFBQUFBQTRLWDk0Lys1T3lubks1Zkw2YUtObS9UR043OVZiMzdycmNvWENzcGtzanBiUHFUbW1hZTJhV0o4L0lUcFRjM042dWhjZGxZQlJuMnIxaVNoTmNjYlBIUXdLV2NTb0ROMCtMQmUzTFh6aEdrK2JNYlB4OWtFNXpTM3RDWEZCeDlkS0g1ZFgzL1RGcTFaZjNHeTNPZGp4L1puTkhEU2N2djU5ODk3TnN1d3ZPL1VDOXRMcFNrOTY3YXYzd1puNnNDK2ZjaytjVHgvVHNqUFQxdDd4NWsralZwYTIzU3gyMGVmZmVxSkU2WS9POFArZGk0dXZmd1ZXdGJWcmJPVlN2YXByaVNrQ3dBQW5ML3Y3eGxKZ25hbXFwRm0yNFpsVFhyM0svdDEwK29PcmUrY1A5L2RtVERRcXRhQzNucEpyN2FzNmRUV3J6MnBRMDlXTkZyMjE5N1BYb0xSVjUvWnI1UTdIdi8wdjdwQ0FBRGc1V1d6UityR1h2V3FWNlY4bmRmQXdJQjI3dHhweHlmR28zSzVIRlRLRlRwTnJRTmpUT2dPa2RxdDdKc1Y2MlkzcWVTbWZkb052L0dUUC9tVER4SmdCQUFMVC85cXBUSVQ2b3hrYjNLZjc3OWhaUEx1MTNDRzhDTE14TzBmUFc3UTQyN3NValhkcUh6ZkY2WHRBd0lBQUFBQUxDb0VHQUdZMTRyRm91LzJ0TjFhdThyRTVpcFhXZVVyTjllNWFjMUMzZmdlYWZLRnZKYjNMazl1TnpVMVhkQWVqQUVBQUFBQUFBQUF3QThaWTVUSlp0WFUzS0pWL1d1VGtKaHo1Y050U2xPVEdoa2VVcVZ5WWtlbkRZM055WE9iWUhhdTZ4bytQS2o5Ky9hb2MxbDNFb1p6UFAvNnZzd1VjcFJLcFpQNThBRk44NGxmaHE2ZTVXY1Y2SE95b2NPSDNIcXZLSXBPdmRqZkJ4ZDE5ZlM2Y3pIbnQ5dzJqcFB0N0MvYWV6bkp2akF5bkF4UGRtUjVlOVhjMHFyejVlZW5YQzZwWG9JZ1ZEYVhTNEtNQUFEQStidG54MEh0RzV2ZDcvYkdUS2gxSFkzYTNOdVNsUFpDV3ZOUkxoMm9WV205YnQyeVpCNC85OGh1alpWckt0ZGl6UVlmaUJTNDQvK2RRNVBLcFFMMU5PVUVBQURPakEvbGJtMXQxWm8xYTN3YjErRHc0Y002UEhnNDNydDNyeW01ZWdrYld6SVc2c05YeU9TTU5WdDgrL0REQnc5ZnRYWHIxckx6ZVZkSFZ2dmtKejg1SVFEQWZHYmVlZGVXYkNGU1h5ME0zdWJPV1cxMjA3THVWM0RJRnl0ZWpwVzUzQTNhbzVUWmRkdGRXenIvOEYzM1BDSUFBQUFBd0tKQmF6d0E4NTFQeGVsUnJHdGw5RzRydTlLTnR3dDE1Y09MT2pvNnRQNmk5V3B1YmxZNm5VNHVsZ0FBQUFBQUFBQUFBQmVlcjVQUDVmS3pFbUJVTHBWVW1wcEt3b05PMXREWW1EeTNEM3VaRFVPSEIzVmczOTRrOEdlbUFLTmRPM2RvZk1ZQW8vQm9nRkdqNWhPL0ROMDl2VzU1T25XdS9EcVpHQjgvVFlCUm8zdis1Y3FkWjRCUkhNZkpkajZUQUtNcHR5LzRiZVNISnd1UzVWMnU1cFp6MzkrbStmbXBsTXVxRjM4Qm8zOFBoUVFZQVFBd0srN1pjVWlsV3FUWjFKaEpIUXN2MnJ5OFJmTlZ6aDJyK3ZLNmRaM0pmSDcxbWYycVJuYldBb3g4R0pMbkE0eGFjMmtDakFBQU9BdlRBVWF1bU5XclY1dmR1M2JIdTNidGlrZEdSb0p5dVd5c3JGQVhxYVFZYlhHYllJczFkcHVScWFSU3FhKzYramFmaWttQUVRRE1ZOFdpekxEN09Wd0xVMzFHOXFlTjFHWjlNSjJBTStJRGpDNVBLWHpFS3ZZZDJ4TmdCQUFBQUFDTENLM3hBTXhieFE4VjN4Ylg0aFVLOUsvbFE0eWtGZGJhUEVFNWRlQldlU3BNSlNkeTNVbGN0YlczSmJjYkdocVN4dmxzRXdBQUFBQUFBQUFBemx4WHovSWsrT1pzVEUxTkppRTN6MjkvUnU1OFNSTDA4OEx6eitrdlAvc1o5YTFhN1VxLzN2eldXM1hOOVRlcFVHaElMdEE2RXp1MlA2MzllL2RvTHZobDhQTWR4NmRlSEZhcGxKUDdhdFhxS2ZmbDh3V3RXWCt4R2h1Yk5KLzRkZHlWQkJpZGU5OGJQanpxeURxWm5RditlMWYwS1p1YithTDJBL3RlMUdPUFBLVGxmU3ZWMGRrMTQyTjh5SkdmbjJxMW90bmd0NW5mZHMwdHJUTzhWaldaSHg5TzVZTzRBQURBd3JOcmVGS1ZLTmErOFZKeWpEcGJ1aHV6dXF5N1diOTZ3enIxTkdXMEVDeHJ5S285bjlIYkwxK2gwWEpOLy9XZm45TnMrdW96KzdTMnJXRmVoemtCQUREZmRYVjNtZWFXNW5CRjN3cFg5MUhWZzk5OXNESStQbTczN05tVEZlcHBsZjhuRE1LL2NvTkRXeiswOWR1eDRxYy8rdEdQL3EwQUFQUE9ycFUzTmpUSWZGU3lQYkphWjQwV3hnOTN6Q3RXOW1mY1lQTGYvODh0OTRVMmpqNzVqbjk2WGdBQUFBQ0FCWThBSXdEemxqVzJMekJCdnpzSnRka1lrM2FUQ2dUbDFJZHgvL2xHK0lWQ1FlM3Q3V3BwYlVrQ2pBQUFBQUFBQUFBQXdObkw1WEpKYU12WkNGTXBSYlZhY3R0ZkhPNXZUOWJHdFd0aVhLWFNsTVpHUi9YcTE3M3gyR1BPMU1UNGVCSXNOQmQ4QU5QcDVpK080K1MrbVM1OEQ4SlVFb1NUenN5dk52REduVHZKNWZMS1pNNzlHcmVYV2lmbndvYzluUzdvcVZRcWFXUjRLQW5RT2gwYlI2ZmREdWNpNDdhWm41OGdERSs1ejRjbCtmbkp1blVJQUFBV3B2RktUWlhJcWx5TE5adHlxVkF0dWJUV2R6WW9FeTZNdGtMNTlKSGpuZjYyUWhKZ05OdjJqWlhWbWtzTEFBQ2N1MncyYTF4eDlTZjVwQzdxOGNjZWp5dVYyUWx4eG5scFBEcTgzaGl6MTVVRG9jSkRBZ0RNUzdrZzNlRE9rRnptemlpMHlKaEdBZWRtbGI5U3lkYlNqV1ViYzBBR0FBQUFBSXNFQVVZQTVvMS8vKy8vZmI2NXVUbHRyRTlqVjVlVmZZTXJQanlueVZwckNDK3FqMlhMbGlVbmExOTU3U3VUUnViKzVPMlo5dG9NQUFBQUFBQUFBQUJPOWFQLzZpZjEzdmY5K2xuOWpiV3hmS2JNemgzUGF2RFFRWDM2NDhVa2ZHaGcxMDRkT25oQVE0Y0g5ZDgrOVRIOXplZi9wejd4ZTMraTdwNWUxY00xMTkrVXpOUFpHaHNkMFo2QlhacWFuRGpsdmxRcXBhWm0zdzUrOFowcm1wZ1kxNmhiZGh1ZmV0Ri9OcHRMbGp1ZG5yc0wxU3ZWYWpJL05UYzhtVDgvNU9mSG56Y0NBQUR3N250K1VNT2xxbWJiSjMvc01yWG1NbXJPcHJUUWpnRGZkbGxmTXZ6TXYreE1BcDUyajB4cE52empzd2MwV1kwRUFBRE8zM1JkeXh2ZStJYXNEMWdlMkQyZ3djSEIrSkZISG9sS1U2VmdxalFWQ25WaHJlMjFzbTkzOVlBL2VzZldPOTRmMi9nTFlSZytNanc4Zk4rblAvM3BZUUVBNnVwOWYvcTZYNDJ0K3EweDF3bVlCWkdpenl2UW52Zjl4WlozcEVyWnlkOTk5ejhjRmdBQUFBQmd3U0xBQ01DODBkTFM0dHNjQmJMcWNjTXVWOXFuN3lPOHFINzhSUUZoS2xSRFEwUFNNTjJQQXdBQUFBQUFBQUNBYzlmUTBLaGxYZDA2RitYU2xES1piRklxbVNNZGtzWlJsSlR4MFJFZFNzMWQyTTFNY3JsY1VzNlc3L1hlWHpBV3p4RGs0eTNXemhXc3RUT0dGM24rL0poZjdqazlUZWFEc3VJNG1hK1pISmtmenRzQkFJQWpmS0RPaFFqVjZXeklxaldYVnJBQWp6dWFjMGZhMVdSU2dUTFI3QjNESnV1NlFvQVJBQUN6WWJwdW83R3gwZmo2cU1hbVJsVXFGVi92WVUxQXZVZTlITmZUYlpNcldWY2EzYVJPVjEvWWtNL242MXZwQ1FBNElqRHRZV3phM1ptTnN6OFJCTXpJOUxnRGdEaW9LalVSbGVscEhRQUFBQUFXT0ZJb0FOUmRzVmpjNkFZYjNRbW1kN3ZoVFViR24zaWk0cW5PTm0zYXBPYVdabDEyMldVQ0FBQUFBQUFBQUFEenc2cit0ZXBiMWEvUDNmMDFQZmJJUS9yTjk3OVhJOE5EU1JuWTlVSlM3dnFqLzZxVzFqYjl1L2QvOEdXZmI5Zk9IUm82UERqamZkMDl2Y25yelZibkJnZjI3VkZqWTVOZWNZM3ZtSmUyN2Q2QmZYdTFaMkJYRXQ1MHNxNmU1YnA4ODlXYVMrUGo0OGsrTVRFK2RzcDlQalJycnVjSEFBRE1idy9zSHRLK3NaSm15M1Y5N2NxbEEyMVoyNm1GcnZqNlMvVDR2bEY5K0d2Yk5CdEdTbFh0SHkvcmtiMGphcytudGFxMUlBQUFjUDU4dlZkL2Y3OHZ3VlZYWDVYWnUzZHZ0R2ZQbnNvamp6eVMydlBpbmlDS0k4a0tjeS9qaTVINU5UZjh0V3c2KzJKeGE3RlVqYW8zdS9IYWYvcFAvK2xGQVFEbXpPMS85dnFiNHRoMldxdGZrYkZkQW1aUGl6dld5a2NLNzg3azlMZHVmS3NBQUFBQUFBc1dBVVlBNnFKWUxQclBIOTh5dmNlVmpWRVVYUllFUWJlcmVBcXR0WWFlVytlZVgrZGhHQjdyR2JtcHFVa05EUTBDQUFBQUFBQUFBQUR6VDVoS0tWOW8wUEsrVllyak9Ba3dtbmJvNEg2Tnp4QkFNNU5hclpxVW1makFHbi9Pd0ozRDBXeHc1NE9TMTdKYzlGVVgxdTBuZnYzSC9zSzdlY0xQVHhUVkJBQUFGcWJ4Y2szRFUxWE5sbVdOV2JYa0ZrZVR4czVDUm0zNXRMS3B3QjMvV2xXaTh6OElycnJqdWVHcGlqSWg3YW9BQUxoUXN0bXNiejlydXBaMUpXMXFodzRQMlZxdFppY21KdWlZdFk2c2JOYklLSjFPKzJUMFdyRllmTVp0bDRtUGZ2U2p6d3NBY01Gc0tXNUo5YTlXS283aWZwbWd6MWhiRUQ5SmNXRTBLTFp0djN6WExmMDVsWVkvL2E1N2hnVUFBQUFBV0hBSU1BSXc1OXhKSTM4U3I5R1Zmc1Y2cHp1cGRGMWdndXVuZXlnaHZLZytNcG1NR2hvYnRHSERCdlgwOUtpNXVkbWY2Qk1BQUFBQUFBQUFBSmhmZktCUVkyT1QrbGF0MWsrODdkL3E2MS85T3czczJubnMvcS8rM2Y5T0h2UFJULzdCeXo3WHhQaTRwaVluWjd5dnRiMURYVDNMTlZ0S1UxUEo2MWtiQzNPdlVxa2s2eitxelkvQUlCK281T2VuVWk0SkFBQXNURS9zSDlYTzRVbk5sbjkxU1krNkdyTmFERzdxNzFBcU1PcHB6R204VXRQZ1pFWG5hOEk5enlON1I3UnBXWk0yZFRVTEFBRE12dmIyOXRDWE5XdldKR0hjOTk1emIzbHljdEwrNEFjL3lBdjExR2w5akZGa1ArOXVUeHFacndVS3Z1bHUvNzRBQUJmTTV0WEpkVCt0TmFOM0d0bHJYTTErUVNRWVlaWlpLZU1HNndOWG5aSlJiYkNtMUQxdS9CNEJBQUFBQUJZY0Fvd0F6S2tQZnZDRExkVnF0VG1kVHQrb1NGM3VWTklscml3anRLaCtmRWhSWTJPakNnMEZMVnUyVEMwdExVa1BNbXdUQUFBQUFBQUFBQURtdDBLaFFTdFdyWFoxKzIwblRLOVdLMGs5LzQ3dHp5VG5BTTQxaE9qNTU1NVZXM3VIenRiQi9mdUUrYWRTS1d0aWZFeTFlUkpnRkNjQlJtTXFsUWd3QWdCZ29SbWVxcXBVaTFTelZyTWhGUnpwOEd4NVUwN0xXM0phTEFxWlVLdGE4em93VVo2VkFLTktMZFpoOXp3K0VBa0FBRnhZUGh6YzYxM2VHN3E2Rk92ckwzeVEwWUVEQjZ5djA2aFdxNEZRRis2NDBmZk91aW93d2RVZi92Q0hmeTRNd3owcWExOTdiL3R6dDk5K2Uxa0FnRmxURG9KVm1VaFh1TTllbjZLYnRvYXJUSERodUZxbVZ2ZnZsYkwyaFgvL0p6YzhPdkFQZlNOZitNSVhJZ0VBQUFBQUZnd0NqQURNcVh3K3Y4SU5saXZXYjFoakc5enQ5WVlFOXJyS1pESmFzV0pGRWw2MGJ2MDZBUUFBQUFBQUFBQ0FoU0ZmS0dqelZkZnEvbi82MWduVFMxTlR5ZkNCKys1SndvdGVmOHU1QlJnOTl2RDNOREowV0dkclpIaEltSCttSmljMWVPaWdTcVVwelFmK1lqOC9QNTFkM1FJQUFBdkx2dkdTOW8yVlZZdG5KOEFvSFliS2hJR3U2RzNXcXRhQ0ZvdENPcVdyVnJScTIvNVJQWDF3WE9lckVzWGFOVHlsVlMyTFp4MEJBREJmaGU3NHhKY3JycmpDaCtWbytmTGxPblR3a1AzV3Q3NVZLNWZMQVFGRzlYRTBOeVBqeWxYVzJDdU16TnR0WkwraGxMNHhPREQ0UlRkOVFBQ0FXWk9LZFZWczlFN0pYdVEraFF0YytZTUx5L1M3Zi9vREUreXpZZVBEeTdZYzNLNHY2UHdyVkFBQUFBQUFjNFlBSXdCem9sZ3NibEZOclhFY3Y5MmRPMXJtSnEyMDFvYmtyOWVIUDZucTEvMmxsMTJxYkRhcjNwNWVaWE5aQVFBQUFBQUFBQUNBaFNNTVUwbUlVVWZuTXExWTFhK2h3NE9hSEI4N2R2L0FycDBLM0RtQmMzWGZQVjlYUzJ1YnpsYjVOQUU1emEydHlieE85MkIvdkNQaE9nZm1UYmdPQUFBQVRxOVNpelZacldtVzhvdlUwNWhWbHl1cGNISGxBTFRrVXJwcWVhdkdLelhOaG5JVWEvOTRTYVBsMlhrK0FBQnc1bHBhV2xRb0ZNd2IzdkNHMU5qWVdMeC8vLzdxd01CQU1EZzRhR3BSemRqWTBpQjZqcmwxSHByQXlGcTcyUmpUWlhMbXNxMGYybnJZR3Z1NU1Bekhpc1hpRGdFQXpzbjcvdnVXUG5jeVo1UDcyWCtkKzRMYllPVStaUVhNRGF2NHFzaVlkOGNGZmRLTkVtQUVBQUFBQUFzSUFVWUE1a2FrZmhuMUc1azN1ZHFrVmorSjhLTDY4UmNHK1BYZjE5ZW5UQ2Fqam80T0FRQUFBQUFBQUFDQWhjWFg5V2N5V1RVME5xbTl2VU1UNDJPYVBPNStIMmpVMm43dTV3QjI3WnpkYTN4eXVVSXlyMmFHQUtOS3Blem1mMXhSall1eEFRQUE1cnVhdGFwRVZyS3prMkRVbWsrcnB5bW4xQ0pyUzVRT0E2MXFMYWl6a05Gc2lOMzZIaXRIbXFwRkFnQUFjeXVmei90aW1wdWJ6ZkR3c0MwVUNwRWIrdHMrd0VpWWU4WlhqbHAvQ0duNjNLZ3ZLNElnS0NuUWQ5enRBVmNJTUFLQWN4Vkd6ZTVremlZajArL0dlcmp5QjNQTHJITGY4ZGxVck0rNmtaMENBQUFBQUN3WUJCZ0J1Q0NLeFdMT0RYeFEwVTJLZFpPVnZkSGQ3anc2RFhYUzFOVGtlNERSSlpkY29sd3VwL2IyOWhsN09RWUFBQUFBQUFBQUFBdUg3Nnlnb2JGUm1mU0pGMGJ2MzdmbnZBS01mdjZYL3AxV3JWbW4yWEx0RFRlcHZXT1pPMGVSUCtVK0g3N2s1M2R5Y2xJNGQ3MHIrdFRldVV6elJhR3hTV3ZXWDZ5V2xoWUJBSURGNCtCNFdkc1BqYXNTeFpvTnl4cXlXdC9lb0V4cThiUmgrZXJUKzdWM3JLUy9mWEt2bmpzOE84ZTRFNVZJaiswZmtYWC9UVlVqdldKNWk5YTFOMnA5UjRNYXN6UUZCUUJncmpRVUdvTCtOZjNwNXBabVV5Njc0Nkx0MjJ0am8yUDJpU2VlbUozVVFweXJUbXR0ckZnZmRyZEx4YTNGQjkzNDlqdC81ODcvSmdEQUdTa1dGUnhZdmFYTEtMWFpLbjZubTlRdHpEa2ZGMTJOclB6Lzd1Zi9wTnNXVlo4bFBmT2pUVG9kbXNiQTJDQWRHUGUvRkN6OGdPaDJ0eElhVFJEKzYvZmQ5WWJMUWxYdi92Uzc3aGtXQUFBQUFHRGU0NncxZ0F2RmY3N2tiR1Q3akRHYjNlMzFJcnlvN3Z3RkRENjRxS3U3S3huNmNRQUFBQUFBQUFBQXNMQ1pJRkFxbGZiZGpwOHd2VndxcVZvcDYxejU4S0pObDEycDJiS3N1MWVOalUwejNsZXIxWkw1amVQWnVRaCtxY3JsQzBxbjU4LzVIMzh1eW0vek1LUnBBZ0FBaTRrUHp4bXYxRFJiOHFsdzBRWHc3QnN2YTJCa1N0c0hKelEwVmRGc3FNVldvNldhZHJ2bmZYei9xSlkzNWRWUnFDYlRBUURBM0VsbjBzWVhYKzhSUlpFT0h6NXNqVEY4SWRlWmxjM0tWWTlhYTEvaFJrdHVtMVROd2c5d0FJQTV0aVZ3WnhoeWtZMDYzY21uZmpjaEs4dzlkMVFSSjhYRzFUajUyVjl4WmNZVGZvRng5NWdnVGdkYVRBY2pHZmVkbnJGV0t3Smpxd0lBQUFBQUxCaTBFZ1F3cTRyRllzRU4zaGpIOFUxdStHNTM0aWZyVGdqbGhMb3dnVkU2bFZaZlg1LzZWdmFwcDZkSHpjM05BZ0FBQUFBQUFBQUFpOGVxL3JXNmFjdnJOVEk4cEFQNzloeWJmdDg5WDArQ2djN1Y1WnV2MWcwM2JSRUFBQUJ3SVhVMlpOVGYxcURVQXI3QS9MNmRnMGxZMGFmdjI2N2hVbFV2REUvcVF0azlQSldVTDIzYm00eGYyZE9pMW54YXhkZGZvbHdxMFBXcjJnVUFBQzY4ZERxZGxHdXZ2VFpKazc3dXV1czBNVEZodjNUM2wycVZTc1VNRHc5enJVWWRtQ09wUlhrcit4cHI3YXZ2MkhySHI4anFIOTIwcjVtYStjZml4NHJiQkFDWTBiNjFtZlowRkgzYUdxMTBINll0d3B5WnJNV2xLTGJ4d1ltNEZsa1pWM3lQSUdsWDJsNytyNk5qdDFLQkdRbU5TbTE1MDVZSmdrd3VaUlFzME9vVzk0MytVKzc3UElwVHdUKys3Nzl2MmZYNy85YzlBd0lBQUFBQXpHdFVpZ000YjhWaU1UaDZzOU1WSDJEVTVVcWpQd0Zrck85U2hFNUY2aUVJQW1YU0dlWHlPZVZ5T2FWU3FXUWFBQUFBQUFBQUFBREFmT092Sy9Mbk1lZ1UvZnhVS3hYVmF2T25NOW9vaWxTcGxOM3czSU8wQUFEQTRoZTRnOERVQXJ1YXpscFgzSDhUbGNpVm1nNk1sM1Zvb3F5YXU2TVd4NXBMcFZxc1VqWFd2ckZTRW1CMGVMS3FmQ1pRUGhVS0FBRE1IViszNVV0alk2T3BWcXRKc0xnZlZseDlqV2N0N2FucndhMzNKTkRJeUxURjZiajd0My83dDhlNnU3c1ArUHR1di8zMnNnQUFpWGZldFNVWDJ6am5mdXNXM0dkbVdwZ1RzZnVpaXQxS3I4VTJpR0pYMGVCV3Z2WC9uak1idUQ4UDNPa1oxZHpUeFVlcUwzemR5MEk4QStkbk80NXFjV3RvTk9yR0NUQUNBQUFBZ0htT0FDTUE1ODNWbC9td29zRFZiSDNHalJaYzdkWWJqSzh2TzlwUUIzUFBud0J0Yld0VlcxdWJycm5tR21VeUdXV3pXUUVBQUFBQUFBQUFBTXhIMld4T1RjMHRTcWN6d3JrYjJMVlRJOE5EbWkvR1JvYjF6RlBiTkRJeUlnQUFnTk5wTDJUVTE1SlhLbHc0SFhORk50WjRKZExuZnpDUWxLY09qbXYvZUVuMThQU2hzV1Q0Yno5L1dNM1psTjUxeldwZDI5ZW1uOW04VWdBQVlPNDBOemY3WXQ3eEMrOUlsVW9sN2R1M1Q0OC8vcmg5L0xISGJhVlNNVWVEZERDSHpKR3dCcC9xK05xa1dQMWFLa3hOSFQ1OCtBNDN2czJWK3dRQVNEUXFkYjJOYlkrUmVZTXdaOFlydGpSV2lhY21xclk1dGpydmsyUzFXRTJTYlRvNGRlUmFybVVOWVRrZEdEVm5sTlBDVS9BQmtNWUV2MmhUMnVuR2YxMEFBQUFBZ0htTkFDTUE1NnhZTExhNlFTNk80eHROYkJxc3NTdGQ1VkI2WVFaekx4N3Q3ZTFLcFZKYXZtSzU4dmw4Y2pzTTZWRU5BQUFBQUFBQUFBRE1YemwzVHFQTm5lUHduVElBQUFBQTgxVVVXNDJVcXRveld0SUR1dy9ydXdPSHRXK3NwSEt0cHZtZ0hNWGF0bjlVZ1RrU0RMV21yYUExN1ExS0I0Rm8wZ1VBd056eGJYY2JHeHUxc20rbGZLZXdCdzhlakNjbUpuVDQ4T0VnaWlLK2xlc25rd1FoeUx6YTNWNVZMQlliM1hCeWZIejhJYmU5SWpkZW4wUktBSmdIak5WTjdxZGprNlVQOHpuaDZoZmlTcXhLT2JLMkV0a0wxbHQ1cVJhSE5TT2JEOE5hWUd3USt0N1NGeGhqN1VxM1c1cDMzcldseDQyV1B2dXVlNFlGQUFBQUFKaVhDREFDY0Q1ODVVOVBvT0EzcmJHZDd2WnF3b3ZxcjcrL1AybmNmOW5sbHdrQUFBQUFBQUFBQUdBaGFHNXBWZCtxTldwby9KNEFBQUNBK1NxeVZydEdwdlRJbm1IOSt0OC9ybEl0VXJrV2E3N3c4L0sxN1FmMTZMNHhmZi9GRWYzMGxYM3Fic3FwTVdPVW9sMFhBQUJ6eGdjWWRYWjIrbUt1M0h5bGVmenh4NnN2dnZoaS9QRERENmZqY2l3Ylc3Nlk2OEFZazNlRHZGdi9QNXVNeTl6ckJvZXkyZXgvS0pmTDQrNDJBVVlBbGk1ajN4MWI5OU5SbUFzK3ZHaGtLaDZmaXVKQ09WS0RMcEN4c2sySFJyYVFqcWZDd0FTRlFEa3RPT1phdDErdWFsUnFZNnlhRHk5NlJBQUFBQUNBZVlrQUl3Qm5yVmdzOXF1cWZrVzZ5UVoyblp2VTYwcEJxQXQva3RPSG9QY3U3MVUrbjFkdmI2L0NNQlFBQUFBQUFBQUFBQUF3TFp2THFhVzFUWm5NQmV2STk2ejQ4MXQrZmdxRkM5WXVId0FBWUZZZEhDL3I4RlJGbjMzb0JlMFpMU1hoUlZGc05SOU5WS3JhT1RTcGUzWWNTdWJ6eHkvcDFmTG1uTEpoS0hLTUFBQ1llOTNkM1VFK256ZXBWTXJVYWpWdGUySmI1R2g4Zkp3R3YzVmtaVmU3d2JKVWtMbzlNTUhBMXExYkgzVjFWczhYaThVZEFvQWw0clkvMmJKZW9ScmR6UllqRS9oUFIxeFlQaHk1R3RtVUR5K3FXYVYxZ2JrdGFzY3JOc3FHVm9WVW9BVXFKOFZiM05tbG5TTEFDQUFBQUFEbUxRS01BSnc5SDE0VWFJczE5aWRjVGRabW9hNThXRkU2blZaL2Y3L2EyOXZWMGRFaEFBQUFBQUFBQUFBQTRIaTVYUDVvZ0ZGRzg4RjBnRkcrUUQ4cEFBQmdZVGc0V2RhdTRTbDk5cUZkcXNXeHlyVlk4OVY0SlhKbE1na3ZldXJnbURiM3RxaTlrRkVtREdSRWdoRUFBSE50MmJKbG9TdCtxTmdkUit4NWNVOVVLcFVNQVVaMTErK09qYXcxOXVMWXhJOGJZNzdxdHMvWDNYUUNqQUFzR2Frd1hHOWxlOXpOVnNLTExqeS9objBXc3F0U1NKV2p1Ym11MDFwZlQyRGpPTDF3STQzZEl1VGN6RzhKWkFrdkFnQUFBSUI1akFBakFDL3IxbHR2RFMrOTlOSTE3dVlxeGZvWmErMGFHYTExNHoxQzNlVHplYlYzdEd2RmloVkphRkZiYTV2U21Rc2V2ZzRBQUFBQUFBQUFBT2Fab2NPRDJySDlhWTJPREFzNG5YUW1vNGJHSnFYVDh5UEF5QmlUekk4UFZnSUFBSmpQcHFxUkltdjE2ZnVlMDFNSHhqUmVxU1VYL3kwRVExUFZaSDcveC9kZTBJcm0vZnJBVFJlcHF6RXJBQUJRSDRXalFjNXYrckUzcGFhbXBzeitmZnQxNk5BaHUrM0piWEc1WEE2aVdrVFM0Qnl6c3NaYUc3cTZxbjQzOGpOdTBzMTNmUGlPL1NZMC96MElndWRiVzF1ZnVmMzIyOHNDZ0VYbVRiKzNQcnNtN1BNWG9Mek5GVG8ybnlQdU84ZU9sT0xSVWkzMjYzNU9lbmh3ZFJnbWtocXFzVFdUMVZqcHdDZ2RMcXhERG1PVmt0R1ZVbUJ2dTJ1TDMxLzMvZUc3N3RrbkFBQUFBTUM4UW9BUmdKZDE2YVdYK3Q0OUdoV3B5MVg0WE9OS3R3Z3ZxcnRVT3BXY3lHeHZiMDk2WkVtbFVrbFB0UUFBQUFBQUFBQUFZR21wVmlxYUdCOVhGRVVDVHNlZlIvTG5relJmT3RoMTgrSG54d1NoQUFBQTVqTWZYbFNMclI3ZlA2cGR3MU9LNGdXU1h1UlVvdGdWNmZuREV4b3Ixd1FBQU9vcnFadHhlbnA2Z2xLcGxBUThsOG9saFdGb2pjZ3VxaGRqa2dxelZsL2NkdkR0NVM5eXQvOVBITWVIQlFDTDFNcHNTNWpKS0JYSjlybFB3dlhDbkxBeWNTMVNOWXBONk1mbXhKR0RqSlN2em9oY1daQm5aWXkvQnRhNDcycmI2czUydGRaVW8xY1hBQUFBQUppSENEQUM4SktLSHlxK1RaRld4U1oranpzMzQrdXBWaDN0WlVLWWUrbDBXaTJ0TGRxNFlhTWFHeHZWdWF3ek9abnBUbHdLQUFBQUFBQUFBQUFzVGVWeVNXT2pJNnBXS3lkTXYrYjZtM1RSeGswditiY2JObDJtZ3dmMnozamZDODgvcDdiMkRxMWRmN0V5bWF6T2xKK1hMMzN4cjA2WmZ2VjFQNktXbGxaMTlTdy9kckhXVXRmWjVmc05zVE91anowREwraDdEOXluTlc3OWQzUjJhUzdrQ3cxYTNyZlNEVS90OUxkVW1rcm1wNzF6bWRzbk5nZ0FBR0NwK0wzdlBLY2RneE5KZ05GVWRXR0dobjUzOTVEU1lhQS9mL2dGdGVjeitzVnIrZ1VBQU9vcmw4dXByNjlQM2QzZHV1cXFxOElkeisySUR4MDZwRWNmZmRTTWpZOFpHMXNhYTllQnRUWnJqTW5FVWZ4ZlpEUStlSER3aVRzK2ZNZEFMYTU5S0k3ajBzYys5ckZCQWNBaWtNMDAzeElydk1KOThxMTFIMzVOODZiemc4WE9mZEdVWWp0WlBmSTkzNmc1Vkl0VkdpdkhRODNab0RFYm1pWXRURDFHOW0wWnBmL2UzZDRwQUFBQUFNQzhRcXRRQUNkd2RXSG16anZ2OUJWaG5jbUVxdnF0c1N2ZGlaaGVkeUxNQnhkbENDK2FlOU1CUlQ2MEtKL1BxNm1wU2ZsQ1BqbDVDUUFBQUFBQUFBQUFsclphclphRXkvamg4UXFGZ2p1dlVIakp2L1hCUkpsTVp1Ym5yVlpWTHBWMExnWjI3VHhsbWc5THltWm5Ea0lLZ2lBSjhmSERVMWlyT0k2VEh1a1gyM2txdjh6cDA0UkRIZG11SlRlY3U0dmsvVGtwUHo5aE9ITlRncm1lSHdBQWdIcXF4VFlwaDhZcjJqVXlxZWpvK0VKVWRmTmRqU1B0R3A3U2VDVlM3STZ4amYrUFptQUFBTlNWcnh0eXhmaTJ3YTJ0clVsOVVHZm5rYzVOUjBkSGt3TVBONDF2N0Rsa2psUkErb0VQZG1oeWgwd1RQbi9jMVZ2MnA5UHBzZi84bi8rektwWEtWTEZZbkJRQUxFRHYrZU9yMCtwVjJod09PdDFQdzVYdUhFemVmZW9Gd3B5SllvWEpqL0k2VkRGRU5xa2lpTFZBdWRYbVQycDJTM0h6bHVLVzFCWnRpZDEzOG9KZEhnQUFBQUJZYkFnd0FuQ0NPKys4MDdlUXpybnFxQSs0NFVZYjJqZTRZY0ZYakJGY1ZEOGRIUjFKZy9FM3ZQRU54eHJ3QXdBQUFBQUFBQUFBZUlNSEQranBiWTlyY25MaWhPbE56UzBxTkp4NzU2MysrY1pHUnhTZjVVWGFJOE5EK244Ly9ZbFRwcmQzTHRPbXk2N1U4cjdWcDV6cjhQTzZ2RytWOG9XR1UvNnVGa1hKZktRekdSVm11SDhoODh0VGJhN0lCUFBqMm9CTU9xMW10eTFTYmdnQUFMRFVEWXhNYWVmUXBMNjU0NkIrc0hkRWk4Rm5IOXFsd0JpOS84YjFTZ1ZHalJuYUlBRUFNRi8wcitrUFhkRVZWMTZSaEhuL3pSZi9acXBhclpxZE8zZlMyMmw5clpmUmVtUE50MjFzOTFaS2xhOG8xdCs2Nlg4ckFGaUljbTI5bVVGN1ZTejlHeVA3T3BKdDU1WTc1WmFxeG5hRjZzQmFIM0FzOTNXbWhabk9mRVM3SzI5eml6Q3dlYlVlT0RCNXp5RTNQaTRBQUFBQXdMekEyV2NBaWZlODV6M3A1Y3VYdDdpYnkzMngxcTUwSjFzNmpFeDZZZGROTFd5K0YySmYydHJia29iOGhFZ0JBQUFBQUFBQUFJQnBVVlJUYVdwS3BkS1VhcldxYkh4aUI2TU5qWTN5dmJlL0ZQK1l5Y2x6RHprNm1lOGwzcGVaTkxyWGFtbHRtN0dqQnQrQlEraW1oek1FK2ZqbEhCOGZVeTVmV0hRQlJyNERDNzgrZ2hrNk4vYmIwMi9YT0k1MHBrcFRrOG02bWtrdWwwdld2eCtlbGpuU2tVWjRta0FsUHo5K2U1d3BIejdsNTZkYXFjeDR2NThmdjE4QUFBRE1SNGNteW5ycXdKaW1LbWQrUERiZlJkWXFkbVg3b1hFMVpWUGFzS3hKQUFCZ2ZnbU8xc3QwZDNjSFBzQ29WQ3I1K2pZN1BEeWNCQnU1UW1QaU9ySFdabzB4UFRMYVZDd1dEN3Z0TXVpMnorQkZGMTAwOU43M3ZyY3FBSmpIYnIzMTFuRFpsb1A1c0ZycHNHRm1vNUh0RkpZV0kyTmxRMWZtUjY4YTU4VTB4NEg2Z2x6Vm40QWl3QWdBQUFBQTVna0NqQUFrbGk5ZjN1c0dWN21UV205MXc3ZTZreXUrOVhlSzhLTDY2dXZyMDdLdVpkcXdZWVBTOUhRTEFBQUFBQUFBQUFDTzQ4T0xkbXgvUmdmMjdkWEUrS2x0YzlldTM2RGVGWDB2K1J6K01ibmNTNGNjblkySjhURk5UVTdNZU44YTkxcVhiNzU2eHZzeW1hd2FHNXNVekJCdTVFTjVubmZMMmRXelhCMGRpNnM5ZlM2ZlZ4UkZtcW1INDBxbGttelhxSGJtZ1VGN1hoelFub0ZkTTk3WDFiUGl0T3QvbWo4ZjFlQzJRNWc2OWJ5VUQxVHk4MU1wbDNTbVJrZUdrMjAzTVVPb2t0L3ZYbTUrQUFBQTZ1bStuWVA2OUQ4L3AzM2paMzc4TTk5TkhnMWorbS8zNzlER1pZMzZqUzBiQkFBQTVwZnA4Ty9YditIMVdSOFVQakF3b04yN2R0dEhIbm1rTmpVMUZVNU9Ub2JDbkROSGVxSHRzTEp2bHRITmlsVUtndURQQ29YQy9YdjM3djA3ZHg4QlJnRG1OUjllbENtazE5ZGtmOVRJL29iN1VNdHp0ZERTWXEwQ2QwcXFJYlphREJjbmJWSWN2czJFd1YrNjIzc0VBQUFBQUpnWENEQUNsckJpc2VpN1Y4MnBwdXR0Wk5jcjBJM3UzTXBHV1dYZDlFV1FxTDN3K0Y1VHN0bXNXbHRiMWRMYW9wNmVIalUzTngvclRRVUFBQUFBQUFBQUFHRGE1T1NFbm5ucUNRMGVPampqL2F2NjE2cTljOWxMUGtjMmx6dFc0aWhTdGZyRDYyeUdEZzlxLzc0OWlxSXpEOUR4ano5MGNQOHByK0hEYXRLcDA1K2VibWx0UytiWGh4aWRyRmFMTkRJOHBDWjN6bVN4YVd2dk9CSVlGSjU2M1ZtcE5KVXN0dzh5T2xQK3NhWFNpUmZZKy9OTTZVem0yTVZ2THlXZno2dXJwemNabml5TzQyUitPbDVtbnpyaGI5dys1ZWNuQ1drNmp0OG5NdG1zQUFBQTVxUHhjazJISml2YU4xN1djS21xS0Y1OGwzUStkWEJNdVZTZ2tqdldEbzFST3FSdEVnQUE4NUd2MS9GdGl0M1FaTFBaOFBEaHczSWxHaGdZQ0taS1U4WXV3dU9VQmNKWHRPV016SFd5V3VIcXpYcTJidDFhS3BmTG4zZjFZTFZQZnZLVEV3S0FlZVMydTdiMGhGR3dLbGI4TSs3WDN3YjM3WkdONVg0T0NrdUpsUTFqbVp4ZEJBRkdidC90Y2N1ejJWanpWUUVBQUFBQTVnMENqSUNselFjWXViTmF1c1hWUkYzaXlodUZ1dkluR3ZPRnZIcDZlOVRmMzYvR3hzWWswQWdBQUFBQUFBQUFBT0JrVTVPVGV2YXBiUm84ZEdERyszMGdVSU03MS9CU2ZMRFFkS2xVeWljRUdBMGZIdFNCZlh1VEVKb3o1UjkvNk9DQlUxN0RCeFNGTHhOZzVFdkRqQUZHMWJNT3psa28ydG83aytGTUFVYmxVdWxvZ0ZGWlo2cnFIbHN1VFowd3pianpUMzRibkVtQVVTNWZPRlpPTmgxZzVJT3p6cFFQTHZMemMzSUlscCtmYkRZbkFBQ0ErV2k4VXRQT29VbnRHM1BIWTZXcUZxT25EbzZyTlo5V3FSWXJFeEpnQkFEQWZEVWRZT1NLV2JWcVZiaDM3OTVvejU0OTBkRFFVRkF1bHhXWnlLY1JZTzZsanBicmZZS0NrZG5rYmxkYy9kdFhYVDJmVHhjbndBakF2SkpSdWtlaE5rV0szK2xHZlhoTmp2Q2lwY2Q5WC9rZi8za3RBdTd3cDhjdFVWdXN1RjBBQUFBQWdIbURBQ05nQ1NvV2k2Nml4dFZCeHJyTld0dmdhcUZlNThyaTY3SjJBZkdOMG50NmVwTEFvbFdyVnlYRGhvYUdNMnBJRGdBQUFBQUFBQUFBbGhZZkNyUDN4VjE2YXR1ait1WS8vcDlUQW9OYTJ6c1VCcUZXck9xZk1Sam5aRDVZNktLTm0zVHd3SDY5c0dQN3Nla0g5dTFSRUpqazljNlVEMVFhT256b2hHaytlR2p0K291VnpiMThtK2kyOXZaa3Z2ZTl1UHZZNjFZcmxTU2txYXRudWM3VXdLN25YWGxCKzkweUxBUzlLL3FPYnRmZHg2YjVaWDdHcmMrcnJyM2hqSjluMTg0ZHlkOGNyN0d4S2RtK1p4TUFOYjBkL0Q3ZzE3OVhxOVdTNS9iNzE1a2FHVDZjL0kwUFBqcWVuNS91czlpZUFBQUFjOGtIRjkyMzg1QjJEVTlwc1pxczFuUmdvcXp2dnppczVVMDViZXhxRWdBQW1QOWFXMXVEVENaakN2bUN4aWZHdGUySmJWVWZaTFJuejU2MFVEZlcyaFhHbUNnMDRmOWpBak8wOVVOYkgxZWd4ei95a1k5OFN3QlFSN2ZmZGZNdHNjSmNaT04zdVUrclJ2ZFpsYmV5Sk5oaTRUTktHMnNDR3djYmIvc2ZyNy9wWU5PZTczN2g3ZHNxQWdBQUFBRFVGY2tZd05MVWVMVGM0aW9nTTY0QzhoS2hybndQS1cxdGJXcHVidGJxMWFzRkFBQUFBQUFBQUFCd09sRlUwOURod3pwMDRJQ2UzdmI0S2ZjWENnV2xVbW0xbjJIUWpIK3NENU9wVnNwNjRianA0K1BqeWV1Y1RZQ1JEd3dhR3gwNVlWcERZMU1TUHBUTDVWNzI3eHNhbTVQNTlzRTUwNjhieDdFbTNMeVVTMmQrQWJtZjd4M2JuM0YvTjZhRm9MbkZuU2RxR1RraHdNZ3ZzMThQWjdQY1Bpam93RW1oVFQ2Z3ltOWZ2eDNPMVBSMkdENTg2TGdBbzJyeTNLTW5oUkc5bEZLcGxQeU5IeDdQejgvWkJDb0JBQURNcGZGeXBPMkRFem84dFhpdmU2dEdWbE9WS0FscHlvUmN1d29Bd0VLUnorZU5MMDFOVFVtZDJlSEJ3OUh3OERBQlJuVm1qR2s1Y2tOdnM3S0gzSGlYamEyZlFvQVJnTHB5bjBrYkE4V3QxdGdmUHpvdVlGR3dDdDMrSEpwQXZhSGk5Y3NPZGowaUVXQUVBQUFBQVBWR2dCR3doQlEvVkx6RlZUeHVWS3lmY1JVMUs5eWtUcUZ1VXFtVVAyR2xhMTU1alJvYUd0VGIyeXNBQUFBQUFBQUFBSUNYOHIwSDd0UFE0VUg5d2FjK2Rrb296TFQvNjFmL2c1WjFkZXRNK1dDaFYxNS9rOUtaakg3dy9lLzk4TFgrNVorVlRxZjFTenZlbjRUWCtOQ1owNW1ZR0U4Q2g3NzB4YjlLTHA0NjN2SytsYnJHUGI4UHhYazVhOWRmcEZIMzJKMDd0aDhMenZHaFNQNTUvV3U4Nm5WdjlCZHF1Zm5LelBqMy9yRVAzSGV2dnZXMXYzZmxLeXBOblhuNFR6M2RjTk5ydEh2WGFqMjk3YkZqMC9ZTTdFcVc1K1piM3FMMUYxK1NoRUQ1ODBzejJiSDlhUjArZEZCUFBQYUluanJ1T2J5VzFyWmsrL3J0Y0tZMlhYNmwyNDZSRGgwOGtBUXBlV1czdnozbzlqOGZQT1RucmJHNVJjM05MVFArdlE5U2V2YXBKL1RJUTk5TjV1ZmtFS3hYSnZ0RG93QUFBT2FqUTVObFBiRHJzQnN1N3V2ZWhxZXFiamtINWEvNnU2bi96TUpQQVFEQS9PRHI3THhYdmZwVldWL3ZjdFZWVituZ3dZUHhndzgrR0pXbVNzRlVhU29VNnFWVFJtOE1USERkMXExYmIxT3MvK051Ynl2WHluLzNzWTk5N0tBQTRBSjQ1MTFiY2sxcDkvbFRNZXZjWjlBNldmTWFCVnBuWXJQQm1qamxFOWFBUmNucUZyZDd2ekxNNk90dWJGd0FBQUFBZ0xvaXdBaFlXbkpHcHRYSyt1NU1sd3QxNXdPTWZDTjczeE55TnBzVkFBQUFBQUFBQUFEQVMvR2hSYjRNSGpyb2hqT0g4N1MxZHlibGJHUnp1VlBDY1dyVmFsS2lXaTBwTDhWYWR3WXFqalV4UG5aS2dGRXFsVTVDa2xLcGw3OXV5ai9Xejh2Si9QTld5dVhrTmZ4cnZSVC8yTkdSWVEwZkh0UkNrUzgwdVBORkRTZE1xN2wxN29zUGNxcTl6UHIzOS92OXdxK2o2ZUNuNHgzWnZtbWRLWDhSbkorZjZZdmhwdmtRbzBxbG5MeWVQV2s3bit6SS9KUk9Pei9aWEY0QUFBRHpVUzIyS3RYaVpMallKY3NaTGY3bEJBQmdzZkh0ajcxQ29XQjhnRkZUYzVQS3JsNG9DQUpyQWtJcTZzVk1ieGkzYWF5eEdWbTF1bTNTNWVvekJ6SlJob2JpQUM2b3NLcFViR3plS21oV1lKYTV6NkErYTlUcVBwMjRkaENMbHZ2bXpWbVpWZ0VBQUFBQTVnVXFJWUJGckZncyt0YmRQWXAwazR6ZWJXVTNKT09vcTVhV0ZyVzJ0dXJLelZjbVE5L3crNGZucXdBQUFBQUFBQUFBd0dMMy8zMyt6L1c5Qis0N3E3ODVzRzlQRWdpemErZU8wejdtdFcvOE1XM2NkTGxlNTRZdHJXMDZVdzJOVGZxWmQ3NUhiZTBkK3U1M3ZxMlI0YUdrVFB2UXIvK0tsdmV0MG4vOXpGOG9US1hVNkI0L2JYSnlJZ21vK2N2UGZpYVp0K1AvcnFHeFVSMmRYYnJtK2h2MTVyZmVla2J6Y3YxTlczVDU1cXQxOTE5L1RtT2pJOGswSDU3a24vZTczL2tuZmJ6NEc4bHorY2Y0K2ZhaFM0ODk4bER5MkwvNDB6L1M0S0VEZXVDK2U5WFYwNXM4WnZldW5Rc2l5T2pIMy9adnRXZGdkN0llYTdXcUpzWi8yRW5zbi8vSkgranYvci8vcFUrNzliK3NxL3VFYmV2RG1ueVkxVi8veFYxdXVlOXgyK0M1WS9mNWRlTzNtMThQZnZ1ZURiOGRycjcyUjNTL2U4NlQ5d2UvZm05NzU5djFrei85OC9xcG4zN0hzZTNnK1dDalBRTzc5TXhUVCtqVEg3OVRReWV0Kys2ZTVVbDQwZG5PRHdBQXdGendnVVVESTFQYU9UeXBGMXhaN01Zck5UMnlkMFNyV2dzQ0FBQUxWeGlHNnVucDhTVzQ3UExMTWdjUEhxd2QySCtnL1BEREQ0Y0RBd05CdVZJMk5yWTBWSjVyVmlrams3S3lQeStqbnpjNTgrdkZyY1ZTTmFyZTdPNnQvYWYvOUo5ZUZJQUY3N2E3dHZSa3BGeE5xWDRUMjVRQzJ4Y1lOVm9ibk5MTFJLejRldmRobkh2cFp6U2ovcUh1OCtNUnZZeWp6OWZvL3FiUGpXYWo0NjhWSXFkMlh2TDV3WkV3bTl3cTllKzFUcE1LMy9PK3UxNTMrUGZmOWMxUEN3QUFBQUJRTndRWUFZdFVzVmowbFRBK1JYcXpPL0Z4cVJ1MjZHVXJPM0doK0lBaWY0S3dVQ2drb1VWdGJXMEVGd0VBQUFBQUFBQUFzRVQ1Z0JvZlJuUjJmMU5ML3U1NHlYa0dWN0xabkN2WkpOam1iSUtMVHBiTDU1TVFJOTliKy9HQk5aVkt4WlZ5RWt5VGNhOVRhdm5oYTR5UGp5Ykw0b04wZkRrMmIwR2dRa09UT2pxWEplZEh6bFRnL3M2SDRUUTJ0NmpKUGQ5MGlOR1IrU2dmRGV3NWtNeEx2dENRUEhiL3ZyM3VjY05KbUpKZlQ4bHJ1L3RhM2JJY09uaEF3NXIvQVVaK3VYM3g4end4Tm5wQ2dGRVVSY2ZXZjlVTmZXRFV0RkczZmc0ZTJPZTIxK0hrTVNmejI5TnYxN1BsOXkyL0h0dmFPNU41T241L21KNmY0YUhEeVR6NSs5T3BkSEtmMzBmMzdobHdqeDlPSHVNZmU3elc5bmJsY21jL1B3QUFBSE9sRnNlSzQ2VnhwV2ZrbHJOU2l4VlpybXdGQUdBeFNhZlRwcUdod1hSMmRyb0tIcms2bkdIcjZ2ZnM2T2hvSU5TTmxjMzZEZUsyejNWdXRGWXNGbjFTL2JnYmJoZUFlZW5Xdjk2VWFaam9DdHdaanRhd3BwUjFweTZxTmd4Q0UyUkMyWnhWTFJlWW9NMzlqc3dZcTE1WHI1NXl0ZXNkc1d6Qld0dHl5aE1hMCtFK0MxN3lPajVqM1AzVzU4N1pmcjBjOTN5eTFsOGpsUE1mTDhLODU3WnJVakQ3M1B1dXg3MHBtbS83Z3kyTjJYSTUrdDBQM0Q4bEFBQUFBTUNjSThBSVdMeHVpcUpvbzZzRS9RMVhmR1VrWFdYVmlXL2c3Y09LT2pvNnRMcC90YnE2dXBJQ0FBQUFBQUFBQUFDV3BqMER1NU55dm9Jd1ZHTmprNjY1L2thOTh2cWI5Tm8zL3BnMmJycGM1K3JTeXpmclAyNzl6L3Fiei8rNS9yL1AvODlqMDUvZi9reFNicmxwY3hLUWRQbm1xNC9kdDN2WFRnMGZIdFQ0K0ppaVd1M0lmQVdCbXBwYmRQMk5yOVo3Yi8rLzFkWFRlNmF6a0FUdStQSlRQLzN6U1dqTy8vdnBUeHk3YjJEWEMwbjUwaGYvNnJSL0g2WlNhbmF2L1RxM0xuN3lwOStoMy8zNG5kcjc0dm12Nnd2TmI4ZStWYXYxUWJmK24zM3FpV1MrcCsxOWNTQXBQLytUUDVxTTM3VGw5Y2Z1TzdCdmo1NTVhdHVNeittRGhmejJQSmRRcTN5K0lKOTc5TlB2K0NXOThjZCtYTGU5OCszSDdoc2RHVTdLMDlzZTEzLzl4RWVTL1dINk5YeVkxZmNldU8rMHovdTJuM21uTmwxMnBRQUFBT1lqSDE0ME1GTFM0YW1LbG9LcFdxd25ENDdwdWhHdTZRTUFZREZwYlcwTmZWblJ0eUlKbDM3MDBVY3JRME5EOXY3djNKOFY2cW5UK2hpanlIN2UzUzRGSnZpdUd6N2l5dnNGWUY3cXFYUjFXVmQ5YnhSY3I1VHZYTnhzVGdkdTNFYnUvYXdOUm1HUHo2SXhKblQvK0hmNFVjbTAwejNyeTNTQWZmUkozTi9mcEROQmg5b0xTalh5ZFEvQ0JlQytWLytOZFRLRjlHZkx6Zks5aEJBUUNBQUFBQUIxUUlBUnNFZ1VpMFgvZmc2Q0tMZzhqdU84cTNkNWJSaUduVGEyUHJ5STkzcWQrTjZPZmMrL3ZiMjlhbTVwVmx0Ym0zSzVuQUFBQUFBQUFBQUFBTTVHdnRDUUJBUDVvQnNmMHRQUnVTd0pDVnJadjFickw5N2d5aVZKY00vNXlPYnk2dXBabmdRWkhUcXdYMDg4OW9oS1UxT2FuSnlRalkrMHFQWUJOVDQwWjlyRStKZ3FsYkxzMFI1akc5ejhGUm9hay9DaUs2OTZwZHJhMjVYM1NUaG5xWC9kUmU2MUo5WHQ1cWRVbWtyQ2pGNUtLbGtuWFdwMzYrV1N5NjdVSnJjTS9yVXptWXdXaW5RNm94V3JWaWUzcjc5cFM3S2U5Ky9ibXl6L2REaVVkL3o2SHo1cHZVenZKMWRmZTRNN045V2FiTS96T1RmVjNidmNQV2NobVoreW13OGZsbFNyVmQzdDBySEhEQjQ2a056bjFZNmJUOC92cXptM1g2MWRmM0VTVExWeTlacGtuZ0FBQUFBQUFIQmgrVG9pcjZ1ckt5d1VDdkdtVFp0Y1BWNUZBd01Ec2F2RE1iNEk5Wkt5c3QxRzVvb1BmL2pEN3dqRGNJL0sybU16ZHVET08rOGNGWUE1OVo0L3ZycVF5N1YxeGlXMUJDbTF4SUh0TklGN24xYTF3c2ptakRYclplUXIydnRsbGZPaFJ1NDJGNFVBODRqN1h2WFh6dmtNbzVzeTVYRGd0ci9lc3MrZDNxeDk5bDMzbEFRQUFBQUFtRE9FbWdDTGgyOTluWWxOL0xNSzFlNXFYMzVodXFFNDZxZWhzU0ZwRkg3MU5WY25EZWZQcFlFK0FBQUFBQUFBQUFDQUR5Zkt1bk1PcS9yWEprRkRyN3orUm5YMTlPcjF0L3lyWkxvUGlUbGZMYTF0U2ZIbk5qWmVlb1grKzMvNy8ybkg5bWRVSHBoUzdXaUEwWFNJemVuNFlDVmYzbnY3LzUwRTF2U3Q2dGU1dVBFMU55ZWhTVi84eXo5THdvc2VlK1NobDN5OEQ4cTVhT01tclZsL3NkN3pxLy9oMkxMNFFLV0ZJcDFPYS9OVjEycmwwWFYyM3oxZlQ4cmdvWU5KVU5TMGwxci8wL3VKWC85K2VMRmJKK2RqN2JxTGsrRTczbjFic2gzKzMwOS93czNMK0FrQlJuc0dkcC8yNy8yKzVQZUhOLzdZait1cWEzOUVsMisrT3RrdUFBQUFBQUFBdUxEQ01FeEtmMzkvNkVmNyt2bzBNVEZodjNUM2w2S3BxU2t6TmpiR3RTUjFZQnczOENFTEcyTWJid2hNOENvYjJYOVVTbDh6RmZPUGJ2bzJBWmhiUHJ3b3RsY3BZemZHTWh1TjdHYkZwdFc5V1ZlNGQyM0tuaFQzWmtUK0d6RHZXQ1VuU21OajM2MVFqMmNtOUVpdG9uRTNpUUFqQUFBQUFKaERWRG9EQzF5eFdHeDFnMVlUbSt1c3RXdGNYZWkxVnJaQnFLdXVycTdrcE4vYWRXdVQ0Q0xmdTY4ZkJ3QUFBQUFBQUFBQVM4T0dUWmRwZWQ5Sy9idjNmMUNsMHZtM2pXMW9iRXpPT2Zqd0Z6OWMzcmNxQ2VmeElUV3BWRnF6eWIrR0QwcDY2OXQvVmtPSEIvWFl3OS9UMU5TVXhrWkhqajJtVkpwS1FtenloWUk3RDVJOU9uOXBYWFA5alNvVUdwSndwWHkrb0hPVnpXWjlONm42eVovKytTVEF4ejlmSEVXcVZxdEppYUphOHJxK0ozay9yNWxzVGxlODR1b2tOTW5QdjE4djNvKysrU2RPQ1ZIeTkxKysrU3AxTHV0NjJmbnc2OWcvL3kxditkZHV1TzZFK3dvTkRVY0RwV2EzbytWQ29URUpZL0xQNjRmUFAvZXNCZzhlU05aL0hNZkp1dmZMN1pkLzJ2UjI4UHRkVTNOTE1sOStQNWt0Zmo3ODY3N3JsMjkzODNMUXpkTXp4L2FCU3FYaTVpdHkyeXluSTlkZkhRbVVhblRycnNPdDR6WHJMdEtteXpkcitZcVZaNzJ1L0Q3bGw2WGdsdS85djFFODVmNk5sMTZ1aG9aR25TMGZBbmE2N2VxZDdYYXR4MzRDQUFCbVI2VVdLWGJIbmYvd3hDNlZxcEVlMkhsSTJ3Nk1LcGdhMDFMeDVBdDc5WHZmK0lIV0xtdlJzc2FjTHVsdFYzTStJd0FBc0xqNG9HbFhwMlJlZWUwcmc4bUpTVE0wTktTREJ3L2FmZnYydWVPaFdEYTJKSExNUGIvT0EvZnZSYklLYk1iMmJkMjZkYS9iVHYvSFRaOHNGb3U3QkdCVy9kS2YzTkNlRGJPWlFPSDFrdlVuVjlhWk9HNjNNaXVOVEtlVmRjVjB1emRuenAya2NPOVBQaHFCQmNhOWY2Mk5GUHh5TG1OZi9OVzdYdjlZWkN2UFRabmdZUDhMOTFTS1JjVm44MlR2dkd0THJqbzJsV2xxeXJmckhMZ3p4UHMrKzY1N0NGRUNBQUFBc0dRUVlBUXNmRDdBcU45VmxQNHJhK3hOU2xMZWVXL1htdzh3OHFGRmwxeHlpUUFBQUFBQUFBQUF3Tkt6Y2RQbHlmQ1YxOStraGNZSC9FeUhHSG5mL01lL1Q4Sno5Z3o4OEhxWmtlR2hwSFIwTGt2Q1czekFVQzZYMTV2ZmVxdG1ndy9EOFg3cXA5K2gvZnYySkdFNGxVcFpVNU9UbW5TbDZtNzcxL1VoUFRkdGViM1M3cnpNOURvLzNodmYvTmFrbkN2L0d0UGhORC82bG4rdHVlRERpQzdlZUdsU3ZCOTgvN3NhMlBWQ3N2NXJ0VnF5M3FjRGdxWk5iNGZyYjNxTnUvM3l3VXhuYTNwZXJ0aDhqWnVYNTkwOGZlL1lQakErUHE2b1ZrMkNrM3l3a3VjdmlPdnFXYTYrVmF0MTVWWFg2bHo1N2V2WHZTOVhYZnNqbWkxKy9xYWZkemEyYXozMkV3QUFNRHQ4Z0ZFdHR2cmJSNTVYcVZyVC9UdjJhNkpjVlRCVjFsTHgxSzZTZnUvd2tONXd5VXBkc3J4Tks5b2FDVEFDQUdBUjh2VWh2cnp5bGE4TWZYM09vVU9IOVBqamoydHdjTkNXSzJVU091cmdhQmk0cjFDN3lJY1kyZGplNEtaTnhYRzh3OVd6SFhUVENUQUNabG16c3UxVzZjYWFZbmZpd0JUY3UvQ05ibkxhRFpNZUdZeU8remdrdkFoWWlIcGtUYWQ3SzYreHhtd0xyRG9DcFNwWnhXUDNhRXROdXVlc0FveGEzU0ZVbE04M1dxWDZkVTVxdzBweWpBQUFBQUJnYVNEa0JGaWdpc1ZpdnlKdHNaRzl6bFdzWE84bXJkS1JTbFBlMTNYZ0cwK24wMm10NkZ1aHpzNU85ZlgxS1F4REFRQUFBQUFBQUFBQUxIUlhYbldONGpoV3BWSTVOaTJxMVZTclZaWEpaR1dDSU9uWVlUcThacmExdFhmbzVsdmVrc3hEVXFKSTFsb0Y3bHlNdjhqSGh5MHQ1dk15L2VzdVZ0K3FmcFZLUjlvMyszWHZsenM0YnBtbjEzOXpTNXN1dFBiTzdpUW9xWmJzQTdWajI4T0hLazBManU0VCtVS2pBQUFBNXJPN0gzbGV1d2JIOUE5UDdGSXRzaG92VjFXTHorcGF0Z1d2WEkyMGIyUlNYM1hyNEZ0UEQ2Z2htOWFHbmpiZHRMNVh3SHl3YmYrb3RoMFkwMWVmT2FCOVl5Vk5WZDN2RUN2TWd0RDlkc3VsQXIxaWVZdldkVFRvbG91NzFkT1VFNERGendjWjlmVDBxTG1wV1ZkY2NZVjU2c21uYWlNakkvYTU1NTVMbFV0bFkyVko3YWlEd0FRRnQrN3pSdVpEMW4zWkZiY1d2eTJyWFpXbzhya29pa3FmK01RblJnVGdyTngyMTVhZWxNTE43dVltOTB0dmxhdk52c3pWWjdmSTJENzNYa3U3RDd3R2Eyd2c4YkVITEJheGNUOTEvSHRiMnVER2VxMHhQeGJic0h6NUtydjdzcnR1bm5SZnVKUHVSK1hNbFQvR05odHJDdTYwVjRmN1dFaTVyMlAzRWVMK1U1elhPV2hVTVBHcmQ5MWNUVWFzM0FrK1BXRmtLKzRzNTJGajRuRjM0bk9mVEdvZ2xhb2Qwc0h5aTcvN2dmdW5CQUFBQUFBTEdFRW53RUpWVWF1ckF1bDN0emE2c2xtb0s5OEkyemVNYjJscFVVZEhoNXFhbWdnd0FnQUFBQUFBQUFBQWkwSkhaNWZxeVlja2RmY3MxMUxWMHRLcSthUlFLQ1FGQUFCZ01kZ3pQSzduRG81by8ralN2VDZzRmx0WElnME1qU2ZqKzBjbTFkbDRUdGZsQVJmRWFMbW1BZmNlL2Q2TFE5bzVOSm1NK3hCVm5MOTBhRlJJcDF3SkZBWkdwVm9rQUV1RDc3alZsMXd1WjlvNzJuWGd3QUgzeWVyKzkva2RQcU44YWVVNXpodHVHNlNUb2JXdjhFTmp6SmpiSGxrVG0xd1FCRFVCT0h1UkdtMW9lOXo3YTVPUldlK09JcStVc2EzbWFHRFJrYmcyd291QXhjVDRHQ0tUWERQYjdnNXUydDJ3LytoN2Zic2JUQ2kybys3ZFAvUFJqbFduKzdmUkdLMXd3OVIwcEtPWmhjOEo5MXdsNDc3cjNlZFF5WTN0YzU5TGg0MEpVbTdhdUsybFM1V3N1QWdOQUFBQXdJSkhnQkd3Z054eHh4MTlwbXE2M0R2M283R051OXhKaVhWdU10M2QxRkUrbjFkM1Q3ZDZlM3UxZlBueXBFZVNkRHBOZUJFQUFBQUFBQUFBQUFBQUFBQXd6eDBZbXpvVzNJTWpuaDhja3dtTWZtTHpHZ0gxdEd0NFV0L2RQYXkvZTJxUEsvdFVyc2FhcXNXRUY4MGlIMkRtQTZIOCt2M2E5b09xeHJIV3RUZm9GNi9wRjRDbFpmUG16ZWxxdGFyTExydE00K1BqOXQ1NzdxMlZ5MlV6T0RqSTlTWjFaR1d2czdHOU5oV21ibEdnWjRyRjRqZmM1Qys3NFRZQk9LMzNmZllOYnd4c3ZENDI5bWZjRzZuRldOTWpZekx1S0RKanVJNE9XTExjWjhDYVFJcmlKS3B4NWtBaWQzOWdqOFE1enZwbmhYdkZuSlc1THJsdGJjM2FJSElUL2Z5NDIzRXR6QWRqNzd2cjVvcjcvbi9BL2ZDZE5HRnduNjNHZTgzazVHUGJOVmoreXUzYnl3SUFBQUNBZVk2S0YyQUJ1T09PTzVyOTBCaXp5bFdEZExuS2lOVnV0TVdWK2RYZDZoTGh0a015ekdhelNXQlJZMlBqc2VLRGk0SWdFQUFBQUFBQUFBQUFBQUFBQUlCNXprb3hXU2duc2xaUnhFcEIvWTJXYWhvWW5kTCs4WXFHSnF2QzdEdVNCV1ZWcXZrUzY0V2hTYVZEMmo4Q1MxRXFsVEt1cUtXbEpXa0wzZGJXcGxLcFpNdmxzbnl3VWFYcXI2WDMxOXB6akRBWHpIUmo5U01kSGJ2VmJsZTZTU1hGNm84VnJ5NFdpK1B0N2UzNy9RTnV2LzEyd2d5dzVMbjNSSENQN2drMnJTNTArdkZZVS8yeVFiZjcyT28zVm5scjFPNm5Hd0ZZeXR4blFPaU9aTUtYK2l5NDBFYzY1c2gzdS8reVAvYVpaSDc0ejZUN3ZxKzU3LzE5N25OcjBoMTQ3VmFvakNua1IxYUg2OGZmODVkOTQwT3BBNlAra1Y5NCs3YUtBQUFBQUdBZUlzQUlXQUJNWk41b2plMkxUVnhVb01CVlV6VDk4THdFNXBvL1FaZlA1M1hkZGRjcG04dXFwNmRIQUFBQUFBQUFBQUFBQUFBQUFCYVdRaWF0NWx4RytLRjhKcVhtZkZwQXZUMTFjRXlmdm0rN2hrdUVGODJWdTdmdFZTb0lWTHo1RWdGWW1vNTI2R3B1ZmZ1dDZWS3BwSDM3OW1uYnRtM3hrMDgrR1U5TlRvVzFXbzBHN0hQc2FKaFI2TXBHSzd2UnlQeUNqVzNsOE9IRHYrbW1QZTdLZlFLV3VMSGVlOW8zWjlRWXEveEo5ejdwbEExZTQ4TkFmaGdLQWdBTFFzR0hSYnJ2K2pjazhVWldQeEVvcU5qUVRxVlVlVXJsOEttdVV1OFgweVlZdVBXdnRZMFFJd0FBQUFEekVRRkd3RHprS2h6TW5YZmU2VTgwZENhbHFvdGQzVU92cTREdzAramVwazU4Y0ZIZ1RzNjN0clltSitoOGVGRW1Rd01tQUFBQUFBQUFBQUFBQUFBQVlDSHFhUzVvb2x4VkdCeTVxaldLclphcWRCZ29td3ExckRHdmJyZGVnSG9xMVdLVnFwRWJScXJGc1RBM29tUlZ4eG92MTVMeHhpek56SUdsekxlWnp1Vnk2dWpvME1xVks4M282S2dteGliczJQaVlxZFZxUXQzNGF3bjhCL1RGMXRwVXNWZ2M5eE1IQndlZmROdkt1bkhDRExCa3ZQK3VMYTBsNVZyTHF2WEwxcnFOc2IzdUYxMkJ6Q0lBaTRXL3ZsQkdvYXhwTmtiZFFXZ3VjNU82dTByZDJkdnVXbEdlVkhYbnhLUnFYL2lWZThZRkFBQUFBUE1BWjVhQWVlak9PKy8wWFZnVkZPbm5YRVhEVFRhME4rcEltQkhxcUxtNVdkbHNWdGRlZDYzeStYd1NZZ1FBQUFBQUFBQUFBQUFBQUFCZ1lYcmpaYXVTQUtNL3UvOHB4ZFpxckZUVlV0WFRVbEJiSWFkWFhieGNtMWZTVkEzMVU0dXQ5bzJWdEcraXJQM2paV0h1K01Bb2IvdmhDV1hDUUp1Nm1nUmc2ZktkdlBiMDlQZ1NYSGZkZGRyKzdQWm8vLzc5OWp2ZitVNFF4N0h4UmFpSG5QL0h4dmJmSjJOVzk3cC9EelUzTi8rSGNybnN3d3NHQlN3Uk5hVTJaMVRiSXNVL1lVMjQyVS9qZ3duQW9tTGtyeTlNRzZOTDNQQVM5LzEvaTFVa1V6UC9FcGg0WDZOU255NFVhc1B1dmtjRUFBQUFBUE1BQVViQVBGSXNGdjBKaFI1WDFrZFJkSk1iWGhjbzZKY1BNMExkK09BaVgzcVg5eWJCUllWQ1FlbDBXZ0FBQUFBQUFBQUFBQUFBQUFBV3J2YUdyQnF6YWQxKzh4VkphTXFMUTB1M3cvcTF5MXJVMlpoWGYwZVRjdWxRUUwzNE1MSGhxYW9tSzVGUUg2VnFKT3UyQXdBY3I2MjlMY2htc3phS0lsT3IxZlQ0NDQ5WEhUTTJOc1kxS1hWa1pWZTd3Ykl3REg4dEhhVDNGVDlVZktxbTJ0TWYvZWhIbnhhd3lCU0xDb1pYYjJtdVZzTXVrN2F2TTdLWHVTT1dTNjFNRDhGRndCa3dpdHg3WmNvRXlyaXhqTENRclhCSEFTMXVlLzVDcU5UdysrNTYzV1lUQjl0clFXMTdkcWc4OHJzZnVIOUtBQUFBQUZBSFZCWUQ4NHNQTU9xUDQvalZ4cGpialV4ZVZBclZuUTh2Nmx2WnB6VnIxcWlob1VFQUFBQUFBQUFBQUFBQUFBQUFGcjcyaGx3eXZQM21LMVdweFhweTMyRXRWUnQ2V3RYVFROc28xRjhTWUZTcWFySmFFK3FqNUQ0UEFlQmtIUjBkeHBldTdxNGs1R3p2M3IyMXljbkpnQUNqdXV0UC9yVzZ4QnI3ckRIbTI2azQ5YmR1Q2dGR1dJUzJCTzZmMWxSS0Y4Y3l2K3h1ZDd0Q2VCRndob3kxVVJnRUUwYkp1NFpyMVJZdzkzM2ZkL1RtUnZjcmV0Z05meEFIOFZjelNvK1BOcGNyYnB3QUl3QUFBQUIxUVdVeFVHZWYrdFNuOHFPam8wYVIzdXBLajVWOWd3bU1PN01qSDE3RWU3UU9YRVdPQ29XQ1dsdGIxZDNUblF6YjJ0cVVUcWNGQUFBQUFBQUFBQUFBQUFBQVlIRXBaRkxLcG1KdDZHN1RVdFdhNTlwRkFBRHc4bEtwSTgzYmIvaVJHOUtsVWtsN1h0eWp3Y0hCZVBmdTNYRzVYQTZxMVdvZzFJV1Y3YlhXdmpvSWd4VjNmUGlPSDdYR2ZqbUtvc0ZWcTFZOS9ONzN2cmNxWUFHNzdVKzJyRDhRaG0yaDdQdGsxT3dtclhRbEx3Qm53VmhqVkRWU0pDd2UxalM2VGJ2QnlEUkcxdDVRQ1BJUC91cGRyOTB4RlpXK0drWWRwYys4OTh1VEFnQUFBSUE1UWpnS1VHY2pJeU5wWTB6Z0tsR3ZkU2NNVnJqaExlN3NBZXJJQnhobGMxazF0elJyOWVyVnl1ZnpTYUFSQUFBQUFBQUFBQUFBQUFBQWdNVW5rd3JkdjZIeUdUbzRBd0FBZUNsaEdDYkR0V3ZYcG55QWtXOWpuYzFtZGVEQWdaandvdm94dmdHODFDU2pKbXZ0U2plODNvM3ZjOXZybWIxNzl6N3ViaE5naEFYTmhxbk90TkVxYS9YajhqL2VwRVlCT0Z2V2h4Y1pjZFhhb21MODljR214OTNxa2JGWHUvRmNZSVBPcGpEN0hZWGpzWnRPZ0JFQUFBQ0FPVU9BRVZBbnYvM2J2NzBpblU2M0tOWnZ1YXFmVGl0N2c0eFFaeHMyYkZBbWs5R0dqVWVHdVZ4T0FBQUFBQUFBQUFBQUFBQUFBQUFBQUlBZjh1MnMrL3I2MU5QVFl6YS9Zbk42MXd1N29zT0hEMGZmZitqN3FaSFJFUlBIc1REM3JMVlpZMHhHVmg5MG81TTJzdSsrNDhOM0ROVGkyb2ZjTmlsOTdHTWZHeFN3UVB6cW43N3VkU1kwN1lyaU85d25TcWV4YWtydU1GeDhBNXd0SzZYYzkwQnpiRTFXV0x4aTh4cHJkSDFrd2hzVUsvcDNkNzMrQTZGcXcvL3RYZmM4SlFBQUFBQzR3QWd3QXVva25VNzcxUGVNZk1LeHEwaDFwVm1vTzdkZGt1SjdBd21DSUNrQUFBQUFBQUFBQUFBQUFBQUFBQUFBZ0JPbFVpbGZqQTh6YW1oc1VLbGNzcWwwU29ad2tib3hSMWErSHpTNG9TL0xaZVhUcEZKdUd0Y1FZVUVKak1uWTJEWWFtU1BYM2ZEUkFwd1hLeE80OXhIdnBNWE15QWRVWmEzVkNuZEVVQXVsbkRzSXlBa0FBQUFBNWdDVmo4QWN1K08zNzdoZWdhNTNsYWovMW8xZUs5U1ZQMm5tUTRxdXZ1WnF0YmUzcTdlM1Z3QUFBQUFBQUFBQUFBQUFBQUFBQUFDQU05ZmYzNTl5UlpkZmZybmlPTlpYL3Y0clU1Vkt4VHo1NUpOY05GOWZtMlMwS1F6QzU5M3RRM2Q4K0k1L3RzWisvaU1mK2NqL0VqQlAvZXBkTjc4MWtObHNGZitDWlBvdGNTdkFiRWhGVmkxeExDd0I3bU56eFpHaC9WWkt3YzdiNzNyOW44VUtIdmx2Ny9ySHV3VUFBQUFBRndnQlJzQWNLQmFML3FSTHdaVlZpclRKeXE1enQ5dUZ1dkdoUlpsTVJnME5EY3JuOHlvVUNzazRBQUFMMmY3OSs1UGh4TVJFMGdDa1Vxa2N1ODlQcTlWcXlYZWZEL0R6d2pDVTcvbktmdy82NzhOc05xdDBPaTBBQUFBQUFBQUFBQUFBQUlCNlNRVkdvUWtFQUZpWWZEdHRyM05aWjFBcFY4enk1Y3RWclZidDBOQlEwcTdORmFKSTZzUVk0eHNJZGdZMnVPVERILzd3cThJd0hMS1RkcmlqcitQZzdiZmZYaFpRWisvNTI2c0xtY0dtVlRKMnZmdTQ2RGRHQktBQndIbUs1VDVMcmUxWEVJLzg2bDFiTnVaS2xjUGYyNTg1L0swNzdvbmM1NndWQUFBQUFNd1NBb3lBQzZ4WUxQcjNXWTlxMnFoQXYyR05YZTNHKzRXNjhpRU5uWjJkMnJCeGczcDZlcElnaCttVFpRQUFMRlJmLy9yWGs5Q2lwNTkrT2drc0dod2NQSGJmbzQ4K3FwR1JFYjN5bGE5TVFvczhIMmEwZHUxYVhYenh4VW5wNit0VFcxdWJBQUFBQUFBQUFBQUFBQUFBNmlFd1JvM1psTElwMnZNQndFSTEzY0hlcTE3MXFtd1VSYnIwc2t0MTZPQWgrNjF2ZmFzMk5UVVZUazVPaHNLY000NGJ0THB5VTJ6aTY0ek1mMVNzTHlxcjd3OE9ESDdSVFI4UVVHZTVnMjFYeFlGOXQySjdvOXRqMTdzOVZ3Q0E4K08rODN2Y1A3OWdiYnhkQ3ErY3l1Vy91bmwxOU5YWDNybGxYTHFuSmdBQUFBQ1lKUVFZQVJmUWIvM1diL1c2UVpzNzhmSjZFNWd1OTRPLzI0MDNDblhoQTRveW1ZeWFtcHFTMHQzZHJVS2hRSEFSQUdEQmV2SEZGelUyTnFibm4zOWU1WEpaRHozMGtIeURqejE3OWlUajQrUGp4eDVicXgwNXQrQkRqY0x3U1BzUC83M29BNCtHaDRmMXdnc3ZxTCsvWHgwZEhicjAwa3VUc0Q4ZmNBUUFBQUFBQUFBQUFBQUFBREJYUW1QVW5rK3JPWmRTT2pTS1k2dklDbk9vcHltbmxDRXNBTURzOEprNXZpMWFSMmVIMmJScFUrQTc0WE1sT25Ub1VEQTFOV1dzdGZJRmM4d3FrRkVZSzc3SXlJUkJMaWdYUDFUY1AxNGEvNGNvaXVMZi9kM2ZuUkl3aDI3N2d5Mk55cXFuRnNUclE1bDExbkRkRFJZZkl5SzVVSGVOYmg5Y0oyT3ZqVzJveTFkbHZyR3N1R25rcisvWVZuV0hiQnlRQVFBQUFEaHZCQmdCRjFBNm5iN2NEVmE1RXk4ZjhSWDdJcnlvcm54dkhqNndhTjM2ZFdwcmE5T0tGU3NFQU1CQzl2VFRUK3VwcDU3UzNYZmZuWVFXK2NZZEwyZkhqaDBuakQveHhCUEhibDk4OGNWSndOOEhQL2pCNUx1U0FDTUFBQUFBQUFBQUFBQUFBRENYd3NCb1ZXdEJYUTA1RmRJcGxXcVJvbG9zekoyTnkyanFDbUQyK0k1bVcxcGFmREc5dmIycGd3Y1AxZzdzUHhBOS9QREQ0Y0RBUUZBdWwrbUp0ZzZNU2E1dDhPVjZHVjF2WlYralFLVnNOdnVRbStaN1MzeFJ3RndxcURGVWNKT1J1ZEZLZmloZ3NmRVpvZVNFb3A3Y1oydVBHL1FZYTlhN3o5clhXVE8xYjhYcXJrZnV2UFB0bzFLUkFDTUFBQUFBNTQwQUkyQVcvZkVmLzNGNjc5NjlhVmRsZjR2N1ZkOXVyZjF4VjVhNUgvaDVOelNHbXFhNktEUVVmQ1dMTHIvaWNoOHFwYTZ1TG1VeUdRRUFzTkJFVWFSeXVheG5uMzFXOTk5L3Z4NSsrR0h0M3IxYkJ3NGMwT1RrcE03WC92MzdOVHc4ckQvOHd6OU1lcjM2OVYvL2RlVnlPWFYyZGdvQUFBQUFBQUFBQUFBQUFHQ3U5RFJsZFZOL2g1NDVOS1puRDAwSUY5N20zbVkxWk5JQ2dBdXBxYkVwVEtmVEpwVk9CWnN1M2FSbm5uNm1XcXZWdEgzN2RqNkE2c2hhMnk2amFtakMvMGVCS3NVUEZ4OVhxRWVLeGVKWEJWeGd0LzJQMTk4VUtsNHZtVit5c3AwaXZBaUxWRG9VTUYrMHVKSXhObmhQWk15dW9SWC85THUzZnVxRzBTOTg0UDRwQVFBQUFNQjVJTUFJbUVWNzkrNzExVWtaVjErNnlSVlhnYXJYdXBKMFJVTjRVZjM0c0NMZmU4ZnExYXNWaHFFS2hZSUFBRmlJckxXcVZxdittRVAvOUUvL3BLZWZmam9KTDVvdEl5TWp5ZkRiMy81Mjh0MzVTNy8wUzJwb2FDREFDQUFBQUFBQUFBQUFBQUFBektuR2JFcnJPeHAwYUtMc3hnZ3dtZ3ZkalRuMU5PVUVBQmRTTHA4enJvUytYWnJ2MEc5MGROU1d5Mlc3ZmZ0Mm9ZNk04dTdmdkJ1K1RWWWxOK3hUbE54RGdCRXV1RENJMXh0cGc1VnVJcndJaTFsb2pHSjJjY3dQUjcvM3pTdmRjRk1xRlgrMnB5djI0VVVFR0FFQUFBQTRMd1FZQWJPZ1dDeTJ1a0cvcTZSL3Rhc3ZmYlUxOWpJZFNTTnVGT3BtMmJKbGFtMXQxZnIxNjVYSlpwVFA1d21TQWdBc2FBTURBN3JycnJ1MFk4Y09QZnJvbzVxWU9MR0JubS9VNFlQNzN2U21OeVhmZ2F0V3JWSmJXMXRTanVkN3JOcTJiWnR2L0pFTS9mUDVNbTF5Y2pJWmZ1cFRuOUpGRjEyazIyKy9YYWxVU3JrY2pkUUFBQUFBQUFBQUFBQUFBTUNGMTk5YTBEdXZYcVhXWEVhbGFxem5EazlvdkZJVFp0K0s1cHc2QzFuOS9DdFdhc095WmdIQVhQQ2QwdnB5NVpWWEp0ZTByRmkrUWtQRFEvYWg3ejBVMVdvMU16NCtIZ3Ixa3JLeVY3clN0WFhyMXRlNzhlOEZjZkM5Y2xTKzkyTWYrOWhCQWJQazlqKzdjVlVZcERPMW1qNW9aZWlsR2dEbTNncFpSWlVnMktwcTArQnRmN0RsTnc4dUswZGZlUHY5QkJrQkFBQUFPQ2NFR0FHencxL04zeXFqdGE2aS9ocDN1L3ZvTk5SUm9WQlFVMU5URW1Ua0E0d0FBRmpvZkxEUXM4OCtxMzM3OW1sa1pPU1UrMzNJa0E4eFdyMTZ0YnE2dXJSaHc0WmsyTjNkZmNMalNxVlNNaHdjSEV6Sy92MzdUN2pmOTJ6bFBmUE1NOHBtczhsNEVBUUNBQUFBQUFBQUFBQUFBQUNZQzYzNXRES3BRRDFOMmVSMkdOQjU0WVhTbUVrbjYzaDFXNFBXZHpZSUFPYkNkSHUwdHJhMjVJYnZwRGFUemRoTUptT24yNjloN3BranZRV241YStOa0ZxTXpFV3lLbHRqOTJXaVRGYkFMTEpScnRIR1FVYUtOd29BVUE5NXVXOStLN1BaRFhabENrb3RPOGpYUFFBQUFJQnpSNEFSY0I2S3hXS3JJcjNmUnZaSzk0UDlyVUpkK2RDR1hDNm4xZjJyMWQvZnI1YVdsaVRFQ0FDQWhXNXNiRXovODMvK1Q3M3d3Z3Y2OXJlL2ZjcjlhOWFzVVdOam8vN3FyLzRxYWRqaEEveGVpdisrZk5XclhwWGNmdXRiMzZwSEgzMVVqejMybUw3d2hTL29vWWNlT3ZhNFhidDJKY1BQZmU1elNSalN6VGZmTEFBQUFBQUFBQUFBQUFBQWdBc3RFd1pKZWZjbEJiMXJSWXQrOEUvZjBzaWhQYnBuckYxVGxrNllac09LVEVsWDVNYTE0ZXJYcVh2MVJxV1haUlZrMHdLQWVtaHRiZlVsdVBqaWk0UHg4WEVkT25SSS8vSXYvMktmMy9HOExWZkt4c2FXSkxzNWRqVE1LQ1dqSDNQREgxTk9INzVqNngwVkszdGJFQVM3aThYaTl3U2NnL2Y4OGRXRlFxWXBFMW45U2FSNHVRQUFkV1dzTG5IZjcyc2lCWGNIQmZ1SW0vUitBUUFBQU1BNUlNQUlPRXV1b24zNmZkT2xzbG9WdW1KY2RUenF5b2NYWmJQWkpMRElEOE13UE5ZekJ3QUFpOEhvNktncWxjb0owM3o3QVArZHQyelpNalUwTkNUalI5b01uSjEwT3AzOHZmOGU5V1Z5Y3ZMWWZlVnlPWGx0UDR6aitKeGZBd0FBQUFBQUFBQUFBQUFBNEV4WkcwbFJySGhxVkxYUi9VcFZKNUxTRklWS3hhRncvbkttb2xRNElVME9xamE4VjJIcmNwa3dKWk9pU1N5QSt2SnR3SDNiOEVLK2tIUm9Pekl5NHI0WHJDMlh5elJjcXlPM0NjTEFCS0dWN1luanVGWXNGbnZjdE1sNzc3MTNjc3VXTGJFYmp3V2NrYVpDSmFYV01GSm9yVks4c1FGZ2ZuQ2Z5ZTdIWU5qOG5yL2MwcW5Hc2NuUC9QaERrd0lBQUFDQXMwQ0FFWENXWENWN2p6RW1wVmgzSzYyTXE0Qy9SS2dyZjRKcXhZb1Y2dTdwMXNhTkc1TWdCMThBQUZnc2ZJRFFYL3pGWDZoV3E1MHd2YjI5UFFrZWV2LzczNjhycnJoQ3pjM05PaGVYWEhKSlVueEREOS9nNDV2Zi9PYXhFQ1BmazVWLzdUZTk2VTI2OGNZYmxjL25sY2xrQkFBQUFBQUFBQUFBQUFBQWNLRWt3VVdIZDJ2MC9yL1E2QU4vb2FieWhKcmlTSDNDYkNzLzk3KzF4dzJYdmUwVHl2WmRvZnpGcnhJQTFOTjBSM3g5ZlgwKzE4Ujg3M3ZmcXd3T0R0b0hIbmdnYWJobVkwdmVTUjBZWTFxc3JOc0ErZ00zV2xLczc3cHBUOTU0NDQwZm41cWFHbmJUUmdTY2dYUTIvSm1ncHRlNXZla3k5Mll1Q0FCUWQrN3pPT2UrN0sremlsZG55bUdnY3V2ZGJ2TGRBZ0FBQUlDelFJQVJjSWJ1K0k5MzlKblFORWR4OUNOdXRCQ1lvTTMzSXVBcTNZVzVad0lqLzE5UFQwOFNZTFI4K1hLMXRMWWtQVzRBQUxDWTdONjlXd01EQTZwVUtvcmpFenNvV3J0MnJXK2tvYWFtSnFYVGFaMHZId2pvd3dEdnUrKytZd0ZHN25nbmVlMkppUW50MjdkUHZiMjlCQmdCQUFBQUFBRE1wRmFXeW1NQ2dHT0NsRHV4NlVxdVVRQUFBQURPVGpRK3FLbnQzMUYxY0tkc3JlSWJNQWdYVm5uWEk0cEw0d1FZQVpoM2xpMWJGdVp5dVhqVHBrMUpXN1lYQjE2TW95aFN1VnltNFhqOXBLeHN0NnpDMElRL21jbG1kaGFMeFJleTJlenp2L21idnpra1lBYnYrOU5YTFZOR3kydzFYbXNWckRTeTZTUXlBd0F3Ynhockd0MUg4enByN1ByYi9tVExlcFcxN3c5LzVaNXhBUUFBQU1BWklNQUlPRk1aYlhJL3ZqY1pZOTd2eGxwZGFTRzhxSDdDSUV6Q2lpNjk5Tklrd0doRjN3b0JBTEFZUGZUUVEwbUEwZFRVMUNuM1hYMzExWHIxcTErdC92NytwTWVwODdWaHd3WjFkM2Zyei8vOHo0OU44NkZKL3JVUEhqeW9aNTk5VmcwTkRXcHViaFlBQUFBQUFBQk80c09MQm5jSUFJN0pOa3FwTEFGR0FBQUF3RG1vN250YW85LzVNOVZHOTh0V1M4S0ZOL0hrTjJXMi83UGFmK3lEQW9ENVpQWHExYUViaEw2enY4bkpTZnNQWC8ySDJ2ajRlRUNBVVgyWUl4ZFIrQjRYTjFySEJPYjZXUEYzWlBVZHQwMis0S1lUWUlTWm1YQ2Rxc0gxUnVZR04zWVY0VVVBTUE4WitaTmFOeGxyRG9WaGNDakt4dmU1OGUwQ0FBQUFnRE5BZ0JGd0dzVmkwWi9ReUxpeVVaRXJSamU1K3ZWMXJySzB4VTNMQ25XUnpXYVZUcWZWdTd4WCtYeGVMYTB0U1pBUkFBQ0wxYUZEaDVKeVBQOWQ2QU9MZW5wNnRHclZxdVE3Y1RhMHRMUW9rOG1vcmEzTjkwNmxrWkdSWS9kTlRFeG8xNjVkV3I5K3ZRQUFBQUFBQUphODhZTlNWSkgyL0VDS2E5TFFicWt5S1UxeFhRYUE0NFR1ZEhPWWtwcTZwVlJPYWw0dU5YUktIV3RjUmErcjF3M1RBZ0FBQUhBU2EyVnJaY1dsc1NQaFJlVUpZVzdFNVhHWldrblI1TEJrQW9WNU9yZ0NNTC9rY2ptbFhGM0w1bGRzRGlmR0o4elJ0blgyd01FRHRscXRHaHRiMGxEbW5sL25nZnYyWG0yczhjUEdyVnUzdmlHTzQ3OU5wVklUeFdKeGw3RGtGWXNLZHE3ZWtyRTJXRytNMmVJbTlRaEFQZFNDUU9OQllOd0pDK1VFdkNTNzNuM04zeEtZWVAvNzc5cHlxUFdGTGFQdWV6MFdBQUFBQUx3RUFveUEwL09wT0RsRjJ1eXExZC9xS3ROZjRZYXJoTHJ5SjU1OFlNUGF0V3ZWMnRxcXBxWW1BUUN3bUEwT0RwNFNZT1JEaG56WVVHOXZyKzlkU3JPbHViazVLZjQ3ZG1wcWFzWUFJejhFQUFBQUFBQlk4aVlIcGRLbzlPVGZTOVdTdFBNN0FvQVorUTdwTTQxU3ZsWHF1MXJxM2lBMWRycXowU0VCUmdBQUFNQ01qZ1FZUmU1M2R6UjZRSmc3dGpMaDFyNFVUNDI0M3l3cEFvd0F6RHUrSGJseU1xOTR4U3ZDOGZIeHBGM2R0bTNiN01qb1NGeXIxVUtiZklwaExobVRaRVlGUnNZM1pGenROc0ZWN25ZbGxVbzk2OGI5RnprQlJ0QTkyaEpzZHUvZTJHaTllNWR1Y1h0Tm5uY3JNUGZjZTYrV01tYmthQmZ5QkJqaFpSamY2L0ZLRTlydnVPLzNKKy9SUGVOdW5BQWpBQUFBQUMrSkFDUGdKTVZpMGI4dkxuTmxiUnpINzNHVjZyM3U5bkpYa2Q3Q1NZMzZhV3hzVEVJYWxxOVlydmIyOW1ROERFTUJBTERZN2Rtekp5bkg4K0ZGRjE5OGNUSzhFUHgzcnYrZTlZRkYwOHJsY2hLbVZDcVZCQUFBQUFBQXNPUkVOU211U2dQZmx3WjNTSHNmbGZ6RmZJZWVjOU5yQW9DWFZKMDY4bG54b3ZzTU9maXMreXg1MkZYRVhpRzFyWkpXWFNmbDZMUUZBQUFBbUdialNOWEIzWW9uaG9UNmlNWUhaY0tNKzgyeVFnQXdYL2t3bzU2ZUh0OWhuN244OHN2RDdkdTN4K05qNDNyeXlTZk5WR25LMk5nYVljNVphN1BHbUV3Y3h4L3k0OFd0eFgrUzFhNUtWUGxjRkVXbFQzemlFeVBDa25OcFg3Q2lhdlR6Z1RVM0dxdUcyTmpRaUxjb2xpWmpGQWRHdzFiS1dLdEd6U1dUeE1XRzRnMklNMkl6eHBxVWxmbXhTTUdtVGF1ajRqM1NQZ0VBQUFEQVN5REFDRGlWZjErMHVncnk1YTd5L0hwM08rdEtqdkNpK3NwbXMycHFha3JDaXpvNk9nUUF3Rkl4TWpLaTBkSFJFNmI1eGhmZDNkMUhlcFM2QUh3d1VxMTI0b1YzMVdwVkV4TVRjc2RJQWdBQUFBQUFXSEpzZENSODVPRFRSMEtNZlBqSUZCZFNBamdEMXAxbnRyVWpueUZEUjBQajl6OXhKQmpOQnh0MVgwS0FFUUFBQUhDOE9GSThPU1JibmhEcUkxbjNhUUtiQWN4dnFWUXFLYmxjenZqMjVjTkR3OHFrTTlaNE1xTHRmMzI0dFovMFVPeTJ3U3VPVGhwVm9LeUpUUzRJQXI1Y2xpZ1R4bm5aY0wxN1gzYTZuU1JGZGdxV05tTURZNnB4Yk1NNmZGUDU3MGozSlVuSUg4NkVDZHllRXJnYnE5MnZ4QXR6MFFJQUFBQ0FSWWNBSStBNGQzejRqbCsxc2UxM04zODJNUDQzdHBxc1RjNWpDSE92dGEwMUNWRFlzR0dEOHZtODd5RkRZUmdLQUlDbDVQbm5uOWZ1M2J0UG1PYS9GNWN2WDU0TUw0UTFhOWFvczdOVFgvN3lsNDlOTzN6NHNMNzczZS9xYlc5N213QUFBQUFBQUphTU9KSnFVOUpULytES1Y0K0VqNHdmUEJKRUFnRG5ZK2MvUzdzZmRKV3ZPNlhHWmRMci9xTUFBQUFBQUFCd2JqWmR1aW53bmZaZHZPRmkzMUdmdmVkYjk1UW5KeWVEQXdjT1pJUzZzYkxYMmRoZUd3YmhtMU5oNnZuaTF1TDlVU1g2WDcvejhkOTVXRmowM25uWGxseGVxYzNHMml2ZDN2QlR4cGdNMFdKWTZzeVJYZytpd0NpTzUvZ05FUnFaUXRxRTZaQ0w1SEEyekhxM3EvYW5iT3JuM25mWGF3Ly8vcnUrOWFjQ0FBQUFnTk1nd0FnNFVidXJqMmwzRmVVOTB4TUlMNnFmSUFpUzB0RFFvR3cybXhRQUFKYWFhcldhbE9QNTcwZmZlNVFmWGdqK083ZGNMcDh3elRmdW1DNEFBQUFBQUFCTGltOUhYSm1RSmc1SnBSRlhVVklTQUp5M1d2bEk4WjhyWVZvQUFBQUFBQUE0ZDJFWUd0OVI3blNIdWVsMDJ2b2kxRnZ1NkxEUGxTbFhPcFZXUVZneVFyOFBXSk5Yb0ViZWtNQVJnVEUydHZWNVJ3VCtNam1mb3dTY3VaVHgxeUFiMit4MkhTNGtBQUFBQVBDU0NERENrbFlzRm4xUVVZOWkvWVliYnJTeWw3aENMd3QxdG1IREJuL1NTRmRkZmRXeGdBWUFBSmFhOGZGeFJWR1VGQUFBQUFBQUFOVEpnU2VscjN6NFNIalJ4S0FBWU5ZOWY5K1JZYTdKbFJicHh0c0VBQUFBQUFDQWMzTzAwMXp6c3ovM3MvbFNxYVI5Ky9acDI3WnQ4Wk5QUGhsUFRVNkZ0VnFOMElZNWRyUkRhZi9QeFZiMjRzQUUvL2FPclhkVTNPMVB1V25QZk9RakgvbGZ3cUpVa0ZxTjRxSU4xR0xJU3dFUzdwMFF0R1NEd2xUTlpzWXJzZVpTeXBoTWN6Ym9UbDJZL25PeDJCbnphM0pmM3UrL2E4dG5LNU9xL2VHdjNETXVBQUFBQURnSnFTQllrbjd2OTM0dk96Z3d1TXpkWE84cXhOZkZObDdtYW9FYXJMWGgwUXB5ektVa3Z0c29sOHNseGZkODRRT00yQllBZ0tYTU41NG9sOHN6QmhqNUhxSWFHaHFTNzh1NTV1Zkh6NWQvYlI4MENBQUFBQUFBc0dpTnZDaU5IWkFxazY1U2hNNGtBVnhnWS91azZwU3JIQjZUZk4xcnBrRUFBQUFBQUFBNGQ3NTltMitiM3RIUm9aVXJWNXF4MFRFN09UbXBrZEVSSlVGR1ZxZ1AzL0F3WmF6cGQ3ZFN4V0x4R2o5eGNIRHdNYmV0ckJ1dkNBdmVyWCt3cGRHZFdXbDFHN3ZGalRZS3dERXAzODk3b05ES3h1Njd5Smc1dUhncWtLMjRsd2tDNHo1L0Jadzl0NytHZmxDTDArdlR6WlB1WkphZUZnQUFBQUNjaEFBakxFbUg5eDVlcDZ6ZWFDUDdvOWJZVzZiRDNBbk1xWTh3Q0pNZ2h2WHIxNnVucDBjcitsYTQyamcrbmdBQVM5dWVQWHMwTWpLaU9ENjFkdzBmOXJkMjdWbzFOczc5T1YwL1QvdjM3MWQzZDNmU1d4VUFBQUFBQU1DaVZCcVZIcnY3U0lqUjhHNEJ3QVgzOU5la2hrNXAwMXVPRER2V0NnQUFBQUFBQU9jdWs4a2tiZE5kQ2E2NzdqcnQzTG16TmpnNEdEOXcvd1BwdzRjUHo5aTVJT1pFTHZuWDZCZDlpSlMxOXNmZDhFQnpjL043S3BWS3lkMnpYMWp3T2d1cHl3TFpmaU50Rm9CalRHQ0N4b3hwaW0xY016Smw5MW5vTDU2Nm9EM2FHcU1vSFFSRDJkQ2tNNkZwRjNBdXJJNzB2QkhFdnhyVjhrKzVXeDhYQUFBQUFKeUVoQkFzR2NWaU1aUE5aaHZLNWZKMU5yTHIzYVJYV3RrVlJvUVcxWXNQS2ZMQkJ6NkV3UmZmdTBWRFkwUFMyd1VBQUtnZjMrdlU2UnBubEVvbGpZK1BxN096VStlaVZxdkpIWS9KOTJRMU9EaVlQSjkvTFQvdXc1cDhveEVmYk9pUERRcUZRbko4a0U2bmsrbjFNREV4a2N5dm4xYy9ueXRYcmt6bXo2K2pNekc5dkQ3NGFYUjBkTWJsOWFXaG9lSFk4dnJqb3dzWjV1Z2IzL2o1OHNOcXRacHNUejlQdnZqMTdwZlB6NHVmRDcrOFo4TS9sdys0OHZQdm44YzNBRHJUWmRtOWU3Y3FsVW95VDM2ZERROFBIN3ZQcjIvL1BQbDhQamxXOUFGZVBuelU3eHNBQUFBQUFNeTZxQ1pWcHFUQjdkTFVpQUJnenRUSzBvRW5wZmExQkJnQkFBQUFBQURNc3VibVpuL2hRTEJ4NDBhTmpvMXExd3U3YWxFVW1kSFIwVkNvcDNZcm13MkM0S2VNTldOYnQyN2RubzdUT3ovODBROC9MeXhZUnZGRzk0YnJGOWZyQUNlWWZrZUVnWlJQU2RYWW5ScUlkU0ZGN2pWdElXMXk2VUI4MytHOHVmMXBuVXcwZnR0ZmIybWNuRkR0cysrNnB5UUFBQUFBT0lvQUl5d2xoWEs1dkV5eGZzUDlXdTUyNHhzSkw2b3ZmMUc3RHo5WTNiOWEvZjM5eVVYcGhCY0JBRkIvN2UzdHB3M284WUUrUHN4bitmTGxTY2pOMmZMQk9mN3ZCd1lHOU1namp5UzMvWFA2MEJzZld0UFMwcElFK216WXNFRjlmWDNhdkhuenNXbjE0RU4rZkpET2Q3LzczV1QrM3ZLV3R5VEJQbWNUWU9TWDhabG5ua25LOVBMdTJiTW51Yzh2bXc4djhvRTgwOHZyUTR3dVpJRFJpeSsrbUFRcFBmamdneG9hR2txMmhSLzN5N2RtelJvMU5qWW0yOWZQMjlrR0dQbnQrTUFERHlSQlEzNmIzWERERGNueW5JbUhIbm9vV1RjKzdNbVh4eDU3N05oOVNkQ2xXMDlkWFYzSnV1L3Q3VTJPR3drd0FnQUFBQUJjRUZGSnFveEt6MzlIaW1zQ2dEbmpBNHllK2FhMHR1TEtxd1FBQUFBQUFJRFowOTdlSHZxMmNiNXRsTzk4N2l0Ly81VnFwVklod0tqK1Z2bk83R1QxU1JrZE10YjhjeldvZnQ1Tko4Qm9BUXRsYnJHeS9RSndpdEI5NU9YQ1FDMDVhYndTdTJKMUFWVUQ5K0hha2cxYUFpNmh3K3k0U1RaSVpTYWl6bHBGNDI2Y0FDTUFBQUFBeHhCZ2hFV3ZXQ3h1ZElPQ084bHdteHMyR3BrTmJuaG1WNXhqMXZuUUluOUJ2cjlBMzRjZTlLM3NTeTZTOTlPU0V3OEFBS0R1MnRyYWtnQ2FpeTY2NkpUN2ZQaWcvdzQvbDlEQmIzempHOXEzYjUvdXZmZGVUVTFOSldFK1BqZ25pcUprNkFOOWZPaU5QMTU0OXRsbmszbjQ4cGUvbklRWitmS3FWNzBxQ2RVNVcvNTVkK3pZb1czYnRpV3ZmYkozdk9NZHZuY3RyVnUzVHVQajQwbTQwQk5QUEpHVUF3Y09hR3hzTEpsWC96elhYMzk5OHRqdTd1NlhmRTBmQm5UZmZmY2RXOTdSMGRHa1RDK3ZYMzQvbkY1ZVAyL1R5M3ZsbFZkcTllclY1N3k4SjZ0VUtzbThmLzNyWDA4Q2krNjU1NTVqd1VyK1BoOGE1QnZrK0drKzNNaUhBdmx0N09mbjhjY2ZUeHJzM0hUVFRVbUkwT25DaVB3NisrZC8vdWRrUGQ5Ly8vMTZ4U3Rla1FSVSt1YzhIZi82dnZqZ291ZWVleTRKTFBMcmJYcCsvWDNUZkdpUlAxNzA0VkYrK1B6enp5Zno5NlkzdlNrSk5mTGJEZ0FBQUFDQVdYUGdHV2xrcjFTZEVnRE1LUnU1aXJNZFVzY2FhZkt3bE00ZktRQUFBTUJTRXFTVTdyNVl3Y0NqUW4yazJ2dWtrQTZGQUN4ZXZ2MlJ0VlpYWDNOMTJyZFQ2dW5wMGNHREIrT2RPM2ZHUHRESUZRS042c1FZNHh2TVhXV3NhZDY2ZGV2Tjd2WkRKamJQZDNSMTNIdjc3YmVYaFhudi9YZmQwbDlUS1djVmJ3aGsraTVvTEF1d2dJV0JEUXVwcEMyMkRVeGNtYWk2TXdTeDlXRnVHUm5Od3NWVjFqZmd0ZTI1TUpVS2pkSjhzMkZXMlo1SXFiZG1jL1p4Ti9KMUFRQUFBTUJSQkJoaEtlZzhXdDdtaXEvZGFSTHF4b2NkK0l2aWwzVXRVME5EZzFhc1dDRUFBREMvK0dBWTMwakROOHc0bVE4ZTlLRTc1eEpnOVBUVFQrdUZGMTdRVjc3eWxiUDZ1ME9IRGlXaE5wZGZmdms1QnhqdDM3OC9DU1Q2NGhlL2VNcjlQaWpJaHl2NkVKenB4ejd5eUNOSjRJOFAwZkVCUDlQOGJiOXVYbzZmMzNOZFhoL2k0OE9Pem5WNVQrYVhxVnF0SnZQakE0YjhjcDJPRDJ5YTVwZHpZR0JBYTlldVRjS3NmSGpRNlFLTWZERFRkQkNSSC9wOVo5bXlaUzhaWU9URG92eTY5b0ZIL205OENOSkxQZjU0dTNidFN0YU5EN2J5Q0RBQ0FBQUFBTXlxOFlPdUVtQy9GSi9aNzFRQW1EVnhKRTBPU2xQRFIwTFVnaFFCUmdBQUFGaHlUSmhTcXFWYlFhRlZxSSt3b2QxdGlMTnZGd0lBQzhWMDI3ZFZxMWFsZkNkMHZyTTMzelpxNzk2OXNSUDZ0bCtZZStaSWI4Z1pWMVpaWTN2ZDhJWkFRYzdkemc4T0RqN2d4Z2t3V2dBcUtyVUdTclg2Y0F0NzVEb2VBRE1JM1dlZTd4OCtscW02YjZhb1ZJdnNrZnlpMmVFK1VHUDNiNXpQbUd6R3Z4WWR6bU1XdWYwMDUvN2RiR1hIQlFBQUFBREhJY0FJaTA2eFdQVDdkYzdFNWpYVzJzdmRTWVRYRzVsdVZ4b2tVZU5TSjRXR2drSlh1M2JKSlpja3dRZmQzZDNKT0FBQW1IOThtSS8zb1E5OTZKVDcvSGU0YjZ6aFE0N08xQmUrOEFVTkRRM3BjNS83WEJKMGN6d2ZpTlBjM0p3OG56ODI4S0UydmxHSUQ2aVo5dFJUVCtuRkYxOU1Rb0Y2ZTN0MTY2MjNxcTJ0VGJQSkIveDg3V3RmMCs3ZHUvWDV6MzgrbVY5ZnpxVXhpbDllL3p4Lzh6ZC9jOXJsOVkxZWZFTVl2N3orTVh2MzdqMzJtRWNmZlRSWjV1bmxmYzk3M3FOejRjT0EvSE4vK2N0ZjFvTVBQcWp2Zi8vN3lUS2RLWGNjblFRTStUQ2wzL21kMzlHTk45Nm9IL21SSDlIR2pSdTFjdVhLWTQvN3pHYytrNFFQK2ZVM0hmYlUyZG1wTld2V3pMaWZURTFOSmN2cjU4c1hmOXRQbXc0djhpR1gvdS84c2svem9VNStHL25IK21YeTY4MC8zcisyRDNyeTR6NW9pU0FqQUFBQUFNQ3NHSHhlR3Q0bEFLaWIwcGkwLzBsWG9ialduZmx1RmdBQUFMQVVoZmxtWlZaY3JtaDB2Nkt4QThLRmwrNWNLNU50a01rMCtCUUpBY0JTNEROejJ0dmJsY3ZsektyVnExTDc5KzIzQnc4ZXJENzk5TlBCMk5pWXFWYXJnYld6RlNlQk0yYVZrbEZnWlYvcmhqY28xZzEzZlBpT1dqV3FmaUNPNDhySFAvN3hNMjhJaHpsbFRIaXRlOCtzZFJ1dmthdDNnSmVYRHBSS1pZTEFEUlc1cjV2UmloMnR4VFl1VlczQjNlMFQ5OUpuOUVSR2tmdnNyT1hTaWpLQmlSdlNZVFkweXVSVGhtaFN6THBBcGoyVy9WRVQyOXB0ZDIzNWNxMHlOdnFaOXo0MEtRQUFBQUJMSGdGR1dJeDgzVXJLVlhxdWRoVXdHNDNNcFc2OFI2Z3JIMGlRVHFlVGkvYjlCZnYrd25RQUFEQS8rYkJCYjlPbVRab05PM2JzU0lKempnOGxtdWFEYXZ6citaSktIZmw1Y25KbzBOallXRkoyN3R5WkJOMWNDUDQxRHh3NGtBUWxQZm5ra3pvZmZubDlnTkZMTGE4UE1acnV5ZXRraHc0ZFNvYm51N3crZ01pSFFmbm44Y3ZrdzMrbUE0Yk85Tzk5Y0pBdnc4UERXckZpaGRhdlg1OEVCUjNQTDY4UE92THJiOXIwY3M2MGpINmUvSHo0MEtPWjFyWGZEM3hJVm12ckQzdlRuSnljVExiUmRBRG05SFA0MS9aaFZ2NjFmYmdXQUFBQUFBQ3pvanpxS2d0b1h3bWdqcUtTK3l3YWsycDBLZzhBQUlDbEswamxGQlphRkUrTkNIUERoeGY1ZFc1Q21wY0RXRHA4KzZaTUp1T0xhVzF0TlU0VTI5aG1kbVlVVEJENVVDOStRN2lCYnl4MnBEZEdvN1NScWJuSnVkTzF1OFA4WUt4dGQvOXkvUTV3aHNMcHo3dlF5TWZsVFZadDFTcTVHZnM3empoQ3p4NzVtNVJNbEE1TW5ITlBuQXBORUJpUkpZWlo1M2EyalBHZjlWWXRHV056cWpXTkN3QUFBQUJFZ0JFV2tXS3g2SyswWDY5SXI3UEczdTVxV0RyY2VLTlFWNzI5dlVtNTZPS0wxTlRVSkFBQXNIUTg4c2dqR2hnWTBGLzkxVjlwY0hEd2hQdXV2dnBxM1hycnJicisrdXUxYnQyNkUrNGJHUm5SSC83aEgrcXBwNTdTTjcvNXpXUFR2LzcxcnlmRHZyNitwTHoxclcvVmJQQkJPdnYyN1V0ZXMxYXI2VnpkZi8vOXlYTE90THl2Zi8zcmt6TFQ4cjd3d2d2Nnk3Lzh5OU11NytXWFg1NkVQNTd0OGo3d3dBUDZvei82SXozOTlOTW5oQXQ1UG1EbzVwdHZUc0tJL0R4Tkd4OGZUOEtCdnZTbEx5WEw4T0NERHg2Nzc5dmYvbll5L3N1Ly9NdDZ6V3RlazRROStmWDF1Yzk5N3RoamZHQ2xENnRzYVdsSkFvaW1RNm1POTh3enoraDk3M3Rmc3AyUDU1ZlBMK2R2L3VadkprRkYwMEZheDd2NzdydVQ3Zld4ajMzczJMUkhIMzFVMjdkdjF5Lys0aTlxOWVyVnlYUE05TG9BQUFBQUFKeXhzZjJ1N0JNQTFJMFBVUnZaSTdXc0VBQUFBTEJVNWRiZG9PNTMvTEZHdnYwbnJ2d1B4ZVVKS1k2RTJXZlNlWmxVV20wMy80cXlmVmNJQUpheTN0N2UwQmZmWnN0M0FQZkFBdzlVZkR1bmg3Ly9jRWFvcDlVK215TU13dWZkN2VIaTF1S2pidlNyeGQ4cGZseVlGOTUvMXhiZlkyRnJKUE1UYm5nOWlTbkEyVWtGUjk0MFBRMWg1L1MwMkZwVjNFOGdhMDhmWk9UL3lrY2doVWFwZEdob1BJczU1ZmE5OWJGUzcxVEIzTzFHSHhFQUFBQ0FKWThmcGxnVWlzVmlhNjFXYTB1bjA3MDJ0TTBtTWlsckxOSDZkZUlEd1AxRjQ2bDBTdGxjTnVtVkFnQUFMRDNsY2xuRHc4TW5UUE1CTjlNaE56NW81blRIQ1Q0QXg0ZnMrR01LSDZoajdROVB2Zm1RblltSkNjMldxYWtwSGVuQVJNcmxja2VPWTF6eElUcCtlSHlQVGRsczlyVGhPTDZoeXJrc3IzL05sMXJlczEzV1NxV2lhcldxeWNsSmxVcWw1UG1PNStmRHowOUhSMGNTRXVTWGFacHZkT01mMzluWm1hd1RmNThmOTBGRmZwNzgvZjU1aDRhR2ttV2REbnp5ai9QTDRaOTdPcnpJTC9mSi9OLzYrZk4vNTUvTG0xNzMvdS84My92eDZXa25hMjV1MXRqWTJMRnRjUHg4K2YzTnJ5di9IQUFBQUFBQUFBQUFBQUNBaGF0YUs2a1d1ZUtHWlhkK3VGcG9QWElOdkE4d3FsV0VXV0lDS1Foa3MwMVNKcWVwcUNJYlZ4UzQ5ZTZsVXprQmMyMjRWRlc1RnJrU0p4ZnFIOStHWnJhbGpyWUphczJsbFFrRFpWSTBQY2NQVGJkaDhtMlJmRnNzMzI3SnQzdHl4ZTJXMWx6SWZSTXZ5emNleTdtdDBGa3NGdnZkN1VtM1BVcDMzbm5ucUZBM2tZMThnOEdDVENnQXM4Vi9GNzM4OTQwaE1BejFZbzF2aE41c1ZNc0tBQUFBQUVTQUVSYUxTTzlQbWRUcU9JcmZtWXhUK1ZJM0puQW5hZ29ONnU3cDFzYU5HNU9MNHB1YW1nUUFBSmFlcjMzdGEvcktWNzZTQlB0TTh3MDVicmpoQmwxLy9mVjY2MXZmT3VQZitTQ2IyMjY3VFgvLzkzK3Z4eDU3TFBuNzQ1L2o2MS8vdWxhdVhLbWYvZG1mMVd5NC8vNzdqNFVVZFhkMzZ5ZCs0aWUwYXRVcXJWNjlXbjE5ZldwcmF6dWo1L255bDcrc2h4OStlTWJsZmRPYjNxUzN2T1V0TS82ZGY4M2psM2R3Y1BDRTBLSzc3NzQ3ZWN5WkxxOFBGL0xyNktHSEh0S0REejU0eXYxK3ZmdGwrdUFIUDNqYTUzamQ2MTZuZ3djUDZ0ZCs3ZGVTb0NJL1gwY2I0T2gvLysvL3JYdnV1VWVqbzZQSEdvbE56OStHRFJ0MDg4MDN6L2ljUHJ6b205LzhwcDU1NWhudDJiUG4ySFFmZk9TRG5YN3U1MzdPOTJDV3JMT1htaS92ai83b2o1THdJdjg4ZnVoRGpSNTk5TkZrWGZudHQySUZQZE1EQUFBQUFBQUFBQUFBd0VKVXFaWDAxSjZITkZrZTA5REVBWm5lUHBsLzlXc3E3SHBDcWFsUjVRZWVWRUNJMGF5b0ZacFZiZTNSWk44bHFyVDE2dm1Va1E1djB3cVZsVWxsdFhINU5RTG0wdkJVVlovKzUrM2F0bjlNLzdqOWdFcEhnNHd1bEJYTk9YVTJaUFgrRzllcnB6R3JXelowQzVnMjNYbmJLMS81eW96dlhNME5kZURBZ2ZqclgvdDZOREV4RWJoQ1Nrc2RtQ005NHpWWjJldXN0ZGNxMXEvWjJQNHZOL2w3ZC96SE83NTQ1Mys1YzBDb0R4T3VrNExyM1hicE5LU3BBTE1pY0crbGJNajdDZk9ZTWV2Y2QvSXZ1cjMwZTI3c1h3UUFBQUJneVNQQUNBdFNzVmowM2JxazNNbUE2NEk0YUhBL2RxOTA0NjFDWGZrZUp2ekptdVhMbDZ1dHZVMzVmUDdZeVJzQUFMQjBsRXFsSkt4bWZIdzhDZUtKb3VqWWZZVkNJUW1YYVc5dmY5bm55V2F6U1RDT0Q2ZzVQaFRJQitmNGtCNy8zR0VZSmdFNDU4TUhCdm5ReFZlLyt0WHE2T2hJUW5qODBJZjgrR0NkbCtQbm8xd3V2K1R5dmxRb3o3VHA1ZlhQY1h5QTBlSERoNVA1T05QbDlZOTc3cm5udEcvZnZoT20rMk16SDlSMDlkVlhuOUU2ODQvM2ozMysrZWVUQUtOcGZqbDljTkgwY3I3KzlhOVhaMmRuc3Q1ZUtqaklQMzcvL3YwbmJFdXZxNnNyMlIvOHVqclRZOGUxYTljbSs5anhRVWgrdWYzeisvMEZBQUFBQUFBQUFBQUFBTER3UExQM1lWV2lzcDUxdzNLMXBJbktxRXdVeTlpYU10R29BanVwYkM0bEUzTVI3MnlJc3FGcUtxa3l1VitSS2NrR2FWZU1Kc3VqU29lWnBHMUFZNjVWdlczOUNrMG9Zd0lCRjhwOXp3OXF0RnpWSTN0R05EQTY1VDRMWXNWSE85YTZVQ2Fya1E1TmxIWGZ6a0gxTmVmVjA1UjFKWmNVNEhnK2pNVzMzMnB0YlEwMlhySXg5aDNDalF5UFJJY09IUXFtcHFhTS83eTBGM2gveGN6Y2VuZGZUMmFkckl6eXFoV0x4UU51OGozbGNqbjYyTWMrTmlqTW9XQ1orMmVUZThOa0JRQllFdHozY09DK2dkTkdwdXYyUDN2OXFsSnBhTzluM3Z0UVZRQUFBQUNXTEFLTXNGQTEraElvK0tBQ2RibmJWd3AxNXk5Yzl4ZkRYL1BLYTVLTDQxTXBQbUlBQUZpS2ZFRE5nUU1Ia2pBWkh3NTBQSCtzc0huelp2WDE5YjNzODdTMnR1cmlpeTlPQXBHT0Q2clp1M2R2MHVERFA3Y1AvVG5mQUtNZE8zWWt3VUVmLy9qSGswQkdINDV6Tm56QWtHK1U0cGY1ZE12YjA5UHpzczh6dmJ6K09ZNS9uaGRmZkRFSi8vSFQvUHlkU1lEUkF3ODhrSVE4SGErcHFTbjUyMXR2dlZWbll2cXgzLy8rOS9XbEwzM3AySFMvckw3NDUvUEhmQi80d0FmT2FMMzVZS0ZubjMwMjJTK090MjdkT20zY3VGRXRMUzFKaU5HWnVPR0dHNUw5N0x2Zi9lNnhhWDc5K09jL1B2d0pBQUFBQUFBQUFBQUFBTEJ3M1B2ay8xYWxWdGJUZXg0Ni9ZUGE4c0pzY3VmWVI1NTE1Y1NwcVRDam5ZZWUwa1c5bTlYWjFDdnJ4bjJvRVhDaC9NbjNkbXE4VXRPWG50eXJ1VEkwVlUzSy8zQ3Z2YnExSUJtckxXczdDVERDS1h5QWtXL1g1TXZyWHZlNjFNR0RCMnNIOWgrSUhuNzQ0WEJnWUNBb2w4c2t2TldCOFJ0R0NsMjVYc1lWcTF1c3RSVVRtRnV6Mld6SlRTZkFhRzZ0YzF2bGpXNjRUQUNBcGNFazF5YW5aTTJhT0xaWFNVMzN1ZkZEQWdBQUFMQmtrUzZDQmFWWUxQYW9vcDY0RmwrblFHdU16Qm9kQ1ROQ0hiaktmUVVtMElvVks1S3dvdFg5cTVOaEdJWTZjajRBQUFBc1JUNVk1b1VYWHBneFNNYUg0cXhhdFVwdGJXMHYrenorc1YxZFhXcHNQUFZ3endjWStSQWRINXpqdzRmT2h3L1A2ZTN0VFY3TDk1UjF0bnh3enNEQWdNcmw4aW4zVFMrdkQrZDVPZFBMbTgrZjJ0aHllbm45TVZaSFI4ZU1meC9Ic2NiR3hwSkFKUjhTNUlPZmp1Y0RoazczdHpQeDRVUit2djM2dmZ6eXk0K0ZVazN6QVViKzJPOU0xNXNQTVBMN2hkOC9qdWVYMTcvTzJSdy8rdGM4T1N4emVyK2JhVHNBQUFBQUFBQUFBQUFBQU9hdjV3OCtxVnBVMGY2UjNZcmltbEIvY1J6cDhQaCs3UnZhcVdmMy9VRGRMU3RkV1NWZ3RoMmVyS2dTeFhwazcwZ3lySmVSVWxYMzdEaVVoQmR0N20xVklSTXFFNUpKZzVrMUZCcUNydTR1WFhIbEZVSC9tbjd6M1Bibm9tcTFhbDhjZU5HSDZjakswcEMrRHF5MWVXTk14a2IyWFc2MFZQeHc4VEszTVhaTlZhY2V5dWZ6NVdLeFdCSm0zYTJmdWlHL3JDM2JZbTNRYVl4dE1WWXA4UTU0V2RhNjR5MjNnOGF4M0ZHWElyZi9sbU9yV2kyeWdVMGVZVTc5VWpUdVAydE5LalJ4a3Q0Vm1MeGIzMkVxVk1xUEIxekRBNkJlak8xMS8yNlVVdDhYQUFBQWdDV05BQ01zTEJYMUtOUm1WKzMyVTI3c1dsZWFYT0hzVUoyRVFaaGMyTDU2OWVya2duc2ZZQVFBQU9DRFpIYnQycVh4OGZGVDdrdU9HZHl4UXpxZGZ0bm44WS8xNFRrK3BPaGtQcXpuNUNDY2MrVURqUHI2K3M0NUNNa0hCdm5sUFRrd3lKdGUzbXcyKzdMUE03Mjhmbml5NmVXZDZiNlRIek0wTkpTRURaM01CeGo1ZVRsVHh3Y1lYWEhGRlhyMDBVZFBDVER5d1VWbnV0NThnSkZmVHljSERQbWV5ZnpyK0JETU0rVmYwOC9mOGZ5eSt6TFRkZ0FBQUFBQUFBQUFBQUFBekY4dkhIeFNVNVZ4SFJqWkxjd1BzVDBTWUpSSlpiVjkzdytVRGpNRUdPR0NPRHhWMFhnbDBnLzJ6azQ3b0hNMVhLcnEzdWNQYWZQeWx1UjJLakFFR09HMENnMkZ3SmRseTVZbDQzRWNSMU5UVS9iRlBTK0dxbDhPMTVKbmpFbDZEclE2RW1Ea3hpOVZvRytuYk9vNXQzMkcvVFJoMXZVMUsyK1Y3b21ON2JCU0srRkZaOHE2NHkycGFtM2t2Z1o5Y05GRVpGV2FyTm5RV3I4V2JlM1V2N0R1MjhrRXVkQkdZV0JzSnFWVWFOekV3QndOTUJJQTFJbEpBb3d5bVZwQkFBQUFBSlkwQW93dzM1bGlzZWl2V04vb0t2UGZhcTI5eEZYRmJRb1VySENWYjc2Q21UTkRkWkRQNTVPeWN1VktkWFIycUtlbjU1UUx5QUVBd05MbGc0dDgwSTA3NlgvS2ZmNll3UWNTbmNteGd3L3I2ZXJxbWpIQUtJb2k3ZGl4SXprTzhlRTY1OE9IRjUxTnNNL0pSa2RIaytXdFZDcW4zSGN1eSt1UHMwNDJ2YnpleFJkZlBPUGZWNnRWM1gvLy9kcStmZnVNOTY5YnQwNlhYSEtKenBhZkx4OStOREF3Y01MMDZYRy83RDdJcUsydDdiVFBNVGs1ZVd5LzhFRkx4L05CU0g2NVU2blorWG02ZCsvZVpGMzU3ZXJuQ3dBQUFBQUFBQUFBQUFBd3Z6MjE1MEVOalI4UTVwL1JxU0Z0ZS9GQmRUWXQxeVVyWGlsZ3RqMjJiMFF2anN5ZlRKSERrMVZ0SHh4WE9teFNZNVpMTFhCbUxyLzg4bVJuOGUyVmhvZUg5ZWdQSHEyV3kyWGpick1UMVUvS3lsNXBZN3M4RE1MWHByUHBSN1p1M2ZxRFVxbjBmLzdMZi9rdmU0UlpVd3NLUFViMkZtdnRlc0tMWGxvMXNvcGw0NkdwZU5pNmZiUWNxZG50cHlsclRSREhjWnVWOGEwcmo2eEZkOGNNVDJGa3JLTFkzMmNWVmszYXJYdmorRCtxcFVNemtRMU5LcGN5cVhTb1ZDWXdaOTZySkFDY0QyUFh1WStuM2pnMExRSUFBQUN3cEZFaGlubXRXQ3o2eXJlVWF1cFJvTXRjcmRvR043NXg1cm80ekpVd0RKWE5acE9MMUgzUEVmNmlkZ0tNQUFEQU5CKzJVeTZYVHdtcThmeUowak1OcXZISEhQNDRZNmJIKzllWW1KaVlNU1RwYlBtQUlmODY1OG9IQjgzbThzNTBYRFc5dkRPRkpFMnIxV29hSEJ4TUFwVm00cGV6dGJWVlo4dlBsLy9iZERwOXduUS9QNTVmOXBmajUyMTZQWjNNaHd5ZHovby9tZDhucHVjTkFBQUFBQUFBQUFBQUFERC9EVThjMHZEa0lXSCtLVmNuWlcyc2N1MzgyMmNBTXhrcDFYUm9zcUw1b2hMRkdxOUVpbUxhcXVQTXRiVzFKUTIrZkZ1eGJEWWI1M0k1VzZ2VmlIS3BreVROUmZLTjNYeGp1UlkzdXNiS1JtNDRsc2xrc3NMc0NteWpySHBrMUNpOEpOL0N0QlliTzFWVE5iYlcvWk5NZHZ1ckRkM2d6TUtHM05kVGRQUm1GTmtmVG5ULzFHSlYvZDRmeGdyU2dlR0xETURjc1Vsd1VTRzBjVm9BQUFBQWxqUUNqREJ2M1hISEhkZTdRVmNjeC85WmdacU5USWNyYWNLTDZxZXhzVkdyVjY5V1QwK1B1bnU2azR2WS9RWHRoQmNCQUlEamJkeTRNVGx1ZU8xclgzdEtrRXhMeTVsM3JPQ1BOWnFibTVQZ3hBdXBxNnRMM2QzZE9sZFhYMzIxVnE1Y3FkZTg1alduQkNxZHkvS2VIQlIwcG54STBKNDllNUlRbzVuNDQ3Z05HemJvYlBud0lyOU5IM25ra1Judi8rNTN2NXVzdjVkYWh6dDI3TkRBd0lEbWd0L25mSWlUdGZ4dUFBQUFBQUFBQUFBQUFJQ0ZvRndycVZTZEZPWWYzNW1UM3paUlZCT3dGQnljS0d2Yi9sR3RheThJT0Z1KzdaY3JRVTlQVDlxM1lUcDQ0S0MrLy9EMzdZc0RMOXBLdFdKc2JBazFxZ05yYldpTXVkYXQveXVESUxqMWpxMTNURmpaMzBxbFVydTJidDM2bUhCZWpBbDZZK21OYmdmdlRMSjRjSXJKbWkzWFl0bkJpU2diV1lXUmJLZG1YN29TeCsxUlNScHpPM3c2TUJOaG9FcG5QbWdOQXhOa1E3WU5nQXZIZmEvbWpWWE94cWtiM3ZmWk54UisvNTFmKzBjQkFBQUFXSklJTU1LOFV5d1cyNC9lN0hlbHk5V2RyWFNWeHY0cTdqemhSWE52T3B3b2w4c2xwYW1wS2JtSXZWRGd4QndBQUF1UmIxam1WU3JuMW5PWkR5OTh1UUJEZjh6UTJ0cWFERTkrSFI5c2RLWjhrSThQTC9LdmR5R2xVcW56ZW8zcDVjMWtNa21JMFBIT1pYbjkvSnlyVXFta2FyVjZ3clFqSFVvZDJYWitIcytXbng5Ly9IZTZZQ1VmMnVSZjk2WDQvZUJjOTdtWitQWGsxL3RNZkhEUjlINE9BQUFBQUFBQUFBQUFBSmovckkzcHBHYWVTdHJ0MnFORFlBbUlZcXRLRkN2aU13bm5ZTHBOWFdOam8vRzNmVHV1dHRZMlRZeFBhR3hzekxkcHNxVlNpUlNST1dTbUc4OUpPWGZUTnpqemplQnFidnVzcnRWcVFiRllQT2lPUVNidnZmZmV5UzFidHNSdW5JWm5aMkZMY1V0S3NjMjdtODN1SFpBVnh3c25zUDRJMTYyU2FteE5MYmEyNnRzMkhsbEZGNlJSckpFSjRpTXZMUDlhVVdUY2Q1cmkwRnFURHBJSEtKRGhNd2pBckRQK3M4VWtLWGJOeHNidEFnQUFBTEJrRVdDRWVjZEc5bWRjNWZCNlYxbjNhOVBUREVuc2RkUGMwcHlFRlYxMzNYWEp4ZXN0TFMwQ0FBQUwxL2o0dU1ybHNwNTY2aW1kaTVVclY2cXRyUzBKdERsZDBFNW5aMmRTenRmUkhxbG01Ymt1cE9YTGx5ZmxmRTB2cnkvbndvY243ZG16UjhQRHd5ZE05MEUvUHJqb1hJT1IvTjl2M0xqeHROdkJONjd4SVpkejZkcHJyOVh1M2JzRkFBQUFBQUFBQUFBQUFBQUFBUE9OYjMvdlMxOWZuNzhRd2p6MjZHUFI2T2lvL2NZM3ZwRUVsOFJ4ekFVUzlaSDA0bXhqK3dkR3BxUlkvMktNZWZMR0cyLzgrTlRVbEc5NE55S2NrV0p4UzJwNHRmb2lFNjB3Tmx4QmVOR3BLcEd0dVZJOVBHbXo1Y2llZmUrVDV5R08xUmk3YmJKdklwb3lWcFh1cHRDa0F4TTBwSlVWQUZ3d2RxUDd4emNxLzd3QUFBQUFMRWtFR0tIdWJyMzExdkRTU3kvMXFlditpdWhPVnhtLzF0V1RyU0N6cUw3OGhlcGhHQ2E5UGpRMEhna29PTmVMM2dFQXdQeFJLcFUwTVRHaGJkdTI2Vno0bnFIUzZYUnlyTUN4d2NMZ3c0c2FHeHVUWTd0NjhiMkorZUNzbWZqNXltYXpNclBVc2MvMGEwVlJKQUFBQUFBQUFBQUFBQUFBQUFDb3Q2TWR4Sm5WcTFjbjQvdjI3WXVqS0RLVlNvV3JKdXJJeXJZbzF2SjBPbjFkRUFUN1AvU2hEKzByRkFxSGZ1dTNmbXRRZUZrbVZxY0p3aGFpaTA1a2ovNFR4Vkk1c200WHF4LzNBUk80ZjZ5YkQrTm15ZVR0a2FrQm56d0FMZ0JqMUJoYnRRb0FBQURBa3NVVng2aTdTeSs5dE1VTlZybGF1WGU3NFUxR1pwMnJEMnNVNnFxM3QxY05EUTI2N0xMTGxNMWxrNkFDQUFDdzhPM2N1Vk1EQXdQNjZFYy9xblB4eTcvOHkzcjFxMStkSENmNDBCbk1mOTNkM1VueG9WUDFjdkRnUVEwT3p0eW1vN1cxVlQwOVBVazQxbXdZR2hyUy92MzdaUzNOSWdBQUFBQUFBQUFBQUFBQUFBRFVYLythL3FUM3VZc3V2a2lUazVQMkszLy9sYkliQmkrKytDS044T3JITjZqYmJHVTMyOGorcThBRUR4dGpIcDZhbXJyTFRmOW40U1VOcnA4cXFOcHdrNVZaWjBSYnZSTzQxZUZEaXlhcTFoeWVza0VzYTB5ZGVuaDNzNUo4eGd4TnhjcUZSdmt3Vkdpc2dwQUVJd0N6ejFxdGQ1OHV2UUlBQUFDd1pCRmdoTHE1NDQ0N21sWFRKa1ZhYndON282dVB1OHJWam5XN3V6TENuSE9WN2NsRjQvNEM4cGFXRnZYMTlhbFFLQ2lUemN6YXhlUUFBQUJuSTRvaVZhdlZaTGdVVEM5dkhOZXp2NTBMbzFLcHFGd3V6M2hmUHA5UGpqOW42NWpUdjFhcFZDTEFDQUFBQUFBQUFBQUFBQUFBQU1DOGtrcWxWTWdYZE1XVlY2U21wcWJNc21YTGRPalFJWHZnNEFGYnE5Wk1ITWVraXN3eGZ4MkZiMnZtU3EvUG1BbUNvTHAxNjlhYjNQRCtLSW9HZitkM2Z1Y0o0UlNwVW11cUdsYjZqWWs3WmRsdGoxZXppaXFScmRRaUcxcTNxb3hWdmZLTFRoQlpHNDlXNGtvdVZCZ0dZZHJ0K3ZOaHRnQXNMdTJ1Tkw3enJpMjVwckc4L2YzYnYxSVdBQUFBZ0NXRkFDUFV6NVNhbGRYMXJxcjNsYkw2R2FHdWZNVjdHSVpxYjI5WGYzKy91bnU2bGN2bEJBQUFVQzgrME1lSDN0UnFOUzBGaTNsNWZhaVFMek9aRGpDYXpkZnk2M0V4QmtFQkFBQUFBQUFBQUFBQUFBQUFXTGg4Z0pFcjV2TExMMC83VHRxNnVycTBiZHMyT3pJNkVzZFJITkxtcVQ2TXY1aEM2azJLMVVZalUzSGI0bE51OGpOdUdnRkdNNWpLMkZRNkN2cXRWU2NoT0NkeWIrTmFxV1pMVlN0L1FVNUdabjZzb1dxc2VLUVVsK09zU1Rka2xIYjcrbnlaTlFDTGh3OHdVcXVVaTlvUCs0TWFBb3dBQUFDQUpZWUFJOHlwVDMzcVUvblIwVkdqU0xkYjJRNFp2VnBIZjV5aVBreGcxTnpVbkFRWDlmWDFxYm1sV1UxTlRjbkpFUUFBc1BqNDczd2ZsUFBtTjcvNXRJOFpHaHBLd2w4ZWVPQUJ6YlhCd2NFa2dPYWhoeDdTM3IxNzljd3p6K2p4eHgvWFl1V1g5L0RodzNyNjZhZVBMZS9ERHorc2MrSERLRmVzV0hIS2NkeisvZnMxUER5Y2hQcWNpd3Nkck9TWC9SdmYrSWJPMXNHREJ3VUFBQUFBQUFBQUFBQUFBQUFBQzFFbWsxRm5aNmV1dlBKS3MyclZxdkRBZ1FQeDZNaW8zYlp0VzFpcjFReGhSbldUMFpGcnJkNHVxOEU3N3Joams5c1dFMjZiL0k5cXRWcjY1Q2MvT1NFb1ZiVXBFOWlOa21rU1RoQlpSVk8xdUZ5TmJWcnppVlhvUGxYeTFValJaTTFPNUFKbGc5Qnc0UkNBV1ZjT2dsVm1xcW5xYm80S0FBQUF3SkpDUlFQbTFNaklTTm9ZRThqb0ZqZmE0c3Btb2E0Q3R6a0toVUlTWnJCbTdacmt3bmRmQUFEQTR1Uy85OXZhMm5URkZWZWM5akY3OXV4SndtcnFFV0EwTVRHaDhmRnhQZmJZWTNydXVlZVNlZkE5VFMxV2ZubDl1TkR4eXpzNU9hbHo0WS9oL0RIZDFOVFVDZFBkTVhneVBOZjFhSzFWdFZwTmdvd3VoQmRmZkRFSk1UcGIwOHNGQUFBQUFBQUFBQUFBQUFBQUFBdE5FQVJxYkd6MHhmaU82M2J1M0drSEJ3ZmpaN2MvRzE2b3RsbzRJOGwxVmtibU12ZVBEMzFwQ1JRY2NOdnJmNlhUU1I0TkFVWk9rTElwRzVzZWQzTitoZlRNQTdHTlZJa1V4VmJ6SzRYTTdkUld5dFNzeXBXYUxXWFNnZC9YdWE0UXdLd0w0NkRkcExSNEx3QUFBQUFBY0ZwVU5HQk9mT1FqSDduY1ZhTDNXbXQveTVWT1YrKzFUcWliVkNvbFk0d3V1K3l5cE9lR2Rldlh5VmVtKytrQUFHQng2K3JxU3NyeTVjdFArNWlISDM0NENidjUzT2MrcHd0dGFHZ29DZHo1eWxlK29rT0hEdWx2L3Vadmt1ayt4S2lwcVVrYk4yN1V3TUJBRW5LekdFd3Y3OTEzMzYyeHNiRVpsM2Y3OXUwYUhCelUyZklOV3Z4ejVQUDVHZS8zd1Vpam82TnFibTdXMmZEejl0UlRUK25nd1lNejNyOWh3d2ExdExUb1hIMzk2MS9YZmZmZHA5bXliTm15WlAvbTJCWUFBQUFBQUFBQUFBQUFBQURBUXJGeTVjcHcrZkxsb1JzYTMrbmNQZCs2cHpRK1BoN3MzcjA3STlUVEpobHRDb1B3MjZFSlg3emp3M2M4YWtMemQ4Vmk4Y3Rhb3Y3RG45NjhLYXJWbGtjbWFMSkd4aVJKVDVnV3hjcFZZdHZ0M3NmQmZGdzN0Y2lha1hKa01pbHJzcUx6Y3dBWHhQVldadGdONTc0M1pRQUFBQUIxeFJXZG1CTnhIS2VOTVFWWEFkZm5SanRkeVFsMTVRT01zcmxzRWx4VUtCUUVBQUNXaHVsUWw1Y0tzZkVCT0Q0TVp5NjQ0MFRWYWpWTlRFd2s0VDU3OSs0OVlUNTgyR0lZTHA0VHBOUEw2NWZWQnhqTjl2TDY3WGE2YmVjYnRmaHlMcXJWYWpMdk0vSHo3TXU1S3BmTFNaa3RmdmtKTHdJQUFBQUFBQUFBQUFBQUFBQ3drSVJoYUh6Yk1kK1puRy9ubGNsa2JEcWRQcmNHWDVoTjA0M2orbVRrRzlIdGkrTzRRVXRZWklKTTdJb1VCMFFYemNRRXNwcVg0VVZlN0Q5Vllobkxwd3VBQ3lTUWNsYVdhMGNCQUFDQUpZaXJPbkZCRkl0RnYyODFxcVl0N2xmbkZodmJON2p4VFNTcjExZERRME1TV25UbGxWZXF0YlZWSFIwZEFnQUFtRXZUWVVYUFBmZWNIbmpnQVgzNXkxL1dZNDg5ZHV4KzMvaWlxYWxKUC8velA2OE5HemJvNXB0djFxYys5U245N3UvK3JoYWk2ZVY5OU5GSGsrV2NhWGxYckZpaG4vaUpuemkydkIvNHdBZjBoUzk4UVdjcm04M3FWYTk2VmZLY2YvbVhmM25LL1g0ZVNxV1MzdktXdCtocytQbjM4N3gvLy80WjcvZXZlVDUrK1pkL1dhOSs5YXMxVzlhdVhhdkd4a2JsY3B6M0FnQUFBQUFBQUFBQUFJQ0ZZT1B5cXpWV0d0Wmp1NzRqekM5TitUWjF0NnhVZTJPM0FBQnp3N2NEOC83MVQvN3JmS1ZTMGVIRGg3WHorWjN4Z3c4K1dCc2ZIMCtWeStXNTZaMFFKekMrQjJscDlkSHk1cTFidDk0Vm1PQy8yOWcrcjBCL2V1ZWRkNDVxaVlnVWJiWlduVWRXQ2FiNVFLQnlaRldOTmErNTJjeTQyY3hVSTdsNXRRcmRaZ3pZbGdCbWtWVzh4WDF6N2hNQUFBQ0FKWWNBSTh5NllySG9FK2FiWGVtU1VhY3JUY2FhckJYeDNQVVNCSUh2a1VHNWZFNzVmRDRaOXdVQUFHQXUrZkFjSDRZek9EaVlOS29ZSGg1V3VWeE83a3VuMDhtd3M3TlR6YzNOU1lqUmRFT01oZXI0NWZYbGRNdmIxdFkyYTh2cm45ZVhWQ3FsS0lxU25yaW1UVTFOYVhKeVVtZXJXcTBteStHSHh5c1VDcG9OL2poMU5yZTFQODZsWVFRQUFBQUFBQUFBQUFBQUxCejViSk1pR3gwNzEzdjh1VzdVajk4ZW1WUk9CYmQ5MHVIQ2JzTUJBQXVWL3l6MjdhdjhOUUROemMzR2YwY0dRV0JMcFZMeXBjbDNabjBZdDJYOFB6YTI3VzUwT0l6Q0ZYZjh4enVhNy8zdXZmdTJiTmtTRjR2RmVSNWhjMzVpWXpLQmxCRk9zYURla3Zib1p3anRMWUdYZE9SOWJZKzhaWkozanJISm0rZE0zdThudmIzODE3cWY1cDdCSFAwMldaVGMyc201WmN1NTc4UGdqanVLMXQzbWdBVUFBQUJZSWdnd3dxdzZHbDYwU1pFdXM4WisxUDJXYm5FL01WdUZ1bXBwYWRHS0ZTdTBidDA2TGV0YUpnQUFnSHA0OE1FSHRXUEhEbjNtTTU4NUZ1d3pyYSt2VDQyTmpmckVKejZSQlBCczNMaFJDNWtQTHpwK2VVZEdScEl5YmUzYXRjcGtNc255TmpRMEpPUG55eitmWDI4K3BHajU4dVduck9NZi9PQUhHaGdZME52Zi9uYWREUjgyZGZmZGQ1OHcvOTcxMTE4L0t5RkdmdG12dmZaYUFRQUFBQUFBQUFBQUFBQ1dwdGRzZkt0aUcrblJGKzZUdGJGSzFTbWh2bnhnUmk1ZDBPck9EWHJENWY5V1RmazJBUURtbm05THQyelpNbCtDS3pkZkdlemN1Yk0yT0RnWWYrOTczd3VIRGcrWlVxbEVyOGIxa1pKMXhlam4vRWhrb2w4d09UTnc0NDAzL215bFVpbTVTZnUxaUlWV20yUk5zelhrVVp6TXI1R0ZFbUpVZGZOWmpxVEFIQ2tBWnVhVGlpcnV2VktMVlNsSGRySVcyVXBzYmEzc2ZzVEdMeE5qNU80T2ZVeFJQcVVvWlV5UVRwa085MzRMTW9ISmh1NHpOQjB1emplZit6MTVuUnZzR2w1OVQvTjdQL09XaXZUbHMrK0JGd0FBQU1DQ1JJQVJaazJ4V053WVJWR0grNUg1T2hPWUxtTk5nL3VoVGFwNm5hUlNLZVZ5T2JXMHRxaWx1U1U1Y1pITjBRTU9BQUNZZTd0Mzc1WTdLYTk3NzcxWFEwTkRTYkNPRC9qeE9qbzZrdDZoZnVSSGZrU3RyYTFxYTJ0TGVveGF5UHp5K3RDZjQ1ZlhMNzgzdmJ3MzNIQkRFbHprbDljSEQ4Mm01dVptYmRpd1FmdjI3VHNod01pUFQwMU42Ym5ubmt0ZWMrWEtsUy81UE9WeVdjOC8vN3gyN2RwMXdqSk04NkZUZnBzQkFBQUFBQUFBQUFBQUFQQlM0ampXNU9TRXJMV0thdEVwOTA5V3BwTGdvbFV0bHlxS3F6b3dzVnUxcUtKU2RVS3grMC9pNHZpNUVPaEllNDNHWEp0U1FVYkxHdnJVa2UxVFpiS215ZHFrNHRLcEY5ZjZ6cXFDSUZDd3dOdDZBTUJDMGR6YzdEK01nNHN2dmxoalkyUGF2V3QzNVBqMmFud1ExNWUvZHFiWGZTZitWQmlHNDhWaWNaZWJ0dDBOdDJ0Uk11M1d4QTF1S0N4Yzd0QzhWSXR0emQwc3VHMUpHQnFnSXdGa1BwUEl2VGVxUHB5b0VzdTZuN05oTFZZcXRqWnc0eGszS2ZBSnZIRmtyUHYvcFgrc0dzZGFVNDFNWEhOL1Y3VTJETjJreXBIZ01Cc0dOa29aUmU3ak5NNkV5Z1h1UG5lL0ZvbU1XMi9ydzlUVVlYZDdod0FBQUFBc0NRUVlZZGJZeU40U21yRGYvVDcvTlIzOXdZNzZtUTR2MnJ4NWMzS1JQQmVYQXdDQWVubm9vWWVTQUp3Ly91TS9QdVUrSDRMamczVCt6Yi81TjFxN2RxMWFXbHEwMFBubEhSZ1llTW5sL2FWZitxVWt2T2hDTEc5VFU1TnV2dm5tWkQ0ZWUreXhZOU45R0pIM3dBTVBKT0ZKTHhkZzVBT0x2dm5OYitxRkYxNDRJUWhwMnRWWFg1MkVaQUlBQUFBQUFBQUFBQUFBOEZKOGdOSGdvVVB5QVF2VEhSN041SnJlVzFTSnB2VG8vbnMxWGg3U3dYaTNvcmltS0xtdUdoZGFFSVFLVEtEZXhyWEtoSGxkMGYwYXBZS3Nwa2FxbXRLd2U4VHdLWC9UMzc4bUNUREs1Zk1DQUZ4NDdlM3RvU3Rhdm54NTh2MTY3NzMzbHQxM3F5SEFxTzQ2ZlRFeW40eWplTmg5bno0cXE4KzZhWXN5d01ncVhtV2xIUEZGQzFzMXR1TkJaQ1ppYS95MWhUa0JVT1N2aG5RZmNHTVZPK1VEaklhbVlqZFF5cFVtZDNmNmFEbktua0hXN3BFSDFPS2pENno5Y0ZyeWN1NnRtRTJacVhSZ3FpMVpFNllEOTFOczhWenRtekZCY0ZQSzJHMGl3QWdBQUFCWU1nZ3d3amtyRm91K2dzcVhtOXhQNWs3M3UveG1WenFGdXZJWHJQdVR3YjVYaFZ3K2wvUnVrMDZuQlFBQU1OZDI3OTZ0b2FFaGZldGIzOUxvNk9nSjkvbndIaC9tczJYTEZtM2N1RkU5UFQzS1pyTmF5SjU3N3Jra3FNa3Y3NEVEQjA2NHI3dTdXMTFkWGNlVzE0ZExYcWpsOWVGRWwxOSt1VVpHUnBMWDlPdisrQWFnMy83MnQ1Tmp4QlVyVmh6YkRxbFVLaW5qNCtOSmc5RWRPM2I0WHJtU3gvcm5PWjUvdlArNy92NStkWFIwQ0FBQUFBQUF6SjZxakNyR2FDZ01WWExERVRlc3VxRnZ5enBwQWtXTHA4Zk5DOGJJeWwrcGs3VlcyZGdxNzRacEc2c25xaWwwdDV2aldJdkpsTnNuUm9OUUk2NlVBcU95RzQvZFdqZ2NjcjNTMldodyswV3l6N2g5eFhjejNWMnJ1ZjNHcWoyT0JBQUFBT0Q4K1E1MGZ2REk5MVV1bDVNZ285TXBSMU5KWU5IK2lZT3FSQ1ZOVmdMM0d5Y2xhd1Bod2d0TTZINVJHdTNLSDFSbzBwcHN2TjhOUTZXQ3pHbi9wdld0UDZsTUprdUFFUURNc2REVi8vbHJCdGF2WHgvV1hGMVcxbjBXRHc4UDI5MjdkOGZ1ZXplb1ZxdFVKdGRQM3NxdU5zYjgrTmF0VzFjR2NmQ0V0WFpQUjNmSHc3ZmZmbnRaaTBPUFRnanh3QUpsckQvUTV0TUNTNWlQRXZLQlJkWFlWcXVScXVVb3p0VGNqOUJ5WlAxcEkzZldTTmFkZWd0ZVBxam9IRjdiMnRCOVY5Z290bmwzU2pNelduWmY3OGFxa0RIamdidWprRElOL3RUd0FuNkxadDNjWCsrV2RMRjg5d0VBQUFBNEF3UVk0WHo0OEtKV2QzYjRMZTdYOEVaMyt6cVJ1bDEzemMzTnljWG5sMnk2SkRrcDRXOERBQURVdzhEQVFCS0U0d045ZkpEUjhYd0F6aFZYWEtIWHZ2YTF1dnJxcTdVWStHWDF3VVV6TGE4UEVwcXI1ZlhoUlA2MTl1L2Zud1FuK1lhZ3h3Y1kzWGZmZlVubzVkcTFhNU95Yk5teVpMby9idlFCVEw3QjZBOSs4QVB0M2JzM2VlekpmSURSdW5YcnRHYk5tbVE3QWdBQUFBQ0EyVk16UnBQdS9NNkw2YlNHZ2xDNzNYRENUU3U3YVFmRFVCWERCWnN2Si9BaE5MSnFpdUlrcktndGl0UmdZMlZMVTBsQXpXSUxNQ3E1ZldLL3E5ZlpuVW9ud1ZjK3pNanZSOXN6R2VITWRkVnF5YjdSNnZZWDN3cjlDcFgrLyt6OUNad2sxMkhmZWY3Zmk4aklvN0xPcnI0YjNZMGJCSGlBNEFWS0lBV0RwRVJ6WkpPelkvblF5aDlSc2orVXpURjM1Vmw5TE5xaXhJSkdIbzkyWm1XdHJablJhR1JSL3F5cFdkdVNMZHRjbVNKcENCSkI4U1pCUUxpUFB0Qm5kVlhYbFZWNXhQSDJ2U2dVMUFDNmdUN3F5S3I2ZmJ0ZlJkNFpWOGJ4SXQ0L3lsQWpBb3dBQUFDQTFkSHIrZVBRRDMrM1BDWjkvTmpSSzNobjlHTEJlbHJRY3NqVVVaMSszZGUrOTk3NzFCZ1kwUGlMNXg0QUFOWkg5R0tBK1kwMzNoZ1h2aDRybkNkMjVNZ1JkLzc4K2JJQ05FMVRWcUFid0pqeUtnU2hUYzFoSjNmUXlQeWxRc1cvTnRaOGEzcDYrbkgvK0JZSmNUQjdiS2lPRnpZemY4akVIMUl4b1VxY0NDTnNYMjQ1eEtpWEtWM3NGVXVMV1dIVG9teHYrOUpWYXQwYUxleGVYR2RVc2lJRXdqbWwrZklYWmM0dXh0WkY5VGdhQ0QyM2FhOXZFdzdaR3QydHdwd1FBQUFBZ0cyRFpCTmNzWW1KaVQzS2RLZXY2UDQrZi9mNy9BN2xMWDZmZVZDRUYyMklFRklVeXQ2OWV6VTZOcXJEaHcrWGpjOURNVnlGRndBQWJJQVEzaFBLSC96QkgraFAvdVJQWGhibVU2dlZ5dTJXdSsrK1d4LzcyTWUwYjk4K2JYWlRVMU9hbjUvWDcvN3U3K3JKSjUrODZQQysvLzN2MTBjKzhwRjFIZDRRTWhURzhiLy85LzllWC8vNjE4c1FvenpQMVdxMXdna3ErdXhuUDZ1QmdZRXk4Q2hzVDRadHgvQjRPS0ZsZW5yNlphRkh3Y2pJU0JsWTlMNzN2VS9mOTMzZnArSGhZUUVBQUFBQWdOVVJ3bWQ2ZnQvOEN3Tk5wY1pxM3UrcnAvNStlQ3ozaDN0Q2k1T1U4OGN2U3hFQ241eVVSWkVXL0hpYzlNZk1RcWpSYzVYbGkwRy9xOTNXWUpIcjltNVhJUTZxb3MzWHhDS0VXYzNaU04rcjFqVVhMUWNZdGNPOG9qQy9tRTA0UkJ0dnpzOHJZWDQ1KzJMRHJ4QWVWdlB6elo0czFlNHMwNXU2SFRWOXZWbmRNWFlCQUFBQUFBRFFYOEo1WCtFY3NCdHV1TUhzM3IwN21wcWFLcWFucG51UFAvNTRORGMzWjlJMDlWV2sxR3V0TnovT1E2VitaS3o1QWQ5OWwzSG0zazkvK3RONUZFVVRSVkVzVGt4TVBLOU41dS8vNWcrTmRhTnVZcHdHL05CeDBHS1R5NTJLYnVIeVFoeFd3UFlUWnZvUUdOUXJsTTkyOG5hV3V5aDFHaTV5RjI5MFlsQTdMVWF0NzRXc2NLMWFaT0tocXZVZHYwS3htMnl4YTV4MU1ydjk2SHpYMy92TSt6L3BEOE05OU05Ky9Fc1BDUUFBQU1DV1JvQVJybHhIVFZXMHg5KzZ4WmUzK3dydkFURXZiWmh3d0NFME9BOEhIVUtqOHJHeHNUSzhDQUFBWUtQMGVyM3lxb2tuVHB6UTg4Ky8vQmg3dVBKVDJHNEpWM3k2NFlZYnRCVzAyKzF5ZUY5NDRZVytHdDRRTmhSQ2pFSkkwWVhiaHlIRWFHbHBTY2VQSDllVlNKS2tISllRd25UbzBDRUJBQUFBQUlEVnMraVA5WVN3b3FOKy96djM5M3ZHQ2xjdmhCaVZvVSsrMjM3eHNkbVZLNUtIQU9kOCtUVm1remJhQ2ZOSHk4OHpKeXVWTXV4cWttT0QxNnhyWC82YlcxQ2t4QlhsNzdMaWxzZDVZZHphWFdZWEFBQUFBQUFBdUVxaFBVRTRQMng0ZU5pRVVxbFVpc2hHN3Rsbm4zWFdicmEwZzYzRC9QblZxQSs4MkIyV1UxNFV4YkMxbS9NWVFBZ3ZTcVJhYm1nL3RCVVVaYktaci9pbTJodmJrUXUvQVNuTG5XdW5MdmUzWXhldWUySTJmcldaT3lXK2Y0b2lkVzIvRnJlaFB6Zm4ydHlFM3E3NWhVeG9nM3BiVWVoSkFRQUFBTmp5cURUQ1pmbjBwejg5NU90UHgxWG9rLzd1UWIveitEWXJXL2ZkZWtpR04zMndnNzdkVkt0VkRRME42Y0NCQTlwL1lIL1pNTDFXcXhGZUJBREFGaEhXN2VIWTRNVzJzOUkwMWZ6OGZObGRDeUdNSndUY1hLMUhIbmxFWC96aUYzWGt5SkZYUFhmTExiZm8vdnZ2MS9qNHVMYUtyM3psSy9yT2Q3Nmo2ZW5wVnoyM01yeDc5dXpSZWd2YmlyZmVlcXZ1dlBQT01tVHBtOS84cHVibTVuU2xRbURSZmZmZHA3dnV1a3R2ZmV0YnRXUEhEZzBPRG1xem5rUUJBQUFBQUVBL09SWlhOQk5GK29QbW9CWnRwQTRYTEY1elg2dlZWZlgxYms5VWE3cXgxOVY3ZlYxWXhUOGViWUl6OU0vNWVTWDM4OGh2ajR5V1FWZXpmcDRwaExVU1Fvdk9SRWF6VmF1bi9MSFpIMWhzNmFaZVR6dUtYQldDakFBQUFBQUFBTkNuZG96dGlJYUhoNlByYjdpK1BNZndHMS8vUm05MmJsYVAvOW5qb1NyVTE0UTZLcUkzUU9HS3NlVWIrdGRabnMxTi9NTEVJMzVpZkNjdDBzOHVMUzJkLzZmLzlKKzIxZWNpcXplbVJUVE9tWU1BTnJOVzZycTkzT244VWxIMWQrUE11VUhqL0FHNFBtb2JHVEtMUW44dDlreXZsK2ZuaHhOYkg2cVpla2dFMm13cmNTdHowRG0zeHcvVG5rLzg5dnZlbkxiZHYvajF2L3ZBU1FFQUFBRFlra2c2d1d1YW1KaW92WGp6Z0ZLTkYxRngyTXFHMXRmakt6SGJoQmV0dnlpS1ZLdlhORGcwcUdheldSYkNpd0FBMkZxU0pDa0RDeThtei9QeXhJTFFYUXU5WHUrYXdwRmFyWmJPbmoxYmRpL1VhRFRLWWRxOWU3ZnE5YnEyaXBYaDdYYTdMM3Y4d3VFTmdWVHJMY3V5c3A5Q3R5aUtzaDg2blU2NDBsYjUvQ3Y3OTBJcjRVUmhPdTNjdVZQWFhYZWQ5dTdkcTEyN2RwV1BYV2w0VWFWU0tjdkZoSDRMODF5WTU2OVVDUEo2cFREZUE3YU5BUUFBQUFEOXJKQlI0USt4dFd5azgxR3NCZDlkSkN4NFhYVDhlTTVkb2ZPS05PN0hlOHNmZDJ2NCtvbEdId2ZTdkhoVXRnd3N5djJ4MmJrd0RQNlJqT08wYXk2TTczS2U4Vk1oalA4UU9EWlM1SXJEZWV4Y2xob0FBQUFBQUFCOXlFYldKRkh5MHZsWW8yT2paZHJCNFBDZ3NqUno0Ynl4d3RlUnVvSWdvL1ZraklsQzF6bTMxM2NHZlpuMzFkUlROck9IQndZR2tvbUppUmxmWnRYSFhCRTFJN2tSeDhVWXRvUndqVlZabGdQWVBncTNmREN3VnppbHZtUnU1UWljc2YyNFdBdjk1ZnZaWnY2Z2N1NWNrUmN1dDlhdlN6YlpyOWFQNWNTdkJCUGp0RXZPSElwcitjMmYrRC91TlhsUDVUcHYxN2w3bHo3OTZRbG5PUEFHQUFBQWJBbTA2TVJyOHZ2bWQvcUswcHF2blA1dEU1blk3L3p1ZCt3UGJxZ1FYaFFhamg4NGNFQnZ1Zk10QWdBQVcxTUlqQWt1Rm1MVWJyZDE2dFFwM1hiYmJWb0w1ODZkdTJnd3pPVTZjdVNJSG5qZ2dWYzlmdDk5OStubW0yL1d2bjM3dEpVOC92ampyeHJlRVBLejBjTzdNaDArOTduUDZkRkhIOVdiM3ZRbTNYampqZnFILy9BZmxrRkczL3ptTnkvNTNzSEI1YURNTUF4aCt6UGN2aGJYWDMvOUpRT01UcDgrcmFlZWVrcTMzbnJyRllVWUxTd3M2Ri85cTMvMXFzZmYvZTUzYThlT0hlVjRKOFFJQUFBQUFOQ3ZaaUpiQmhmOWNhT2hKNnMxWVgybHh1cXNud2E5cXRHc3IvdjRnYVZGM2RMcnFsK2xNbVdRenVjR2h6Um5JM1VNWVZmcktZejczRStEUHhwbzZzditXUGxIWjJkME9FMVY3K1BRS3dBQUFBQUFBR0RGMjkvKzlpUmNaTzRkNzNpSHBxYW0zSmYvNU12cDdPeHNORGMzRnducnppeGZRWHpReWIzTDVlNmR0bUoveXQvL3o4NjV4ejcxcVUvOXhpLzkwaThkVWQ5eXR4VXl0NUY0c3pVVVRqV1h5ZnA1THhhaFZOZ0dPcm5yNW9VcnBoZUxlcjVKa3RoQytFOVd1TEc1bmxxZHZKamEyVENqMWNoZStSVmorNEhSVy8wUXZkVzQ2TDlTckU0VW0xLzFTNkxaMlVNUC92NS8rNy9lbTBrUHRnUUFBQUJnMDZNMUp5NXFZbUppekhmR1RHSGVWS2dZTU03VS9JNGlGZFI5SWpUc2ppdjhmQUVBMkE2c3RXV0FUSjduTHowV0xnQ1JaWm5DU1FYOUpQVFAwdEtTMGpTOTZQTURBd05sc005V3NUSzh2Vjd2b3M5djFQQ0cvZ3JUb05WcTZlVEprMlhRVHpBK1BsNEdZWWIrQ3ZQVWF3VXJoZGMwR28zeWRhR3NwVEJ2aC9uWlhVV0RyMlBIanIzcXNUZSs4WTFsLy9mYjd3TUFBQUFBZ0FzdEdhdHpVYXkyNWZEYlJnbzFiaTAvTGNMMGFQdDZ1R3JoWlB2d1lpNGQzMitMeHFqcit5NFZOa3FZTThwNXhrK1BXVi9xT2ZWUEFBQUF3Rm9LKzJlSnlSU2JRckhZL2w0UExWZFY1Z2pOQllDdEtsd01McHdUdG5mdlhoUE9hd3RsY1hHeFBNOHNjQVIyYndnLzNvMnhadGh2N2h5c1ZDcHZuNWlZMk45dXR4OE56LzN5TC8veW5QckF2UlAzeG9jUCtjMHlaOFpsdEZ2WUdveXpmdllqdkFoYlhsaTlPZit2NTNjcjA5eUY4SzVOeDY4cm9xeFFwU2lzTGF3L25tazI4ZS9XbUVvNVVZd09HZG5kdWJIZmJ4cEY3K09mK2NBNVh3K1FWL0tvN1V4V2RHeWxpSXU4VjlpMFdQS0hTMTk4ZDJkeFlMTDR0My8xOFo0QUFBQUE5Q1VTVUhCeHVUN29kd1RmV2FqNENiK1BQdVFNbGRIOUlqUWczN0ZqaDVvRFRRRUFnSzB2bkRBUXlrb0lUUkRDYWNLSkF5SDBwWitFTUo4alI0NW9abWJtb3MvZmNNTU40ZVFIYlJWemMzTTZjZUpFT1MxZUtRUk9idFR3aGtDbHljbEpQZkxJSS9vUC8rRS9sTk1sK1A3di8zN2RmdnZ0Wlg4RjRYWS82SGE3TDUwRWN5Vm1aMmYxTzcvek82OTZQQXhmdUVqVm9VT0hCQUFBQUFCQXZ6cFdxZWdydnM1bmhnQ2pEVFh2ajd1RmNtUGEwNEFydEQ5TDFlakRzNWFQK3ZubHBDOHowWExRRWpaR1ZwNE1idlJVVXRWVUhHdHZhMEVBQUFBQTFrN0Q5RFFlTDJuRXRqVWF0WVcxOTkzT1BzMjZyWE5oS2dEQW53c1hVbXcybTZIWWZmdjIyWER1VlNoZi8vclgzWkhuajdodXIydmtTREZaYjhhVWxZNlJIL2Z2RFdPL3lJdS83TzluOVhyOUwyazVyT0ZiNmdOdjI2dVJYR3JtUnQvdjc5NHRiQW5PbVhMRHo1WHgvZno4c1hYbFlTNzNzL2xjMjVsMjVzeG1uT1d6UXZXc2NQWFVIOGVNL1NDRXRjZm0vZFc2c2VXZWR6OWRIcFYxSWNCWXMzNUtmYzhaY3o2UHN1T0YwVkxpc2w1aGl6T1JiS2NwZTdRb2xDVTJPNUhNN0dwSmowOEpBQUFBUUY4aXdBaWxpWW1KeEhmR2ZMbk43NW5mNW5jRTcvRzc1emM2NTZwbU02ZnlBZ0FBYkhMNzl1MVQ0V3ZjbjNycXFaY2VDNEU1eDQ0ZHUyaHd6bXA0L3ZubmRmNzhlVjJwY0FXbVRxZHp5V0NsWGJ0MmFYUjBWRnRGbnVmbDhJYnVLNFhReVkwYTNoQ3M5T1V2ZjFsUFBQRkUyWC9oeEpOS3BhTHJycnRPQnc4ZTFFWVlIeDh2KzJXMWhNOEtRVTBYczN2MzduSTR3elFBQUFBQUFLRGY1UDRnM0tJMVdyQ1I1cTFWeW5HNHZqRGw2eEZDU05BT1g2L1ZVUDlaNmIrTSthVXZuSWxqTFRpQ3BBQUFBSUMxbHRpOERDL2FHeTlvVDB5QTZIcDRvcnRMQUlEdG9WYXJhV1JrUkc5ODR4dTFmLzkrYytya0tkZnBkTnlSbzBlV0l3VUtSMlhreGdqdGVtTG4zRS80Ym1maTV5ZmVLS2VwZHRyK2NyMWU3MDVNVEt6ZVNYaFhvQjI3TjFsRnQ1cmxOa2NBc0tsMHNxTFh5NVZsUlJIYTBjYWJPYStyazdsMjRRODVEeVVhTUZ1b3dhZVRxUm01UTdiUUxyOEZzdGM2cFU0dWwweTRRbTdtbjV1TnJDbHkyZmxhMWZUKzNyKzRyMjFzQ0QzU2JPNU15eDkrejVRWDU1UzRybi9SaVc3ZTdmMkx2LzNWSzI4TUFRQUFBT0NhRVdDRUZhR2ljNDl5M2V0M3hEL2lkL0t1OC9mSENDOENBQURZV0FjT0hDaTdyd3d3T243OCtKb0dHRTFPVHVwS3JRVDZYQ3JBS0FUTERBOFBhNnNJdy9sYUFVWWJOYndod09paGh4N1NpUk1uMU8xMnRYUG56akpJS2N4TGh3NGQwa1pZN1FDak1GeWhYRXdZN3hzMW5BQUFBQUFBdko3TUgzcGJDUzhLWGZTSHFTaFc3bytMdmpIVU54UzUrczFVSE90b0pTSEFxRStjOWRPRCtDSUFBQUJnN1NYS05ScTF5L0NpdzVVWlllM1ZiQnJTbHdFQTIwQUlNSG94eEtpc2RIejBrVWVMK2ZsNWQvVG8wYkxpMnZsLzJCQkorZGZwSi8zZmpvenU4SldSVDhRdWZyVGRicytXajIwQUU4VnZNazczT2Vkb1l3UmcwMm5uNnJhNnJwczVoWk82SzlyRWxqTFg3aFZLbTRtcCsyTlZXK1pnczErejFQemZ3eXZ4aWU3UEg3K0FLeDl4dm1Oc2VNWWQ5WCtPK1p0bkZOYVBzWDFjdVp0UEZHV3FLZ1FmRVdBRUFBQUFiQUFDakxhNVQzemlFOVd4NGJFZktJcGl2Ny83UTM0LzdnWWpFOEtMbWdJQUFNQ0d1K0dHRzFTcHZQeFlTYXZWS3NOcFhuamhoYks3YTljdUpVbWlheFUrTjRUQ25EeDVVbWZQbnRWR0N3Rk5Nek16bXArZjEzYXdNcnhoT2x5TkVLZ1V3cWVlZU9JSlBmend3MnEzMitYakliam81cHR2VnFQUjBFYXAxK3ZsOTRkdUNIenE5WG92UFJlR09jekhkOTExbDZyVjZtVjlYcGozejV3NWM5SHZpR04yY3dFQUFBQUEvYXRqalY3d2RUM3pFZUZGL1NRRVN2WDh0RW5WWDlyR3FPMzdiVW0rL3piejVXQzNtTlJQRitPa003NGVLbkpPTzNOYTl3SUFBQUFBQUdCek8zam9vTzEydXFyV3F1SGNMdmZ3ZHg5TzIrMjJYVmhZNEdTc2pSTTd1VnVOTXdjaUUrMklrL2laKzMvaC9tZlRJdjNUWC9xbFgzcEs2K0R2ZmVZSGIzTTJ1OGZrK29DdkZIMnpqTm00a3hBQjRBcGxUbmt2TC9KdXFpVE55K0NpVFg5OWlyUlFOU3RjSk9jUEhHN3pRNGZPbVhGalhNM0lIWExoT2tKT2I1Uk1OM2Z1TDBaWjFQdkViOTkzenIvbXRMUHV0UExpakhQeGJKYk5QQ3J0VFgvanB6NjNKQUFBQUFCcmdzckViVzVzYkt5cVFyZGIyY09GaWcvNnZkZlFZcmdtQUFBQTlBVy92YWFscFpmWGthZHBXb2Erek03T2x0MlJrWkZWQ1RBSzRVVWhSR2R1YnE3ODNJMFdRbTVDZjNRNkczTFJvSFczTXJ4aCtsNk5FR0FVZ3FkQ3NFOElCRnF4WThlT01zUW9CUHhzbEJEQ0ZVcVlUME4vWGhoZ0ZBS2J3bkRuVjlEUTYyTEJWdUd6QndZR0ZORUFGQUFBQUFEUXgzSVp6Zmg5MXpaWEtPNHJJU1FvbFN1RGFmcEo2Sisyc2VyNWJzNDgwemVLY0VhNC83OWdJMVVJTUFJQUFBQUFBTUFXTUR3OGJEUXNEUTBQbGVjckhubitTRm5wdGJDd0lHeVkwTjVyVCtHS1VCOTVneS9mZFhMZk5jWTg3UjlmbHdBald4VGp2ajcwSHNuZDVudmlJTFhVQURhVG9wRHI1Y3F6d2xVSzU3WkVHOXE4S0lmRE9uSGxFMy9vdE9uL05zdmJMM3ZDaGYrWi83dm8xMTlQbXNJOEtXT2Z0S1k0WStQYTg3RnRoWVlaQkJnQkFBQUFhNFFBbzIzb2YvcWYvcWVCVnFzVkdXZCtTVTRIblhIdmNjdlJ1NFBPT1YrZlNiVWlBQUJBdjNqM3U5K3RreWRQYW5Cd3NBeCthYmZiTHozM0gvL2pmOVMzdnZVdC9ZTi84QTkwL2ZYWGEyaG9TTmZpUzEvNmtyNzczZStXQVVaWEk0N2pzaCtxMWVwRm53LzlldkRnUWIzNXpXOSt6YzhwL0JHakVHcno3VzkvVzUvNXpHZDA5T2hSOWFNUXlCT0dOM1JmS1lRdVhlN3dodWthVHZwWUdkNW5ubmxHVnlQTUd3ODg4RUFaWW5TaDA2ZFBsK0UrOTl4elR6a2ZYZXQ4Y3JWcXRacmU4WTUzYUhwNnVwelBYdGwvVnhMY0ZNYnRLd09NOXUzYnA5dHZ2MTNOWmxNQUFBQUFBQUJYSWpQaEtxekdIekh0TDVsTUdYYVZjL2dXQUFBQUFEYkVmenk5UTQvUERXZzlIR3gwZEYyOXAxc0hGN1dyZG5VWFBnSUE0RnFGYy85OE1SLyt5SWRyNFdLSTV5YlA2WmxubnltZWUrNDU1KzliVnpocUs5ZFphTi9qWEdqeDQrN3czWnNqRzczdjA3L3c2WGwvLzFlc3RkTVRFeE9mMHlyNTZHZnVyZFVWM3huWjRpYmp6SS82NmIzSCtPLzAvWkQwVy8wNUFMeWVOQy95bVk1YnluSVhUaXplRW0xby9YcWd2T0p4engvWWRKR1VSS3lXTDhadnJjUitaQTBhbVR2OXZUdjhJZGZNcjljeTJkcjlJYUh4NzMzbXZqLzBhOWd6eHRpSG5PdWUvcldmK0pOSEJRQUFBR0JWRUdDMERmbUs0eEJTWkgwTjVoNS9ONVN4bGVjSUx3SUFBT2d2OVhwZGpVWkQva0J6V1M0VVFuSm1abWJLOEp0d2dQcGFoYys3MnZDaUZhRWZMN1ZOR1Q0L2xNc1JoaWNNVnhpK3kzM1BlbHVaSnFzOXZCZUdWRjJwOE41WHZqL1A4ekljS0hSWFl6NjVGaUhFS0pRTHJmVGZsUWpqdGR2dHZ1eXhFS0FWUGp0MEFRQUFBQUFBcmtTNDFFdjQzMjhOTUVKVElHZjZMMWdKQUFBQUFMYUxUbVkxazFhMEhrYXpUSjBpVSthc0FBRFlLQ3Zud2pXYnpmSkdlN0JkaGhyNXgxMFpwRU50NVlaNDhTcmxma0tvNmx5SXJOQ0lkWGFnS0lwVlA3blNmM2pONWFyNWI5em55Nml2UDI4eTFRRnNSb1ZmYlJXRmM4VVdXbm05dUQ0b0I4aXhjSDV0b2Uxc1dIZktsRmRtdmpDQzBjanNDcGRjOXVPd0VidDRmWGI2QVFBQWdHMkNscDNieU1URXhHMitjNXV2cFB4azZQcWRyVUhmNVVnbkFBQkFIeHNhR2lwUEN2ajR4eit1WThlTzZYZCs1M2RlZXU3RWlSTmwrZG1mL2Rsd3dvQisvZGQvdlF4djJiZHYzMlY5ZHBabElkeFNYLzd5bC9YUVF3L3BxMS85cXA1Ly92bVhudi9oSC81aFRVOVBsNDlmanRBUGIzclRtM1R3NEVFTkR3K1hnVHdYQnROODlyT2YxVnZmK3RieWN5dVZTaG5NOUVySGp4OHZ2L1BuZnU3bnlqQ2ZNSHpoQklqd2VhMVdxd3k3V2VuMzhOcU5ES3NaSFIwdFN4amZyK3kvTUY0dkhONHdESzhNN2duQ01Eejk5TlA2bFYvNWxaZUdONFJXWFdwNGQrN2NlY24rV1huTjdPenN5eDcvM3ZlK1Y1YlBmVzc1UWt2dmVjOTd5dkYvMjIyM0tVbVM4dnQyN2RxbDNidDNsOU52WkdSRWF5R01nM3Z1dWFlY3h5NmNwMWI2NzZNZi9XZzUzc0w4Y3lrcjR5U01XNzlmODdMbnd2dkM1NGR4QndBQUFBQUFBQUFBQUFBQUFBQzRldUY4d0ZBT0h6NXNQL1NoRDltbm4zNDZYVmhZY0E4ODhFQ2wzVzZiSWkrRURSRk92R3c0NC80WEk2TlAvOEtuUHltblA4dUs3Rk5GVWJUK3lULzVKOU9YOHlFLy9abDd3NG1DSTVuVFBjYlljY244cEpQR2pOeitsU0Fyc2pHMmgwNFcvam8xS2tiQVZoQlNhWHE1MUUxVlN3dFgweGEwbEdtdVlxVnFMRTZhdmpvZkRrMXEvVkx2cHpLWjFpYys4NzZ3N3Z5YVh4Wit6YW40ZkN5ZEdUbDI3L3pFeEFRYk93QUFBTUFWSXNCb2kvTTdTbUVhaDUzdFBiN2NsdWY1RzYyMWc3NXVLWExPclFUdkFnQUFvTStGa0p4ZXI2Y2RPM2FVb1VEejgvTXZQZGZwTEY5RTU1RkhIaWtEZmNMOUtJckt3Snh3UDl4K3BibTVPWFc3WFowOWU3WU1sQW5kRUE0VERBd01sTys3NFlZYnlvQ2JLelU0T0tqOSsvZVhueG5DaUZhRWdKM3d2YUUvdzRrTllaajh0bWxaMnUxMkdVeno2S09QbHU5WkNhb0p3VHFoWDFhR2F5WFFaMlc0d3pqWmFDdkRlL1RvMFRLMGFjV0Z3eHVtV3lnWEc5NFhYbmpoWmNNYnhubDR6ZFVNNzgwMzMxeU92ekR1Vjc3ZmIvZS9MT3duQkJ5Rjd6aDU4bVFaWkJSdWgva3B2Qzk4UjVnMjRmSFFEK0gyeXJ3VUFxZENDZmV2TmpncURGL29weEJtRlBydnd1RUw0VTBMQ3d2bGZCSDJVeTZjYjBQL2h4S0dLNFFjaGZldURGTjRiUmlHTUIzQ09BNzlEZ0FBQUFBQUFBQUFBQUFBQUFCWVBZMUdvMng4c24vZmZ2WFNuczVObml2eVBEZWRUb2RHS1J1cmFZelpYYWxVM3VXY20vM1VwejUxekUrcnFYLzBqLzdScTRLTVB2cVplMGRxVVMrSjgyUXNVN3hITHRzdGEyK1RLd013aGtJV0JxRkZBRFk3NS96U3JYQ1pMMkg5dENYYnp2cmxmZUVIajBYMktqQkcxcThIYXpJdVhHWDRSbFBvYllYVjlOU2hCNC8rbmM5OHNQUHJQL0g1b3dJQUFBQncyUWd3MnNJbUppWjgvYUdhU25XbkluM0U3MysveXhwNzkwb01PdUZGQUFBQW0wTUladm5JUno2aXA1OStXazg5OVZRWjlQTHd3dysvOVB6cDA2Zkw3aWMvK1VuVjYzVzk3MzN2MCtqb3FBNGNPS0RoNGVHeVhDaUUxSHpyVzk4cUEydSsrdFd2bG9FeW9heTQvZmJieThDYWozM3NZL3JtTjcrcGYvZnYvcDJ1eEcyMzNhWVBmL2pEK3R6blB2ZXlBS01RUFBQNDQ0K1gvWG5ycmJlVy9SbjZONFRQaEJDbDhQeG5QL3ZaTXBnbUJObUVBS1Yzdi92ZFpmK0dzS1hRcjZFYmhBQ2J5Y25KTXJCbW83M3puZS9VME5CUTJlL0hqeDh2SHd2RGNPSHd2dU1kN3lqTHl2QSsrZVNUWlJCVmVFOFlsdkRhbGVFTklVamh1WXNOYnhndmx4TEd4WC8zMy8xM09uYnNXQms4dERLZmhNKzdNTUFvaENZRjMvNzJ0eS81V1NGRUtJUVZoV2taQXExQ3Y5MXl5eTFsQ2Q5ek5RRkdvWjgrOElFUGxPL2Z2WHYzcSthNy8rMS8rOS9LY1JQR1V3Z3ZDcTlmRWVhQk1FNys4QS8vc0J6SFlYeXRDUDBaUGpQMGF4aC9BQUFBQUFBQUFBQUFBQUFBQUlEVmRlREFnZktrc1VPSERvVnowdHlEZi9SZ2QyRmh3VDcvL1BOVllTUGRWTGppSnVWNnZ6SG1tZGpHWDI2MzI1L3hqMy9sd2hkOTlEUDMxcHFLNzNTWnZVbkczQ01WYnpFbXVsTVh4RitRaEFGZ0s4aWRzbGJYelhWelYxTm9WN2tGWllXNlJ1SGM4RWk0WmcwWlgyUjIrOXYzeVVZZjlldkQzQnJ6V3hXWGhZWUJ2eW9BQUFBQWw0MEFveTFxWW1KaVRHRW5POWU5ZmwvMEp1ZmNHNXpjVGtLTEFBQUFOcThRMG5MMzNYZnIyV2VmMWZ6OGZCbG8wMnExWG5xKzErdUZLeXJvdWVlZUs4TmZ6cDQ5V3dibWhIS2hQTS9Md0tBUWJCT0NZTUw3Z2hCVUV3Sms3cnJycmpLUXAxS3BsSS90MnJXckROSzVNR3ptdFlUd3BCQjRFMEpxUW9oTzZOZnduY0ZLV00rWk0yZktBSjN3SFNFTVoycHFxZ3lwQ2YwU3dtdkNkeDQrZkZodmU5dmJ5dGVHa0tid2VEOEsvUnI2ZTN4OHZBd1l1dGp3aGxBaGErMUx3eHVHSjd3bXZDK004d3VIOStqUm81cVptYm5pNFEzYit1SHpkKzdjV1g1TytMeFFqaHc1VW41ZUNNQUswekZNMHpDZmhFQ2cwQTM5K0VydGRydDhQa3kvOEpsaFBndnpXNWozRGg0OFdFN2pFR1lVZ3E3QzUxMko4TjdRZnlIRTZjSjVLb3kzTUk1Ky8vZC92NXhudy95ekl2Ui82S2Nubm5paW5COVdoamVNeS9DNkVIb1VBcnNBQUFBQUFBQUFBQUFBQUZndGUrczkzWkl0YVQzc3JYVzFJK2twc1lVQUFPaG40Unl2Y043WW9jT0hvbmE3YmNMNVpiT3pzeTZVTkUxTlVSUTBXbGxuNFZ5NmNDNmdsb002YnZMMy8rTFAvL3pQWDY5NjY1aFU5T2IyL3RtbzM4S29tY0xkN2F4Mit3bDBvMy9YbUlBTlZ2ajUxcys1TGk5TTd2elN3eFhxWGVxMTFwcW1EZDF5Q1dOZTdBS3ZWdmdsWXVvWGlybmNsdDI1eXYyUGg5L0FtcW40WXYzUzZUWWpzL3NULy9KOWY4WGw3cnlON0xPZHpzemNiL3pVdHkrdlFRVUFBQUN3VFJGZ3RIVWQ5UHZhdTN5ZHpDLzZ5c2ZRb25qYzd6UUpBQUFBbTFjSU1QcnhILy94TXZnbmhNdDg5YXRmZlZtQVVRaDRDZVZyWC91YXJrWUlsZ25sci8vMXYxNkc0RFFhRFEwUEQrdldXMjh0UTJNdU44QW9CTW1FOXovODhNTmxpRklJcWxrSjlBbmQ2ZW5wc2p6NjZLTVhmWCsxV2kyLzg5M3ZmcmQrNUVkK1JOLzg1amZMRWs1NjZFY2hyT202NjY3VEY3LzR4WEs2WEdwNHYvV3RiMTMwL1NIQTZNTGhmZUNCQjhyUHVOTGhEU2NoaEdrV1N2aWNGU3VmOTluUGZsYkhqeDh2NTZPaUtNcXdwUkNnZExFQW94QVlGSnc3ZCs1Vno3M2xMVzhwaC9makgvOTRPWDljVFlCUjZML2YrNzNmS3dPSlZvUlFwK0JUbi9wVStibHZmdk9iWDNydWhSZGVLUHNwek84cjQzWmxlTys0NDQ3eWR4RkNvQUFBQUFBQUFBQUFBQUFBV0MyM0RTNXBmNzJuOVZDenVlcFJvVWFjQ3dDQWZoWUNpM3d4ZDkxMVZ4TE9QN3Z4eGh2MStHT1BGNDg5OWxqZWFyWGlicmRMdzVVTllKYXZkcjdQeWUzek45L3RiK2V1aVA4Z3Qra1ovOWdiL2YyYXJIbVhwVjBSK2tqaC9Jd3FwM2JtVW4rN2wrWnU5bEt2YlZUVURJRXRTV1Q4L083RXZJeExDWGx1M2J3OFZkcHBpMG9MRmZ3RTFreTEvT3YwRjUxem1SL1QzKy9IOWJORjRYNHRTUWFmOU04UVlBUUFBQUM4QmdLTXRwaUppWWw3bFduRTd5RDloQzhEdmxwbWgrOHluUUVBQUxhUUVKZ1RBbUN1di83Nk1wQW1oUHZNejgvcjVNbVRWL1E1NFVwSUlTd29mRTRvYjN2YjIzVDQ4R0dOajQrclhxK1hyd25oTkRmZmZITjVkWjVubm5ubXNqNDNuS0FRUHZ0OTczdWZici85ZHYzbWIvNW1HVHh6T2UrLzc3Nzd5dS84YTMvdHI1VWhTSmNTK21kcWFxb2M3bzBXQW9qaU9OWmYvYXQvdFF4c0NzTWJ3cDZlZi83NTEzMXZHTjU5Ky9icGd4Lzg0R1VONzRXQlZhOG56QThodU9qem4vKzhIbnZzc1hKYTc5Ky9YMy8vNy8vOTh2blF6eUh3S3ZSckdJK2hHMG9JTkFwaFF1SGtrdWVlZTY0TURBcTNWNFF3b1JESTlHdS85bXZsZlBJelAvTXpaZGhTbUc4dVI3UFpMT2VwSC9xaEh5cmZFd0s1amh3NW92UG56NjljQlVxTGk0dDY2cW1uWG5wUHVCLzZZZVg1RU1JVXdvdCs5RWQvdEp4bnczQ3R6TE1BQUFBQUFBQUFBQUFBQUt5R1pweXJGaFZhRDVGeFphbVlMZHZHRmdDd0JZVnowTUxGNnQ1dyt4dnN2bjM3ek9uVHA5M2MzRnoyMUZOUDJYQWVXcHFtVmxoM29RMlJNY2FhclBvdW82VFZtTHBweE5rODdneWZsRE4rMjhZU21JaU4wU3RjbnZuU1R0WExRMktSY3dNaFlpWXZWUEZQUjVuZkpMN1VlN3RaVVY3NE1rUjF4VWE5MkpwMnZXTHFpVFdKdjEwK0RnUitsb3B6NTRiOExUOC9iYzBabzNDdTRzVE80NW96empwbmRvUnI3dnFWNnlmOEEwOTk0cmYrd3BOK2FmUlFtamFlL044LzlybTJmNDdwQUFBQUFGeUFZSnV0SnRkaHYyOTkyTy82L0dWRGxDNEFBTUNXTkRvNldvWU5SVkZVQnJlRTBKeFRwMDVkY1lCUk9KQVh3bmRDZ002YjMveG12ZWM5NzlGdHQ5MzJzdGVFRXd4Mjc5NWRmc2ZsQ3YwVnloMTMzS0ZiYnJsRlgvemlGOHZBbThzSk1BcmZIMDVvK0lFZitJSFhmRjI0TEVZSXRRa0JQQnN0aktNZ0RHL28vekM4WVZwY1RvQlJlUDNCZ3djdmUzZzduWTR1MThMQ1Foa0NGTUtMSG4zMDBUS2thbXhzVEIvNHdBZktnS25Cd2NIeU04TzBDZE4zcFhTNzNYSytDTzhQWVVYaFJKSUxBNHhDMEZBb0lld29mTTdmK2x0L3F3eWR1dHdBb3pDKzl1elpVNFpiaFRDanljbkpzcXlFSndXaEd4NjdsUEI5SWNRb2pMZndld2pEQlFBQUFBQUFBQUFBQUFEQWFxcXZVM2dSQUFDYlZUaC9MRng0emhlemQrOWVVNnZYc3VucDZlTFlzV09tM1c2Yk5FMkY5V2Rrckp4OGlRNkVWa1dWOXFpS0tKVVpPbE0rNzBTQUVUWkc0VlQwY3VXTGFkRkxjeFZaVVRSY21GLy92SDFqY3FuM0xpOU5sbk5DL0tJbnJ4aDFJcU1rOGpjaS96aHQ2UEFTdi94elR2V3RHbDYwekZoSGJNNDZNTllZTlgyMzZXZW4rL3dEKy96dGZYNGVlNzZSdEo2Ly8vNkpqalRCbEFBQUFBQXVRSURSSmpjeE1WSHpuUkZmZi9pRGZrZm9MaWYzL2Y3KzViVWNCZ0FBd0tZV0FtbXV1KzQ2M1h6enpXWG9UQWpNeWZOY2p6LytlQmtBYzJIWXpjek1UTGlhVVJuMEVzSnBkdTdjV1FiWTNIVFRUV1VRVENnWEM2QUpqMzM0d3gvV3ZmZmVxeC8vOFIvWG9VT0gxR2cweXVDWjExT3RWc3Z2K3J0LzkrK1c5ei8vK2MrWFFUaWhYMEovaHY0THJ3bUJOaUg4WjJob1NHOTk2MXRWcTlWZTlqa2g1Q2VFTE4xOTk5M2xjQWJoeElkS3BWSU93K3NKbi8rbU43MUplL2Z1MVgzMzNmZXE1OS93aGplOEZFSjBMY0tKR000ZkRRckRHNGJ0d1FjZmZHbDR3N2dQdDFlRzk4NDc3eXhmZjdIaERXRlN0OTU2NjBXSE53ekRwWVR2RG9GRUlmam5TMS82a3A1OTlsbDk1U3RmMGV6c2JCbjQ4emYreHQ4bzU1VncyN3g0cVpuUVA3dDI3U3BEZ0c2NDRZYXlIME5ZMHZ2Zi8vNXlHclZhclRMSUtJUlBmZnZiMzlaM3Z2TWR6Yy9QbDhGUlMwdEw1V2Y4NGkvK1lqbU5mdlpuZjdZY3RsY096NldFWUt3UVZoWG1zZkI1WC8vNjE4dnVoV0ZaWWZoRHNGR1l6bUY4aGY0TTgxU1lIOE44ZU9EQWdmSStBQUFBQUFBcjJtbXVrL050WmJsVEo3dktSb2F0aHRRWmxmSTlXbTBMdnB3cGpGcWN4dGlYbmkxMmFESHZuNG16NEE4QXQzeDN6bkhTZlQ5Nk5oOHJMd1U5dXhielRHK0huL0FWYVNyMUZaeHp1aHA3Qm4zOWJHUTExcUQrREFBQUFBQUFBT3RqOSs3ZGRueDgzSTZNakpod1B0dDN2L1BkWHF2VnNzZU9IYVB0MGdheWVTTGpZalVuYjFVUmRaVW5iYVcxV1dYMXE2dDdCSzVVTjNmcFFyZG8rMjdTelpWa2hZdUxzbXE5REMrNlluN3hrcVJGTVRyVHNaVTUvNEhEZGR0THJGdzlWbUpYVHBERnR0VEpuSHJiSUtPdGNNVlE3cGpYMTV1VE9lZ1hRT04rT2JNN2w1MmJQdndudi9MeHo5dzcrYi8reElNUEN3QUFBRUNKU3NETkwwekRtb3h1OGQwN2ZibEpJZEFJQUFBQVcxNElmd2xDK0ZEZ0QvcVh3VG1oaENDYUVBYXpJb1RLaERDWUVBUVVib2R1ZUg4SXl3a2hOcGNLblFuUDdkKy92eXhYS29xaXNudjc3YmVYM1JDd0ZQb3RCT3lzOUY4SXBRa0JOQ0ZnS0F6SHdZTUhYL1U1SWJ3bWxLdnBoeUNFNm9SeEUwb0liRm9yRnc1dkNQYzVkZXJVUzhNYnVtSDhyd3h2Q0M0S0FUd1hHOTZWSUtrckhkNXd3c2RLNkZBWTEwZU9ITkh4NDhkZitzNFFkblhMTGJlOExLd3AzSDY5MEtFUWdCVENrOEx3aFBraGhDa0Y0YnVDSjU1NG9ueC91TC95M09VSTd3a2xUSmVWN3duajdjSitDWUZNNFg2WU4wTHdVZ2hiQ3ZmdnV1c3VBUUFBQUFCd01YbmgxT3JsNm1XRmx0S3JQRHUxcUN3WFY5ZHFXL0w3N3gzbHloVENsVWd4NmpjdGwyaldYZFc1OG10aTBjOHZTK1cxc01POGZKV0JYRmd6TFNXeS9tZWNyTVU4ay90bFVPWS90K3Uvb0hOMVY2a2ZxVmNFQUFBQUFBQUFyS2Q2dlY1V2xvWHp6Y0w1Yk04OTkxeW9DS2R5YzRNWlg0ZHBjaXViRDZxSWZMMmhNY3FUUlFIckpTOVVkSE9YK1ZMeGgvSEN5YmFScm9GZnZFUk9KdW90cHlDcG5ydHdLWWlpTHZKY3Ryc3dTN2h0Y0FqV3ovK0p1QURLdXZOanZPSFhvUTJGcmt4cVpFYjgyclVuQUFBQUFDOGh3R2lUbXBpWTJLTmNIeXlLNHAzKzdvLzZIWjV3QmpXWFRnUUFBTmpHVnNKd1FraE5QL3JoSC81aGJSY2huR2k5aDNkbVprYWYrdFNuTkQwOXJhOSs5YXN2UFg3ZmZmZVZRVlVoTk9scVFxQkN3TkI3M3ZPZWNyNzZLMy9scitoWGZ1Vlg5S1V2ZmVtbDUrZm01c3JBcE05KzlyTzY5ZFpiOWI3M3ZVOVhJL1FuQUFBQUFBQlg0d3ZQVEpaaFJULzlueDVSSjh0MXR0WFZ0WG5UaTkyL29EWEJCWTM3MWo5WG41b1crdENhemk4dFgxNElOODY5V0s3T1NLMml0K3dkMWpzUGpPcEgzM3FkRGc3WE5kYmd0QUlBQUFBQUFBQ3NyWENodk9DSGZ1aUhxbG1XNlFNLytJRndRYjdpcTMvNjFYeCtmajdxZERyOWt5Uy96ZGk4cG1ReGxERi83MVoxaGs2cnFIVFViWjZWczFkNVlRamdFbktuL0Z3cm4rbm1ydGJPM1pqV3lFeTdLQmM2YnNDMks5YW9tZGpWdjBvSk5vVThYQXgyT3lRWVlhT0ZFS01RMXZpdlE0elVKejV6MzA4WUZXZisyVTg4K0hrQkFBQUEyeHdCUnB2SXhNVEVTaVh0ZU43T2QwYlZhSWVWYlRqalRQbWZxN1FDQUFBQTI5TGk0bUpabHBhV2xLYkxWMlEzeGlpS0l0VnFOUTBPRHVwYWhjOEtWOFlLSjVlRTB1MytlV1BRUE0vVjYvVlVGRndzQ3dBQUFBQ3dmbnBab1Y1ZWFMTFZMUU9NTXI5ZlduQkNLZ0M4SlBYTHhVNWFhTGFUNnN4Q1I4UFZXTTBrVmhMVFBnd0FBQUFBcmtSV0xOYzV6UzUxeS9vbjZxQ3VYbXl0TDBiVlNxUnFIQW5BMWhmT1k3UCt0eC9PWTJzMm15WXY4bkRmdGR2dDBPWS9OUDRYTm83Tlk3a29sczJxWllDUmkxS1ZiWk1NMHdYWEp2eTJ3OC9iejFWV1J1c2k5MThhTWV0dWEzNmV5M3pIdmxpQTlXRzB3eGliZmV4MzdoMVhjMkhwTi83eXQ1Y0VBQUFBYkZNRUdHMGl2aDZsNlN0dnJRcjlocTNhSGI0cTU1N2xKeVRDaXdBQUFJRHQ2NHRmL0tKT25EaWhCeDU0NEtYSEdvMkdkdXpZb1IvOHdSL1VoejcwSVYycjhmSHhzdHg1NTUyYW41L1hONzd4alpkQ2pEcWRqcDU2NmltTmpvNEtBQUFBQUlEMThvMFRNM3AyZWxFLzh3ZVBhbnFwSndEQXl5MzJjbjM5eEhsOTUvU00vczJqSi9YSmUyL1JCMi9aclp2R0J0U3Njcm9JQUFBQUFGeXVrek90TXJ6b24vMlg3Nm5WNldscXNTdGNuVDFERGQyNloxUWZlTU4xZXNPK1VXVTVGOHNDdHJwdzRieWhvYUZRN0J2ZThBWjc4dVRKZEhabXR2alRQLzNUYUhwNjJuWTZIVUltTnNSeW9reXl1TXRYSkVyVitiMXlVVStMTzU2WHM1bnlaRkhBdGVqbVpRaGt0TkJ6WTFvbk14MlhWWXd6UTFWQ0VyZXJkdVpPK3ZtdTZtL3VFYkJlblBtZmMrZk9KTjNvL1M0ZGZzZy84cHNDQUFBQXRpbk9TTnNFSmlZbVJueW5WaFRGOTV2Q0REampydlAzR3dJQUFBQUE3OGlSSTNyaGhSZGU5bGdJTURwdzRJRHE5YnJXbXQ5WFVhL1hVNVpsQWdBQUFBQmdyZlZ5dngrYUZYcHlzcVh2bko1Vk82T1JFd0M4bHNJdEx6dWZQdGZTV0wyaS9VTTFBb3dBQUFBQTRBcjgwWk1udE5oTjllemtuRHBacmxZbkZhNU9KODNMY2JoenNLWmVzWHdid1BZeU1EQmd3L1c3YjN2RGJXWitibDVIang3TlBaMC9mNTdFa1kza2pKUlhWRmthTFFPTWJKYW9pSHNFR2VHcTlYTFg4WWZ3UWxKV1ZldkUxNFZYQ3YrTlBYOGpKS1BGMWdqYmkvUHJsOXlKQ1k5MVo1eHAram52UmhWbTl2LzJMOTUvVDZXZVBmbi8rdEVIcHdRQUFBQnNNNXlSdGptRTFOODlWdllmT3VQRy9lMURBZ0FBQUlBWGZlVXJYM2xWZ05IWTJKanV2UE5PN2RpeFEyc3RCQmkxMjIybEtTZm9BUUFBQUFEVzNsSXYxMnduMVo4Y25kSi9mT0swMmltTm5BRGd0ZVNGVTd2STlhZkh6dXY1ODR0NjUzV2oyam13Ym0xR0FBQUFBR0RUKytjUFBLcGVsdXZKTXpQQzZsanFabnBtY2s2TndTSEZsWW9BYkI4akl5TlJLUHNQN0Mvdi8rRWYvbUczMCttWW1ka1pxMEp5WlpJTzFwc3RscHVYMWVjT2xBRkdJYmdvcmMrb1RZQVJydEpTejdVSzUwS08wTHBWUmp1bmV1NlhJOTNNS1RJRUdHMUhXZUdzSzFpUFlBTVlOZjNmZS95U2FFOWhOWkttOFcvNit3OEpBQUFBMkdZSU1PcGpFeE1UaDVYcXNITGQ0M2VmYi9RUDdmV2xJUUFBQUFEd1ptWm0xT3YxTkRzN3E0V0ZoWmM5RjhleHF0V3FvbWgxTDB5MXRMUlVmcDhMbHlsNVVmaWVnd2NQcmt0WUVnQUFBQUFBVTB0ZFBUdTlXSGFYcjlEdUJBQjRmZE12TGpkUHpYVzBwOW5SenFhdlB6U2N4dzhBQUFBQWwzSm1ickhjanpvN3YxU0d3MkwxUEQ4MXAvbE9UMisvdGFaUkFveUFiZTJtbTI2S3NpeFRyVmJUNHVLaU8zYjBXTkh0ZGsybjA3SEN4bkJXTnFzcWJvK283b3lLU2tkRmxDcXJ0c3B3STJ3dDVzV3kybExuZW43emFYVlBZTDA4UlphN2VXZE5hRFBaRkxhVlhNNFZ4amlPSDJPakdKa3hKL2VXb2pEdi8zdWZlZDk0cjVjLzlCcy85ZUNVQUFBQWdHMkNBS04rRnNLTHJPNTF4bjNZN3pmZktRQUFBQUM0UUFnd1dseGNMTHV2RERDeTFwWW5kYXhGZ05IYzNKeUtvbmpwc2ZBOUljQm9iR3hNQUFBQUFBQ3N0YW5GbnA0OHQrQzdYWFd6UWdDQXl6TzExQ3ZMcVlXTzlyVzZHbXNrdnY2UUFDTUFBQUFBdUpRejgwdWFhL2ZLQUNPc3J1ZlB6WmZsbG9ON05UbzRJQURiMTQwMzNoaUhjOUYyNzk2dHFha3BOemM3bDgvT3prYWRUa2ZZR01aWm1heFdoaGhWT3NOS0d6UEtreVVWY1VjNUFVWmJUc2k0WDR1Yys3UlF1aEVwTXY0TGkxNmh1YXB4VlJGZ3RPM2toWEhGaFZkb0JkYmZXQWd4OGt1amxwOFJEeWVKbnZTUEVXQUVBQUNBYllNQW96N3lJei95STlFZGQ5eXgzKzhuMzJhY3VjYy9kSXVUdTlWM0R3c0FBQUFBWGlHY3BCRUNoUzRtaEF3OS9mVFRldHZiM3FiVjhQampqK3V4eHg3VG80OCtxdW5wYWVWNS90SnpRME5EdXZQT096VStQaTRBQUFBQUFOYmE2WVdPdm5OeXRnd3lBZ0JjdWFNemkyb21zVzRaYnlyWmlPdGZBd0FBQU1BbWNXeTZwVE56aThMYW1WdnFhbXFCZ0NoZ3V6UEdxTkZvYU4rK2ZlWTk3MzFQUERzN2EyWm5ablhrNkJFM2VYYlNaVmxteWFQWUNDSFZ4aW5xRGNpR1FLTzBxc0ptNmc2Zmt2TlBGWEZiMlB4aVB5MHJXNmllT0N3cHVwbUxySkVWcnNoU1Z2UnlaOUplVml6NVJXNGxLMXpEZDJOZE1DNzlpSjBMM2RpUDRLcFZVbzFOM2QrVU5mMXhzWVM4Y0hXL3ZxZ3NMNytBamVPWFJUZjV2M3VNMC9zLzhTL3VPL2pQLzlZRFh4QUFBQUN3RFJCZzFFZnV1T09PVU9VenBrSzMrUDNrdit6a2R2djdld1FBQUFBQUY1RmxtWHE5bmk1MmNrWUlONXFjbkZTMzI5VnFPSFhxbEw3OTdXL3J6Smt6V2x4OCtjbDVsVXBGQnc0YzBNQUFWOFFEQUFBQUFLeTl1VTZxNDdOdExhV0ZBQUJYYnRZdlI4KzBPc3B5WDY5WUVRQUFBQURnRWtLNHp0bDV3aG5XVWlkTnRkZ2hxQnpZN2tLQVVaSWtvWmliYnJySnpNN09LcFRwODlPYW5wb3V6NVBEUmpHeVdiVzhGUUtNWkp4NnpTbmZMV2lSdGtWWUswVjlFajZ6V2pJbmt4VWsyRnlwWHE0OEwxeTYwSE1MSVFqSUg0b05QMzc3WWluRlZwMHdZcXYrOSs4cWZ0a3QxZnNwWGk0RUwvbkp6OUlKRzg2VWJZTDlYeFBmNnRlWllaNGt3QWdBQUFEYkFqdGtmV0xpNXlkK1VybEdDbE44ekJvNzVPUjJPT2NpczhVcWdRQUFBQUNzbnAwN2Q2clpiQ3FPWDcxcmQvNzhlWDNqRzkvUXlaTW55OWU5L2UxdjE5RFFVTGhLVmZuNlhidDJYZkp6anh3NVVnWWdoYUNpczJmUDZxdGYvYXJtNXViS0VnS1RMdlJqUC9aak9uVG9VUG01MW5MQkdnQUFBQUFBQUtEZkxYWnp6WGN5RmVLcTlRQUFBQUR3V2hyVldFTTFrbC9YMGtDUytIRmNGUUJjS0p6bkZzNkwyNzE3ZHpoZnpUenl2VWZ5Y0NHL3IvenBWOG9UMUZ6aGFHaXpBWXl6SVJ4RXpjbGI1VXlodkxxZ1BHbXBNempsNzJlU3pRVnN1TExhMitVeXpKQ3ZwM0RMbzJ1eWxjK25oWXBPWGd6N3V6WC9lRlBHLytTZEs1ZTVGN1p0ekp3YkQ5MDhkV3I3d3d3elM2WXpWTFh4Y0UxeHhSclpEVjQ2NTNKaEdFTHZDK2dMeHYwdHY1SnNmK0szUC9DNE1XN3BuLzM0bHg0U0FBQUFzSVVSWU5Rbm5OeVEzemtlOGpmMytOdmhTRmRDZUJFQUFBQ0ExeElDZ3k0V1hoU0VxMDZGRWtLSFFuZHFha3IrWUtLR2g0Zkw5NFFUT2k1bGZuNitmSDVoWWFGOC82bFRwOHBBbzR1OUo1d3NNamc0ZU1uK0FBQUFBQUFBQU5CZlFvT0V3aEZlQkFBQUFBQ3ZKNXpKYlRlNkZmWVdGMDZYWnh3RGVLVndYdHlMNThhWmVyMnVVUHg5RndJcEhLSGNHMmc1RXNUa1NSbGc1SHczZDVGTXlKTXloaW1EUG1LWUhhOUFyMUNSRmE0bzNFdXBQM0g0UVYrMFhhTlRGRHJGOHUwUWdlU1BOdmhTNXNxRjBiNngyM1YrS2NXVldORmZuT3IrYjkyNW9pSFdsQUFBQU5nR2FHRzZRU1ltSnZ4T2h4Sy94LzVKMzczTjc2eC9PT3kzay9BTEFBQUE0SEtGSzB3Ri8rZ2YvU09kT0hGQ3Yvekx2L3lxMTB4UFQ1ZmwrUEhqV2czaFpKQWtTZlJqUC9aalpYalJ4ei8rY1FFQUFBQUFBQUFBQUFBQUFHdzE5OXkwVDUwczEvL2ozM3hGV0YwN0JtcHExaXJhTWRqUXNMOE5BSy9sN2U5NGV4bVk4YmEzdnkxY3lLLzQ0d2YvdURNM054ZE5UazRtd29Zd3ppcnVEUHN5cFByc2RjcVNSZVhWUlhXR1R5aXZ0QVgwY25kSTZHdXozWHloMVhQZGJsYU1GVmNYL0JQYXBjYnp2YUsxbExyemU1dDJ0QllibHN2ckpFVGhkREtua0FXYVJMUkg3WGQrQ3YyMmtUbjEwNSs1OTBOTFBiVis0NmNlbkJJQUFBQ3dCUkZndE00KzlyR1BWZmJ0Mnpmc2J4N3daWTl6N2pxL0I3SkRBQUFBQUhDVlJrZEgxZXYxOU5hM3ZsVnBtbXArZmw1WmxtbHhjVkdkVGtmZGJsZFhJNHFpY0JVck5adE5WYXRWMVdxMThyc0dCd2QxL2ZYWGw0OEJBQUFBQUFBQUFBQUFBQUJzUlpWNHVSMzNqVHVIeXU1ejUrYUZhMk9NWlAyZm5VTjFIUndiVkQyaE9RT0F5MmV0TGM5WjI3MTd0NjNYNnpiY0QrZklMUzR0T2xjNDQ1d1ROb1lwSXBtc29xamJsTWtyS3FLZW5NM2xvbFRBZWl1Y3EvbkZRVVc0cUxDb2RQNWZYcmdvOStQSkx6Nk5yaUgveG45ZVZNaFY1SzRxQkdsVkZJWFRkbHdETEU5TGJCS1JuMWIrdDZMYktnMDc2ZThUWUFRQUFJQXRpUnIvZGJadjM3Njl2bk5YVVJSLzIzZnZNY1lNaU9rQUFBQUE0QnI4d0EvOFFCbFlkUGZkZDJ0NmVscGYvZXBYZGZic1dUM3p6RE42NnFtbk5EazVxU3NWVHU0SXdVWER3OE42ODV2ZnJJTUhENWJsTFc5NWk2Njc3cm95eENpOEJnQUFBQUFBQUFBQUFBQUFZQ3NhRzZpVjNZLy9oVGZwL0dKSC8vai85MjNoMnNUV3FwSEUrbS91dWtGLzRiWUQrdTdaUmMxMmN3SEE1VWlTUkR0MzdyVHYvOEQ3cTYxV1MxTlRVL3JXdDc2Vkh6dDJ6QzB1TGtZdWQ5Y1F3WUdyc3p6S282eGVsa3BuMkQvazFCNDdwanpxS0czTUNGaFB6bTl1WklWMloyeGVYRkx1blB3NFVqZFRvNXM1NlJxWG5JVlR2U3hsbE03R0xJWjdSZGtmMjQ0VEFVYWJTTlAvOUE1SzlwTlJwcy83Kzk4UkFBQUFzQVVSbkxOT0ppWW1SdFRUWVdXNnlVWHVQY2FZdlg0UHNlS2M4emVwSXdVQUFBQndiVUtZME1EQVFObTk5ZFpidFdmUEh1M2R1N2U4UFRzNys5THJ3dTF3cGFrMHZmU1ZqWGJzMktFNGp0Vm9OTW9yVm9YZ292QllLQ0hRcUZLcGlQMFlBQUFBQUFBQUFBQ0EvalRmNmVuaytaWVdlcW5PemkycDFjbVU1cXZYY3UrN3ArZDA3UHlpdW9zTE1xSEYyelY2NU1nWm1XNWJ6NTg2cDloeURBcmJVeVcyYWxZcjJ0bXNhM3l3cm9Oamcwcmk3WDFCbVVKR1BSZXA3V0sxaWtSWWU0WGpJa2FYOG9hOW96clg2bWg4YkVTOU5OZGN1eWRjbmR3djJ6cFJwTytjOWRzUzBaUk9MUFQ4TmdzSkF3Q3VYRGkvTFZ5Zzc0WWJiakRoWW54bno1NHRldDJlT1hIeXhQSUtqVVNIRGZKaW9GRzNLV3RxNVgwWHBjcVNKWVV0dkJCdWhENWhsQnBuQ21lVWFLTlNaN0FoaWtKWkwzZVo3NFpwejA0QXNFNzhLakQyeTl6ZGN1N2dKLzdWZTI1WFQrZisrVTkrK1p3QUFBQ0FMWVFBby9Vem9rZ2ZjWEp2OFJXaEgxbDVrRWEvQUFBQUFGWkRDQzRLQVVQQmdRTUhMdm02Ung5OTFCOThMRFEvUDMvSjE3enpuZThzZzRzQUFBQUFBQUFBQUFDdytTeTBlL3JpRXkvbzJjazVmZVhaTTNwaFprRXppMTJ0aFVqWDdvc1B6L2tpWUZzYmJkUjAzVmhUNzdwK3QrNitZYmVhZDFTMFo3aWg3U3lUMVpKTE5KZlhWVGVac1BaQ1lCUXU3Z08zSDlUcGhZNXUvUFlwVFM2ME5UTTVMMXlkM0JqMW9rai82YmxaL2FmbjV3UUFWNnRXcTVWbGZIeThETjk0K3VtbjA0V0ZCWGY2OU9uRXlhbklyejFzRlZmT2hFQkVKMVVYZHN1WlFwWE9pTExLb29xeDQzSTI4NCt4WGRjdmpGUFB5UFdzSzNmdGFWKzRqZlFLOVpaNmJpbDFydW52MWdSZ2ZSakZSdVkyWjh5OFNTcy9LRk44elQ5S2dCRUFBQUMyRkNvWTFrL0xseWY5OGRUZEpMa0RBQUFBMkNqNzkrK1hjMDVwbWw3eU5WSEVTWWtBQUFBQWdQNlZ1RXpOb3EyZGNhcW91dm9ORUZ6V1UzbDJ2WHYxWnlleFZSSnhJVklBMXk0cm5ISmZzcng0OVNrRXhpOW5iQ1FUdW1iMWx6bTFySzI0RzVaem5Md0FBRnRKdTVlV2kvWmYvdngzTmRmdTZodEh6cXJWVFhWbXJsMTJBZlMzVnJlbkY4NjMxRWt6UFhicXZGNllhWlVCUm4vam5iZW9rV3pQVTMxYlJhSmo2WWdtc3dFOTB4c1gxbDdMSmNLbFZhelI3YnVHRlB2dU05Tkx3clV3NVg4QVdFMzc5dTJMdXQydVB2Z1hQNmdzeTl6amp6MmV0bG90T3pNelE3dXBEV0w4UDVzbHFoU3h6UFQxeWl0TEtwSzJzdXFDdjkwV05wWXhTbjN0Yzl0UHBnRmhXL0hISjRwTzRmTGMwY0lSMkNDSGZmbUlDcnY0c2YvOWh4L1pkL3B6bllrSmtid0lBQUNBTFlHS3VQV1RLZEladjJzL0t3QUFBQURZSUdOall3SUFBQUFBWURPTFZhanVENzBOUllXS2lsYWRjMWtaWHVTSy9GWFBEY1N4cWhXQ2Z3RmN1MTVXbEFGR1haZXJlR1dRa0luQ2Y2bk1MMXI5QUtPcVMyVnpLK000RnhvQXRwSTBkK1U2NVhPUEhDMERpNTQvTnljQW0wZWFGNXBaNnBUbDZiT3phbGJqTXNEb3czZmVzRzBEakhvdTF2bWMwNXpSUDJLL2Y3WnZ1SzdKeFo3Zlh5UGdHZ0Q2VGJQWnRMNW9ZR0JBN1haYlowNmZLU3Y1WjJabWhBM2lqSytEck1qNGFzZ2txeXBMcXI1T05GRWVkeVFDakRhY05jcXNNYWtwcHhDMmt6REIvU0VLWDQ4a0FCdkFINkViOFQrL080MTFEemFTVnZLZzd2VTdtUSt5TEFZQUFNQ1d3Skc5OWRQeTVXRmpUTk1WN25kOTk2MU83a1lCQUFBQUFBQUFBQUFBdUd5ajdVbmRjUDdQVkp1YzB0emN2RmFkV3c0dWN1N1ZaKzIrcC9tQzNwQ2NFd0JjcTJQcGtLYnlBVDNkMmFHRklublpjOGFZOHZMWDRScmx5MlYxSGRyNUR1MU14aFM3WEFDQXJlTzNIbnBja3d0dFBYZHVUbmxCZXhkZ3Mvdm1zVWtsa2RWTnUwZTBlN0Nobjd6bkRRS3dzU0pyZE5PT3BzNjB1Z0lBOUs4a1NXU3QxWHQvNEwzSndzS0NQVDk5WHNlT0hjdVBIajFhdEZxdE9NL3oxYTl3dzJXSnNycHM3cWRQcnk1bkM2VURVNzZicWVlN0FOWlA0VnpkMXgwbC9sQm9wVHdlc1FXME16Zm5oeXNjOU5oV1YzbGRtNk5JbHk4Y1RnKzFrT0dDSFpjS3hJcDhEMVlpVnIwWDhtTXJOczRNRkVidmNJby8rcWI5MmU4K0tKMFFBQUFBc0FVUVlMUk9KaVltTXQrWi9mVFBmWHJTUk9ha2s3dGRBQUFBQUFBQUFBQUFBSzVJa25mVjdNMnJ1WFJPK2VLczF0UGg2SG5kNWs0TEFLNlY2KzFVa2cxcHNwTkxSVjNycVpFdHF1RUdCQURZV3A0Nk0xc0dHQzEyVXdIWS9HWVdsd05TbmllVURPZ2JJY0NvV1kzTGNERUFRUDhLNFVWSmtwZ2RPM1pFalVaRHRWcE5zN096aXVQWWJaV2dqczNLRkpHTWZNa3IvbzVUWHB1WGM2eFhnWFhuRkRtWmFDc3RFZ3ZuMHJ6UXRydHF3MHZYdzloZ0liem9VZ0ZHckhrdnhsaG41UGN3elppUk81d1oxUVFBQUFCc0VRUVlyYlA3Ly9IOTMvQ2RiMHo4d3NRdittN3E1RzcwM2FZQUFBQUFBQUFBQUFBQUFBQUFBTGdDWitlVzFNbHlmZjZ4WXpveHN5Z0FXOHR2ZitWSlhUZlcxTi83QzI5V0hNSlRhb2tBYkl4YWJIWHZEZU02TmQ4UnRxNmpNMHQ2OFBrcDNYMXdUTm9yQUp0Y3ZWNHZ5NTQ5ZTZMNzNuZGY5UFRUVDZjTEN3dnVvUzgvRkMwdExabHV0MHQ2emdZd0ljN0NHZFZuRHBiM3EzUDdsQ1dMYXU4NDRoL081U0tDZWRkRFpJMnBoQUFOMGtXd0JUaVpycFBMdEkyRW4yNHRYdjhmY082a05IZnBiTHVZNithdTFzN2Q2N1dMRGRNbHJVYW1WNDlNT3Rhd3cwbGtLa0p3dHgrZGQxdXJyLzcwWis3Tkh2YlZ1dzlPUExpdDVtTUFBQUJzUFZTMmJSU25KZjkzU2xnMTdnSUNBQUFBQUFBQUFBQUFBQUFBZ0MxdU1VMjExS054SjdEVjliSkNlY0dwa2NCR0N5MzhZeXNsa1ZGRWEzOEEySFNTSkRHaERBME5LWlJxdGVxaUtHSWphNk01STFORXNsbFZKazk4cWZqN05IZGJEOVpvYTg3L1JybmJxc04yRFVKcnU5RGticlZIREczNXRwYzhMNHJjVCs1Y3p1cHlkb25NOG44L2c5anduc3kvTlN0Y0liekU3MTJPK002SUFBQUFnQzBnRmpaR3BOL3hmeit2UXYrSDc3NWR1R2JHbUZDTkVzN0dDVFdWSlBFQ0FBQUFBQUFBQUFBQUFBQUEyTksrZSt5Y1RzNHVhckhIeGJtQnJTcUVGejF4NXJ5RzY0bnViT3dVZ0kwUndvdUdxckgyRE5iMGhsMURPclBRMGRsV1Z3Q0F6ZVB3NGNObEc2cGJicmxGN1hiYmZmM3JYKy9OejgyYnh4NTdMQkUyVEpSWHk1S2NIbEVSZFpUVkZ0VVpPdVc3YzhMYWlZeGNaSTNiYXBHTWZwTXRqNHlaaW8wSjdjckdoQXM0WlU1YTdXeGNZMHlvbE1yOGpiQXNqWVF0N2VSaWNUNHZWTWtLZDNtL0w2Zll6M0p4TDNlMVh1NW5GSmZOKzkvbjB1NkJhQ1MyaHJTNndPb2ptWXZlZmNzdCtjODhLRTBKQUFBQTJNUUlNTm80cmZLdjA4TXlDcW14N3hTdXhYa2owL2JqY3RvVmJ0aDNEd2tBQUFBQUFBQUFBRnkxMmRrWnpjN002dlRwazByVG5vRExaYTNWNE9DUWhrZEdkZmp3OVFJQWJCK0xpNHY2OXJlK0x1QnEzSHJyRzFTdDFqUTROS1Fvb3AwTGNMblN3cFhoSmx6bkhzQldrNWhNVGR0VDNhUytFTksySG81bkkrbzV0c05lVHpPSmRkUFlRTG4rSmNBSUFEYW5jQnlqVnF0cC8vNzlkblIwMURpL1F6VXpNeE5LMGV2MWJGRVV3a2FKWk5PcWtzVlJSYjZiSlV1U3lWVlV1bktHNmJLcW5LeWY5Nk90Rm1Da01HUnl1Wjl4MkxCOWhWQjFGTUtMVnJzS3lSaGxmajVxRzZlS3NHV0ZPc2d3NzJTRnEvbUtTT3Vudks1R2xpc3BqSXY4NTVRZkVOc3R1QlM2VXM0ZE5ETE55cElkK0pHSjIrZi83Y1RqbktBREFBQ0FUWXNBb3cweU1URngzbmZPVDN4cTRnLzk3dHRqZnArTkFLTnI0SGZTWHZDZFdlUE13Nzc3Qmw4SU1BSUFBQUFBQUFBQTRCcWNPbmxTVHp6K1ovcmpQMzVBVTVQbkJGeXVTcVdpbTI2K1JZY09YNi9ESC8xYkFnQnNIMHRMaS9yMS8rV2ZDN2dhZi9QSGY3TGNmcmk1MlNUQUNMZ0N2VFRYVW85Z0R3QmJUd2d2T2xTWjFaNW9RWHZpQldIdC9lZldyVHFURHdxdmJjOWdWZmRjdjBPdE5OTVQ1NWczQVdBekNzY3hmREZ2Zk9NYksxbVc2WlpiYnRHamp6NmFQL3JJbzhYOC9MdzZuWTRWTm9UTksyV0pld1BsL2M3UWFSV1ZqcnJ4MmF2TnlzQWxHS3ZJR2xOeDV1cURTUHFTQ3lGbEpyVlcvSTVmSVlSZjU0VldQUVRiR1A4VE5XYkJkeHVpcmVxVzFjM2R5anpVdkpabFJscW9GcnE5ZkRsUUsrYVg2cG5idzkrNGtnN3ZQN1JyVGlMQUNBQUFBSnNYTzRVYkxkYmpTblZDa1k1cWVYb2NFSzdFMTN6bFVzZDMvN1hmRGE0WlkvYjRranB4U1RFQUFBQUFBQUFBQUFBQUFBQUFXMXNTVzlVcWhINEIySG9pT2RWTXFxYnRhc1MyaGJVWG0wSjRmV1AxUkhmdUhkYkRwK2NFQU5qOHJQWDdWTFdhRGgwOFpFUDMzT1E1MTJxMXNoZGVlTUV1TFMyWlBNK0p6ZGtRWWJRN3hkMUJ1YlF1VTBRcWJLYTBjVjdPYjdPNEtCV3VUV3hNTllsTVpHV29WTUExY2Y2bldqaFhkZHBpWVZoNG1WN21Gaktuc05NNHJGWFF5ZDFDVktob1ZNeXFmTjZXNEtwMytqWGNQbi9yOHdJQUFBQTJLUUtNTnRqRXhNVGpaZmNYSm83NVRzM3ZyQk5nZEFWYzRiNXVqWjJkK084bmZ0MlB5OFBLOVZFL0RsUHFPd0FBQUFBQUFBQUFBQUFBQUFCc2RaVm9PY0RJY0w0VWdDMG1VcUdheWRTMFBZMUVIV0h0eFNZWFh0OVlJOUdkKzBhMDUrbEpBUUEydjVVQW80T0hEaHBmb3BNblQ2YXpNN1BGM055YzBqUzFCQmh0SkZNR0dBVlJyeWtYOVpRblMzSTJVMDZBMFRVTGVjaEpaR2graFd2bW5LSkNxc3JKQ2x0V08xTXJLMXltMVFvd1NsM0xHdjk1ZFV1QTBZdWNjM2Y1ZGQrc0NEQUNBQURBSmthQVViL0k5U2xmNnpQbWQ5VS9xK1hwVWhNdXBsVVdwODg1NDc1bWMvdGxmNHk2SndBQUFBQUFBQUFBQUFBQUFBRFladDYwZjRjT2p3OXBJSWsxczlnVmdLMmxYb2sxV0t2b3hwM0Rxc2EwQlYxdmMybWt4U3pTZWtoc29XcmtWUFhkeERxaGY4WFdxSmxFdW4zWG9IN281bDE2WW5KQngrZmFBZ0JzRGVNN3hxT1JrWkZvZEd6VVpGbW1yMy90NnozZk5VOC85WFRzNU1oNjJTQ204TnRrcnFyRzlQV1N6WlFsaTByck0wb2Jzd0t3c2Z5eXNWckl4SVhSK3V3OFhVVGhleUF2V0VhdnBiUW9tbW1oVmR0WjdlYXErZ2xXRVY3aWYwdjMrQkpDb2lZRUFBQUFiRklFR1BXTGl2N00vejNnQ3BjYkdZNHlYMXJZQ2V2NmNmU0VzZWJicXVyb3hNUUVBVVlBQUFBQUFBQUFBQUFBQUFBQXRwM2hlbFhWQ3FjQkFsdFZDRXFweHBHYTFVcDVHK3VyVjFoMWl2VnJneHVaRUY0azlEbHJURm1HcXJIMkROYjA3UGxGQVFDMmptcXRhdjFlbGdZR0JzcjdUenp4aE90ME9uNEZFRUowakNQRWFHTVlaOHRpZTAwNUc1b1ZHZVVKNjJDZ0g3ellEdEthRGN4aHpaMHpoUlBMNXpWVU9KTVVoVnUxcWV5blYyUllwNzZNbjRYM21PVzJzd0FBQU1DbXhaa0wvV1BlbDZQVzJwOXh6cjNMNzNIOGJlRkN4LzA0K1lZMTlrRm4zUi81KzFPK3pCSmVCQUFBQUFBQUFBQUFBQUFBQUdDNzJqbFVWMmc3OUNOdnYwbm5sN3I2bDE5NVVnQzJqdi9MMjI3VTRSMkRHcW9ud3ZyNzArbGhQVHJYMUhvNDFPaVU1ZGJCSmUydWNXcnNadkRXZlNNYUcwaDBwdFhSYzlNRUtBREFWdlhlOTc0M0tZcENkOTExbDA2ZU9Pa2VlZVNSck5WcTJmbjUrZlZMT2NUTG1DSlcxQjFVdlZkWGZmWTZwZlU1RlpXT09vTm5YZ3czMnNCK0MyV1R4SEZFdmtlVEtQUXYrU0hZL0xMQ0ZmN1hYd2hycGloY0V1b2dWMnVaVWFnWUZGN0dqOW5kb2Z1SjMvN0FEMFpGUHZXclAvbkFkd1FBQUFCc01nUVk5WW1KaVlraUZPZmNjWC8zZWwvbS9lMnEzNm1yYXZ0YXFUaVk4dVBpcEI4WHgvenQ0LzcyaWRPblQ3ZC80emQrSXhVQUFBQUFBQUFBQUZnVGxVcEZqWUVCN2R3WnpwRzZpcFBROGt6T2w2TFhrdXZRZ0djek1aV2FUT3hMcFNxVDFIU2x3cnd6TWpLaVd1M0szd3NBMlB6R2QrM1N0Y2puenBaZGwzYUV6U1VlUDZSckViWWhRZ0Z3WmF3eFpUbThZMGhEdGE0YWxWaHBVU2pOYWJNRmJHYk42dkxwdlFmSEJuV2RMNVpHeFJ1aW14c3RaT3VUVGJDVVczVUxxOXd4clRlTFJpWFNlQ1BSVUxWUzNsNUtjMkh6Q3cyeVE2QURpMTBBSytyMXVna0JSc1BEdzFwYVduS2pvNk95MWlvOHRyaTRmUHpMT1Nlc0wrT3NMNzRlcWFnb3lycmxvVXliVmVWc0pCZWxjdjZmZjRIV201ODErcDRMTTZ5UksxZDNabXZHRi9rcGIvMWcydVhmSnV2MTdTQk1hVWRWMkpwYTdRV0cvMlZ1Z2lYbXVpc3JnNXpMeGd0bmFUY0xBQUNBVFlrQW96NHlNVEd4NUR0ZitQVFBmWHJXUkdiQTc0bTl5OSsvVzl1VXJ6QmM4SjBwWDduN00zNm45TGdmUDZUR0FnQUFBQUFBQUFDd1RtNis1ZGF5L01VUC9TVmRqYUk5cSs0TGoycnA4Uy9xL0JkK1JkZzg2amUvUi9WYjNxbUJ0L3l3YWdmZUxBQUFMdGZPbmJ2MHozN3RmOWUxT1Bkdi80RzZKeDVSKzVtSGhNM2w1bC83dkFCc25JLy9oVGVWM2U4ZVA2ZnBWbHRmZWU2TUFHeGUzM2ZqWHUwWmJwUy83ZkVtQWNGQVA5clpySmJsbmtNNzFNc0xmZkdaU1VLTXRvQ0JKQ3FuYXkxYW4vQXlBSnREQ0N3YUdob0t4ZDU2NjYxMmRuWldvVHp3WHg0b0ppY24xZTEyTFNGR0cyRTVTU051ai9naUphMmRDaTJSRm5ZL0lXY3o1Y242WG1BbEJIdFVJNk9PN2U5NXdjL1BQZVBja3UvVmhpOVZiVDAyeTkxWVptUzdmdE1zOXRNakpzRUl3S1ppZjdDdzVrbC80NDhFQUFBQWJESUVHUFVoNDB6SFYxNGU5VGR2OVBWcDRaS0NzYmJYdEdyNWt2bnliVittUW9taWFFNEFBQUFBQUFBQUFBQUFBQUFBZ0V1Nlk5K1lwaGJhbW1wMWxCV0ZacGQ2WmFoQ044K1YrbTVCbTFxZzc5UmlxOGdZMVN1eGh1cUpMeFc5WWUrb2RnM1YxVWc0elJmb2QyT05pbTdhTWFDSGprWUVHRzBCWVhtY1JFYVJGUUJjVWh6SHF0VnEyck4zai9GZE56MDk3WHE5bmhaYUM4c3BLZXgzYll3dzN2MXlQT29PbEFGRzVYMmJLNDk3eTArYWRab3dwdnptekhjaUo5T0hheFRuL0tvdU4yWUx6Nm5HV1NkclE2NFlQOGZ0d2MvVHptM2xlUnJiemJoVURBc0FBQURZaERpeTJZOFNQV2xraml0WHpjbUZTMlB0OEtXcDdlTlpQL3h6eHBxLzdaekxKaVltVGdnQUFBQUFBQUFBQUFBQUFBQUE4SnArOFNQdjBwbTVKWDNoc2VNNmZyNmw3eDQvcCtmUEwycHFxYXZweFc0WlpnU2dmMFRXYUx4WjA0NUdWWWZIQnZTdUczYVg1UzBIeGpYaUh3UFEvejU0eXg3ZGMzaGMvL3FSazhMbVY2OVlqVFVTSlhFa0FMaVVack5abGc5OTZFTWhzTWo4eVovOFNUbzdNNnZ2ZmU5N0ZlZWNDc2QrMTBZd0xpclRhZ2JPMzFBR0dPWEpvdExhbkxxRGsvNStLbWZXSjJqUVduVXIxclQ4N25mRDkwNURmU1l5SnE5R2FrZFdkVzFCZnB4YlA3SHJ4VXA0RVpFMjIwSnNWZmdGY3RFV3NQbjVlZm1lOGk4QUFBQ3dDUkZnMUljZWUreXgvSTQ3N3VnbzBzT21NUC9mUW9XdjFUUnYwaGJuNUI0MXpwejB3L3BIL3U2a0w3TytVSE1MQUFBQUFBQUFBQUFBQUFBQUFKZXBXYTNvTGRlTjYvRDRrRzdlUGF6LzlNUVpQWEptVHJQRm9vcGVKZ0Q5bzFhSmRPZjF1M1JEQ0M4Nk9LWURvMDN0SHgwb0g4Zkd1Mk40U2FQSitpdzN3L2VNVmpJTnhpeW5ONXRHWWhYYml0N3RmOE9UcmE3KytNaVVzSG5GMXFvVzJ4RHVJQUM0WEljT0hiSjc5dXpSUUhOQWk0dUxPbkxraURydHR0cnRqckJCbkpYTnFxcTBoMldLU0huU1ZoSDFsRlhuNWFLMTNkNktaRXd0TnFhYnkvVHkva3ZQaWEycjFDdlJrTy9QUk1BV1lZMk1NeVMrYkVhcFgwNkdUZS9ZTXZrdVVQVmpZL0R2Zk9iZXcwVlByZC80cVFmWnlRUUFBTUNtUVlCUkgvcTMvL2JmNXFGTVRFdzhMS3N6ZmcvNkRYTGE4Z0ZHZmpnZjlaMXZ1cTc3M2Z2L24vZWZFQUFBQUFBQUFBQUFBQUFBQUFEZ2lqUnJ5d0ZHSzQ0c0ZqclJrWTYzSldkU0FlZ2ZGZjk3dmZQNnZicHozN0ErY3ZzK29iL2NNYlJZRnVDMU5DcXhMOUwzSFJ6VGJDY2x3R2lUQ3cybmEzR2t5QW9BTHR1aFE0Y2k1NXdPSGp5b3lYT1RtcHVmMWZscEVXQzBnWXl6TWxtdERER0t1ME5LYS9NcUtoMWYyc3JYT3NESWhIV0pzYm1mSjNxNStvN3Z2NlFlbTRSMUhiWVNZNncxNFlldi9nc053MnRMaXpLQXltK0hDMyt1VnNnTnhZb1BLOG5PK1B2c1pBSUFBR0RUSU1Db2o4MTV3OFBEUGVQTVE3NHlzNURSQi8zRE5XMFJmcGpheHBoemZyaWU5TGNmc3M1K1U3bU91N3FiRndBQUFBQUFBQUFBQUFBQUFBQUFBQUJzQWgrOGRaYzZhYUhmK3RZeHRkTmNVMHM5QVFDMmwwcWxvbDA3ZCtyZDcvNCt6YzdNbHVYbzBhTTZkMjVTdlY0YTJ0QUk2ODBvQkpwRWFWMDJTMVF2RHFtd3FYck5zM0xHS2ErdWZsaGxaRjJsSHB0R056ZHhYNFdwR09YV3VXNXNGU2VSRW11TUFBRDl5UytobTBiRmJjVnk4KzhuQlFBQUFHd1NCQmoxc1gvNlQvOXAyM2ZhRTUrYWVNWVlNK0RrN3RVV0NqRHl3NVFibVJsZkgvZU1zZVkveWVyNHhDOU5uQmNBQUFBQUFBQUFBQUFBQUFBQUFBQUFiQkszN1J3cXUyT05SSzF1Um9BUkFHd3p4aGhGVWVSTFhUZmRlSk5tWjJmTE1qTnozbmRueWdBamJCUWpteWZscmJKcm5MTDZuSnpKbFd2MUE0eXMvN3BLcEdyVWIvbEF6Zyt5TWFuMVBSaGJrd2dBMExkTTJlN2I3dkhsakFBQUFJQk5oQUNqelNEVzV6V3JCODJRdWRQZjIrUHJqTjZsVGM1WGV2MldLOXd4WmZvM1BkT2JTNUprK3JISEhzc0ZBQUFBQUFBQUFBQ3d5cDV0MWRUT0k4Mm5zUXJYMzFjVHJVZTUzajYySUFBQXNERUtKeTFra1JiU1NFY1dHK3AzSTBtcTRVcW0zYldlcXJhUHJ1Z09BQUFBYkZPLzhWKy9WZDg2T2FOUGZ2NHhwVVdoVGxvSUFMRDlEQTBOcWRsczZ1emttWkNhbzJlZWVwNFFvejVnbkpYelZXaU5xUnY5blVKNXNxaXN1cURPMEtTY3ljcHBkYzNmNGYvRnhxbFdNWXNEaFYxcXA4V29yM1BjOFBaNzFjakU0M1U3V0luVTN3ZExWNGw1c1d5UG9iMDhOaVNpMk5DbVR3RDZuRjlWalRnVmQvdDFWVXNBQUFEQUprS0EwU1l3TVRIUjhaM094QzhzZDdVVk9JVXo3K2RWMVpsRVNjOFBJNWNaQVFBQUFBQUFBQUFBYXlKM1J0M0NxdU5MdndjWWNSSXRBQUFiTDJ3dmhCSzJIZnBkMk1iSjNNbzJEZ0ZHQUFBQXdFYmIxYXhxMTBCVjFwZ3l3QUFBc0QxWmE4c1N4NUhpU2tYb0Y4dHJaMU5VNUV3aG0xZDlaV0JiSnRTdCtYWDNhdFN1R2JQeVBTNThhaEdLK2tSa2pkMU9XeWRoV3JBMTluS01FMkR6OEwvVm11bURBRHdBQUFEZ1NyQUJ1NGs0NDM3R0dCTzd3ajNzcTdJaS8xQlRtOGVTazB0OUJlekgvTzNKaVltSkJ3VUFBQUFBQUFBQUFMQU9ubHBvNkhTbnFoZmFWYVY5SGtRd1dzbjBudkZaQVFDQWpSR0NnR2JTaWs2MUUzMXBjbFQ5N29hQnRpOGRqZmh0aUhyVU4yMmhBQUFBZ0czcjhHaERJL1dLZnY5djNxM1BQMzFHdi96SHp3ajlyNWxFdW5GSFV4KzVZNjgrK3JaRGFsUWlBUUMyTnVPc290NkE2cUhNNzFlV3RKUlhGOVVaUHFHODB0YTFHcWlZWmowMnpWTUw2cmF6b2kybjJrYWxHNDRrZHFvU20wcWpZb2ExVFlTa3BscE1WTStGakRHcStGRVNNVnEyaEJDNDFzbGNPYThuVE5RdHlJejRQeitRdStLb0FBQUFnRTJrL3k4Vmg1ZjRpb0xNT1pmNW0rZWQzTFhYaHEwRFg3ZVdham04YU5wM1QvalM4Y1BRRVFBQUFBQUFBQUFBQUFBQUFBQUFBQUJzTWJHeHFzVldROVdLeGhzSllUaWJRTDBTbDlOcXdIZXRNV1VEZndEQTloSUNqVXpoUzFhVjljVVVVVm11K3ZOZUxIRWtGNG8yZ0pFclFvbXNySlZqNVlhU254bmRDcTBDNStjeDM4bTBrWndMUDladHQ5SHRObVRKZ3ZWa1pLT1BmdWJlMnIwVDk4WUNBQUFBTmdFMlhEZVJpWW1KTTJYMzV5ZCswZS9jMytyM1FENnBQdWY3OHpsL0NPY3BVNWpmOUhQYlEvNmgrZnZ2djU5TC9nRUFBQUFBQUFBQUFBQUFBQUFBQUFEWWNwclZTSGNmSE5QNFFGWDdodXI2elc4ZTFWZU9UUXY5NjlCSVEvL3pmL1VtN1dsV05WU2xpUVVBYkVkUjJpaExaWEZIbVR6VUdUbWhJdTZxMnp5cnF4RUM4YXovbk5HYTBWQmhkYVpWS0YvbnNKRktiR2Q5THhRN0I2SnhBUy95ODJWbWpBbUJReFd0UXR2U3lKcjUySmc1UDgvdjluZHIyZ0JKYkVjS3QvM2lmTUlBRjRRWWJXbCtWVExlVkh6MzdZZXlKeCtVemdnQUFBRG9jOVN1YjBhRm5qWFdKRTd1dUwvWDhLVnZLcEpDK3JLdnhFajl6VmxmanZyYmovaitmZFNYVS81Kzc5T2YvclNibUpnUUFBQUFBQUFBQUFEQWVobXBaT29WUnFrdmVaOWZYTFFaNXdJQUFCdkgrRTJGeEJRYTlPdmtmYld1K3QyT0pQWGJENW1zb1pVQ0FBQUEwRythU2FTYnhnYjA5Z01qQ3MyTHYzdHFUa3NwOVgvOXBCWmIzYnB6VURlUEQyaXNYbEc5RWdrQXNOMlowRGhLVVc5QU5rdFVtRXd1NmltckxxbU1DekZYZGszM2lqR3h0Y3Byc2Nsei85Wk83a0xiSzJ1TXNWb2ovdnRTL3dYRlFLd2tCQ2x0Qkd2VThnTnFDNW1HMEZmOExKSDcrYUxyWEJFNVhmdjhFV1prRy81czRHRjQ2MytsTXRzdndBaGJuMTlqSkViRldHelRSQUFBQU1BbVFJRFJKalR4anljZW1waVltRFdGK2E0ejdqcS9KOUkzQVVhK0FzM3Y3YnUydjNuYU9QTi91dHg5N2Y1L2ZQL1hWcDRudkFnQUFBQUFBQUFBQUt5MzNiV2VHbkdoMFNSWDBlY0JSclhveWs1NkJnQUFxOHZJYVNET3k2c1czejYwcEg0M21xUWFTekpWTGRzUUFBQUFRTC9aTTFnclMyak1mZWZlRWYyUGYveVVuanJYRXZwSExZNzBrZHYzNnZCb1F3ZEh5RmNBQUlUVnRpbi9Kb3M3NUl4VDNCNVJsaXlxMkhIRTM4L2xydkJZWGlVeWNVVW1IcTJwblJYT25WbDB4aHBqZmZWalZXdWtZazB2c2VydXFFY2pzVjI3b0tUWDRyOTMydm5oTG5MSENyYlArQm1pRjFzdFpvV3RPT2V1T1JURi8yWk1YR1pXYlJ3L3YxV1d6d09nbmh4YmpXbjZQd2RkYnA4VUFBQUFzQWtRWUxSNVRjbnA5LzFPL2p1ZDNBMytmcWpRMmRBa1ZkOHY1M3kvelBtYnYrY3JNS1pNWWI3bTU3QVRBZ0FBQUFBQUFBQUEyRUE3a2xTRGNWNDI3dS8zNnk3R2xndERBZ0N3a1VJVGh4QW9hSXpURFFOdDlidTY3OWQ2bENzMmJFTUFBQUFBL2VyZ1NGM05KTllIYjltdDIzWU82dk5QbjFYWWd1OWxOTERlU0lQVldEc0hxcnIzaG5HTjFDb0NBT0NWUXBXYktXTEZhVjIxdVgxeVVVOTVwYU1zYWFudzNTdFJqVXdsc25KamRhc3NkMjR4ZFV0K1M2RGlqMTFlODBySXlQbVBNcjBra2swaVkycXhpU3JXMU8xeUdoUHdNcEcxVVRYT0swWHFvbUlWcXBYalNKVWtOZzNyUDFvYmlKbDliZVIrSG5GK1FjVVJpSTNoNSt1Njcrd3hOcTRMQUFBQTJBUUlNTnE4cHZ4dS9lOHJWK0gzUkQ2azVXbTVvUUZHb1o5ODNkWUpZODJ2Kzl1ZGlmOSs0b3dBQUFBQUFBQUFBQUEyMkhnMUV3QUF3T1V3WmlVVVNCcXA5SCtBRVFBQUFJRCtkM0NrNFl2MHdZVTlPdFBxNk1IbnAxUTRSNERSQmh1cXh0clZEQUZHT3dVQXdNVVoyU0tXZkluU2hvcW9vNnkyNkx2cEZRY1lWU0lUeC83endzVk11cmxMdTBXeGxPV3VrZXZhQTR5Y1RCRVpkV3V4c2MzRVJMWElKdUg3QkZ5RW4xZXNuMGNxdmJ3dzJTb2tHUG5QcTRUZ0xHT04xUVl4cEJldG1jTFBJeUhFaUFTamplSGs2bjRPMytOL1lBUVlBUUFBWUZPZ01tS1RtcGlZeUgxcEtkTERKamYvbzdQdWIvZzlrdmRxSXpoOTN2ODk0N3VmelpTZGpHMGNnb3M0b2dZQUFBQUFBQUFBQUFBQUFBQUFBQUFBM2p1dkcxRXZML1NyUC93bXRYcVpmdW1CcDlUSmNzMTFDR0RmQ0IrNVk1OXUyemtvQUFBdWwzRVZ4ZTBoVlNxTFpaaEhYbDJVczVlL0hnOFpLN0gvWXlQRmV3ZnNjTzVrL2FhQnVya1cvVFpDdDV1N3d0OTFmdk5neUw4MGhNRlVYdDBQYmtuRzVFbWtydldmT0pDWWNmOTVVZDJhQVd1TmlleHlRSTJBUzZoRXJtcU5uNVV6eFYxZEE2UGMvdzZ5eEJyYnFOakUrbC9EOGx5Ky9pck04V3NtOGpOTEZHTFN3cVFseEdqOU9kWDhnbitQYzY0aEFBQUFZQk1nd0dqemNoTVRFNWt2azM0djhFbS9NN0trRGVKM2dNNzZ1b1pqYXVsYnYvU3J2elFyQUFBQUFBQUFBQUFBQUFBQUFBQUFBTUJMeGhwSjJiMXozNGdtVzEzVjRraFpRU3ZnalhKNHBLRTl6Wm9BQUxoY3BvZ1VvanhNVVpIMUpYZFhIdFppalA4RVV3WU5WWExuRkRZRkNybk1PWk9taGN2bGpIL0VGWmZNQ2pFbTk4OWxzVFVkL3htMkdvZlBrNmxYTEcwRWNWbXNNWDdPOFIxZEkxZk9vb1dmcFcyMFBCdHFvMWl6Y2QrOTFTM1BLSXpmamVKbjdiQnNyeGxuaU9rQ0FBREFwa0RseE9ZMzVjdlhYTzcrblkzc3FhSW8vcEt2eDlxcHRiWGtuSnV4MXY1aDRZb3YyTXgrV3gxTlRmenFCT0ZGQUFBQUFBQUFBQUFBQUFBQUFBQUFBSEFKdCs4YzFHM2pUZjNCVDN5ZnZuVmlSdi9xNGVONmJucFJ6NS9mc092WmJpczdCNnBLSXFNZnZtMlBEZ3pYQlFEQTVYSW1WMkV6WmRWNXBmWHp5MWxEMThES3lQclBHRXJNa0V0TWM0ZXo1UWNXVXZRYWIyc2E1NXd4WmpEYzZkZmNGaWNYdVRDSTY4eVBqOXdhYzk1R0ppUkhEZ3V2c2pMZk5SUGJqbTJSem5WZHMzQlhQcTJxZm50cXFHcFVyNWpsTi9mSHZOanhnMmFkVVNKc0NqVmFONzhPTSs2WHBTTitzVDh1QUFBQVlCTmdFMytUbTVpWXlId24rNFdmKzRVcFY3aGp2Z0pxUWNzVkxHdTFvOTN5WmRvYWU4clhKaDMzMzNkTU5VMU4vSStFRndFQUFBQUFBQUFBQUFBQUFBQUFBQURBYTBsaXE4SzVNanhuc3RYVjRaRUJkZEpDclc2dTgrMWUrWnFzdUxaQUJGemFTRDFXTFlyVXJNWmxBUURnY2hVMlZ4SDNmRGVWczRXdTFYTDRrQW01TCtGV3RCSUFFNzNPMjE1ODU3cUhBMTBKNjN2Umxac3o2NzlOWTV6TGpWTXVYTlRLZkJmNWFWT3haWmhSRWFaVDRjenJ6bFBPTFUvVnlMOHY5cVhpYjBSK0Z1NmJJQzJuckJ3MGJCcTJYMVBZK2tkc1FodHdSenR3QUFBQWJBNXN1RzRSdi9pUGYvSGYrODYvbi9pRmlZTysrM1luOXhhdHZwYXZVL2c5djhQekRiOHIvenYrZnVmK2lmczdBZ0FBQUFBQUFBQUFBQUFBQUFBQUFBQmNsdEJRZDZnYTY5NGJ4c3Z5NUxrRlgxcjZ0VDk5VHM5T0wrcmtmSnNRb3pYeWd6ZnYwazA3bW43OFZ3UUF3SlhJcXd0YTJuRkV6cWJDYTJ2RUppOEttVjYrenRzenprK2V5SFN0SlJUbDlUU3J0dTQ3b2N6N3llU20yOFh3NjczSEdOTUphU3JqQTVHU1NKR2Z6algxa1NRMjA0VnoxYXdvaHdzQUFBQUFzTTRJTU5waW5IUEhmV1ZBMDkrODQ4V0hybWthdTVBNmJVeW9MWHJTbDVhdnlIbXl5SXRqTnJLWnYzL3RjZUVBQUFBQUFBQUFBR0JyTXBGTVhKT3BEU29lTzZpcmtlYUZRaHVkYy9OWGRqMkZPTEpxSkpHcUZWL2l2cjc0NkNXRmExZjIvUEF2ZFRNdGRyTXJlbStqV2xFWTdLSDYxVFhBaVlkMnk5YUhaU3Q5ZGI0cEFHQ2JzQU9qNWJyb2FyY2ZsbnBoM1prcjl4c1JXWDVscHpYc0hLejU3WWZOdWUyd1ltNHBMYmNodXVtVlhXQzhHa2ZhT1ZRVkFBQUFnSTNSOEhXWjQ0MUViOWt6WEhZZlBSdjUvWnRjTDh5M1EwTjg1WTR3bzlVeVZrKzBwMWxWc2tucmpnRUE2OCtaUXM1bWNsRnYrYlpZTC9jemE1eXhNaVFZWGFiWW1zajZtYm9lbTNMT0xzSjJwMU9STy9YOFdBempNWXpQU3JnZFdXTWpVNzVIdnR0M0cxTmgydnZlTkJtL1VXd3h6a2ExajM3bTNwR2p4OVI2Y09MQkt6dUJCQUFBQUZoSEJCaHRNU1l5ditNN1RWZTREeXJzZDhzTTZob1lheGFkWjYzOWVkOVptdmpGaVM4SUFBQUFBQUFBQUFEZzlVUVZSY083VkQzOE5nM2xWM2NWMGpPenkxY1ovK0kzamwvUiswTDR3STI3bTlvLzF0Qk9YemFqRUZ5MHNOalRVeWZuOUlRdlYrTDIzY05sZU5HQm04WjFOU3BqQjFYWmNhZ01NUUlBWUwzVkRyL2RyNHV1VTJYUHJib2FKMTVjZDU3MzY5R2xLd3dCL0lsMzNIalZBWUQ5NGl2Zk82V0ZkcXJUZmp2cVNyeGgzN0J1Zk5OZUFRQUFBTmdZQjBjYVpibm44STd5L3E4KzlLeU96eTdwdDc1OTNOZVJGbHJzWFZsSUtTN3RuZGVObGVNNWljZzFBQUJjbmhCZWxEWm1sTlVXeWhBajlLOFFXMVMxTm9xdElhbndNZzFWN1VEb0RsWnRlV0dBYnU3ODltZkkwblRUZnU2dmhOeWllc1dNUnNZa2pZcnA2eFQ4TU8wejUyeVhUV2RzTVZidVVGUHhuWWNQWlEvN3U3TUNBQUFBK2hRQlJsdlBlVjlhdmp6b1N6Z2ovd082T2xQaGM0cWkrSnd4WnRIZmZqTFByN0oxQVFBQUFBQUFBQUFBMkhac0ZNdlZoNVdNWHk5anJ5NElJRHAxUmtXVzYzenJtU3Q2WDIxZ1VPbmdma1Y3OTZ0K2NMODJvM3h4U1haNlJ0MnBKLzN3VDE3UmV6dlZNZFVIaDFTLytaMjZHbEZqdUF3dmlwS21BQUJZYjVXZE55Z2UycTE0N0pDdWh1czhvZGJKSnpYWDZXbGhzWHRGNzAwT3ZWMzE0U0Z0WnUzSC9sQUx4WUxmZnJpeTg5ZTdZZnZoNXZjSUFBQ2dYK1N5NnJoWXJTTFJiRjRUMWw3bUlxRi8zSDF3VEcvWU5haGR6WnJtdTZrZW4xelFpYmwyV2VZN21kb1pyYkt2MUVpdG9tRmZocXF4YXJHVkVRRkdBSURYNTB5aEl1cXAxNWlXaTY2c3ZuRTdzMFpWWjdUdUc1aCs3VzdqV1BYWU90cE1YcUd3WlJUeUhVUElZMnhOa2tURnNCK2RmbEk2RzFrVGJZWkVxRER0L2M0azAzNXRoQ3RHT0Y5VzZ5b1FxLzE1QUFBQUFQb0FPMlJiek1URVJBZ3cwcWQvL3RNUEdtUEduTnhWQnhqNWd6Sm5veWo2bCtHMi85eWpBZ0FBQUFBQUFBQUF1RncyVnRRWUtVdGwvSHBkalVoUHFVaFRuVi84MTFmMHZzRWlVVGE0WDNidkc5VzQ1WTNhakhvek00cVNrK284TmVtSC84cXU1TnFwN3ZERHY4c1BPeUVFQUlETko5bDVvNjZGTzVWcTBSelhiRzlHYzFlNERrME92ME9ObmJ1MG1YV1NyNnVsM2xWdFA3RHRBQUFBK2trdW80NnJxRlZVTlZ2VWhiV1h1YzNRSkhuN0NBRkd3US9kc2x0bkZqcjYvTk9UK3RyeDg4b0twMTYrUklEUlZRamhSWWRIR3hxcWhRQWpBcnNBQUpmRFNTOEdHS1dOODhMbHM4WlUvZWJsdW05Z2hpbFdzYVllVzhQRzdSV3lJY0hJdkpRNmxmaEhrdVdibXlmME1VeDd2N2xzbDNOeHNNb0lNQUlBQUFEd3VnZ3cycUpNWnI1Z1lyUFRHZmNqL3U2SUwzc3U1MzNPdVVlTnpLUCs1bGY5THVDemZwZjl1TCs5SkFBQUFBQUFBQUFBQUFBQUFBQUFBR0FkdElwRXg5SVJUV1lEZXFZM0xxeTlsa3VFL2pUV1NIVFA0UjI2ZFdkVEg3cHRPZEJvdnBQcEd5ZG0xTXNLL1ljblRndXZiKzlnVlhmdEcxYWpRaE1LQU1EbGNiWlFaK2hVR1dDRUs1TlkwOGlkVy9ma201QmFWSTFNSmRvOG1UdFlSYkUxbFdJYlpSY1pyVis4VkJScHdZL2F3dTkrckVyQ2NHeTE0RHVGTHlRV1g0YThjSU4raVRxZXBMUUhCd0FBUUg5amczV0xtdmduRTQ5UFRFenNNWVU1NjVaVGd5OHJ3TWpJblBTZGI1ck1QQkErUXdBQUFBQUFBQUFBQUFBQUFBQUFBTUE2NnJsWTUzTk9jd2FDSkxLNmFjZEFXWUtweFo1YXZheThIYm9FR0YyZTRYcEZCMGNiYWxRaUFRQndPWnpKbGRibjVHd21YQm0vK1ZKMWhkYWZNU2EyaXNrdjJwNzhoSSszMDYvVm1PV3lIcXpmVGJmRytORzdPZ2xSUnFibis1MkY2Mld5ZnBucXgzMVRDZTNCQVFBQTBOL1lZTjNhSnBYcVkwVmNmTWhhZTc5eHB1cmtxcTk0VFlnQmY5YnY5RDFsSXZOL09PZGU4T1g0Mk42eHJnQUFBQUFBQUFBQUFBQUFBQUFBQUFBQWZXT3NVZEZJdmFLLy9jN0Q1ZjM3Lzh1VHd1dmJPVkRWN1R1SFZJOEpNQUlBdkw0OGFhbUl1OHFyQzhLVlM2TDFDMVpaRVJrelYvRmZHaHNOQzl0UzFjOTNlVkZHWi9YODdHZWRueFcxUllXZlYzVWROMnNURzM3U3p2UnlyWW80Y3NZdUR3WXVpeHVUc1FkaTA5Mnk4elFBQUFDMkJnS010cnFxSnBXcjVUeGRJdUxXeUtRS0Y2dHhMbHgrWStyKysrK2ZGd0FBQUFBQUFBQUFBQUFBQUFBQUFBQ2dyMWhqZkpGR2FoWGg4a1YrdkNXeFZXUnBKdzBBdUF5bWtIdXg0TW9adjk1ZDd3QWovMzI1TWE3OGJteFB5L05kT2YxZDJZcHlpODhLNnptdnYvakxNcGRvbm5yRmpEUGw1Qkl1azdGKzhSYjNYTVVLQUFBQTZHTUVHRzFoRXhNVG9aWnMxbmUvNExzZmRjNzlOYitQK05kWG52ZDdlYitsUWk4bzBxLzZ1NWwvWFVzQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUd3aDE0ODJkTzhONHdJQTRMVXRoM01zN0h4YVJhVWpYSjBveEpJWVpmWFluTTZkR3IzYzdkQWFHNjNiUm9XZ3dtMHZzcWJuNTd1cDlacnZ0b3VCeEk0V3pybFdtbXMxREZUdHFGOU9yRTRhRWdBQUFJQytRWURSTnREcjlkSWtTYWI4elZPK0hEVXliU2VYcTlBei92NEpYN0tob2FIVjJYc0VBQUFBQUFBQUFPQUtGVVdoZHJ1dHBjV2xVS2V0UEtmS0dnQUFBQUFBQUFBQVhEdGpKT3YvR0VPZ0FRRGc5UlZSVjg0VWNwWmoxcXNoaVZWTk15VTlyUjIvaXM5OHg4VldpcTJ6SVRrSjI1ZHh4bGlyeURsWmJkR2ZzWkhyK2JtODhEZHJXaWZXLzdhczgyTlgvdmZtTjYzOStJMTBGY3JmcXd1L1ZST0N6cXdBQUFBQWJDa0VHRzBELzhQLzhEK2M5cDNURXo4M0VmdmR1Z1YvKzFrVG1aYnZmbUZpWW1KSkFBQUFBQUFBQUFCc29CQmVkT1RJRVUyZG05TE16SXljNHlKckFBQUFBQUFBQUFEZzJvWEcwWTFLckNTaWZUUUE0UFgxQnM2cnFIUWtVd2pYeGhvVGoxYWpYUzNqdEpTdFhaSk1aTXlpWDgybkE3SEdZbXRaNFc5enhqcmJpRzI5bmJsRTJwcm5udmo1L0Z5OEhCKzBYK3VrR2R0aytidk5lU2NYWjA1RHVncVIwWkl4Smh1SU5CSkhodDhyQUFBQXNNVVFZTFNkVkhSR21SNjJ4cDRyVkxSUG5UcVZDZ0FBQUFBQUFBQ0FEZERwZE1xZ290T25UcXZYNituYzVEbk5MOHpMaFJQSXlDOENBQUFBQUFBQXRyWEVaR3JhbnVvbTlTVVQxdDd4YkVROUZ3bWJ6MEFTcWZEMTZ1MTA3WUlCTnJNa2lqUldyNmhlWWY0R0FGeGFlWnphT0JWeFIzbGxxYnlOYTJUS3NCTEZrVnd0TWtXYU81dVhqNjRPUDgwS0kxTTBRazVoWkNMakNkdWU5Yk9kM3p4T2VzWFdiVGRycmJQUkJzM3V6WXF0NW43blk4bTRyblBPNUlXczc3N3U3ODlZcFpGTTVuK3ZsY2pZRUYzRTd4VUFBQURZZ2dndzJrWW1KaWFlOUowbkJRQUFBQUFBQUFEQUJsdFlXRkNlNS9yYTE3NVdkcnZkcmdBQUFBQUFBQUFnQ09GRmh5cXoyaE10YUUrOElLeTkvOXk2VldmeVFXSHpHVzlVbFJWT0o5TzI4R3JOSk5iQmtZYUdhelNkQUFDOEJsdkltVnhadGFXc05pOWN1NUJPVW9tTTZzNFVSVlZwcTFmRVM1bGJ0Uld5bGNtY2xEZXJOcW5ISnJMa0Y4R3pScllXbTRHdG5PMFpHVnVKckRiRStJQWQ2T1V1ZGUxOG9aZWJLSmRMWHN3dWVzM2ZkbXhNdHhxWnhkRzZHVTBpVzdmOFhBRUFBSUF0aVZwNEFBQUFBQUFBQUFDd2JsNTQ0UVZOVDAvcjNMbHp5ak9DaXdBQUFBQUFBQUM4V3F4Q0RkUFRjTlRXZUxRb3JMM1lGTUxtTk41STFNc0xuWndud0FnQWdLdVYxdWFWMXMrcmlIckM2b29qWndka0t6TEtqTTE3N2RUVkNtZXVPbjdGeVJWR3lnY3ExdFppYTZ1UnNaRlpEa3dDUXBoTzVPZVN5THJVR25VTHVhcWNxV2dMU1NKRjhRWWxBTm5sNzQ5SGE5RkFHZnRXeUdhRm91SVN1NU9oTjJQL0ptdFY5YmQ5ZjlzeWU0bmZLd0FBQUxBMUVXQUVBQUFBQUFBQUFBRFd6Zm5wOHpwNTRxUW1KeWVWNTF2NGtuY0FBQUFBQUFBQXJwcVZVMkp5MVUybXBxVVIrWHFJRGZXMW0xV3pHcXVUTWYwQUFMZ1dSZHhXMnBnaHdHZ05STWFZS0ZhVU82VjVZZE51VmlTRjAxVUhHUG1QYzhZcHI4VzIwa3hNVkFuaEtJWTRGUHk1TUQ5WWEzSS83M1Zjb2RoSld5ckF5QStmalRab25nOWZHL20vallxcUt6RkV2Y3pKLzcrb0VDNVdqY3ZYVmJURnBnTUFBQUNBVnlQQUNBQUFBQUFBQUFBQXJKbkZ4Y1V5ck9qY3VYTmxtWitiVjVxbWhCY0JBQUFBQUFBQTZHdVB6ZzNveUdKTjYyRkhrbW04MnRPdWFxcFJmeHU0RXMwa1VtUnB0QThBd05Vb0luL3N1cktrUEZsOE1ieklDV3VqR3Bra3NTWk9JaE1WaFRUVHpaZXlRcTV3R3JpYzkxdXIxTDkvd1g5T1pUQXhBMGxzVE1oRk1XSTdDSy9tWncvVHJCaTdtTW4wOHEzMXU2NUdhaVQyNmtQQVZsdnM5MFdpU3l3N0NSY0RBQUFBdGhjQ2pBQUFBQUFBQUFBQXdKcnA5WHBsaU5INTgrZDE1dlNaOG54UHgwbWZBQUFBQUFBQUFQcmNWSytpMDUycTFrczFLc29nSStCS3haRlZWRkR2RGdEQTFjbmxva3pPNXBJcGhMVVRXUk1DVjJ6VmI3WVUvcGJwS2l2emh5NlRjWEt4TldrMU5sRzlZc3Y0UmpJY2NTbld6MXB4Wkl6Wll1RkZRV1JVNmFkNTM1WlJTdndZQVFBQUFCQmdCQUFBQUFBQUFBQUFWdG1aTTJmVWJyZjE1VC81c29xaVVKYlI2QVlBQUFBQWdJMXljS1NoTy9jTjY5bnBsdVk2cVFBQWwrZGNwNkxuRit0YUwvWElhVit0SitCSzNibDNXTFB0VkY5OFpsSUFBS3kxVnJTZ2NNbWF3ditydUVUMW9xSE55WldoUmIzR2pKYkdueFBXVHkxZURqcTVmcVF5NUp6VXpaMHk1M3BMUFRmajc0YVRDMTQ2d1NDSnpRNy82bWlnWXVvbTNMVm10NERMVUlsY2RjaWFhc2ZQVFYxdEdXRlFpbXBzYWhWclNBd0NBQUFBMEhjSU1BSUFBQUFBQUFBQUFOZkVPVmVXVHFkVDNsOWFXaW9EakZZZUJ3QUFBQUFBR3ljMFo2Sk5FOUMva3NncTRqY0s0QnFFNVVnb3VMaHduS0xnZUFVQXJCcS9SQzI3cWVtV3R5SVRLZnl6THBMUjV0cXVMV3dxWjNKaFk0WGRvY2gzL09hTWRiNGovZms2MjVyd3RHR1BDVmZNdkZnODUyZWdzRGtZYVpQelcveGhnY1ZHTFFBQUFJQytSWUFSQUFBQUFBQUFBQUM0SnQxdVYxbVc2ZUdISDliYzdKeE9uejR0QUFBQUFBRFFIK3B4cEtGcXJJb2wyQURvTnlGdzVQYmRROW8vWEJjQVhLMndISmxzZFlXTFM0dEM4OTFNM1p5MjNnQ3dHcHdLOVV4UFR6Y2VWK3dxcXVjTjdVeDNhMmUyZTFPRkdCVlJwdmJZTWQvdENCc25KQk5Wb3pKcXBsS1B0VlBBS2dteFYzRTVmOW41WGw1MDByd1lMV1FTYldMK3Q5THkxUWhkWDhOWEZlMkNBUUFBQVBRaGRsUUFBQUFBQUFBQUFNQlZDY0ZGQ3dzTG1wbVpVYWZUMGNMOGdwYVdsZ1FBQUFBQUFQckhTQzNSbm1aTlViUTVHcEVDMjBuSUZXc21zV294QVdQOWFEVEp0SysyUHFFd081SlV6VGhUYkFoWXdaVUw2L25DTWU5Y1NpOHZkSDZwcDNhYUN3Q3d1bGJDakJiaStmTGVRRDZveVArcnVycXNzMzBiWnVTaW5pOXBHVjVVK0M2QXJhdGlYVkt2R0tXRnNkcmttOHlWS09TVW01QVVGd2tBQUFBQStoQUJSZ0FBQUFBQUFBQUE0S3FFOEtJanp4L1JDeSs4VUlZWWhaTzkzR1kvNHdzQUFBQUFnQzFtejFCVm9jMW9DRWtCMEYrc01Sb2ZTUGg5OXFtOXRaNjBUbzN1UjVOVVkwbW1la1RBQ3E3Y2JidWFhaVFFb1YzS1lpLzNwYTM1RGdFVkFMRGFjcE1yajlvNkYwcmxqSGIzOXFybTZyNjd6ei9idit1bXZOSldFZldVMVZvQ3NMWFZZMXNQd1QvdDFLbWJiKzd6V1pMSURGWmowN2ZoY0FBQUFBREFFVThBQUFBQUFBQUFBSERaUWxCUnQ5dlYyVE5udGJpNHFPbnBhYlhiYmNLTEFBQUFBQURvVThQVlN0bE5Jb0lOZ0g1U2phMUNLOG85eldyWlJmL1pWZTJwSGhWYUQrRjdRbmhSc2s3Zmg2Mmw1cGNuRGI4YzJlMlhKNTIwMEZ5WG9KNkxhV2VGWnR1cG10VllzYVhSTndDc2hWYTBvSTdyeUNWU1hNUWF6WGZJeUNvcEV2V0g1ZVBadmNhMG5DVTRFdGdPck4vdXF6am50Ly84NXFCVG51Y2EySVFKUUprdnFkL2tyeWFSWVVzV0FBQUFRTjhpd0FnQUFBQUFBQUFBQUZ5MkVHQTBOenVuUng5OVZFVlJLTXN5QVFBQUFBQ0EvalZjajFWUElnS01nRDVUaTZNeWNHVFBZRTNvVDd0cXFYYUpJQmowditYbFNWd3VUODR2OVFnd3VvUk9sbXUyazZwV3NZb3R3WEVBc0JZV28xYlpiZHNsVlZ5aVJtZEFrWXVWcUY4Q2pKYjFCczVMWEp3SDJCYmlzanJNcUJJQ2pBcVRGdGJWbmRObTJ4aE0vV0IwRW1zcTFjaFF3UWNBQUFDZ2J4RmdCQUFBQUFBQUFBQUFMaWxOMC9JU2RFOC85WFI1Kzh5Wk0yVm9FY0ZGQUFBQUFBQnNEaUc0S0RUVzJqZFUwM1hEZGIwdzF4YUFqWGZienFiMkVWNEVZSlVra2RFOWgzZm84YlB6ck9zdllhNlQ2Zmpza3NicWlXcTBvZ0NBTlpXYVZNNDRuYXdlVTFSRWFoUk5OWXNoTmJNaDJSZi9iWVNzdGlCblV4VVJZWC9BZHRPczJtWTFjdm01SldjM1czeFpFc2trMWhqL1h3QUFBQURRejZoNkJ3QUFBQUFBQUFBQWx4VENpMEpZMGNsVEo5VnBkelE5UFMwQUFBQUFBTEI1eEhhNVllaFFOZFpZSXlIVUFPZ1Rld1pyR2grb0NnQldRd2dzdkduSGdNNjNlOExGdGRQY2o1OVVQWC9jZzJZVUFMQzJuQ25rbDdpYWljOHJjcEc2ZVU4MmpkVXdUVm0zTWVGRlFSRjN5eUtUQzhEMmtsaVR4QlVqYTV3S3Q3a2lqQ0pqVkkyTmljZ3ZBZ0FBQU5EbnFIa0hBQUFBQUFBQUFBQ3ZjdkxrU1owOGNWS1RrNU5hV0ZoUXUwM2pSZ0FBQUFBQU5yUDdidHlwdzZNTmZlLzBuQUJzdkIrOGVaZWFDYWZ4QWxnZHpXcXN2L0xHL2VYdC8vUGhFOEtyUFRmZDBoZWVQcXMzN1I0aVFBNEExbEZ1Y3JXaWViV2pKWjEyeHpXVWphcGUxTFE3M2EvWVZXUzA5b2tjem1aeS9sK25lVlo1dFNVQTIwL0ZobVdOMDlpQTdhYTUwMHk3NlA4TlFxTTBNbW9QSkNZWnE5bkI4aEZzVDBZbmMrbnhhbW81ZVFzQUFBQjlqU09mQUFBQUFBQUFBQURnVmJJc1U3ZmIxZExTa2hZWEZ3VUFBQUFBQURhM0pMSmx1QUdBL3RDb3hHVUJnTlVTMXZOSkZBa1hseFpPUzJtdU5DOEVBRmhmempobFNwVVp2encyUFZYTUJtd0grMzZRS2Nvd0l3RGJqeW1qZjR4aUkrZXNOZ1VUa3RkQ0JwdnZkMnZNSnVscnJJbEN1VEd1MXk2S1hBQUFBRUFmNDhnbkFBQUFBQUFBQUFCUXI5ZlQwMDgvcllXRkJUM3o5RFBLODd3c0FBQUFBQUJnYS9qZ3JidVZGVTUvLzNPUENzREdHYXpHb2VHaFB2cTJnd0tBMVJLV0t5TzFpdDY4ZTBnL2Z0ZEJQWHg2VHQvekJYL3U2TXlTWnR1cC9zNjdyaGNBWU9QTVZzNXJWdWQxcW5xaXZQL0d4YmNxY3JFR2lxYldTbWZ3dE5MR3JQS0VDL2NBMjkxUVltcDVvYUtUbXZPWmM3SGZQQnhTbnhxb21HUzhFU1V4MFVYYm5qRm15ZmxWYUM4UktYd0FBQURvYXdRWUFRQUFBQUFBQUFDd1RSVkZJZWVjRnVZWHRMaTBxUG01ZVMwdExiMzBPQUFBQUFBQTJEb2lXMTVxWG51YXRiSjdwdFVSZ1BXM3M1bW9Ia2NDZ0xWUXExZ2RIbTJVWVQxNHVjd2YrK2hrdWVhN3FXWTdxWnBKclBqRjdTTUF3TVpadEF1S0ZLc3d1YXlMVkMvcU1ySytYUHN5MmhsLzNOdC9yck9oaE13SGpvRURXRmFOVEJ3Vk5zcHNYdVNGL05KQ2ZiVmhtRmdWc1Y4VStzMVZ3eGJycTRWVG1wei9sNGRGdlF1bk9KazBkUHo0U3B3ZloxSEkvQkVqRHdBQUFGaHZCQmdCQUFBQUFBQUFBTEJOZGJ0ZDVYbXVMMy81eTFwY1hGU3IxUklBQUFBQUFOaWFWZ0pUZnVpV1hXcjFNdjNlbjUwU2dQWDNsMjdicTVGYVJRQ3dGbTdiT2FqeGdXb1owUFBIUjZhRVA3Zll5OHZ5K05rRkpWR2t1dytPRVdBRUFIM2dTUDFaR1dlVnVFUWoyWmoyOXc2cTRpcUszTFUzZVhPMnA2eTI2TXVDOG1SUkFCQkUxdGp4UmpTVTVxN3cyNFc5VnErSWx6TFhOKzFzL1NhcUcydEUzU1JTbEVRbUVWNGxkMDVaSWZVSy85KzVvcHNWMDlZL1hvbk5Eai8rYkdKTk5iWk9NUWxHQUFBQXdMb2l3QWdBQUFBQUFBQUFnRzFtWVdGQjgvUHptcCtiVjVabFdscGFVcFptQWdBQUFBQUFXOStkKzRZMXRkZ1RnUFVWVzhrWW81dkdtdHJWcFAwaGdMVVJBbm1hU2FTREkzVzlaZSt3bmpxM29FNW8yWXVYSEo5ZFVyTWE2NjU5STZxRmhUTUFvQTg0NWY1Zng3WTFIWjlUdmFncktSTFZYVlBXV1JsZGFRQ0Y4LytrUEVxVjFXYmxiQ29BZUNYckZ5L1ZTRkdSR0JOeUxYdTU2MlYrY1ZRVXFsM0ZndWZhR0tYR0w3b2FGWk9FZmduaFJiSHZMYUhrbCttdW02bHdYdXBjdUZaYm5EdEZhZUVpUDlxTXY5OElyL1BQUlpHdmZPbjVjUmdadnhxSVhGYVJpZndFTmtrY0pybElOQUlBQUFEV0VBRkdBQUFBQUFBQUFBQnNNNU9UazNyKytlZDE5c3haZFRvZEFRQUFBQUNBN2VNanQrL1RpYm0yL3ZFZlBTVUE2NmNTUlVvaXEzdHZITmVCNGJvQVlDM1VLbEZaUWpqUGZDZlR2L3gycXFPelM4S2ZlM3h5UWVmYnFkOG0yaXVhVXdCQWYzREdLVE9wNXV5TTV1SVpqYVJqYWhRTjdVcGoxVlNYY1ZlV054SENpL3libEZjWDFSazZMUUM0bUJCME01Q1lTclh3eTZDS05OY3Qya3VwNi9Ua0V1Y1VhUjFacVd1TThoMzFLUEZMUEZPUERjbkhGeWo4QlBIVEp1MW1MbHZvRlduaGQzMzh3NkZ5WldXRGZxejhXMTY3emEyOHJlZkhhMmV3YWl2VnlNU1Z5RlJseUM4Q0FBQUExaEkxN2dBQUFBQUFBQUFBYkhIaDBtTm56cHpSL1B5OHBxYW15bTRvV1pZSkFBQUFBQUJzTCtPTnBHejA4K0UzN05XeDJTVTlmSHBPQU5iZW5YdUhkTXY0b0VackZUVXE2OW9PRXNBMmRPT09nVEkwN1lIbnptbWhsMm1tblpicmYwamY4OXMrejA0djZreXJLMnVNeGhxMERRZUFmck1VdGRTekhiVnRXN0dMdFN2ZFgzWUhpb0hMZXIrTHUrcld6eXV2TGdnQVhrL2t0d2xONURSVU5mV0Jpa25hbWJOeVJvdHBNWjA1eFZsZTFHV00xZXEyeFUxOTZkVmlaeUpyZkQyQlRXSWp2dzB2dktod3kxRkU1OXQ1cS9EZGRzL1ZjK2RpSjFPUjhTdUYxOXU5TVVxY00zWXBMYUp1Wmt6bXpHS0lMeHFyUjgzUXRXUVpBUUFBQUt1T0FDTUFBQUFBQUFBQUFMYTRFR0EwTXpOVGhoY2RPWEpFUlZISUZUUlVBQUFBQUFCZ08ycFdZMlcrWHVET2ZjUGxmUUtNZ1BWeGVIU2cvTjBOVml0bHFBZ0FyS1dkQTlWeWViUExkNDhuYmMxMVVuRllZRmtJTHBLNm1tMm5HcWxWTkNZQVFML3AyWjdDdjZWb3Fidy9tSStvV3RRMG9Nc01NREtGOHZxOGlxZ2pBSGc5eGtpUmpPcXhLWk10WSt2S2JlZHVyaVVWcW1UR0pDYUU2YXhpNEkweHBqRE85V0pqVFRVeXBobmJKSTZNL3krOGFHWDNwWlc2anI5dGU3bHJ2dmpNNjRjWExYOUE1T1NpdEFocFVYNmFwdXI1MFZ1TTFkVmsxd2dBQUFCWUd3UVlBUUFBQUFBQUFBQ3dCYzNOelpYQlJkLzU5bmZLYnJqZjdYWlY1SVhFbVRnQWNGV2FkLzNYMm5uN0lRSEF0VHAxYkZyejUrWmtuem9sTGRDSUJnQ3cvbW9WcTQrKzdaQytORHlwUHpzN3I1bDJUK2ZicVFDc3Z0M05xdlkwYS9yQVRUdjFnWnQzYTZqR3Fic0ExbDRJU291dDBkKzg2NkRlZjlNdTNmL0FrenJEL3VmTC9QN2pwLzN5dWFxZmVlL05BZ0QwdDlQSkNWa1pUUmFuVlN2cTJwWHVWZXhpVlZ6bFZhL040N2F5eXBLeTJwd0trd3NBcmxUbHhjemhuUVBSVGlkbkMyZWlvbkEyOVl1VXpMbXM4SXVhTEhjTC9pVWhJendLNStCMEMvZXFCWTQxSVJySm1TUUtZVVhHV0t1RzMwU1BxcEh4WFZlcFJMWVp5VC91WDJXc2lEcCtoZGwyc2RqSlhkN0xYVWhoditab3B6UjNnNkY3cHBYUFYyTWJqOWROUTV1R0cvS3oyWjVhcDVjSUFBQUE2R01jQlFVQUFBQUFBQUFBWUF2cTlYcGxjTkhrNUtTY2MycTMyd0lBWEp0ay9BWlZEOXdoQUxoVzhjS3ppcnMxbVdqSzM2TUJLUUJnL2RYaVNJZEhHOXJWcktwWmpkWHFaUUt3TnNMdmJhUmUwZDZodWc0TTF3VUE2OEVhVTVaREl3ME4xeXJDcXgyZFdaUS9nQ0lBUVA5clI0c3kvbDltTWhYS3kyQ2lrQmx5MFF2MzJNSVgvN3FJa0Y0QVZ5ZXl5MWs1ZmlsVFc4bk5DYWxGNGVISXFTaDhpV1I2dVhOcFVTaDJSczQ2WFNUQXlQa3RjbU5pYXdyclh4SlptMFFtMUJNWVJjYllTbVRJTEhvTmZnVG5uY3hsZnBOOVZYWm9WajdIZithQzlXdVRjZ3B2RW41MWwvaDVxT1pxQ2ZNTUFBQUEraG9CUmdBQUFBQUFBQUFBYkNIZmUvaDdPbkhpUkJsY0ZBS01BQUNySjlsemkrcTN2RWNBY0sycXM0a3F2U015eWJNQ0FHQWozWE5vaDM3N1I5Nm0zLzcyTVYrT2wwRkdlVUZEZm1BMWhBYVB6U1RXUjk5MlVEOTl6MDFxVkRaUHd6Z0FXOGVkKzRiTDdzKys5MllkblZuUy8vdFBueE9XL2Q2Zm5kSytvWnArN0s2RGZua2Q2YVlkVFFFQStwZnovN3EyVTVhWnlyUjJ4MDFmQnBXMGRxblNHWklwd3ZhMjBjTHVKK1JNSVFCWVRiSGZ4NC9MNkJpVHZQZ1FDY1ZyWks1YkxMUjdydHZLaXVHODBLcW5zYWFGRzJ0bExqMnpvS2xheGRSR2FuWXo3QWlNRzluRGhZcWFBQUFBZ0Q1R2dCRUFBQUFBQUFBQUFKdFlVUlJsVUZHV1pXVnBkOXBsRndBQUFBQUE0UFdFZ0pWdzZmZkJhcXp4Z2FRTU1BSnc3WXd4R2twaTdScXNscjh2NisrSHh3QmdvNHpVS3hycFZNcGd0WjQvcHRETENTeGNjWDZwcDhoVUJRRFlYRUpJVVZsc3FpTHV5dVNoaVp6eGo0VjFIT3M1QU5oc1hMbm9kaXFjWDZUN3BidldrcE1OMytIQ2VxUDg0bEJ2SXdBQUFBRFhpQUFqQUFBQUFBQUFBQUEyc1hhN3JTTkhqdWpFaVJNNmVlSmtlUzZtNDRSTUFBQUFBQUJ3R1lacmxiTDhYKys4VG0vYlA2cWYvOExqK3JPejh3Snc5YXhSR1ZyMDVyM0QrdFcvOUdidGFWWTFWT1YwWFFBYjY2TnZPNlNweGE2T3ppenB6RUpIZi9qTXBMQWNYdlNMLytWSjNiblBMN04vK00wQ0FHd2VSZHhSMmtoOU9WL2VqN3FETXM3S1JWMEJBRGFmY0s1VHlGbGRTb3ZtUW05dHozdnkzeFA1N3hoenJsQTlqaFJicDVnRUl3QUFBT0NhY1VRVUFBQUFBQUFBQUlCTnB0UHBLRTFUblQxN1ZyMWVUK2NtejJscGNZa0xTUUlBQUFBQWdLc1NRb3dPanRUMXp1dEcvZTFZM3owMXA2VTBGNEFyRTF1aklmOGIrc0JOdS94dnFxR3hla1gxU2lRQTZBZU5KTlk5aDhaMGRMYXQ1NllYZGI3ZDh5WFZkcFlWcmd4ME9qb1Q2K0ZUczlveldDc0xBR0R6Y1RZVEFHRHp5cDN5VHVaNnVUT0pYNnF2UzJWSytaMjU2OVQ4ZDhaV0ZmVXROK3ByYXZmWW5QYmdBQUFBNkc5c3NBSUFBQUFBQUFBQXNNa3NMQ3lvMVdycFQ3L3lweXFLUWxuR3laZ0FBQUFBQU9EcTdSMnNsZVZIM25oQVoxb2QvY3dmUEVxQUVYQVZRbGpSem9HcVBubnZyV29tVVJsaUJBRDlvdUdYVVgvN25kZnJ5Y2tGblpocjYrSFRjenJmbnROMkZnS01ucHBxcVpNVit2M0hUK3ZlRzhZSk1BS0FUYXFvdEFVQTJMeDZ1ZXZOZGQxOEx5K0cvTjI2MWtHdlVHZXVVNXkzTlR0VWt4bFcvOXB0NVpSSGFnb0FBQURvWXdRWUFRQUFBQUFBQUFEUTUvSThMOHVaTTJmVTZYUjBidktjT3QxTytaaHpUZ0FBQUFBQUFLdmhwaDBON1JtczZyOTU0ejZkWHVqcUM4K2NWZUhySHRLYytnZmd0VlFpSTJ1TWZ1Uk4rM1ZndUs0OXphcVN5QXBYcjZkSU0zbGROVU40KzNycEZCVkIyOEo0TTlGSGJ0K3JrZnJ5Tkg5aGRrbm4yNm0yczFZdjA4T241blRiemtFQkFBQ3NwbTdtOHNMSkdldUxaS3FSb1QwbmNJRncybE1Sd25tYzRtN3VCdnp2WmQxMlRwMXpsYlF3UTJtaFd1NTd4TXJJVisvMElkUHdmVHRpQzlxREF3QUFvTCt4d1FvQUFBQUFBQUFBUUo4TFFVVzlYay9IangvWDNPeWNKaWNueThjQUFBQUFBQUJXMDAzanl4ZngvbS9ldUYvSFo1ZjBKMGVtbEJXRlV1b2hnTmNVd29waWE4c0FvNE1qSVFpc0pseWJYaEZwdHFoTG1kUnhuTzY4SGhqUDI4ZDRvNnFQM0xHdnZEM2JUc3Z3SGdLTU1qMThlazczM2pBdUFBQ0ExZFROWFo0Vkt2d3VvN1BHbUdwRWUwN2c1WndLNTNmL2MxWFMzSzFyc3E3LzNxUndMc21LMEE4aHZNaUZDQ1AxRzk5SERkOW5JUWlONVFjQUFBRDZHaHVzQUFBQUFBQUFBQUQwcVlYNUJaMDhlVkxUMDlPYVBqK3R4WVZGcFZsS2VCRUFBQUFBQUZoVGQrMGYxczNqQS9yVkgzNlRqczIyOWYvNXpuSE50SHZiUHR3QWVLWGR6YXIyTkd2Nm0zZGRwME1qRGQxOTNaaXFzUld1WGNkVmRDWWIxSlJwS0U0TFllMjFYRlhZWHU2NWZvZHUyem1vUDNqcXJCNDVNNmYvOFBocHpYYTI1N28relF1ZGFYWEtJQ01BQUlEVnROZ3IxTTZjWkV4aWpMK2ZtcmxhWkN0RFZkTUlNU20yLzdKU2dIV1ZPWk12cGNWU055OVRkZXZhQUw3YW9idVV1dDVBeFRUOGJ6SlMveG55UzVHbW5CbisrUDl5Yi9OLy9XOGZiQWtBQUFEb1F3UVlBUUFBQUFBQUFBRFFwN3E5cmhZV0ZqUXpNNk56aytmQ1JjZjhmeWNBQUFBQUFJQzFOTjZvYXFoYTBaMzdSbFNMSXpXck1RMzZnWXNJdjQrUmVrVjM3QnJTYmJzR3k5OUtUT3ZUVlpISktuUFdWNGh5cWpPd1ZzTDZQcFFuenkxb3ZydTlRd29MZitpbG14WEtDNDdCQUFDQTFlVTNNVUk0U2pqWEl6TEc1UDVXR3BraVVsOW1wQUFid1JYK2Q1TGxUaHVXQ0YyNDBBOG02OWVUc254UEpXVnRrMVdjTkdnVERnQUFnUDdGeGlvQUFBQUFBQUFBQUgzaytQSGo2blE2ZXZTUlI1V21xYnJkcm9xaUlMd0lBQUFBQUFDc3F5U3l1bjNuWUZuZWUvMjR2bkpzeXBmeitzT25KOHVnQTJBN0N0bEVBMG1zMi96djRvTzM3Tkk3RG95V3BWR0oxVWdpd29zQWJFb2Z2SFdQN3IxeHArN2NPNkpPbHV0bi91QlIzeTAwdmRRVEFBQUFyazVJWThsOTE1ZEs0WnlNTVhMT1JiM01qUlhPOXJJaU96OVlzZlhCcXEwTDJNYnlRc1ZDcjJpL0dDWTZvQTNRelp6TGl5SWZxRVQ5SGFOczRqZjJYQkVXTFo4WEFBQUEwSWNJTUFJQUFBQUFBQUFBWUFNNTU4b1NRb3VDVnF0VjNnN2RFRnlVNTdrQUFBQUFBQUEyUWhJdlgvaDgzMUJOMXczWGRYaWtVWFpiM1ZTem5heDhydFhMQkd4bG9aRnBNRnlOWmYzdHZVTlZIZksvaGNPakRSM3d2NGM5Z3pVQndHWlc4K3Y3VU1KeUxRUVlIZlRMdUlWdXB0Q0FPTndQWVVaYlhjVWFWU0pMRUIwQUFGZzF1WnpMblNua0ZLM3NWd1pPeGhZaHdhZ3d5cDFUQ0RleWhtMFFiRi9oSjFBVXNzNVh3V2lEK0QwZWsvditXRDZIeTZoZmY1SkZVUXhaRldNQ0FBQUEraFFCUmdBQUFBQUFBQUFBYktCdXQ2c3N5L1N0YjM1TE16TXptcDZlRmdBQUFBQUFRTCs1KytDT3N2ellXdytXb1VXLyt0Q3ptdTJrK3BmZk9TNWdLMnRVUXFDRjFmLzkrMi9VVURYV1Q3N2pzSkxJK01jNUJSZkExbkxudnVHeSt3Yy84WDA2TWRmVzd6NTZVZytmbXROL2VPSzB0cnFoV2tYM0hONmhHM2MwQlFBQXNCcDZ1ZWJiYWRISm5CdjFkNU1Mbjh1ZGtqeDFZMjFyL1A2bFZJMmNJb0lVc1UwNXVVcXZjSHUwZ1p4VDNmOVdmU25EakJRaTNmdnhGK2tYRTNjNVovZjdtNzhqQUFBQW9BOXg5QlFBQUFBQUFBQUFnQTBRUW90YXJaYVdscGJVYVhmVWJyZVZwcWtBQUFBQUFBRDZXV3lsbXY5emVMU2hUcGJybmtNNzFNc0xuVy8zbHJ0TG9ldksyOEJtRkZ1alpoSXZsMnFrM2MyYWFwWGxlWDZvRnBmUFI5WUtBTGFxc0p3YnFFVGxjbStwbCt0ZDE0MXFycE5xdHAyVjRZVnBVU2d2bkxhS0VCWXc0SmY1WVhoSGFoVUJBQUNzQnIrMTVITG5DdWZDZHRQRm8xQjg5VW1lRlM3MW0xNSs3OU9RWUlSdEoreFg1SDIwYXhGNnhmOW9aY052dGg5L2tjNk5HZDlqOTA3Y1c3WUxmM0Rpd1V3QUFBQkFIeUhBQ0FBQUFBQUFBQUNBRFRBMU5hVm5ubjVHcDArZjF2ejh2QUFBQUFBQUFEYURrWHBTZG4vNm5wdks3dCs1K3dhZFdlam84MCtmMWJQVGkzcm82SFI1LzJ5cksyQXoydEdvNnJhZHpUS2M2Nlp4M3owOHB2R0JLcUVXQUxhTk1zQnRMTmIxWXdOcWRUTk5MZlgwKzQrZDBzT241L1RRc1dsTkxmYktRS090d0pybDRiMSt0S0dQdnUyUTlqU3JBZ0FBV0ExWnJyeVhLM015bDB4NDdtYXVOZS9jZkRXT2R2cTdOUUhiVERjdmZ5dDlJL1JMNnZjUm9yZy84NHQ4WDcwei9MM3prSnA1cFYwOEtISENHUUFBQVBvS0FVWUFBQUFBQUFBQUFLeVR5Y2xKZGJ0ZG5aOCtyMWFyVllZWTlYbzlBYmk0T0Y1dUdEaStjK2NWdlc5MGRFeU54b0NTWlBNMkxMVFdxbEtwYUhCbzZJcUhmN0E1VkE3L1ZsV3IxVFE4TXVLWHA1MXlISzJuYW8zemhnR3NqbXExV2k2cngwWjNMRi9PZFIydHJDZXMzWm9YYzc2VzlVVGsxNytiWGROdk82UnBlbFhiRHdCd3RXcXgxWGdqMGQzWGplbVc4YWJldUh0SXM1MVVzKzFVNTVkNjZ1V0ZUc3kxbGVaTzNUd3Y3NTlmMmhxaEI5aTh4Z2VTTXJCaXhlSFJocExJYXN6UHk4TzFXSHNIYXpvNDB0QllQU2xMbU05eDlVSTlSOWhHUzVKRVMwdUx3dFlSdHJuamlOUFJ0N0wvUDN0L0hpWFpkZGgzbnI5NzM0czFJOWZLeWxwUktDd0VRWkFnUVFLRVFBbVNxTVd5UnBLNzFaNlczSzF4dDZYMmFXbnNhYmMxeDM5TTk1d3ozZkxZWjA3N2RNK00yOTNlZExvdGVkckhpMmpMaTB5YW9pa0tiVkVTUlJJa1FJQkZGRkFvVkJWcXljcXEzRE8ydDkyNTkyVVZXRmtGRkRLcmNvbk0vSDZxYnI2SUYrKzlpTGh2eVl3YjkvMWUxUi8vUW9EYmN5Y215bU5sK0QyL2ttUmxtRkg0blg3cTZySjJzMllsMG84OU51V1ArWTB5dktoVlkzc0dBQUNid3plRHhGbWhxblBPdmxjVVNuZ3NjNHI4OXdSN3M4RWVlQjlwNGJxcFUyaDBHWWdrMGN5L25pUlg3cHVHaHZ4K083RDdaYUhvT1NValhYL3pmeGNBQUFBd1FHaGhCd0FBQUFBQUFBQmdtNFFBbytYbFpiM3graHNxaWtKWmxnbkFld3NCUkNGYzRlREJxUTNOTnpZK29hR2hJVlVxVmUxV05yTGxTWDNEdzhNYmZ2L0RJOFBsKzkrclFqREYyTmg0ZVF5dDFiWTNVS2hlYndnQU5rTzFWaXVQMVJNSERpaUtJbTJubTc4bmpObWJKK0hmeis4SnV3ZE92QjRkR1pVcm5BNjJOeFlNMFBMYkJRRGNxM29jbFdWeTZMdm5HZld5M0pkQ1o2NnZhQ1hKOVpVTHMrcWt1WmI2bVZaOE9UTkxnQWwyMXVNSFd6bzgvTjIvRlQ3OThFRzFxcEVlbld5cEdoazFLM1N2M1V3aHdDajhqUmIrVmlQUWZXOEo3VmN4Kzh1ZUZzTGRxZzFiQmhnRklid284NTg1L3NXM3I1Uy8wenYrOS94dUZrTHFmdjdwQjh2ZkFiZitYZ0FBQUxoZlJlSGl2SEJWNTN4ai9IdkVvT1FoMmFnd1VTRm5SSVlSOWlIZmZOanorMG40VURrUUFVWWhVQ2tNbkV6b0dMQzlYK0J0aUhsT3hpMklBQ01BQUFBTUdMNHhBZ0FBQUFBQUFBQmdpNlJwcWp6UGRlclVLV1ZwcGl0WHJwVDNDUzdhUDE1NjZTVzF6clQwMGpkZkVqYXUwMm1YWVYrRjIxaS9zUG41Ulgzbk82ZDE0ZTFMK3VZM1g5WnVGSTRUdlY1WGMzTnpHMzcvYjcxMVh2WDZqT2JtbDdRWHpjM05scVhmU3paY04vZnJtMzVmRHZVTEFQZHJZV0hlSDhkNjZuYTMvMWgyOC9mRXpMVTV4ZkhlNnpaeVA3OG5Qdjl2UGwrZVZMK2JYYncwN2Q5N2Q4UHYvWnpmTHY3RlAvOFh3bUJaV0ZqUVhzTjJ0bi9raFZQdUNxMGtoWkxNdDRWMCtqSzVVOU9YbW5PS3U2bUFuVFRXcTBqUmR3TWRYN3RjOTNlTnp0WmpXV01VMjcwWjlyaFRRbWpSekxWWnVYdG81OEZnKzczZiszSVpVTlZzN3Qwd2Jhd1Z3b3NLL3p2KytrSlhTVjdvOGZtdWRyTkdKZEkzZnZkOCtUdmcxVnBGQUxEWnJzM09xTlB1K3UrSUN3SFlYNXh4VlNjVE8xUDR2elRlUFp6SVNiWGN1Y2hQeHdjbDdFdis4MFhmN3dNYUZHa2Vzc2RjVnI2a0FjNFVjODc5bUcrK212bkZ2L3RUdnpwLzVXejJtVjg1UlZvMEFBQUFCZ0lCUmdBQUFBQUFBQUFBYkpHYllVV1hMbDVTdDl2VjB0TGVEQlBCZTV1ZW5oWTJ3OFo2aG5WN2liclRWLzJ0cTlvYk52Yis1eGZDc1daSlY2YjN5dnUvbSszdE5YanVYQWd2SXNBSXdHYmIzbU1adnlmZTIydXZ2YWE5WStOL1A4eS9ST2dtdHQ1TGJHZjdXamd5VlcvY2JnallZYmZsYlV6UHJBNHZDVnR2Z004QXhJYWRPZk9tc0w4ZDFpN25meDljNEtzYkFBQ3dCWnhUeGNuSjNPMHpVRG1OS2hyMHRCUmdpeFNGUW43UndGd0ZydkQvamZPbHpCY2JZRVpQK0JjNDBxeXVWSFhrWVQrQ0FDTUFBQUFNQmdLTUFBQUFBQUFBQUFEWVpPZlBuOWVGQ3hjME56ZW5UcnVqVHFjakFBQUFBQUFBQUFBQUFBQUE3RjNPT2VWT0tnWTcvZ1FZQ0wzQzVZVnp1UWFFMzMvOWl6SEZnTWNYaFJjNkxLTmpoZUpmcmxWNzMvSmpmbE1BQUFEQUFDREFDQUFBQUFBQUFBQ0FUWlpsbVhxOVhobGMxRzYzQlFBQUFBQUFBQUFBQUFBQWdMM04zU2dBM3A5elplYlh3QWd2eFdnWE1NYjZuNzY0TWFlaUxnQUFBR0JBRUdBRUFBQUFBQUFBQU1COVNwSkVyNy8rdXE1ZnY2NjMzbnBMUlZISWNUazlBQUFBQUFBQUFBQUFBQUNBZlNOMEZVbnoxU0dBM1NVck5DYTVvakNLSWcyOEVYK1krWXRHOXZQL3hhLzk2T1ZNMmJtLzh3c3ZuQk1BQUFDd2c2d0FBQUFBQUFBQUFNQ0c1WGxlbG5hN1haWityNjhzeXdicjBtQUFBQUFBQUFBQUFBQUFBQUFBTUdDY0ZQbWZBM09Pcy9IL1RUbllWWWFzeWFkcTFvNzh6Rzg4VVJVQUFBQ3dnMklCQUFBQUFBQUFBSUFOVzF4Y1ZKSWsrdEx2ZktrTUxlcDJ1d0lBQUFBQUFBQUFBQUFBQUFBQTNGMmF1d05HWm1BQ2pKeTA2d0tBZlAxOWozUDJvLzdGLy9xeDlyRmYvL04vYytyTTMvcS92TEFpQUFBQVlBY016Qi8zQUFBQUFBQUFBQURzQnJPenM3cDQ4YUl1dnIxYXNpd3JDd0FBQUFBQUFBQUFBQUFBQURBSTB0d3B1Vkd5d2drWU5NYTV5Qm5IT2M3M3dibXkvaXFGY3cvNTI4OFhRM2IwWjM3bGlhcHpNZ0lBQUFDMldTd0FBQUFBQUFBQUFMQnVaWERSeFl0bGtGR1NKQUlBQUFBQUFBQUFBQUFBQUFBR1NUZDNjamR5aXlJanRhcmttV0N3T0dPcUlsdnIvcGp5SFBIWUdQTnNJZmRnN0lwWGp6MDQxZjdMZi9sbmw2UmZvWFlCQUFDd3JRZ3dBZ0FBQUFBQUFBRGdMdEkwMWZ6OHZEcWRqdWJtNWpROVBhM2w1V1hsZVM0QUFBQUFBQUFBQUFBQUFMQTluR2VNeWZ6TnlCY3JZQThvM0dxeEc4d1hDdUZFaFp5S1hGbS9VSkk3Wlg0WENZdUtqVkZZV3RQdkpLWWFtUTB2RzhDdTB5cC9PdnZ2NVVaUFhUNzU3MzdyTC95OTcxLzZuLzZ6MzdzbUFBQUFZSnNRWUFRQUFBQUFBQUFBd0Ywa1NhS1ptUmxkdTNaTlo5ODhxM0RsTDhmbHZ3QUFBQUFBQUFBQUFBQUEyRjZtL0xJK002dGhMQVFZWVU5d3Q1U041UXk1TXZpbzcxeTIwbmVkZnVINkljVElqNjc1QmRueHVxMGJxNmdlazE0RTdBTWh3S2hsalBrVGZ0aXVHYjBxVlMvNzJ3UVlBUUFBWU5zUVlBUUFBQUFBQUFBQXdHMFdGeGVWNTdtKzl0V3ZsY09WbFJYMSszM0Npd0FBQUFBQUFBQUFBQUFBMkNGV0pvdXM1cTNSc0w5YkViQUhaSVdVNWs3VnlNaXNNMnVvbHprbHVYUHp2Y0lQWlB6TlVlZmtCLzVCWXpMam5LdkZzcldJOENKZ28vTENsUWw1a2QyVis4OHgrV09CY2ZwL09PTVcvL3l2ZmZxL1VheVZ2L1dmdkhCR0FBQUF3Qllqd0FnQUFBQUFBQUFBZ05za1NWSUdGMTI5ZWxWRlVTakxNZ0VBQUFBQUFBQUFBQUFBZ0IxVldHTlNJNU1MMkNOQzZGQ3h3V3RwaGVuendybHU1Z3JqRkRsVEJucFZiaXl3SHhaWnNVYVJJY0FJMktqaVJvbTBLelZVN3ZibUtUKzRhaFdQRmZSN0F3QUF3RFlod0FnQUFBQUFBQUFBc08rbGFWcUdGcDA1YzBhenM3TzZObk90RERBSzR3RUFBQUFBQUFBQUFBQUFBSUN0MEU2THBUUTNXUzJ5WXpMRzNtM2FsZFQxQ3ljM3M1TFgvVjNybkt1SDdDT2o3d1lWeFpGWjl2ZFN2NkNENHZ4UllNUHlQT3hjVXNWcTEzSkYwZktEbG96N1I1R2ljMy9oMTM3MG4vajdYL21mZnVHTFh4RUFBQUN3UmZnQUNnQUFBQUFBQUFEWXQ3SXNLNE9LZXIxZVdWWldWclM4dEt4T3AxT09Cd0FBQUFBQUFBQUFBQUFBZzhFWVg2eHVpV29CZHIvY09XV0ZjWjc4ZjcrZDM3bUZGK0VSLzFnUzBvdkM5R0ZDbGRQZU1iSGZSWndmUzZjWDRCNjVHMlZYdXhHRzVnOFFoOFBCdzk4NTZZOGpsLzZMLy9XUFhZaHQycmswTk5QNXpNK2VTZ1FBQUFCc0lnS01BQUFBQUFBQUFBRDdWcmZiMVd2ZmVVMVhyMTR0UytoOTRuWi9GeFFBQUFBQUFBQUFBQUFBQVBha2ltU3RKY01JZTBjdlU3WHZpbmk4R1ptSzg5dTRlYmRwWEpya3lxKzM4M3JoN3I3OVY2MHBLaEVCUmdCV0dabkQvdER5Ri8zd1Q4a1dWNTJMLzVkajdXTmYvcG5mMENsQ2pBQUFBTENackFBQUFBQUFBQUFBMkVmNi9YNFpYRFE5UGExck05ZTBzcktpSkVuMndLV3pBQUFBQUFBQUFBQUFBQURZdTR3cGk1RnpCQmhoenpCT0laTExwcG55ZnVxeXdqbmRMRm51aWlRUDRVWEc5WE5uMTlPMXhWcFhpYVM2MzFjNGR4VEFyYXErREJWeUo1MHhUeC92SFByQS8vblhmdnlrQUFBQWdFMFNDd0FBQUFBQUFBQ0FmZVRxMWF0bGFOSFh2L1oxRlVXaExNc0VBQUFBQUFBQUFBQUFBQUFHbTVGc3hacEtaQTNCTE5nem5DbERSWFM5V3l6RTFxaFdNV00zSCt0bVJhK1RxTlBPaWxaYXFMNmU1Vld0bWFqRkllT0xuQzhBYTB5VXhlZ3ZGUzZYay8wZnE4b1cvTGhmRVFBQUFMQUpDREFDQUFBQUFBQUFBT3hwZVo2WDVmS2x5K3IydW1XQVViL1hMOGM1dDU1cjB3RUFBQUFBQUFBQUFBQUFnSjFtalltcWtSbXlkalh3QmRoTGN1ZnFybkNhNjM1M1hGYTRTcEs3WnU3V2NSNm9VVWdrS2VKSXNkOVBEUEZGQU83R1NkL2pmL2Ird3EvOThNOFhjak50dVM5VmsrWDhWMy9weFZRQUFBREFQU0RBQ0FBQUFBQUFBQUN3cDRXZ29pUkpkTzdjT2MzUHo1ZWxLQW9CQUFBQUFBQUFBQUFBQUlEZHcwZ2h3S2dWQ2RoN0NxZTZMNXJ2cmVuVFVybFIzcGR4eXYzc2VUV3l0aFlaZGhNQTcrZTVHME5qcFZmSHBEL282RWppN3hOZ0JBQUFnSHRDZ0JFQUFBQUFBQUFBWUU5YVhGalUxYXRYdGJpNHFLV2xwVEs0cU52dHlqa25BQUFBQUFBQUFBQUFBQUN3dTBSR3FrYVNOVWJBUURMbC94MFJXZlg4UHRLM2NtUCtWUkJnQkdDOVBpaG5EdVRHL2xmMXVQZU5YL3k3UC9XdnBTdnByLzdTaXdRWkFRQUFZRU1JTUFJQUFBQUFBQUFBN0VuZFhyY01NTHArL2JwbVoyY0ZBQUFBQUFBQUFBQUFBQUIydDlnU1hvVEJGYlpPczBNaFJwRTFhY1dvWjR6Si9kMktBR0JkekdIL28rWExqeHZyMUt5dWZHRkJ3NFcvVDRBUkFBQUFOb1FBSXdBQUFBQUFBQURBbm5INjlHa2xTYUxYVDcrdU5FM1Y2L1ZVRklVQUFBQUFBQUFBQUFBQUFNRHVaSXl5cWpYWHFyR3ArcnNIdEVYNm1WUG9ZZEJPaW12K1pwN2tMaStjcW5taFljbFovMHFxeHJpT0g2YjEySFNObkp0b1JFZENXRTAxSWxnSmtwVlJMWExhaVp5dFptekdmUm1OVExtdENoaFUvdGdxSnd3VW81WS9hbnlva0JueFI3Q25SbzM1ekYvNEc5L3ptZW5mTzlIK3pHYytrd3NBQUFCWUJ5c0FBQUFBQUFBQUFQYUlFRnFVSnFuYTdYWVpYcFJsR1FGR0FBQUFBQUFBQUFBQUFBRHNjdFlvTTNKYkdxSVFBaldjLzVFNzVVV2hMQ3VMeTlMQ3Vjdy9zeDhxemVWdnV5TDFVK1QrOFRDOUk0a0ROeGdUaWltSDI4M3ZJemF5SnZiUHpqbWpHR2czajdVWUxINlZWUDNQVVg4TU9leC83UTFId3cxNzdjUFhTRU1EQUFEQXVzVUNBQUFBQUFBQUFHQ1h1aGxTOUx0ZitsMTF1MTB0TFMwSkFBQUFBQUFBQUFBQUFBRHNIVWFLUnV0MnNtSTNONWdsQkdpRVN5SXRKM2xucWU4NnZkeU5Gb1VxZnRUaE82YTlFZUhnWnhrS3BadHBQTnhiV2N5NnNUSG0rRWhVai93MGxZaXNCMnd2djhVbDFxaGJpOVZvVmt4VndJQXJqNzBFR0EycWlWRDg2dmt6bWFLblB2SmcvdCs5SUwwbUFBQUFZQjBJTUFJQUFBQUFBQUFBN0RvaHJLZ3NuYTc2L2Y0N1FVWUFBQUFBQUFBQUFBQUFBR0FQTWNxTlVSRmJZNjBOTVVLYkZ4Q1VPK2VTM0dXKytOdXF5RzE4NFg0R2ErUk1XcmllZjNWUkpUSVZBZHZJYjRDcVJqS1JFZWxaQURaTHl4OVFEa25Sd2IvMER6OTlmWGw1ZWZGWGYrbkZWQUFBQU1CZEVHQUVBQUFBQUFBQUFOaDFMbCsrckxObnorcjY5ZXRxcjdRRkFBQUFBQUFBQUFBQUFBRDJuc2lvWFRFeXJZb1oxaWJucy9SeTE3L1dLVmF5M0RWenAxSGRBeWZWTWlsYjdCVlhXMVhUYkZSMFFNQTJxa2JHVGpSTVhMV1dBQ01BbThMLzJuM1VEeDR0blB2OWZqOEt2OWUrNEFzQlJnQUFBTGdyS3dBQUFBQUFBQUFBQmx5ZTU1cWZuOWZWcTFmMXhodHZhSHA2V2lzcks4cXpYQUFBQUFBQUFBQUFBQUFBWUcrcVJjYldZck9wd1N6Ty8wOXlaVWtoWllXcisvdVI3by9KQ3hmbnhYMHZCMWczSTFkWVkzcVZTRm5GR3IrbmlBQWpBSnZLR3Z0eDQvUzhtczNSWC95N1QxY0VBQUFBM0VVc0FBQUFBQUFBQUFBR1hBZ3d1blRwa3BhV2xuVDY5R2tWUlNGWE9BRUFBQUFBQUFBQUFBQUFnTDFydUdxaWl0M2NYQmJubkRxWlMvdHBFZVdGV3JwZlRxYWZxMTR2UkxnRHRvOHhlU1hTU2lVeTlYcHM3Mzg3Qm9BN3VCK1RVVjd2UjcvdWh1SzJINUVLQUFBQWVBOEVHQUVBQUFBQUFBQUFCdExLeWtvWlhQVDY2ZGZWNy9jMU96dGIzaS95b3J3Y0lnQUFBQUFBQUFBQUFBQUEySnVxc1RyR3lkVWpVNnRFbXgxZ0pMZVNGTzJzVUMwOGxlNlRYNTZSTWMxQ0xoS3dMVnhhamF3T05Hd3J0b2J0RHJ0S2JEWFF3bThjczdtL2RuWXRYdzExLzdOdzFuNWF2YUh6ZnRSdkNRQUFBSGdQQkJnQkFBQUFBQUFBQUFaU2tpUmxlZnZ0dDlYdGRzc0NBQUFBQUFBQUFBQUFBQUQydnNnb2k2M0pLcEZwK09GbXgxMFVTYTUrVVd4UzRKQlJ5RnFxcmNaZUFGdlBiM0o1SkdlSEtyYk9Wb2ZkeGgvVE5jaENlQkg3MVNwWG5vUHVmSjJZUjExa09COGRBQUFBZDhVZmpBQUFBQUFBQUFDQWdSSUNpeTVldktpNTJia3l3R2hoWVVIT09RRUFBQUFBQUFBQUFBQUFnTDB0dHVwVklpVUg2bkhORDdjaXZDZ0VNdGkwY0pOK3VEa0JSc0J0NnNhMEMrdjZmaHZMakZOUmpqVEdSSEpEWVZ6aDFNdjlkbGpJMkw0clJwMU1aVjBMZGk3eHkzR0hobXcxc21aMTV5QnBCZGhVRmI5alZmbnRzSmJUanhucnB2LzgzL3owLzNMdFlELy96TS8rSVZjaUJBQUF3QjBJTUFJQUFBQUFBQUFBREpSdXQxdUdGODNPenBZQlJnQUFBQUFBQUFBQUFBQUFZSCtJck1sam82eGkxYXhGWmt2T2ZYTk8xcGVhZ0MwU0c1TlZqRW45ZHBiSXJBWVlHY242Y2JYQ2o4dU0rdUYrN2hRWm1XTGRsL1V5Sml6TDFXTnJyUWwzQldDVGhaM0xzSE90WmMweDUxeFJiU28rZUkxZm53QUFBSGgzQkJnQkFBQUFBQUFBQUhaVUNDbDYvZlhYZGUzYU5aMTk4Mng1cVVPbmRYZk5BZ0FBQUFBQUFBQUFBQUFBdTF3dFV0S3EydTV3MVRUcXNSM1NGdWxsVGxsQm53UnNqWXJmdEpwKytHdzlHajFjaTBmWE04K0szeDV6UC95dFRyYXc1Ry83KzJPM1QyT2t4Qzg2UHpZUzFTdkdtSHE4dDhOVjhodTdhRHQxdlN4MytVSy9XSEJ5MVRUWHdidk0xbzJNMG1wa0ZuMGxOWWNyOWtBMWttSkxFTTBBNjRZZ0w3KzZTY1FaY002NUVUODRWaWorNWFoWm5QTzNmMTBBQUFEQWJRZ3dBZ0FBQUFBQUFBQnN1enpQeTJHMzJ5MERqUHE5dnZJc0Y3bEZBQUFBQUFBQUFBQUFBQUFNS09mY2pTLzI3eXNSeE1rVllSaVZTekxHK2hKWm1jakkrTUdXcG8yVTcyQUwraWE0c203S2wwNWF5bDBVTnlyL1ppVVpzL2VxeTJoakcwSEkxd21aV3NPMkRISlJwM0NobW93TGxlTzNxL0RUR3V2OFpINy9rUFpnbGIzRDNkaVQ4cndjS0N0azh0VXJvVVcrQXV6ZDVnMzE0NmUwdmk3am9uQTJCSlg1dWcyTGNiRTFWaGc4SWJ0cnNMYm43TWFRODY3Zmc5OHpXNFUxVlFFQUFBRHZnaitrQVFBQUFBQUFBQURiYm5GeHNRd3Urc0p2ZjZIczM1aW1xUUFBQUFBQUFBQUFBQUFBd09DeXhtWTNja0FxdWc5V2R0bklGU05WbThlUktxTjFPMnFNS3JFeDk3WGM5WERhZ21zck9ZV3NtWjVaeldRaTJPRXVlcGxUN2xkQWJGZlRhR3A3N096R3NBSEVNaHZLWkdtR1JDTC8vOTl2VmtiYXZubytzNUxNSlU2VmhjS05SdFowNDhoMEpocTIxWXhOUGRUYlhrN0lTbktYK1pMT2RRcy9WRWh5R25ZeU5mL1EwUHZONnplcmVrZzk2dWV1MWMrbFJmK2pGcHRPMWFvLzJZaEcvRzNPcFIwdzFkak0rblZjeXdvMU5BQmlxMW5yaitYVzZaZzQ5L3BPVGkxL0FQb1BmZjE4eGQvN1ZRRUFBQUMzNFk5b0FBQUFBQUFBQU1DV0s0cENlWjVyWVdGQi9YNWZjN056WllCUkdPKzI0dEtHQUFBQUFBQUFBQUFBQUFCZ1U4VldSdGFaNFpwUitLby9MMXdZSnJsTWNyZjVJcm1xTWFwR040SmEvSElxeGxsWGk0M3o0MndJWkxIYXZmdzdLSHlOZEswdHc0c0lNTHFMTXJqSWJ6U1ozM1l5K2MwbmMybllCaW9SNFRKQlJjNCtFcHY2c3IrZDVjcmpXTmJYVDcxaUZJWDlaSytHRitYT3Vid3dlYzl2Rk4xTVVlNWtYTW5jVjJLVFAwYkZ5V3FvVWVxUFZvVS9DRldzTVhzNUEycFg4YjhMSXIrZEQ4eSs3My9GbWNpNHZaMFNkai84TDI1Zk9TRk1iT0svL1BzL2VxTFhtMS84MVY5NmNWRUFBQURBRFh5d0J3QUFBQUFBQUFCc3VSQmVGSUtMenA4L3I2dlRWelU3TzFzR0dBRUFBQUFBQUFBQUFBQUFnTjBoamhUYnlPandVRndHMENTNVU1YTdUbExvcmdFR1ZXdEc0OGhVSzFhS3JBa2hOczA5bFEvaG5QUHZiOW1hTXRpaEpieW42bzBZbnJsdXJzTFhXMCttVzdFdUdvc2k2czJyR0dPZXJWZGFzODRWblR4UG85akV2dFMxeDRYd29rNVdwQ3RKRWE4a3JyWTYxdHgzWWxOV3FKWkp0WlcwV0tua0pqblFLSU95aUtjWkVGVmo2c2Fxa2hTRGNmRzdTaVFUR3hzSjc4Rll2NlltL2UrOEk2N1FKNnJWNGRmOFNBS01BQUFBOEE0Q2pBQUFBQUFBQUFBQVd5YUVGbDIvZmwyZGRrZXpjN1BsN1pYbGxUTFFDQUFBQUFBQUFBQUFBQUFBN0Q0aC9TTU9QNkl5aktoZWRYY1BuN0RHMUswSnc5V3k1OUpEakRGNTRZYUtRbnMrYUdheitPMUd1Wk5aNnJ0YUpmTGJSYi9vMW1NVFZ5TlQwZjdtakZ6UFdKbkltTmhhV2UxaC9zamgrcm5MZXBsVENDOUtjcmNsNFRIOXpFV1pQL0JrZFpVSlJwWUlvNEZRaTlVMGhiSHRiRUFDakt4cCt1TlJ6ZitTSXNUb0x2emFxdnZqMUVsL0pKOFdBQUFBY0FzQ2pBQUFBQUFBQUFBQVd5WkpFbDIrZEZuejgvTjYrKzIzVjNzZWFUQTZuUUFBQUFBQUFBQUFBQUFBZ0kwcnd6L01Pd2tQZFg5blh3ZjN1TUxaM0dpb2NJUmVyRmMxTWtweW1XNVcxUHVGVXVlS1piOWxOUWd3Y3M0WTA1TXA0aWphKy91VmMwNjl6R1hkdEloV0VsZlZGdW5uSVFqS3FYQmxRaFFHUkMyMlRRMUllRkVRV3cyRlk1UFplekY3bThyWFQ5M1gwRW0vTjcwbUFBQUE0QllFR0FFQUFBQUFBQUFBTnRYczdLenlQTmNicjcraE5FM0wrMkZJZUJFQUFBQUFBQUFBQUFBQUFOaHpWck11S3M2RmtCU3MxODJJRUZjbzd1WWFpdFBDeEpHU3FsVWNXN3N2NjdMd1pkRzR2QzBUYVkvM3Nja0twOXp2Tkl2OTNPV0YyZEkzNitRcVJxYm9adXJrVm1hb29xYXc0NnArS3crYmdaWHIrdzBnZGpKYkZtTDFQbkk1bDFkalZXcXhNY1FYdlEralVXZjBDYjlmdlN3QUFBRGdGZ1FZQVFBQUFBQUFBQUEyVmJ2ZFZwWmxldlBOTjFVVVJYa2JBQUFBQUFBQUFBQUFBQUJnandwNUY3Rkl2Vmkza0JCeU15WEUrWnRaN21wcFpOSWtWeFliRThLTDlta1lsSEVkWHlQOXZaNWVwTlUzbVBzZnZVVGE2bjNIYUhXYlNuUFhEazg4VkdGbkhRU3hOWXFNYzhhWVZLNjhMTjVPQlJnVi9vQ1V4OVpHVlJ2Q3czQTNmajFWak5NSnZ4ZU5DZ0FBQUxnRkFVWUFBQUFBQUFBQWdQdVNwcW1TSk5IcDEwN3IyclZybXAyZExZT0x3bmdBQUFBQUFBQUFBQUFBQUFEZ1ZsVmJadGFFREp1K2NiTE9xTnJQMUV1TFlxWGFqRWFyMGY0ODd6R1ZvZ3NxSnZMeTN0NE8yWm50RnRjSzU2SkNianlFMXhpejllKzNrN2x1MVRxTkt5SjRaVUJVSW1NUE5HMmxteWxhN2hmYUNmWElGSTFZYVd4VUVkNlgzMVByZm5ETUg4Q1AvWVYvOE9uai9mYnkzSy8rMG9zZEFRQUFZTjhqd0FnQUFBQUFBQUFBY0Y5Y3VBS1dMMG1hcU5QcHFOZnJsUUZHQUFBQUFBQUFBQUFBQUFBQXdPMUNXTTJOdkJvblV3WVpxWkJ6eHBraURQZDZlTS9kNU1iWVRIdGZWcWdvbkNscG03akNPV2RYdHpjTUR1dTNBYXRpeDNaNnZ3VTZhNDNmTkxBQnNWOWhjWlFxanJOaHFnNEFBQUFsQW93QUFBQUFBQUFBQVBka2VucGFiN3oraHE1ZnY2N1oyVmtCQUFBQUFBQUFBQUFBQUFBQTYyR05LY2FxdHAwV3J0TE9YQzB2TkpMTGplUzVmN0NpZlNlVEZ2dHlXalFhMVI2VzM0Z1BXa21LUTlwbVdhR0t5WVVCRWx0angycW1ZWTFMVmhLM1dEalhjREpWYlFNakpkYW8yNnFhMmxnOUdpV0ZaMlA4ZWpxY0tYb3FidlcrNGUrdUNBQUFBUHNlQVVZQUFBQUFBQUFBZ0hWcnQ5dmxjSGw1dVF3dTZuUTZTdE5VQUFBQUFBQUFBQUFBQUFBQXdFWlVJbE54UnBISlhDWTU2MlQyYllhSXI0QWlsWEVoRm1Rdnk1MXpjdVdiM1BaMTdaODBMbHpJcmNHZ3NVYW1IcHVvbnp1VEZxNHd6dmd4Vzd1dXpJM25qSzNJTHJvSHZ2cXF6aFd0TEcxdFMrQVVBQUFBQmg4QlJnQUFBQUFBQUFDQWRYdnJyYmVVOUJPOSt1cXJLb3BDV1pZSkFBQUFBQUFBQUFBQUFBQUEyQWhyRkkwMTdHZ3ZjMmtuZFV1NVU4UDVvbjFxV2E3WE1Yczh2Y2hMY2lWWjRRcC9jOXZYZGVIY21IUGtGdzJpUm13cmNWT1YyYmJmUkhMWGMxWTF2emRFMmtMTjJGUW1tMUVsdGxMRVpuRVAzSVExOXRFaUtsNFZBQUFBSUFLTUFBQUFBQUFBQUFCM2tlZDVHVlEwYzNWR2FacnEyc3cxWlhsV2pnc0ZBQUFBQUFBQUFBQUFBQUFBMktpYmVTRVZxNmhWc2JXa0tOVExYZG92WEw2Y0ZNNlB6OFBqMXBxVzljUFk3dTJFa1k1Y3ZhdndUdmQyaGxGV0ZFbVNLMXd4YmQrR1ZlRk9ZZThPSVVMVldLcjdZWklwejFkM2hzMCtCenFMakZFMWttcVJySC9PUFg1azJUcEd6dS9EWnFJd2VWVUFBQUNBQ0RBQ0FBQUFBQUFBQU54RkNDM0tza3pmK2M1M05EYzNwNldsSlFFQUFBQUFBQUFBQUFBQUFBRDNLd1NXV0d2czVKQVpXdTZyNzVLaTIwNWNzdHgzV2JPaXhCcmovTEFWcHR2ckFVWUwxb3gzOW5oNFVkRFBYYmVYcXU5dmpndTR3ZS9yc3BFMFZMT3E1REp6Ulo0Vm1lVE01cDREYlp5U0tISWFyVWVtR2ltcStJRndUL3pSYXRUL1BCRVhhZ2tBQUFBUUFVWUFBQUFBQUFBQWdIY3hQeit2eTVjdmEybHhTWjFPcHd3djZuYTdBZ0FBQUFBQUFBQUFBQUFBQURhTENTRkdUcXJISnBheFpxbFhWSlBDdVhabWNpT25mbGI0aWVTcS9TS05yTWw4U1J1eEdoVnJxcEdmMmV5UlhLT3VmNi83b1dkT1hwZ29MUXJPYThXNzh2dDFIQnRqVlpleVhKcnI1eXQrdENtY2huUWZyRFVyY2s0VDlhZ2VXYWtaVzFuanJIRHZqS240S20wYUc3RS9Bd0FBb01RZmhnQUFBQUFBQUFDQU80U3dvaEJnZFAzNmRiVlgyZ0lBQUFBQUFBQUFBQUFBQUFDMlFnZ2hpcTJpdWt5MDRtODdGOEpMWFBsWTZvdnpZenBTN3FkSjY3RjZJYnpJM3c3alpiUTNFb3d5WC9JOUVzWjBOMzZkK1hkcHlyVUgzTTd2MnlGVXlJYlVzaEJ6dFppWW50OVNiT0hjL1FVWVNZa3hwbWpWVE12NkxiQWFoYkg3WUlmYlNzNUZvU3FOS3dpQ0FnQUFRSWtBSXdBQUFBQUFBQUJBNmEyMzNsS24wOUdGQ3hmS1lTaHBrZ283cDFLcEZNMW1Nejk1OHFSOThNRUhvNUdSRWNVeFRmc0E5cWU4eUtjWEZ4WS9QMzExK3FVLytJTS9lUG5kcG9taUtIUmFmTlFZODVTY2ZsNTd3UEhqeHpVNU9hbEhIMzFVclZaTEFBQUF3SDUwNnRTcHNzMXFibTVPU1pKb0wzaisrZWNWMm5xbXBxYUU5OVpQK2krMVY5b3Z2WDN4N2E5ODdXdGZPNjA5NE0vOG1UL3phNVc0Y2xJQWdJSFI3WFYxZFhwYTMzcnBHM3I1NVcvZWRkcURCNmYwb1E5L3hMZlhQYVpqeDQ0TEFPN21qVGZmME9VcmwzWHh3a1crZXdmV0lUSkdObkt5eG1TU3kvMzNmZFdiNlVRbVJCd1pWWFBuS3QzVU5aTENWRUppUnJOaVZ2eDgrWERWREVmVzJHZ1g1cEhrVXNmNTk5dVhHK3FYd1Q1N1cxRm9PQzhLUjNnTTdpWU9LVVArSUhCMDJJNnFrRm5LWEQ4dmxQYXlvcE1YcHVhUEJYWG5YTlVZczJaRDh1T2NINVg0NDBJdnNxNWZqVXlqRXBucVVFVXRQODZFNENLMnZNM2haQTRidWJIQ3VVa0JBQUFBSXNBSUFBQUFBQUFBQUhCRHU5M1cwdEtTcHFlblEyY09GWGtoN0N4cmJRZ3NjcU9qb3pwNjdLZ21KaVpVclZZRkFQdFV6NWZ6dnJ6OGt6LzVreSs4MndTLzhpdS9NdVlIYmY5NzdMRDJpQkJhTkRZMnB1TVBIQytIQUFBQXdINTA4ZUpGMWV2MXNxMWtyemg4NVBEcTMvckhDVDU0SHd1K25QL0UwNS80bzUvKzZaOStTWHZBWC8ycmYxVUFnTUhTOGQrUnVTTDMzOEZVMU8yMDd6cXRNVTZ0b2FhT0hUK21reWRQQ2dEdTV0cjhOUzJ1TEFyQStvUVlrcEJTWkkwTEhWWnU3N1JpNUJRNWxZRS95ak5Yam96OHpZcFZxdXJ1alNRSjRVVk9KZ3Z2YXovMDFIRk9GVWVFRE42SHZSRmQxb2hOcFhETzFaelNWQzVOamVrWDVhNnZ3bGhUaE9QQ21obkRrU0k4Sm1XUm43WVdtVW9sTW5Fek5uVjdXOWdSN28rdnpMci9XVGZPY1o0NkFBQUFTdnhoQ0FBQUFBQUFBQUQ3MU9MaW9ycmRydjdnOS85QXZWNVBuVTVIMkhuMWVyMW9OcHZ1UjM3a1I3S3g4VEY3N05neEVvc0FBQUFBQUFBQUFBQUFBTUMrVUkzc2NpTXVPcjNjSFhIdTd1Yy90ak0zR2lLQS9IQ2hZbzJPalVUbEZVR2lYUlJUMHBQcHBrWjlaOHl3djd0MzBwdUJUUktDaDhacXB1RnZoakwrZnBQZm1DNlVBd0lBQUFDd2JRZ3dBZ0FBQUFBQUFJQjlKazNUc29UQW9oQmc1SnhUVWV5SGE3Z050bHF0Vmw0ZWNHUmtSTTFtVTVWS3hVVFJidXBTQndBQUFBQUFBQUFBQUFEQS91UkM1d3VWWC9IelBmLzlNcXRDTU5GNk9Ua2JwczV5VjFncjQvK2JzQ1oydzhvb3dxdDNHM2l6QUFBQUFBQU1JQUtNQUFBQUFBQUFBR0NmZWV1dHQvVEc2MjlvWVdHaERERENZSGowMFVmVGtkRVI5NE0vK0lPMTBBK3ZWcXRGQWdBQUFBQUFBQUFBQUFBQWc4M0orZS81ZTBZSzMvTlhoZnRTalZRYnF2Z0t6V1RYbStxVEZSckpDMWRjWE00WDZyR0pEN2VpRVJNaXBYWkJnbEhIYjBGZEkxZUVOMHY4RlFBQUFBQmdseUxBQ0FBQUFBQUFBQUQydUR6UHRiUzBwQ1JKeXVIMDlMUTZuVTQ1SGp2SFd1dXExYW83ZE9pUUdSb2FNZzg4OEVEVUdtNFZVUlRKN0lZZWRBQUFBQUFBQUFBQUFBQUE3RExXckpiTjVML2lEd0ZHZld0TVJRUVkzYmZZS0haUm1lV3pvVFhsbkV6aFhDMHI1RHBaMGFzWkcxZmo3VDEvTXZURXlVS2kxUVpldXQ5d0dsMjV5TTlsOTNLQ1VWNlVXVjlhYnlnVmdOM0JSU2I2bVY5NW92b2IvKzJwTlB3K0ZBQUFBUFl0QW93QUFBQUFBQUFBWUk4TFFVV1hMbDBxdzR1K2MrbzdvVGNRM1lFR1FBZ3ZHaDRlenA1NjZxbjRvWWNmTXExV0s0cmpPQklBQUFBQUFBQUFBQUFBQU5nU2xjaHNma2FNVVJGYnRhMXhUWDl2U0xndmNhUmFaRTJ0dlBpVDIwRC9GaU9UT3czMUM1Zk9kNHZGc1pwclZ1Tm9XOCtmTFB4TFR2d3czOERMN2pnM3NoTGU2aDYvMkZWZU9HVytYZ3E2TEFGN2lwR3JIbnR3cXZtWC8vTFBMa20vd2g0T0FBQ3dqeEZnQkFBQUFBQUFBQUI3VUxmYkxZT0x6cDg3cjM2L3I1bVptWEpJZU5IT2lxTEl0Vm90UGZUUVE2WTUxRFRqWStQUjRTT0hUYjFlbDdWV0FBQUFBQUFBQUFBQUFBQmc2NFNJR1AvdGZCRlpkVnlodUpEcXVrOSttYllScTFHSmJGVzRiMUZJaERKTzFxanIxNVZmVFdwdVpINVh1Q2cxYWlhRnNmMjhTQ3ZXUk5hWWJlbVU0VityMGh2RDlYSWJuQjRBQm9seGRqUlRjZmp5a2Q5cWk4TVpBQURBdmthQUVRQUFBQUFBQUFEc1FTSEFLRWtTblRwMVNwMU9SMm1hQ2p1dlVxbTQwZEZSUGZYeHAweXIxVEtUazVPUkFBQUFBQUFBQUFBQUFBREF0ckFoYmNnWUZ4dlR6bzJyRis3K0E0dzgwNmpZUmlVU2ZRQTJnVEdySVVheFZkYzVVeFNGMjFpQWtZeE5jelg3bVV0cmtWTHJsMmdqYlV1QVVRZ2pTbThNMTZ1NFViZ2NHWUJkYWxTS0R5ZlY0WE5hUFFRQ0FBQmdueUxBQ0FBQUFBQUFBQUQyZ0R6UHk4Q2k2ZW5wc3N6TnpwWDNsNWFYNk9HMHc0eU1lK1RSUjdKYXJlYSs1N252cVZRclZZMk5qeW1PYWFJSEFBQUFBQUFBQUFBQUFHQzdXZVBNZ1lZWjcyWW1tdThWdWgreDFWSnNqR2xWYmRQSWJVdEl6bjdSakl6TmZZM085Kyt0NDBzdmMxbmgxSnVvdTZnU21ZSHRwTkV6VGl1aWV3OEFBQUFBWUhmajdBZ0FBQUFBQUFBQTJBT0tvaWhEak5ydGRobGVORHM3V3dZWVlXZUY4S0p3RGIvaGtXRlhyOWZkaVJNbmpBQUFBQUFBQUFBQUFBQUF3STd4MytYYmFtU3JTWDcva1RGK1daazF4c1pHVWJpSHpSTkZ2bWFkdStkS3pRdTVKSFNwR2ZCc29Ed1VOaDBBQUFBQXdDNUhnQkVBQUFBQUFBQUE3R0w5Zmwrblh6dXRoWVVGWGI1OFdWbWFLYzNTTXRBSU8yZGtaQ1FmSGg3T1AvclJqOFpIangwMUJ3NGNxQmhEYnpNQUFBQUFBQUFBQUFBQUFIWmErUHErRmttMlpsU1BJM1VTMTE3SlhDZk5pM0VuYzlmejdZeGN4OCtadG1wK1FyK2NzVm8wSm15SlZsWERvY2F2ZGRRTGw0OXlSdFdOekY4NDE4Z0xWMDh5WS9xUlU5VWFEV0xYamV4R0dlaVVKUUFBQUFBQTNnY0JSZ0FBQUFBQUFBQ3d5MlJaVmc1N3ZWNFpZTFM4dkt4MnU2MzJTcnNjNytqU3RDT01OYTVhcVpwS3BSSUNqRFEyTmxhVzBkRlJVNi9YWmEwVkFBQUFBQUFBQUFBQUFBRFllZUVpUkpGMXFzaW9Fa25WMWE0V1JlSE11eWZKM0FpK3NUZUdJYnlvNHUvRWthRXp3QmF4WnJWdUk2TndHYStOUncrWjhsSlRKbmR5dnVSaFVSb296aXUzTmt0UEh3QUFBQURBYmtlQUVRQUFBQUFBQUFEc01wY3ZYeTVEakw3OGUxOE9YWm1VcHFtd3MwSjRVYXZWeWg5ODhFSHp6RFBQUkdOalkyVVJBQUFBQUFBQUFBQUFBQUFZU0ZFSU1mTGY3TmNhWm1oY0dzcmQ2dGY4U1VpOHVTMVJKaVRoeExZTTAybGFzL0VzSFd4Y2RLT2F4K28yelFwWExQWmRUZmVnWDdnbC82TlhhOXJKU0daZytuTGtScjFDcGxjNE55ekRlWjRBQUFBQWdOMk5EN1lBQUFBQUFBQUFNT0NLb2lpRGlycmRybnE5bnVibTVsVGtSVGtlTzI5OGJOelp5T3JRNFVQbTBLRkRwbDZ2SzQ1cGZnY0FBQUFBQUFBQUFBQUFZRGNKZVRraHQ4aUc0VzBaUlNHemlOaWluUkZiRXhYbGFuR1pYdy9HT1cwb2hNaFA3M0lYYUZ0VzR2cWZ3aFQrSldWdWRiUER0dkRia0JRNlhGVUZZRlA0UTJ4UldKTU5MMTdrV0FZQUFMRFBjUVlGQUFBQUFBQUFBQXk0TE11VUpJbGVmZlZWWGJsOFJmUHo4NFFYRFFCampUTXlldWFUeitRaHRPanBaNTZtelIwQUFBQUFBQUFBQUFBQWdGM0sza2llaVdLaWlnYkpTTTIydW1tUkxSbTFuWE1WSjlQY3lQeEo1bHhtVFc2MklTZ29iRG14MWhkaVZEaWxxZFJ4UnNQK2JrWFljcEd4QzlhV055Y0ZZRlA0NDEydldwaVZTNGVyQkJnQkFBRHNjNXhNQVFBQUFBQUFBQUFEcXRmcjZlclZxMXBaWHRIeThyS3VYYnVtVHFlajFVdkNZYWUwV3EyOFdxMFdKMCtlalB4dGMrTEVDUnZITkxjREFBQUFBQUFBQUFBQUFBQnN0aEFHVkxHeUl6VmI2K2N1NnFRYjZ6ZVRTM1huWEZSSVVhU3RGWlpmYzZ0RERCNWpsQmtyQUp2SUdTMG1McDNXWno3c0Q3ZW5CQUFBZ1AyTE15b0FBQUFBQUFBQVlFQ0ZBS01MNXkvbyt2WHJtcDJkRlFaRHM5bk1SMGRIODA4OC9RazdPVGxwNi9VNmwxNEVBQUFBQUFBQUFBQUFBQURZQXRaSXNUVjJ1R3JxTm5IcXBQbUc1bmRPamR3WGJZUFlTWFVaQW93R2xOK1Vjc04xNDRETmxidWx2L1ZuWDVnV0FBQUE5ajBDakFBQUFBQUFBQUJnZ0Z5NWNrVkprdWppMnhlVnBxbG1abWJLKzlnNVVSUzVScU9SVDA1T211UEhqMGRUVTFOeGE3aGxSMGRHYmFWU0VRQUFBQUFBQUFBQUFBQUFBTGFPdFVaVk9SVlZrNDg0azNkVEY2ZUY3SHJtRGFFMWtpdkduWEUxWnpSclhGVUFBQUFBQUdCVEVXQUVBQUFBQUFBQUFBTmthV2xKN1pXMjNuenpUUlZGb1N6TGhKMWxyWFcxV3EwWUh4KzNqMzdnVVUxT1R0cFdxN1d1VG5BQUFBQUFBQUFBQUFBQUFBQzRQOGFYT0lRWU9ibG14ZVpKWHRpMGNPdnJ1MkZVV0dmeUlUOXYzZCtkRlFBQUFBQUEyR3dFR0FFQUFBQUFBQURBRGtyVFZFbVM2TVVYWHl6RGl4WVhGc3Znb2pBZU84ZmExVDV1UC9SRFA1UU9qd3liUng1NXBPSXBqdU4zSGdNQUFBQUFBQUFBQUFBQUFNRDJpU01YalZnVFJkYW1TZTU2ODUyaWxya3kzK2dPRmFOZXpaamUwMVhiUEY2eHRVbGpaQW9wdGFiWGwreXNjVlh0TEZNNEY3MzdxOGRXeUYzUnNJVUFBQUFBQUZ1QUFDTUFBQUFBQUFBQTJFSE91YklrL1VTZGRrZTlYcSs4angxbXduK2o1bERUTlp0TkRROFAwMTBNQUFBQUFBQUFBQUFBQUFCZ0IxbUZGQ0lwTXM0WDQ2dzFoWElYdmZ1MGNyNFVkV3RjeXhoVDhUT0dTMVpWNUZ6dTVIWTZPTWl0OWs0eHpqbERpTkUyY1g3N29Wc1dBQUFBQUd3SkFvd0FBQUFBQUFBQVlBZGN2bnhaMy83MnQ3V3dzS0RGaFVWaE1Eend3QVBKeE1SRS91a2YrblM5MFdpWWVyMiswMWZiQXdBQUFBQUFBQUFBQUFBQXdDMmFzYTAyWTZrZUdSVk91dHJPbHJKQ0puY2E5cVBTSVdPV1AxR05HaCtyUlJQaEJNcm9sb0NnanhXbXNTQ25ucDh2OGZlN094UWUxRFd1bURQS01oR3BzMTBLYWJ3Z0xRb0FBQUFBdGdRQlJnQUFBQUFBQUFDd1RkSTBMWWU5WHE4c1daYXBLQXBoNXhocnlzdllWYXRWVlNvVk16UTBaSnBEVFdQQ0Jmc01IWllBQUFBQURMYndtVEtVOFBueWRuRWNsd1VBQUFBQUFBQUE5aXJyaXpPK1BkUWFLK05rTTFmVS9jMWhZMnpWclBiOGVMZmVINzdsMU5XMG1oelVjd3BkUjBnUkFnQUFBQURnUHRCTENRQUFBQUFBQUFDMnllblRwOVh2OS9XdGIzMUx6amtWT2VGRk95Mk9ZamN5TXBKOStNTWZqcDc0OEJQUjZPaG9wZEZvVkFRQUFBQUF1OER5MHFJV0YrWTFNMzI1RE1xOTFlall1SjU4Nm1rQkFBQUFBQUFBd0Y1VmpWZmppWTRPeHkwNTVaVmVNVGR1VE9XWlNqUVcrZkh4ZTF5N3F1bmtQcG5iL294VjlMb3BxaDBucFZ6bkNnQUFBQUNBZTBhQUVRQUFBQUFBQUFCc2tTUkpsT2U1cmwyN3Bpek5kRzNHRDdPc0RDOEtCVHZEV0tOcXBlb09IejVjMU90MU16VTFaWThkUGFaR282RW9pZ1FBQUFBQXU4WGk0b0l1WG5oTEwzNzFEN1cwdExqbXNRODg5aUVDakFBQUFBQUFBQURzQzJYMmtIRzJIcGw2VGNiYW0rUGVnelV5aFV4VWxkTUJaM3FGS2FxWm4yOHpldk9RZ3dRQUFBQUEySThJTUFJQUFBQUFBQUNBTGRMdGRzdnk2aXV2YW1GaFFaMU9SOWg1MVVxMUdCb2FjczgrKzJ6bWgrYmtReWVyQWdBQUFJQmQ2T3FWUzNyNUcxL1hiL3lEWDlPRmMyZlhQUGJjODUvV3ovN3AvMHdBQUFBQUFBQUFzTmRaSTBVeVpxUnFXaTBuVmQ0M2ljZ1lLMWNkYytvMVpWWVNZMW85cVo3NVIrNG54Q2lFRjRWTFoxa0JBQUFBQUxDL0VHQUVBQUFBQUFBQUFKdHNjWEZSVjY5ZUxZZmRUbGZMeTh0SzAxVFlXUWNQSHN4cnRacDc4T1NEVWJQWk5GT0hwcUpLcGNLRjd3QUFBQURnUG56K3QzNVQ3ZmJLbW5Fam8rTTZmT1NvanA5NFVPTVRrOW90L3RrLy92L2RNZTd3a1dQKy9ZenBvVWNmVTZzMUxBQUFBQUFBQUFDREtRUVBkZnpQcXRiZkZjUlBHY2RTODZDelJVMUY5NUpSdGJlYVFYUlBJcG1rNlY5R0xPTUg0b0phQUFBQUFJQjlnd0FqQUFBQUFBQUFBTmhrSWJEb2pkZmYwTUxDZ3JyZHJqQVlwcWFtOHBIUkVmZnNzODlHOVhyZDFHbzEyc2dCQUFBQTRENzltOS82VFYyZnVicG1YQWd1K3Rnbm50VlFhM2hYQlJqOTVqLyszKzRZOTdGUGZOSy9uNU9hT255VUFDTUFBQUFBQUFCZ2dCVytkSTNVQ0hmYyt1YXhVaHpLSWVmYUI1enR6WnFpMHJPNlo3RmNNdVRNWXV4Y0xCa0NqQUFBQUFBQSt3WW5ad0FBQUFBQUFBREFKbmpycmJmVWJyZDEvdng1ZFR0ZGRUb2RwV2txN0p4cXBWbzBoNXI1dzQ4OGJCOSs2T0hvNE5UQnVGcXRhbmg0MkhnQ0FBQUFBTnkvTjE0N3BZc1h6cTBabHlSOVBmTFloL3puNGtTN3lTc3Z2WGpIdUlPSERtdHM0b0NLUEJNQUFBQUFBQUNBd1JaYThSTG5zcjVNTzVacWtWUmZ6M3dWbVhBVnJPcERNdjJPVStlMGNTTUNBQUFBQUFEclJvQVJBQUFBQUFBQUFHeUNFRjYwdExTazZTdlQ1VlhjM0hvdjVZWXRZeU9yU3FYaXhzZkdkZnlCNDJxMVdqYU9hUllIQUFBQWdNMjB1REJmbGx0MU94M2xXU2JuZHRkbjQ5dmZSNUQwKytWN0tYYlpld0VBQUFBQUFBRDJvOUNLVnhpNXdpa3RwRXEwenZtTUZJZExZUTM1NXMzWUtSUFh4UUlBQUFBQVlFTTRVd01BQUFBQUFBQUE3c0g4L0x5eUxOUFh2dm8xZGJ0ZGRUcWQxUWNJTDlwUnRWcXRHQm9hMGcvLzhBL2IxbkRMSERod29GS3RWa09Ra1l5aGR4a0FBQUFBQUFBQUFBQUFBTUJlMWpmU0plUHN1R1FPdUkzMUZSbDNHczZkM01ka0ZucEc5clJ4SXh1WlAvTFBXWGN5a1loQXVsMGxNb3JsWktrWkFBQUFBTmlUQ0RBQ0FBQUFBQUFBZ0hWd3pwVWx6M09sYWFwMnU2MGtTYlM4dkt4ZXIxZU93ODZwMVdwbGF0VFkySmhDZ05IWStKaWF6YVlaSGg0V0FBQUFBQUFBQUFBQUFBQUE5b2RDc2wwcEdybUhFQ0VqWTJML295R255RWxWdVNMejl3dXQvNnBaa1M5MkhkT0ZCUm9YbmxMN1FxaEJzMy9lTGdBQUFBRHNPd1FZQVFBQUFBQUFBTUE2WkZtbWZyK3ZjK2ZPNmZ5NTg1cWRuUzBEakxDelRPaktaYVVuUHZ4RVdxL1gzUi8vNDMrOEpnQUFBQUFBQUFBQUFBQUFBT3hMbVJSZHRXNTBxRENhMHIyWmNtWXNseXNpMllWcnp0WE9XUTJ0Wjc1WXhnMzVFanU1OTB2cXFUdGpEemhGNStUSTlBRUFBQUFBN0hvRUdBRUFBQUFBQUFEQSsxaGFXaXJEaXNJd2xCQmtWQlNGc0hPaUtISnhITHZXVUV2TlZ0TWNPblJJL2o0ZHVnQUFBQUJnbTAwZFBpSnIxMTVQL01peDR4cHF0VlN0VnJXYm5EajU4QjNqSnFjT2xlL0ZmdzRWQUFBQUFBQUFnTjBoVnhsa2xDZStSS0diaVMrNkJ6VXByaHZaVnFFc05jNG14bGgzbCtsOVM2a3hjcEgvYWQ5djJVYnlpM0l1ekNBQUFBQUFBSFk1QW93QUFBQUFBQUFBNEM1Q1dOSHAxMDVyZm41ZWI3Lzk5bXJYSWZvTjdiaFdxNVdQalkzbFR6L3pkSHppeEFrN01qSlN2ZjJFV1FBQUFBREExdnMvL2tmL3FaYVhGdGVNRzU4NG9PTW5UbXFvTmFMZDVPZCsvaGZ2R0hmOHhJUCsvVXlxMFdnS0FBQUFBQUFBd09BTGx5VHIrN0pvWEhkT2FvOUtJdzFuR3RxZ1NNWk91SExlL3JCeFMxZWt4bFZmTXVrOWV3NFpwN2dpTTJUV0Y1amtyREc1bkN2VGpBQUFBQUFBMk0wSU1BSUFBQUFBQUFDQTJ5d3ZMeXZMTWwwNGY2RWNUazlQcTlmckVWNjBnNHd4cWxRcnhWQnpTQTgrK0tBZEd4dXpZK05qT2pSMXlOYnI5Zkp4QUFBQUFNRDIrK2pIbjFHLzMxc3pMb1Q5akl5T2hmQlo3U2JQUFBkOWQ0d2I5ZStqN3Q5UHpYLzJCQUFBQUFBQUFMQjdkSXlwVHN1cFZwaktodE9MYmxHUm9tSGY3Rms0NityT2RXYU1xL1g5dU1UY0dXUmtqV0lyVnpmT2NON21BTEpXUzlhV2EyMTNwZThEQUFBQXdDN0FCMkVBQUFBQUFBQUF1RTBJTUFxQlJTKy8vTEtjYzByVFZOaGhScTVXcXhYakUrUG1xWTgvcFRMQXlCY0JBQUFBQUhaVUNERGFLejc1M1BNQ0FBQUFBQUFBc0RkMDVLcXBVWFhLU09QM2NiMnkyUDl2T1JQWC9DSW5aRG85dWNxeVVaUzh5N1QrcWFMSW1mdkpTOElXaW1TV285VnJwQkZnQkFBQUFBQ2JqQUFqQUFBQUFBQUFBUHRlbnVkbFNOSGx5NWMxUHpkZmxuN1NWNVpsd3M0eHhwVEJSUjk0OUFPdTJXeTZSei93YUZTdFZqVTVPYWt3QkFBQUFBQUFBQUFBQUFBQUFONU42UFVUY291V2pldk5GY3JHaklhc2pORTlpcVNxbGV4Sm1ienZWRnlVVE9LY25iV0tJLzlFb1NkTDlUNkNrdllMdndhNmZsRDRNaVFBQUFBQXdKNUJnQkVBQUFBQUFBQ0FmYThvaWpLc2FHWm1SbGN1WDlIaTRpTGhSWVBBeUJuLzQ5Q2hROFhZMkpnKzhwR1AzSE1uTWdBQUFBQUFBQUFBQUFBQUFPd2ZJVXNvOVA3cFNPbUtWWCtrVU5PR2ppajN5SzZlaXhtUE8vV2NUTDRrWjd2R3VGbTU4aHpORUdBVUNldVErYnJNQ2dLTUFBQUFBR0JQSWNBSUFBQUFBQUFBd0w2MXNMQ2cxMCsvcnVYbDVUSzhLSVFXcFdrcTU3Z2MyazRhSFIzTnhzZkhzKy85dnUrdGpvMk5tWkdSa2NnWXNvc0FBQUFBQUFBQUFBQUFBQUN3TWRQR3RXYmxoaVpNbERVbFo2V2E3b01wNTNkNjJQbWZ6aFFQR2JPVStNWE9HMVZIWGNnNTRwek51NmxHcHBjNTlmdVpHOWMycTBXS0tySG9HQVlBQUFBQVc0QVB3d0FBQUFBQUFBRDJ0WDYvcjI2M3EzYTdMUXlHS0lwY3BWSnh6V2JUall5TTJGcXRKZ0tNQUFBQUFBQUFBQUFBQUFBQXNGR0ZqRW1OUXMrVEVGeXpDZUUxcTcxWUt1WEMvRzNuUWlpU3E0UndKT05IRVk5emQyYTF2clFEd3BvelRuUkNBZ0FBQUlBdFFJQVJBR0JmTzNQNk5jM01YTlczWC8yV2txU3ZUcWR6eHpRZmVPeURtcG82ckE4LytUR05qbzBKMkUvNnZaNWUvTm9mYVhGeFFhKys4dklkajlmcmRWbHI5ZkZQZkZJam82UDZ5RWVmRWdBQUFERG9UcDgrclRSTjlZMFh2NkdpS0pSbG1iQ3ovT2NLTno0K25wNDRjY0orN0ttUHhXTmpZNVZRQkFBQUFBQUFBQUFBQUFBQUFOeUgvRVo1elRvWFMrNWp4ZWJsMXhnNVc1RkdLLzdXTU1GRjZ6SlVpVVpya1N1Nks3bTJXN09pdzVWb2QrY1haWVZUN3B4ckorckhWbmFrWnFzQ0FBQUFnQUZBZ0JFQVlGL3hiWFRseWFuTHkwdGFYbHpTcFVzWGRmMzZqQllYNXBYbnVYcjkzaDN6ek0vT2xZK05qSXhvWVg1RWg0OGVLOGZYYW5VQmUxRTRlVHZzSzVjdlhsQ3YxOU9WSzVmVVhtbXIwMm5mTVczdXB3MVhJUWpUckxSWE5EbzZybXF0cHNtREI4dnhJZHdJQUFBQTJHbmhjMkQ0RzdmYjdhcmI2V3BoWWNIL0xadXZqdWVTWnp2blJsK2dBeE1IWEFnd09ucjBxSm1hbWpJaEtEV09hYm9HQUFBQUFBQUFBQUFBQUFEQTVrbWNiQ2E1WEM0MWtyRXlPOXBCeGI4R2ErUWl2ZE9MWm4rSTVIelZtOUJ2cXdqM1RWZ1ZXODBvRDA4WUdVV3gyVjMxN1c3OHlKM3ovK1Y2dVl0eVZ3WVpKVlkyYkQ4RUdBRUFBQUFZQ0p3RkFnRFlWOExKcWYxK1R5OTk0K3Y2MmgvOW9hYXZYTmJTNHNKZDU3bDQ0WHc1ZlBIcmY2UjZyYTVmK00vL25HK3hqSFgwNkhFQmUxRzd2YUlzVGZYMy85NnZsbUZHVnk1ZmV0OTV6cnh4V28xbVV5OS84MFY5OEVNZjFvLysySStyV3EwUllBUUFBSUNCRVA2dVRaSkUzM3I1VzdwNDhhS1dsNWZMUUNQc0xCdTZnUm1qNy8yKzcwMnIxYXA1OHNrbkt3SUFBQUFBQUFBQUFBQUFBQUMyd0RYcnlxQ1hsY0plajUwcVE5S29kcEF4cmxKeFpzZzZGKzJuQ0tOcWJNcytRbGFtRjlLTG5GTk5XOHhLWFdPVU55dG1PTFoyZHdVWXVkVVFvK1hFZGJQQzVmTzlZamhjMjcwU21mbEdwYWlOS1JvU0FBQUFBQXdBQW93QUFQdks4dktTM2p6enVpNWRlbHVMaXd0SzAyVGQ4L1k2SGVWWnB1K2NlbFhONXBDbXBnNzVCbU9yS0lvRTdBVjVudnZHN1VKdm5QNk9WbFpXeWlDakVQcTFYbW1hbHZ2VnpOVXI1WDd5OE1PUGFuemlnQUFBQUlDZDB1MTJOVGMzcDE2M3A0Ny9UTGU0dUtnMFNZV2ROVFEwVkZTcjFlTEkwU05ScFZJeEJ3NGNzSEZNVXpVQUFBQUFZSDlxcnl5WDM3Tk5YN25rMnkwU2YzOUZXWjZwOE9YQTVFRkZjVVdIamh4VHJWWXJ2NmZlYkVuU0w1K3p2YkswK2gyaEwrRjFoTy9TdzNlSDR4T1RDcC9iYS9XR1dxMldwZzRmM2REeXIwNWZMcGZwMndEQ1JkVjEvTVJEQWdBQUFBQUFBSGJTTlJYMWxtK3NhanFUK1VZd2E4S0pJVHZBT0JOWnVhclpSK0ZGUVhpN0laQ25HY3NWL2tZMzE1YXJ4NmJpS3p1czYxMVQyN2x6THMxTmtmbEtTZ3ZuZXBtcjVLNnd6b1hZSnlsY2E5cHFQMFZmQVFBQUFCaDBuQlVDQU5oWGxoY1g5YVYvKzl1YXZYNnRMQnVhZDNtNUhIN3AzMzVlWTJQaitzUXp6NWJoUlFRWVlhL0k4MHhabHVscmYvU0hPbi91ck9abVp6YzBmNWFtdW5ybHNycWRqdWJuNWxUN3lUb0JSZ0FBQU5oUkljRG8xS2xUV2xoWTBPTENvakFZSmlZbU1sL3k1ejcxbkJrZkg0L3E5VHJ0MUFBQUFBQ0FmU3Q4YjkzcHRQVzdYL2ljLzQ1dFZoY3ZuRk92MTFXLzE5T1RUejJ0VWYvZDlBLzkyRTlvWkdSMFN3S01RbGhSZU00TC92dkJVTUx0OERxV2x4YkxpNTJFMXhEQ2l3NGRQcUtISDMxc3d3RkdiNTE1WFdkOUdmYXYzMXBMZ0JFQUFBQUFBQUIyM0RtcjFxaHYvSnBTMURQR2hCTkNhdG9CVnFwS3BtcktPSi85dzk2STNCbHJXSmNWVXJlOS9vc3UzNnRXeGRicXNWbE4vdGtsc3R3VW5iUkkyMm5oMnFrTFVVVlZ2Nm1VMjJwNEY3R3Z5c2c0QW93QUFBQUFEQXhPREFFQTdBc2hsT1hjMlRPNmZPbVNwcTljVnIvZjA3MEtWNTBNb2V1blh2bVdKZzlPNmVURGp3allDeTVmdXFqck16T2FtNXN0dC9ON0ZUcFloLzNzL0Z0dnFsNnY2WUVIVDZwV3F3c0FBQURZRGxldVhGR1NKTHB3NFlMU05OWDE2OWVWSnFtd2M2SW9jbzFHSTUrYW1qSVBQdmhnZEhEcVlOeHF0ZXp3OExDdFZDb0NBQUFBQU94dWYvbS8vbVV0TGE0TkRqNXg4aUU5K2RRemV2eUpqK2pvOFJQdk90OHJMNzJvTDM3K3QveThDMnZtLzc0Zi9HR05qSTdwUjMvOFQraGVoTytwcHE5YzFPZit4VCs5NDZJMlR6ejVsUDdzbi91TDd6bnZYL3J6djNESHVDZWYrb1IvUDQvb2s4OTlYeG5DY3pjejA1ZkxJT1YvOEwvK2JiWGJhNzl2KzlCSFBxb2YrT0UvWGdZQmhWQ2lMNy93UlMwdXpPdTNmdk1mbDIwWTRVSWhTZEwzMzlNdHkrVzU4cnpRMWVrci92dTJ1bDc4bzkvWGlKL25aLzlQdjZDeGlRTytYcC9VL2VoMk8rVjNlcC85NTc5UmhoVzkvSTJ2cTcyeTVNdUtmLzZsc20wbFhMd2tuRGQxYldhNkRCNXFOSWQwWVBLZ2Z1Y0xuOVdIZlQwKzhlVEh5L1ZjcnpmZTlUbE92ZktTdnUzTFY3Nzh2K3ZzbWRQNjhUL3hKK1hiQndRQUFBQUFBQURzdE1TWHRwRXVHMmRhenBpeC9aVWZORERxa2EwVzFtbWtacElrbCsxbGJ0UFBkYTNISnF0R0t1b1ZWYXEyUEJWb29QVXo1NXRsblZ2cXUzYnVYTlRQVk0xV3QwL25DbWR2dm9FeXdNaWF3bXFmcFY4QkFBQUFHR2dFR0FFQTlvVTh5elJ6OWFxdVhidGFkb0M5SCtGS2w2R0Q1dVhMbHhURnNVNktBQ1BzRGZOejgrVjJ2YnkwVkc3bjl5cDBaZzc3MmZYWmF4cjMrOTNCcWNNRUdBRUFBR0RiTFBtL1owTWc1NWt6WitTY1U1RnYvUlc2Y0hmK003U3IxV3JGeE1TRS9lRGpIOVRvNktodE5CcFdBQUFBQUlBOTRRdWYvWmU2ZU9IY21uRlBQdlcwcXRXYWpoNS9RRWZmWTc2cjA1ZjFPNS8vMStWd1p2cktPK05EWU0veEV5ZnZPY0JvYVhGZWx5NmMxNWUrOEZtOThkcXBOWTg5OS95bjd4cGc5RS8vNGEvZk1hN2JhZnZTMFFlZitNajdCaGd0TE15WDcrV3ovL0l6dWo1emRjMWpQL0REUDFZR0Q0WHdvckNVQytmT2x1WGYvS3ZmZk0vbGhib0pRdGpUK01RQlBmTTkzNmVwdzBmdk84QW9CQ1l0THk2VzRVS3oxMmZLNGZ1OWhtQ28xZExwVTY4cVN4Sk5IanhVaGpHOVY0RFI1VXR2Nnh0Zi9VTmYva0Juejd5dTcvbmVIMURoM3pzQUFBQUFBQUN3MHpLdGhoZ3RTTWJJbVRFTmVLck5IbFdKVEZ3NHVXYkZwa2FGZXBrMlhTMVMwYWpZdkJyWktEYUtOT0J5RjRvcGxwT2lsenRYOS9YenptdStQWDBwM0xXV0FDTUFBQUFBZzRNQUl3REF2cERudWQ1NC9UVXQzbWQ0MFR2THl6Szkrc3BMNWUyUFAvMUpBWHZCbGN0dmw5dDF1TExxWnJoMmRhYk04My80MFE5b2RHeE1BQUFBd0Zib2RydGxlZjMxMTdXeXZLTDUrWGxsYVVadzBRNnJWQ3BGNkRUenFVOTlLbXMybSthQkV3L0VZZWhMZUV3QUFBQUFBQXkxUnZUUW80OHBTZnByQW96ZXZuRE9mNzk3NzJlcXRGZVcvZkl1KytVbTc0eUw0MWdmK3NqSC9QTjlRRHNsODk4eHIvalg5cy8rMGQvWDIrZmYwa3N2ZmxVTDg3UHJuci9iN2VoWC8rZi90ejd3d1ErVndVRWhDT25FeVllMUVXRVo0YnZ6di9QWC81ck9uVDJqUC96eUMrWEZTZGFyMSt1VmdVYWYrMWYvckp6M1QvMG5mMVlQUFBpd1B2WDhEL3IxT1Z4T0U0S0wvdlUvLzQweXZPakZyLzZCNXVkVzMrT3hFdytXRno0QkFBQUFBQUFBQmtGaWpMbnNpbXBpYkRibXRGaVQ2ckZVRTdaVjZGL1VxcHBxTFpZZHF2ZzJ5TXgxTzc0a3VSc3AzTWJQZmJWV2FkV2E1VnBrcWtNVjA2cEZpcVBJUnRZNHF3RU9xbHBKOG01V0tKL3Z1WlovM3pZdDNLaXZtdmU4UUZ6SUx2SWI3S0hZR2k0aUJ3QUFBR0JnRUdBRUFOZ1hzbnkxTTJpNE11YW1MQy9MdExTNG9INi9LMkN2YUxmYjVYYWQ1WnR6NllKdXQxM3VkNkVUTkFBQUFMQlZ3dCtiNFlURXVkazVMU3dzbEdGR3puRmhxWjFtclMwN0dFMU5UYm1ob1NFZFBYcVV6aklBQUFBQWdEV3ExWXBhcldFL1hIdE9VTGpZUnZoOGY2L0NkN2toYU1jVjN3MDNqdUs0RFB4cDNRaloyUW1GZnozaFFqbG4zM2hOcjUxNlZlZmZPck9oQzR2MGZKMjhkZVoxMWV0MUxTN01xMVp2YUtOQ08wcDREYWRlZlZtWEw3NnR1ZXZYTmphL256ZVU2Y3VYeW5McDdmT3ExZXEzdmM1TytUb3ZYamkzSnBpcTFSclowZm9IQUFBQUFBQUFidVZiRDAzUEdKTTZGWmxSV25XRUYrMEU0Ly9IUnBHMVJuR2xYQzk1VWloTmMzZFBWNjh6VGk2MkpxM0dKbXBVL0lLTndxSTF5T0ZGUVZhWVBDMWMzcy9MZm0vaHhWYmVwd3VjZjErbVB0anZDZ0FBQU1CK1E0QVJBR0JmQ0ZlTlBQMmRVeW8yS1VnbGRDNmR2WDVkeTh2cjcxQUtETHFWNWVWeXU5NHNWeTVmMXJXWkdYVTZiUUVBQUFDYjdlTEZpM3I1cFpmOTU3SmxyYXp3Mld4UVBQTG9JK25VMUZUeDNIUFBWV3UxbXFuWDYzVHVBZ0FBQUFDOHE2SFdzRTZjZkZnWHpwMWRNLzdyWC9teXBpOWYxTDBLeS92eUMxOHNRMzV1Q2lGSlR6NzFkUGw4TytYMHFWZjB0Ly82WDlQYkY4NXBZVzYyZkQwaFZPblAvZkwvVGJWNlhaOTg3dmwzcGczdklaVC83My8zSzNyanRWTmFXbHA4SjVEcDdKazM5Ri8vOGkvcC8vRHYvVW45My8rZi83MDI0cS83NVgzbjFXL3BhNzZPKzczZW1zYys4UGdUZXV6eEQrdTU1eit0aHg5OTdKM3hvUjZ2VGwvUjczeit0elF6ZlZtdis5ZHowei84OVY5VkhGZDA1T2h4alUwYzBPV0xGL3pyL1hZNS9xWkdzMW5XLzVoL3IrSDlBZ0FBQUFBQUFJUGt1bkgxci9ueWVHR1NvODUwakZUekpSSzJsVFZHSVdob3JHWmFZelcxY3JlNkNwTGNxU2hjMGN1MTZKekwvTjEzcm1vZUdiK2VqTEdOMkJ3SzY2d1dsM0UrVlQvK2tBWmNDQ2NLTGI2enZYeTVuYmkrZjUramZseGx2Zk9IK21wV3VKNGNCb094NW9GZi9yVS85dFNsb1V1blB2T3pweElCQUFCZzN5TEFDQUN3YjRRT25jWDdSSkFEMkR6K0M0STFWN1lGQUFBQTdsZWFwc3F5ckN6ZGJyY2NPajduN1NoampUTXlxbGFyb1pqaDFyQnBOQnFyMXkwelhPTUxBQUFBQVBEZW9qZ3VnM3ZpK04yN0w0WFAvZGJhc214RXVCaE5tUGQySVdobm84dmFUSG1lSzBuNjVmc2RIaG5WNU5TaE10Q243dXVnVm0rc21UWk1FOGFINlVJSkFVWTNGVVh1MzE5YXRwT2tmbmsyaWhSRmQrOENGcVpMa3FRTUxlcmRGbHhVcWRiS3ovWGh0UnlZblBMUE4xSSs5MDFKYzBoalkyUGw2KzM1OXBpd3p2SWI3VE9ocmtPWm03dXUwRUlUd281dUxqOU1WL2Z2YThRdnQ5VWE5czlUTFFzQUFBQUFBQUF3YUVMYlZ1NEhvU2RTUlR2VDM4WGNlQjFZZGJNK3dqQjBRYkxHV0dkTUpGZTgweGhxclFtWlIyV2o3ODF1U29QZVc4bmQrSkU3NS9MQ3Z4dm5RcERSaGhxdS9Ydk5icnpmbU41WkdBUmxCOExDa3FnRkFBQUFBb3dBQVB0RGFOVHI5WHNDc0gxQ3grbFFDa0tNQUFBQXNFbE9uejZ0cGFVbGZlZlVkOHFPSEk1dU96dXVWcTI1NGVIaDdLTWYvV2owNUVlZmpKck5abHpsWkVRQUFBQUF3RHBNVGs3cGs4ODlyemRlTzNYSFkrRTdwc3NYTDVRaE9JY09IOVZHTEM4dGx2UDJldDEzeG9WQW9LUEhIOURrMUdIdGxLWEZoYkw4MEkvOWhCNS80a245M00vL29rNmNmUGhkcHoxNi9FUlovb09mL2RQbGUvbmJmLzJ2bGVGQVFab2tmdHpiT3YvV1diMTI2bFVkUC9HZ3hpY203L3JjWWJwWFhucFJ2L2ZDRi9YV21kZlhQRFkrTWFFZi9mRS9vUi81OFo4cWgrL2xULzVILzZuKzNaZCtXMy8zYi93UHVuRHViRm02bmRXTG5mL2R2L0hmbHdGUm9lNXYxbnRZdDg5LytrZmZlYjhBQUFBQUFBREFJTXA5Q1MxYU0wWjU2cHNtanpubkd0c2NneFBmS0NHV25kNVFxK3lOVlJDVkVUM0dOaXNhdlRGR3U1cGZ3ZUhzaWs2cTVGb25iK2ZPRFJWT3d4dFpSQ015MTZxeFhHUzBzY1p6WUlzWVp4cVp5VWVHMmxOV09pVUFBQURzWHdRWUFRQUFBQUFBQUJoSVNaSW96M1BOWEoxUm1xVzZObk5OL1g2Zm5qbzd6RnFyRUZKMC9QaHhOUm9OalkrUDI4TkhEcGZqTEJkU0FnQUFBQUNzVS9nY0djSno2djZ6NWUxQ2U4RDgzS3hHUmthMVVhRTlvYjJ5dk9ZaUcxRVVsYzgxMUdwcHB3eTFoblhvOEJFOThaR1A2Y01mL2JocTljYjd6bk5nOHFDeUxDc0RtRzdYNzNWMWRmcXlKcWNPdmU5eTVueGRuajN6ZWhsK2RGUDRETjlvRHVuSTBlUDZ4TE9mMHRGakQ3enZja0pRVXBnMlM1TXl3T2ltcGNWRldWL0h1VysvT1RBNXBTZWZla1lmL2Zneit1QVRIN21uZFFnQUFBQUFBQUJzdDQ1YzJRZzNKWlBWWkFvcnQyMVg4SXFkVlBIRGJIdHprN0FEOHNJVjNjSWwzZHdWaFhNMTUxeWtEUVptMVdMVlk4dkdBZ0FBQUdEd0VHQUVBQUFBQUFBQVlDQjF1OTJ5ZlBXclh5Mkh5UzBuMldIblZLdlZZbWhvU005Ly8vTzIxV3JaeWNsSlVvc0FBQUFBQUJzV0FuMUNHUmtkditPeElzOTE4Y0k1VFV3ZTFFT1BQcWFONkhZNm1yMStiYzI0RUs1ei9NUkRPeHBnRk1LTG5udiswL3FSSC84cFBmM3M5NjVybnFQSEg5RG8yTGlpdUhMSFk0c0w4M3JqdFZQK2ZaMHNRNGp1NXBLdnk2OTgrUVhOejExL1oxd0lNQW9CU1E4Ky9LaCs1dWQrWHV2eHNGOFhZZHFWcFVWOTVmZi8zVHZqcjF4NnUxemU4TWlvVGo0OHB2L3JmL1hmYXNxLzMwT0h1UUE0QUFBQUFBQUFkb2RGbzJvb0R4UmFhVGlYVzJuYkFveHFNbXI2WVUrTzY3cnRjYm5mdHVhN3hVcGV1SHJ1MU5wb2VGSFFpTzE0aFFBakFBQUFBQU9JQUNNQUFBQUFBQUFBQTZFb0NtVlpwb1dGaGJJc0xpNnEyK21xMytzcnozTmhaeGhqeXI0eWs1T1RlYTFhYzQ5LzZQR29XcWxxYkd3c2hCa0pBQUFBQUlEN01lby9YNTQ0K2JDdVRsLzJiUUM5Y2x4b0l3Z0JQYlY2WTkzTGFhOHNsOEZGU3d0emR6d1dSWEVacUxPVG4yTkhSc2YwZ2NlZmVOZkFwdmN5UG5HZ0RIbUtva2ozSWtuNjd3UTZoZnE5TlJ5NjR1dml5YWVlMXNPUGZuRGR5d3Z6aEVDbEIvejZDdk9lUFhQYTEvdUtnaEJnRkI0Ym41Z3M2N3JsWHpjQUFBQUFBQUFHUTJoZEduSlNhcVMrdisxdUZOenBtbEcxSjFlY2RBVEVZUFA0L2MzMVVwY25oWE5wNFpxRk05Rkc5OExZcW11TXlTdVJobUlqTmxBQUFBQUFBNGNBSXdBQUFBQUFBQUFEd1RsWG5rZzNNek9qOCtmT2x5RkczVzVYMkdGbU5jUm9hbW9xSHhrWmNjOC8venp0eWdBQUFBQ0FUUk5DYjBLQVVRZ3N1ajNBYUtqVld2ZHlRb0RSaFhObmZYdkMvQjJQaFFDZ1E0ZVBhaWVGQUtQSEh2OXdPVnl2RUFZVTNHdUFVZXJiV1VJOXpsMmYwY3owbFRXUFZhdTFNb1RvNlBFSDFyMjhNRThvSjI0RUdGMzF5N3daWUdUZUNUQTZzT04xRFFBQUFBQUFnTFZpNTl2aFpOUjFUcG1STXVHOXpQbG1zR1ZmUnlkSmVNSW1LdnkrMTgxY2xtVE9wcm1hOXhJaEZsdlQ5U1d0UktZUkczTnZqY1lBQUFBQXNJVTQwUVFBQUFBQUFBREFqc3F6WE9jdm5GZTMwOVgwMVdtdExLOW9aV1dsRERQQ3pxblg2MFdyMWNwUFBIZ2ltcHljdEljT0hZcWJ6U2Jkc3dBQUFBQUFteW9FK2h3N2NWS3ZuWHJsblhGNW51dmloYmRVcmRYV3ZaeHVyNmZaNnpPK2ZhR3padnpEano2bTQzNzUrOUhzOVd0NjZSdGYxZlNWeTNjOEZzZXhQdkQ0RTJYbzBFYXRyck9IVksxVzN4bFgzRmhuQnc0ZUtwKzMwV3lxMlJ3U0FBQUFBQUFBZGw3bzdCRkNpM3hyVFRwZXFEOXRYRzNabUlwd2g0NXhpbnlGelRtdEdDTXpMa01qRis2Yjg5dlVjcEs3d3BrTjk3Mnljb2t4SmgycDJXYlYzN0ZoRkFBQUFBQU1JQUtNQUFBQUFBQUFBT3lvTE04MGUzMjJEQzA2OTlhNXN0ZVVFems1T3kyT1l6YzBORlNjUEhuU25qaHhRcTFXeTRhVEd3RUFBQUFBMkV5TlJsTVRFd2ZXaE9Ia3ZxMWdmbTVPUzR1TDYxNU9ubVZxbDRISS9UWGpKeWFuZkRtby9halRhZXZTaGZPK0hoZnVlQ3p5bi9FUEhUNnFvVlpMRzdXNnppWlVXYlBPOG5LZExjN1Ardld3WEFZa2lRQWpBQUFBQUFDQWdSRjY0bFNkeVgxTFdXL2VLRjZXQ0RCNkYya29SbHF4NnNVeWR0eUpSaTdjdDdEL2RUUEozRXVmT0dOeWEweS9hczFJbzJKaVl3UUFBQUFBQTRtelRRQUFBQUFBQUFCc3UrbnBhU1ZKb2xlKzlZcTYzYTdhN2ZicUE0UVg3YWpoNGVIOHdJRUQ1cGxubnJIREk4UFczNjVXS2hXRll1ajlBZ0FBQUFEWUFzTWpvenA2L0FGVnFyVjN4cVcremVDMVU2K28wV3l1ZXpuZFRsdVhMMTdROHRMYTBLT0hILzJBanA4NHFmM29acDBzTGQwWkJGWDE5ZjNCSno2aWUzSGc0RlE1YjZQUnVPT3hoWVY1ZmUwclg5WVRIL21ZUnNmR0JRQUFBQUFBZ0owWGV1TGtLazhrckkwVnFrN0pwSkYxM1RubmFxa3hWcmpENjZhWXFNbmtFeTZhaStTcUZXbmpTZUNBdDVLNmZwSTdPZWZxWVY5Y2J4OHNhNVJFeG5SR3FxWTJVck5qVWFSeVo2VUhGd0FBQUlCQlJZQVJBQUFBQUFBQWdHMVhGSVd5TE5QS3lvcDZ2WjdTTkJWMlh1Z2dFMFdSYXcyM05EUTBaRm90K2w0QkFBQUFBTGFXdFZaeFhDbUh0d29oUmlIOGVMMXV0aldFNGExQ1VFLzFsbkNrL2VSbW5iamI2dVNtZTYwWDMzWlF6aHRGNzk3MXJPL2Jlc0x6QWdBQUFBQUFZSERjdUp5WWlZMHhzWnl4empoanVNcllld25CVHI3RjByblF1dVovaWd0LzRSNFZJYnRJWmIrc0RXNUVKc3hXV0dzVVIrWDJ5R1lJQUFBQVlLQVJZQVFBQUFBQUFBQmd5NFdBb242L3J6ZmZmRk5uM3p5cnhjVkZUbVFiQU1ZYVdXUDFxVTk5S204MEd1NzdudjgrMm93QkFBQUFBTnRxNnZBUlBmblUwMnExaHQ4WkY5b01McHc3cTZQSFQ2eDdPZk56MS9YS1N5OXFadnJLbXZGSGp6K3dvZVhzSmUyVjViSWVGeGZtMTR3Zkhoa3R5NzA2ZFBob1dZWnVXV2MzNVg3ZGhlZnI5Ym9DQUFBQUFBREFZTWlOMUpGVEtsTW1HVDNnVEhiTTMvMktkZFZrZ0FOUjhodnhTdjNzdXpsTDRlV0dFSmVLbFNLN2RTOCtYSW90OTAveFZWdE1UamxsSDNTbVkrUXFScVlpWUFPVys4VjhXcVpnNmVoNnByZkc1UFZZODgyS3FZL1hvd2xUamhNQUFBQUFERHhPUmdFQTdKaTBLTFRReTlWSkMzV3pYQ3RKVVk3YkN0ZXZMMmx1NUxnMjI2Vm9Rbjk0YVVuQVh2Qkd2NzRsKzhuTGM3bm1ObkUvR2E1R2luMEwvRlN6V3Q2ZmFQQW5MUUFBd0tCYldGaFFraVJhV1Y3Ujh0SnlHV2JrSEJkdzIwbHhITHRLcGVKYXJaWVphZzJaaVFNVHFzUVZ1cm9BQUFBQUFMWmR0VnJWVUt1bGloOUdjYXdpejk5cE43Z1podU0veDc1cldNNnRjai9meXNxeWI0UG9yeG5mYURUTDVlTzdxQk1BQUFBQUFJRDlKNzlSQWlQWmtQOVRsNHFtVTlZeE8zdU9ZV2dPZFA1ZjRYd3puM081SzR3dDVHd2VYcXFUU2ZQdlRuc3p3Q2kxY3BGeHZwaGNmaGhiVTdIK0ViUEp2Vi9DNWRrU1g5cStoTjdyTlFFYlV4UXV6Z3QzOXkzVCtOM1Q3d1JWVzE2THJxakhwbEsxSmhJQUFBQUE3Q0tjN1EwQTJERVhseE45L2NxS3pzeDNmZW5wYS83MmZDL1Rsbm44VDJtemZiVXIvZXEvT0MxZ1R6QWY4ZnZKUjdUWnZ2ck5udlROemR0UG5qbmNLa09MZnZieFNUVmlxeDg0Y2U5WGh3VUFBTURXNi9WNmV1VmJyMmh4Y1ZIVDA5UENZQmdaR2NrbkRremt6ejc3Ykh6aXhJbW9WcXRGbTk2REN3QUFBQUNBZFJpZm1MeFJEcWpWR3RiUzB1THFHVXZleXNxU1hubnBSVTBkUHFySEhuL2lyc3RaOG0wUGI1MTUzYmRGZE5lTVAvSFFvenArNGtIaHUwNDg5QWgxQWdBQUFBQUFzSStFeTB5SDJPK2JaMnRZcVI2R1I1MVpHWmZ5VThidGNJZHNwOXczQ2JaVDExMUpYTHVYNVkyc1VNV1BydXM5dXJPRURDTS9TOTZJVFR1eUpwOGFNcE4rWkxTWmlTK2gzdHBtTlRSSnhwbkQvZ2tQY2MwMmJGQlNhTGdNNGJwTDF5eS9UM2FOVVg1d3lGYU1qR2xWTFNkSkFBQUFBTmgxQ0RBQ0FHeUxOQTk1K05JYjgxMGxlYUZ6aTRtdXRoTzk2ZS9QZEZKL08xVlcwSklMNFAyRlkwYlhmeVAxKzVlV1ZJdXNWcEpjcldxa0k2MnFSdXVSeG1vVlZhd1I1MTREQUFEc25LV2xKZVY1cnRuWldXVlpWb1lYZFRvZFllZUVjS0pxcmVxYXphWU9UQnd3RXhNVFp1TEFoQjBlSGpaUnhNVzZBQUFBQUFBN2IyUjByQXd4YXJkWC9IZkhSVGt1VFZMTnpjMXFxTlY2ei9tY2MwclRSRWtTU2w5Rm50KzIzRkdOam5LdUJ3QUFBQUFBQU9EYjBuekxtODJNaXRqSTJDRm5iS3pDM2V4MnZkMW5kSVRuSzBMN1hpSFhUbHplejRzb3pWWDNMelEyVHBHN1M0ZHdQNjgxWVY2bmVwRXJiNmRLWTF2a3JkaFdaZTZhRmJOaHFhK3NGZjk2T3Y1cCsxS3ZLbGVqdHpyV3owVXlZV3YvN2lZVHdvcXNNVDIvb2RldFVWU05iY1hLK1IvR1R5dTJMUUFBQUFDN0VnRkdBSUJ0RVVLTFFpTCtiNStkMTNLUzY1OTg1N3FTd3FtZkZRS0FqYml3MUMrSDM3N2VVZVJiN28rMEt2ckFlRU0vY0dKVUg1NXMraElwTk4vSGZDY0VBQUN3WTBKd1VidmQxamRlL01hTmt3aFRZV2NaWTl6SXlFaHg0TUFCUGZmY2M5SFkyRmhaQkFBQUFBREFnSmc4T0tYakowN3F5dVdMeW02MEpZUkFva3NYenFuMVBnRkczVTdIbDNZNXZOM1JZdy9veUxFVEFnQUFBQUFBQVBhN3dwZ3NkNjRieVRTTVZCMEpJVUd5SmxaUmhnbGwybVl1WEN4YjZtV0Z1OVlwUXFOZ09OZXhvZlVsRU1VaDRDakxWYzM4Z3VZNitVSzRDRzV6Uk5XdzNHZ1R1NUwzL2VMNnhrVjFtYzZ3WEdmVTExdEZxZ2hZRjNQSHRoTENpNnBXYzBNVk8xR0x6VkFqTnJYWWN2NERBQUFBZ04yTkFDTUF3SlpJODBLK0RWbHZ6SGQxWlNYUlY2KzB0ZFRQOUsyWnR2cCtmTmUzRXJ2dGp1Y0hzT2U0OEdWVE45TzM4NDdtZXBuKzZOS3lqclNxK3Y0VHd4cXRWZlR4UTAxVnJCVUFBQUMyVnA3blpValJ4YmN2YW01dXJpejlmbDladHUzZG1uQUw2LzhXTnNibzhRODluamViVGZmSUk0OUVjUnhyY25KUzFXcFZBQUFBQUFBTWtnZE9QbHkySlh6ejYzK2t2bnJsdU5EbTBPbDBsQ2JKZTg0WHBybDQ0UzNOejExZk0vNkVYMTY5WHBmL01LejlhcWcxckdNblRtcCtmbTdOK0xmT25QWjEydGU5U3RPa2JBc3FpbHdBQUFBQUFBRFlQUXJubStDY090YVU0VHRWSTFjeHhoU0hDblZ5NDh3Vll4cmFSb1djbSt2bDNkd3BkUGl1T09jaWM0OFhzYzJkYTRZRmRqTFhqbzJpUm16cTJtU0xjdFd6eHRnUEZTb2lvOFN1aGhqZGQrcU1yL1J1NWx3eGI5VGNqT1ZoWjlXZFZQT3JjVnhhcWhpbDg3R3EvY0pZRTVtaGNHcERDQ3J5bTNtdFlqVlJzU1pNS3JLTEFBQUFBT3dGQkJnQkFMWkVFWkx3QytuOFlsS0dHTDF3ZmtGWDJxbVdFem93QXRnODRWalR5WXF5ekhSU3ZWWHRhYVFXYWF3ZTZZR1JtajQ4R1FLTUJBQUFnQzFXRkVWNWd1SE16SXd1WHJ5b2RydGRuanlJblJVNmRJVnkrUEJoTno0KzdoNS8vSEc2dWdBQUFBQUFCdGJZMklRT0hUNnErSmJBSWVkY0diUnp0NURrUE04MFB6ZW45c3J5bXZHalkrTmxpZVA5ZXlIMGFyV21pWWtEYWpUV25uYzJlLzJhR3MwaDNhc3l6RHBKNUh5YkVBQUFBQUFBQUhZUFoxUVVScjVoUjBVSVRUSEdoSjdXZGtTbW5ZUVFvVzN1V2VLYi81eC80dFJKa2I5YnY5ZndvcUJ3WlNCVGtXU3U0NnlKRzdFMlBjQ29ZeFQzNWVLZXNmMm1VKzdyczdJWlZWYVJ5MnBTWnB4cjZINHFBUU1odEhDSEZ0a0RoWHBOWS9wRGtYRlJwTWpFeHQrVWFuRzVxNFVjSTg3dEJRQUFBTENuOENFSEFMQ3BacnVwdm5KcFdhOWM2K2pWYTIxZGFTZnFwSVVmbnluSjZid0lZR3UxMDF4OWY2ejV6R3ZYVll1c1hweGUwVmd0MXAvOTJKUXEvbjY0RFFBQWdNMnp2THlzMDZkUHE5dnBhbjUrWGt0TFMwclR0QXcwd3M0Wm54Z3ZKaVltM0JOUFBHRkhoa2ZNNFNPSGJSekhkRzRDQUFBQUFBeTA4WWtKWlZtNkpzQ28xKzNvN0puVE9uVDR5SHZPVitTNW4rWjFYWjJlWGpQK3lMSGpPblRrbUtyVnF2YXJ5TmZsVUd1NERESzZYUWlIV2xsWlZoUkZhalNhMm9qNXVWbE5YNzZvcmw4L3Q2djdaVDMwNkdOK2ZSNFFBQUFBQUFBQUJrc21tU1c1eUJwamJvMjhQdXBNM0hPeVo2elRka2x6cDhRNTR3ZERNcHNUbmVSa1hEc3RlclhZVkVmS1RLVE5WWlRQSVYyM0xrdWM4aW1uV2tYM0h6Z1VPOU9yR3RmMzFURHM3M0w1M2wwa2JHVitoYmtqaGRvaE1XdlUzNjdKVkdPL2JkU01HZlBENGtEVlJsMi9jbnRsYU5pTkZVeFBybDBuSzV3dlVqOTN5MmxlZEpQQ1JDNGN3d3BOdUpBUFo1VDRkWnRHa1ZtcGhIQXpZK0pXUlVQK2dCdUh0Q29BQUFCZ1ArQU1iZ0RBcGtwODYvR1ZkcW8zNXJ2Nnh0VzJ1cjUxSmpUU0FNQjI4SWNnNWY3SHhlV2t2RDlTaTNSa3FCb2FpYlg2bFJFQUFBQTJVd2dyQ3NGRkt5c3JtcjArS3d5R2NHTG04UEN3TzNMa2lDWW1KbFNyMVN3WFp3TUFBQUFBRExwS3RhWjZ2YkZtWEo3bmF2dDJoeVJKM25PKzFXbVdsU2I5TmVORGtFNnJOYXo5ekZwYkJrS0Y0ZTFDZ0ZHZVpib1hxVjhmWWIzazczSVJveWl5WmIyL1cyZ1NBQUFBQUFBQWRsYmhaTEtiWVVHM25PWlJjN0o1MmJsays4NzlLTU9BaXZLMXhKdjF0TTYzZW1XRktTcUYyN0tPNCtHbDluM2pXbGRtMHlyTHQ5NFZWaWJmenZySDVnZ3RyN0hmSGxwK0Z4cnlLM0RTR1dlTml5T1Z1MU9acmwrSmpQeCtwM3RyamNXZzhFM3E0UmlxTkZmU3k5VHY1NjdpNzVwd3psdzQ5dmhEYXhFQ2pPSkMvZHpLeFVZdWovMzJJQUFBQUdEL0lNQUlBSERmcGxjU3pYUlMvWlhmZjF0TC9VeW5acnNDZ0VId3phdHR2V1RhK3IyTFN6bzVXdE12ZlBTUW5waHM2c09URzd1S0xBQUFBTzcwYTcvMmErV0pia1ZPVU9ST3ExUXFHaDhmZHljZVBLRm5ubm5HdEZvdEc0b0FBQUFBQU5oRkhubjBNUjA3Zm1KTjhNM2l3cnkrL01JWGRmam84ZmVjTDhzeVhUaDNWclBYcjYwWmYrandFWjA0K1hBWjRMTmZIVHA4Vk05LytrZkwrcmxkdjljdDYzWmk4cUErOWZ5bnRSRlhweS9ybFpkZUxJT2piamM2TmxFK0p3QUFBQUFBQUFaUFpoU3RPTmNjY1NhK05VbzhNbXJVSmZlZ005MFZmM2ZXdUtxMldEOVhMMTN0ZGxUWEpuRk9jWks3WS9FV1granJrbFhMeXVsd2JudVJ5aENiVFhzUDJCME9GYVpmTnlxZUxQekc1bVNzMGVnN0Q3clY3UytUV3c2WllSMjUwWjZmUk5pVitybExyM2Z5WlQ5c0pMbkNvZlBBamZJT3M3cCtHLzZRNXFkeDQzNDZoUVNyaFVUaHlndmRrNk54STJ3VnRaaUxFQUlBQUdCdjQ0TVBBT0NlZGJPaUxOUHRSRmQ5NmZ2Yk9ZSHZBQVpRNGIrTjZ2cHZ1T1o2bWVaOVdlaG42bVdjYUE4QUFIQS9yTFV5aGkvVWQxcXoyWFN0Vmt2RHc4TnFOQnFLb29qMUFnQUFBQURZbGFLNFVvWU5oVE05akYzYnBha29paktvS0F6ZlRaYWwvckY4emJoS3RlYkxscDluTmRCQ08wR29nN2hTZWRjZ3AwNm5yU3hOdFZGcGtyeHJlRkdqMlN5ZkN3QUFBQUFBQUlQSithYTMzTGUraGVHN1BlNWJkZ3JqdEMxbmhmaW55WjFUcmwwcVZKSi84WG5tdEs4N3BZY05LZG9INXhHWkd5V1djelhuQ3QveWJHcmxLR1BlcTdPV2t5bHk0emhwWVJmTEMrZS9saWgzY3VzSEcrNlV0N3FCeUdSK09hRUlBQUFBMk9QMjd5WEdBQUQzN1pXWmRoa0U4bGQrLzIxZDc2WnFwN1NsQUJnOC9vdXQ4dmgwWnFHbnYrcVBWeDgvTktSUEhHN3Bwejl3UUUvNTJ3QUFBTGczSThNalN0TlVTMHRMd3M3NWlaLzhpU0lFR0owOGVUSVNBQUFBQUFDNzJJSEpnK1Z3ZEd4Q3k3NjlZWGxwOFozSHVwMFZYYjU0b1p4bXFEVzhacjRRWG5UNTR0dGFtSnRkTS82QkV5ZjErQk5QN3VzUW81SFJzYkk4OU1nSGRQVDRDVjJkdnF4K3IxYytGc0tMZnZjTG45TUhIdit3dnYrSC90aEdGcXZYVHIyaWYvbFAvMUc1dkp0Q2VORVAvOWhQbHNzREFBQUFBQURBWU1xY3F5NFpVMDFDQit2YnNqaGlxWGlvTU4yTGN2WHJVazFiTE0yMWtHWmw4czJ1NjlCOU0zVnBYbTRwdFhLVHpqUzFUdzM1VmRqeTI5S2MzNmFTUFh6TnRSQzVIM2FLaDV4ZDhldTczM0p1TkhLbXJydmtmYTNJOWZ0U3Z6Qm05TVlpc0l2a1R2bTFkakdmRnE3U3p0eVk3b0hmT3NvdktLNjJpK3NWS3p0VXRSTUNBQUFBOWpBQ2pBQUFHemJkVGpTOWt1b1BMeTlydHB0cXNaOHJJN3NJd0M0eDE4MzB4bHhYTDgyMGxlU0ZucHdhVWlQbSt3QUFBSUNOT25yMGFCbGVSSURSenBxWW1GQ2xVdG5XN2ovdGxXVVZSYUZ1cDMzSFl4T1RVNHBqbXAyeFBjSzJHTXF0akxWcU5vY1UrZTJ3WG04SUFBQUF3TzRUUW9yQ1o4NWJBNHlTSk5IODNLeUdSMFkwcE5zRGpETE5URi9Xd3NMOG12RWpvNk1hOTUrYm80alBxWk1IcC9UQko1N1UvUHpjT3dGR1dacnE0b1czL0dlbnVzNmVlZDNYMVlHeTNFMVlKNWN1WHRDVlN4ZmZhUis0cVZxdDZlRkhIOU9odzBjRUFBQUFBQUNBd1JTQ2R6STUvKzlkdTVwWTYxeTlhaFZYbkZTWTd3YjE0TjMxamF2RzJzT3BQWGNScnJSV2RXV29UMW9ObTVWVWwvWmVaZmozNmVwT2VYaHpJLzc5RHN2RmxVSW1lTDk1MjBhTnJsRlVPQmZKN00vdFpMZnk2MHg1NFd3L0wrcitXSGpmSjV2ay90aHEzZDdkQ0p5S0JWOXIwK2ZPbDhjQ0FBQUE3R1AwMEFFQWJOaHJzMTI5Y0dGUm56MHpwK2wyS2dEWVRjNHY5Y3ZTelp5K05WUFRveE1OQW93QUFBRHV3WWMvOG1ITnpNem8vUG56d3M0NWV2Um9wRzAyZS8xYWVYTG81WXNYN25qc0E0OGJUbFRFdGduYjRvVnpaOWVNQ3dGYVI0K2ZVSzFlVi8wd0FVWUFBQURBYmhSQ2NDclZxczZkUGZQT3VQYktpaTVlT0ZlR0c0MVBUSzZaUHZlZlVWOS83ZFFkeXpsdzhKQ09uM2hJa0I1NjVESDk4SS85aE02OC9oMHRMeTZVNDlJMDFjdmYrSG9aVHYyVkw3K2dKNTk2K24wRGpFSjQwZTkrNFhNNjljcEw1V2V5VzRWMTl0enpuOWJvMkxnQUFBQUFBQUF3bUVJb1VhSVFwbkhuWS80aFV6T21WWk5UMDkvditXbHlNbGZ1YXNXWW9jSnBYd3JoUmFOK3EyazQ5ZjMyMHI1dUZmbHRxNm85Sm5iT1RjcW00ODY0NHk3c0o2NXFqRmxYaHhUZkVqc2NMZzFZRUY2MDY0VDlPbk15M1Z3dGJRSy92TmFlUGxZVXV2by8vOWtYWGhNQUFBRDJQUUtNQUFEcmRta2wwYXN6YlgzdHlvcStNYjJpbGJRUUFPeFdsNWI3YXFlNWZ1ZXRCWTNVSXYzeGgrbE1EUUFBc0JIVmFsWE5abE9IRGgxU3I5ZlQ0dUtpc0QrOC90cTMxZTIwOWFVdmZPNk94Mzd1ei96bkJCaGgyM3puMVpmMStYLzl6OWVNYXpTSHlwTnl3MG0zaHc0ZkZRQUFBSURkWi9MZ2xIcmR6cHB4U2RMWDRzSzhIeVpyeGwrZHZxenIxNjZ1R1JjQ2RFS3AxK3ZDcWluL1dUMEVGQjAvY1ZMdGxXWE5YcHRSbnVmbFk2RmV2L3pDRjh2eHZWNjNuQ1o4cHFyVjZ1RXk0dVhqSGQ4T0VBS2tUcjN5Y2pudDdXR3lIM3ppSXpweTlMaE9uSHk0REpRRkFBQUFBQURmWlNTM09nQjJYamdESkwweGZDKytWU2diZFVwa1hLVXZWYlJGWXVzYWhkM2RpUjYrTHVQTnVDUjRaSXlONWVMZGxITlROU2FaS05UMWh6ZmZhT3N5ZjZSemUrMUlkOVNwVzNYR0hQTHJ1ZTV1dkQwbiszN3Zjelg3UmxsUHJ1cGJ1bmY1VnI0LzlYUDFzdFVESlEzZUFBQUF3QVlRWUFRQVdMZkxTNGwrKzYwRmZmdDZSNmV1ZHdRQXU5bmxsYVFzWHp5L3FLR0tKY0FJQUFCZ2cwS0EwZERRa0E0ZlBxeTV1VGtDalBhUk4xNDdWWjY4K0p2LytIKzc0N0h2L1lFZjBTYy85ZjBDdHNPcFY3OTF4M1lZVGxKKzRNUkpIVDMrZ0o1Kzluc0ZBQUFBWVBjNWNQQ1F1dDN1bW5GcGt0d0lNT3F2R1Q4emZVWFhyMTFiTXk1OExsZ04wbG5YUmJEM2hSRHdHa3I0dkxRd042dDVYMjRQTUFyaFJWbVdLWTRyYWphSGZOdFA3WjBBbzluck0vcjZWMzVmcjd6MFlqbnQ3UjUvNHNreStDalVPd0FBQUFBQStLNGI0VVhBd0FnYlpLcTdiNWdWcDJ6Q3FOT1hhUzdLYlZtQWtUVzJHVVhobGVUYXJiSVFZQlRDYk81elQ0L2tJbC9Sc2R0RllXYzFwL1NBekZMUE9kY3paUTNzdWVQZE1XZTZOYjllSnB3WmVXZmtPdFpRQ0MveVczVy9heFIzakt5dzZ5UzUraWtCUmdBQUFNQ0dFV0FFQUhoZjNhelEzL3ZXVloyZTdlckxGNWZVVG5kdkF6RUEzTzVyVjViTDRkLzh4aFVkYTFYMTA0OGRFQUFBQU5hbjJXanE4UTg5cmd2bkwraktsU3ZsaVcvTzBmY09BQUFBQUFEY3V4Q0VFMFhSbW5IdGxXV2RQWE5hVDMvUDJxRFNtZW5MdWo0enZXYmMyTVFCUGZUb1kycjRkZ3VzOVpQL3djL3F1ZWMvcmYvUC8rdS8wY3pWSytxMDJ5cDhlODZLcjk5dmZQVVB5OURpei8ycmYxWUdWNGNnbzZEZjZ5cE5VeTB0THBSaFJyYzZjdXdCMVJzTi9mVFAvbW1kT1BtUUFBQUFBQURBSFl3MWNyc21rUVQ3UmlLejFKZnBWT1FtckZTOTlURi94MHc0MlFXenRadHViRlJ4Wm5mdkhtMDVyV2FjM04vYnFCVW1pNjJTeURtWDdvSWFxZm5TZEtxTk9CMzBhM0NsRjZwaUR3aFZIOUtHSGkyMFVwUEpKNTBaTnZld2NoZU03S3hjM0RlN0o1QUthL1h5dkova0puU0VIQlVBQUFDQWRTUEFDQUR3dnJwcG9UZm5lM3A3dWE5cm5WUUFzSmZjUEs2RjR4d0FBQUEySm9vakRROFBxMTZ2eTFxcm9pZ0lNTnJuUmticHN3RUFBQUFBdUQrdFZxc014YmxWa3ZUVlhsa3B3M1p1MWV2MS9HTnJ2OE1PNFR1dDF2QWRJVWlRamg0N3J0SFJNY1Z4N090bnRkdFlhTXZKczB6emM3Tmx1WER1N0xxWEY5WlRxT3NUSngvV29jTkhCQUFBQUFBQTFqSnJCc0RnS09TU1RPcFhkQ04vNXhhaFZhMG1ZeUp0YlI4Z2F4VHQ5bnlYM0wvOFloT3F5ZGU1SzdPUWRrRjFoSmNZdHBIWUtJNmNMNzZaVm51RXZWSEdaWk9hWDdWKy82am9IcVJ5cG1Oa3VYVDg3bFVVSm5kMGhBUUFBQUEyakFBakFNQmQvWlhmZjF1ZE5OZG4zNXhUbXRQMkFtRHZDc2U1azZOMVRkWmpuUml0NlZQSFJnUUFBSUQxT1RoMVVOLy9BOSt2YjcvNmJVMVBUd3Y3MTlMaW9nQUFBQUFBdUI4bkgvMmdLdFUxRjMzWDR1S0NYanYxU2ptODFlV0xGN1M0TUw5bTNQRElxSTRlZitDT1pVQjY4S0ZIbE9lNVB2SHM5K3JpaFhQNmczLzNKZDJMSnovK3RENzI4VS9xSjM3NlozVG84RkdkZlBqUk10d2FBQUFBQUFBQXUwTm1aREluODI1bmlGaTVxbitnTXVxTU9lanZ6L3M3bWZCdVFrRE5mcXVieUxuaWtMUExJNjRNOTJsR2ZqdXFTMlkzTncvZURHVjZ4Sm4yWktGMHpMbHdJb0dWMlZpaWxITktjMnU2YzNLMWk2YW83NHBFS3J5ckpIZU5OTi9VRkxlZVZoUGJhZ0lBQUFEMk1BS01BQUR2YXFtLzJveDZjVGxSMjdlNmROSkNBTENYaGVQY1hEZlYyLzY0TjFLTGxSYUYveUxDeUZxK09BQUFBSGcvMVdwVnJWWkw5WHBkVVJTVko4SUJBQUFBQUFEY2k5QytVS3MzRk1leGN2OTlqZk1sUzFOMU8yMmxmbmlyTUM2VVcxVXFGVFdhUS80N25raFlxOU5lcmF1aXlNdFM4M1ZkOTNVZDZqdlBNbVZaK3E3em1YQ2lqaS9WU2xXeHI5OWpEenlvNHlkTzZzRGtRVTBkUGxLR0Z4RmdCQUFBQUFBQXNIdUVWSTdWYkk1MzZ5ZHRRbk9RaVZ6aHFzWmsxaW5lcWh3V3MwWExEZS9NM1hoN1c5a1RmTDllSXJ6aE41K0s4ZHVGQ3lrL3ErRS91N1hIZlhqZEZiKzExSnhjb3pCcWxpa3p6bHBqTnR6Z0djN0NTbnlscENic1g0YVRFSFl4dnpsRW03cC9oeHc0UjRBUkFBQUE5ajRDakFBQTcrcnpaK2ZMOEtMUHZUa25BTmd2cHR1cC9zZXZYOVlmT3ptbUU2TTFIUnV1YXF6R244d0FBQUR2cDE2ZTdGYlh3WU1IMWUvM05UczdxeVJKQkFBQUFBQUFzRkd0MXJCR3g4WjE5UGdKOVhwZHpVeGZVYmZUZWFmYzZyVlRyNnB6VzREUjVNRkRldnlKSnpYVWFnbHJmZWtMbjlQbGl4ZjBiei8zcjhxNi9lUnp6K3ZFeVlmMWN6Ly9pN3B3N214WjNrMFV4K1Y2T1g3aVFYM3NFOCsrRTN3RUFBQUFBQUNBM2Fucm5GczB4ZzI1MWZDWmR6Tms3UEtVYzhzTFJwUEpGb1J1VktLdFRSY0tsL0EyVHNUSWJMTFliemZIQ2xOWXZ3MkY5VmZ4dFR3a09Sc1NvM1paWFllWEc4NFVlTUNaM2tPRjdkYWNodnhtT1hTdkc4MjhkWlV6UnBYT3ZvMjIyanVjTThOdUU5ZGpOVGF6c1MwM3R5RUJBQUFBZXhobll3TUExdWhuaFhwNW9lbVZWRzh2OVFVQSsxSEhId3RQejNiS0w4WmFsVWhSdUl3SVgxNEJBQUM4cjBham9Za0RFMXBhV2xLU0p2djNNbU1BQUFBQUFPQytoUkNqZUNYV2pLNjhNNjdmNjJweFlWNURyV0hGY1Z5RzhJUnh0NnBVcTJWNFVSUkZ3cW9zeThveWMvV3lMbDI4VUFaUUJ5RWthdXJ3MGJLK0ppWVArbW5TZDUwL2ltTFZmYnZQK0lHRFpaaVJ0UnUrK0RnQUFBQUFBQUFHU0dZVTk1M3F1ZlNlRFQyUmM2WWlGMW16TmJFMGRNMytMdVBYaDNHcWhoeWdRYTRaKzkxU3NkWkV1N2x2MkdwNGtYT2poY2xEVkh0VW5tZnJvbnV0LzU1YzZ2Y3BreG9YNXdJQUFBQ0EvWWtBSXdEQUdtOHY5M1d0ayttelorZDE2bnBIQUxBZmZYTjZSZWNYZS9wTHp4N1g0V1pWellvTlY0c1FBQUFBN3U2eER6NVdEaGNXRnRUcjk1Um5kTWZZYjBaR1J3VUFBQUFBd1AycTF4dDY4cW1uZFhYNmlzNmVlZjJkOFJmT3ZhbFhYbnF4ZkN3RUhNMzR4NU1rV1RQditNU2tIbjcwZzhKM3RWZVd5K0NuRi83dDU4djY2L3QybXdPVEIvWHYvNGYvY1ZtUG9iNm9Nd0FBQUFBQWdQMmpKNDJGcnRHWkN3azA3OTVIdW00VVY1MnR4YTZ3VzVHcFkwMFpHZ092NHRTS3BVSURmc25kZWloT1VVMGEzZTBYdGdzbjFZNDZrejNsN0hMRnVVYkZhT1JlcXovMy8yZU1GcS9MMVJlTldnSUFBQUNBZllvQUl3QkFLZmNOejFudTlPS1ZGWDF6cHEzWlRpb0EySy9Td21tcG4rdTEyWTZHcTFhZlBES3NpUVovT2dNQUFLelg1T1NrckxWNis4TGJBZ0FBQUFBQTJLalFyaENDZFZaV2x0ZU1YMXBjMU5YcHkvcGc4cEh5ZnJpZDU2c0J5a090bGc1TVR2bjV4b1MxTHB3N1d3WVhYWnVaVnEvWDlXMDNCM1hveUZHZE9QbXdhdlc2QUFBQUFBQUFzTCtFN0puaWZhYXhoYW5JT2xYOXpacWZJVEhhVlprMUlZcG10MXkvTm1RNStkZHFCLzMxamtqZDZtclY3dHBHUmFzeU9NdWRjT28xWEFpUGNnMWYrZmQ4b2tEcVhEZEU3RisxYW5aa290MjFsd0FBQUFEQTV1SXNiQUJBS2ZldHovM2M2ZXZUSy9yc20vUHFwTGtBWUw4S0FVWnBrdXZVYktlOHNzZ0hEelFKTUFJQUFOaUFFR0RVYURRSU1OcUh3b21rQUFBQUFBRGNyNXNCUm9zTDgydkdMeTB1YUdiNmlwSWtLZStIMnplMVdpTmxJRStZRDJ1RkFLTXZ2L0JGWFp1NXFuNnZwNG1ISDlXaEk4ZksrZ0lBQUFBQUFNRCtjelBBNkc1Uks4WW9qcHlKYThhVmFUV0pkbytRc0dOM1NYaFJFT3E2SElZVk1zQ3ZlN2hRcnlJVE1vQjJkWUJSelRuM1VCRjFJeW11bUpETGRPOVNZN285NCt4MTQ4YmVMeFFNQUFBQUFQWTZ6c0lHQUpTbTI0bGV2dHJXaGFWRTNTeFhzUTJoMzdiSUZPV3BXcjA1TmJ1K0pFdCtYS3BLMWh2a05sY0FBeUtKNjNMKys0OTJiVnk5Mm9pV21sTXFiS3c4cW1penZESGYwNVdWUkQvMjBLaEdxbFpqOVhqd0wyMEJBQUF3QUE0ZVBLaXhzVEUxNmcwNTU5VHI5d1FBQUFBQUFMQmVVUlRwMkltVGFyZFgxb3dQd1VXZFRrZm56NTVSZTJYdFk4MVdxNXhuWkhSTVdCVUNvSzVPWDlHcFYxN1NTOS80cXJxZGRqbitpU2VmMGdPK3JnQUFBQUFBQUxBLzlZeVVPcWRpSFdkdXRHUzZoWFBGc2xIVGJXSzhUcmpnYkxZZEo2NWcweHgwSnJlNzlHeWZFRndVWHZramhXazMvR1pYZFJyeUkrNzV6VGk1MU1tNE40d2JTdjF5TWdIdkxTOWN3NW95L0FzQUFBRFkwd2d3QWdDVWxwTmNiOHgzdGRETGZDT3d0b1h4RGQ1eGthclpXOURFeWlVTmQyWlV5ZnVxSmN1eWpvWm9BSGZYclkyb01KRVdXa2UxVkNUcTFNZVZibktiN3ZUSzZyVkNybmN5ZFVZS2piamRkVFVPQUFDQW5kSnF0Y3BocFZwUlVmZ1BtWDBCQUFBQUFBQ3NtNDBpVFV3Y3VDT01LTXRTcFVsZjgzT3pxMjBPdDZoV3ErVThqVVpUV05YdmRUVXpmVm1YTDcydFN4Zk92elArOEpGak91UUxBQUFBQUFBQTlxYzBGQ1BsNjVpMktwYzFmTk9jZGE1Um1NMjdFbXpJTHNvNWJXUlhDWWsvTm1UMzdFSmh3dzFuR2t3NnBlRjl4TWEvbmZ2Z25BbWJjSEV0Y2lFUGFYZFdDcmFOYzZyNHJ6UUlNQUlBQU1DZVI0QVJBS0IwclpQb2hRdUx1cnl5OVdlVjJpTFRBOWRlVVQxWjB2alNKY1Y1WDVXODU0ZStHZHdWaEJjQldKY1Fkclk2WE5IQmhiTjY2TXFMV214TmFYbm9rSzVNUEs1K1pVaTVyY2h0d3Zkay8rcU5PWDNqYWx2LzVUTkhOVkhuVDJnQUFJRDErdlFQZlZydGRsdS84OFhmRVFBQUFBQUF3SHJWNncwOTg5enp5cksxMTYyK2N1bGlPUndibjFCN1pYbk5ZNDNta0k0ZWYwRERJNlBDcXVrcmwvV2xMM3hPYjczNXhwcnhaOCtjVnEvWDFkTFNvdUk0VnJONVgrZnFBQUFBQUFDQWZTUjA5YWU3Lzk3aGpFbUtRczRhMWQ1cm1tRm4raldqNUlMUmNLYk5DK0FJMjFIQnRyUkdSU0V3U2tvMFdLSWJRNytSaE1iWE5aM3pqVnhrbmFtYTI4WVBta2VjYVk4NDVhUE9OUHoySHVrZU9lY3kvMDZ6TjYzaXRsRWN6c0RheTV0eDRYZlVzSi8yQzVmNEE0Wkw4MkwrOW1raW82bzFKb3F0aG93eGNUWGlpdEczSzZTVzg0ZGFBUUFBQUhzY1oxOERBRXFkdE5DMVRxcGtHeUxzb3lKVHM3K2dvZTZzeHRwWEJBRDM0bWJZbVhXcGI5Rk55OXU5dEtWZTF2UEhtVFI4R2FMTjB2Zkh4cVgrZXE0eEFnQUFnRnMxbTgzUWFVUFlQMFpHT1VrVUFBQUFBTEE1NnZWNldXNlY1N25TSkZHYUpuZUVHMWxyRmNlVmNvaFZvWjY2bmJheU5GMHpQZ2wxNklzckNoVytBQUFBQUFBQVlIOHEzR3FPME4ybXFjaUV4L085SGRNeUdDTHAzcE4xdHBoZExaWGJ4eHNaTHp3VXJqbzh1TnZJc0ZNKzVreG01VnBXNXA0YmtaMHA5NGVpYlFxejZGZlhYai9ESUx6WnNGYnowSlRzbk92bjZ0OCtUUndTb1l3cWZnc2dvZWU5VlFZODR3c0FBQURZRkFRWUFjQStOOWROOWJVcksvcktwV1ZkWE42Nm5QWW9UMzJMWktGbnYvTlBaRjJ1b2U2Y0FHQ3pqYTFjS2N2QitUZVZSMVc5L09oUHFWZHBLWXVxdWg4dlhGZ3NoLy94RTVQcUQ5ZDBwSFYveXdNQUFOZ3ZXcTJXNGpqV0J6LzRRUzB1TG1wNmVsclkyNVlXRndVQUFBQUF3R1laYWczcnlhZWUxdnpjckM1ZU9LYzNYdnQyV1U2Y2ZMZ01LN3JWK01Sa09lM1U0U1BDcXZiS3NpNmNPNnZGaGJVWHhmN2RMM3l1SFA2RHYvZDNORG8yL2s2OUhUcDhWSTNta0tyVnFqNzR4RWY4c0tiblAvMmpBZ0FBQUFBQXVLbWJPYVc1Szg3TXBjdTF5TGlocW5YMTJOUjlhWVRnQ2tNK3c2N1NsMXZvR2RNYmtoNThyMmxhMGxSSU1JbENpZ25yZDBzMXd5VjhmVDEzeldBRkFZMDZvL2ZxUFIvNVRXUzFER1o0MFVtbjlrRm4rZ2NLalZTTjR2czlTRjN5czg4Wlo2NGEzWm5rc3djVWZnTk1jbWtsS1ZhV0U5ZE9DemRTT0RYOFF6ZXZOdkRnT2hiVHRjWVVJeFhUcmZuZkR5TjEyd3ExYmpsK0FBQUFBSHNlQVVZQXNNLzV4aVQ1RmlVLzFOYndqVmVoamFtV3JzajZCa2xURkRLT0t6Z0MyRnJoT0JPT043V2tIWTQ4eW0xbDlTdVIrL3pDSVJ3djIrbGV2MDRDQUFEQTVxdlZhbVdRVWJqY2xndC9tWEZCTmdBQUFBQUF0bHludmFMck0xZTFXV3IxdXVxKzJDaFNGRzFQbDZQd1hKVnF6VC9mMnV1T0x5MHRsdVZXVVdUOXROVTdwdDNQUWhqUmdjbXBNc0FvaEVGMU91MXl2Q3UrKzUxOWxtWHE5WHArZTJscjJkZHBtcWFxVkNxNjVyZWRFR0FVZ3FPc2pXVENWYlJ2clB2VllWUXVQd2p0UGdBQUFBQUFZSjh4TW9XY3laMWNWamlUK2p1eDhTUDhRNUV4VnRnVndnb0xnU1hyU1NZS0s5WDZTWXROQ2lIeHordHVkQ0VpMW1UQVJYNDNqMVpYMDY1cENMUnlMdmJIcDRwLzNkSHE1bnRmY3IrOGNCWkI2cGVYN3RGdE51eVRtZDhwd3pHOVBQVnJ0ZDQyL0Y1TmVkYUcvLzNnNS9lL0k4SjVheTVhWFlwdlptWjNCd0FBQVBZeWVvOEF3RDQzMzh2MDJUZm5kSGs1MFZhSVhPWWJxUXM5Y3Zrckd1bGNVNnMzS3dEWWFvMWt1UngrNk53WDFhdU42T1ZIZjBxRmJ6L1BvNHJ1eHd2bkYzVjhwS3BIeHhzQ0FBREErb1FURzUvOW5tZjE1cGszTlRNem96elB5d0lBQUFBQUFMYlcrYmZlMUYvOHhUK3R6WExpNU1QNnVaLy9SVTBkUHFKRGg0OXFPelFhRFQzK3hFZDA5a3kxZkQ4My9lNFhQcXM0WHZ1OXo4am91Si8yU2VHN1B2YUpUK3F4LytIRCt2SUxYeXpMSDM3NUJjMWR2MWFHUDkwTU1XcXZMT3ZyWC9ueVhaZFRxemY4T2oraThZa0RPbjdpWkhsN3ltOER6ejMvZzJWQTB0SGpKd2d4QWdBQUFBQmdId21oRm5taEVWL1V5OG8rSUtrdnZkR2FTV05yM0lHR0hiYUVHTzBLZlNQVDl1dHplQjBYSXh1VFVXaVJtOStrSzVkbHp2U3oxUWlqdWpEUVJwMlpINWJDU1VmSHRFdU1Gelo1MkRkL2pqa3oxSkNHN2pkeWFObVkvTHh4NmF5S3lvcFJWWHRNQ0M5YVNseXZuenM3M3kxcUNuVzJXamJNNzlYMUVGeTBuTGptc25INWJMZm9qOVJzUE9wTExYS0tMQ0ZHQUFBQXdGNUZ6eEVBMk1jNlNhN0ZYcTVMeTBrWlpMUVZobnB6cWlkdDFkSzJLbGxQQUxDZDRyeXZtajhHalM5ZlVyL1MxT0xRWWQyUFN5dUphQzhIQUFDNE4vVkdYY2VPSHRQY3dwd1dGeFlGQUFBQUFBQzJWcS9YMDh6MFpXMlc0WkZSSlVsZnhUWUdFMWVydFRJMFo2ZzF2R1o4bXFZcWJnVHdoT0NjRUtJek1qWW1yR1d0VmFWYTFiRVREK29UejM1S0V3Y210YlM0cUZPdnZxd2wzMGJ6K211bkZQbjZxOWNieXZOc05YZzZ5OTZwMjV1eUxDMkRqbFk1TFMvTzYrcjBGYTBzTDJsa2RFeVBmL2lqNWZDeHg1OTRaM2tBQUFBQUFQei8yZnNUT0xtdSt6N3cvWjI3MWRvckdvM0dRaEFFUVJBQ0NZa1NLWm1TK0N6WlZqeXlIZHQ1anBLeE5ZNUh0ak9Lay9obC9Ka3RNNW1adkV3bU0yK2N5ZnVNTXBQWWlWOFd4L0VvanFVNDN1UkYwVUpKbEUxUnBFU0pKQWlDV0J1TjdrYnZWVjNyM2M0Ny85UGRFSllHMGRWZDFWMWQvZnRLbDlXbzVkYmQ2bGJkcy93TzdTbU8wdHB0bW1LalJHdGREVlhrT2tET1V4a0pEV0hUMis0Vm1XS2dCQnRMSkFva3Iycmx6N1lFRHBsakpaYlFGRERBNkNiWGJCYjM1cC9kdyt4N2xkVzc0Nk1jYUozMmFTY2FWRHJOcFNyam1uTVQxT1lYUFlUV05hV1NSWE5iTWZzbGduWjY3YXhtemdOSmtrTFhvdFJOMjd5ZnpVZGM1dWZLaDkzTTMzdzNLTStjY1pSajlnbS9HNGlJaUlpSWVnOERqSWlJOXJDRlpvd2J0UkN2emRYUUtSSWFzcTk4RGYzVkdRUnhIVVJFMnlrcjRXbEpFMGRtWDhGeWJtVExBVVl2MzZoZ3ZwNEJFUkVSRWJWdWVIZ1lqNTE1RE9mZk9NOEFveDdXUHpBQUlpSWlJaUlpNmc3TlJ0MEcxTFNMQk5QVWF6VWJIclJkSkh6bnlORmp1SEZIRUZQWWJPTFc1WHJrMUdtTWpSMEMzYzd6ZkRzOThhNzMyR25Oci8rTGY0S0o4U3YyK0pESDk0M3NSOE1jTDgxR0E3VmFGV2tZM2pZZkNUV2FuNXUxMC9pVlMzZTl6L2Q4L3cvaTRLRWorS3UvOERlUnlXYVJIV09BRVJFUkVSRVJFZEVlNDJxbDNMVjBtekJORjN3SE9GVDBNaEtONHpLbG9tc2xDanFVQUtNTlJCajFwYWpZZ1dCVmV3S0gwbFEza3BWanBnOWtaWUJvOVdQVVZRRkdPU2lucjh1VzZWNHlVTWx4b0NyaFJZTlFoYTJtNU1qbjQ2clNrWVFYelNzZDlHSWtXejNXVVpScWxKdTY3V0ZpeWh3NzVzYXBSV2xZaTFUa09hNlQ5ZUJtWEREZGpvaUlpSWlvQnpIQWlJaG9EM3R0dG9ZcnBTWTZJUk5WRVppcFdKOUhvYjRBTjkyK1JxeEVSTGRTT3JYbklSa01vSzgyZzlBdm9HbW16YWlFQ1Jick1TNHMxcEh6SEJ6dVk1Z1JFUkVSMFVaNW5vZGlzWWhpWDlIZTF1dDFKRWtDNmkzbDBzNkZVNVhMSmVnMHhmbHpyeUUxdDh2bTMyRVlvbDZycm5iWTlEQTR2QTlCRU9DaGgwOGlrOG1ncjUrQlMydGsrMGtINE1zWHo5dnR0clF3anppT3pSVFpqcXlGWXAvZGJyN3ZZMkJ3Q08zMHlzc3ZtZmRzWXRHODU5byt5K2NMdHFQeTZOaEJaTE01bkR6MUdMcEp1YlJrem1NMVRFNWNzOXRJbHMrMTV6bTJxeVFpSWlJaWFxY2d5TmpyZ3Y2QndYcyt4M1c5K3o2SFZwdzcrNHE5WHY3cWx6NXZ3NGhrdTQwZE9vSWYvSkUvZi9NNWNyM1RNTmM3YzdNenR1eW10TFI0ODVxdFdxbVkxODNZUUNPNVpseHorZUtiOXZtZi9OVmZNZk03akI4dzg1UHJvd0t2a1lpSWlJaUlpSWoycERqVk9hMmhseHBwM1hlVVV3eFVSaWxtVlhTakNNZzJOaGhNa3dXU0ZPM2p1MDRPZWdQSlNYdElvRlV0c2grVTlnZkpiSVVQbmZPaEFuUzVBWTJvQ0tWTnFhUXM3NllEbDh4aEdac1RscDVTR2pLTSt4SzBGNjRFOGZTVUpGM0pMcXMwVXkvdThHZFJtLzFoTmlscWNScUZxWXIyNVp5TUM4V3ZCU0lpSWlLaUhzTUFJeUtpUGV5MXVSb215cDBKTUpMd292N2E3RXFBVVdNQlJFUTd4WkVBbzhhQ0xWeVg4MUk1ajgwSEdFVXBGcHNKTGk0Mk1KVDFHR0JFUkVSRTFBSUpQWkZKd292Nit2cHNTQWtEaktpZEt1V1M3VHo1NHZOZnRiZVRFK09vVnBadGg4eE1ObXREY0k2Zk9HazdUMHB3VWIrWkdHRDBIYkw5Sk1SSXRwOXN0MHNYenFQUnFLUFphT0NSVTZkeFlPeVEzVjRTTE5TSkFLT0tlYy9MNWozWDl0bGFhTktaSjU2MDc5ZU5BVWJTZWZlYkx6NXZ0NUZzSHpuT0dHQkVSRVJFUk5SZUVrSXJ2N2Y3Qis1OUhlSzY3dXB6R0dCMFAyK2NmZFZlTDB1QVVhMVd4YW5UWjh6ME9ENzZzWS9mdkhhV2F6SzVOcE93bzhpVTM0eGZ1WFR6T3ZIRzlLVDlXNjRYYncwd3VuTHhUVGlPZy9ITEYvRzJ4OStPSjkvelBtQU1EREFpSWlJaUlpSWkycVBTRkRsdGJwWWE2VkxXVTE0aGNEUFNrSmRSRmQzSGxQQmtRNFVBRzhndXlVS1pYU3ZQYkUvUVNlQ2dnRTFIelBRbXN5UHFrV3plTHZ1c09CcTUzYkNyQnFIaW9vWlQxQ3FITGRBS2t1ZWpyenZRSWJSVFVwTGYxWHRoVzRtY3FNMVVpM1RIQTR3TVYwS01LcUd1S09oa09Lc0M4NlhBYndVaUlpSWlvaDdEQUNNaW9qM3MyZkVTbHNQMmRoWlZwdERLU1dNTUxWL0g0ZG5YVUdndWdvaW9HMlREQ281T2Z4UFg5eitHV21ZSXFYSk5kVUxyQXlGRVNXclBudzhOWnZDZVEyeDBUVVJFUk5TcUkwZU9ZTisrZlhqdUs4OWhibllPdWdjYmQ5RDIrdlkzWDhUbGkyL2l0MzdqMTFCYVdyUWRMZE0wUlJnMmJXZkt4RXpTaVZLWjZlV1h2Z2JYOWZESHYvL3ZrY3ZsOGNOLy9zY3hPbllRSC9yd0QyTXIvdU0vK3oxMzNYZm1pWGVaNlNtOC9aMVA0YUdISDBFci90Ny84Ri9hWlgvOTFXL2Z2RStXODRDWmZ2Sm4veHFPUGZUd1c3NWVPcVBLZHZpbi8rZi9qdG1aRzdjOWR2cnh0K1BIZnZ5blZ1ZDNDSi8vbzkrM0hWRC84SGMvallYNWVSdk1JK0ZpOVhvTjJteEgyWmJTU2RYelZyYWIrUG4vNm4vQTBQQStQUG1lOTJJem1zMEdvaWl5eXpkbmx1OVBuM3ZXdm1mRHZPZmFQdk9Ed082MzU4MWpybm52NTU3OUhMSzVIUDdTei81Vkd4STBhcFo5cTFhMjhiZnM5TzkrNDEvZjlmaGYrUnYvRlE0ZU9vSzNQZjZPbTUxMVgzcmhUOHowcDVpOU1ZWEs4ckk5NXNTN24zNC9pdjBEZHB0ZU45dGZncUMrL3Z4emVQUGMyZHZtbWNzWDdId2xvR216b1V6LytwLy9NcTVldm9CWFh2N0dYWS85NkVkK0FqOWlKam0rcFJNM0VSRVJFZlUrQ2FBNWRPUW9ubjdtZ3paVXBwTUtoUUllZk9pRURicTUxVC80cFg5NTEzTWxpRlNta2YyajJJcXMrVzM3MEltVDVyZnVqNXQxL01DNno4bGtNdVo5RHJRbGJQVTNmditMZDkyM0ZsaTZrWFU1YlBhRlBQOGYvWXZmdU91eC9hTUh6RFMycVZDZnpXN2pPSTdNY2RHd3diRXlmZll6djRNYlU5ZnROYk84N2hmKzIvODNCb2VHelRJVnpUWFl5alZFWDMrLy9iZE00b21udnV2bU5ac0V1TXB4TmoxNUhWT1RFL2pNdi85TlRGNmZ3TUxjakgyT2hOTytjZllWZTEzN0l4LzVxTDFHa2YzaisxMC9PRHNSRVJFUkVSRVJ0Wm5XVUxIV2ZjMEU2VUk5S1JkOEo1UDNGVWNPN1RKTndEZTdha09OZDNMUVJlajJCWTRvdEQrbng4d3ZOVXU0WklxNnBNOWtQMmhMSklrc01GdTEyenVnN3RNcTlEVDBDYWpBMFhyVGg1VTViOFZtbFpNM0hPMDFIYWg1ODlGSUpjNm8yeEtsMm1TNW1aYWJpWTRUYUJrQmJsc2FtWmh0bkpNZ3RGcWtIYzlKa2ZkYjc4OUJYU1cwazZzaUVCRVJFUkdCQVVaRVJIdmFiQzFDTTA3UlhocU9LYUlMNGpvS3pTVWJaa1JFMUEzY05MTG5KVGsveVhrcXhlWUt1Nk5VWThhY1A0ZXkvQ2xOUkVSRXRCbjVmTjVPbnUrdHRPMWdmaEZ0MGR6c0RSdlk4ODBYdjNZelRPWit4cTljUWwvL0FON3g1SHZRRGhLeWN5Y0ovTmszTW9wSFR6K09Wa2x3a1hRd2ZmSDU1MjdlZC9UWWNUdlZxcFg3dmw0NmpNcTJrR0NndVRzQ2pJSWdzSSt0ZGV5VjhDTFpIdDk4OFFVc2wwdnJ6bTl0dThyenhJeDV6VlpJcDFZSktaTE9zN0o4bHkrY3YrZHpaekJsYjdQWm5BMU5xbFlxWmgzYTA2WlZPdkxLdWwwNC8vcTYrL0RIZitvdjIrTms1Ym14ZmU3VlN4Zndzam5XSkNCS1FvM1d5UDdLWkZjRzhKUHRLTWVrUEUvVzhWWVNYTFJnWGl2bndjMlM4Q0k1UnRaYjVuZEt4Mkt6ckZyejVFcEVSRVMwVjhodlZwa2tPR2VudlBlWkQ2SlRKSmhUUWt5TEp4N0ZjVE4xMmxiWFpTMmNxTjNiWkxQemsxQmF1VWFRNnhDNTlycDYrYUs5cHBOanB0alhiNE5WSlp6SjgveWJyMW03NXNwbTd6MUl1VndmeWpYYVY1LzlIQmJtNSt4OWNoMGk3MVV1bCswMXk5UFBmTS9LOVVuQThDSWlJaUlpSWlLaVBVblpzWkg5V09zb1RCQm5YTzMzYWdqSWJxWVZuTlEyM3JuL3Z2R2cyaHMxSXJFdzdVOHcwbzVTa2RJODF0cEJXc3RMeVdHM2I4MnNLUXIxekw0dnBCTENzL21sMVVxbHBwd3pMU2tkTk0yTVFudHY3eDVMVWFyalpvSnREWjdScTBGSmlmbERzV2xMTDVCT2lZbjUySEJ2RWhFUkVaSEZYdGRFUkh2UUM1UExxTWNwcGl2dEwyZktoc3M0c1BnbUJwZW40Q1loMnMxeFhUdnlvNHdpNzdpZFNkcE9reFJKRXR2R2xNMW1BMFRVRzB5ZGhEMHZ5ZmtwZGwvQjdNQkRxT2Iyb1ZWeS92enl0VElxcGpaMXVoS2lFTGpvQzdabHdBRWlJaUtpbm5MeTVFbU1qWTNoN0d0bnpiVlhFOVFiK2djR3NGMmUrOUxuOFZVei9lbFh2b2hMYjc1eFczaVJId1E0ZnVJa2ZOOUhObGN3eDFnZG9Ubk9wS05tbzE2M3o1R1FtVi8vRjcrTTBiRkR1RForQmUvL3dQZmhHVFAxdWlpS1VEYnIvcW4vKzEvaXRWZStoZk92djRxbHhYbXpQY29ibnNjdi90Mi9oYmM5L25ZTURnNWllR1IveTUySVAvOUh2NGZYdnYyeURaMjZOUVRvclp3Nys0b3BFM0x3bjMvOEovSDArNzRiUC9YeG43ZmhWWjBtZ1VtLzgrbC9nMHNYM2pESHl6OHh4MC9OSGtOSmV1OVE4UDZCUVJ0YzlaVXYvb2U3SHBNZ0pBazNLaFNMMkt5cmx5L1o3WEhuZXg0OGZBU0hqanhnT3lJcnhjYVlSRVJFUkVRRW5EWFhmYjlwcnYvT3ZmWnRNNzJDTUZ3cGcvbVJqL3dFamh3OVpxNGhOaGQ4SmErVDYybTUvbGhjbU1OLy9mTi8rV2JZN1VxSVVRbXZmUE5GZXozMXpBYy9aSy9SaVlpSWlJaUlpR2h2TWxXcmZqVk1CMTBIeW5jVkFnZHdIZFpuZG91bTBvaHQ3TVQ5OTRtQ3praEhSSW05bGhyenJiYjJrV1BCL0Q4MXgwWkZwOXBMb1RZL0V0QXFNei9WRnlBVHVOaVZqYnNMV3FsdVNuWEpBclUramNqc2Qybms4SmJidEY4ckc0VzFaSmEvM2NPczM4dWdXYlk4VkhKS0s5L1hldE1kakxSOERCVGlpMGk5ZVZmNzgrWTQycTUxMkFuTnhBWVh4ZlVZQTJHcVpmMjMvZk5TamZTTUE1MzBCYzVCMEs1bFB2T3o1cHcxWWI1QlNpQWlJaUlpQWdPTWlJajJwUGw2aEhvc0pXenRMZGlVSVJLY05MWWhSbDdTeEVyeFkyY29SOG9XSFRpZHFMeXdIYnkwSFkxU3lmdzFPR285VVkrUTg1S2NuK1E4NWN0NXlueTI5U1k2ZFRiaUZPVXdRY2xNdmkydVo0QVJFUkVSVWF0eXVkektkWmUwdXpFVHI3dG9vK0lvUWhpRm1KK2J4Zlh4SzVpOU1YMWJlTkhnOEQ0RVFZQWpSeCtDNzN2STV2STJ2RWlDc3VSNVZiOWl3NHVFaFBhNG5tL25Nejk3dzRicHlHdjlJSU5lMVdqVVVUYmJZZWJHRkNiR0w2TldyU0FNUTR5TUhyQ1BaN081bTgrVlRxZFJiTXFSYWpYVWFsWG8xZENlcFlWNVRGK2Z3TlRrQklKTUZoc2xuM21aU2t0TE5zUW5NdThyazVCdEx0dGV6ZzJ5ejI1ZEJsRXgrMGJLZzJhbXB6QTlkUjNUNXIwcnl4c1BYZHFNMkt5N1RMS3NjcnpOeld3c01DbGp0a2wvLzREWk5zRzZqOWZOdHBRZ3FWYkplVktteUJ6L3pjYnRvZHV5SDZUanNPdy94K2xNNkRjUkVSRVJFZTB1Y28wN1B6ZHo4NXBHL3UxNW5wME9IemxxcGdmczM1dXhOcDk5SS91UnlXYk50VWpXM3E1ZHE4ajFZNjFXTWRlUGM2alhheUFpSWlJaUlpS2l2VTFhNVNjcGRKenF4RlZ3WE96dEVWbWtoNElETFRrMVdrR2xhcVhMZ2twV1EwVDB5ciszaGJRQzJPamVVS3ZQZEpHYW1tdTFjdGNXckxRWk1tVk5aa29jcGRNdEpzWW9VeW9sdVRPZW8yU3M3RjFaY1M2bGRUNVcrck4wQXdtWThwV096VkdxNzdlMzFjcnp0NFY4UkZ5empiSnd0Q1FyU1hoUnNLbnp5a3FMdGRnY1BLR1phOE9CcXN0QnBMcGxEM1JHWWo0cnNZWTU1Y2ltMjVtT0VETHV2RG5YSmFCZHpYeDB6T0dFMEh5MWMxOFNFUkVSa2NVQUl5S2lQZWlMNHlYTTEyTzBsU20xOHRJUXViQ01JN092MlNDalRraVR4RTZOZXRVVUx6cklGelkvV3YyOW1QSnFPSDRBeDFTTnVLNkxacU9PT083TStoRFI5dXV2emFEWVdFQWxONEpxYmg5aVUxMnhtUkNqcFVhTXoxeFl3SHNQOTVrcEFCRVJFUkcxNXNpUkkvYjIzT3ZuYklPa2VyME8ydjNLcGM0UHBsUXFMZUw1NTc2RVAvNjkzOEpuZnZ0VGR6MytOLy8yLzRwQ3NROC8rcEdmdU91eFQvN3FyMkQ4eWlYOCtyLzRKemREakNTTTUzYysvVzlzUUU2MVVzSFR6M3dReDArY1JLKzZjdkZOdS80M3BpZHRHTkNaSjU3RXdPQVEvcE9mK1Ruc0h6MkFkei85ek0zbnlyYVM2ZGYrMlMrWmJmNHN5bWFicmJVWW5MdytnYi8vZC85Ny9NQ1AvQmplL3M2bk52VGVzczBsUk9xNVp6K0hQL3pkZjNmYlkwUER3L2pRaDM4WTczclBlL0VYUHZxeG0vZlBtT1ZzTkJwMjM4bnJaZG1mLytxWDhPWWJyOThXWE5VSjh0NFNXdlRMbi9oRkcyUzBVZEtCZDJVNmNOZGpZZGpFdWJPdlluQjRCSzJTVHI4UytGUXgyMkh0K1AzT2U0N1lmWGZveUZFUUVSRVJFUkZKV0pGYzY3NzB3cC9naTUvOWc1djM3eHNadFVGRFAvYmpmd2tIRHgzQlZoMDVlc3pleXJYY3hQaFZ2UGo4Y3pjZm01dWRzZGMvNzNuZmQ0T0lpSWlJaUlpSXFCYnJhcGlrMWYxNXB6OXdrY01lRm1pdHgrQTBBNDFxMWhUbGFBMWZBKzZzd29pcGtYZExNaGd6c0MzSkhtR0x6L2NBdlU4N2pZYUcwM0QwbGtlSGNwVnlEaFM4L21hc2NhTzJ0VFgySEtmc093cURXWGNRdTVTbm9kMHVpdmN5eDJpVWgycVkvU1FkZDdxbUgrcWdSaklFSno2U3doK0UyblJEL2xUR2tZSnFUamphRzFkcFZxTFlvejBRcnhaR0NFdU50Qm9ucVErb0hRa3drbkdrbGRxZFFXTkVSRVJFUkhSdkREQWlJdHBEWWxPNmxwaXAzRWl3VUc5L0lJOGYxZUhIVFNnSnJ1OXczdmpLaVBNSlV0dHB6cFJhT1owcEpiUmhScTRIUjk3UHZOZEt2am9SN1c3YW5xZmNKTExuclNUd29EZFI3aDRsR3JPMUNOV0lZZkZFUkVSRVd6RXdNSUJNSm9PSmlRa1FiWVNFMlVpb3pwM2hOWDBEZy9COUg2TmpCMUVzOXEzN1dubk1QcmQvQUdFWTJ0RGlOZEs1VTBKOUpNaW9seVZKWXRjeG04M1pzSnRIVHAyMllUdWpCdzZpZitEMk5uelpiTmFHRzQyTUhyRFBiVjU4RTQxNnpUNldwb25kZnZKdjJYWitFQ0FJM3JwdFl1VWUyemhqbG1YQXZQZERKMDdpNE9FSGJudk1YNTNuMFdQSGJXalBJNmNlczJQbVZaYkxxK1ZDblNPQlhFa1MzMXpHbFk2K09idGQ3bHhmMlU2RjR1MUIyMnZiVDdiUHJlSFlzdjcxZWhXdGttUFd6aXU1K3pwVWdyaGwyVHlQMVQ1RVJFUkVSTFRpK3NTNERSRzZWYjhwaHluMDlkdnI1MDZUYXpZSmcwMDZmTzFHUkVSRVJFUkVSTHVEMW5CVGFEL1YyalVUSExVSFVrTHV3OVR1ZWptTnJJUVhhUVduMzJ3V0tVbHhvWkNZTFJZcU5CT3p2VUlvUHpHYnExdEtXVXpKVWhSQ3Q2MXlXcnFDdUk2cFkzZk5lbXVkSkJxUjJTYStIRE52OVRvdG5UdVVXUkJIcFhJMEJTNmN3RmxwRk02anF6M001MVI3NW9QcmRMcUQwQVk1WnEvblU1VVVsVXFMNXZQaXl4R3d5WjF0emtOcGF1WlROck90bVVOR1duWDBlbThoNlE2bEpTQnQ1VHdzd1drN0ZpQ2tKYTlMNjI0T01JcnRBYUhhMC85YWVxU3QvdGxUb1UxbUU1bXZLbFV4eDFPcmVYaEVSRVJFMUtQWWtwMklhQThwTjJQVTRoVGZtS2xpcXRMZXNnRTNqVEJVdVk1Q2ZjSCszV2t5MnJ5SWd4Q080NWhwMDZIcDkrUzRycDJrVjV3MDRKUlI3blhDb0JLaTNjNlJzbDh6RmV0emlMME1wb2RQQW1nOXdHakpuRk9mSFMvaHhGQVdSRVJFUkxSNTczN1B1MUdwVkJoZ1JCczJNejJKVC83cXI5d1ZZUFRVZDcwUCtYd0JIL3J3RDkvenRXdVAvZnZmL0wvdDdlVEUrTTNITGwwNGo2bzVGczg4OFJSNldibTBaS2Vubm40LzN2MzBNL2pveHo1dXc0SFdNenAyeUU2ek05TjQ0T2d4L1BJbmZ2Rm1nSkdVemR5WW5zTEV0V3QyMngwNStpQ0M0YmNPTUxwc252ZmNzNSt6Ky9CV0I4WU80bTFubnNESGYvNi92T3MxUThQNzdLMHNaNjFXTmU5ekRDKzk4Q2Y0OUNmL0ZjS3dpVTU2OFd0L1lzdWRWcGJ4RUg3MEl6OWh0NVZNc3I1RHd5TnYrZm9IelBQT1BQRWtYbm41cFp2SHEydzMyUTZuVGorT1ZzbDJtekhidkZHdjMvVllMcCszMjdGd2ovQXVJaUlpSWlMYVc4cmxFbjczMC8vR1h1ZmVTcTY5RGg4NWF1cS8yMSsvZnFmSWhyQldrTVNkYno5QVJFUkVSRVJFUk4wdjFjakpGS1ZBb20wVC9UMGZNdE1QRkE1QXJZdzBaTGJKb2JVSHpOOEpWTE9zTUx1a2RINEsyTGVzTlpwZHNNRk1EWHJTcDdGcy9qSUZUR2tlV3lUSFFkWlRFajVrSmhmVlNGY3FZVm9PRXd3bjBJVzNlcTJqbEFRZEpVVmZSWjZqOUdEVzZUUDNPUzdUaTlvbXI1SDJReVd0dDdUdmpJSlc4U21vWlhNTTVvcGE1Ylp3RXBIMHE2YUVGNzNpcEptR3VhTWJQbCtkbHBxVGk0emRiRDVmY2k3TzdlUlpPTlY2RUYzTW5KdXF5dnhIUXcrZ0RaUTUzbGJPZU9pcHppZG12UmJNU2wwd1h3NFZFQkVSRVJHQkFVWkVSSHZLOVVxSXllWFFGRGExUDN2ZjBRa0dLNVBJaE50YjVpQWQxV1NFZWVVNGtNSWgrYnZkbk5WNXU2NW40OW1USkFZUjdYNzU1cEl0QTU0WmZCaUowL29vczdHcFJTMDNFMHhWSWx4WXJHTTBINkEvMHkzVk0wUkVSRVM3UnhBRXlHUXlHQmdjUUJ6SHFGYXFhQmZsS0FSK1lPYzlPRENJNmVscGxNdGwwTzZVSkFubVptOWdidWFHRFlOcE5HNFBjWG5vNFpQb0g5aFkyNVpEUng1QW1xYTNCUmhKcDhvYjA1TlltSisxOCsvckg3Z1pYdE5MSkJCSVFvQWt2T2laRDM3SWZENkc3dnVhZlNQN2JXaVA1OTFkcFZDdExHUDh5aVU3My9zRitzaDJsZWZlMllIMmtWT243VExkajNTd2xlZTZaam0wMlgvZmZQRnJkdXFVeVltcktQYjE0OC8vK0YvQ3NOa0dFdm9rMjB1bVhPNys3VERYdHR2NWMyZk52MVlDak9TNGsrMnd2Rnl4eDdEbitldHUxL1ZJOEpRY28yRjRkekI1c2RobjMyc2orNU9JaUlpSWlIcWJYRGZNM3BpeTF4NTNCcjhHUVFhWmJNN1dmN2ZUc2lsdldTNlhicnRQcmsva09vVkJxMFJFUkVSRVJFUjBxemhGMUl4MTdQcklxbllYVXV3U3NWbnZKYTI5L3BWaFdSdG1JL2pxanRGWTViNjhSajlTQko1ajZvdWh3b1o1NmJ6U21WREduMFo3SlVCRk9rdTRHbThaR2lTNVUzbXRuRkRwdGphb2tINGFucU9SOTFUV2R4eHBweDJrV3NueElubE90ejkzTmZ6S2NaVHJRS3VNbzZSNWh6YjM3L29EeWxlcXo3OXJqWGVPMmNtK0M1MlJWbGpZSWM3S3BBOW9WVGVmQ1pqU3hseEdiNzVQck5hSVl3VTk0V2l2WmxaTXdvdVNQWEltU2hJVk4rSWtOSjh2NlR6UmVnZUtQY1JWS2twVmlyaE5IMGRYb1c0bU9aeDdMTURJYmlMelBhWVRFQkVSRVJHQkFVWkVSSHVLaEJlOU5sZERsTGEvUU5OSkpjQm9DbTZ5dmFNbnlxaU5ydXZDOTMwYll0U1JBQ04zWlo3U09VN3FTQmhnUk5RYjhvMGxCSEhEVlAxdDdqTXRvNy9JOEI1VGxSQVhGeHZJbWRwQkJoZ1JFUkVSdFU2dTV5VEFhSEJ3RUkxR282MEJSbzV5N0x3UGpCN0FnOGNlUksxV1k0QlJoL1VQdEdYUXFYWEo5ZmpNOUJSbVZ3T003dlRRdzQvWXdKaU5PSFRrcUEzQWVmR1creVNJUjZiRitUazdmK2xnMmFzQlJtZWVlTktHOFVpQTBVYnNHeG0xWlM2dWQzZmJwYlVBbzRkUG5ycnZmTllDakNybU5iYzZlZW94UExDaEFDUGZQbmYvNkJnT20zMG81NHpPQmhoZHcrallRZnpZai8rVU9SNktPSDdpMFpaZXZ4WmdsTTErcCszUldvQlJkYm1FcGxsK2FaYlVTb0NSZkFhaU96b2dDMWsrQmhnUkVSRVJFWkdRNjRhWkcrdGZPMHVRdEZ5anREL0FxTVFBSXlJaUlpSWlJaUxha0NoRjJFd1E1bjFrc0pKRHMrY2tacjFMQ240TnVwRm8xWFNsaWNzZEFVYU8rYmZaUUFNWlU0NHpwSUdLMHMyR1JyTm1xczRUQlZkNmhMU3pWMGhrcXYrVmh2U2N1RitBa1R6QmFkcXNvUFl0Z2N6TlV4SmloRXdPS3JOMmZ5UFd1TFA3aTMydVl3TkJYRWM1UGRWNDI0UHU5N3NudjBnT1RNL1ZabjlvN2V4VVBKUzAzREVIUlBxZ1JzMXNHNzhJdGFYR1NaS0xKY05HalN1ZGxWNEV6VDEwRmtxZzQwYUVXcFJxR2JXTEFVWnZ3WnhqSWcybDR6WWxHSm1UVlYyYVhxSEhhTW5rZ3pLbmFvOEJSa1JFUkVSa01jQ0lpR2dQdVZKcTRJV3BDcUtrdlNXYStjWWlzczFsWk1KbFV6elQ3aXovKzVPT1h6Sml2ZThIcGt6VXNaUGp0TDhVVVVhajFHbUNOREhGZHVaL1Njd2dJNkxkVE1LTDNEUkNvYjRBTDI2aW10dUh6YmhlYWRwejY0R0NqOE45R1JBUkVSRlI2eVNVNVBUcDA1aWZuOGY4M0x5OXpwTnBNeVJ3eHZWY0hIM2dLSEw1SEE0Y09JQmlzV2duNmFSSG5WVXVsZEFwc2JrT1AzL3VMQ1lueHRkOS9QaUprelpzWmlNT0hUNktKRm4vR0pOd25mbTVHWXdkT294ZUxFS1hVSjEzdk9zcEhEaDRlTU92R1J6ZWgzeXh6NFpJYjRVRThFeU1YMGExVXNHZHk5VFh2L0gyWlJMV2Mvam9NZlFOREtLVDN2V2U5NXBqNVFIN1hwdFpkd21Ma3RmNndkM1hpaEw4Sk50aS80R0R5R1p6RzVyZjRzSzhmVTE0UzRDUm5QT0doa2N3UERKcXQ2UFA4eHdSRVJFUjBaNVhxMVZScjY4ZkVDMmhzaElHRzhmdEdaam9jMy8wZS9aYVpmTDZOWE03ZDl0akJ3NGVzdGVmRW9wTFJFUkVSTFRkdnZyY2wyeDk0OExDd29hZUgwZVIvVzE3YmZ6cWZaOWJXbHpDRytkZVI3VmF3YmRhSEZqZzNlOTUydFpaam14d1VBNGlvbDZVYUIyRnNXNW9lUDNZNDVZVS9Fc0t6Z0d0dmNIN1pEbGw0V1I4cmYyVFFOclVpSzQ0OENSZFExS0gyaUUxKzhXRlN1OGZLYVdVV1k1K1QyMVArSlMzenJoVENpc2hSbXB2NWw5dEt3Y3FjQ1ZiYWlWSGFKdmZlMlZmUDV5cWFrNXIzUWRWVkZzSVBkUFFOcERtb3RKZXcveTdodmFHZ08wR2lmbUUxK0xVaWRQdStmREVxYmFmWjFkMTErYzU2NnU4bTY2RXFMVkR6amVmSlJtTnNmZk1KZERuVXNSTElDSWlJaUlDQTR5SWlQYVUyVnFFcTZWRzJ3T01KQVFrRTlmczdVNHdaWkUyVEVpQ2l5VEVxRk5GYWJham1wa2N0N255bm1DQUVkRnVKdUZGTW1VaXFYNVFtdzR3V21va05pQ3VHbTEvZ0JzUkVSRlJyL0E4RDRjUEg3YlhYUkxHSWRkY202Wlc1cmQvZEQ4S2hRSWVldWlobXc5dE5YeUZkcFpjKzg5TVQySitibmJkeHlXODVjRFlJV3hFLzhBQUJnYldEOHhwTnVvMllDZE5lN09aVWk1ZndKR2pENW4xMzNqNFQ3SFlaMiszK2htcTErdFlYS2VqUU1ITVg1WnJveVJrZW5nNGcxd3VqMDU2NE9neHM2Mk9tZmZhM1BXaXJKZThkcjN3dERBTTdiYm82OS80ZnBEalVsNGpyMTBqNTh6Q2FraGJZWFUvRVJFUkVSSFIzaGFaYXdicGZMMmUwdEtpdlkzajlneUdmT25DZVZ3MjArTDhIT3ExMm0yUHlYV25YSC9tODUyOWRpTWlJaUlpV3MvRkN4ZnM0QmpYSjY1dDZQa3lzS1dFZlM0dDNiL2ZiYVBad0kzcEtWU3JWV1N6V2JUaXhJbEhiTDBMQTR5SWFDOHpWZkhtckl2WU5nN3Bzc0NLN1ZiWDJwMVhjRzBjM24yYUtIaGFCOUlKY0w5V1VtR2N6R2p0MWMwZlZiU0hWaXFSSEpIN1BVOUJPNjVDenRIYjA2YkNjL2IyTWJMVHpINzJIVGtzZHVDekt1OG9hUzhqR2xIQi9Dc0RGTEVGV2l0cENaVE9POW8zbngwVjdjRkRLelVuR2drdjZxWmVEM3J0UDEyMlAzeEh0WFZrNjhCUjVuVFdrd0ZHRlFVMWJWWnNaem9VRWhFUkVWSFhZWUFSRWRFZUlNRWFWMHRObkY5b1lMb1NJVzV6WWZHQmhmUElOMHZZU1ZKL0VVY2hLa2xzTzYvSnlQYXFRNFdrMHFGTzY5UytwNHpRa3lZTU1pTGF6ZVFjbGpvK0Z2b2Z3R1pjTFRkeHZSTGltU1A5ZUhnd2k1Rzh6OG95SWlJaW9rMlNRSm1uM3YwVXJvMWZ3N1ZyRzJ0TXZFWUNpeVFrNUttbm5ySU5oVnR0TEV6ZFR4cVpUMDZNM3pQQVNFSmMrdm9ITmpTdkEyTUhFWVhOZFIrYnZINGQ1ODYraW5lODY5MDhqdHBFOXRubEMyK1kvYmYrcU1XSGpqeUFnUlpIS040T0Q1MDRhVHZiYnRiQnd3OWdhSGdmc3JuY1hZK1ZTaVY3bk9VTEJSdzlkbnhEODVPUm4rVXpFTjBTWUpUSjV2RFUwOCtZWlgwVVJFUkVSRVJFUXE2eEpPeDBQYSsvK2kyNG5vZVAvK1QvMDE1RHYvZVpENXJyaWl6MmpZemFmL2YzOTYvN3VrcWxnb254SzRoTW5YeWpYamZYTTYvZ0RUUEo5WjZFclZZcnk3ZTgvMUY4Ny9mL0lONy9nZSt6Zjk5cldZaUlpSWlJT2ttQ2kyUkFnRXNYTDJ6NE5XdHRRdStuMld5dURGU3d1Tmh5TzlYbGN0bjhSdWFnSzBTMHQ2V3AxcEdyVXZUbW1FSXRxWnV2a1liNS9sbFFxdUlEWVYrcUI3MzdCRnc0MEw3Y1BwNUNSZWJyNncxSG1XOG1PUE5LQjloR3NoRERXcUZwZG1TVnphYkpHSVJlQ3JRVGxaUWVOcitvTnYyRFJ3NG5lZkZqcVZvdWFpU0RHa1VsaC80V2o3UFhuVFJZTnZPWVIzY0YrR3dITzRDN09lZkdpUTRTT1lkSWZGeVhCTWhKMXI1MHZmQzZyQmc1NXlIanAvWlFhU2dOeDV6dU5uZU9YVGxONnY2TTJsaWp0dDFHbzV5bThZUmJ5OVZBUkVSRVJBUUdHQkVSN1FseHF0R0lVNFJKMnZid0l1RW5JYncweEU2VFFqVlRvN0Z5dS9ydlRoU3FTUU5McWFPV2VlL3hRUitJZW9KdnpsL0pGbXBCNVJ3clV5aTNtcldwUkVSRVJGc2xnVEdlMTNxeHBWeXJ5ZXVLeFNKeTY0U0ZVRytRRUNPWjFpT052VGZhS1ZLT0ZmY2V4NWtFRmQ4cjNJZzJKNGtqTzJyeHZmYWQ1L2wyNmpZU2lpYlRacm11YTE2ZmdlZmUzUzV2N1RoTFpHelJEWkpPRTdJTjAvVDIxMnoydkVsRVJFUkVSTDFwNVJwci9XdUV0ZXZxNmNrSkd6cFVXbHEwd2FoWk04bHI3blVOMUdqVXNWd3UyVTdhOVZvVmN6TTNNRGx4RFJVemoyU2RhejBKUThybThyeFdJU0lpSXFJZEk3OTdFeW1ManlLMG03Uk4zV2pZMFozUzFkY1NFZTFsY2hiVWV5MDk1QjdzdGxDbVR0MThPWmhhNEExdWxaVWVEREljazlSRSsrYWJKZEVTUjRKdEp5MDAySjJDMWpoUXFkdUdUN2Rhblh6ejhjaVplU3BveDdsUHNOZEdtRitGU2xvRG1SbnV5ZnkwbFhWZTdRWFZSUjljamU3Y0g0NUVQQ2t0eDUyY1h6ZS9pS3ZkMjlweERIY2xwZFBBUlJ5NmRYNnpFeEVSRVpIRlZpSkVSSHZBYTNNMS9PNmJDN2hjYW0vbnV5Q3N3alZGNVNPbHk4aUd5K2dHVXJGYmI5VFFiRGFReXhkdGc4aE9oUmdWaW4yMmdXYlR2SjlVUk91VTVTMUV1OUcrMGxWN20ydVdrU2dYWVZEQVpyd3d1WXhxbU9BdnYrTUEralA4bVUxRVJFUzBHUkk4ZFB6NGNkdWdXTUpPbHBhV1VLL1gxMzJ1Ny92MitZODg4Z2dlT2ZtSS9kdDFPVnJwVHVzZjZOeGdVWVZpRVIvOTJNZnQ4ZkV6UC9jMzducDhaSFJzbzdOQ3NYOEFmZjJEb08wUmhrM2JLYlpwUHRmck9mUEVrL2NNbE5wSmg0NDhhS1lIc0ZuNXZMbStOTk1qcHg2ejU3UlhYbjdwNW1PTEMzUDIzMGVQSGQvdy9DYkdyOXcyRHlGbFh6S1BmU1A3UVVSRVJFUkVKTmF1RWY0L24vaW5lT21GUDhHblAvbXY3bnFPaEE4QjEvREcyVmZSRGhKWU5EQTRoSi84bVorejExRS8rcEdQZ29pSWlJaUlpSWhvUFVtSy9oaTZrQ3F3bGNlcUt3cDk0MHIzdlE5T09hK2hmV0JEalMvTTg5UTdVcFdyUUtkWnJlcEwwRjVKWVZ0R0QvS2hvaUdkVnNvS1FRWFlYT05yV3BkOExrYTBRZ1NOMGc0RnpXUTFVSVJDcG9YWE9CcVJvOURBRmdPMURtcFZlMUNqTnFBeDROdERiV3NiSVlVS0pTT3M0YWlncG5UWG5YWWtVbDVhekVodnI0MFBnZFdhUkNPdFJyclpURkozOVMyN2hqbG03TlJ0WEZrbUJ4ak51eXFNVTdVVWJpN0RxRCtqSXQ5UmlabGZUNDNJcUdUc2I0V3EyU28zUHZIVHoxNEJFUkVSRWRFcTlxd21JdXBoTWxKTFpFcWFLbUdDaFhxTWV0emVnSjFNWElPWGhIRFNUaFdUYlpLR0xmTk0weGhKYkw3cy9NNlZ3VHVPMUp6STEya3NJeDlJZ2hLSWFIZVNJTGJJRFRZZFlGUXo1OXJaV29TSVdXWkVSRVJFVzViTlpqRXdPR0FEUDI0Tk1KS0FXZ25yS0JRS3lHUXlLQmFMZHBMZ29rNkUxMUwza1JDakpFbnNjWEFucjRVQW5Gd3ViNDhkMmg1SnFzM251WTQ0WG4rVVl3a3Y2dVVBTWduQmxvNjh0NUl3N0xmYUpyZVMwSzVxWlJuTnh2cUJiakp2ZVE4aUlpSWlJcUpialk0ZHhBTVBQb1IzUHZWZHFOZXFxTlZxOXRwaTdScERibHNsNVMrT3VYN0xablBJbVBJYnVSYVI2L0dEaDQ1Z2VHUy9EUy9hdC84QWlJaUlpSWlJaUlqdVJjUEdrVGlnbTZRSGdqUS9ya0s3cGdaWmo3U1kvaUsxN1VVTkoxWkttL3I1T0ZUYUNaVnFhUnNuMHYvQy9yV3g5MVptb1gyRnhGVXFXVmtEb3ExeG9IVk9xemd2eDVhV3c2czlqY0VjclZVSzVSU2dFd255S1NsNE1iQmpEYzNNRyt0QWEyMCtPenFqemQ5bUVUMnpmQTFvS2JIVjV0WTJvR20yK0JsK1MyWVRHRkd5MHVHcDZ3S011cm5WbitlWVE4ZzFCNDJqNDFScko5VWIyeS9tZUU2Vm94TGZVWTdmalFsTlc2UVY1SEJkTWdkVUEwUkVSRVJFdDJDQUVSRlJENVB3b3RsNmhEY1hHM2h4dW9KMkc2NU1JTjlZTXFVeHJUZHM3Q1NkcHJZSXZObG8yQWFVZmY0Z09tR2w0Nnh2cDJhemdkQk0wb21TSVVaRXU5UFk0bm5VTW9PbzVQZGpNMTZicitOS3VZbS84ZFFoRUJFUkVkSFdqSTJOWVhoNEdGLzcydGV3dExSa0xyTldyck44MzhmQXdBRE92UDJNRFo4WkhSMEZkWmR5cVlST0NZSU1qcDk0Rk8zdzRFTVA5M1JnVHJlUmpySXowMU9vVnRZdm55cjJlUGpPOFJNbmJZZmU1NTc5M00zNzZyWGFXMjZUV3kzTXplRDh1YlBtZkxoNDEyUFNZZmpNRTA5aWFIZ2ZpSWlJaUlpSTFraXcwSWMrL01ONDd6TWZ4SS85eDMvSlhGTzhoamZOZGNVckw3K0Vrcm0yK1ByenoyMHF3RWdHRDhybkN6aDY3TGlkNUhwRVFsVy81L3QvMEY3YjlmVVBnSWlJaUlpSWlJam9QbnkydHIvZDJ0aXBieWhka0p5TEQ2U3RoVjNrb0p5SE5USVY2UG95Vk9XU0tSNmFOOVhKcmN5anB1QjRDcXB2Z3pzblVFajJ3YWxIRW1OQjFBWUQybWsrcUZFWjFDcmZiLzZKZGxId0hXZ2NUMVVwVmlwNkhzbHd2SU1qNVVsNDBSaWM1a0NLOUxCV3NXcyt3bzY1dXdsVk5lZUM2THlqQ3hLd2RCMDZpelpKb09OYXBFdHhxdktBenFPTEJHNzNua0pjYzV6MFoxUVFKVG8yKzZacXRtR21IbTlzdjJROHA1cHhWSE1nNHd5WWRmVFJZOHhoWERHYjUyWHo1elNJaUlpSWlHN0JBQ01pb2g1V2pSSmNYbXBncWRIbWdDR3RUUmxlaW15ampIeDlFWTVPVzN1OUtldHpYUStPdVZYT2Q4S24weVJaR1QwZ2lXOTJUdDNTWXFhcGZhODRDdTJ0QkExMWluUjY5UDBBYWRwb3k3SVQwZmFUODFtaVBDaWRRR29xZEl1REZqUk5zYlNNSmpKZGlaQ2E4OERodnBicS9ZaUlpSWpvRm82NVZwU3dqNzVpSDRhR2htNTJxRHQ4K0RDeTJhd05MOHJsY2lBaTJnMzZCd1l4TkR4ODIzMWhHR0poWVI3MWV1MityMTk3Ym1SdWIrVUhnUTB3a25rWHpIbVJpSWlJaUlqb1RxNHBYNUV3bzBPSEg3RGxMWDM5L1RaSTljalJZemZMVzZLd2lZcTVMekgxOUZKbnZ4NjU5aGdZSExienl3UVpESStNWU4vSUtBNGRPV3JMYWZLRmdnMDNJaUlpSWlMcVNzcjgzMXU1bFFaZXl0WDJUN2gzdC9XVTV5bHBCUFlXNDJEb1ZNRTJNWk9tczNmT3d2dzdqYjdUN2t3blNucU0zLzA4SWlLaWRhejErbGhTaUQydG5TSmFhOHpzYTdnNVU1UXpLSjA5VXRVc09UcEk3TGZmL1NXNjFTUWk1Zmc2OVJ6em5tQ0VFVzJCT2NoMVRpTXBtaDlNeFZSbEE2VmRkT0NnOGhRQ2xXcDMxSFhDaHZrNXVBeWRrWjlxRWJhUC9UbHFQcExtYzVPWUQrYjIvVUkwNjJzKzQwNlM2dFk2U0pEbEtEaFpENzVTeW5YTkZrdzFJck05VTNNcnAyMjdIODBWZ2lPUEt5bVdkK0JsUGVWNzVnNEh2WG1HTk1keHcyeUphYlBhOXgrNWpZaUlpSWoyRkFZWUVSSDFzR3FjNHV0VEZWeGZEdEZPanFsNWRjM1VWNS9EWUdVS0trMWFlcjBwcUVBbWs0R3pHdnF6UmhwR3BtbUtSc1BVNnByYnJRWUJ5YnhFczltRTZsQ0EwVnJ3dXN4YnBqaU9UT0c5Wm9nUjBTNDBWSm1VZ21ONGFXenE3QnhUSzlCYStYek5uSE5sT2p0ZnhVek5aNEFSRVJFUjBSWkllSkZNKy9mdnQ5ZGRjbDBuMTFudmYrYjlJQ0xhYmZidEg4V2RnL2RWSzh0MktwZEs5MzE5eFR6dit2Z1YrL3hiNWZNRkZJdjlPSEwwSVJBUkVSRVJFYTBubTgzWmFkL0lmcHcrODhTNno1RnJqVXNYenB0NitqcWFqY2E2enhrWUhNS1pKNTRFRVJFUkVkRnVwRHhKYzlEUytCWEtOVGRCdW5LYlNXMlArVnM1R1cwbkNUZTZWL014SFNra2RlYzdJVWEzUG1iK0hTOTlwNHRHMmxSMjByWnJNOU1kaUlqb3JkVlh2eXF1bW0rYm92bGFLbXEwMUJnNUF4V1lGd1RRcUE2YjJiMm10UitaeXVxTkJMU0V5bjZOYlRoU3hUVmZiT2I5c3I1NUR3WVkwVmJJNFRNQ0ZRMXI1UTRyZEd6MEp2TVRMeWNEbzU5TzFVSmRhWnhWeUVSYW83U054Ni84U3ZUTnowTlA2MGpTYnFDMzU5T1RtczlybE1KTE5SaGd0QW11bzV5K3dNM256ZkZpdGlFYXNRN0RCR0dTWWxsNmo4bHpISE9GNFRpcUVMZ0lzcDd5WElXc28zcjM1R2pXdTZHZ3pqa3FtUU1SRVJFUjBTMFlZRVJFMU1OS2pSZ3ZURlV3V1dtaW5iSmhHY1hHRXZ5NERqZUpXaW94YzEwWGtpRXRveStxTzJwM1hjODM5Y01wQWdrdk1sT3oyVUE3eEpGWlJzZXhBVWt5cXFUYm9TQWo2VXlieWVTUStBbWE5UnBEakloMkdUbWZaYUlLaHBhdm94NFVzWndmeFdhOGZLT0svb3lILytqNEVJaUlpSWhvYTBiMmo2Q3Z2dzlKa3ZBYWk5cXFicTdiWlNMYURnZkdEaUdYTDZ6NzJNTGNEWncvZDlZODU2RHRFTHllSkk1UnE5VVF4L0Z0OXo5eTZyU2ROeEVSRVJFUjBWWmtjM2tjUG5vTTJwUy9KRW04N25NNlVjZE9SRVJFUkxRVldxZUlraEQxc0lwNlZNVnlmZEg4WFVHNXRvQllSNmdPWGtPU0ppam02dEpQSGNwZnJXdVV2NTNWVy9mdStrY0pPMXA3SEdyOStrbWRLamlGZENXOFNOKzVYQXIrY0hMTGM4MFVtNW1sSzZrUXJ5MThCZmw2SHJYY0RBSTNRQ0U3Z0Z4UXhFQnVHQmsvQjg4TlFFUkVOQWZ0U3diZVBvMXFCdkJ5VUMwRkdSVzBEVEx5SHRGT0xUWmZWcGNjRk9YYktXeHZsb2JuQW5uekZXdS92YVJVS1FXMWc0SksrN1JlYmloNEpiTTcwY01PcHFoNTVyaDgwQnl6bnRZT3RpSFB4eHkzeGJ5R1BxSGxKNXBLYWxvMzVOWjhSdUtHL0hURGR4cXBtVDk4YzJ4N05haUNmSllpdGU1UHdBMlR6MG5Oekc5S3FieVV1TjVRV21XMHRxV3ZOYVZ5NXZITU1yVFg3bFp5Wm41ZW9uVy8rY3NGRThjMnpaRlBwN2xHeUxybUhPc29MNEVPMU9yaFlLNGlsR3V1SnN6anJxdnM1eGk5ekZ3emxkSVkzekRmTEZNZ0lpSWlJcm9GQTR5SWlIcFltR2hjTFRWUWJpWm9wOEFVeStVYmkvQ1RwaWxTYWEyWVdZS0ViSWlRZS9kWGtOd3ZSVHErbjlyT3FXaFQ3bEpxS3FHVlRtOTJlTzFVNDBvSk1YSTlENjRwMHdzbGZFbUNtTmpCbG1qWGtQT1phMHBSNWZ5V21oTFZaV3pPOWVVUUM0MFlSRVJFUkxSMWZYMTlkcUxkbzM5Z0FMdEJGRVUyOEpob094U0xSWGplK3RVeGxVb0ZNOU9UTnJ6b1hwK2UxSlF4U1RDM2xISGRTc0tMOW8zc0J4RVJFUkVSMFZiSUlFVER3L3RBUkVSRVJMU2JTTnZNSkkzUldBMHZ1bEVhdDdlejVldG94bldFK1VWbzZWdzgzSWwyWEJxdGRsdlhVc1N2Rlc0MExzSUxmZVRtQWdSZUZ2djdENk12TjRTc2hCZDVBVHQzRUJHUlZWWHdISTJvcnRDVXI1d2MwRktBa1cvK0x6MG14dUJVWldqcENhUkYrVVlNMFZhUytaZVJvQTc1L2tyQkFLTjJjY3d2blR6UVNLSE1idFE5SFdBMEJCVkpjTkdnbHNOb2V3SmZQR2liR0RrS0d6MlRSbEJobkNJeW41Rm9XU0ZwcXUvODBEUEhkTFpwOWtPcWRFRStQd20yZHB6cmxYbW9pdEwyTTcwSSsvbUdMRkRGTEZmU3FVMmc0WmlmenptR0YyMk5XZzBtY2x5c2RrcVRjTGs3dCtrZTJjWmFSYjZiakp1anR3UWlJaUlpb2x1d2pKdUlxQWRGcWNZM3B5czRPMS9IYkMxQ25MWTNSS2RZbjhlQmhmUHdveG82d2ZFOFU1cnRJcHZMMlE1YVlYUHJTVWFTSTlSc05FeEIwVXFBa3N4ZkdtSzIyMG9Ja3lsRXpPWE5zbXZVYXhVUTBlNFJtUE9hbk4rOGdRY3hOM0FNbS9IcTNNcTVjYllXd2pmbm5NRU1mM0lURVJFUjBkNVJMblZubTRSS1pSbFZNNzMwd3A5aWFXRWVYM24yYzVpNlBnR2k3VEE0dk0rV2NZMk9IYkszY3pQVE54OWJYRmpBcFF2bmNlRGdJUndZTzdqdTY2dVZzbm5PRzNkOXZvNmZPSW5Cb1dFUUVSRVJFUkVSRVJFUkVmV3lwZW9jb3FTSlN6T3ZvaDVXTUxWNEJXSFN3R0psRm5FYTJTQ2pabFJIcWhPRWNRaHRiaE92QWFqdUdZQlNFaDYwK2Q5U1k4Yit1M1psQ1k2NTAvTXk4TjNBVGhrdkI4LzFjWERvSWVTQ0lnNFBINGZyZURnMjhqYnpYQmUrRjRDSWlQYU9tb0ozRHJwdkVDcDlFTHBjZ01wbU5GcjZNdkRONitYMkhhbENaUDYvQUN4WG9ZTlpCUnRvMUk1aHNnT29aREJGdk9Sb3o4eXovUjAwOWlDMWtuTVRxbDJXaEdLT1VkYzN4MmhCYVJWcWV3emZKSDlLVDV1Q1JwelRLaGt4NjJlTzUzUWZWTUdSa2NSM2pneVBYblNWMG9IV2tpcGsvdnVkeFRHcjRhUm04U010d1VVcnc3K0hTbFhOem1sTzZMUy9ZVDZuMVMwdXZleG8yVjVwaDdaQ21HaEVUQmVqOXBHdmpzdm1rRFZYTkppK2NoVWMrWnVJaUlpSWJzUGUxRVJFUFVnQ2l4WWJNY3BOVXltYnRMOEMxazFDWktNS0hOMk9JdXU3U2FXc2RqUmNWNzZtMmxXV29WZEdxVmNybzlhN3lrRW5ySldkdXFZWVV5V0ovYmVNOUVORXU0TXk1d2s1djhsNWJyUGsvQ3RXenI4czdTY2lJaUlpNmdaSkhOdGc0K25KNjVpWm5zVExMMzROeTJVT0FFWGJJd2hXQnNQTVpyT0k0OXZMdXFLd2FjTzFrdVRlNVd4aEdKcm5WTzU2VHFIWWgyd3VEeUlpSWlJaUlpSWlJaUtpWGliaFJXSGN3Rng1RXBWbUNlUHo1MjFnMGR6eTVMMWYxSmttb3B1M21rQVFKblg3ejdCV3Yrc3BFbERrT1Q2a3ozd3hNNEQrM0JBQ0wyT0RtWGEyWHo4UkVlMEU2Zm13ck9BSEdqSWNkSnpUYUxsVGdpTVpSc2FnK1JZS3plc1Q2Q2hWc01OQXQ2c25pQWRvWHlGMVpQbjRkZFUyam0yRXJuZFZRM1JYd1Fsa1BIT3NmM3pKejdNTVZKbzF4OHVRVmxIT3JHTk9EcUdkN1c0alI2M3Z5RUtvdDByZytzN0JYZGVRbGgvUnJGSnAzSWFGVDI2ZmZkdWxlbVZBZUtKMk1JZXE5SktwbWorcnYvclR6elpBUkVSRVJIUUhCaGdSRWZXZ2FwVGdOOC9OWWFIZTNpRGpiTE9NZ2RvTUJpdFR5Sm0vTzBrcVc0Tk1kaVZzeVBVUWhrMUU0ZVlEUmRha1NXSTdoY204TTJaeVRQRzc0N1MvcHRwZG5hOTBKSk5Pa3ZWNkRVVFUvVnhUTlNmbnQzNXpyanV3ZUFHbC9DZ2FtWDVzeGovNzFnMGNHOGpnWTJjT2dJaUlpSWlJdHBlRXhFeE9qT1BjMlZmd3hjLytBVjU1K1NVN3JYbnE2V2ZzN1l2UFB3ZnFQQ21MR2I5eUNhV2xSZXhsejN6d1EzWmIvTTZueDIvZUo5dEV0bzNjZnk4M3BxZngzTE9mdSt2K00wODhpVXcyQ3lJaUlpSWlJaUlpSWlLaVhoQ25FVzRzaldPMmZCMlhabDdGeE1JRlhGKzRhTU9LMHQzVmYzOVRvamhFaEJCbnIzM04vdnVGQzUrOStkaFFZUlJIOXAzQWdZRUh6SFFVeDBjZlJ6RTdnS3hmWUxnUkVWR1BtM2QwWmg3SUhOTzZ1bCtyNnI0VS9ZRlNMZmNIRE16L3g3UTZZQ2E4RFhhWTZaS1pHb3ZRU2F5Z0IxUGx1VXE1YURHUUpkQUloNEhGc2xLRDVyVjdycCtpaDk3c25HbldLUzZZbnllK3RpRllHMXJGdk1hdzNMNVB2MlgvbkdEMU5vZGR5aXo0Z1BtWURMd0xLb1JXelJmTloxUkNpR1pWZDZZRU1jQ0kyc2tjU2hYejMxOVZPcDBBRVJFUkVkRTZHR0JFUk5SallsTzZGQ2NhOVNpMWY3ZVRveE40U1JOTzJxNjgvWTJSeXRXMVNlZzJsSjdKUENRY1NVS0c1TzlPVmVEZVhIWkgyWklhelpJL29sMUJ6blAyZktjM2Y3NnJtdk53bVBJelQwUkVSRVMwWGVRNlgwZ1FqQVFZVFUxT1lHRit6djQ3aWlKemJlNmd2My9BUG1mLzZDakFvZisyamV5Yk9JNXU3cU85eWc4eVpybzlvRHRKWWh2Y25TUjNYMy9LWXhMR0xiZnJ5V2F6eUdSM2JacytJaUlpSWlJaUlpSWlJdHJEMXRwU2hrbkQzdGFiVlNScGhGSnREcFZtR1kyb2lpZ0p6ZlAyZHQzQ21pUTE5UWx4QTQyd2ltcWpoS1hhTEdLemZZcTVHSTZwODhwbGl1YS9Ec09NaUloNm1OUW9tOXBtSjFFcWliVjJQS1cyTklxemhuWWNPSTR2ZjVsL3V0TG5BWERSSXZubVVYcWx1OFJlNU9qT3RENlJuYnZEbTFTYmRVdk1RbmpZdzgzaHphckhldVVXaWZuY1FhM3NGdk1MVlNWYS9xWE1SdExZM2g1V1JEdExwYnBtanY0SVJFUkVSRVRyWUlBUkVWR1BtYTZHbUtxRStNcEVHZTJXYnl6aDhPeXJ5RFhiUCs5N2tZQWhKOGpZVG9hZTV5TnNObXdueEsyS3dpYmlLRVEybDRmdkIzQmN0KzBWdHpJL3o4N2JzOHN2bmRHaU1BUVJkYisxODEzVHk2T1dIY0ptZk9iQ0F0NTlzSWlQdjJNTVJFUkVSRVI3UmYvQUFIWktwYklNbmFiNDVLLytDa3BMaS9qbFQveml6Y2N5MmF3TkwvcVJqL3dFRGg4NWlwLzhtWit6ei9uRDMvMTNvTTZyMTZxWW5MaUc1WElKZTltcDA0OWpjV0grdHZ2bVptZnd4dGxYVVM3ZHZXMGE5VG91WFRpUHFldnJEMXIyMU5QUGdJaUlpSWlJaUlpSWlJaG9ONHFTcGczbHVYampGVlNiWmZ6aHk3K0dWQ2RZcXM2QjdsYXVMOWpwRFh6RC9qdmpaZUU0TGg0OTlDUUc4aVA0bnRNL0JzOE4wSjhiQmhFUjlhWnJDb1ZyU3VOUmpYSy9SblYvcWdlM0VtTGtRL1VCdW04RUt3TTFZNU1wTllHR0dsSEtuVUs2cFVDbDNVb2lCTnM5N0pCc3lING9KNEhzMzUwSmMvU0FaaEdZOXpYMlFRNlhQYW9HWEkvTU1iN3NhTGNKbmFrNnF0QTAyeU0ybTZnQzdTZm1NOGtVRjlwVHRLNDVqdjVzQ0RSQVJFUkVSTFFPQmhnUkVmV1ltV3FFbVZyN2k4QWNVMUVza3hjMzdlMTJrekFnQ1ROU3BzSlZPZW5LNkR0NmExSHVNbzgwVFcwZ2t1KzRxKytEam5DVVl5dUxKU2hKUmdUUzZSNk9vU2ZhQlpTcGhKUHpuWnRFOXB5bmxmbnN0bmlDaU0zbnZCR25tRFhuWk45VkdNendwemNSRVJFUjliNzFRbGc2cmRGb29ObW80OEw1Y3pZb1ovektKUnRPSk9RNlBKZkxZM1RzSUE2TUhjS0R4NDdidjROTUJrVGJyVkFzMm9Eclc0VmhhTU8zb2p2dUYwbVMyTWNhOWRvZDgrbUQ1L0VhazRpb1Y5UXFaU1J4aEZwNUNVa1VJV3pVUU5TTmNuMERjSDBmdVdJL1hNZER0bEFFRVJFUkVSRVIwVVpKZTAyTkZIRVNvZEpZd25KakViWG1NcWFXcnFBZVZoQWxJZEkwQVcxTVl0dWhtcktsWnRtMlQ3MHkrenA4TDRQaHdnSGtnb0taaXZEZHdJWWFFUkZSYjZsQnk4ak42RmZtcTFQck5GQnFSeXVQemFJb0YvQWRtS0pqck1RZ3NhZkUxam5tcDVNam03SkQvVnRvaFY3cG1SUW5TdW5ZL0dGK2picUorWXpGV0RtT1RhMWROakU3b201MlNWTXBQOVJ3UXJOcjB0WGNyNTJKbDJxTm5DY1NyZVZJNHRGRVc3V2dsWnFXOEtKTWtnbEJSRVJFUkxRT3RuQW5JdW94ejQ2WFVHNjJ0eEpYbVZyT1RGUkR2bGxDZjMwV084RjFQVHRKNEpDRUdVbW5ybllVYkVzSFI1bWY1L3RZR1lDZy9XVnlFcnprQkFHVXVaWE9aZktlOFE2RVFCSFJ4Z1Z4M1U2NXNHelBmMDAvRDkxaS9WNDlUbTJvbkp5WEh4ekk0ajBIMlptRGlJaUlpS2dUeHE5Y3hNejBGUDcrMy8xYldGeVl0d0ZHYXdZR0JuSGs2REY4MzRkL0dCLzY4Si9GUXlkT29sanNBOUZPT0g3aVVkd3d4K3F0bHN3eEsxT2xVcm5yK2ZWNkRaY3ZuTWZjN0kwNzVuTVNBNE5ESUNLaTNuRDl3bXVvTEMzZ0cxLzRQZFNXUzVpZHVBS2liblRxM2QrTjR1QXdIbm5pdlJnWU9ZQkR4eDhGRVJFUkVSRVIwVWJKd0kvTnVJN3BwWEdjbTN6UlR0TkxWOUdNNmtqMWJ1ajYzVjNpWktXLzhQbXBsKzN0Tnk0L2E0T0xEZzgvakJOajc4QWpZMC9nd01BRDZNOE5nNGlJZXNzMWhZSkVwMlNWV3NvcFlGUmpFRHZJQWJJeTViUXl5NlFoUS9jd2tuQ0xOT0FwbTFURkxLZ08wMUN4T1daTHl4cnBzdEs2cE5EZkFISUxTcStGRXgzQUxoZWJqMlZpUDZyZ2FHKzBKZVkwLzBYenRYUGxsejcyN0RTSWlJaUlpTzZCQVVaRVJEM210Ym1hRGMxb0p5ZU5NVnkraG1KakFWdVZKb25OS0UvaTJBWUhPYTdiMHV0ZHo3ZEJRRGZuazJ3OUNFam1FemFiWnI0S21VelczaWZMMW02eTNDNGtpTW1IeExRbk1scVFacGt5VVRjcm1QT2VuUDltQjQ4aGRGci82VnlKRXJ3Mlc0UHZ5am1GQVVaRVJFUkVSTzEwWTNyU0JoZDk1WXYvQVcrK2NSYlRVNU5vMUd2Mk1kLzNjZXpoUjJ6UXk5UFBmQkFuVHoyRzBiR0RDQUtPTXJzVEhOZERKcHUxd2M1N21SeURNbnEwYkFzcDI0cWk2T1pqNWRLaVBhWkg5aDh3WlVjcjVXVTYxV2hJRVBZdHp4T0R3L3V3ZjNUWHQ1RWpJdHF6ZEpyYU9wS3BLK2N4ZmVWTlRGdzRpM3Fsak5Mc3RCMjhnYWhielYyL2l2TDhEQnJWQ29aR0Q2RTBONDJEeDA5aGNJUy9TNGlJaUlpSWlPaXRYWms5aTFwekdWZm56bUc1dm9qcDBqVXNWbWNSSlNHYlVMYVJiTStGeWcxY21QNjJ2WDFnM3lNWUtvemFVS044VUVRdVlQczFJcUplTXFWME5tZXFIZkpBM2RWd2NsQTdHazRTS0pYa3RVNURaZnNxdHI4ekJtMDM1V3ZJRU9FOXN5OVRRQklnMHlXbGRXeldxd0prRTYzZHVsTDVTRUUzelM5VFUxUG5Td0JYTC8xRVRWSmQxU2w4TU1DSXRzaDhUUDRVcWJvS0lpSWlJcUszd0FBaklxSWVjM2F1aGpodGIzR1pveE1NTDE5RHZyR0lyVXJUMU9iQVMvQ1E0N2d0QnhpdGRIVHpFRWV4SFpHbkhRRkdJZ3diTnJSb0xjQ29FeHpIa2YvQTlWeFRvS21SUnFrTlR5S2k3bFZzekp0ellJcWw0a0dFZmdHdHFwblB1UVRMN2MvN0lDSWlJaUtpOXBMd29sZGVmZ24vNFE5L0Y5OTQ0VTl2ZTh6emZSdGE5SzczdkJkLy9zZC95Z2JHWktYcEh1MEl6NVQveVBaMzkzaUEwWUd4UXphd1FyWkZHRGJ2Q0RCYXNzZjAwUEMrbXdGR0VuYlViRFJ1ZTU2UTU4aThpSWhvZDVJUXV6Z0tNZkhtYS9qbXM1L0J3dlFFd2tZZFJOMXVibktsUGZMa3BYTVlIanVDNWFVNTVQc0hHV0JFUkVSRVJFUkU5M1ZsOW5YTVY2Ynh3b1hQSWs0alJIRUlhcjg0aVd4d2tVeGlyanlKa2Y1RHlBVUZxT0lZQTR5SWlIck1qRUkyMERvZGhWcktLSGc1dmJQaEpCbU5wS0JVc2d6dHhFQnJuVVNvNjhnTzlCU1UwMFBkWGN5cWhDbVF6RU9uRGJOcU54eWRUUUNuYVhQQWVsZWNvcHBvTGVlSEFSQnRnVXJTcitrVVYwQkVSRVJFOUJZWVlFUkUxQ011TE5SUk55VkxDL1ZZa3NIYnhqVVZtbjdjeEZEbHV2bTdYWlhHTW5wOEEvNXFwelVsb1Q0dEJoa0ZtUUF5OUk0RUdFa0lrRFQ0M3dvSlZoTE5SdDJHS2dWQjU4cnZQVCt3Nnl2TExTTXR4M0VFSXVwTytjWVNNbEhObkFmcjlueVl1SzBOQ2xLTlVseGNyT1Bob2F3NVAwY29CQzR5cmdNaUlpSWlvbDdWUDlENXRpNkxDL040NCt3citPcVhQby9uekhUNXd2bmJIbi82bVEraXI3OGZQL1dYL3hvR2gvY2hsOCtiNjNBV2hlK2tRckVQUjQ0ZXcvVFVkZXgxRXVMMHlLblRtSjI1Z2F1WEx0eThmM0ZoRGhQamwvSElvMis3ZVYrMXNveno1ODdpeHZUa2JmT1E4S0xEWm5zU0VkSHVkT1BhUlp4LzZVOXc3ZnlyS00zZHNPRjJSTHROWldrZTQrZStoZjdoVWRUS1Mzam9zWGNoVytnRDdZeGFyWXA2clliUzBvS3BkOXhhbmVsNmhvYUg3U0F6UThNaklDSWlJaUlpMm9ocXM0eG1YTWRMbDc2SUtHN2c3UFd2MjNDZDBQek5RUiszeit6eWRaVHJDNmcyU3Nobit2Q09CLzhmOE4wQWJ6djhiaEFSVVc5SWxGS1h0S21TVnpwMU5LbzV3TTlBQmRnQkJhVWJTTkdjZFRBSXhRQ2ozYzZCMGptTjFOVkt0OUIwdnF1RVdqZWJEaXBsYzNqV2dHelZUTEZDV2pIcmxpZ282UjIxRjM2Wlpsd2xLWmJlM2xoYjZnUUYvYkk1RVZUaUFOTnhyYmdBSWlJaUlxSzN3RjRiUkVROVlxRVJZOUZNdGJpZDhVVlM4SmpDVFNNYjR0RXVVZ0dkckliMlNLY3RWN1Zlb3VsNXZyMTFuSVlOQVVxeHhjYTRxNVhpY1J6RGxiODdHR0JrdzVyTTVKcjNzc0ZMRERBaTZsb1NYZ1F6QlVuVG5nOVRjM3JRTFp5eUVuTSttYTEvNS95YzhSeFRDUUFpSWlJaUl0cUNNR3ppMG9YemVPMlZsL0dORi83MHJzZVBuemlKb2VGOU5zaUl1b01mQkhhZjVISTlQV2pkaGtpWmxnUVFSZVk0dm5yTC9kVktCWXNMQzBodUNlbVdjcXFaNlVtVWx4WnZtNGNFUWcyYjdVbEVSTHRUdGJTRVM2KytpS1haS2RTbHlUVFJMaFEyNmxpWXZvNlpheGR0dmRmQll5Y1pZTFNEb2pDMDRaY0xjN04yRUpsMjh6d1gyV3pPL0tZSEVSRVJFUkhSaGtoUVViMVp3UnVUMzBDMVdjTDFoWXVnN2JkY1g4UXl6RlJmZ09PNEdPazdoRnhRWklBUkVWRVBNYlhMYXQ3Um1WQWpHbFZZOWdBbnMwTVpKVm10SXFYUThKU1dTbThmdEt2SmNMMGVGSGJ6c0wycFFsd0ZhdlBtOEt3b29BVHRSYnMwakdrclhFZm5YTDJyZHlYdE1LM1V0TmE0RWJ0WStwVy84dnMxRUJFUkVSRzlCUVlZRVJIMWlLOWVMK1B5VXZzYnBCNmVmUVYrM0VRbnBFbU1XcTJDSU1naWc2eXRJRlZPYXlXQ3VYekJkdVpLNnhMY3BNMDh0eGJnRkVlaG1aK3llVWF1NXlLVHlhSlRwS0d2aERtbGFXb0RsR0lHR1JGMXJmMUxGNUZ2TEdCaTVISEVYdXZuaGF1bEJ2N3QyVm44d0lsaG5ON0hEcnRFUkVSRTFMdktwUkk2WlMyNDZKV1hYOEl2L3QyL2hVYTlmdHZqRDUwNGFjb1lBdnczZi90L0FWRzNrbVAwMU9uSGJWRFJ0Nzd4NHMzN2x4Ym1NVGt4YnN1NTFsUXFGWnc3KzRvNTFtOXYrM1A2OGJmamlhZWVCaEVSN1M1eEdHTHF5bmxjZS9OVlRMejUyc29BQjBTNzNJV1h2NFlycjMwVEQ3N3RDZVNLL2NpWWVqdmFmcGN1bnNlM1hub0JuLzdrdjhMVTVBVGF6ZmQ4T3lqTm9TTkhNVG8yaHZjKzh6MzJOKzNKMDJlUXkrWGcrenN5b0RzUkVSRVJFWFdoeTdObmNYWDJkYngyN1FWTWxhNmcydWhjdlJGdFhDaHRnQlh3N05sL0I5ZnhjRzd5UlR3NGNncnZmZVFIa0EzeXlQcThuaWNpMnUyV0ZmeHZJUjA4Q05VOGFLcWZCNkR5R1kxdExiakxhVDJVaFJySWFqZzE4NzBUZ3paTEtiaG1PKzd6b1hjc2RNYlRPcFBWYXAramRNYitrTmdsWmhWbUt5b05yZ01ETVhTdW9kUkJyYldUbUhYUWV6QzhTRGhLNWZib3F0UFdOWlZTelVTbm4vU1J2dkxxZVN5QmlJaUlpT2crR0dCRVJOUWpva1NqR20wdHZHYzlYaExDTlZNblNIZ1A5TXF0L1hzVEhNZXhreWtVZ1c3RGFBR3lIRW9LSjNWcXBzNlc5OG95cjAwN05OQUJFVzJRazhiMmZMaFpvVGxITDV0emRCanowMDVFUkVSRXRCVlJHTnBKd2w3dUpNRXdRWkRCMFBBSWlMcVpiNDVUMTNWdnV5OUowOXZDaTliSThaN2NFWEFobmNlejJjNkZiaE1SVWVmWVFSUldKNkplc0hZOFIyRnowM1Y5dEhWeEZLRmVxNkcwdElpNW1Sdm9CTS84QnBVNjJUUk5zRnd1b2RGb1FLY3A5enNSRVJFUkVkMG1Uc3oxU1ZoRnBibUVjbTBlMUIwMFZ0cnF5cjZSQUtPUzJUZjFxSXBVSjd5dUl5THFJYUZTVG1STzY2WjJPVTMxOW5kUFVDdERXZHZockJtVzBoYXViRS9zRU9ubElzdUFsZHRkdy95Nk1hWFlLbWtvYmY1V1RpamJjSGV0UXR2SnZuVFlZNGsyUnd0SHAzVnpJREc4aUlpSWlJZzJoQUZHUkVTN1hEMUtFWmtTNXVjbmwvSDFxUXJhN2ZEY2ExQzYvY0ZJdHdxYkRkdXdPWmN2cmpSK2RWMGI2ck1SOGp6UDg5SFhQNGd3RE5GczFHekRXWjF1dm9CTndvdGttZHpFdDRYbm51L0RkVHYzbFZrbzlwbGxUbEd0bEcxbE1FZGRKdW8rSTZVclNCMFAxL2FmUVl6V080bGVMalV4L2ZvY25oZ3Q0SWtESExHS2lJaUlpR2d6bHN0bC9QSW5maEh6Y3pQclB2NzMvc0UveHRpaEl5RHFacGxzRnM5ODhFTzJ3emZ3cVp2M1Q0eGZ0V0ZGVXI0bHhxOWN3dVRFdU8yRXZ1YkkwUWR0UU5lQnNVTVlHQndDRVJIdExsSFl3TGtYdm95Wmljc2c2alZYejMwTHRlVWx2UE9EUHdUcVRSSzJLYjlSWlhyeCthOWlkT3lnL1YzNmtZOStERSsrNTcxNDlQVGpObENXaUlpSWlJajJGbWxyMllocW1GeThqTTk4ODE5aW9YTERUdFM5a2pURzlZV0xtRjY2Z3ErOStVYzRjL1Q5ZUx1WmpvOCtqbUoyQUVSRXRMdE5LdVFtbGM0ZDA3cTZYNnZxL2hTRG5tU1hiS01SclpwWklMMXFsZ08wV2NvMSs5TGRnZEFaMjM5R0pnWFBMRVBYOXp1dEtMM2NBSnBuVlRvc0lWNDE0QUNJcUYyZU5WZDlmNHdFejMvaVAzdDJBa1JFUkVSRUc4QUFJeUtpWGE0YXBWaHF4b2lTOWhaT2VuRURqazdnbU1wS3RRMGpyTmpnbmpTQkREVHZPeXRsNUJzUE1aTFhBNDZqYmdZTlNTVnJHNWJLaGdtbHJtTXp4MlY1VkFmVDEyWFpKY2hJSm5CVUc2S3U0a2lRbXptdkJIRWQycHdQUXIvRkVDTHprWTVUamVVd3dXd3R3bURXdlhtdUl5SWlJaUtpalpQd29uTHA5Z0dkY3ZtOG1RcklGd3JJWmxzUEhDWGFib1ZpRWJuYzdjZXFoSEpMV0ZFY1IvYmZqVWJkQm43ZlNqcUVTeEMyNjdvZ0lxTGRTYzczZDU3ZmlYcEJFa1dJZVd4M0pRblFsS0NoemFqWGEwaE1YYWxjZzhWUmROdGpFcnhacVN4amVuSUM1OCs5aHNNUFBJaitBZGNPVmtORVJFUkVSSHREcWhNenBaaFl1SURaOGlUcVlRVlJFb0oyQ1MzdGJNMDFYMzBCVTB1WE1Wd1l0ZnMwbittSDUvRGFqb2hvdDJzcTdaU2h2Q0h6bGEyMFRsMmx0dTNrSGtBbEdXMitWRHJYN1lJNnlBWVltZDhKYnRkMlo5R0dTaHJtR0RlL1BKMWxzNmdOd0c4cXBUbzdiUHZ1NWNoTzVlZVJXaE9iejFyRlhEUE1tSU5uQW03Q1NrQWlJaUlpMmpDV0xoTVI3WEt2elZYeDVtSURTODBFN1RSWW5VSW1xdGxwdXpUcU5Sc1E1THI5TmpESWJhR0JxN3pPODN3NzFXdFY2SFFsRUdrcmtqaTJreWxBaC9ZMVBEL29TSURSeWpxN3lCZUt0ckd2akVva0lVWTZaUkVxVWJmdzQ0YTkzVmNlUnlQb3gvVHd5VlplanRpY1IrSlk0NVdaS3JLZWd3OGNIY0JvbmdGR1JFUkVSTlI3K2djNk56S3JYTzgvLzl5WDdyci9rVk9QNFlHangzRHc4RkhzRzlrUG9tNG1JVVRIVHp5S2ZmdkhicnQvL01wbDg5L0x0aXhLekV4UFlXRmgvcmJuakk0ZE1xODlpV3lPQTFVU0VlMUdTUnhoWVhvQ3RmSWlpSHBOdlZKR1pXa0IxSDBrdk9pakgvczROdVBTaFRkUXJWVHdoYzkrNXE0QW95WHpXMVdtMy96MWYyRkROczg4OGFTdDd4d1lIQUlSRVJFUkVlME56YWh1dzI5KzY0VmZ0bi9QTFUrQ2RvOUVKNmE4S3NHNTZ5L2FTZmJoZ1lHamVPTFlkelBBaUlpb0IweEI1YWFVem8wb3RaU0RTdlBBTUxiSlBxQXhDQldkaCs0RDdUb1NYalFBaFc1dGxTRGhSYkZDOVlaQ1psSWh1d3lkYnpLYzV5MzVya0tVY29CMWFvV2VNLzk1dzV3S3Z2aC8vZlRuUHcwaUlpSWlvaGF3ZEptSWFKZWJxb1I0YzZHT01HbHYyRTIydVd5bU1yYWJscENQS0lKeVhEaXVoODNrQmJubWRWSnlHa2FwbmQ5V3ljaWkydnhQNXF2TkFuVWl4R2lONnpydy9RQnhIQ0ZtZ0JGUjE4bVo4K0pXVGlzenRRaVhseHA0MytGK0VCRVJFUkgxb25LcGhFNG9sNWJzdEo1aXNZaWg0V0hiV1phNmt3Uk9GOHgrOG9OZzNjZkRzQW5IbEFWNTN0NnBzc2hrczdZemVhV3lqS3FaMXBUTWNWNVltTGZoUmRKWi9GWUZlNnp2V3luN0lpSWlJaUxhZ0w3K0FUeDYrbkZzeHI3OW8yalU2OGpsQ3lndExlTGIzL2c2R28yNi9YdU4vRnRjdTNMSi9uNTk1MVBmQlNJaUlpSWk2bTFKR3R2MmxHZXZ2NEJHV0VXdFdiYjMwZTQyTWY4bUtvMFNEZzRlUXpFM2lPSENBUkFSMGU0M3ArRDdTSEZNdTZHQ2R0UTI5Q1AwVFhXNGtxNFhxLzl1N3pEZDNjY3hxN2k2VVh1aTBZcXNUMWFqR1dpN1BobDBpUlRRRllYSUhNZ29RL3RMU3JzeVBIR3ZIMS90WWo3ODBqa3AxZHFjQjJTMGVhSjE2VlRCaWMzMTNpUzAva0lzSTdFUkVSRVJFYldJcmR5SmlIYTVDNHQxZlBsYUNmUDFDTzFVck0raHZ6YUxuZEJzTm15bnRTQ1RzVUVoR3cwTVdudWViNHJacGNOYmtpWklrbmpMSVVZU0pvUjRwYk9kZkhHNkhlcE1KOHN2SGREY25JZEd2WVlranRzU3dFUkU3VE5RbVRMbnBocXVZbk91bEpxb1JpbCs2T0ZoSE80TFFFUkVSRVJFR3pONS9acVpKdFo5YkdoNEJFZU9Qc1FBb3k2V3pXYXdiMlFVK1h4aDNjZnJ0Wm90YnlrVzk4NEFqSU9EZzNqazFHbU0yNDdlM3drd21qTEhlWm9rdUQ1K0JUUFR0NDlXTGVGRlI0NGVRemFYQnhFUkVSSFJSa2lBMGZkKy93OWhLOHJsRXVabWJ1Qi8vSy8rdWcwdmV1WGxsMjQrSnFGRk1uMzkrYTlpWUhDSUFVWkVSRVJFUkh0QW5FUklkWUxQdmZKdmJYRFJZblZuMnBsU2U1MmIvSWE5SFJzNGl1SGlHQU9NaUloNnhFVkhGNlNIeFFPSkxqbXdvVUpGZEppdlVmQ3hrbndqUFNIcTZHMW1QYU5ncGN0SFR6UmFNU3NSRHdHTGVTaHBtTkExQVVZSnRKNHhoMU1GMmgxM09uOGM5eExYbkFTVXRsT29sT05xNks3WnI5UmRsRmFwVnJxdW9MN3BxUFQvWEFZYUlDSWlJaUpxRVFPTWlJaDJxVkl6d1d3MXhGUTF3a0k5UnB5MkorakdqK3R3a3hpRjVoSUs5UVhzaERSTmJYQ1JoUGc0cHBnOENLUjh6QlNCYkN6SENNcHhJRStWa2V3VE02OUdyWXAyQ0p0TlJGRmtSeGtWbmVnWUtTRkdFbHJrKzRIOEEyR2pZYllIYytHSnVrVytXWUtqVTJTYnkwZ2RGNkhmV3FmUjJWcUVjalBHYkYzTzNSR0djejZJaUlpSWlPais2cWFNb0Y1Zi8vcCtjSGdmRGg4OVpzc1FxRHRKS0hRdW43ZWgwK3VaR0wrTVl0L0FuZ293Nmg4Y3NnRkdFbDRrSVVackZoZm16UFp5N1RhWm03MXgyMnNPakIzRVNmT2FyQ256SWlJaUlpTGFMcmxjRHNQN1J2QlRmL212NGZ5NTF6QTVjUTIxV3NVR2thNzU2cGMrWjRNMi8rb3YvRTBRRVJFUkVWRnZXZ3N1ZXY3TlAwU3B2b0NGNmd3MDJ6YjJuQmN2ZndFRHVYM295dzBobituRHdjRmpJQ0tpM1d2dG0vcTgwcmtpb0IvUUtsUWFqbEtkNzA5NFdLTVVLNlV1US9lamg1bmErK1dzN2IyQ25xaklOd2VHTXdBVitOQWVzTUVPUEIyU0FnMXRiaTZyTk5jMEN6T25WQzdaNllYYXBaU0wySFZSMWFuT0psMFVURVZkcGFZVjN0VFF2K0ZDbmJ0K2RhYUcxODd5Z28rSWlJaUlXc1lBSXlLaVhhcVpKSml0eHlnM0U5VGlGTzNpcFJIOHBJRWdxaUVUMTdCVHRFNFJSU0hjMUZzTk1KS0FwbzJWTmFyVnBDUFg4K0ZxamFhcXJjNXpheUZQY1J5dHpGdDNkcFI3ZVE4YjNHUnU0ekMwMjJLcnkwNUU3UkhFZFdqbElFanFpTFhmY29CUk9Wd3B3NVVRSXpsM0Q0T0lpSWlJaURZaWlTTEVabHBQc1ZqRThQQSt1QzZMdTd1VjR6aTJmT2RlSVZPTEN3dEkwNzFWOXBITjVuQmc3QkFLZDRRMlNTZndhcVZpdDBtNXRIVGJZd09Ed3hnMXI4a3d3SWlJaUlpSXRwRU12TkkvTUlpbm4vbWcvZjM2bThWL2FldE5idzB3dW56eGd2M2RUMFJFUkVSRXZVdkNpNUkweHJXRkM3aStjQkgxNWpLbzkwek1YOEJpWmdaenk1UG9pNGNZWUVSRXRNdXQxY0xQS1IyRUd1a1JyWm95eUxKQzUrdm5oN1JxTkRSYzlIaXhvYWNSZWkzMGRlbDJzcnR5R3A2RG5kOXpacXRLVDZsa0RzaldGWnhsY3h5RE5rVnBwUjJsd2xScEQreWFST3VMektkdXlZUDdSNmxUVy9qVTN6a2Jnb2lJaUlob0U5aWpnNGhvbDVxdFJmalNlQW5YbDV0b3A3N3FEQWFxMHpha1k2Y2xTUUtkcHFoVksvQ0R3RGFPbFlKZHRjR3kzYlZHc3JsY3dRWUExZXRWYkpXZFQ2MXFRNGJ5dG9QWnhwZW5GVEovNWJySVpITTNsMTIyQlJIdFBFY25PTEJ3SHZWZ0FMWHNFRGJqK2NsbFRGVkMvSlYzSGdRUkVSRVJVUy9wSHhqQWJqQXhmaGxYTDE5Q0p5MHV6T0hTaFRmdzVIZTlEM3RkLytBUXpqenhKSjU3OW5QclBuNWplaExwSGl2M0tKcHlwWWRPbk1TcjMvN21iZmZQejgwZ2lTTjc3TlNxSzJWWlVqNDBZTGFoaEJlTmpoMWNEZnNtSWlLNlhWbmxVSGU2TCtUT2R4VUtnWXVCcklkaTBIcGJkMjMrVjQ5cVNOSUV0V2pyOVR4N1Zyb3lxVENGRTRPb1pWSjNXU2dXY2VUb01meklSMzRDTC96Smw4MzBsWnVQMTJvcm44OC9mZTVaREF3TTR2U1pKMEJFUkVSRVJMM2w5Y2tYY1hYMmRWeVpPWXVsMmh5b2QwVkppQytmKzIyTURUeUkvWDJIa2MvMG9aRHBCeEVSN1Y0Vk04V212UDFOUit0K2FIMUlkejVzWjFpcm9ZWXBXblJ0U2Y5S01UVjF0NEtXOENMbCtVQlJTL2pVRG1VeTFhR2JkWVhtTllWTURUcTdLTTMzUVZ2aEtLMXlubkxEeEZRVHhkeWFkQnNacmNLY292VXZRRG16WVRXNk1EdTd5UEFpSWlJaUl0bzBCaGdSRWUxU3RWQmpwaFloYW5OSnJnUVhaY01LbkxRTFdpK2JVazladlNTSjRhWnJYMWtiVDZkWHE4bENydWUxdFJPY0JDdDlad1RSenFUbDM3cnNzaDNzdjgwa1lVWkV0TE5VbXRqelpPeHNmaENIK1hxTXdPVkl4RVJFUkVUVWU4cWxFbmFEU3FXQ2VyMno0YzFoR0tKcTNpYzE1UWg3WFRhYnM1TUU4YXluMldqWTdiV1hCRUZnUTR6azlsYXlMUnBta21PbjBWZzVSajNQTmRzdnV6cmxRRVJFdEo1SStXaXE3aHQ0VmprS3FhbnI4TE0rTXBuV215ZWtPa1VraVR0SlpHcGtlbVAwNGgyUm1xMG5QMHNqMllhc2E2TFdTVjJsNS9uSTVmTTRmT1FvK3ZwdkQ2OU40cFc2NVlXNVdSQVJFUkVSVVc5YXJNN2lSdWthcXMweXdyZ0I2bDFSMHNSY2VSSVpMMmYzZGNabjNRUVIwVzZYbUtMaHlOd3VteW16VFVYRXBzWWlrR0pwYVMzTjhLTGR3VnVacENMQlYycm42bVRNOFpvMmdiaWtkYjdxd0pQamlEVWJXMlIycHl0anJJUG9kdWF6SG12RGhmdHk2RWFWWC9ycnoxWkFSRVJFUkxRRkREQWlJdHBsNGxTakZxVjRmYUdHVDUxcjN5ZzJTaWZ3MGhqRDVYRWNtaitIcnFHMWJmQWE2b2E5RFRKWitMN2YwaXc4ODN3Si9pa1UrMndZVW1PTEhSVFROTEhUY25uSkxFdUFiQzV2Nys5RUlhM3JyaFFSRmdwRkc1eFVxN0lzaUdpbmVXbUV3M092WWJGNEdCTUgzbUVxU1Z5a1Rtcy9xNzk0dFFUUFVmZzd6eHdGRVJFUkVSSGRYN0YvQUgzOWcrcytkdjdjV1RpT2l6TlBQR2tEWHQ1S3BiSnN5eGYrdDcvejMySnk0aHJhNVprUGZzaUd6cno0L0hNMzc1TWdtdExTSXNLd3VlSDVYTHJ3aGcydWVlWGxsOW9heHR3dERvd2R0UHZwMnZnVkxDM00zN3gvL01vbHRPTFNoZk40L3JsbnpYWjZFYnZWNk5naE8zMzkrYS9lZHIvOFc0N2pXN2ZKMFBBK3U5M2tsb2lJYUUzTnllQzZONHBKZHg5ZXl6eUVtc3JZRUtOdTliZmZleFFmZXRzKzdDLzR5SG9iRDNkZmJwYnh5Vy85YzRSSkU1VTZCL3ZjS2hXdUJCbGxMb1J3cXhydVlnTEZuaVBVZ29IQllYdjk4K2E1MTlaOVhIN0h4bkVFSWlJaUlpTHFIZE5MVjNCdThpVzhkT2tMdURyM0JxajNTWHZiZWxqRitOeWIrUFhuL2o3ZS8raWZ4VE9QL2pDSWlHaDNDNVZ5cHFEek5WTlNuRUNYRGtEbCtqUTZPaktDbVhueVdLb1c1NkN6RXc2S29KYllKQ0V6U1lEUGRoVGxQNnJWalFDMnNta1lPMkJKSVpsUU9scUU5aGNWbUtEWVJwNVNRWDlHSGFnb2pVck1nZGpJcXBrcGNyWCtjUTFuK2hNLy9SOWVCaEVSRVJGUkd6REFpSWhvbDRtU0ZOVW9SWmkwdHdqU1NSTjRTUk51bDNhT2t3cFJtYUJUMjRIUGNUYmV1SDJOQkF5WmNuYzcycTlFc052NXRXR1paSGxXNXQzWmxIbjdIbTFhZGlMYU9rZXZuRGUxbXpHVlFxMzlyRFpuRHhudzJwN1BSY0Z2L1p4R1JFUkVSTFNYQkVGZ0p0OWNGenMyN1BqVzYrSW9iS0phV1Y0TkhGNi96RUR1bDJsdVpocHhuTmhRSVpuV201ODhyOVVPdDc1WnZqc0RoMlFlRW1vVWhwSDVPNGJuM2Z1NlFRS1gweVRCL056czZycWtkbjE2ald5RFREWjcxN2FRZFc0Mm14c3FZNUhubGt0TFdGeVlRNk5ldzI0bjRkVitrTGw1RERRYjlYczhKNERqY2l3OElpSmEwVkFaMU0xVWRiSUlsVy9LSngxVDRyaHpJK0Z1UkRQUldHN0dOc0JvbzFLcEV6TGxzSW1PN2QrMGRWb09Fek9sR2ZPYkt6YmwzSjZ5dlI1VXpIb24yaGpIMUZYSzczbjVqWHF2NnpNWmxJV0lpSWlJaUhhL3RkLzZZUnlpRmxZUUpRd1czbXUwS1krSjB3aGgxRURkSEFPK0c4QnpPNXB6UVVSRTJ5QXhKY1dScVpRM3hmWTZOaWQ3VHpwWWRKQm5TaEw5VzJveGVyRTB1bE0xTkRKZngyeXd0TU5WUUd1emQxZDZxMnhyaFpPVU1NdHQwN3h2Wk43YVZGM0lPQXpkWGVtMUswbGJIQzAzZXUxM3Z1cDBCeWpxVHZJalh5a3pvV3orTG1udGhhWTJsaGQ3UkVSRVJOUTJEREFpSXRwbGxwb0pQbk54RVMvZmFHOEhyWHh6Q1FjV0x5RFhYRVEzc3AwUUpldGZPaUs2SVhMNW9tMGd1MUZTdGlhZHdkelZqb3pTU1RFS3QxYkdJcDNLUXIzU3VTNHc4dzR5R1hTSzV3ZTJRVUFlSzUwYUcvVTZpR2huQlZFTmgyZGZ4VUxmQTFqb2Y2Q2wxelpzWnhDTlA3aTRnTHp2NEljZTNwR0JLb2lJaUlpSWRvM2pKeDVGTnB0RGYvK0FEUWFxVmlvM0gzdnBoVC9GS3k5L0EvL0p6L3ljdWVaM01UQTRkTmZybDhzbGxKWVc4US8vL3YrTU44K2R4Ym16cnlDSjQzWG50N2d3ajhtSmF5MkZHSjA2ZmNhK3g1OTgrUXMzNzVONXlIVHgvSS9nNUtuVE9IVGs2RDFEakthdVQ5ajMvU2VmK0VXY044c244K3BGc2czZS9mUXpkdjNtWm03Y3ZQOTNQdjF2OE1SVFQrUEgvdU9mdEVFOStYeGgzZGRMZUpFODk2VVgvZ1NmL3VTL1FpOFkyVDlxanAvSGNXMzhDcGJNTWZES3l5L2Q5WnorZ1NGN2pQVVBESUtJaUVnOGx6dURzcFBIRzhHRDJDMmVIeTlqb1JiaHA1OGN3MFBEMlEyOXBoSXVvOVEwdnh1cXM2QTI4UlcwRHpSUHJuUTJ6TDBld3FtbDhLY1pPRU1iSTNXaThydCszLzREOW5xcVZxdmVWdWQ2N3V5clNGSUdZaEVSRVJFUjlRTHAxOXFNNjdpK2NBRmZPdnRiQ09NbWFHK0praVp1TEkzajFZbm43YkZ3NXVqN2NXVDRZUkFSMGU1V1VmRGZOQ1hGS2ZUeUFVY3REMmc5NEVOdGZQU0JGcmptLzRjMGhxRVVia0JEV21HME5weFU5NU4xN05SUVJETGZQaWpVdEVhdGcxRXo4ajR5KytFVVJSbHlHMnI3eW5oVHJScWhlZE52T2pyYlFPcWE0NU1qTzNXQWRMM0t1QW9OUnlkS0tma1lTZ09tam56dXFjc3BWVGIvTFptUCtmL3B3UDNDOWVMRTJVLzl4Yk1NTUNJaUlpS2l0bUdBRVJIUkxyTWNKbmh6b1k3cFNudkxCN3drUXE2eENEZnA3aUpoQ1FzU1NSd2hOV1dqbnQvYVY1a0VHVWxuUnRmMWtMZ3JnVWkzamdyYU12TmFDVmVTVUtFNE1xV2xubytPQlpFcjJHVVg4ajVhUXAxU2pqaE10RlBjZE9XODZlZEdzRm1YbHhvWXpQSW5PUkVSRVJIMWpyT3Z2b3d2ZjJFTTdmTElxY2RXZ29zR0JoRmtzbmowOUJrc0xzelpFS0kxY1J6YjJ6Lzl5clAyZWU5ODZydFdnb3hObVVFWVJqYjBabkppSE5jbnJtSHEralVzTE16ajBPRUhUTm1BYTYrdjVmRmJBNHlhamJxOUwyMmgwKzJCc1VNSWd2VkhuSDN6M0dzWUd0NkhEM3pvQjFBc0ZsRW85dGx3cEdhamdWcXRodm01R2J6MjdXOWllbklDUzB0TE5uUlpuaVBYL1BWYUZiMWthSGdZeDArY3hOZis1TXUzM1MvcnZHQzJnNFQzREkvc3g0bVRwK0NaZlNNaDFPWFNraWwzU2ZERzJWZFJyVlpzZU5IRStCVzdUZXYxMnE0UGVTNllZMkxVSEQrenR3UTYzU21UemRyblpMTWJDM3NnSXFMZVZWTUJOQnpNdVFNSTFlNXFVN3hRalREaE80aGIrSTFWQzZ0Mm9zNUoraFJTejRVM205aGhyeFdybldpRHNybWMvVTB1MTJPM0JoakpiL3RXd21DSmlJaUlpS2g3VmNNeXJpOWN4STN5aExtZWo3Yld6cEoydFVwOUNkTkxWL0R3Z1RQMldIQ1YxN2wyc2tSRXRHMldBVk5xcjFWZXFkalZTcHUvQTNSSW9KRU9hUlV1UTN1UjZxMitqTDdlL1Nrd0JZM0loZExtKzkxVldtL0xsN3paYkhaa2hSa0hydm1scVJxckFWZlVXYTZNYytFaVNoTzRITnBpYjlGUzFRdzlaMzdJbnpQWGRtK2tPajNmY0JzTCtOUmo1bEE0Q3lJaUlpS2lkbUZ2YVNLaVhhWVNKdmp5dFJKcVlYdGJFQWRSRmNPVlNmaFJkM2Y2U20xb1Q0SXdiSmh5RXdrd0tyYjBlcWswOVh6ZlZxYkxGRVVoZExMNW9qZVpSeUlkSmZWS3VGTFdjV3c0VWljb3JDeDdtcnFRN21yU0FEZ05HWFJOdEZQY0pMVG56WEpoODUyenZ6NVZ3ZjQ4Qnk4Z0lpSWlvdDd4bFMvOEI1dy8reXJhNWFNZit6aU9IanVPUjA4L2prd21nKy85L2gvRStKVkx0d1VZU1dkWm1YN2wvL3JmYmVqTlgvMkZ2Mm1EYi9yNkI3QzRNRy9EYmlRWVI2WktaZGxleC8vb1IzNEN1WHdCeStXU0RSQ1NnS00xbFVyRjNEZmJVbWp3STZkT1kzWm1ldDNIL3ZTNVozSE9iQk1KWTlvM3NuODF3Q2l4N3pFeGZobmYrc2FMK01KblAyTURldGJJODZRamNLOEZHQjA1K3BEWkw0Tm1mZi9ndHZ2cnRScHVURS9pTTcvOUtaeDU0a2tjUG5MVTdKODhnaUNEdWRrYk5tRHExLzdaUDBiTmJJOHZtdGRLUitralI0L1oxK3oyQUtOOUk2TTRhWTRmT1JZa3hHbzlBNFBEOWprRGcwTWdJcUs5YmNucFI2eGNYUFlQWWJlWktJZFliQ1FvTitNTnYyYXhQbytseGdLb2M2SXhEMDdkMUpsZFUwQ2lvVmp0UkJzazRiSHltMXhDV1NVQWRvMzh0cGRRV0NJaUlpSWkydjFxeldXOGVPa0xtQ3RQSW9wNXdiaVh6VlVtVWFyUDRkU2hwL0RBdmtmZyt1eUNRa1RVQytZVnNvdW1hSGc0UmNXSERoMmdZd0ZHZmFiMCtVR3RLMWVWeXBlaGUrcUxKQWNIZWZ2WDdnMTdISVdxKzZhcXdJRWV3RFpsRks0R0dLWG5WWnFWMWprVlppTnVDOWRSU2NGMXdqcFNMMGs2OTVtbkxxUjFEVXA5MDl6K3RvZjB0NjhYWjJxZitvdG5lYUZIUkVSRVJHM0gwbU1pb2wza1dybUpxVXFJY2pOQm1MYW5nTk5OWTJTYlplVE01TVZOVTN5Nk8zSzBiV2lRVWpkdlhkZHQ2ZldPZWI1dnl0dHNBSkVwWlUxU0dWbDI4OXMwMWFiWTFDekxXcGlSekw5VEk4d291NzZlbVJLa2JtcmVPNEZPT2JvUjBYWnprTnJ6Wmphc29GQmZRRE1vSUhZekxjMWpZcm1KS0UxdHB4M2ZWY2g1clozTGlJaUlpSWk2emNMY1RGczdxMHJBVU1QTVQ2N2YvU0N3NFRZU2JETTZkdENHMnR6YVVYYTVYTGJCUlovN285K3oxODZaVEJhTmVnMmwwaEptcHFmc2ZQYVBqaUV3OC9udTcvdVBrTTNsOE5Melh6WFgxRnN2QzVHUUpRa21rdVZiQzAxYVV5NlZFSVloZnVQWC9uL0k1d3ZvSHh5MjRVUzFTdGt1MjQycFNWeS9ObTZYNzhuM3ZNK0c4MGhJVTlpRG9jV1piTmFHOEp4ODIyTTI4T21WYjc2SVpyTnBINVA5S1NGVE44eStrdlgzZmQrVXIzaG1lODdaZ0tyejUxNnoyMDNtOFlEWjN0LzcvVCtFNTU5NzF1N2IzY3p6UExOT3ViY014TTdtVm83NVhDNFBJaUxhMjI1NHcyaW8zUm1JM29oVFV4ZWpNVmVOTUdQcXVrYUw5MjhUM1V6cWFNWU5VT2RveDlSeG1aOGg4YUFERldvNDgrMGRRSVdJaUlpSWlJaDJweWdKVVFzcnVGRWFSN1ZSQXUxdE11aEhoQkR6bFdsTUxGekFRL3RQdzNQWjM1MklhTGVUMG1EcGdYQkRJYWhBcDhjMW9wWGVEKzJ2aURERjBGNWVxM3kvMGs3SnZFOWRhUytCNm8zSUdtblFvblpuZXBHMFdqZlZCQmpVeUdTMktZSEo3UGN3MVdreTVTcTNyclVudFVEc0NiTjlQQ2d2SHlDZmhNcHZKdHp5ZTBEVG5HaXI1bnovV2EzMHZEbFpQYWVSbmxzMlZiZjQxR01KY0JaRVJFUkVSTzNHQUNNaW9sMWtZam5FVkRWQ09XeGZ5SkNUUkNnMkZteUFrWjgwc1Zza1NiSjZHOXZPaVdneHdFZ0NqMlJLVnpzcHBtYWJicVg0VFpzSzJzUVU0OHZ5Q01mdFhBaUpEVER5UExobTJhVmlXRWNhZXBjRVR4SDFFaVVkcUJNSk1GcTI1OUhFOFRZUllCVEtvTmIydko3M0hBWVlFUkVSRWRHdU56ODNhNmQyS1pkTGFEWWFObk00Q0RJMklFaXVpUStNSGNLTjZjazdBb3hXR3RCLy9vOSsvNTd6Mno5NndBYm9mT0Q3UG94c05vdHJWeTZqMGRoNnAzZ0pNT3JySDdETGQrbkMrVHNDakpiczlCdS85cy92TzUvSDN2NEVqcDk0RkovNTdVKzFaYm02VFRhYnM5T2piM3NjWWJPSk44Nitla3VBMGJJTk1BSmVNdnZ3OTlaOXZaUUJ5WForMEd6dkQzMzR6MkxHSEFNU1lyU2J5ZkVzeCtKYmhYUG5jamw3ekJNUkVVMTd3NmlwTEhhamVwUkNZaTduYXhGbVRWM1hSZ0tNR25FVHpWMVVkN1VyT1Fyd1RYM2JrQXRIbWk4endJaUlpSWlJaUlpTU9BblJDQ3VZS1YxRG5FYWd2VTBHMlV5VEJQT1ZLVnhmdUlnSDlqM0NBQ01pb2g2Z1Y2ZFo2R0RSRkJVL3BKMGFsRlpLbyswQlJxNEVHSm1wb0JIMUtSV0YwbzFsSlQ5bjEzTWNwRXFLMW5kaEhKUHNBT2xZT3FSVlpydHFuOHl2aWloV3FubE5wLzFsQng1L2FXNHYxOVZlem5HOGVyd1dZVWE5VEpuUG10WjYwZno1YjNXcTUzN3Baei8vSElpSWlJaUlPb3dCUmtSRXU4aVh4a3U0dmh5aW5ZSzRoZ01MNTVHdkwySTNxdGRydG9PWEZKZ3E1ZGhPWDYzd2d3Q2U3NjhVd0tjcDRtaHIyMWM2MzBHdHpFTTYxWGwrNXlwcFpibGwzVVB6UG5FY0k0a2pHK0JQUk51cldKKzM1OUhJRGRESTlLTlZ6U1RGWnk0czRPR2hIRDUwYkJCRVJFUkVSTFErQ2ZRdEZJczRkZm9NL3Z1Lzl3L3dsUzk4Rmw4MjArVEVOY3pQemJ6bGF4ODkvYmlaenVCSFAvSVRPSFRrcUEweVdnczh1dFBLL2RwY2E3ZldUQ3FieStFLysvbi93b2J3RklwOXVIVGhEVnkrY1A0dFh5UFBHeDA3aVBkLzRFTjQ3TXc3OEs3M3ZCZER3L3RzZ0ZFdk8vUE9KL0hRaVpONC9kVnYyY0NybGVDaSs3em1pU2VSeXhmd3NZLy9QSTRjUFdaZlAyaTIxVzRuKzF2V3BYL2c3dXRCT2Q0bDBPcUJZdytCaUloSVRMdERLTGxGN0dhWEY1cHd6ZSs2eHc0VTd2dmMrZW9zRnVwem9BNVRRSktYLy9UR1lOZEVSRVJFUkVTMGRSZHZ2SUtwcFN0b1JuV3dTU0t0bVY0YVI3VzVqSGNlK3dDeS92M0xkb2lJYUhkb1NOR3crYjYvcEZZQ2JUcFpPejJzRlFyUTZoVXpsVXhkQVNOVWR0WUJvRDZTcXREWHVzOTJ4dWtnczYranlMemZGYVg5T2FYN3lrcTc4VzVNZmRybGxQbWZKeWxsRHVveXhhbnUxMUE3MWIrNHF1eWhnVDVRdTBobnR0RHM1eTlwcFdkTjVkOGZtazA4RllicWRXQ1plV0ZFUkVSRXRDMFlZRVJFdEl2TTFDSXNObU8wazVNbXlJYkw4SlAyQmlOdEZ4blZ4ZDZtS1J5bjlRSk14MWtKN25kTWVhdHVRNUdyTE1mYXJYU3M3Q1JaWnJpT1dZZkloaVVsSUtLZDRKbnpwNXhINVh5NkdXR2lNVldOY0tESVVhbUlpSWlJaU42S1hHZDdubysrL242Y2Z2d2ROaHhvWUhBSU42YW43dnZhdnY0QkhENXlGQ2RQUFlhang0Ni81WE9qc0lsbW80Rlc1WEo1R3phenVEQ1BBMk1ITVRNOWVkL1hCRUdBWXJFUGp6ejZOaHZRSThFODh1OWVON0wvQUFZR2h1eitrMURtalpEblN0aVBiQ2NKZnBMdEZBUVo3SGF5RHJJdWpudjM0Skp5dk10NjU3STVFQkVSaWJxVFJWMXQxeGk0blZFTkU1U2JHeXRMYmNSMVUzNjZPK3V2ZGhQYk9jU1RuaW5zS0VCRVJFUkVSRVFycXMweTZtRUZxVTVCdEViQ2k0aUlxUGZZRW50VFBGeUZWb0h1YktKTXhzdy9nRktlVXBDdUcveWxzYk55V3NYOVVORjJ4RWhwalRSUmlLc0ttYktDTCtGRkRLL2FmaXRkbk16blQ2bkVUSkhaQytsTzdRY0ZGY3Y3ZzlwSnRxYzVyZXRwcGRVRUhQZDVlTFdsWC9ucHI1VkJSRVJFUkxSTkdHQkVSTFFMU0dOdUtVWDR6TVVGdEZNbVhFYSt1WVRCNnJRcG45aTk4VGNTWWxTclZlQjVBWEttUkUwNWJzdGhScG5zU29QL09JNXV6bk1ycEtPamNoeFQzdVBaVXZ6MU9xRzFTNURKd2c5V2lnMGxPQ21PMkppZmFEdGxvbVZrNGhvS2pVVXNoeU1JZlJrYlpPT0phTlVvd1djdUxOalJ5djdjSS90QVJFUkVSTlR0ZnZKbmZ1NjIyMDdLRjRwMnltYS8wMUYvSmNSb0FELzZrWi9Bbi9uQkg4VzN2L2wxWEw4MmJnT0RKQXhudVZ5eTErUVNDblBnNENHY1B2TUVSdmFQMnRDY3pDMUJNREtQdFhYNDYvL0ZmM2Z6ZmdrSmx0Y2ZQSFFFbS9HWWViL2pmL3Nrcmx5NllLYUxtTHcranVWU0NaWEtNclM1YnBmM0xSU0xPSEwwSVl3ZUdNT0pSMDhqbDhzaGF5WjN0ZnpnRTcveTYvYTIyYWpmbksvcmVYYmQ4NFg3ajJnclFVcEhqejJNMy9uYzgzYzl0clpOUGEvMTZvRi8rL3Rmdk9zKzJhYXlmNExNeHNPRUpPd3BhMTczUC82di80Zjk5Mi8rK2orMys2NWVxeUdLSWpUcU5iTTk4dkI5SDI5Ny9CMDJzT2dkNzNxM2ZhNkVHTWsrRWovN1YvOXovSVdQL3FkM3pWOUNmelpDbHVHcHA1K3h4OGhQL2VXL2Z0ZmpJNk5qMkVteUhySjhENTA0Q1NJaW9sN3h4bXdOQy9VWS94bUlpTzVXclZhUW1IcmE1NTk3MWx6YmxlMTFubHhMVFl4ZnVmbWNRNGNmUVAvQW9QbTlmc0FHZ3NxMVlhZEVwdDYxWHEvajdDc3Y0OGJVSkdabnBoR0ZJUzVkT0k4d2JOcm5GRmV2NytSYVQ2WW4zL05lRzA2N0U3NzhoVC9HNHNJQ0ppZkd6ZkxKY3I2QmZENlB3ZUVSZTAwczE4YmYvYjEveGx4WGpXeG9mdko2bWMrTHozOFZwYVVGbkQ5MzFsNm55VFdkekd1Zm1lZDNmKy8zbS9udld3bG1kVG82U0RzUkVSRVJiYU1yczYralhHOXZlMVhhL1VxMU9TeWI0NkxhckNEam0vb2gvLzUxVmtSRXRIdE1xRFFiUUNVRFVBdDVyWU5CcUNMYVRDa3RVZnJ1U2EzS2RhMlNWMVF5R0NxMXF3dVZjbG9meUtyZE5VQkF2MFppOW0rOFAwV3VxSFhCN2VBK1NFMHhxeWxKcmM0NjJyK2cwc0dtcE5Zd3ZHakg1VHdVM0x5VG02bkFTZlhPN0EzZlFWMDVTa1k5MjFnakgxcUhUczNIdDJKdUw1b1AxWmZUTlAyR28vVTNLc3BmNkhlaTJ1RGxENjRHRjMwTlJFUkVSRVRiaFFGR1JFUzdRQ1ZNYllCUkxXcHZ1SFFRMWVFbWtTbHgydGhJOTkxTWNyK2xFNkEwYUpWRWZxMGRVOEM5OFlMZ3RjYVVqdU9hMTZZcjBlSmJLSWhMMHdRT3RBMUNrbmxyT3krRlRwUk55M3JhU1FLVEpDNXBpOHRPUksxeDVQT21ZM2hwYU0rcjRTWWFaaXlIaVEycnE1cnpmT0JLZ1R3YmVCTVJFUkZSOTVJT21iZmU3Z1M1MXBaUUc1bkdEaDJCdEtYeWd3QkpITmxPcm5KOVh5Z1djT0RnWVR4dzlCaUtabG43MTFuZVRxeUxCTy9JSkdFOFNSekRkUjJVUzB1b1ZDcXJBVWI5OXZFSGpqNkk0Wkg5T0RCMjhLNTU3Qjg5Z0szd2JOaVIxL1pPcysyYTMxcFp4dHA2U21mZkpJbFJxMVpXQTR6cXF3RkdudG0vaDIyUXozcmJSRG90eTdRVkVyNGswL0MralhYZ2JUY3BNNUpBNnZYS2NpVFFTbzZYVEF2aFVFUkVSTjJ1RWFlMkxKU0lkamVwazVVQUgva2RmeXNiQ0x1SnZpNnh1UTRJb3hCVDF5ZnNnRFBYeDYrZ1hDNWhabm9LOVhvTkUrTlhiejVYNmwvbE9xQldxOXJmOGxPVEUvYitFWE45SllQS3VPN1dtMEt0TFk4RTVDNHV6T1A2dGF1WU51OHpQemRyQjdLUlFDVUo5aEVTUml2MXdDc0JSdjAyREZjQ2FHVjVoQiswOW50ZXdsMXR3S3U1UHBKQXB6dEowT3JhTlY5azlvRXNSOE1za3l6WERiTzlKUFJwY3VLYTNUK3kzWEw1UEtybWVsU3VzeHIxcXIwdkRDTU1Edy9mdFh5eVAyWDdyczF2WlQwamUxdTFRVkpYNGRrQW81d05ucFZ3SndudkhUWDdRcTY5cGI0Nm4yY0haaUlpSXFKZVVBOHJhRVoxRU4xSzJ0WW1ab3FURUpHWkdHQkVSTlJiRWxPeUY1dXEvSnFwdXZhMEJNOUlNQVpVZTN0QXJNd3JnSmJocWhNZnl0U1dhd20wMlYwSlFMY3cyOGZiTFFzdnk2bTBiSDhnYjI1OWJZcFVPeGxlWkg0OFJHYlgxcUFodnl3YjVyMmtob2c5WFhhZTZ5amxyVFJMU1pOWWZ1VnRmNUNZNjlvZVg3djJzNzlUek9lbkliZU9Sa1VybFdxa3MrYVVPbTQrY1ZmTVhyMnFxK1h4U3d1b1BmdDNualVWT00rQ2lJaUlpR2k3TWNDSWlHZ1hlUFpheVlaYnROdXhHOTlBRUZYUks2UXhhMUtOVnp1NEJiYUI2a1pEak5hZVYrenJYMmtRV3F1c2RDQkxOci9kcGZOWnRWSzJqV1R6aGFKdHNObkpBUUprcEV1UkpOR1dsNTJJV2pkU3VveDhZd25uSHZnQUlqKzM0ZGRKSDFVSkxycFVhdUFQTGk3ZzlFZ2VqNDNrUVVSRVJFUkVHL1BZbVNmczFHME9IVGxxSjdxL0gvM0lUMkN2YWpZYnRsTzBCRGZkU1RwQ256cDlCcU5qaDBCRVJOUXJGdW94bWdtYnBoUHRkdk96TTNqajdLczJST2hXRXVJajlhS3R1blR4UE40OGR4YS84by8rdjdoODRid05MNUlBMkkzNGpWLzc1OWczc2gvLzh6LzR4eGdhM3RlVzROVlNhUkhQUC9jbHZQVENuK0RUbi94WGRqMmoxY0NpOVR6M3hmOXc4MjlaRmduYmxlV1J2ODg4OFNSYXNUQTNnL05tVy95NzMvZzEvTlp2L092Ykhoc1pQWUIvK0N1L2JrTmVaYjdYeHErYTVYd1duL250VCtHVmwxOUNwYkpzZzNUZnlxZk0raFROOHYwM2YvdC9OZGNhQiswMXg1bzVzMThsTkdwdGZsOS8vamtiWlBSV2Z1MmYvV040bm0vbTk3L1lhK0R2L2Y0ZkFoRVJFUkh0ZmxkbVg3Y2hOVVRybVYyK2ptWmNSOS9ZRUlpSXFMZVlXbXYzckpNT0g0UnFGclZhOHJYTytRb2JieFM5UVdiZWZYTDdnSG1mR2xReXJqUkg5ZGtHRWt3MUFJVUhOTndIdEhJN0dSMGo0VVVOcFphV2xQYSs1ZWhCS2UxbDc1YnU0VG5LVEVEZVY4dU9jcUpHbEE1dmQ0aFJNVkFEcm1LZVZldjBPZlBSTFdtRlgxVksxeHl0UDFzTDgrR3YvSlhmcjRHSWlJaUlxQXN3d0lpSWFCZVlyOGRtaXRBdVNxODA5dlNqT3Z5NGlWNnlObXE5aEJENUVrcGtRNE5hSzFsMXpQTWxkRWptczlVUUlMczhwa3hOUnF0MHpkZXVWazdIeHdlUVpaY005SFN0VWE5bW1SN1JkbkRONTF6T3E0Nk83WGxXdDFpR0h5VWFNOVVJRHc2d2VvYUlpSWlJaUdpdnFGYVdjV042eW5ZMHZwWHJlUWd5V2RzeHVWaHN2UU00RVJGUnQycEVHd3NrRVZLLzQyei9nSzlFOUJhay9qRU1Rek0xN2VBeWQ0WU1GY3h2MTF4dTQvMlo0aWl5WVVFVDQxZHcvdHhycUN5WDdYelg2amZsZDdFTUFiMDJrSXVROTVabGtIcGNxWXR0TnVwb21Fa0NkdzRlUG1KRGpQd2dRQkJzcnMvVC9Od01wcWNtN2ZKY3UzcjV0dlZjRzBCSDFsSHFaRVZpbHFOZXI5bm5yTlZUeXpKZE9QODZKaWZHY2Z6RVNmdTZXOWRocXhyMU9pNWRlTU5NYjlwYldXYTduQnVvRjI3VVYvb3dYRjU5M1ltVGJ6UDdJVFQ3b1dUbWRkNEdTSTFmdVlUUzB1Sjl3NUJFc2xxZlBuNzFpcm0rcWVESjk3d1BudGx2RXVKRVJFUkVSTHRYbElSSTB2YTFXYVhlRWtZTjFOMEtpSWlvZDBVS2FnbmFNelhWeXRNNlZkTEJRcmMvN2labkN0dVVtWDJ3VWdLbll0WHBuaGJ0c3gwTEtxVjkwaGVsSGIxQlhET1R3TXl5enhRaVpsWjZ0SFJzRmN3eXh5bFVJdUZGeXdwdWF1K2pidVFyOHhFM1JkM05SSmxQdXZrd2JrZUlrVUlpaDdVRUtMbUtGWUgzcGlOVDVGOHkyeXMyMjZ0aVRvOVN1Rjh6Kytpc1JycnNRRThuU0d0eHpZbXZKZWZZQVlXSWlJaUl1Z1lEaklpSWRvSFBYVm5FVktWOW85bTRhUXdwUVI2dVhMOFpadFJMcEVHb0xidk9GMjNqU0duWXVsRzJNYnpyMlpGQnBmSHJTc1BYZEVPTlBlOUY1aUdOWnFYVFdjWjFiWHZiVHBTdHI4MVRsbDBheHFacFpTVkFLV0ZaRk5GMktOWVhrRytXNENmbTNPRUdpTnpXR3NaZnJ6VHg3SGdKKy9NKzNuT1FqYnFKaUlpSWlJajJBdWtnL1BrLytqM01URS9kZG4reDJJZVIvUWR3NW9rblFVUkUxRXVtS3h2di9PaWJNbGJmOFVGRTNVT0NnMmFtSjdHME1HL0RhdTUwL01Tak5rUm9vNmFuSnZDdGI3eUl6L3oycCt4MEs4ZHg3TzlpQ2NLUkVLQTExOGF2MlBlWEVGQUoySkZBVUpuK3UxLzRLL2krRC8rdy9SMDlPbllRQjhZT1lUT2VmKzVMZVBQY2EvakUvL1kvM2ZXWUJCZDVubzlIVHo5K015Qkpsa05DZjZRK3VObG8yT0Nma3JuL2YvNWIvNFY5WEg3VFM3Q1RiSnQybWJ3K2p0LzZ0Ly9hWGs4OC85eXpyYndVVTljbjdPMy8vdmYrUnh3NmNoVGYrLzAvWklPTVpMMC9aNjVOUHY5SHY5L0s3R3lZa3Zpbi8vRHZZMlQwQUI1Nyt6dHRFQ3V2WllpSWlJaDJ0K1g2SW9qdVpXcnBNbkpCRVc4LytuNFFFVkZ2bWxjNktDa0V4MU1WRjZGQ3BEcFFIZWdBOFVDS0lJU2psNVN1aDlET1BKREZMdUdzVHAwTU1wSWVMQTN6QnZlUEdYOXJzcHd5YkZLL2hqNmRPazFIMmY2a0hhdUFDYUVxVlVmalc0NGVsTjVLN00zU3ZmcXpUa0Z1SzZHVzQwTDZPbTF1WklBV21PT3hiczRtU2NGRG44ZVJUTzVKd292TWFmZXJRRG9OcGM0NUt2cUcwczc0a3FsYStkV2ZmcllCSWlJaUlxSXV4UUFqSXFJdXRsQ1BVWTBTTERWaWxKdnRLN2JMTjVaTU1XOENKNVdpekhia3NYY2ZDZTZSRVRzbHZDZnJ1dmEralphWnE1V0NON2lPWnh1ZVJsR0lKTmxDc2ErRUNNbG9tOUZLbzN6ZjkrRTRMam81UUlBMDZKWEFwQ1NPRURMQWlHaGJLS1RtdktwUk1PZFlMNG13VkR6WTB1dXJZWXFKNVNabTY1RTU1OGZJK3k0OFo5Y01KRUpFUkVSRVJFVDNjV042MG9aT1QwNk1ZM0ZoSGhQalYvRHlpMS9EK0pWTHFGYVdiM3Z1VTArLzMzYUtKaUlpMnNzS2ZoRlIwcjRCUG9obzYrcTFLczZmZXczemM3UHJQbjcwMkhFTWoreS83M3lrTHJmWmJPRHFsY3MyTkVlQ2VHNGx2NFg3QndieC9nOThDSmxzRmdmR3ZsUG5JdTh0NFVtZnMwR2drN2VGZ1U2TVg3WkJTTTk4OEVNdEJ4ako4c2h5eVh6blptN2M5dGlSb3c5aWFIZ0U3M3JQKzh6dFBodzY4b0FkU0VkSWNOSE05RFJlZWZsRk03MkVjcW1FUnIxMjg3V3lQTEpkMmhGZ0pBRkp6ejM3T1J1U0pPOGwxeEVTRnZUUXc0OWczLzVSK3g0UytDUmtYVUt6VG12WEhuTGRJZE90Njd1NE1JZC85eHUvZG5OKzhyaHM3NGNlUG9rUk16K1pyOVJ0OXc4TzMzemQvT3dNTGw4OGY5Zjg3TGFvMTIxQTY0UEhUekRBaUlpSWlJaUlpSWp1VFNHQmh1U2FlT2hzL2d0dGdmUkFLQ3Z0WE5Qd0RpaW9UaVVMU1UrUGcxcWhabzZFaWluVFN0b1EyTE1kQXIyeTdKMDhnT1ZESWoxUXR0SWJSSll6TU1XRlI3V0tzK1p2RzE2a3RZc085R1hSc0o5dFBlN29iRTFwdTl5OTJWdXBkNndkQmYyKzQwV3AxdVV3UmFmbFBSWDRya3BWSnp0VWRUOFpHVURHUW1pWVQwbERRMDBybTFlbVpzMUhLTkdwdmdxbGF5blVPTFJUY1ZReUY4ZmVsTyttcFN0WGQ4VXBrb2lJaUlqMk1BWVlFUkYxc1lWR2hObGFqS1ZtZ25MWXZoQ2FYSE1KWGhyWkVLTmVGc1doS1ZCVHlPYnphSldVaGJtZWxNdG1rS1FKVWpOSkk4L04waEpnRkVkMlBoSXVKQUZHTXI5T2xMbkpQR1grbVV3VzBxdy9Dc010TFRzUmJZelNxUzNFdCtmWXBObHlnRkV0VGxGYkRzMTVQN0xuL0l6ck1NQ0lpSWlJaUlpb2gwakhhdW5jL09Melg3VWR0SjkvN2xuYlVWaW1PNzM3Nldkc3AyZ2lJcUs5TEIva0VhVk5FRkgza0FDak44K2RmY3NBbzBLeGVOLzUyQUNqUmdQWHJsekc1Ly9vOSszdjVGdWRPbjNHL0I0K2lwLzV1YjloNm13OUZGZERlVVROTElQVWYwNU9YTFgxTXJjSEdGMnhnVUdqWXdkdGlGRXJtczJtcmRPVjVaRjYzVnNkT2ZvUWpwODRpYi93MGYvVXJtTmYvNEN0OHhYeVhBbFVraUFnV1piUUxOdWRBVVpQUFBWZCtPakhQbzZ0a3Uwa0FVYVZ5akl1bTJzSzJkYjdSa2J4amlmZlk3Zlo5MzM0aDIrR1Bja0FPOHZsMHMxckQzbmRyWUZEb1ZsZkNUZjZyZC80MXpmbkorRkYyV3dPcHg0N1krZjNQZC8vZzhqbkMzYWQxNXc3K3dxKytOay91R3QrZHZuTWVuL09iRDlaMzQ5OS9QOEZJaUlpSWlJaUlxTDFTSzZKWHNsa1laKzJMcVZYcHhMZ1JBNmN3UlRvYUlCUkNsVlNTazA1R2czenh2RXVhRDRkbU5KSkg1MGwreURDMW1UTWxEUFQwVlNaemFvY3BYUUdIY3FOc1o5cmhmUzZvek9teEZkMVBncUh0bXF0cTBKL1ZybVJPU3VYdDJGY2tienZCRmxQMmI1ZWU1aFVpdHd3bjVvbDgxRXhrMzdaL0hzcFZzNVpjeG9NLzlIUGZ2NVpFQkVSRVJIdFVpenNJU0xxWWxkTFRidzJWMGVVdERkOFpxUjBHVUhVUUsrVEJxYXk1V3dEVVZQSUtvMHRSU3VoUVk3cklnZ0MyekEyYkRSc0FORldsaWZSR25FWUlVMVNCSmtNT2hVYUxyT1Z6Q0xQODVISjVjMTdOaEhIRE5vbTJnNGpTNWVST0FHdWp6eUd6YmhTYXVCTDR5VjgrUGd3TXA0RElpSWlJaUlpMnAyKy9JVS94dXV2Zmh0WHIxeXluYk9sYzNBU1I3YXp0M1FRbnArYnNaMmJiM1h3OEFPMlBPcnBaejZJM0NaQ3VZbUlpSGFMTjAzOWx4Ui9QalNjdStkeitqTURTRFdidHhOMUF3a2NxcHM2MTZtcDZ6WU1aMkw4OG0yUER3N3ZnK3U0T0h6MEdGelh2ZS84b2lqRXk5OTRBWmN2dldrRGlkSmtwUTQyWStwekhVZmhRei93SXpiQVNINFQzMW1mS25XM25xbTcvZUVmKzNFYi9QbGYvL3pQM255c1lYNTN5KzlzQ1ZtUzVYejhpU2R2Q3o5NksyZGZlUm5OWnNNdXo5cmdNRkpITE8vM3pxZSt5d1lpU1REU25jdmt1cDY5NzZudmVwOTlyMDkvOGxmeHRULzV5czNIWlhtdW1Xc0NXUjU1L2ZFVGoyS3paRHZKdHU4YkdMTFhEQ2RQbmNiN3Z2dDc3YmFTVUtWYnc2TmtHV1c1amgwL1lXOWwvODFNVDk2OFBybDFmbjZRc2Z2dXlYYy9qWGUrKzcxNHhNeDMvK2dCSERoNENJRWYzTFlNaDgxN1NiQ1J2TVkzMjBZQ1dpVW95YzdQMUlmTCtzN2VtTGJ6N1I4WU5OTVFpSWlJaUlpSWlJaHVaWW90R3E1Q1hXbWRRYWVTVktndFFyTjNVbE5XTnEwUVYweWgyVUhsZUk1dWYrcUlLUkwwVFNtZVBxbWRjQWJhbFVtQ2UzWkRrRkczR3RDSVBDaDlWRU5MK0pSajg1WTZNeWkybGxBeWhlU3EwcTRwZVhSbGFJcmVIbXE5OTBpZG5RUUs3Y3U2YUthcHJqVFR5SnllcGJELy9nWCs5eWVIUXl5aFJZRUxsZlZOMGJMVHNhNVVPMG5XVXc3L0pmTkpNNmZOZE1GODhpcm1FM0xGcktyNWFLaWF1VTJpVkU4NldvZndVSkhiMEp6M1hFUkw4cHhVMVVzMVpQanhJU0lpSXFKZGpRRkdSRVJkYktZVzJTQ0xNRzF2NCt4aVl4SFpjQmw3aFRTQVZYWUV6RnhMcjFzckVaTVFJTmNHRDRXbWNEVzkyV0IxVTZSME5vbE4wYS81bjViTS9jNkZrOGp5MndBbTg3OGtqczIvazYwdE94RnRTTEd4QUswMi85bGVxTWQ0YzdHQjk0Y0o5dVg0YzUySWlJaUlpR2kzT3Z2cXQvR1ZMM3dXcjd6OEVrcExpeHQ2VGYvQUFJSWdnK01uVHRyTzBrUkVSTDFxdGhyWkFQZUgzdUk1R1Rkckp5TGFlVkxIR0ptNjBucTFpa3NYenQvMSt6YWZ6OXM2MWVIaGZSdWFYeHhGdUQ1K0ZYTXowM2ErYXp6UHRmTTUrYmJIYkZDTy9EYStrend1VHAxKzNJYnozRXJxUkt1VkNtNU1UOXJsZk9qRW94c09NTG94TldsZXUzemI4amltamxtVzRVSHpQbWVlZUJJRk15L3ZqdC9wVWlkcm4vUFFDUXdPN2NNWFB2c0h0ejB1eTdOa3RwY3NqOWhLZ0ZHU0pGaGNXTERoUVhMTjhQWjN2UnMvOENOL2Z0M25yaTFYTUp6QmtOa3ZyMzM3bXhnZE8yUzJ6ZFROQUtPMStjbDZIVDl4Q0tmUFBJRVBmZmpQWXQvSWZudmZlaVFvNmRUcE0yYmYzYkQ3NzQyenI5d1dZQ1RyVzFrdTMxeE9CaGdSRVJFUkVSRVIwWjBjaGRCUnFxR2dwSk1FUi9yc1lqSjhzb1FJbGMyK2loVFMwVlNia3YyMnA0NUlydzNQMVRvZDFhclpNRyt3QkxnY3VubHJzbHFsV2Rsbld1bEFhZG5HR1hTS3NqbFhTY21CVzFvTm4yS3ZsZDNGbGI1SDVteGNDTXlITVZhNkVpb0owWkVQZXpzQ2pNeFJpRVJDa3ZLK293TFhjVDNWbHZsMkZTVmR4QlRNcVZJdm0zOWQwMURqNW5TMllMN29YalovTDNsbVNuUWEvdExQZnVFc2lJaUlpSWg2R0Z1L0V4RjFvVEJKRVNVYVorZnFlSGE4aEZyVW5nQ2pUTGlNSUtvajA1VGJLdllLYVhpcDBoUzFhc1VHK21TekVtU2tOanhlZzRRZnlWTmx4RTh0ODZsVnNCV3lQSGFaekFMSXZITzVQRHBKMWptVHljTDNBelFiZFJ1Z1JFU2Q0NXZ6ck9pcnppQnhmZFN5clRYTWx1QzZValBCbjN0a0h6RFF1Ym9pSWlJaUlpSWk2aDdISG40RVl3Y1A0ei85K00vYnpzV0ZZdEdVSGJHdExoRVI3VzBEdVVHT3ZVM1VCZWJuWmxFdUxlS1gvby8vRFhPek16WWNLSTV2cjIvOG9ULzNGMjNvelVaRlVZVG5uM3NXVnk1ZHVPMStDUndhSEJ5eXY0bnpoZUpiem1QUVBFY0NjeVJZU0pibjlWZS9kZk14V1VZSkVuMzZtUSthZngzRVJuenJHeS9ZVUo1YkRRd08yNkNrZzRjZnNML1JYZmZlZlNyazhVdzJpeE1uVDlsbE9uL3V0WnRCUVJLTUpNc2o0VWNyeTdRNWZoRGd1Ny8zUDhLRER4M0hYL3JadjJxMjA4aUdYenM2ZHRBdTE2VUxiOXdWUUNXUGZmUmpIOGZiSG4rNy9YdTk0S2g3emU5emYvUjdkejBtZGVFVnM4NUQ0Y1lDcllpSWlJaUlhSGZKWi9wUnpBNkFpR2l6VExGdjZpcWRnSGFOZVVod2tjWW9WRFdyVk5xdjBZODJjNVJTR2dnT2FKVU9hTlc4NW1odlRtdTNwcm96REtlZ1VNNm5LdlpNTVNMUVBXRXNwc1N3UHBDcWNBd3FsOVdtcUUvdTFPaG9iY3NOcGIxcEI4NHN0Qk9DNFVXN2xxUmN1WkltNXFoRHJncnFjZHFzUjFpT1VwMVBVclE4NG9pYzZ6T2VXZ3BjK01YQWtld2krSzR5bjNYdEFMMVJBV2pXWWs3Ym5EZjlxeW1jK1RTTm56Y3IxNGcxR243aTFNTWdUdElRbFRCQW5LOGhubTAyK2QxSFJFUkVSRDJQQVVaRVJGMUlteEtNeEV5THpSaXp0UWp0NGlVaC9LUUpWOGRtMmtQbEhscmJVVUZ2RCs2Ull0R05GWHFwMWRieDBpQlZPMXZ2T0tiMVNpQ1ZOTngwZEdlTFoyOWRkaGtoTkpUUUpETnB6V0pob2s1Wk83L0srWFl6cWxHS09JMXNtQjBSRVJFUkVSSHREZjBEZzdiRDkrbkgzMjQ3SVh1ZUR5SWlvcjB1Y0RQdzNBQkV0TE5rZ0pTbHhVVzgvdXEzYlNqTldpalByWTRlTzk1aWdGRm9nNUhxdGRzSDNTa1crekF3T0dSL0Q3OVZXSkJZQzltUjV6ZnVXQ1paUmducFNlS04xN1hMOHNoMHEydzJZK2VmeldUdSt4dGRIcGVwMkQ5Z1gzTXJDVmlTNVdtc3MrMWFJZXQ4WU95Z0RWUTZmdUxSbGw0cmcveXNiZHU3SDh1dTdzUFIxY0dBdGpZL3FROVB6RHBMd0JRUkVSRVJFZldld0pUWCtDeXpJYUl0a05idGpzMnFvZDBpVkxDQkk2Rnl3ZzdXWkV2UEJ6Y25vU2NhNlEwTjdYVnh4b212RVdlZ28yNExZc21aNWVvelJiQUZyZk5acU5WQzFzNHVveW4xVkNWb1Y4S0xFZzVNc1d2SnJuTWRKWDJjbFBLVW0yb25qUklkeGVubU9oOUpKcG5ucUNoajVwVXpreU1mY0xYMlRyM0JsSUEzemRyRVpnTzk0YWg0K2gvOXpMUFBnWWlJaUlob2oyT0FFUkZSRjNwdHJvWnYzS2ppeXRMV0dqRGVhYWd5aWFIbDYzQ1Q5b1VpN1NhMmtXU1Nvb2FLSFoxeUl5Tkgzc3IxVnI0MkM4VSsyOWp5emdhMXJZcWowTjc2dm05RGhmd1dsNmNWem1vRDMxdytiOE9MS3N0bEVGRm5IWjU3RFpYc01KWUxveTI5TGt5MG1SSjgvdW9TcnBhYitNR0hoMUh3dHg2ZVJrUkVSRVJFUkR2cnpCTlAyb0RwdnY0QmpJNGR3c2xUcC9HSW1VNmVlc3gyOXBZeUp5SWlJdnFPL3N3QWxQbmZnZUpCVTJiYXhHSjlBVVRVbXNtSmNmenlKMzRSbS9IS3l5L1owSjJ2UC8vY3VxRkY0dWxuUG9qakowN2loMy9zTDlvZ3pvMlMrVDMzN09mdXVsL21KVUU2UWJEeGpyRFBmUEJEZGpsZmZQNDcvUUxHcjF6Q3pQUVVmdWJuL3NhRzUvUGk4MS9GeFBpVjIrNlRkWkxmOFlQRCs3QlI4anRmbTdwazJYNXIyMDJXVDlhM2xaQ245VWhkN3cvOXViOXdWMERTUnNoclpOdG1zaTBQbEUxRVJFUkVlOUNKc2JlakhsWndmZUVTZGtMR3k2S1FIVUF1S0ppcGVQUCt3ZngrRzNZOFZOaVBTcVdDQ3hjdTJLQlFtWnd3QnlkNTYyc0pKL0ZYbnBPNnRzeWhrN1NUSVBVYTBDcTEwN3JQa2NmYzBOd20wRjZNWXc4ZHc4aStFZVJ5T1J2cSt1YjB5M2U5WnFGeXcwNDdhY0JzLy83Y01JaUlOaXZ3bkVMT1U3NXl3TWF4dTh5M25YVFlsQzRsNzAyY09iUHovSXo1V2tDYm1XOW8zMVh3SDlWT2VETFY5YSs3YWJZcEFUbGRsbm1pTkNMSFp2ZEl1TXZPTFp5dlpTY29ER25WT0taUk1iOTBpaTZ3TFkwUGxoVGlxMHBIUythWGpOay9IY3UyaWxNTjgzOXplKy9uQks1YVNjQmlnTktXMmI1Tlpqc09abFJ4TUlOaXJCMTdsTmRqM1REN1FUZGpQWFAzcTdSNWlYSnp2aHB5bFFveUsrbGpydGtmQjlDYm5qT2I1S0tYTnY4dUhHL2hFei85N0JLSWlJaUlpTWhpZ0JFUlVSZHFKaW1XdzhTR1dMU0Rzb0hYR2s0YXcwMzNabmpSclNUQVJ4cU5TZ2lSRks3SjFJcTExeWlKQU5jcjg5dUt0ZVZZbTArcnk5T0t0WG5iWlRkMHlzRXJpRHBGenJkeTNsVmFha3ZNWjd6RnozWTFURkdOT0RJdEVSRVJFUkhSYmxVb0ZEQXllZ0JIamg2N0dWb2tBVWFGWWhGRHcvdk1mZjNJNXZMd1BNK1UxYkJ0TGhFUjdTMitxYWNJTnZqMWwvRXlTSFVDSW1wZG8xRzM0VG1iMFRTdmJkd2p1Q2lUeVNESVpHMG9UaXZoUGlJS20zWmFqd3hDNDdjUVhuUXZVdThxZGJBYmtTUXlDTTc2NXhnWkpFYVd4MTBkTEdhcnk3UFZldVd0V0tuZjVuVUhFUkVSRVcyTTU4aWdqRnY3SFd6bjQzNm5IN3RyNXVjNEVoemsyRDcra2xseDYyOVUzLzNPdFVCZ3lnTHltVDVrL0R5eWZ1SG0vWVZzdncwd2ttQ2p5RXROMlVJVzVoYzlsRzJqWmVhdDcvT2JWMHY3cmUzcTFhN3MrNm43WlhQWVpUYlBTeFV5YnM2c28xbnZJR092US9yV0NRbTZzNHdrVFZmK25jajljdTJoemJXSC9FK3ZYSVBJYmJMNm1yWG5wbnByYmRKa1g5MjZiNG1JV3JYU0ZGK3hvR0lYMHF1VEtkMXpKT0FrTUY4MnE3MFQydjRGcTJUVzVrREp5QmVic29GQk5uK3dXM28vMkc5d3ZUUEpSV3R2NnBtZkFJSDVNWkhSU3BsdlprZEtBRmQvOEhSY0JKMkc5aFlTMWRpVzk3Uy9YY3h0S2l1aGtaaGIrNE0wVHJYdEV2VldBVVpLZG9iMHlZRzJpeU5IcEZxOVdmczNiYzdhcG5OV095TzVqcjY3UDdKeVhMT1RiQytsWHQ3VzVqQk1IUG5wamJSaXJqM200SGhwc2x4bmh3OGlJaUlpb2xzd3dJaUlxQXVkbmF2aE4xK2Z4VUk5Ump1NFNRZy9hV0s0UElHeHhmUFl5NlF5VmhyRVNpUFVPSTV0dzFyZmI2MGkxVGVWdzFJNEt1VnZVUlFpYkRheEZmVmFGVklISXgzWXBFTGU4enBYc2V1dXpqdWZMOXBHc3ZMZVJOUVpZd3Zua1MwY3hPVCt4eEU3UGlJLzE5THJ2ejYxakRjVzZ2akI0ME1vK0t5bkpTSWlJaUlpMm0zKzBzLytOVHNSRVJIUjNSN2RuNU9HenZkOW5vUVh2ZlBnZXpCWG5jRnNkUVpFMUpxWjZTbjg4aWQrRWUxMjVwMVA0ZDFQUDRNZituTi9BV2VlZUxLbDE1NDcreXB1bU9WYWo0Ui9uanA5eHRiSGJvWFUzOG9VeGZldmI1KzZQb0hGaFhtRVlYalhZd01EZzNaNStnZUdzQlZTTjcxY0xxRmVyMk9uWkV5OWVILy9RRWZyb29tSWlJaW9kNHdOUG9pbDZpd201dC9FVmh3ZWZ2aG1NRkV1S09MSThBbTRqb3ZBeTJLd01JcENwdi9tY3g4WmV3ZGFzYkN3Z0dEeEJVeE1UR0NpTklGdW8xSUhicHJmMEhNbHJFamFzYjc3NklkeDV1MW5idDcvd1EyOFZ2WlRuSVJZck0waE1yZkw5UVhVdzRxWnFxZzBTMmhHZFpUTmZmS2NoY29ORzRDMFZKM0RWc2grSEM0ZUFCSFJabVZkNVB1Q3pnNzZTNTBoVVhpbWhNdjlscE1POTJ1ZHZnT3VGSGk1Wms5dXJVQnZIZWJ3OEJXMC93N3ROQ1NYN3prM3pjVWFxSGJKWWRNUDVReHA4elcrQTh1VHhVcW96T09wbWd2ZytNTWFrbnBvUGxWNkdOdEF3b3V1S2l3dkF2NlUwaHY3d2JPUitacjkyelE3dVI3cmNqM1M1V2FpQjFJTkg5cXNzdHBZU0pJRGxGd0h1dUE1YWNaRHRwaHhpdTVhK2hWdGlyc2FBMVYwMWo3bjdtSHNVV1l6ekpyRDlJWlcrT1YvOU5PZi8xMFFFUkVSRWRGZEdHQkVSTlJGbW5HS1VoaGpzWkdnRnNxb0orM0poL2ZqT25LbUl0SkxRdEFLTzhwbGtpQ0pJMXNZNlhwdWE1VWdNZ0tRcVVoM1hSK09HNXNpMksyT21La1JSWkZkRHRmMTBPbVVkenVTa1hKc29KR0VPdDFyVkZFaTJobzNEWkZyTENMMEN5MEhHQzAwWWpTVEZKVW9SbC9zSU9kdGZWUXpJaUlpSWlJaUlpSWlvbTdndTJwRFE3QzZ5c05RYmg5Q0dhekREWkNtcG01SHMwNkRhTHQ1bm9kOUk2UG82eC9Bb1NNUDRQRjN2TXRPQTRPdEIvdUVZUk54MUw1NjY2SGhZVnZmdVo2RnVWbk1URTlpMkN5N3JNTjZZbE5mTE11RU50WE5GNHA5ZHBta0EvS2RtbzI2WFo3K3dXRmtzMWtRRVJFUkVYV3JvY0lvb25qOTMrMFNPaVR0RCtWV3dZSHZCZkFjRDRHZnQ3ZWU2NXZid0Q1bnBPK1FEU3dTdnJsL3VEZ0dSN25tT1M3eVFiOTVUV3Z0cVc2VnlXU3dmLzkrRzJTMDIwbDQwY0RBQVB5ZzljQlIzOHZZTnFkOWVnamFsSnRrdkN5aXBJa3dicUlaMTgwMVQ0aEdWRVZzSHFzMlN0QklVVzFXYktCUkxhd2dTU01rU1d6S1hwcjIycXJhTEpuSElyUC9tNllNSnJYUFd5UDdYTUtuWkI4U0VXMkdqQjFzU29WajExR0JXZ205b1YxSVN0SGsyMEdTaStSYldMN05DK2djcFNFZEgvU29WdWFiVFR2bXZSMHRCeEoybGw3cFBLTFJnV0FjRFpXbVdqZTEvZExWOG5tUllCN1p6cUVwNVV3R3RPU0FLWld6dDlyRk5vYnptUDNlbEI0NGkwajltdHA2djFUcE0yWFdWVGNTTTk5RXUxRU1QMHpUSU5FcWJ6YXlKL3RmdDlDeHhwUVVCOHI4cDVtWXVTcmxtYTFvZm52cTBGVXF5YmdxYTI2Wm5VWmJvSytiVCtNM3pFZHo5MStFRUJFUkVSRjFDQU9NaUlpNlNDTkpjWEd4aWNsS2lJVm0rNHBVYytFeWhpdlhFY1JWMEFwcDRDNlRsTldtYVdwS2JndG9MYi9JbExhYVNtTzVsZmxJdzlZazN2dytrL0xyc05tQWx3YTJBbDg1amcwWTZoUlpkbm5Qck03YXl1ZkdEbzcyU2RUTHZDU3k1OTl5Zmo4cStaR1dYanRkamV6dGZEMjI0VVc1SWh0K0VCRVJFUkVSRVJFUlVXL0krUnNyNzVST2prY0hINEpqNmt6eWZnR051RzdxWXhoZ1JMVGRYTS9ESTZkTzQ5Q1JvL2pSai93RWpoNDdicWZOcU5kcXFOZHJhSmNqUng5Q0pydCtwK2ZyRStNWU9EZUVwNTRldm1lQVVSaUdkcG5TZTRRZ3RXcG9lQjhpczB6T09nRkdwYVZGbkQ5MzFtekx4NUFkT3dnaUlpSWlvbTUxWk44ajl3d2VIaXlNSUJjVWNXVDRoQTBwR3N5UElQQnkyTjkvMk54ZlFONDhWc2dPSU9OdFBweG9JeVRBNk9FVEQyTjJkaGE3WFQ2Zng4R0RCNUhQNWRFcUNSVVNmZG5XQW1aTDlRWE1sSzZoSGxic1ZEYi9sdUNpeTdObkVVWjFMTlhtYkhoUnVmNmRBS09oNHFnTnQxb1pwSk9JcUhXT1F0TlRxdW9wOUh1TzZ1d1hCWFdNcFBiVWxRMkt3WFdsMWJCV3F0Q2ViUEIxbVo4a3ZqTHZlakpWOVpKU3pySktNNkY1djNpSFEyak0yMnRIcVE1VldHZ2RLWlFqUU5JTmgrV2JWLzQ0b0ZFZjBxcXhYNnZBbEQ1S0FlUUF0dG1TMGxVSmtacHlNSWcyaUJJSk1WTHBUQ1dwSkZwblUyMVgxWndmZE01dTVkYjNjMEYyU2oyUlNRN01CQmxYMVUyMVZHTmZEcTV5VlNDOWRKaGhSSnVqWGpGSDFTZVROTDRBSWlJaUlpSmFGMHVQaVdoUGlkTVV0VEJCbUtSb1JOdmJ1RmxHa3MzNW5xbVVkY3kwZnFQc1dwVGk3RndOczdVSTdaU0pxdWlyelNDSW02RGJTZmlRQlBta3B1SlZwNDV0Zk5zSzVUcncvV0RsSDZZa0twRlFwRTJPenJteUhBbWF6WVlkVVVmNVV2YXEwTEdJZHhtNlFpcVN6ZnhkVDlZL3RXRk9STlErYmhyWjgyL2tibjRVM1ZkbnF5ZzFZeHdzQmh0NmZtSnFiaFpxVFRzaVJaeDBzRVp3SGI0NUp3N21mTGlPQTFPNURDSWlJaUlpSWlJaUlxSmI1ZjNObFIxbS9SeU9EUjdIZEdVS055cVRJS0tOR1JrZHczZC83NS9aMEhOWGdueXFPUHZLdHpCMS9kcHRqMGw5Nk1sVHB6RjI2SWdOTGhvWWJLMWo3SzBhamJxcEQxMi8zam9JQW1TeVdXem5DTmhSRk5sbDB1dlU4VW9Ja1N5UDYzWnU0QmtpSWlJaW9tNDBYRHlBSkkxeDV1ajc0THNaRzB5VTh3dnd2UXo2Y2tQbXZnRDl1V0hidGpIcjUrRTZIdktaZm51L1RLN2pvOU1jeDBIVy9GNHZGb3NZSEJ4RXJWYXoxelc3a2F6RHNXUEhVT3dyWXJ0a3ZaemR6M0V5aENnSk1SSWZ0dTFwUi9vTzJYM2ZpS3Jtc1JpMWNCbk55RnpIeFhVYlhsVEk5Smw5M1BuOVMwUzlLWEJVa1BjVlBLVjRJdWtCc2ZraHNLUzFGUG5yQWExcU9lakFoK3BZUDBYelBsNFdHa2Mxb3FvcFA1dzN4WGxWd0l2VnptVFJCRURCVEJsVHNPaDBva0RUek5ITG1uVjhRS3RTUnB1ZlBlYTkrczFrN2pPbGxlWTl0M20xWTQybWhrNm5ISjJMMi9EbVlhTGpGTkJMamRSUHpUWk1VcDAzMjlGZGljaHFMN1BzbVRUUmJxa2hHMC9IQXhuSE5jZVRZbHQzMmpnWkFVR0Y1dkNjajFWOHhhbWhBaUlpSWlJaVdoY0RqSWhvVDVGUWgzSWpNaFZxTVJicTIxdFJtUTljRE9jeTZNLzY5d3d3cWtZSlhwdXJZYWJOQVVhQnFVanNyODJhMHRrNjZIWnBJb0U5S2VJNHRoWGFyUVlZeVd1Y0lERGxVSG9sZ0NoSzEyM2N1bEdKcWZDVlNtQXB3NVpsVVIxc25TdGw5WFo5RTFPYTcvbG1HMFNTNkFRaWFoODNDZTM1dDViWi9DQVRyODdWVVdxbStOQ3hqWFVHTUpVNG1LMDBWOEw2dG5razhyenYycEhUTStiVTRqa2JHMEdkaUlpSWlJaUlpSWlJOW81QzROckJQbHFWZFhNNE52U3dLZk5zTU1DSXFBWDdSMGZ4NTMvOHB6YjAzR3BsR2ZOenMxaGNtRjhud01qSEk2Y2V3K2pZSVJ0Z3RCWE5SZ1BoUFFPTU1zaG1jeDJ0STcxVEhJVjJtZFlicEVZR2c1SGxjVjNXZVJBUkVSSFIzckt2T0dhRGlONSs5UDNJWi9vd1hEaUF3ZFh3bW01eFo0Q1J0QUhkMVFGR0R4MURQcC9IZHNuNE9UdTlGV25MS3NGRjVmcUNtUllSZUJsNGpnL1B6WUNJYURNQ1Z3VUYzd2s4RnJYMGhBUlFKUVhmMFdnTUtGMXp0WklJdzQ3MVV6UWxobjVXSTMwUVRtTkIzbDlwbFVDcnlnNzFqVFJ2V3JSSlhCMHB5MVRLZ2ZieUN2RXhyY3A1TFVsSjhuOXNma1RkTFVvVW1nbFVmRVBwNFhaRURJVXBrampWNlZJelhSbjFHOGhEZDJiZzNpVFZXV2xSWDBxMCtiR280cXl2M01Ec040KzU5YlJCNW5TVGF2TVowRXJQL1pPZmZ2WUtpSWlJaUlqb25oaGdSRVE5NytKY3hWU2dKZmowdDY2aDBvendwdmwza3FZd2hWM1lUcExPN1pvSzA3RytMQTcyNS9EOWo0NWhyRCtMd3dONTg1aURXcFRnUmlYQ3MrTWxHMlRVbHZkTW11aXJ6YUZZbjBjUVZ1R0E0VFQzMG13MjdLMVVha3R4YjZ0QlJwN3YyNGFyRWdxVW1FcmJKSTQySFdRa3I1T1JQbE56bkdheStaWDVkckNScnF4ekpwdURFenFJekxwTGlKSm1rQkZSV3pnNnRlZmZmR01KUTh2WGJaQlJNeWkwTkkrdlQxWnd0ZERFTDd6NzBEMmY4NjNyaTFpcVIrYTdidHg4djZXNFhxcER2dVpTdmIzZmRhNGRWYzNGUThNRlBMU3ZpSGNlSHNMREkwVU01UVA3WFVkRVJFUkVSRVJFUkVSNzIyRFdSVEhUZWpPRm5KL0h3OE9QbWpxMEtwWWFDeWczUzZoSE5SRFJXeXNVKzNIbWlTYzM5RndaN0VRNi9MNzI3VzlpWXZ3cUZoZm1FSzEyL3BYN1gzbjVKUncvc1d6KzlXZXhGVFBUa3pZa2FUMEhEeitBaDA2Y3RFRkcyMlc1WExiTEpPdDRKK2xFTE11VHkrVkFSRVJFUkxUWFNIRFIydzYvRzU3andYVjgrRjUzaHRZY2ZmQ28vZTMrMGtzdjRlTEZpN2J0cGQ3bU5sT2JKWUZGeDQ0ZHM1T3NRN2VGcDBwYjJzRExZYWd3aXI3Y01Gd2w3YitVUFNhSWlGcmhLTVMrbzZwWkQ1bU1pNnl6amVIVjFIa1ZwZjAzZ1FHelY1TkFxNXI1bHNqSVdNN29BSFBzS01ueTZUZi95Wm52SkZOcWx5NXFOT2VWRG1LRmJUbXdaTVhrbTdDVHJhSVZ0UEkwQ3VaOXRHK0tlWjBkN1A5cE5uVWkwNXRPbWl1WmY4ZllHdW5IRmFjd2RUMkpIeWJZN2g5dFhtcmVjcUdhUkk3ajZJTkZKMk1ISHVjNWllNURLMTAzSDh3TE90RUxJQ0lpSWlLaXQ4VFNZeUxxZWVWbWlLWXA0VHA3bzRSeUk4THJOOHJZU1ljSGNsaXNoM2pxZ1dIMFoyM211aWtDMDdaVXI1NmttSzFGYUJlVnBnamlPcndraEt2YkU0clVxOUprWmZ0SWFOQm1NalljcVpoMUhTZ3pPYkkvc1RYcGFvRFFkbFNrU3ppU1ZId25abkxNZGtnVGhkMVJmVS9VL2VUVEpPZGZMdzN0K2JnZXRENEsyVXd0Uk1aOTY0b1JDUythclRieHpldUxNa29FcHBjYjJFblZNTGFSZVJKZUpOL0JSRVJFUkVSRVJFUkVSTUkzOVNqWlRReHA2em9TZk5TSHZGOHdyOCtoRWxaQVJQZm5lUjRHQm9kYWVrMmhXRVEybTdXRG9LeVJjS1BTMGlJcWxhMS85aHFOQnNMVllLUTdaWE01Rkl1dDE2VnNSUmcyN1RLdHh3OHkyNzQ4UkVSRVJFVGR3bk44OU9lRzBlMGtCRWl1WDRJZ1dCM0FVdTJhQUNPNVp1dnY3N2VocVo3WGZkMDZiTnRTNWRweW1RQkVSRnRnVHMybWFEaHlsUlFSTXlpazEwU21DRDh5WHhtUjdSSWpuVlpVSjcrSWJkNk1mQzhGRW1La1ZGSlhPalhIVmhwM0tEVHBUbEpxS20vVTRTTlp2b2J0andQelhqNTJra1pxVmpZMUpjTkJXY0haNnM2VmJqSXlTRytVd0FtVDdmM05wcUhzR2FpZUlQVzBYdWt6SS8vaGFZbnVUK0syS282alFoQVJFUkVSMFZ0aWdCRVI5YXh2WFYvQzlWSWQvL0RMNTdCUUM3SGNiRjh3MEZiY1dHNWdydHEwUVVvNTM4SFBmTmZER014bkVQdFpYQzAxMFU3WnFJb0RDK2RSck0rRE5xWldxOEIxZmVRbGtHZzEyS2NWbVV6V1ZuNm5hV0pEaU5hQ2tWcWx6V3NUTTUrNldSNFp4YVpRN0x1dGtYQW4rSDVnS3NGOWhNMkdIV0UwanNKZFU1RlAxTzF5eldWN1BtNjZXVFF5L1MyOXRoYW5tSzFIK016RkJlelBCM2pQd2FLcHRFblJNUGYvN2lzVGVIVzZoSytQTDJDaDNrUzUzaDNmZFJmbWxuRjFvWWF2WHA1Rk1mRHdQMzM0RFBZWE0zaGtmMnZyVGtSRVJFUkVSRVJFUkwzbGJhTjVIT3piZkplM2g0ZFBZclE0aHVldWZBR1hGdDVFbExJdWc2amRIanJ4S0o1NitobDg2WE4vaU9acXNFKzlWc01YUHZzWkxKZVhVQzZYVEoxb3h0YUxkcnRhdFdLWFYrcHV1MEVVUlhaNW9xaTk3UUtJaUlpSWlQWXl1VDZSOEtLM3YvM3RHQnNidzllKzlqVXNMUzJoMiszZnZ4K0hEaDNDQno3d0FmakJ6dVlTRUJGMWlnSlN6MUhsakt2ODBZSWFkaVNTaGJiVnNGWTJiR2RRNC9xOW5sT0hIa2lWOHBhaHN6SmthWFdEZTBtZUp2UHUweW84cUZWbG4wYkJoeTRvbURmZHBrU1lnNlo2WUZRckhUc2FNc3g1UmFIakF6bDdFcHhrMXErelBUdTZ4eVZIZTdOS2V5V3piV05zbmxUbHlQRzEwRWpqYXFTVE9OVlNXYlFqNXdSVHI1U0pVeVNUeStsU3pvVS9XblFMSUNJaUlpSWlvclpnZ0JFUjlaeFlnbDlNeWRaQ3JZbnJwU3BtcTAwczFyb241TmdVdE5tcGFVcTh5ZzNnK2xJZGxkQXNjTTdCUW4wclJYcTNVenFGU2hNRWNRMXUycjc1OWpxZFNrUjhnaVJKNERvT3RBME5VdGhvZFluVXE4amtPQ3U1K2hKaWhNMDJuSmNnSk5tUGt1NHVnVWptcms2R0dLMHR1ekx2WVpmZnJyUGEvUElUMFUxdUd0bnpzVzl1NWZ5czFjWS95L0lSbEdtMkZpTllIWG1tRnNhWU45OXRVOHQxVEpScTlqdHZzZDQ5MzNWUm9zMFVtKy9qRk11TkdKT2x1ZzFkZW5pa3o1NWFXQWROUkVSRVJFUkVSRVMwTitWOUYvM1p6UStDSEhnQml1aERNZWhESVNoaXFiRUFJbXF2YkRhTGdjRkJ1Tjd0SFdnbHhHaTVYTGEzanFtdjJBMEJSbkVVSXdxN0p5d29TVmFXSjBtNkkxQ0ppSWlJaUtnWHJMVjd0TmN5QXdQbzcrOUhHSWFvbVd1WGJyUTJxS1lzYXk2WFF5NmZBeEZSTDFLUVJ2QXE4VXc1a3VzZ2RSM0hZY3ZSenJMdGM2RzFxMWNTaEJ6enI3eUdzaUZEYi9FNlR5a2IveDJiVjBsL0JlazVrQ0pOelV2bG4zWm1kM1lua0oycHpGc0Y1aS81SnN1YmFTV05SbTFycm85cjN0RlZxVExycVNPejhyWFZoZFlkUE5pYzFXMk1iVjdYN1phWTlaVGpvbUZXdFc1V050WmIyNjZwbVY4cTNXTE1UU3o5Wk15L045NUxwNzJVc2kzWkhlblhGVGtxU1dXa0RMa0RiT0JPUkVSRVJFUzBWUXd3SXFLZU0xMXUyRENIWC8zNlpYejU0Z3k2M2ErOWVObVVDcnNvN0IrendVYnRJT0VZMmJDQ2ZITVJJNldyb05iSUNKeTE2akk4UHpBVnhIbFR0T3h1T0d4ajdYbjVRdEdHRjFVclpUdnliN3JKUnFnNlNXMGxRTDFldCtGRk10OU9DNEtNclVHUUJyU21mQmhKekFBc29xM0tSRlZrU2xYTTlSOURKYmNQVFQrUDFObjRUL0ZxbE9BekZ4YncyRWdlZithaElidzh1WWhmL3VvRlhKeXJZSzdhdmFQME5zMDVUS2EvODhldm1pcEtoZWYreG9kTVJiUkNJZUJsQ0JFUkVSRVJFUkVSMFY1MFlpU0x4dzlzZmlEYmpKdTEwM3VPdkIrblI5K08zM3J0azZpRXl5Q2k5amwrNHFTdEwzenUyYzloWm5yeXRzY3FsUXBlZlA0NVBITHFORTZlZWd6ZGJuNXVCb1dKWXRmVWQwcjQwK1RFTlR4NitneUlpSWlJaUtpOURoODViS2NnQ095MXkyLy85bStqR3cwUEQ5c1FvNC84aFk5MGRFQkxJcUtkNWpsTzJYY1VEdmU3Zy9Kdmw3RWdIU1diVjFybURtdlYzR2VtRVEydlR5dEpqY3FxbFljUDMvUEYrdTUvSjlxdE5SVG1RNWlaS2FpbWRMRllmVmkrdmZyTnZIMk5UQkVZeFVwMjBUQjJnSUlPSkZYblViT1lackdqcjd0cFZzSjJPbGxyRUNqVkdOQm9tUFdYVVYxN3RrSDBzbExKVmFXamVjQ3Z0R0U5bzBSSHk2R3VOeE9kMCtiWVVkalprNEk1WHB3bzFZTXExbWs1Vkkyc3A3eXNDeDlFUkVSRVJFUzBKZXc1VEVROVo3a1pZYXBjUnlXTXNCdG9PL3FMWThPTGt2YmtGMWxCVklVZk4wQ2JJNkZETXNWeGJDcUx0ZGxIM29aRGpHN2x1cDROQVVxM09JcW1YUjVUN0MramNjcHliRWZGdGV1NTVqMmQ3NHdBcXR0NGdCTHRVVjRTMnZOejVHV1F0dmhUdk55TU1WK1BjSFdoaXV0TGRaUWJFWnJ4N2hpaE41RWdOelBOVmhySStpNERqSWlJaUlpSWlJaUlpUFlZTzVTdHVTMEdMdnF6THJiS2N6eGt2U3dHYzhQSW1OdjUyaXlJcUQxeStTS0dSL2JEOSsvdXE1SEVFVXBMaTJnMDZpQWlJaUlpSXVwR3VWek8zbzZPanRyYnVibTVtKzFCZDVJRUs4bTBmLzkrZXl0dFFEZlRKcFdJcU5zNUNyR1NWQmtYVHVBb1d4ak1zMTNueWJlY0JBd2xFc29DdUxHNUsxS0lBcTB6YWpOZk9BcU9xMDB4L09ydVU3ZjBKSkN5ZmxOeXFEeDBUOWpMU2hXRVFzRjg1WnVGMGpYNXQ3TGJvKzNNUVoyYWRVL2tPRWNQU3MydURvRzRycEUyNUhoUzJ0bktwMWl2L2tmR2VvOVRyUkxkWGFlRTFPekhLTkdwNzhwUzhteEZSRVJFUkVTMFZldzVURVE5NThKY0JYLzQraFNtUzdza3ZNZjFrRGd1S25IN3lpL2RKTUwrMG1Ya21pWFE1c1ZSYUJ2aFpuUDVsZEFnMTkxd2hiRThUMGJKeVJlS1pqNlJuYlpTQVM3TEl2TlVEY2RVWEx0bW1YTG9sTFYxek9WV1JrQk9rdGd1KzFaRG1JZ0k2Sy9OMkxxTjBNOGpkak1iZmwzVDFOYWNuYTlqc1JiaVg2a1FiODZXOFBxTk1uYUxSclJ5L3ZqU3hWbU05V1Z4ZUNBUElpSWlJaUlpSWlJaTJqdXlyb0x2T25oNFh4YVBIeWhncXlTNFNMejNnZTlHbURUeE82Ly9Kb2lvUFU2ZU9tMytleHI5QTBOM1BWYXBMT09WbDEvQzZOaEJFQkVSRVJFUmRhUERSdzdiMnppSlVhdlY4TmsvL3F3ZHhER0tkblpRMUxHeE1Rd1BEK01ESC95QURWbVNFQ01pb2w2VWMxWFZkMVEwbkhlR1hVYzVMdk5BdG8yMDFHMEF3YkpDNEN2TXgxclhSZ0Zwc052eXlNbXVlWjNaZC9uc0xnbDBVYVlLUXZLRUh0T09qVjZ2cURRcjNYT3FIVmo4UUNQdWc2cDdVRVYwVVloVHU0UlE4WXpTcFRubzdBMEh4UzJIK3VpVmNLMW1BcWZVbEh5cDdqcW80Z1I2cVpIR3J1TzRCZmF5SlNJaUlpSWkyakplV2hGUnp5azNJa3dzMVZBTlkrd0cyalZsY003V1I1cTlsYU1UOU5WbUVFUWMrWEtySkxqSGhnK2xHa0VtMDFLSTBSb1pLU2ZJWkpIRU1lSjQ4NVhnZGxuTTYxMDNOZlB5b1J6SHpydlRaTmtsdkNoTUc2dERKL1RrWUFGRTJ5SWJMa01yQ1pvN2ljMm9SQW0rY2FPQ3hVcUkzV2kyMGtEVzcveDVpNGlJaUlpSWlJaUlpTHJMYURHRGZYa1BPYis5ZFdJaitWRWtwbDdzMFpISFVJdXF1RmE2QWlKcWp5TkhIOFFqcDA3ajhzVTNiWDJwcU5kcU9IL3VOYnp6cWU5Q3Q1QXdKYTFUZEl2K2dVRjdLNFBkRUJFUkVSSFJ6aGtaR1VFWWhuajY2YWRSS3BVd05UV0ZTcVZpcCsxZzI0MEdnVjBPbVE0ZVBJaUJnUUZrczFsNEhydHdFRkV2c0szS0c0NENmQWM2Y0pYdk9jclBlaXJqS3VXYit4V3ppN1pmYURaNlJmb2NLSjFmZ3ZKS3BwaEtXdTBPbWFJOStmWXBhS1VkS2JvQ05qNEs2eTZpTkx4QVFSL1Z5dFFZUUYxVDJwTmdwM2FXSGpwYUlhTnRjL0NlMHdScThrdHBTaUZmaDNMYjBXOGtOZWVLTUVHY3JPd0VUMnZ0cWk0Nk81akR4VW0xeXBqbDgrSlV3NUdCejNueUlpSWlJaUlpMmpTV2ZoTlJ6MWtKTUtxakh1MldBQ092SXdGRy9iVlpPT251MkFiZFRrS0RaQVFlTC9EaG9MVjlKWVdyRW5xVXlXUk5nVzdEekNlMlFVU2JKU0ZJOG5xWmp5dGY0eDBNTUZvckdKWmxqODM3UnFFRXB1Z3RMVC9SWGljQlJuN1NnSnR1TG9CbzJkVGdmTFBTZ0lyRFhUS215ZTFtcTAzMFozdHVzQkVpSWlJaUlpSWlJaUs2andOOVBvNE5aWkgzMmx1dnNiOTR3TjZlMnY4WTVxb3pEREFpYXFNSGpoNnpnVVVUNDFkdUJoalZhbFc4ZWU0czV1ZG0wUzBPakIyeWRhamRRZ0tNY3JrOFhKZE5zb2lJaUlpSWRwS0VCa2xieCtIaFlWeWZ1RzcvbnA2ZTN0WUFJd2tyT25Ma0NFNjk3WlJkbm1LeENDS2lYcUZnZzNBYW5vTE91VTZhRDVEUCtZN3ZLbVFkUmhmdEdHbWRiRU9Nb0hKbUorWE0vcEdBRmh4TDBjaWFmWllCVWtmcnJLdFVid1lZS1hnK29JK21xckdrNEV4RDIwSzZkZ1lZeVRFZnJBUkI5WnlHa2dBajdkOVFlZ0J0WW42QzZXYWk0eWhOcFNOTzBFM2hSVUpEeWE3TVNzQlNuRW9nbXdiajE0aUlpSWlJaURhUHJXV0lxT2RJTkxlRUZ5VmRIN0t5V3FqbGV0Qk8rMDdIL2RVYnlFUlYrRkhkRmpiVDFrbkZ0ZFlKbW8wR1lqZENOcGUzOTIrMDhIUXR4TWozQTFPODZTQU9tellRYU5QTGs1b2FCTE1zZ1ptZldUSlQwZTNheXU1T2t2bG5zbXRCUmswUTBlWjRTV2pENWZwcTg5REtSYmx3b0xVWm1QTko2Z1V3bFlmbUhDK2Z4ZDExbmwrb05URmF6SUtJaUlpSWlJaUlpSWoybG1OREdiem5TQkdGb0wyRGV2ei8yZnNUd0xxdSt6N3cvNTY3dkIwN0NJQ0xJSXFpS0lvU0xWbWJaVnQvVzdFZDI3R1QyRTJjTlBFa3NaT21icWRKKzg5ME1wMjIwK200bWJhVEx0Tm1ralJOUFduaTl0OXhPckdiT3J2cjJJN3N5TFlpU3pKbFNSUkZVaVFGZ2lEMjlhMTNPLy96T3crQUFCSWtzVHdBRDhEM0kxM2VoN2ZjZDk5OTc5MTM3MW0rWjhGdGJYZWdNN3ZQbHBpT2xvWnhhZm8xeEVsczZuY2EyUzJCYUcvcFAzeW4vVTU5N1N0ZlhMd3VpV01iWWpSOGRRaG56NXhHYjk5K3RMVjNnSWlJaUlpSXFGbjV2bS9PWFhydGZIWjIxazZEZzRPbzFXb1lHUjFCSE1Xb1ZDcG9oUDM3OThOMVhSdzhlTkNHRi9YMjlwcHpwamEwdGJYWnY0bUlkZ3ZmdGMxWlZWK0xtM09nNERxU0VxTThWMG5iVmdaL05KTjRmbjVWcVp6ME5oaFRXcWUwZGpPbTVLOFZxcHBKRUxWQVNmQ1VwTGlrc0VzNENuN2VGR2ZlbWFBMFppNmJLU1cxQlkxb2RXMCs2N21NbGh3anVZaGRJVmFvU01lVWMwb1hBalQyVmNWYVI3VW9LWVlhRXByVnRKK3hJTmJWU3F4clp0K1dkYUYyelhlQmlJaUlpSWhvcXpIQWlJaDJuVmhMOHZVT0NYU1FBQndaZWRGcFhHUHRiRENIVkZpR2w0U2d4b3JqQ0VrU0x3WVlyWVdFR0xtZVo0T0FaQVJRcFdJYmpMUWU4cmc0Q2hHYlpia1NSTC9KNFVVMmdNazhoMjhEazh6M0t3eld2ZTVFZTUyall6dEowSnpzcjljY1lJVDY3NFkyK3lQN0cySy9panZuKzFnT1lsVEQ1aGtGbVlpSWlJaUlpSWlJaUxaR1R6NkZPenF6eUtVMnAwNmpNOWVGbko4ejlZUVJYRlB2ZG5ubUVoTHpIMnN6aU5hdnRiMGR2WDBIYkIzbkFxa2pESU1Bc3pOVEdCMGVzdUZGRFJ1S200aUlpSWlJcU1Gc3UwM1hSYUZRc0pNTUhDbVRXQWd6a2lDalJnVVlTVkJSS21YS1FJN2NnVnd1aC83K2ZoQVI3VWF1cEJlWmYxcFRUbnI1TFF3dmFqWUxaZVJGcGUxN05Xc20zMHpTR3lMV09teHhWQzJUU1B0bXVMdm83Wk1XMWw0S0NIdTFVeXVyeEprd1Z6WnF1QU5YNjVUNStPK3FnQnNORmNxUTMyTkt0elYrV0FpVmhER3FTWUxON2ZTeVFkSU5MWXgwMWV6Z0dGNUVSRVJFUkVTMEFRd3dJaUxhSm9tcHBEUWw5MUxZaDBicW1ua2RiaEtBR2s5R0ZKWGk3T0xjckEzMHllVUxrSW9XdGNxM1VObktHdGVPcEJQN1BxcW0wbHNDa2RZckRBTkVjWVIwT2d2ZmZKNWtuWlRhbkpvREcySmsxajJsMHZCY0Q3VnF4VDQvRWExUFcrbXFEVEVhNlRpNnBzZlZRNHUwRGI1TC9KU3BMZ3FnR0NoR1JFUkVSRVJFUkVSRVRhb2w1V0ovcTQ4MzdjL2p3WU1GZU03bTlZREkrRmtjYXV0SFc2WWR0N1VkeG9zanorUHEzQ0NtSzFPSUVnYXJFNjNWaWZ2dVIvL2hPNUhOWkRGOXpXMURnd1A0MXROUG9hdDdIM3I3OW1NN25UbjlJc1pIaDlFc3JsNjVqUEd4VVFSQkRVUkVSRVJFMUZ6UzZiUU5HSHJrMFVla2h6cmU5dmEzSVk1amN3dy9ibzdoQTh6TXpOaEFJNW5DTUVTU0pKaWNuTFQzV1hpc2hCUXQ2T3pzdEVGRlBUMDlTS1ZUOEgzZlhpLzNJeUxhelJRWVZiU1RSZWJObTlWQTBkRUZSK3U4YThmaVZxcFhLK2xrR0IzU2FpeHRpdHd6UUFkMk1BZndNMXEzM3hHcldwL0M5SGxINXlZVVV0SjdZejB0cjMzeklMTk5zSnQrNWMxTGtvYm84WXNxeVZlaFZiUUozK3hFYTZjV2F6OU9tcnNQYTZoMW9pTWQ1OU51a2dZUkVSRVJFUkd0RndPTWlJaTJqUUkySVd6R1RVSzRNUnRoYnhvdDJmS0pLVWhkdkFLcnJZSlpDQmV5WVVBMmJBZ2JJaU9jbWhyeStqcHNRWURKd25yYjU1SXdKak5wQnFjUXJZc3kreEhaWDYvdndXcSs5bmYrZDRSZlF5SWlJaUlpSWlJaUltcFNydlFRTVAra3pKVHhObjl3WGMveHpmTmtVVWkzSU8xbDRDclBGS00yOWFDK1JFM0w4enc3TU10S29paENyVnExOCswV0JvSHRhTndzcEdOejJFVHJRMFJFUkVSRWIxRHo3UjZsSGFTRURXWE5mM0lNTDRGRlFTMndvVVVMQTBtNnJtdHZrM01qK1Z2dUw5UFM4eVFKTHlxMEZORGExbnJEOHljaW90MUliVTQzQ05vaXR0bXhlZjlpOHk3RzVxZHhvVFd6eEhISDBqMUJJVXJNYkRlMFQzWk1CWUZ2K3p1b3hJZldHLzNZU20zRGJ2cm8yN2RZSzExVDJnbk1BYzltdmVWNkJ6UjR0MTF6WkZoaHRzc25JaUlpSWlMYUVBWVlFZEd1RWNRSnFxR3BTSXhpN0FRNmxZWDJmQ2tWUlNPNHNhazROVVZtQjhkZkJtMnVPSXBzaFhTNVZJUnJHKzVtMS9SNDE3enZNbENCS2U5SG9oT1Vpbk5ZTHlraHJaUkxxS295V2xyYm9Femx1ZU80MkN5Mll0Njg1bXcyQjIxZXQyeURtSUZaUkd1MmIrYVNuWis1L2J1a1VnYVJ1N2J4T0xSckR1TXplUnRpcHBLZDhidEhSRVJFUkx2SHdLVUx0cFBxME9BQUdpMWZLS0NydXdkdDdSMTJJaUlpSXFLZDdWaDNGaDk5Y3krTzdWdGJYY3BHWlAyY25UNXc3Qy9adjA5ZGZSWXoxU2s4ZmZuUFRUMWlGVVMwT2oxOUIrejh4SnZlakZaemZ2YnE2UmNYYnp0MzVqUkdoNi9pL2djZndja0hIZ0lSRVJFUkVkRk9KVUZGZlgxOTluTC83ZjBnSWlMYXE0WWx2a2JCRzRTK1RYcTRTSWZETnFEU2thQjZFRXBsdFZLZTFpMXFoNDBhNEp0VjkwM1Z3Ukd0U3ZzMVNpK29wRDFZeDJ0SUExRTdWSml0YnhvZnU4QVY4MFpQS3EwbWJLRFY1dEFhcVNqUnZXaHljUUpmUStlU2hIMXRpWWlJaUlpSU5vSW5WVVMwYThTSktVME1Jb1NteEtqWjZXVkREalFtd01pUGEzQVNCc2xzcGNSODFod3pTWUNQVWk2Y3RZWlJTZGlRK2JnNmJqMXdLSW5YWCt3clFVWnhFa1BweEs3THBvOXFJU01Sb2I3dXBxQjJRK3RPdEpmNVljWCtKcXcxd0VoSThKR0VpdG41YmhqbWhJaUlpSWgyaklueFVSdnVlL3FsRjlCb3VWd2VMYTJ0YUd2dk5GTTdPanE3a1VxbDBON1paZVpwTzhvdEVSRVJFVFUvejVSZDVsSU8yck1lOXVWOTVQM05HM3poVmdxcEZqdnZLeHhBRUFlWXJFeVllcFhZWGlhaVcydHRhME5uOTc1bDEwVlJpRnExZ25LNVpBZHJ5V1J6dHROdnMvSE4rV1E2a3pIVnNzM1JwMG9HbzVIMThieGQwYitKaUlpSWlJaUlpSWgyTWVtVkUybzRaUVZ2VWtObGxFWmFtaTVyalJ4VTRFQXJSOE5WZG96a1RlKzlzR0VldEpPRzh2SmFKU21OcE9pc3VVK2xOcVY2b2RrTU95ckFhU1doMWttc0VGZk1hNnFhMTVNMC9idTMrY3duMkRFZmJTL1J1dmtLdW9tSWlJaUlpSFlROXZZZ29sMmpXQXZ4K2xRSjA1VVF6VXc3cmd6WlVwODdqU3ZiS2xUR2tBN0xvSzBoZ1VGUkdOamdIZ2t5a3NhdjBwRnlMUlk2WFdaMXppNmpVaTVoSXlybHNnMHphV2xOU1ZJOU5yTWVZS0VCY2lhZFFhSVQyekNaaU5hdW8zZ0ZzZU9qa201YjArTWdBMys0cHVyUDhhRGNHRnFDMUJoaVJFUkVSRVJiNU9tbnZvcVo2U244MjEvNlo5Z3NiZTBkZG5yMys3OFh2WDBIOEtHUC9LZzUzMjJ6RXhFUkVSRTFQd2t2dXJjM2o0Y1B0ZUpkZDdaak94M3R1dHZPRDdiZWhtSXdoNjlkL0JLcVVRVWp4YXNnb2x0NytDMXZ4K0RBSlh6emExOVp2SzVVTE5wcDROSUZYRGgvRm5lZnVLOHBBNHdrRkZmT0tWV1RCQmhKYUsrc1R5YVRBUkVSRVJFUkVSRVJVYk9TRnNreXZQR01Rbm9HU0Y5UjlUYktMV2FXVW9qdjFKaEthYmh0VUhrWmZWbEJyMzBrMXkxVzBFN1d6TEozSzB5YjE1WjhDN3B6TFkvM3RRcGJnTG1NOU5IUVdGdkhrU1pUVWFvNnJYUjV4TkdGS1lDRmxaRCtRZlk5VFNzd3pZbUlpSWlJaUdnakdHQkVSTFRWVElHbEJFNmd3ZUV5NmFDRVRGQUViUzBKTXJJaFJtYUtvd2lPNjY0NU9NaHg2bytSdVpiL2tnVHJvcld0TElpQ3dEYkM5ZnpOSDdsVG1kY3JrZnV1SFNWVTIyMUFSS3VYcWMwaDlEWlFoeVg3RGRudkpCR1lYMFJFUkVSRXUwa1ExR3hZN3F1blg4TG84RlYwN2V0QloxYzNIbnIwYlRaRXVGQm9BUkhSYnZLTmk2TW8xU0xNVmdNYlRpN2xqZ3VrN0hCcGtXT1MxRy83b1FmdkFCRlJzMnJQK25qZ1FCNkhPNXFuM1h2YXk5aDk2cDJkZDZNYVYxQkl0YUJvNnRZazFLZ1dWUkFsck9NZ1drbG45NzRiRHNRaTRiWWp3ME80ODlqeE5RLzJzaFY4MzdQbmtFNlREQUR2bURwY3V6NU5FcWhFUkVSRVJFUkVSRVMwRmxLS0x1TXNqeXFkY1JXY1dhMWNYeWNxcjFTVWdnNDlyUklmT3FmUUpBVnlLOGlhWXNQWXZJaThodlI4Y0dybWRhem1jWEtuaklieWQzQytUYXgxb3BVS1pPanFjZWhNb0xYYnhHOFZFUkVSRVJFUjdVQU1NQ0lpMm1JU1hxUzlWTU1EalBLMWFSUXFFNkN0WmNwd1RjbDFnb1dnOVpTVGxrRUUxcklJR3pTVUpFbDlIc2VJMWhsZ2xNdy9ybHFyd0hXOUxRa3dzaU9wbWtsR0NaWG5yekRBaUdoTjJzb2pDTHdjMWt1NzlVQThKZDg5emU4ZkVSRVJFZTBlbFhMWlR0LzQybGZzMytmUHZvTGV2Z04yeWhjS0tCeTlHMFJFdThubnZ6T0E3d3hONGR6b3JBMHFqK0kzeWdnZFJ5M3I1QjZiTWtUSk4yS0FFUkUxczQ2c2l4KzhyeHZ0bWJYVm1XeW0xblNiblQ5K3VBZlZzSUxoNGhBdVRiMkcxNmN2WUx3OGhzZzIyU2VpYXgwNWV1eUc0VVFTT0h2dXpHbTg1VzN2UUROS3BUUEk1ZkttTHFVNUFvTTh6N1ByVXg4Y2hvaUlpSWlJaUlpSWFHZXAxUHRNT0VXZ1h1Q3VFaFJNMVdZWEVIWW1LQllVcXExYWhraEc4NHh1Y0kwV3JmSXk3ell2cDZyaGpDaTlxbVQybElKcXNZRk4yTG5wNUVyRkpZWGltTks1UVlYQ1lpY1lJaUlpSWlJaW9nWmhnQkVSMFpZeUJYeXVCQmo1RFc4a21hdE1vcVUwQXRvZWNTU2RobXEySTVIakpPWnQ5dXdvdnFzbDkwMm4wNGptQTRBa0RDaEpZcXhIYkpZaEk3UlhxeFY0V3hSazVKblB0RGJySE02SE1Va1FFeEhkbXV5M3E2a0MxczFVOFducHdPaVkvVTBpK3h3TkltcHU1WExaL21aT1RrNHNoZzhTRWRIV0tSYlpJWG16blh6Z0lmUWZQb0sxa2pDT3ExY3VZMko4RElNRGw2NjdYVzRyenMzaVAvN0d2OEZkZDUvQWovMlZRL0ROT2FqdnAwQzAxd1RtK3hLYnNwK3N4eXFlM1dTaVZNUHdUQm5qeFlvTk1GcDZ2aUJsaDJwSmdKR1dBQ01RRVRXbmxLdncxdHRiY2JRemd3T3RhZnQzTTBwNWFYVG45aUhqWlhDbzdYYU1sMGRSck0zWk1LTTRpV3k0RVJIVjdUOTRtNjE3N09ydVFSRFVNRGM3czNqYlpYUCtGcHM2emIvODQzOWwxY3ZyNnQ1bkF4cFhjdm5TYS9aNUpEVEoyNkxqM1h5aHhhN1QwdU90QlRQVGt6aDc1alI2Ky9hanJiMERSRVJFUkVSRVJFUnI1U2duVVhDa2FxZDUwdDZKR3FpaTRJNmI4c05aRndWZkk1ZUc5cVJxWUo5V0pTbHhhMC9NRlVwNXpSWnFkTHRXZnRHVWZFWmFCVlZvcDZSdTNzZlMxVWlaMTlmcXFKM1hGOVBzZ0hTZ2RXbk83SXd1S1JUbXpGdUNMUkNiSjA1WXNVMUVSRVJFUkxTbnNIVTdFZEdXVWRMVHBENjVqZC85cHVJS3Nod1pkdHRvblNDT3pCVFhBNGpjTmY3RVNpY2tiNzdUWlgwRTlmV1gxTXBqa3ppeFFVWmlLd0tNSEFsUk1hL0J0Wi90aUFGR1JLdGs5OXRxQXgxNEpBeFBMY3lWN2VCSVJNMHRDa01iV0RnOVBiMFlYRWhFUkZzbkNBTFE1cEx3SWdreFdpdDViMXdaZ3c5NnhRQ2oyWmtabEVzbFBQM1VWMUVxRm0zbldBa1Izb0pUWHFLbUV5V0pEVENpM2FVY1JKaXRoaWpWd3ZyNS9kTEFVMXV1UE4raFhzb0JXUFpHUkUwczVUazQxcDNGNFk0TU9yTE4yeHpCTWZ2VlFyclZUcUk5MDRHaUthOHRCck9vUlRVR0dCRXQwZGJXYnM3SGlzZ1hDbkNyN3JJQW84bngwZm9nSjZiY2M3VWtNS2hhcmE1NG01U2JqZzRQMlhQTHJRb3d5bVF5ZHAzY0ZRS01hbVk5Wlgwa3ZLZ05SRVJFUkVSRVJFUWJJaFY4elpuNFRyUUJwdVpTU2ZoUFNmb29LZzBKTDVLU05sL3JRSzVvVlNxSnRNNjRxcmsrL3UwYVVnS1pUQ2pVNUt0WnVzVVFNcmFyaEVJV08xT1NLRld0UWZ0alNyZHRSVzJ6dm1aT1JFUkVSRVJFZXdNRGpJaUl0b2lFdTJqZmgzWWFPM2hDT3BoREtxekFqVmJmS0pRMlQxQ1Q4dXNBY1p6WVVLSWJqUjU2STBtaWJRZk1aSU1GOUJLb0ZBYUJEUktTUnNOS09XdGVsN1UvcDY2UEJ0OWtsUXRFelU2WjcydExhUlNobTBZMXM4Ym03L09oUllucjI0dE9VQU1STlJmcHVGTXBsM0gxNmxWTVRVMWkya3dTMEhDakRqcEVSTFM1eW1YdWZ6ZmJ5VGMvak8vL3dSL0JXa21ZYjdWU3RoMWhweVluOFBSVFQ5cXdvZ3ZuejZKVXJBYzJKK2I4ZG1SNENQbnpMZmpTRi80QUorNjdIL2VZaVdpdnFjVVJBdk9kYVVtbFFMdUhsT2ZwcGFGRlJFUTcwSUhXRlBwYWZQemtRMzNJK0E1MmtsWlRObHRJdGVCdC9VL1l2Ky90ZmNEODVsWXhPamRrZzQwazBLZ2NsbEdMZHRjNVJWL2hBRklxamM1MEM2cnVESVp4R2tRcmtUQWhDYXVkR0IvRjZQRFZ4ZXZIeDBidE9kencwR1ZJVjVUZXZnTzNYSmFFQlZYTStWK3pTS2ZyQVViSzJWbjdMU0lpSWlJaUlpTGFNYVFDS05IMVRCZWlYVS9DY2VSRGY5bEJ3VEZsaGtOYUkyMUszd3BtM3FVUmQwSEZudGErMHdTZERuSm1IWTVxcE1haEhTbjlsMWJZMFRWckpYKzJhb1hjRGszaU1lOUZFSm5aS3lwcGs1NHVNdXptbHJ3VTh5UmhiTjV3Vm9IVExxQ2xreGd3Ykg3TWl5QWlJaUlpb3B0aWdCRVIwVlpaR0NXN3dlV3NYaHpBajJ1bVlKUWxlODBnbWU5a2xDU1JEUTFhVDEyVExZdHZ3TWRFT2oxSmdhK0tIYmlPRkQ1dmZobS9EVEJDUGNSSUFvMkk2TmFVK2E3SWZqeHgxeGx3WjVPTEpNaUlkZHRFelVqQ0JLTW93dXpzRENZbkp6QTVNV0VEaklpSWFIdG9MZWRGREYzZFROMzdlbkh3VUQvV0t3aHFOdnhQT3NTKzh0SjNiQ2ZaQlhMT1hhdFdiYUNSM041LytBaUk5cUxZbkVmR0xIZlpmVFJIbnlTaW5hK1FjdENlOFhGSFp3WTdUY3BOQTZhSU51UFhCMDlPZVdtVWd4S2lXTXB4bExsOUFwV3dndDBtbHlvZ285Sm8wKzF3VTZ4cnBCdnpQQjl0N1IzWEJiTlhLL1h2aFp5cjFWWVoyaTduZWE3YjJFRi9Oc0l4NjdMMDNKT0lpSWlJaUlpSXFLR1Uwc3BNSU5wRDVBTnZTZ3Q5KzRjeVplOHlXS3V5SVVCUzA1M01WNDF1ZXdNZVIwUGxUZTNBbktwM3NGeXBaYWUwenZheG94UElFaGtxM2J4R2Y4dkNpeGFlV050eGVvbDJBUzA5czZxT1FnUWlJaUlpSXJvcHRzQWhvbDJqTFp2Q2lkNDI3TXVQb2ltNVBuUW1ENjBZTUxFWEJMVWFtb0dNMmg0R05ZUWdvdDFNK3hsVE8yWnFlR3E3cndNTjBVNDNOVDJOYzYrZXdmRHdNT2JtWmtGRVJFUTNsMHFsN2ZRRFAvTGorT0NIZndoLzcrZitHbDQ4OVJ5R0JnZHNLS0M0WWk3LzIxLzZaL2p2Zis1L3hpT1BQUTZpdldhNldrVXhESENnMEFMYWVTU29iV3B5M0p3alhNRzVNeTloNU9vZ1ptZW1jYis1N1g0cE91NWMvYkwrajAvKzdjWExoL3J2d1AwUFBvYmJ6THlqc3h0RVJGc3A1enZ3SElYLzg0TjM0a0JiR3J0QmU2YkRUZ2RhRHkxZVZ3NUxDT0lBQTlNWFVUR1hMMDFkUUpTRUdKd2RRS3hqUkhIejFjYjRiZ3FkMlM0VVVnVjA1M3ZSbGR0bkxyZWlyN0RmaGpXbDNUVGlLTWJ3d0NXTVZRZnhHdjRDUkN0Slp6SjQvSW4zbU9PWGwvSGxML3pCZGJkLzVZdC9iQU9PNUR6dFZsWUtRbHBRS2hZeE16MkZKSW14V25MT0tJOVp5Y2tISHNKYkgzL2lwby9QNWZKMm5Sem4rbEFsQ2FPWFpVdDk2Mm9ObXUvVHE2ZGZNbys1dnJ0VFQ5OEJ1eDJKaUlpSWlJaUlhQS9SU2lzNE1VZXlvTDJzcWlUUVNHUFNoZmNxdEhkZm90Qm1yaS9vNWdnRzZ0VXEycGVvOEt5ai9WR3pma1Z6WFR3ZnIyUm1jYS9HZUt1R2pON1FoaDNtbEtNekpUT2Y0WGh2Uk92bTJFdzJkU2tCcGtGRVJFUkVSRGZGQUNNaTJqV2tQRTBwWmFkbW8rZkQ0ZXZ6eHE2Zk5xODNhY0xYVEVSRXF5ZjdjYjJSS2poNXZIN2o5MGF4cHB0bzIybXQ3WlRFTWNJd1JKSndCSHNpSXFLMXNHVThqb09XMWxZekxXLy9aWDlqNXdON3krVVNVbjRLbnUrRGFDL1FkcW9mYTlMT0pPY0gxVW9aWWExcUw4ZHI2SngvTTFFWTJIMWl0VnF4KzBjL3RUc0NSSWlvdVMxVVQvVVVmSGptRDlkUlpvNWRTNDVSSGVVZzdXYVE2QWc1UDQ4b2lkQ2FhYmRoS3hKdUpML1RjbGtDalVReS81dXR6ZDl5V1MvOG1tL3d0OXh6M21qcVlZNmNGNE5YekNYelB0UXZ1OHExQVVZdDZWYXpyamxrdkJ6U1hnYSs0OXY3TldPZEtqVzNiQzV2enIxU0s5NG1ZVDJyRGZueFV5bWtVaXVmdzhWUmhDaGFXeGlZbkI5ZVcvNXFQOStyL0l3N3JtdlhhZVZseDNaOTFuTE10bkRPdXRMNjhIdEhSRVJFUkVSRXRQZVk4b0I2b1NBUlllSExJSUZHYVZPT2xwMXY5OXdNSVVibXU2bzhzM2FtbGxXWDVrc1hGNzY0cm5UYndjNFNvRjRSRVpsVlordFZJaUlpSWlJaTJpb01NQ0tpWGNOM0hUdWwzR1lvdnJ5R2E0b3lQZC9PR3kxMHM2WkkwVU9pdUVzbkl0cUpKSWl1bG1wRjVHeWd3L1hDcU1EeU95UDFUVWtFSXRwZUVseFVxVlF3T1RHT1M1Y3Vnb2lJaU5ZbW5jN1k2YnMvOENIYy8rQ2orR2UvOFBjeFBUbGhiNVBmMmJuWkdadzUvUkwrN0l0L2JHNS9CSWY2RDROb3Qxc0lQWkE1R3hqdVhNVzVHVHoxMVMraVZKekR4UGdvR21YNDZoVTd2ZW5CdCtDMi9pTTRjdlE0Q29VV0VCRnRwcFNqa1BZYy9OemJEK0srdmp5T2RXZHRYZDF1bGZWeVpnSmE5OVVETmgvWS8ramliVUZjUXprc28xaWJRekdZdzJSbEhHRWNZTFkyYlVPT1pxc3paaDZhMjRyMnZoVnozL1dTOEtLRHJmMkxmeGRTTFNpa1cyeElVY3BOb3p2WGEwT00rbG9PMk1BbHVlN21HaE9tUjd0YkxwZkh1OTc3QVRQUHJYajdhK2RmdGZkWmplTW5UdDd3T0VXT2ovS0RCUnRrdEZweWZpakhWa3VsMG1sa01tYWY1TjI2RHYzQXdkdnNsRm9oeEtoU0xtTm84REx1TnV1OFdsVlRMaXpydERURVNFS1M1RFZuczFrUUVSRVJFUkVSMFo2VEtPV3dFSTRJOVVBZ0tmbDdSWEs5RlBCUW9pQWxqaDNiSFBGbFZzVlQwTjdSUklWM0tsVjd4a2xTVTZaWVQ2TFdQVk5KMzVXbzJEZmZaZXlnRktQTENrRlJJUmxUeU1UWVNXdE9SRVJFUkVSRU94blRMb2lJdG9CMkhCdFFzU25MVmc1aTVTSnkwd2pONU1lckc5bVNpSWkyWHppLzc1YjllTElRUXJRQjhuc2oxWHNjS29Obys5bUs5amhDSExQdENSRVIwVVpJQjg5YWV4WGVDcDFPb3loRXRWb3hjd1o0MHQ2Z3RVWnNRNHpxNHZxQWlYQVYyeHJ1SkRwSlVEUDdyaURZbkhMY1NybUVpZkVSN092cHM2MVE4d3d4SXFKTklEODlVaExaVjBqaFlGc0tYWGtmZWQrQnM0ZC9rNVRaSWhJc2xQWXlTSFNNU0xlYnNxSFFYaGNuTWJKZTNsd2ZvUnlhNDlja1FDMWEvKytBNS9qb3l1MWIvRHZyWjgyVVI4WkwyOXNreUVpWjkwTENpeFQ3SkZDRGVYNEtuZDM3N0RHSGhQc3NtSnVadHRmSitabDgvbHozMW5VZWNwd1NtekpVQ2Z4WklFRkVNOU5UOW54dnRlVCtFaGkwVkRxVFJWdDdCMXh2OWMyaUpGeEkxbWxwR0pLc2h5eGZqdDlXUys1NzdXdndQTit1RDQvTmlJaUlpSWlJaVBZbXJmVTJ4N01RTmFleXFmMldGcFl0ODZYWkcyOUp2V0ZtTlpTVE42dVZhQ1FUamdRYjJYU2psQXNaY2J6NXY4cVJsaHBwSkZXejRsVU5KMkUxQWRHR21WOXhVL21SVE1kd3FpQWlJaUlpb3B0aWdCRVIwU2FUZ0NHZHlrSTdtMU9jR25reWFtb2F4V3dISEIyaGMyNFFSRVMwTTh6bDlxSG01eEdrVmpjcThhM0k3dzJrMmlrTVFFVGJTNEtMS3BVS0FnWXFFQkVSYmNpUm84ZHc0RkEvZk0rLzdyWlNzWWpSNGFzMnhJaG9Md2pOK1o1TXlYeWJ5SElZMnM3aEJkOEg3UnkxSU1ESThCQTJ5N2t6TCtIYy9PV3U3bDY4NllGSFFFVFVhSjc1L2NuNkR0NTdyQU4vK2Y1OU9OeVJRVDdWQk4wS3RwSHYrbllxcEJoT1FydGJhMXM3M3ZyNEV6aDc1bVZ6M0hGNjhmcG4vK0liZGk3aFB4SWFWTGhGVUkrZlN0bnp2YW5KQ1F3T1hGcTgvc0w1czVnWUgwTVVyVDRZL3NWVHp5RUlsdGVMOVBidHg3SGo5OTV5UFpicXYrTW9NdG1jWGQ2Q3lmRngrL2ZiM3ZGZHExN082NWN1MnNjc0Rkdk5Gd280K2NCRDl2eVdpSWlJaUlpSWlQWVdVNStubDh3WkpVSzB4RGxISTJQbTdZbUNhNzRoaldsTnZYNm0rc05UMERpbW5WbFRRaGw5RlVtbnFZMzNzc0MrblJCZUpJb09KREsrTmdMZGFpNnozeWhSQTJpRkl1Q2Mwb2lHUVVSRVJFUkVOOFVUVVNLaVRhVnNLYVoydmZwd3RKdG9zclVmcFd3WDh0VkpLSzJSaXRoNWo0aW9XWVV5Q3JkeWNMWHJPR0kzaFVhcC85NUlvMzc1emVHQVBVUkVSRVMwOCtVS0xVaG5za2huczBpbDB3aHF0Y1hicEdQczZQQVFxaFdXZ2REdXB1VS9YUTh3cXNVUkZnWm9EWk1ZamlselRMUm5peDRWMnp2VEVvTURGekV4UG9yZXZnTndYUmZkKy9wQVJMUlI4a3VUY2hYdTdNcmk3YmUzNHRIYldyQXY3OXZyaUdodnlHUXk2RDk4NUlhQmpCSnMxTkxhaHVNblR0NTBPYjZmd2wzSFQyRGc0bXZMQW93a3BIWm1lZ3BUaytQMnVXUlpOMkxQQjZ0VnV5NFNLTDlVVzN1SFhVODVuMXl0Tys0OGFoN1h2aXpBcUZpY3hjQ2xDeGdiSGJYcmxUZm5xSjYzY2xNcnVWMm1xMWNHN0RvbFM5WXBZOVpEMXFlcmV4K0lpSWlJaUlpSWlJaW9MakZUYUthcnBrNDhhNm9hTWxyQndmWW5mYmthYVFmYXZ6TlI4Znh3UWswL2lrTmsvcThxSFk0cTdjd0MyWUFOQ0lpSWlJaUlpR2diTU1DSWlHZ3oyWjVEcGdqVjNmemQ3VVRyN2Fhd05rSC82QXR3ZE13QUl5S2lKaGE2YVJ0Y05OeDEzRlM1TmJCK2FDRXdUeWJibjVVaFJrUkVSRVMwc3hVS0xYYWV6ZWFRVG1lV0JSZ1ZpM01ZR2I2S2FxVU1vbDFOMTBPTUpMQW9pR01rOHdGR1VaTFlBQ050NzZBMk96K2RkaGdKTUJMSGpwOUVLcFZtZ0JFUk5ZVDgxcVE5QjNkMVovR1g3OTludzR0NkNvMExhQ2VpNXBlZUR6Q1NvS0tWbkR0ekdqMTlCMVlSWU9TYjQ1UjdVYXRXbDEyL0VJdzBQVGxoendkdkZtQTBNaDkySktGSDExcGZnTkV4Yzh6VXUreTZVckZvcC9IUllmdGM4dnB2Rm1Ba1lVZERWd2F2VzZlRjdjWUFJeUlpSWlJaUlpSWlvamNzQkJnTks0MVdVK2U5Zi83NjdVNEw4aFRTRXFOMHAwYWd0RlRHTjMrQWtkbU84UnhRR1FQeUUzYjlpWWlJaUlpSWlMWWVBNHlJaURaUklvMFhKY0JJYkhJUG90aHhUUUd1Z3d2N0g0V2JSTmczZlI1K1dFV2hPbW4rRHUxMVJFUzBQYlQ1RFVpVWkxSzJDNVZVd1liT2hWNFdrYk1KaCtQeVhPYjNSeVVKVk14OVB4RVJFUkh0RHZzUEhrSWN4NWliblZtOExncERsTXNsUkJHUGUybm5rekNpV0Njb0JvR05vcTMvclcxZ1VaMWNOdGNsR3ZGOFdPMUVwV0tMSE9jQ0NmYXFsejM2cmdQUGxFZTZqclNoVkdoTnBVeUpvWUxuTm4xN1N0b2twNTUvR3BsTUZ2bEN3VXl0Nk96c0JoSFJlaHhvVFNIbk8vakxKL2ZoY0dmRy9KMUcxbk5BUkh0THdSeFBIRHQrQXQ5Kzl1a1ZieDhjdUFSbkZjZWV2amxPZmV6eEoxQ3RWcEhOL1pFOXZ3dkRjUEgyejM3bVArRGdiZjM0eE4vOGViaG1lUkpvdTBEQ2JDWDQ2TWt2L1FtR0JpOHZXNjRFRmtudzBkMW1IV1g1Y2d5MFdnODkrdGI1OWNuWjg4K2xBYnJmZk9wSmpJME80Nk1mL3dUNkRoeXlJYnRxdnY0L01NZndjcTU2NnZsbjhNMnYvWmtOTVZxcXE3dkhoaGV0ZFgySWlJaUlhT2RZT0VhZG1oeEhraXdmYkt5dHZSMjlmUWV3VVhLTVdxdFZNVHN6WTZicDYyNlhzRXpIbEF0M3NQeXY0U3FWTXJRcHJ4OGNlUDI2MjlvN3U4dzVTTUdXd1RvT3kwbUlpSWpXUTQ2ZTdMQlZTa05pd2R2TkZhMW9qdEY3RkxUWEpLdHlRd2tRUlZyWEpoM3RYSUxLenluMkZTVnFOS1ZWY1U1RlozSjVGRUZFUkVSRVJEZkZrMUlpb3Mza3VQVUFvNjBZL3R3OGp4VGVqcmZmQVMrdUlSUE1JaFdXa0EzblRHRkpBaGZzekVkRXRIMU1GWlp5VVU2M29aanR3bVRyYmFpbFd1eDFqWDBhSldsSjlkOGZyVUZFUkVSRXRGdTB0cldiYVdiWmRkSllQd3dDSkVrTW9wMHUwZlhBb25JVUxnWVhSWWxHSlFwditKankvRzJsSlIyOVU5SzUyMHllNDhBeDU0aDV6emZGaGszZW9wSTIxWldCaThqbThwaWFuTEIvTThDSWlOYXJJK3VoTStmaHU0NjJvejNqMnIrSmFPOXhQUTg5ZlFkc1NOQks1SmhET3ZEZVNpcVZ4cEdqeC9EcTZaZnM1U1JKZ0NYSHRTODgvNHdORExMbmZPWTVsd1lZU2Nmd1VuRU9GODZmeGJrenA1Y3QxL05jR3hLMHo2eWpMSDh0RHZZZmhqYnJJZXNUbVdQdHBRRkc1ODY4alBIUkViejcvZDluQTRta2MvSkNnSkdzdTZ6UGxZSFg4ZUtwNXpBelBiVnN1YkkrYmUwZGExNGZJaUlpSXRvNUZvNVI1Wmh4cFVFWEdoRmdwRTBac2h3Zno4NU1ZWFQ0Nm5XM1p6SVpjenpzb2FNVDFHQVN0aXJuQ3FQRFE5ZmRsa3I1U0tkUzlqeUNBVVpFUkVUckk2MmRRMVBVVmpNWFpzMWNTZ0pibTZRSnRMTTRtbmxUMDVGU3RUS1FubkIwRmtUVWNGb2grdlJQUGprTUlpSWlJaUs2SmJZcUpDTGFSRHFkM1pyd29pVWlKMlduUzcwUDJyOWZPL0FZTW1FSnFhZ01KNDdnbUlwc0lpTGFHb21wdDBwY0Q2R1RRVFZWZ0haY3hNcEY0bmlORHk5YVlINTM3TzlQVUlPNlNVZFhJbW8rN2UwZFptckh2cDU5eU9VNUVqY1IwV1k0L2ZKcGpJeU1nb2lvMmZqbWZORTM4LzM1ZWtkd2FZOFpKVEVxVVd3N1JFdW9rWVFaaGRJNVdrS096THdqbmJZaFJZVlUyajdHTWVlZ0N3RkdDeVdTcm1KNEVRR1ZjZ2xmK2VMdjQrQ2gyMUY4b0lqdWZiM1laeVlpb3RWNDg0RThXdE1lL3ZIN0RrTXk4VzVyU3pmVjcwczhlczc4YUFZcjN1YTBINFRLdFlPSUdrYzZSUjg0MUkvRGR4N0QzU2Z1dzlDVlFjek5UQy9lL3BVdi9qRWVucDI1NVhLa1kyOUxheHNlZlBReC9KMS8rRS93bGYvMlIvaXltUlpJT0pGTTczLzhmclMxZDlybld2RGEyVE8yWTNqWkhPUEl0TlNKa3cvZ1kzLzFaM0QzUGZkaHJSWkNtV1I5enA0NWpmL3dxVjlkdkUxZTU4andWZnoxSC85QlUzYWJ4LzBQUG9wMHBoNnFKSUZGWjE3Nnp1TDZTTmp1VXJJOENUQWlJaUlpb3QzcjVSZFA0Y0s1TS9pUHYvRnIxd1ZhZnZCRFA0UmYrQmUvZ28wYXVIUUJ2L09mZnNzKzEya3pMY2liNDFqWEhGLy83aGUvQWNVQW5VMXg4ZnlycUZhcitQOSs0c2V1dSsxam4vaFp2T1Z0NzdEbklpMHRyU0FpSXFMMXE1cXFod0ZUTDY3TWY1TENJNlZ2UHVobUlxVm1KNkM5bDFYY0hzaUdBOXNIRURXVVJxUVZSc3czYXh4RVJFUkVSTFFxRERBaUl0cE1ObkI5YXdzQjlYeWo4Y2lyTjVpTXBPaldySWMyaytPR2NCSUdHQkVSYlJYWko4ZHVDb0diUVRXOWhZMVU1UGVIblZTSmRoenB0T1A3dmgxTlBKZkxnWWlJR3MvM1V5QWlha1pxL2h6T1czSXVKeVdMa2FPUm1PdVVLZE56emJsZXJQUmlhYU1jUDBxQWtXZm0waFpSTHZ0eVRNbE9LclFDQ1RHcVZpc0lneHFTT0FJUjBXcjVqa0xXZDlDVDkrdS9OVzZUL2M1RUFmUU5Bb3lnWXhCUjQzbWVaOHN4VTZrMFhIZjVZQTF5ekZFcGwxZTFIRG1lbFhMUWpzNXVaTExMeTBQRG9QNjlIaHE4akZLeGlLN3VmWXUzU1pEUTZQRFFpc3ZNWmxkZTNtclhSOGpqT3p1N2x0Mld4TEdkcG9OSlRFOU40c0NoMjIyWWs1QU82bGVIQm0rNFhGa2VBNHlJaUlpSWRyY29ET3h4c0FSdFhodGdWQ29WMFNpeTdLbUpjZnM4QzJyVmFyMnNlSDZpeHBQekU1bVdidmNGeGRrWmUxc1Nzd3lDaUlpb0VTSlRHUzYvcWpMZ1QvMGZ1aG10SmZGSkp6V2xIUFlTSXRvY1NycmwxWGROUkVSRVJFUzBDZ3d3SWlMYUJOcnhiSENFZHBzajg3M201KzFFUkVSN3dNTHZqeHZYNTBrc2RWTm9CcTBaSDdrVVQwR0liaVNWVHFIUTBtSTc0M1IxZFlHSWlCcnY3S3ZuUUVTMFU4aW8yUzJwTjRMWDhyNlBNRWxRbTRzUm1YbFhKbWVEandvK3g1MWNqY25TSk1JNHdOanNHT0p0RExTWUdCM0dkaGtjdUdpbnU0N2ZoMlBIVCtMSTBlTW9GRnBBUkxUVVFtRFJSeC9ZaDdmYzFvcEhiMnRCWjY3eHZ6VzZXZ1RpRVBIRUpTUm1IeDFQREVCSE5SdElGRTlkQWNKSy9YN3k5OUJwTkpwS0YrRDJIbjNqNzlZZU9KbFdjMzNlQnNUNy9ROEFYZ3BPdmd2S3owTGwya0JFYjdqcitBbDg4TU0vaEQvNi9HY3hQVG14ZUwxMHFCNjRkTUZlZjZqL2R0ei80S00zWGM2aC9qdnN0TEM4ejN6NlUvYnhRNE1EaUtKb2NabFBQZm1sR3k2ai8vQVJkSFIyNGUvOHczK0tucjRENWpqbkJEWkMxbU5pL0oxbW5lN0ZpNmVlczY5bFlud01wZUxjNG4yZWZmcXBHejVleW5mejVoanJmLzZIL3dUdG5kMTQvSW4zZ0lpSWlJaG92U1NVL05tbnY0N1RMNzFnajVldjlXTS85ZGR0WU9acVF6UEhUUG5rejMzaXg2KzcvdjRISHpISDVvZnhvWS84cUQyZUpTSWlJdG91bzlBb0trQks4SHMwQjNPOW1kT09UbFUxbkJCRXRDa1VaTFNGVTFycjh5QWlJaUlpb2xWaDcyRWkyblY4VnlIbnU3WXpUeGh2VCt5NmxwRnNGQXRMaVlob095bjdlMlREaTVwa0ZCTDVmYzc0TG9pSWlJaUltb1YwaUpXUmtXZG1aaEJIb2YxYlJzb05ndHJpZmFTaHZveGE3S2ZTU0tkODJ3RjFzOFJ4QkcyTzM2VnpyS2hWSzNiVTNrcWx2SGlmVERZSDEzWE4rcVRNZXJubzdkdVA3UkNhYlRRNU9RbWR4R1o3Qll2YlRiYVQ0eWl6M1ZydC9WYTdmdkxhcTVXS2ZRK2tZN0IweXJBalI1dlg2aWpITEs5Zzd5Y2RraVcwUjdiQlhxVG1KK0dZN2NEeHRGZHZyanFMY2xEQzY1T1hVQXVyYUpSQTU1Qm9GMm1uWlA5V3VIbUljSGw2Rm8ways0RjBKbU8rRjJZLzViOVI3UmVHc2o5SlVDbVhybnVNWERjeFBvSjlQWDMyODdTd1h5R2l2UzF0NnRja3FLaVFjbkN3TFkwN083UG96SG8yMEdnOXRLbW5RMVMxQWVzNnFFREhnUTBuc2lGRlp2K2t5elAxQUtQWkVlaktESks1TVhPZjBGeG45bDhWczYrTTU0L0hvZ0NiUVk1aGRLMjQrTGNxcFpDRU5hanFuSzNqaTBieVVKNlBKRzJPYWZ3TW5Hd0w0S2JNZFNrYmFHUU9VcUF5OWVNVGxjcUJhRHUxdExiaHdLSGI4T2FIMzJMbS9jdHVPM0h5QVd5R2hlZTg1NzQzWGRlNVdZS0xPcnYzb2FXdGZkWEx5K2J5OWpHeXZJWEhCcldhUFNlU1FjUmpjMTUwN1hsQS9kekRzWStSQUNQcHNGMllQMi9ZS045UDJmWFliMTdqQTJhN0RnOE5Zc3FjLzhnNWoremZaSDFrdlR6dmplTXYxMXoyekg1ai80R0Q1cnl4QzczN0Q5cmpyTFZ5elRMa3RSdzlkaHlQUGY3RXN0djI5ZlRhMi9McmVKMFpjOHdvajMzVG14KzZyblA3N1hmY2FhK1QrMnpYOG9pSWlJam94cTRNRG1CaWJIVFpkWElzck16VTBkV043bjI5V0FzSkNiMldsQmxHcHA1RXI2R04wU3N2dlhEZDhxU3NNcFBKb3RzY3UwcjVJeEVSRWRGYXlWQTA1cWpFVEFvU3pDTWxncXdYWDA3TFp0TFFOcnhJZ1IyWGlEWlgwZXlFS2lBaUlpSWlvbFZoZ0JFUjdUcnQyUlJ1Nzh4amFLYUNtWGg3c3NSMUttTkhaeVVpSXRvdTJqV0grcWtzRUZTaGtoak40SEJuQVgwRk5sWW5JaUlpb3VhUUpJa055cGtZSDhYVFQzM1ZOckNYNmZMQUpVeFBUaXplNytRRER5R2R5ZG9nbmlOSGoxM1hnYlNSS3BVSzRpakNsNy93QnpiSVoyaHdBRk5tWFFiTk9pMjR3NnhEb2RCaU93dTN0WGZhMFpDM3c2UlpyeTkvNFEvbnQrSFk0bmJyTWR0Sk9pZklkcE9Pekt0ZFB3a3Z1bkQrTEVhR2gzRHV6R21jTmRPb3VTd2RjNlVUOE5MbFNYaFRMcGZIWHVNNWpnMHRXc2hOejNnTW5GbUxWNisrZ3BIWllmenU4NTlEYVVsZ3hVWU5WZStGaGtKditwd05MM0xWemN1azI2TUMzb3k3MFNqU0llaFEveDIyYzN4YjJ4c2R4eWNueDJ5dzJMa3pMMTMzbU1HQmkzWVNYZDI5T0g3aVRRd3dJaUowNW4xODcvRk8zTmVUdy92djdrVFdkK0M3RzZqcmlxcElwcTVBbHlZUlR3d2dtbmk5ZnRsY2g3Q0NaR1lZMjhxc1F6enl4bUNwTnkxQmxiQWlDVEhxNm9lVDc0TGJjeFJPcGdWZS93T1NOQUszK3c0UWJhZmpKMDdhNlVNZitTaTJTcU9mODdiK3czWjY2L3o1MWxlKytNZVltNTJ4NTBRTElhY1NXSlRMdlJFSXRIRHU4Y0VQL3hBYXJiV3QzYTZMVEIvNzZaL0JDODgvWTQ2ZlhyZm5LeEswS3VzbUpNaHBnUVQyeUhUL2c0K1k0N1BEV0srdTduMTJrbk9nbi9uYmZ4K05JbUd3TXYzelgvbjNhSVJHTDQrSWlJaUlWaWJIbnIvL3VkKytMblJJeWdWVDVoajVuZTkrSC9ZZk9MVHE1Y254N0l1bm5ydnUrdjdEUit6eG5ZU2lyOVkvL2djL2o2cFozck5QUDdWc09UTDl0Yi8xODlqM0xnWVlFUkVSMGRyVlRIMjRESEVndzhKSWkrT09KaG5FdFpuRVNwVzBPWEliY1hRYmlHZ3pCUXJxdlBtNlhRRVJFUkVSRWEwS0E0eUlhTmVSZ1dCOVY4SFp6aHh4eDRGVzdQQkJSRVRieVB3T2F1bFlveml3QmhFUkVSSHRmTE16MDNaYVNzSTJKTWpHY2RaZUJqTjg5WXBkM3ZQUFBJMWljUTZ2dkhRS2xYSVo1WExKaHZCSTU5Z0ZaMDZuNEhrZUJnYzZNRHcwYUFPRjdqcCtyKzFRS3AxYUd4SDZJUUZBbFhJUnp6LzdETXJGSXA1NzVoczJZR2xxZmwyV0JpcEZjWVJzTm1jN3prcm4zWlRaQnAxbVhZNlpkY3Brcy9hMnRUNTNISVY0OWkrK2dWS3B0T3kydzNjY3dlMTMzSW5XOWs1a01oa2JwQlFFZ2UzY1VKdzEyKy9adjdDZEV4YldVZWF5RGFYVFJCRFU3THBJQUZGSFo3Y05mN3AyL2VROWlPUFlMTzlaMnduajdKbFhNRE05aWRIaHErYjFYY1dzdVp4S3B4ZTNjVHBkNzVEUjNkT0Q0eWZ1TTl1L3c3NEhlNFdjM1RFeXZYa1VveTdFcHBwdEp1cUYxZzQ4RlNEdHpLSGR2N3FHcGFqNmVmdGF6OTIxTkVlVmxyb2F1WHpCZkUrUDJ1OUdac24zcTlEU2FrZE1IeCs5YXI5bjErNURoZXdMWldUMXZyNkR5Sm52YXFIUUNpTGFHMHcxbXExSDYyMUoyWUM4ZTN0ejZNaDRlT0JBQWJlMXBXdzkyMXAyVGJwYU5QL0VTR1pIa1lSVjZPSUV0QVFZVFYrRnJoWE4zNU5JeXBQUUZYT3NVU3VaMjJyWVViUzh2QkM2Tkkwa2l1MStPUEV6U014clUrWlkxQVlobWI5VnJnMU9PZytWS3NCcDZUSWJtYzB4aU5hcmQvOEJ0SGQyb3FXMTFaNGJTU2RyMTV5WHlmblBBZ2tQOHBmOHZaazZ1M3RrVjJET2pUb1Ftbk1kQ1dBVmNvNnpRRUpXTStZY0xiTUh3MWFKaUlpSWFITkkrYjJVbDB2WXY1VEZMM1h3VUw4OVRwWGcvNjA2TGlZaUlpTGFTbVV6elpoU3VWWlRwOHA2OHVYS09rbGlwVmFmUEVsRTYyS3FCQ1B6VlJ2V1VOTWdJaUlpSXFKVllZczVJdHAxWkRUWXJPL0JkYmFqbUhLK3M0bnIyOUZZaVlpSXRvMHl2NE9lbVNLdmZsbXpub3FJaUlpSWRxNnJWd2JOZEhuWmRaN3YydzZpRWk2MFZxZGZmQUZEZ3dQNDU3L3c5MjNBUjZsWXZPRjl6NTQ1dlhoWnduaTZ1bnZ3RXovOU4vRFk0MC9nanFQSFVDaTBZS01HQnk2YTZYWDgrMS83MTdoNC91eDFJeWt2czJSOTVMVi83U3QvaW1QSFQrRG4vdTRuMGRPM2Y4MEJScklkNVBuKzEvL3BaekUrT3JMc3RoLzRrUi9IRC83SVQ5akFwb3haOW5QUGZOT0dGUDNpSi8vdUxiZWJrRTRUcDU1N0JnOCsramI4MEVjL2R0MzZEWm4zTkF3Qy9MdGYvcGQySFZZYTlYbkJDODgvQzhlVTkzMzV2LzJoV2Q1YnpmSStidGJyeEo0S01Gb283MVNvSjBxNGlzMDB0OU5rZUFpVnBCM0R0ZU9JdFl2WnVCZXQzc2lxQTR3a3VFZzVIaHp6UHFvMWxtVkxJSkdDUmhLSHlPZGI4TWhiM25IRCs0NWN2V0lEeFZZS01McjAycXQydnY5Z1A5cmJPeGhnUkxTSHBGeGw2OVBlZktERjFLazUrUGwzSEVMYVhOZFRXRitIeDZSczlqRmhCY0daSiszbDZOSzNvS01BdWpTSlhVSEhraUtKWkViMjhWY1JqNTU5NHpiWm42ZHlVRzI5OEhxUHdlM3NoOXQxTzVSL0VpcTNkNDVUaUJydDNwTVBvSm5jMW4vWVRrUkVSRVJFVytuaStWZHhlZURTc25xS0JYZWZPSW1URHp4a3kvVnlETkVrSWlLaVhXalcxSWZXVEJuOEFRMzRvS1dtVEsxRlpDc3ZpR2d6bVYxUWxNQTVreUJpZ0JFUkVSRVIwU294d0lpSWRoM1BCaGk1OEp3MWpscmRBTnB4b0YwWFdtMzljMjhhZDc3empJem9iU2NRRWUwZFNmSkc4SS9zL3hiMmlUdWhrNmo4RnBuOXRuWmNKSjRIRllWUWVudDM0dkw3blBJWThFZEVSRVJFcXpjelBZa29pbEVxRlZHcGxKZmRKc0UxaC9vUEk3ZUdBQ0ZwNUY4dUYvSGIvK0gvdGlNV2w4c2xjOWhjUDA3MmZkK0dJblYwZGkwTEpaTE9BUklXRXRScWRvVGppZkZSL05IblA0dHZQdlZWL05XZi9kdTRyZjkyc3g1M1lEMWs5T1RMQXhmeHg1Ly9IRjU0L2hrYkppVHJKQ1RjSkpQTjJuV1JkVm93TW56VmhwRlVLeFZ6eXBMWTlUbjFmQW4vK2hmL0ViN3J1Ny9IVE84MzkrKzJveTQzeXZQUGZBUEY0aHgrNzNPL2JRT01sbTYzbTBuTWRwTndKdGx1azJZOXYvc0QzMittRDVuckxwbS94L0NaVDMvS0xMZUljK1o5aWFMb2xzdVQ1NVRuZnZrNzMwYkZ6TC9ydlIrRXhQbjBINzREbVV3V2UwVWhsY0p1S243Y3FWcTlNYVNUTWtad0ZJNXkwZVcvam93N3UrckhTM2lSNTJlUXpSWGdwOUpJcFh6N3ZiK1pJQWdSbXU5S3BUaHJ2ZzhKZ2ppODVmTTg4T0Jiekhld1lyL0RKZk80NmNtSjYrNHpOenNEaDRIOFJMdGF4bFBvelBrNDNKR3gwKzN0S1hTYnYvdk5aUWt6NnN4S29Ob3FGbVQyUFVsbERrbHBBc24wRlNRekkwaG16VFEzYmdPTTR0bFJNNjhpS2MvVTY1VDJBcWs2TTY4WlpsdEVZUTN4MkFVNHFUeUNWNzhLbGNyQ1BYQ1BEVGp5Ym5zemxHdkthZFBzVkVwRVJFUkVSRVNyODlSWHYyTEwwNWRhcU1zNGR2eGVPOUNDbEMwU0VSRVI3VVpWVTI4Um1ycUdpaDNhQmRnN0xRSnViYzVCSVdEUEhxSk5aM1pEc1p0VUI2cEJYQU1SRVJFUkVhMEtBNHlJYU5keFZYM1VXR2M3ZXZISVNObTJvNGZDcnVoRnBGWjRIWHVsd1RrUmthWHIxVjVKZmQrbjlRN2J2eS9zeCsxdmszUUczdDU5dVB3K2IwZkFJQkVSRVJIdFhMVnExWWJmaExVYW9uQjVVRWMybTdQQlBxbFVhdFhMazdBZkNjNTU3aSsrYnNPRGxuSmMxeXdyYmNOL3JnME1pcUxRQmhqRlVZUlNzWWh2UC9zWDlyYjN2UDk3YmNEUWVnT01LdVVpcmd5OGpoZWUveGFlZnVxcnkyNlRJQk5aSHdraTZ1azdzSGk5aEpDZ0NMdGRKTUJJMWtlbUwzL2hEOURidHg4UFBQU29mVXdlalFzd3VuRCtWUXlhOVh6K21XL2FBS1BWa3VDbnFjbEpHMUlrZ1ZGM0hyc0hZUkJnZUdqUUx1K3JYL25paW1FcU55SUJSdkw0VWZPZXlIVGdVRC91ZTlPYjdldmVTd0ZHdmltRHpIb2NZM0s3cFp5U0tZc080YWtJaWZrdjcwN2E2MVpMS1FldWwwSTZrMGNtbXpmN3REUmM5K2FCeWFWU0JiV2d2ai9TeWVvRzFEelVmOFFHZjNXYWZadWNrYS8wblF0cVZkVE1SRVM3bDlTWmRXUTkzTm1Wd1VNSFczQ3lMNGREcldtMHBOMWJocWN0STNWRVlRVzZOSWw0NUx5WnppRWVQWStrT0dsKytBUHNUVkorSEVQWFNuWVNkZy90WjZCTXVhd2ZSM0FLM2ZENmpwdDlkNG9CUmtSRVJFUkVSTFJxRjE4N2E4dlNsMXFveStnOWNCQkhqaDViVXgwSkVSRVIwVTRpTFVSQ1ZaK2tGWFNXM1ZnV21ScVpER3QzaVRhZmxtby94NXQwRXUvV283SVJFUkVSRVpIRkFDTWkybldPZGhmd1BmZnN4MXcxeE5Cc0JWdEp1ejYwakdpems4T0xmRk84YXlxNTdWQzc5blVzdkJaZGI1Z3VJUjVSTEQzUW1ObE9STHVQN09kMEFoVkhVRUhWZGp4UlNZTEZIZDU4SUpCMlBMdXZUTkk1Tkh0b25YYk51cW9NVkdTcTh1SUUyeUhqdWZabjVaMTM5aURyT3lDaXZTZUtJaHRnSUVFTEVqd2dsNG1JdGtPVjRRdzd6c3N2bnNMb3lMQU4zN2hXVDk5K25IemdJWFIxNzd2bGNvS2dacVlBdi9lNTM4WXJMNzJBeVNVQkhoSlc5T0NqYjhQOUR6NXNwa2ZSMXQ2TzlKSXdIQW5LdVhqaFBQN0RwMzdGQmdWSkVNK0N6MzdtMHpZNDZOLy81ei9BV3NodllhVlN4dW1YWHNTbmZ2WC94R3ZuWGwxMis3dmYvMzNJWnJQNG9mL3VKNUhONWREUzJyWjQyNVJaZHdueCtUZi82cDlpK09vUUJpNit0bmpiTjU5NjBxN2ZqLy8wMzhBVDcva2ViTlNMcDU2eklWS3ZuWC9WQmo5SlNKQ0VJMzNvSXoreXVOMFdTQUJLR0lZMjVFalc4VE9mL3RRYnI5Y2NDMGp3MHBlKzhQc1lHbndkRjg2ZnRRRlN0V3JGTEs5Z2x2ZFJ0TGExNGNUSk41dm55S0MxdldQeHNWLy82cGN4TVRhNmJIa0w1TGxrdmY3ZVAvcG41bjNyd0Y3aDI1QmEyaW9TYlZ5Sld4RW1XUlRqenNYcjI3eGhHMWgwVDh1ZndsVVJNdWF5VW1zL3ptMXJLNkM3dXh1SER2WWlsN3Y1YU9rWExsN0I4T2drU3JPVGlKTFZQNWVNeXY3V3g5K0ZnVXZuelhkeEZsV3ovNmxXdHJic25JZzJYeUhsbUxJM0Y0YzdNc2lieS9mMTVtMlkrTjA5V1ZzK3Q3L0ZOL2R4YldoUlM5b3oxVUZxVmVGRlNXVldmc3hSZS9HUG9hTUE4Y1Zub0lNS3RBUVpCZlVKU1FpNmh0bFdVcW9jbXUybFRQMWhkT2xiVUtrOG5PN2I0YlQxd2IvOXpYQUsrNkJ5N1NBaUlpSWlJaUphU2dZVmtQb0lLYU9YQVFHV09uN2lKTjcwNENObWZwOHRYM2VjdGJYRFNac3krSTkrL0JQWFhYL1B5UWZRMDJ2T1YxTnBFQkVSRVRXVEVWUGFMcDBmVzhFQlZCZVV6RFpoYlMvUjVqSjduQUd0Y09IVUpSVDN2YnlQdmVlSWlJaUlpRmFKQVVaRXRPdTBwSDNzYjgwaTVXMURSeDZwRE43SkhZaWtvYnE4QmhucFcrYlhObHlYWUErVkFCTG1rYWo2MzBSRXU0eU5ia3ZxSVViU01VZnA1UHA3ZURzb3c4M3UyK1czYWZzcTdseEgyVkhlOXhYUzlqSVI3VDBTV3BTWWZhc0VHUzNNaVlpMmcwNTRIcnZUek03TTJJQ2FsVWlZam9UV2VONnRpN25sOTBkQ2RJWUdCM0R4L05sbHQvbXBGSHI3OXVQb3NYdnc1b2ZmWWdPRFVrc2E2Qjg4MUc4YjlCY0tMVFk0YUtrckE2OWpmSFFFYTZWMWZYM2t0Y242U0pqSVVySSs4dHBrZldUOWNybjg0bTBTQkNTUGxTQ2hiRGEzN0hHeVBMbXRVaTZqRVdhbXB6Qnc2UUtHaDY1Z2VuSUNCdzdkWnJhM2p5Tkg3MFpQM3dHODlmRW5GdThySVZPeWZXYW1wNWVGUElra3FaY25TUmlVTXY5ZEhyaGtseWZCVE5LNW92L3dFWFIyNzdPdlYxN1gwbEFxZVV3K1gxaHgvU1FvU1paZHFUVG05ZTRVY243bEtvYkRiaFd0RldLZFFxQnpxQ2F0aTllM1ljUzhEekhhZmZsY3IvLzNKWjFPbWU5eUd1MXRCYk9meWQzMHZsZUd4dUN2bzl6YjkxUG1lOVdMeVlreHUzKzdkbDlHUkx1RGIrcDIwcDZEenB5UHRveUxvOTFaKy9kREJ3dEl1d285aFJUV3haYVRCa2dtQjJ4WVVUUjBHclFLOCtYS2VtN00va29rMDBOUTZRSmNDWHVTS3JacUVjaDNnb2lJaUlpSWlPaGFFbDRrNWZNeXllV2xwRnhkNmkyeXB0NUF5dXZYU3VwV3BFeitXaDBkSGJZZWhJaUlpS2paVk5WODUwYzIrVmtrUTkzRWJJNU50S2tTaFpMNW1sV2UvT1NUYlBCTVJFUkVSTFFHRERBaW9sM25VSHZPVHBjbVN6WW80VTlldVlweXNMbmxCVnJWZzR1MDY5dHBSM0pkVXp2dHZ4Rml0Qks1VGU0bnQwcy92akN1aHhnRkljT01pR2pIY3lwenBxUTVoaE5VYjdGUDAxQlJZR3ArUXJoeGhDU2RoVTduMExUazl3bnU0dStURFdiYTRscTh2Ly9kOTZJN24wWnJab2YrUmhMUnV0VnFOUnRlTkRVMUJTSWlvcldvVml1b1ZhdjRiMy80WCswSXc2WGkzT0p0NlV6V0J2emNkZndFVGo3dzBLcVdkKzdNYWJzY0NlT1JCdjlDZ25Pa29mODk5ejJBdi92Slg3UWhSZEp3LzFyMUlLSEg4R3VmL2gzOHllLy9GL3pUZi9oM0ZtOGJtUS9xK2N5blAyV0Rkejcwa1I5ZHplcGdZbndNWC83Q0grSzVaNzZ4dUQ1Q1JrdVdEZ2V5UGd2cmQ2MkZEZ1QvOUYvOVd3d09YTUlQZmVDZGk3Y3RkR2o0MGhmK3dJYjd5UHJrTjlEaFFNS0RaSHJzOFNkdzVPZ3gvSjEvK0UvUTBkbTk0bjF0eUpLWmZ2QkhmdHorL2RTVFh6THZZeFhQUHYzVWRjczcxSDg3YnVzL2pQLzlYLzRiRzFhMFVtZUpCUXZiVkY3WDNPd00vdE52L2pxdWZiMnZ2UFFkdTkzdVBuSGZzdkNwOVpveHh6QlJrbUNxVnJIelVoaGVkeC9mbEpGNXBrd3c3L3MyVUtqWHZIWTFmLzFtYTB0ekJPeXRGT2c4bnAzNWlEbXVkUkRqamZQYTBkcWQ4SjBhVHJiOENkSk9DZXRWS2Rjd00xUEN3T1ZoRzJaME0xUFRjNmlac2xpOXp2TjZ4L1hzZnE1VzVYaWNSRHZWWDMxa1AzU3VEZmYxNXVBNUNybVVpNDZNaTROdGFXUjl4NFlZYlpTRUZPbktESUt6ZjQ1NDlCekNDODlBbHlaQkc2ZHJSVVFEcCt4VSs5Ym40SFQxdzhsM0l2UGdEOERwT0FpMzl5NFFFUkVSRVJFUi9kN25QbVBMdmFWTWZJSHJlYlorNE9ISEhzZEhQLzRKT3hqRGVraTl3My8vYy84emlJaUlpSGFLTWFWdFhYeG9oMHRpUjBnaExjRkRFTkZtY3JUNnBsYjZkUkFSRVJFUjBacnd2SjJJZHEyTTU2QTk0OE4zbEozQ1pCUERHcFNDbG5BZnRjZGl6TlhpUC9YWHpoQWpJdHBKRnZaWkMvTWtxVjllNWI1TTJidnFIYlB2Vy9pZDJzcGZxcFRySUdWK2o3TythMzZYTjc4VEx4RTFEejIvYjB6TXZsWHpHSkdJaU5aQWZqdGtLczdOWW5wcUNsRVUybW1wVENaalE0VWtjR2kxd2pCRXVYeDl3SWdzdy9kOUtNY3hoOHMzUGxwMlRObVM1M2xJcFZMMk1YRVVtZlY2SXpCYndwYms5dFdLNXRjbkNvTmwxMmN5T2JqbTJObXVqM1B6QUFKNVB1bXdzTkw2eUdWWnA0M3lVMm43bWx2YjJ0RGUyYldteDJadTh2NUlDSlc4aC9JYVZydmQ1SFVHUVczRjJ4WStOK3RsajFiTU1VdHNaNGtOTFpJcE1kZmRxRWhSam5ITWtZNjlqMXdPa2hpdU5KZzA3NXVjL2FpOVZrNjRBN2l1K2J3NUhncnBnajAzVHN4N0ZtdDVuK3ZIckhZT3ZlejROZEdldVk5bnJsUFExNXhSSithZGx0czNxbjY2YnZZeC9xMi9EODR0OWxWRXRQdTFabHpvakllc0tYT1Q0NU8wWi9ZZjd2eStZUU83Qi9uOWs4QjJSQUYwZFE3SjNEaVN5alIweU1DelRXVitpN1RaNW5GeDNCemNwZUcwOWRhdnQ3OVZlN0Rla1lpSWlJaUlhSStMNXN2NnBYeS9lazBaZnpxZHNlRkRVdmF1V0U1SVJFUzA2OW02YW1uNmE2cXhFMTJ2aXI3UmZaVXQ1RmRZYUNaY3J6RlFUVlBFYkY2TFZNRktKV3k5VWwrYVhzKy9IbGZaNnZXYkh0c3MxTjdHcUc4SUlxS3RZSGJBUmFXVElvaUlpSWlJYUUwWVlFUkV1OWI3anUvSHUrN3F3N254SXNhS1Zid3lNb3ZOb2wwZk9wV0Jkblp3T0lQMGlWdnRDUEVMQmNUKy9NK0lqT2dySFh0cVFYMmVzSk02RWUwQXByN09GQ3JES2MzYWZaZUsxem9XUmYweFNxZXhFL1o2MmsrYm8zL3pleFhQU21VbHRzS2p0M2ZocnU0V2ZOZlJYclJuZlJEUjNpS3REb3JGSXVJNEJoRVIwV3BWeWlWTWpJL2hqejcvV1R0ZE9QOHFTc1hsYlVGNitnN1kwWUh2T241aTFjdTkrTnBaL05rWC94aVRadGtMSkJEbmtjY2VOOHU1RjYydGJUZDlmQ3FWeG9GRC9ianoySEg3bUxOblRtTjBlR2p4OW04OS9SUzZ1dmZoaDMvc3A3QWFzelBUZG4yV0xrUElhNUxsM0dwOWhHd0g2YVFnNnpNelBZVVhUejIzZU51RjgyY1JCZ0crL3lNL2lueWhCZXQxL01SOU9QbkFRL2pJUnorR2h4NTkyNW9lKy9EOGVqMzE1SmV1dSswOTcvOWV2T05kNzdQYlByUEtJQ3A1bldPand5dmVKbUZRTWhKMXNzNHlLUW14Q2N3eHkyUzFncWxxRldFYzMvSTh6NFljSVVFdHJnZEhUWmpIcGt6WllGYzJpNXpub1QyVEJUV1hybHlIclJUNy9wUGZpeUNxWWFJMGlVcFl4ZkRzTUVwQkNXVXp6VlptVVkzZUNNcWFpZnBRUzNLSWticHVlZVc0MDg0VGJLeE1PSk5ObSs5OERnZjZ1bEVvM0h6VTlObTVJa3FsTWhRYjVoTHRXVC95cG4xb1dXT280S3JVeWtqbVJoRzgrbFhFSStjUW5uc0t0UG1TcVN1QW1TcERwKzNmNlljL0FwVXVJUFBJRDV1NlJ3L0tYMzFnSnhFUkVSRVJFZTE4UTRNREdMaDB3ZFE1ZkIydnZQVENzdHU2OS9YZ294Ly9oQ2w3Zi91cTZoQ0lpSWhvWjZ0R1VpZXRhMVBWWkN6V3lBV3hYckZ5d05RYUptYWFjUjNvdk9ja3VSUnlXZC9KdVVvM1JaMmloQmZOQnJvYXhycGFEblhSRGkyamxmWWRwSlJTVG5mTzZaWVFJLzhtcTdyUStuRE0zQ2V0TlhwWVYwcEVXOEJWN2hmaUJLK0RpSWlJaUlqV2hBRkdSTFJydVhhVStnU1AzTmFCVWhCaGFLYUNNRWxRRGphaEE3VlM5ZkNpdlRxcWpaci94M1ByNFVVcXFjODFnNHlJcUpubytqQWNNdENJK1Qyd2dVVkpYSi8yQXRjMUwzMXJmcWNrcktnMTQrTkViNXVkTXI0REl0cGJFck9mbGVBaW1Xc2VFeElSN1NuU3VQN002UmV4Vm5FVVlXSjgxQWJlREExZXRtRThrNU1UeTRMdy9GUUt0L1VmeHVFalIzR3cvM2EwdG5Xc2V2bWw0cHdOQzVLUml4ZTRyb2VPems3a0M0VlZMeWVkeWRyZ0lPbEFzTlRJTlVGRXQxS3RWdXo2VEp2WHUxUnJXNXRkcDlYeVBOK3VENjZKMjVtWm5rVEtiSytscjNjOVd0dmE3YmJPNXZKWUs5bXVRVkJETTVQakZDa3ZsQkNpdVNCQU5ZenNTSmJyWlk1K1VBa2xIRmZEQzExa3pHZk1jM2crMUN4Y1UzN3JLaGU5cmIyUTk2Z2oxNEVvaWRCbi9nN2lBTFdvYWo0RFZRUlJpSEpZTnVmUUdoUFZMR1lERDJmTEdyR1dSc0p2bkZlblZBV09iZmk3c2VQZE9FNFFtczlldFZZeis2V2JmMTdrT3kzSDJFUkVqYUtyUmZOUGpPRGlzOUNWR1J0ZWxNd01nN1pIUEhFSnlzc2dPUGQxT0lVT2VEMTNtb1BnSEZTS3dZaEVSRVJFUkVSN3djVFlpSzFqQ1dyVnhldVVVdkI4SDIzdEhUaHk5SmlwUTlpRVlHTWlJaUpxR3RVb0NVd05aRklLZENiV2lTL2hSWEdpYjVoMkwrTzNhbVdxTGswVllzM2NFYUdqd2tSSEdVOUJtdTU2cmgycWVrczd1VVR6QXcrVjViV1k5U3VIMm8yaDdHdEpUSDJybGxGWXRYSlZvcDFpa0RpdXFYVE5leW8yTThkejFBMHJURXZ5ajd3U05rY2tvczFrOXFUbVBFelg0bWhHTzVnQkVSRVJFUkd0Q1FPTWlHalhTa2xScTVrKzl1aWR0alBTVjE4YlF6bUk4SHBRUmtOSkdhbHJkcWVlanoxcm9TT1dtN0toSUlqaStoUW5EREVpb3VhaDYvK29LRFJUQUJYV29PS05kZWJkVVNSb2IyR1N2bzU2OHpvODdtL040a1JmRzc3NzdsNDhmQnNiVGhIdFJkS3hXaWFHRnhFUjdUMnZubjdSQnVlc1ZiVmF4Yk5QUDJWRGZjNmVPYjNpZlZLcE5CNTcvQW5jY2ZRWUhuandVYXpGeFBqNGRjdDFYUmVIK3U5QWI5LysxUzdHZGhBNGR2d0V6cDE1ZWRuMTU4eXlTOFhpcXBkVE02OTNwZGZadmEvWHJ0TnFlWjVuMXllVGtmYUtYMTY4Zm5UNEtxWW5KeEZISVRhaWQvOEJ1NjI3dW51d1Z2WEhOSGZZdHh5cGxNMDJtZzFxR0N0dnZNeFEyb05PbTJWVnpMbG1ZTXJJdXJNNUZKeTFmeDlvYy9pT2g3U1h3cDFkeCtDN055L0xIWnk2WXNPTlJvdWo1ck9oOGNVck5WUWp0U3pBS091V3pUSURPR3BqNTlkeTNGeXJoU2dXS3piTTZHYXExY0RjUHphZlhSNW5FMUZqSk1VeFNaSkU3ZW4vQnpxb0lKbStBdG8rMGNWbmJmbHRQSG9lN3FHVFVQZC9MNXkyUGdZWUVSRVJFUkVSN1JFWFhqdUhQL3ZpSDJOOGJIVHhPZ2t3eXVYeTZEUmw3bEpIa3M1a1FFUkVSTHZYWEUwWFRiMXpNaDBrOHFQdm11bm1qWENWclpUUHk5QlFsVmltSkZRYVFXdFdJZXM1cXRWUjdsWVAwaDNOajRVOVVrd3E1azhuMW1neHRmTlNjVjRmWFVyWDY5WkZ6ZFRGT3BKcGxFZm9POHJ4SEtSdnROeEo4eklpODdEYlFFUzBpUlJxR2pyMjNkcmdMMy9zNjZ3OEpTSWlJaUphSXdZWUVkR3VsemFsbU5KeCtyOTc2RERHaWxVYlpEUlpybUZnYXVPZGtyUVU1cm91OUVLQWoycnVUbGszSldYQUVqNGtyMkVqcjhOdUU2YytkNlQwT2E2WFFDZnNWRU5FMjBUQ00yUmZwQk00WVdBdVIvWGdvbVRqQVQ1YXdvQnVQTmhIVTlLeWo1WWdwN2h4QVVieXErR2I1YlpuZmR4L3NBTW5ldHR3b3E4VkIxcHpJS0s5S1RINzJEaU9RVVJFZTQrRThzeE1UMkd0Sk1CamFIRGdoaUZBSjkvOGtBMzNlZmY3djNkTm93dFhLMlhNekV5YjVjNWRkNXNFR1BYMDdXL0lhTVhWYWdXMUpTTWkzOHpJOEJBbUp5ZFd2SzNkckV2UEdnS1ZiaVFLUS90N3ZKMWhndEtKSXBWT28xbkZadnRFWnBxdVZsR2REN2RObTg5RTJ2V1E4VHk0OCtWanNnM0xFczVvN2x0ZVpTQ1V2YTk1RDhwZWFNK1hNcDYvdUR6YUdWcXpMZlk3NUp2UFEydFc0K01QQkJndlIzaHRLb0RuS0R2ZDA5V0sxaFNRVjVFcGNxaGkyT3huNURGQkhKaWkwTkI4ZHVUNm9wblhFTWIxY004eENRb2hJbW9DeWV3SWRHVVd3Y3QvQ2gyVWtaUW16WS9qeG9JUHFVRk1PYmF1RnBHTXZZYmFpMzhDdCtjdXVMMUg0Wm01eWhSQVJFUkVSRVJFdTQvVVlVeU1qMkhnMGtVelhiQjFEZ3VrblAzaHg5Nk91NDZmc09YdTNsNGVhSk9JaUdnWEMrSWtqQkxFbFZobjRvMzF1M0MwZ2wrTjZuWGlXYzh4ZGRXdzladWJMWlFtZzFvbmMwSGltZGVpek10SXp3Y3MzWlEwYXlpYXgvaU9VbW5YZ1psaHBkVXRReU5sRmllMUdkSVMyZ1VSVWVPWmZkSmxLRDFiY3dxc1BDVWlJaUlpV2djR0dCSFJycGR5NjhFU0VtQjBhYktFV1ZNYWUyNjgySkFBSTRsczBLNVhENi9ZNloyUXBKeDdvVlBiaGdPTVhDbjZyczl0a1UxaWxoMkRBNE1UMFhhcEJ4WkZjR3BsMndFRURlakVhMFBzSExjKzN3a1cxdFB4Skw2b3ZrMGF0bXdKREhUUlc4aml2WGZ2eDRuZVZwem9hd01SN1YzU09UdEpHaGVVUmtSRU84ZTVNeS9icWRIdWYvTWpPTlIvR085NS8vZXQ2WEdWU2dXancxZFhEREJ5VExsRmI5OEJ0TFYzWUtOcTFTcUNXbTFWOTVYMW1iNUJnSkdFS2NrNmJWUVlodkxQdGdZWVpUSlpwSnM1d01oc0d4dGdWS3N1YmljSkwyb3o2OXllenBneVJYZitmZ2ttek9lb0drV3JEakNTWlZmTS9VdGgvZjYrT1hkMFhUYWYzRWxhTTYxMjNwNXJONThUalo5OGM0RFhwcXA0K3ZLc0RjelBtT2s5ZDdTWjgrQVV4a3EzMmNDcUY2NE9tZnRHS0ZhTGlKTktmWXFHVFRIRUhNcEJoUUZHUk5SVWtwa1JKTk5YYkVDT3JzeUFtb2o1dmRBMTgxc3lLdE1GZVAzRDltK25yUTh1QTR5SWlJaUlpSWgySmFuRGtPQ2lnVXV2MmZsU2FWTmUvY2hqaitQQW9kdHN1VHNSRVJIdFRrR3N3MHFFc0JycEZsTTl1WkdSVmFWaTJxMUZHdEtDb1QwdGc3VktnQkUyWFpna2NSQWpuZ3UwWTE2UHJFZG1OZjFIekYxVU1kQit4andpU3N1NmFodGlkSzJ5dEZVMjgwalB2MGdRRVRXZWN2QzYxbXJFN0VrWllFUkVSRVJFdEE0TU1DS2lQYVd2SllPZmVPUU9USlJxK09IN2I4UDU4VGxjbWFrc3U0OTBNTG84WFlZazE5ZWllTVhsU0FMOXNYMnRtQXdTZkdzaVFqVlJxTzcwY0I3cFlGNE5nSlJmRDduWWNDQ0hMTU5zRk4rci85ckU4d0ZHdFFCRVJKdE8xME16bkpyWnh5Y3hWRmlyaHhZbE1Sckc4UkRuV215STBVNlNMK1NSZFJXK3EzZmY0blZobk1qb0xaZ3MxekJYV3puWUtHVnFMOXN5S1JSU0hyTCtHNis1STVleWZ6OTBxQk81bEl2RG5Ya3o1MmtHMFY0bjRVVngzTUI5TGhFUjdUazlmUWZRMjdjZmIzL251OUcxcndkUHZPZjlhRjlIMEZBVVJTZ1c1eEFFalNtUEtCUmFjTWZSWTJodGExL2h1VUs4ZU9vNUc0alVmL2pJRFpjaDYxT3ROQ0pZR3pZVVI5WW5ERmQrZldmUHZJeXB5UW1jZk9BaDBITGo1ajJRQUNNcEMvVE5kbXoxZkxTbTBqYkF5SGZlYUwwcEEwSktvRkhOaTFDTFpZcnR0QnBGY3k1YU1aK0xyRm0yYThvVFhiVUZyVUtwNGFSeGJHL2VoMmVLT3d1K2c1ZEd5MllxNGFuWHA4MzdtMkNtRmtwalhKU0RlbWhZbkxpbUdEUnJMc3RuS1crbUJIZDJwRzNvMFVjZStSNkVVOU9ZL2ZhM0Y1Yy9QVE9IY2lYQytNUVVIT2ZtbjVGU3VXcUtObUl6TVN5VWlOWW52UHdkUklNeXZZaGs2Z3JEaTNhQWVPUThrcGxoODE3TlFoVzZrTG4vKzZCeURJOG5JaUlpSWlMYVRhNE1EdUQzUHZmYmVQWDBTOHV1eitaeWFPL294THZmLzczMk1oRVJFZTAraVF3VXFJRnlCR2V1cGwxVDdTaFYxQTB6VlUyS1NxbjRVSXU3YVFYTHRvN1V2SVppVmFNWUpUcEsxdmNDSXEyRHFXbzgzWkp5ODRVVThpdmR4OVRJUW9hTGtsakhMdXp3QWNpSnFDa3BwYithSk9xbEtXOTBGa1JFUkVSRXRHYnNXVXhFZTByR3J3Y3I5QlRTNkczSklKWVMzbXVDZWlURW9SUkVkbDRKVis0d2t2WmNIR3JQd2EvRThHZXJDS0trSHVXK2s5bGdqL241d3Q4YkNURlM4LzhzTGtQWEE0d1cvdFk3UGZHSmlIYUVPSVNTZlgwY29hRmtYK2FZeVpYRDZaMVZBZWI3UHZLK1kzL0hGa2hnWDgzOGxra2xvcnJCdmwvQ2lUcHphWFJtVThzQ2l2cGFNMmhKKzNqem9RN2JJVGZQOENJaUlpSWlhb0JNSm1PRGdJN2NkUndIRDkyRy9zTjMydXZXU2ljeDRpaEMwcUF3MDFRcVpVT01IUGY2SUZNSlM1cVpua0w2RmlNZ3kvcEVEUXI2ay9XUTljbGtWKzY0TURNOWJkWTVEYnBlSUorTitmSXAxNXpYcGN5MlhKaVdrdkFhdWM2Y01kbWdJd21xV1MwcFg0eVZORGhsMk14T0pxZi9hUnZxNjlraTRMTVRGWlRDQkMrUGxURlJpVEFYeE5jVWRjcDVkZjNjT091bHplZkd3WUcyRnJNL011ZmluZnRSakljd2l6Y0NqR3ExMEpSVE82aFVheUFpMm13U1dKUk1EdFNucVN1ZzVxZHJSVHNsVTVlaGdoS0lpSWlJaUlobzk1bWJuY0hRNElDZEwrVjV2aTMvNyswN0FOZGpleHdpSXFMZFNNOVBVYVNkS05ZTkh4R25GaU5RMk53SzY4WFhrR2lFa2Juc3JLK2ZpSGw0WXFwZWE0bU1GSE9EdHRteVpQT0NrR0pYRkNMYUpFcDdZNzdTZ3lBaUlpSWlvblZoYlFZUjdVa1NaQ1NCQysrNzU0RHRTSFF0dWM0V3BONmdZRE13dDE4dGgvak9hQW1mdVRDSVhWUCtLUzg0TUtYR1VXdzJVbXBqQVViWFdoZzlQSmV1bHh4TDZiUjArT0pvNFVUVVNCSllGSmtwcUVCSkIrV2s4ZnNZYmZablNiNTlTVkFiZHBUcElMRkJmSThmMjQrY0JQSzFwQlovOHlUWUw3bkJqNW96bjlta2xHUG5DOXo1UDdLK0N5SWlJaUtpSC9zci96MGVmc3ZiVjNYZjhkRmhCRUVOLy93WC9wZnJianQ4NTExNDU3dmZoN2U4L1IzbzIzOXdYZUZGSWdoRHpNN09JS2hkSHd6aW1HUDdsdGEyTFIrMVdOYW5VbDY1ODNrK1g3RHJSSnNubm0rYk9WV3RMbDRuUWE2dW1XNVdGQ2JEWEtZY0Z6VzErb0JjYlo5UG8yUStoM0t1MWJIT3p6RnRyNmxLaEgvMzNGVzhObFhCbjc4K2k1b3B6NnlHaVcyQUc1anBaam50MVZpYktjWTNMdGNINXZ2VzBCeU9PRFA0ZmhBUmJhMTQ0blhVWHZoRHhNT3ZJcjc2S25TakE5OXAwNFdYdmczbGVpaDdLVGl0ZmNpKzljZEFSRVJFUkVSRU8xdTFXc0ZMcDU3RHQ1Nyt1cG1lc2dNZ0xQWDlIL2xSSE9vL3pIcURhNVJOSGN2VFQzMFZwZUlzQmdkZXgvallpSmxHRjIvZjE5TUhQNVhDOFJNbmJSM1FZNDgvWVFkOHkyYTNwajVJQnJ3WUhSN0MrUGdvdnZQOHM3Z3lPR0FEcWhhY2ZPQmhXKzhsNzYvbmVjamw4bWkwTTZkZnhLdW5YMEtsVWtaazZpaE92L1NDMlY1ejlqWjV6cDYrQS9aNU96cTd6SGE2RDhmTXRwSTZLdGZkbXZaZlVsZFdOTlBMTDU3Q3lOVWhYRGovS3NJZ3NOZkxBQ2ZIanQrTDN2MEhjTy9KQjlCdTFuRXp0aEVSVWJNSVlsUk5kV1F0MURxYlFHZVZVZzF0bFJ3bVNidk1hNmJlVW5weitHN2pHejJiT3RQcWRGWFBWV0xkSXE5QkJ0VmV6OHN3VmE4WlU3KzZQNVRSWDdCeWxsTmdwakV6YWJQNEhvWVkwU2FRTmg3U0ZrRGF4Kyt3TGdLMFlXcFdRODhsT2o0N25MOTYrck0vZkRvQUVSRVJFUkd0R1FPTWlHaFBrcEhUWmZLYzlRVXVCS1lBOTNJcE1vVlM3ZzJESG5ZczZjU1ZLRnNDREtVYkYySzBzQndKTXBKZVBRdnpoZXMxUzVDSmFKMzAvTmdkc2t1Sll4dGN0REJ2K0ZQWmZaWURiZmIvdGxaQzdieXFDZG05UzNmZHlOVGV1YVlpc2pYamc0aUlpSWlvVWRyYTJuQmIvKzJydW04dWwwTzFXclVOcFVXMHBHRytIR3BMdVlzMEpzOXNJUFFsTnVjR1lWQ3o4NVdremJKOVA0V3RKT3NUUlN1dlR5cWR0dXRFbTZkZWxxZk5mT3ZLb3VKRUdyZzFZWWgzSWdIampUOTNibFpKV0xWVHNUUUYzL1ZzbzFsbHk0a2RHMUFsYzluNTJETi9yLzQ5SERGbHdGUFZDSy9QVkRFNFU4UFEzTnJhcHkxOHpDcFJzampQSzdPTXJkM3RFTkVlcDZ0ejBFRUp5ZXd3a3ZJVWRGZ0I3VUJKYUtyd3pEUXpiTXQzZFhrYThETlFQbzhkaVlpSWlJaUlkckxSMFJITXpreWp0alIwZjM2d3lQMEhEcHJwa0IyUW9aRUdCeTVkZDEwbWs3WDFFMHZEa21xMXFoMGdRdFpOd3BhdUpYVTh0V3V1ajZMUVhqODVNYjdpOHdnSnlzbWFTZXFIRnVxSWJrWHFWc1Q0K0pnZEpHSnc0Q0lxbFlwOURna3ZXaHBnVkNtWGJkMVNvV0NlSjVlMzRVSHl1aVNzSjJYcWhEeS84VzJsRWxQV25waDZnSm5wU1Z2ZmRkbXNsN3l2c243eS9GY0dMeS9lVjlaRHRyZGNMOXRDZDNVamxVckJUNld4RWJMZHE1V3lEUzI2YXA1dllSdEpnTkhJMENDbXA2ZnQvV1NiUzFpUWJCc0pOU3EwdEtCZ3RrK2YrYXo1NXJaOG9XVXRUMnRmcjB5VlVoRWxNMTJydTZmUHp1VTlXZmpNTElST3lmYVJBQ09aQjJhZDVtWm5NVDA1WVFPTHdqQkFhMXU3cmVPVGJiVFc5U0lpMmluTXo0ZU9kUkxIV21tMUNYa3BacEgyUUNKS2RPUTZjUDFOYVBnczQxbUhrZGEyKzhrR0E1aE0vYXFYYUdYcjgyVnpYTHMwNmVaaVNzcGh0dGZpSU9RTW1hRkdrcytWZkpZNXJPL2VvMDN0bTltempFdWxITU9MaUlpSWlJaldqd0ZHUkVUclVBeGkvTTRyNHhndGg5aDFiQTZJK1NjSTZ5RkRtUWIzcHBGU1pKblNFbURrMlZKM1NLYzltZUltN01oRlJNMU5LcWlTQ0NvTW9JS3E3WGlwTnJIenBjN2t6YjdSVkVtNE8vc3dlbTcrZCt6T2pnenU3dHlhMGNXSWlJaUlhRys0NCtoeFBQelk0MnQ2ekwvOHgvL0FObXhlT3ZyczBPQmxPOXJ3NDArOEc3MTkrN0ZlMG9oZGxqVTNPM1BkYmFsVTJvNit1OVZrZmNaSGgxZThUVVpTM281MTJrdHEwdEQ5bXZBaStWdEcwYnRacHBHNUZZRTUzNHpYRVh4VWpVUEVTTEFQVFhiK05XVytjNlZ4N0JXbDE1L0JUSGtTcDhaZU04V1FFZEplQ2lremRlVTZVVWdYN09TN1BsekhRK3ZCdDlnUW80OTg5blVFcHN6eTFRbUdmUkRSenFTclJWU2YvUnlTbWFzSXozd1Z0UE9GRjU2QlNtVlJqZ0k0bmYzSXZ2WEhRRVJFUkVSRVJEdVQxRjM4UDcvNTZ4Z2RIbHAydlF3QTRYayt2dnNESDhMQlEvMW9KQW1LZWZ1YjdyanUrZzkrK0lkdzhvR0g4R00vOWRjWFE0d214a2J4ZTUvN2JieDQ2am44MGVjL2k5V1FPaENabmpWMVBEZnlqbmU5RjMvdGIvMVB1T3Y0dmF1dUE1SkFvRkt4aVAvMTUzOEdJOE5YbDlVcDNZeUVQOG5yZWZEUnQrS0hQdnB4ODV3bmNNdzhiNk9WeTJYelhDNysrUy84THpZVVNMYmJqU3hzbTg5OCtsUG9QM3dFSC8zNEozRGs2REU4OXZnVFdDOEptSHIyNmEvand2bFg4WC8vNnIvQ3pQU1VuVlpEZ3Fza1VFbldROWJuUXgvNTBUV0ZCY25ybGMvSTE3N3kzL0R2ZnZsZlhuZjcvL1A1UDdYUDhZaXBQNVRQdXJ4dXFRT1U5YjJSSjcvMGhjWExIL25veC9EUW8yL0R1OS8vZlJ1cU15UWlhbFpCa3VqWnFrNmlUUjZCeHp6SFNNcFRLYlBMMzRjR2l6VlVKZEorMHFBc29jaHNpV29FcEZ3Tjc1b0VJMmtoUG1tdXlzN2ZUMEptR0dCRWpTVGhSVEkra2Vmc3lIR09hUVBNMi8yMG1mMmUyYzljQWhFUkVSRVJyUnNEaklpSTFxZytZcnJHWkNYQ2JDM0NybVdqdzVPRlllbE5UZTRtbHI1SnlaNkVKUzJFSjJISm5Jam9SdUw1ZlhBVW1zdW1xRmdubTdidjBMWUdRa0ZMZUpHek84WlVrTit4ZmJuSS9xYkpMdDVoTFFzUkVSRVJiWk8yOW83ckFvd2tlR2hpZkJTVmF0WGU1cm91MUE0NFpwV1JoZU80ZWNxTGtqaXk2MFJ2aUUxNTE3VnRQeVZTT3pUbmxaRzVUUUtLWkFqS3BaKzMwRnd2dDh1MG5uYWo5Ukg2bXFDc0t6YWZoZXEwK1lMTm12a01NSDNaWEo3Qlh0RTZPMlJlOTZ6WnI4elkwQ28vOXVCSEhscE5lVUkyTENGYm00WG5lTGFUU1RyVkJtVXVkMGMxQk9hOCtkVk5ESjlLcFh6a2NsbGtNbW03cjd1WmFyV0dTcVdLbWlsTDFReURKNkpiME9WcEpMV2lEUy9TcFVuUTdpTHZxVTYzbVBrRTRPZHNxQkVSRVJFUkVSSHRIQXNCTXpJVmkzUExidXZlMTR0Y3ZvQnNMZy9YMjl0Ti9ZT2doakFJY083VlYyeWcwdFRrT0dyVmV1QzhsT003cGt3MWxVclpRU3NXVkNwbFUxY1RJNDdxOVRWU1QxS2NtOFhaTXk4alh5aWd0KytBRGVqeEdyQnRFMU4vSU11L2RPR2NMVnVXY0tYU05lL25qY2pqNUw0U091U2IxM0RTWFBhdmVTMnJVVFd2dDFRcTRmUkxMMkQ0eW1XN2ZSYnFoaVRBU1prcG04MmE4bWR2eVhOSHRqNnJXcWtzdm9haHdkZnI4eXVEYUcxcmIxaFlrQ3pUTTJYeEVuSjAxYXpmRlZNZnVOTEFJemN5TlRsaHQ5SDlZNCthY3ZTTXJWY2tJdHBOVEMyeVk2b2pmYTIwQzcxNWJTSk1QYmdNR2R2UVNtdXBBdGYxLzJUQjVvZkd2SVlHeEFtWjdSR2I5WTBUcmFUeWRNVUtWS2twRGN3enA4enpPU0FpV2o4WjdreHBKWjFSWnBWS2htdHhMUUFSRVJFUkVhMGJBNHlJaU5hb0hDV1lxa1o0NXVxY0RYM1l0U1FNWk9uYzJZU2ZET2tJSnAxeUZqcm1CRkc5SkR1YzcrakhFQ01pdWdrbnFOalFJcWRheHFaemZSdTBwdjFNUFhCdGg2dVkzN0w2NzFpQ2NwZ2c3U3FrUFFZWUVSRVJFZEgya0JGOXBZSDJLeSs5c0hqZDRNRHJkcEtSV0c4L2ZNU09qdHZzQVViYUhGL0w2TDlCcllwbUlRM1dNOWtpNkExVkNabTZwc3hKZ29sbXpmdm5tdk85bENtbnl2citZdVdKM0hlMlZqT1BpekFicksrTlVyME1zUW5DWmlTODZNSlQ5ZW1pbVVMeldVMzJUc0RWM1d1NjkrZnN2Kytzdmd2VE9vT3Y0KzNZTEgyOVhlanAyWWM3N3ppRVF1SG1RVWt2dm53ZVExZkhVSnFiYW9aUEZCRTF1V2p3UlNUbEtRUXZmZ0cwdTJoVE5oNWVlQWJPOURDODNxTndlOHpVZXhlSWlJaUlpSWhvNTVBd2w3SFJZVHUvMXR2ZitXNzBtN3FSenM0dTVISjU3R1VTWGpNNmZCVy84aS8rOFhYYlNzS0xDb1VXOVBUdHQ2RkVDeVRzUnVwckpCd3FtYSs3K2RZM243TFREL3pJajhQemZGczMxWWdnbkZxMWFwZi9lNS83RElZR0w2LzRmdDZJUE83QytiTzQ4S3YvQ3U5Ky8vZmgrSW1UT05SL08xS2Rhd3N3dW5UeE5WdW45ay8rd2M5ZmQxczZrN0dCU0hjY1BXYTNsWkJ0SWdGQ3NtMEhCeTdaZ0NpWmZ1OXovOW5lM21FK2Q0ZjY3OENIUHZLamFBUjVuY05EVi9DZmZ2UFhiVmpYUmZPYTErTExYL2hEZk5uTWU4eDdmT0srKy9INEUrOEJFZEZ1WW5iTEdWTW5uV2xFOE0vTkJBbGlOOUVOcm1MVXBqNWR1cHVvbEptbEd2VWFUUDE2cFJLaWxITFFhcGE1WW5wL3pUejNwRkxvbElGcndQYlBSTFIrRHB4UUsxMHgrN0ZYZnVVbm4yVEZLaEVSRVJIUkJqSEFpSWhvalY2ZnFlTEtYSUJhTEtPMVkvZUw0dm1nSVYwdlU5N016b0t1TXg5YTVOblNlQnVlSkg4eXlJaUloT3dYWlB5UEtJQXlkV2dxRERaLy8yRDJlZVlaa1hpcGV0amFicW5qTXB0TmZzZG1neGpucHlyWVgwalppWWlJaUlob08wZ2pmR2xFdmhKcGxENXc2UUx1UG5IZm1rZWMzV3JTNEZ0ZVIxZjNQalNMdWRucGhvd2d2UHRwVzg1WERrUEl1Sk5lellFelh3WW1mMWROR1pVRXdPNVlTV1ErRENQQTFBQnc3c3YxZVZRek44U2dtM3VuZHhIak9vZlBoeWRRMUdsN3VkRnF0UURGWWhsajQ5TW9saW8zdlcreFdFRVFoSFljMHpVSnpYSXZmZ01kUXhkd2IrazVCSEVaTmUrTlFPaWU4UlRTMVRiZ2d2bmNLNmNlNUh5dDluNGdaVjUvcGhWRTFOeDBITm5nOStEc245dWdHOXE5ZEhVVzRZVy9rQjZiY05yMkEzNGFhcVY5T0JFUkVSRVJFVFdkYnozOWRjek9UQys3VHNyelhUUGRlZXdlSERmMUl2NDIxNHZJNEJJUFAvWjIzSGI0RHR4MS9ON3Jidi9kLy93ZkVVVVJoZ1lIc0VCQ2dXUjY2QzF2eCsxMzNJbVZ5UFZTTjFRb0ZIQXI1ODZjeGxOUGZna1Q0Nk9MMTdtdWk2NTlQVGE0NkQzdi8zN3pmTzNMd29na21FY0NlZjZMV2IvUWxQdGZldTNjNG0wU252UGxML3dCRHZVZmJraUEwVVd6YkhuZnBDNXJZbnhzMmZxbE0xbjBtbldVd0NTNXorV0JTNWcyNnpZN08yTUh4VmhLQnZTUTEvbGQ3LzBBT2pxN3NSWi85c1UvdGtGRVN5MkVPcDA0K1FEMkg3ek4vTjJIVEthZS95RDFIa0d0Wmg1ekVTODgvNnhkZDVrV3lHZno2cFZCdk85N1B3eEhCbjdZNE9mdzJhZWZRcmxjeG9oNWpiSThlZThQSE9vMzAyMm1UcTBIK2ZsZ0pURnc2VFc3SFo5KzZra2twbTVHM3I4Rnp6L3pEVncxbnpVR0dCSFJiaUhObjVPMTEvcXRXNUxvdFBuNWFXaERZVm4zMlB5a05icFBUV0orckNKdEZxMmRHeTVaaHN1VzJzNVdOYjhpUkVUcnBzMkJ2SDdKN0VzR1FVUkVSRVJFRzhhZUMwUkVhL1Q2ckttNG13MFF4SHVrcEhNaHdNaVhud3kxdWVFZEVtQWtuUGtnbzVxdXovZkt0aWFpbTVQUUlsTjc1dFFxWm02cW5wTE43MmlwNGRoOWtrNmw2cDMzbElQZFFQYXE4anMyVjR2eDJuUVZhYzloZ0JFUkVSRVJiUnRwcUx6UXFQdGFJOE5YMFhicEF1NDhkbnpIQkJpVnl5VTBpN25aV1hOSzQ0SnVUcy8vVzQ1Q08rMDZjdjQ4Y3dVWU93ZWMrd3BvOVo3d0xtSllGM0RZbWJiejhianhBVWJWYW1DRGk4WW5wc3grN3VhaEUzUEZNb0lnV251ZWMxaTE0Vlh0VTROb0tYMEhqbzVOTWNjYjVTcmxpVG1nbUFla240Z3krNHpVQ3FPNnUyWWZYT2htZ0JIUlRoQ0hkdDhmbnZ0elc2Wkt1NWV1MUFPTW5MWStlSWZlWklxdjNaVkQ2SWlJaUlpSWlLanBTS2hMdFZwZGRwMkVGMG5JekZGVEozTHlnWWRNZWVIMnR1V1JBS05ISG52OGhyY3Z2SVpyQTR5azN1Y0gvdkovaDNlODYzM1lxTE5uWHNZZmZmNnp5K3FSSE5lMTRUejMzUGNtL05SZi8xdElaektMNFR4THZYanFPVnRuc3pUQTZNTDVzM1paMy8rUkg4WGhJMGV4VVJkZk80dnBxVWtiQUZRcUZwZXRuMndMZVI4bHlDaGoxbEZDZVM2WXVxUlNjZTY2UVJOa1FBOEpNTHIzVFEvZytJbVRXSXV2ckJCZ0pNOHZ6LzNCRC8rUW5VdEkwTFVEWHB3NS9hSjVqOXZ0OHk0Tk1IcjI2YStiOS9ReWF1YTlsYy9rUnV2bkpCQXBDQUw3R21XYkhEMTJEeDQybjZ0SEhudTdEY2FTa0tjRnNpN256SHQrNnRtL01JK3BYUk5nOUxSOXIvKzNYL3kvUUVTME85UUgyZG1xQWJYTjg2VE4xTkEraEhwKy9YWERBNHlVTkwrSXRkTDZScDFYYklDUnVTbGlOeE1pMmpBOXB1QThyUlVEaklpSWlJaUlHb0VCUmtSRXF6UmFEaEdha3RBL09qK0ZxOFVBZThaQ2liSlVCRXF3a0QvLzA2RTJNY2xJemY4akhYYmsrU1ZFU1VxM1k0NEtUN1NuMlAyUGhvb2pPeUVLelZ6MkI5SUJaMnM2M21pekg5SnVxdDU1YjFNVDNMYkgxVktBLy9ycUJJcGhndmFNaS9hMGg3elB6czFFMUR4a1pFSVpnVThhMHNsOE5TcVZpZzJRMkNqZjl4ZWZYNm5kOXh0QXRGZDVQb3REbTlIOUR6Nk00YXRESzk0bUk2MktkN3pydlNCcWhKVGpJdDdpSVJnZE8yM2o4WVFFR0UxY0FPYUdRV3ZuSWNGeGQ5U0dySi9CUGpSS0VvY0lxa1ZNanNlWW14N0QrTEFjZjk3OGMxS3BCS2FZTmtJUXlESHZmUFNXT2ZZTnc4QWV0N3J1RFg3bnpPYythdS9IY0pERmVjK3hJVWlCS2U5dFUyWHoralR1eVZTUmlrMlo5OFZ2MU10OVZ3bys2enBjTHg5dU93Z2lhbTdSbGRQUTFSbm9zQXJhNVV3WnVyelAwZGdGcUxOZmczLzRZYmo3am9DSWlJaUlpSWlhbHdURlNPalB1VE9uRVVYUnN0dU8zSGtYN3I3M1RlanU2VUUybDl2VDlkUWp3ME80ZVA2czNVNFQ0NlBMdGxVdWw4ZFAvUFRmUUh0SHA5MU9OeW9YL2NoSFA0YkppWEg4MlJmL2VQRTZDVFNLb2hEZmZ2WXZiRURQZzQrK2RVTUJQVk9URXphUXFMMnoyMDRmL1BCSGtFNW44TUJEajhMemZIUjE3NnUzT3pDVGhQWElRQmlmK3BWL2dibTVPVnhaRWpvMFBUMXBYK3VsQzYvaHlOR0w2T2s3Y012MU9tdnVYeTRYTVRweTFhekh1TDFPbmllZFR1UEV5UWRzZUpFTUVDTGJhS1gyRmdjUDllTzczdnNCdTQxZWVlazdkaDFpczUwcmxUSm1aNlpzNE5LK25qNjdqVFppY09DaURVS1M1enBnbnZOOTMvdGg3TnZYaSs1OVBXaHRiMTkyMzJQSFR5Q2J6ZHI3dm43aHZIMmZsbTRqYVR0aWwyZGU1LzZEL1NBaTJzbWtkZHRDRjRtdG9LRnlwa1I1Unh4Y21QWFVFVlNpa3h0WDdFZm1sUlJOR1htMEM5dDJFOUZXVVlHQ25qWDd4NWRqUko4M1Y3QlJEUkVSRVJGUkE3REhEaEhSS3BYQ0dPVXd3Y3ZqWll5VTlsQ0FrWkFRa1RqWjNOQ2lwZVI1NUtta284eENxYnd0b1ZlTmorZ25vdWFYeEZDUjJlK0dnYW1PMnNJZ005a1hTUU1YUDFYdm9MY0xHd1ZWb3dTblJrdTRxek9MNldxQjRVVkUxSFNrUWFablIvUkxYVGNhNEkzVWFyV0dCQmpKOHkwTk1TS2kzY0YxZUx6VGpBNzEzNEViQlliT1RFOWpkSGpJTmlZbmFnVFhkYUMydUh4SmptbTJ0YU5KRXBuQ3pRbWdNZzFhT3drdzZsTkZES3NXTkpMV0NlS29odEpjRFJ1aHpYL3hmUEM3ZTRPZk9XMSsvM1MyRThXTXdtdE9nQkxNRklmb1ZiTklxd2hITVl4VWJOWmo0aVlEQ2hiTlp5amZ1QUFuSXRvOFNYRVV5Y3h3UGNDT2RqbHQzMmRkSEVjOGVoN3UvdVBnR1E4UkVSRVJFVkZ6a3dBYm1TU2c1MXBkKzNweC9NUkpkSFIyYnloVVp6Y29GWXU0Y1A2czNVNXllU2tKNUhuczhTZVF6bVJ1dXAwZWV2UnRHQm9jV0haZEdBUjJrdXN6bVN4T1B2RFFocmExckZ2SnpDVzhxRkJvd1R2ZjlUNjdYbzg4OXZoMTkrMC9mTVErOXgvODduK0dQenF5TE1CSXdwVGt0VXBZMDlUa3BGM2VyZFpMN2pzNVBvYTVtV2xVeW1WN25kUkZ5T1AySDd6TnZqYlpWamRhVGt0cm0vMjg3VDk0Q1BsQ0FjWGlyQTB3aXNJUTVWTEpidjlxdGJMaEFDTjVQUXZQSmR0QXR0R05TSENUaEZYSmZXVmJMUTB3a20xVW0xK2VuMHFaOVFZUjBjNm1zYVhEN3BnNnhmUU95Uyt5NFU3Uy9POW1MUUNsQnFTbTdCZzBSRVRyWXZhTHNwc3BtUXZEdi9aVFQ1NENFUkVSRVJFMUJBT01pSWh1WWFvYVlib1c0ZGVmSDhacjAxVU16RmEzTE9tK3FjUkxpb0NsSjR5M1JVMmdIU2tvZCt0ekNkYUlrbnFKdEt3UHc0eUlkaWZ6M1ZiellVVXFyTXpYUWlWUVcxaFZwMTBQMnM5QWV4bmJ5USs3ZElRTytUMHJoekgrOU5LVURlajd3YnU3OE5qQkZoeHFTY0ZuV0FjUk5RRnBYQ2ZoUVJJaXROb0FvMGFGQThoeTVIa2x4R2d2ajJ4SnROc3drS3g1ZVdaL0s0M05wYUgxMlRNdkwxNS8rc1Z2NDhMNVYyM0Q2NDVPYkx0Y29RVjNIRDJHdHJZMk5BTVpWVmpXWjNwcUFyUTZLYk1mMk9vU3BiU01lT3d5VG9BMngrVEVLUDc0OS85ZnBQd1UwdG5zaXZmUkVwUTBOb2laWWhsVHhZb3BXcTEvQ3lhUmcyUEtZVjQ3K0NBS2hRTHVPM0VmZ3JFTG1IbnkxK0cyOXNKdDYwUG1qa2VRN2owR3RQZWJMMUFPUk5TOGRCeWF1cE1JNGV2UEl4NStGYlIzeEpOWGtCUW40UjI0RjBuN0lUaTV0dm9nSVVSRVJFUkVSTlIwbnZycWwzSGgzTXJuN1QxOSsyM29qQVRoN0hVUzh2VGlxZWV1QzNxNi84RkgwSC9IblhaYjNhcmVUMEo1V3RyYTdUYVY1UTFjdXJCNDI5VXJFdWF1RUFRMTVMSCs3WDIzS1ZPVmdUcCs2S01mTS9QRE5xRG5SbTBiMHVtTUhienBQZS8vWGx2dkphL3ZXaEtzSk5mTDY3dlY1K0NpcVQ4YnVIUVIxV3AxOGJxT3ppNjg0MTN2dzNHelh2TDZwUjdwVm82WWVxWjNtM1g2azkvL1hRd1AxVVB1SlVSSTFrTUNqRGJxM2UvL1ByUzFkK0NqSC84RU1wbk1MZTh2Njczd25xMUUxa3VDbVNUa2lJaUlkaWVkd0krVnp1bWI5SG1VbmkwU2JGZWRuL3RtWW9zZ0lsb0xCWDFGYWVmWHRkWU1MeUlpSWlJaWFpQUdHQkVSM1VLWWFKVER4SVlYblI0djI1VDJQWnViSXgxYlpISzJlQU5JZUpGMjNsaUhIWkwrVDBUcnB5VFFYc2RRVWJoTk8xMnp6NUVHSEJKWW9YWnZsWlpzV2ZsZEd5bUZtSzdHZUtLL3pmN21FUkUxQ3drT1dnZ3hXbTNvU0NNRGpPUTVGK1pFUkxTNWZEK0ZydTU5cUpTWGo2STdPek50UjNsdEZ0S3dYQnFNcjZiQjkxYVFzRDFabjB5V29TS3I1YXF0RHpCeUpCaVJ4eE8wU1dxMUdvYUhMc05QcFpITDVWZThUNUlrbUp1dElKRFJ4YU0zenZ0RFhkK1hGUXY5Y05vN2dmNUhUVEZzQmpVemVlbDIrUGxlNlAxdkFnNjlDVVMwQXlSeGZTcE5RcytOZ2ZhUXNBSXRVMUF4QmI0QmlJaUlpSWlJcUhsTmpJM1lrSnFWWkRKWkcvVGllbXplWDZ0V2JJQk5iVWs0aitnMGRVa2RIWjEyVzkySzUvbElwOU4ybTlhdUNlS3BWQ29vRmVld1VSMmQzZWp0MjIrRGpJNGN2ZnVtOTNYdFFBY3VEaHk2M2RTSHJWejNWU29XN2V1V0FLRmJLYzdmZDZtVUtTZVc5V2xwYmJPdmZ6WHlwcDZwdCsrQXJRTmJFRVdoWFhZanRwR3Nqd1FyU2JqVGFzaDZ5M3VXdnNGN0xPc2xaZDVFUkxSNzJkNHFHcDY1b0c1eUg4VHo4MlIrVGtTMEpocVZST256Wm1jekNTSWlJaUlpYWhqV2NCQVIzY0JVTmNKUU1jRHZ2REtPejU0WlJ6bU1iY2pEbmlZaEltRlVuOHZrbVFyVnJlcDh0ZEFSUFRWZnFSckg5WG1sTnI4K0lLS2RMSWx0TFpOVG5yWGZieVdqaFc4RGJmWnBPcFdGZG4zbzlLMGJ1dXdXZ2ZtQkM4eDIvNytldllKZmUvNHEvbi9mZHd5OWVSK0hXdElnSWlJaUl0b0tNdUxxNDArOEI4ODk4dzI4OFB5emk5ZExRMjN4RjkvNGN4enF2eDJQUFBZNGlEYkN0eDBFZ0paVUNva3BVeXFGbTMvK0tjK1Y5MVBZTnFrY2NQTER3TkFMd0V1ZnYrbGRFNTJnV0tvZ01OdWxHdFN3VzBtb1ZDR1hoK3M2eUdkdmZ2NWZOVlZwVDBaSE1Ld0xhRVp4Rk4xd0pHb2kybHVpeTk5Qk12RTY0cWtoNkZyekJFRFMxZ2t2UG9Oa2JoVFp4ejhPbFdrRkVSRVJFUkVSTlkreloxN0c2UEJWUFBYa2wvSEtTeStzZUo4WFR6Mkh6M3o2VS9pclAvdTNVYmhGR001dWQzbmdkZnpSNXo5NzNmWEhUNXcwOVVXSHNWb1NkQ1QxVDdKdHo1NDV2WGo5MDAvOW1RM0srWnMvLzcrZ294UHJkditERCtNZDczb2Z1cnA3VnYyWWQ3MzNBMmdFZVUybm52MkxaZUZNYVZQZkprRkJFZ0MwV2hKZWRQS0JoMnlRMFFJSmpucnF5Uyt0S2tqcFZqNzQ0Uit5NjdWYXNoNnlQbWRPdndRaUl0cXpzb21aVmpQKzdaelNHRGZ6ZlZwaUFqbElOaEd0bHY2cVZ2clVyLzdrVno0UElpSWlJaUpxS0FZWUVSR3RRRG92bGFNWTQrVVE1VEN4ZjlNU0N3RkdDNWZWTmhiMk9xb2VtMTlmR1FZWkVlMDA4L3NUcFpNbCs1YnQrU0xYQitwUTBMSlAyNk4xV0xMNTVUZHZyQkxDTmR2Z1FDRlYzeXFLbFhwRVJFUkV0UG1rOGZLTlJoV1d4dGZYanJLN0hlSTRSaERVekh6akRiWWJSZFluV1FoNnBsWHp6SGxPc3Nubk9uSXVWWDhHdGYybm1jb0YvQ3lRYVFPaVduMjY1dnhibS9OQk9TK01rOFJlM3QxbG9zcStUdmtJNlBuWHVkSzU3NXhPWTlaTVZlMGgwbzBOY25mTWliY3pINmkxWFZZY3BWbytCL0laU0dJN2dXWGpSRHVHL2Q2RzIzKzhSTnZIZmdhaUFFUkVSRVJFUk5SOGdsb05zN016aTMrcitZRWo5Wkl5dWpBTVVTNlhUTG1kdG1WM3psWU5MdGxrSkRSbnhiSkx3MCtsN0xRV3NxMnZMZitWNWQvb09acGR2U3hmSTQ1Q3M2MldEOUxnT2k0OFU5ZW1HdlRaa1hxeDBOUkRTVm0yNjdMYkNSRXRvVlhOVEhKSjB2UTlzMXN5MWEvYU4zdGRIMFJiU0dveWQrWXZPalV6dHByZnhiUzJ1d3h6ZmpDdXRDcURpSWlJaUlnYWppWEpSRVRYa0k0NXhTREJOd2ZuOEg4K2N3V3p0Umlsa01XYXk4UkpmWkpLWGVsazQyeEQyTWRDNTU1c1J0NDBVMnNkMTljcGFwNE9oRVIwYXlvSzZsTlFnVXFTN2UwVTUzclFyZytkYmNGZVZZdTFuZjc1MDRQd0hRZWYvZkJ4RzJTVVQyMXZoMG9pSWlJaTJ2M1NtU3dlZWV4eGpJK09ySGk3akNJN05UbGhSOG5kVG5NejAzYUUzcG1aR1RRRENTOTY5ZlJMdUhUeE5kRGE5QlZhRU1ZeFptbzFiSllXMzBmRzg1SDFQUGpiR1ZUam1LcWcxcjU2K2QzYi96cHc4ZXRtK3NaOGZ0RWI1K0ZCR0pvaXRoampVMVBZQ3lyVkt0TG1QZkxjZW9jT2YwbUFXakpmMlBucDRFRk02aXllam05RG8yWGFzdWpxYjhkMkNpb0J0Q2tIY0wwM09yUG9KRUpTbmtLU0tTQko1d0dHb1JEdEdQSDRCVVNYdmdWZGFZN2pGTnA2eWZRVm9EcG42c29ZWWtSRVJFUkVSTlJzbnZycWwvSG5YL2tpaGdZSDdOK3RyVzAyUUdkdVNhalJ4ZGZPNHVxVnkvaExQL3hqMk5mVGl4WnpuNzBXWWlUaFJiS05waWZIVjd6OXlORzdjYWovZHF5V2JEL1oxcGxzZHRuMWxYSzlyL0pPRERHcTFhcDIwSS9SNGF0bVcxMWVkcHVmOG5IZ1VMOTl6WTFRclpSeHh0UkQ5ZlR0UjIvZkFSQVJMWEREL0NrVnBVcW1adWtQeko5OVNxbmpabjYzbVk2RGFBdEpncFpVN1haeFRCWnFFT2thNWJuYk84WTdiUjdsT0VWdE9JaC9QbEJnWXdnaUlpSWlvazNBQUNNaW9pV0NXS01VeFBqendWbDhaN1NNY3BBZ1NGaWFlVU1TR2lTYng0NlZvTGF2bEU2ZVZrb0s1WUtXem1CYWFwYXZIVVNlaUpxQ3JvZU9hUWtkTTVPTUFoV0g4OWR0NzVkVysybHB0UUtDRGU5elZZSlRJeVYwWlQzY3V5OEhJaUlpSXFMTkpBM0k4NFVXMnhpL283TUxsVW9aMVVwbDhmYmhxMWZnK1J5c2tSckhsWElzODdrcitDbEVwaHlwR2pjdUZMdGVWS1dROFR6a1BOOWUzbFl5Z0p5RTBCVEhnWkV6UUdsOC9oeDgrWG00ZkE5ZGM3M3Z1VGJrUFk1M2I2aTdqTGJ0dVk0TkxYSmRkNFgzcUw1dGpqdWpHTlVGZEtLTXdGU3BGYkcya2IxdnhrdTV5SFZrc1oxYzMwRVNKZlh5a0NoQU9QWWFvcW5MU0NyVGlHWThhSE5kTkR1Q3VEd0ZKOXRxdGhzRGpvbWFtYTRXb1V1VHBxdzFCdTFSUWRYOHhDdnowNTl3ZEdBaUlpSWlJcUltVVNyTzRjTDVzemFVWjNSNHlBYjBpTHRQbkVRVUJyaHllUURWYWdVejAxUG1sRDYyQXhkY2Z2MGkydG83Y005OTl5T1R5V0F2U1V5NWhtd3pDZWhwQkdYcm53cDJJSTJWVEk2UElwdkxvNnQ3SDNhS2lxay9tNTZhdEFNU2JEWUplSkxQWkJLenZJbUlsbE9tS3RHRlcwYUMwNlpFY2tncm1aelhsTll2YVFreE1sV2xEbFMvdWR5NHlyVmRTSnM2V1haM3VMSFliSjhvMFhBZGRjTXk3OUJNcG1RY0xCVnZRakpXdW5ReDJtRk44MlYxNTNzbTBTNmtkZkp0clZTeFhFTXhWMGJqR2dvUkVSRVJFZEVpQmhnUkVTMVJqUkpNVmlQOG0rZXZZdHJNSjJzc2o3Z3BDVENTamt3eVF2ZTJoUmZOQnlkSkp4dnBlT1ZwR1liSHJKZXFoNk93Vkorb3VaanZwSW9qcUNpQUNxcTJNNDNTMjl3aGNuNy9sV1R6b0xxUlVtam5uejgzZ1RzN01nd3dJaUlpSXFKTko4RXAwamhjUm5BOTFIOFlJOE5EeXdLTVRyOTRDck16MHlCcWxMVHJJWFkwdXJNNUZJT2dvUUZHRW9hVE1zdHY4ZE5vYjRiT0pYTGVYWmtDWnE0QTU3NWl5czVxV0tuUVRNSjhIRWNoYTlZNUNFTlR0QlpndDVLU0FIbWQ4cHBUSzRTakxiU2gvRzcvTlF3bExlaDNaekNwc3lnbWpXdGpuY21uME5YZmp1MVVtaXdqRG1NNE5jbWFEbEI1N1pzSWhzOGltcjRLekk1Q09SNkN1OThCdi9zdy9IMUhvTklGRUZIemt2Q2llR0lBdEhmcDZxeWRzTjFsN2tSRVJFUkVSTFJJNmp1ZWZ1cEp2SGpxT1p3OWMzcngrbmU5OXdPb1ZxdDQ5dW1uYkxDUkJCaUZwbHhXSnFrVEtjN040dWl4NDNzd3dDakJ4UGdZaXNWWk5FSzkvcWtIaGNMS1padXZuVCtIbXFrajJFa0JSbk9tdnV6S3dLVmw5V2liUlFLbEt1V3kvVndTRVMybHRCZWE2c2JTci95VnIzeHg0YnFmKzYwbjJrMGxYSHNDNytNSjlHR3QwV2YrWm9EUkRVaHRyWlRrYXMzT0RqY1NheG1nM05TcjNtU2M3WnAwR1VGOW91WWliMW5hVXphSWFpZVI5aDZldy9paTNTcFI2ak5LWS9SVGYrM0pjUkFSRVJFUjBhWmdnQkVSMFJKUERzeGd1aFpockJ6YU1DTmFCU2xRbENBalIwc3ZKMnc3S1oxMjNYcWdrVnhlV0Q4aTJuWXFyTm52cEFRWDJkQWlDUzlxZ3BTeHhFL1BEKy9BeW9acnZUeGVOcFYvQ2M1UFZkQ1NjdEdiWjEweUVSRVJFVzJ1dHJaMjNIWDhoQjJCZUhUNDZ1TDFjN096ZGpSWmFlaWZTcVhRMGRtTlppT040R1ZFNUZ5dWVjSlJXMXBiN1RyUnl1Uk1NT3RKZVpaR3BET21QRERhVUpDUkRTNXlYR1JNMlZRaG5VYkdhNUlxbURnRVJzNEFrNi9YdzR2MGpjdktsRGsvem1lenlLWXp5R1YyYjdpN2t2ZktsR1c2enEySGUvUlZndVBPR0M3cURnd2syeHM0dEpsMEZLQTIraDFFMDFmbXI5RFFTWVRhNEV0bWc3bG9mZVNINFREQWlJaG9SMGhtUnlISE4wN2JmaEFSRVJFUkVkSDJHaDhieGJlZWZnb1RZNlAyNzN5aEFNL3pjZktCaDFDcGxERTdQV21iT1M0Tk43cHcvcXdOTkFxQzNSc3l2MTRwVS9hZU5oTTFqdFFqOVI4K3N1ZkNzb2lvOGFhQnFxbEptMDRRUFFtNDdVcnBxNGxXbldiK1htMHphRlFmNkEybWlqcUtkVkh5ZVZDZmFCMms1bHRhb29mems5VFFzelU0RVYxUG5URjdpMkdGNUdVem53QVJFUkVSRVcwYUJoZ1JFUzBoQVVhbE1MWUJSclFHelJKZ0pEWDVVdUxzdUc5Y3h3QWpvcVpSRHpCSzRBU2JQL3JUV21nLyswYm9HUzF6ZXJ5TU9ORjRiYXFLQTRVVUE0eUlpSWlJYU5PMXRMWGoyUEY3bDRVWGliblpHV1J6T1h1OU5PNXY1Z0FqV2M5bTBkTGF6Z0NqbTVBUW01enYyK0FoS1ZTYVJuWERBVVlTV2xRd3krek9adUUwUzlOSUNUQWFQUVBNWERHWGI5N2hSVjVEb1lrK3c4M0FSNHpqN3BqNWJPenVLalZ0UGllMXdlOGdMcy9NWDVIWTFyNjFLeThpbmh0Ri90N3ZodGQ1RzRpSXFQa2x4VEViV01nQUl5SWlJaUlpb3UwM01UYUNaNS8rT2liR3gremZoVUlyMHBtTURUQXFsMHNZR3huRzdPek1zc2RjUEg4V1E0TURDSUlhYUxsME9vTlVtaGtQalNUMVNES2xNMWtRRVczRXAzL3l5YXFaeWZTay9QMDMvOU1UejZLR1Bpam5idk5ubTVrWVlMU0VxWW1MZ2dRelNYM01iZjY0clZNOFAwbnZINm5wbDE0a2JBMU9STmZUWnhUVUM2N1dMLy9TVHo0NURTSWlJaUlpMmpRTU1DSWlNcjU1WlJhVGxjZ0dHSVh6cGNDMEJyTE5KQ2dvQ0tXWGsvbDEyZUtmRjNudWhYbWkzMWdmQ1M1YXVJMkl0bDJTbGc2UUd0cnhvWFFNSlIwb0U1bHZUOGlZOWxMUXJtZm1Qc09MYnVKS3NZWmZmZTRxM242b0JVZmFNMGg3Q3A0RVBoRVJFUkVSYlFKcElDMk45cytlZWZtNjIrSW93b3VubmtOUDMzNGNPWG8zbW8yRTRlUUxMY2cwVVFOdkNWT1NkYUtiODEwWHJSSStaT2FkbVF4bWFsVmJSbGcybjduRXpHOVdXcGp6NmdGSTdla01YRk11bHZkOWU4NWt3NHQ0cWtrN1JMWXlpa3gxRHJtNGlNUUo0R2V6OWF4NEtlcDFFemptZW5meWd2bXltREtVM250QVJOc25DQUlFdFJwUzZmVGlkZHA4ZjVQWllTUmx0clVsb3VZMFp1b1pabW9oL3V2TFYzRmx0b0lYaG1aQVJNMUJqdmx6dm9lK2xqUWVPTkNHUnc5MTROSGJPa0ZFUkVTTlU2MVdNVEk4Wk0vcHhkdmUrUzRjdk8xMk8xaURuTisvKy8zZmE4dWgvK1QzLzR1OVQyaW15Y2x4TzJqQ1UwOStDYjE5Qi9DT2Q3MFhlMFVTeDdody9xelpac01yM242by8zYmNmc2VkV0MzUGxPRkx2VlBmZ1lQNHJ2ZCs4THJiVDl4M3Y3blB6dXBPVVN6T3pYK21yZys0U3FYU3RoNnRVWFZEOHBtVTUrcnMzZ2Npb3JXYUN6SHU2bG81amZUUGVkcTdYU3Y5WSticUUvTVRVVU5WVFJsSFVXdWtXRWxQUkV0b3JjOHJSNTNYV24wMlJQU05YMmQ0RVJFUkVSSFJwbU9BRVJHUkllRkZWMHNoeHNvaGFCMzAvRDlKRTRRRlNXQlJQQjlnbENUejYwWkVUY0gxNnQ5TlQ3NmZwb0pJejM5WFZiSTlZV09PVzE4bkNWNVRET1M1a1VxWTRMWHBLbzUzWlJGcjVzSVJFUkVSMGVhUzhCOEpNVm9wQkNpS0lzeE1UOWxHL1UxSktkdklYY201UnBPUWh2azdyZUg5ZG5ETmUrZTZyZzBpOHJXTGl2bXNRY1ZRZHE1dWVpSmt3NHJNZlhLK2I1ZVRsWkJjb2gzR2l5dG1xcHBLdzlnVThTWklQTmMyN1pWZ05nOEpIQm0zTkNnRHRUa1EwZmJTcGg1R1h6c1FSeHhBVjR2bXh1MEppaWNpdXBWS0ZLTVl4SGgxYkE3bkowcjQ2c1Z4RUZGemtHclNsclNQbzExNUZOS2VtVGRwbVFzUkVkRU9Kb016eUxTZ2UxOFBEaDdxbnkrLzk1SE41dERTMm1ZdlIvUDNDK2ZEamthSGgyd2d6VjRTeHpGS3hUbXpEV29yM2w0b3ROaHR0bHBTUnlMMVRqSWRQYlk3d3RubDgxU3JWbTN3MWJVaytFcnEyQnBWTnlUUEljKzE5RE5NUkxSYW4vN0pKNnRtSnRQay8vQWI3eXZHYm5URjFMb2VBdEVta0JxU1dDbzQyY2FaaUpaU050dHN4QndtRC96Nng1NjhCQ0lpSWlJaTJuVHN1VUJFZTlxbDZTb21xeEYrODhWUm5KMm9nRFpBQ252RHFON0N6WFhxbmJ1Y0xRZ0VrZWRNVEpGemVHMEFpbVlCTkZFek12c0c3Zm5tNjJrT1EvMk1LUk91SitLb29HSkR4eHlaYjNKQ2pwNFBMa3JTR2JNdUtZWVgzWUtFRmhYREdLZEdTL2lsWjRmd2wrN3F4TW1lUElpSWlJaUlOa05yV3h2dVBuRWZEdDk1Rnc0YzZzZlk2UEJpUS8xeXVZU3ZmUEdQN0VpNUgvcklSMWUxdkd3dWI1WnptMjM4ZjYxcXRZSm5uMzRLcmUyZE9IWjg2d1o1bFBXUnh2Y3JlZVdsRitCN0hoNSs3SEhRMXBNZ0lwbjY4Z1VrNXR3MHlXc1pqUTNWSkxaL0x6MWRUWHN1UEFrK21qK25sTWMxTFM5dFBuaHZNdk1VYU8waU9CaE0yakNwczlpdDhoT25rYW5Nd2l1UDJiLzk3QnV2VmNWbHN3T3VJQm40RnFMWklYajlqNEtJdHMvWTBHV1VacWR3Ky9GNzM3Z3lWWURUZFJncXhjQUJXcDhvRERGdzVqU0tNeHgwbGhvcmpCTlVvZ1QvK3FueitKT3pJeGd2QlNnRzdQUksxRXhraktyWldvU1hSbVp4ZHJ5SU02TnplR1p3RW4vbDRjTTQyTHA3ejRHSWlJaTJ3NUdqZDZPemV4Kys1L3QvRU1kUG5GeDIyNkgrMjAyOXg0L2loZWVmTWRPemk5Yy8vZFJYelcydjI5dUlGdFJxVmN6T3ppQ0pydyt6VG1leXRuN05hVkRiWFFrdWt1ZVM1eVFpMm9oLy9kUC83ZnhmK1kyMy9rSUdtVGM3bm5wQUovaW9VdXBCN0dHT1FpcmxxYTRnMFJ3aDV3YWtXNG8zM3kzbFZzcno4eTR6TmMrUVU3VERWQlZVRFk1dEdNREdGVHVjaGg1V2pucEtKZmlqV2pyK1E4ek5sVUZFUkVSRVJGdUNBVVpFdENkSnh5UHBielFieExocUcwckdtSzZ4c2VTR1NTOHVyZXF0M0J5OEVVTFN5QTVjZXY2ZmhRNWpNb3BNTWo4bm9wM0I3aE9VL1YvMngxQ3l6NmhYRjJrbDg4UmN0VG5mYVMyUlNkSkFReWJsTUx4b2xiUnR2QnpqeWx5QUtmTjdXWXNTcEQxdU95SWlJaUpxUE5mMTdKVE5abEVvRkRBeHZ2eTRjMlo2Q3JNek0zWVVZbWw4ZmFzRzJLN3J3aytsN1h3bDFXb1Y2ZXJXaGxyTCtuait5bTBRNVhYSk9sSGoxWXVVekZuaFRjcXBGbTZUZnhjQ2llUzhOWmsvZjAyV0JoaVo4MWpQMlVIblJabFdJTnR1Vmp4dlBtZ0JFSWVnVzV2VkdUdE5tNm02bTlvT0ovV3lGNjg4RFJYR2NDclRacHBCSEszMHVaZ3ZvNWtiTTk4UlU2MDRPMkwvZEhPZE5zaGVLVFlCSnRwSzVaVkNFTTF2a3ZKU1VDNi9qelJQeXR1ZDFYMGV0SlRGbTZsU0xLSlc0V0F2MUZpMU9NWnNOYkxCUlVPelZaVE5jVWVjY0FRYW9tWWo1N3UxU052NnY1RmlEWmNteTZpRU1ZaUlpS2l4Y3ZrODl2WDAyb0VYOG9XV1piZkozejE5QjVBcnRDNjdmbXB5d3Q0V0JqVnptdWZhK2hNaTIvN1psUEhxRlFZSkRHbzFWTW9sTk5LTm5vdUlhSzMrL1U5L2MvSnYvdWIvNTZvcHpPNVFjS1RDYWRaTXJkaXJsQTNvOFJUemRtNm9YbSsvdXZ0S1R5Q1daalF0YWI2ZjZFUTdTalh2eUZBT2JPZUZ5T3lmMkRGcHA5TzZhRDVwMDJhbjhIcXNNZlNwano0NURpSWlJaUlpMmpLc3lTQ2lQU2swUlVyVktNSG56b3pqVHk5Tlk2ek1EanNOSTBGQzFRRHd6VStNcitwQkpRMHRacHdQTDZvRjlVU05pRVhOUkR2YWZKaVJUdWZzbjBrcWEvNko0WlptNWtQUkdsY0hJTFVmY0Qxbzh4dzZuVVdEZDA2NzNsQXhNTk1rRHJlbDRUc09UblJuMFpibTZRUVJFUkVSYlE0WkhmYmh4eDdIOVBRMFJvZUg3SFZoRU9EVjB5OGhsOHRqYUhBQWJlMGRkcnFabE8ranRiVU5xWFFhelVMV0o1Y3ZnTFpXYk1xc0VuT2VLZWN6YTJrVEovZk43dlJPSVo3NS9CKzR2eDVnZFBJSHpBbmVDMmI2RHVqV2ZpdDRFSk02aTgrRjkyRTNjU3B6cHV4bEZuM2YvSy93eG9hZ3l6T29taktZNFpzOWFQenpkcGE5OUNLY1hBZTZQdmozN056dnZBMUV0SFhPdi9CdEc0UjR6OE52V2J4T3llK1VUQTdMNnFqT3lYWEJhZG0zcXZ1R3ByNnRORHVMYzkvNXRxbmlZNTBiTmRiQWRBVmZQRGVLVjhmbk1NZkJoSWgyaEZOWForejBFdy8yNDJnWHl5NklpSWdhNmUzdmZCZmU4YTczNGFDcC83aldiZjJIOGFHUC9DZ214MGZ4emE5OVpmSDZGMDg5aHhGVFIzTEcxSTNrQ3dVY09YbzNpRzVtZkd3RS8razNmeDNySVhWdlJFU2I3VmQrNnM5UG05bnB2L1ZiNzBrQitxd0dmaEo3Tk1SSWFUaStVaG5YMWwwektHNGxzbTI4VlNZWWxjemRBak9QemFiY1JjUFM3QXJtYlF3OXBhWVNoVXdDdEtGSktVZEY1ak5YTlIrNURHam4waWhxcGY2TGVVZlAvT3BQZmVrWFFVUkVSRVJFVzQ2dEdJbG9UNnJGQ1M3UDFqQlpqZTBvY2h6b3NjRnM2SWl1aHhtNVRyMU1mYU5oNlFzanVNVHpnU1lKZzgySmRpTzlFR2prK3ZYdmVoVEtYMmdJSmN0MXBZWUJ0SDR6dGRqK2h0N1pidXBubXFjUE9CRVJFUkh0TXVsTXhvWVRlZDcxZ3cxR1lZQ0o4Vkg0cWRRdEE0emsrTi96UERqT3l1Y0JrVG5uaU9QVmQ5U096SDJMeFRrYnByUVNXWjlDNGVZZC9HUjlYSGZsUVJRVHMzeFpwN1dROWFsV3lpdmVKdXR5eTIyMFI4U21iRW5lUDA4Q2pMRDlaTFRpbFVxMzdDZlZuTDl1eWpwNmFlaTJnd2dxbzJZYU5wKzNHblFjZ0s1WGluMUUyc0ZnMEdvRGpIWU5LV3N4M3dOM2JncisrQkNjYWhrcVhsdlpTMXllTWVVM0RtcERwK0YxSElUZnZyOWUxc0x5RnFJdEVRVTF4T1pZWVhKMDJCNEx0YlIzdm5HakJCajVacDhWMVJvYURFODd5SHo1T3FSODNVMnQ2aUd6VTVPWUdodTI0VVZhczhLVUdxcytGazBDN3BHSWlJaDJydUc1S29KWVk3SlNnNVJZU1FmaTlxeVA5b3lQYk1xRnF6aHdGTkd0U0JCeGExczdPanE3NStzOXJtKzZyMHk1ZGNiVWkrUUxMZlkrSlZQdUgwVnZoSUNPREY4MWorOEMwYTFVcXhVTVhMcUE5YWhXcTlkZEo1OU5xYlB6UEVaQkVGRmpSWEUwNlRyT2VYT0lPV2IrTk1WSHFoMUU4N1NwNUZCYUplYnpJUldRcTZxRWpPdkQzSUtEMnpZZkpYRmQ1ajExVEtWME0vZmJrcXdzMTN6d0hINkVkcklCclRCcVBtOW56RThMMHptSmlJaUlpTFlKQTR5SWFFOTZiYXFLejUrYndPbnhFc1lxSE8xeFUwUnhQV1FvWlNvdXBiT2h0RkRkU0tNVktheVVaWVJoZmRsc1JFMjBPem11bldKcHJCTkZjTXV6cHJZaU5sVVhHMnplTHZzZjE0WE9GbXduTzNhcVc3K25yOHlhMzlFSzd1M09vU2ZQeGlsRVJFUkV0RGw2K3c3ZzVBTVA0VXRmK0lQcmJwdVptY0hUVDMwVkR6LzJkdXcvY09pbXkvRjkzemI0VDZXdVQ5L1VwdHlpVkN3aW5WbDlPTW5zekRRdW5qOXJPdzljSzJPV0krdDhLN0krMld4dXhkc3FsWXBkcDlXU0lDVlpuNnRYQmxlOC9aNzc3c2VoL3NNZ3MyMU5tVkk1Q3BIeG0rTThKalJsVzdYbytuTEpqQ2xIYzJ4bnNNYWZ0eWFGSHNRUGZBU2p3L3N4c3I4ZDFabUxpQ29Ub09zOVh6cUFXdUxoYzVXVGlKTGRVNGFnd2dCT3BZVE1xODhqLzhMWG9JTGFtc3RjZ2lzdjJwQ1VhUHdTOG0vNkFES0gzZ1RscGFGOERrUkp0QlVtaHEvYStYTmYrVk4wOVBUaTRYZTlkL0UycDlBSnQrTWc0cWtyNW9lbUF0cURYQi9LVEU2aHczNGVWdU03VHoySjJja0pSQUZERGFueHdqaEJNWWhOMVM3cmRZbUlpSGFxTDV3ZHRTRkdYemc3Z3BTcmtFdDUrUENKL1hqZ1FEdU9kdVpSU0xNSk10R3Q5TzAvZ1BzZmZCUnZmdmd0TjZ4RHlPWHlkcnJqNkRGN254ZFBQWWVaNlNsN205UVpmTm5VbGNodER6MzZWaERkektncE8vck1weitGUnBINk5hbXp5OTlpOEE0aW9yWDZ0WjkrOGdzeS81dS85ZTdIVGMxOW43bjRUaEROVTFBMVI2R3F6R0VTVmpuVWFrWFZrNDVZRXRsOFpQeGgzMUZTVEJ5amljdUtQYVdjcktka09ESjJNdGlwbFA1bGxhalhmK1dudnZJNUVCRVJFUkhSdG1IdElSSHRLYlVvd1dnNXhQbXBDcDRmTG1LeXl2Q2l6YVB0ZUFpSTV6dkFTRkhlZXZLTEpLaEl5aW5qdUw0c21WWVpYcFF5Wlp4U2VuallLWnE1Uml0Q08vY1Z4L2trMmdxUitjYkZXcUZvRGpubDhxV2tZTC9PTmJpcmVMUUVEamxJMGxtb0tKQmV1ZVlhdmI3d01sdnprWVoyWElZWE5ZRDhkdGJNdnZqeVhBMnRhUmY3Q3lsNEhHNkNpSWlJaUJxc3E3c0hPRjV2dEgrdElBZ3dPankwcXFDZmJEYUxucjc5TmpUb1drbVMyQTRBYXdrd1NrejVoSXhBRzBzNXhSSXkrbXdxdmFwMmMzWjkybTh3VW5LcE9MdllLV0UxdERsSGt2VUpydWx3THNGTmppbUxVUndCZlZHc0U0VG1QWS9rdlhNY2M4cTU5ZWVHWVJJak1lL1pkSzFtMWtjaldDSEF5SmYzemN6YjB4azQ1djNMZUkyb3h0R21TQzFDdVRhQndmRy93T3pjQmN5RzQ0Z2NzejdwRk9oNnJVNE5rUTd4emtNWFVRcFQrTDNYanB2dm16TFg3ZXd5QmFkU2hqOTZHVzV4MnBTM2hGaDNFMTd6ZlVvcU00aG5SaEFNdndxdjR5Qzg5b01nb3EwemRtVVExVklKWjcvOUxQSnQ3ZWplZndCSktnK25yUS9KM0JnMEE0ejJKSlZyaDVOcE1VWGdOeTZEcjVTS0NNMnh5UERBSmRUS1pZd04xVDlMUkVSRVJFUkxuUjZaUlJCcmZQNzBFSXExQ0plbXlxWThUWm15SzRVdm5uTnhacXlJVHp4Nm1BRkdSS3ZRMDNjQWp6L3hIanUvbFlYQkhTNmNmM1d4cmlBSWFqYlFTT28wcXRVS1BNODNFNzk3dExMdW5qNjg0MTNmalVicE8zQUkvWWVQb0syOUEwUkVtMExGZjZDMTAyTHFSOStDZW1qSW5xbThsTHBnMTlGZzg5dnJtVTBUTzlMYzNGU1hyL1l4MGp0RWFqNmxCbFNHTk5ydFIwdDJ3NWdYWE40Qm54OWxhaTNNdVdSS3hkcHI1cUVVek9sdVNvSjdsVkljM1hmbktOcEo0eW56dm8xcmpXY0NCQnpGaTRpSWlJaG9tN0VHZzRqMmxHcWNZSEF1d0xtcEtyNDl3c2E0bTByUC95T2R3aVJ3eEhZS1cyY0pxVHhlZ292Q2FFM2hKU256L0o1S2NOeVpOVDk0Q1E2cHNwM25GWU9yaUxaQ1dYczJObXhZWjFHRmErZUoyUS9VOUNvQ2pHd25XeGM2WGU5SXJNeStSQ2ZST3ZjaUVtQ1VxWWNYT2FzSlQ2S2JtYXBHWmdLdW1OL1R0clNIbnB6UEFDTWlJaUlpYXJpdTduMTJ5cTRZWUZURHlQQlZsSXB6dDF4T0pwdXowODBDak5ZeWFxd0VGOVdxRlROZlhyYVF5V1NSVHErdTdaeDBRT2k4WVlCUmNjMEJSckkrc2syVzhuemZqb3JMQUtNM1NHQlFaTjV6bVNzemJjZlpvUVFveVRSYUx0a2dJMW1mYTBsRFZYblgwcTVuenJXY2hnUVlTWEZha29Rb1Y4ZncydkNYVEJGYkdXRmNydGNRZVF3d1drbHJwdjZkZWlKM0NSUFZIUDdrMGpIejNwbDNKdDdaQVVhcVZxb0hHTTFObWJLV0RaU1J6Z2NZUmJQRENFYk9RcGx5RndZWUVXMnQ4YUZCRkdlbW9VeTVYTzl0dDZPbHZRTk9xbUFEakREOEttaHZjckp0Y0ZwN3pRNy9aZ0ZHSlpUblpuSHVoZWN4TXo2R3laRmhHOUpKUkVSRVJMVFU2ZEVpaWtHRTN6dDk5YnJieGtzQkNpa1BIejZ4SDBjNjh5Q2ltK3Z0MjI4RGpLVE80MVprQUFRSk1QclNGLzVnOGJvd0NHeUFrUXpHVUt0V2JXOTFCaGpSamV6cjZjRVAvc2hQb0ZHa0RrMENqR1FnRHlLaVRURmIrUU92SmV2RWNIOFJzRlc0ZTZyeVV0cmVza3IvZW1hYlJLYmV2Q2ExczZ0OWpKNmZvdmxwdHg4dDVhQnM0bGQ1dlFQV2JDR2x0RXE3S3BWb2VWdWFkMzFkUjBtQVVZcE40bmNVQ1RBYVVjcjlMdzcwbVN2NW9kT2YvZUhUelp5VFJVUkVSRVMwSjdBR2c0ajJsS0c1QUw5OWVoU0RzeXlUMkRJU1BHUktHMDJKbnUzWWdyVlVuaWUyZHhVUVJQWDVMY0tMVEtHVHFibEkwS2NxYUZjQmJsY2xaRlZzL3E3YTI3SlliL2dKRWExSHluei9QUE85MzYvSzV0dm40THZkSWZzdFBKKzBZRnFuRmdPTll0eWc4NS9VeXBtdnZmWlRpQjBIVHEwQ0ZZWDFmY2txSmVheDBsa2o4V1F3Qk80Qkd1a2JWMlp4ZWJhS2U3dHo0S0NLUkVTMFYwUmhpSEs1akttcEtWeTllbVZOaiszcDZVTXE1V1AvZ1lOd1hZWXFFcTNXWGNkUG9GSXU0ZVVYVDludm9KaWJtY2FwNTUvQi9ROCtiTDZUSlJ2VWM2dkcrcTF0YlRqWWZ4aWp3ME8yc2IrSW9naG56NXcycHgycmJ5QTFNejFwSDNOdHlKQ3NaKzhxUms5ZUlLRktzajRTd2pROStjYmdYd09YTHFBcUhSQldhZUUxeUhvdEpTTTU3K3ZwaGV0eFlMZ0ZFaGdVNjNxQWtBUS9wYlp3WDV3Z3NjVmF3NldpWFE5WGhvbzBuOW1zbVVyeTIySW1QZjlKVE9iTHY4WXJaV1JjejY2bnAyUjArL1d2cjlZUkpvc1hNRnU1Z2xvbzZ4Q3VlTC94eVJyaVdHTmd1SUs5SXBWeTBKTDMwZEZhbjY2NzNZMlE4d0xjM1RtRzhYSWVBM050Mk8yVVovYXB1WGJ6WVpRdzZRUnhVSUtPYWl2ZVY0ZFZSTVVKK0xVeWlHanJCZFVLeHE1Y3h1emtKTVlHTHlNVHpTQWwrL2laTnVqVkgwN1FMdUpNNVUwNXVnZnZhMStEbWg4Y1lFRVVoT1k0dUlyaXpBeUNTZ1ZURTZNSXpMRzAxczNmdVlHSWlJaDJwMm9ZMjRDY2daa3lCcVlydURSWlJqVmEzamZWVlE3U3ZyUTNVcDNtSlBYT3FXcllqVS8rdXh6K3QwOVVwQWNrYU5OTWxtdVlyYTFjaGlUdm03eFg1eWVLYU0rbWNIemY2Z1BpaWZZaUNSNlM4Q0taMzBydi9vUEk1WExvTzNBSWsrUGptSndjdDJWMFl0cGNmdnFwSjNIMDJISGNlZXdlRUswa1gyakZNVk5uMVNpT3FhZkltcytrNjdKeEdCRnRqbStrbzhxUjEwZFY3KzI5bjFkd1pMU005MkNQa0NiU2p0N1pMWnRsY0I3UDFmVnhyaHU1WExOMVBFZkxHQTVyM2p3VkpRTWFTZVlqMjR3M0MvTStlbGxQNWVKRU4ydURPU21NcUhwSyt5a1hLWWVwWWsxTHVwV1lkMGNhdEF5YTZiVDV0cCtDaXIrZEtKeHh3L0k0UG51dmVTOVBnNGlJaUlpSXRoZExrNGxvVDZsRUNiNTF0WWh5c1Byd0Myb0FQUjlFaEhXVVRzdGpaZVRYVlRTZ2xxSkNLZFhzUW1CRGpPNXk1dENxUWhEUjl2Q2ttTmpVQXFWUTMrZDJxaHBxMmpHVlE1NzlybzdwN0syN0Nkc2FPazlhUThpUVl1YnZhRzJETHl3OGxvMG9HbTV3Vmhvc3hxaWEzOWJXTkVNWWlJaG9iNUNPbmRWcUJWTlRrN2p3Mm10cmZDeFFLQlRRMDl2SEFDT2lOZWp1M29kRC9ZZHg5c3pMaXdGR29abGZHWGdkVTVPVE5veW9IbDUwODJQK2JEYUh6czR1MjhEL2pRQ2owQVlhZFhWM1k3VWtYRWdlYzIzSWtJUVhyV2IwNUFXeUg1RDFrYktNcFFGRzF3WWozY3JDYXlnVzU1WmQzOWJlWWRlSm96QmZUL2JseVJZM09Gc28xcHF0MWV4N25wSmdJbk91MnBiT0lEWTNWcUpvL2o1dm5QQVd6VG13M0JaSm1acmpZQ05SVkltT1VhbE5tR2tLY1hMalJJdGlKVVlRSm5oOWFPOEVHS1ZURHZxNnRlME11VktBa1dmS05kSnVqTDVjRVZIczdJMEFJK1hBeTdZaGlVTm9NeVZSelh3eVZ3NHdzaUZIdFpLOUh4RnR2Y1RVbmN4TlRkbHBmR2dRaGRZV1pESVpPT1dVS1VadEFlMDl5cnozVHVKQ1hURG5xMnA1blZ4UXE2SmFLcUZpcGlpb2dZaUlpR2k3UllsR01ZZ3hNRlhCcWFzek9EVTBnK25xOHZOTHoxRW9wRDBKZ3M2MXBOMTljOVU0RC9TazhJLytrUlJ3TU1Cb0U1VnR3RlM4NG0yMUtMRWxCZU9sQU1OelZRWVlFZDJDNS9uSUYxWjNudDdXMW02bkRsTi9rRGYxaWpKNFFUUWZZQlNZdW8wTDU4K2kwOVJGM0FtaWxVbTlVTThhQnR3Z0l0cHV6LzIxNThMbnpQeHYvbGJmS1hPSWJ5cTkxWjRKTUJKU2JiM1RvMUpjOHlLY0J1Zkx5amFSRUtQMVZPdEhNc25qZU1iWU5FeHRoZkpkcE9VY3Ywa2xaaDBEeDFGT0U2OGpRZllOMHJKR2hlYkNoTkxxQmZQSFYzLzE0My8ySklpSWlJaUlxS213OXdJUjdSbS84Y0l3Qm1jRERCZER4Q3lSM0hxaEZBY3I2YUZYLzl1OVNaaVJsQ3ZKVkEzZXVId1RLZk9PdGlIRUlhZU1CNTFKRk16bHJJcmc4bjBtYWpwcGxlQUI4ejJ0bXNQUWg4ejgxYVRWVGxQbW14emRLT1RNVmlRcEpKazhkRW82NE14Q3hkRk5uMGRMYUpGNVlKTE9vK0ZEZTVCMWRySnFkK1d2VHBWUml0SzRveTBESWlLaTNTNU9FdFJxQVdablozQjE2TXFhSHR2UjJXbE9iUkk3RWRIcTNYUGYvV2hyNzhUWHYvWVZWTXJsWmJkZGZPMHN2dkxGUDhMRGIzazdicnY5anBzdTUvQ2RkK0c3M3ZzQmpJK05vbFFzMnV0cTFTcSs5ZlJUaUtNUVE0TURLTFMyb2JWMTVYQVNDUlk2ZCtabG5IcnVHWnc1L1NMaWVIbm5uVWNlZTl4MkpsZ3RDVHVTOVRuejhuY3dPSEJwOGZwWFhub0JydWZaOVpGNTcwMGFtYjk0NmpuN1dGbWZheDA1ZWd3UFBQaW9EVEhZUzJxeEtmZUxYQlJyTlJ0VUZKa3BOdnRkQ1FJcVJ4RUM4NzRsdW1UUFBzZk1DWTJNbkpkMVBYTnU0eUJseXF6UzVuSjZFMExtSnMxbkxUVFBMYy9ubS9QVk85bzdiTEN2UEs4MGdPc3c3OU53cVlpNStYQ3RCV0VTWTd4U1JzSDNrZDFBR0pVRUdKV0RDZFNpMlJWdm56Wmxwckg1ZVhyeDFWbnNOYlVnd1pXUml2Mjh5TlRabGtJdXUvd3o0Smd5eG9KWE5aK05XNCtRdmxQbCs5OE1MOStKbGp2ZmFsdEtPeWxUbm9KNnVXeFNLeUVKcTVoOTdSdUl5OU9vWEgwRlJOU2NTbk5GbElzbDJDWUFPZ2ZhZTlSTVZSSVR6WVhyUXpHMS9DZWRYalhyenFqSkJlWnp6TElUb3NhU1VEczUxMVV1NjAxcDI4M1dJbHlhS3VMenA2L2kzRmdKVDE0WU0rVTEya3lKS1FmUml5RWRTN24xSHF1SHpkSE13U2hXSjB4Qnh5ejBtMzRIZisrL3pPTC8rTUZmQWhIUkx2U09kNzBYdHg4K2d2LzRHNysyT1BEQnlQQlYvTjduZnR2V1pVaWRCQkVSMGE0eWwvNU5YYWc5YkU1aDMyV0tNTnZNV2NCQlVFUDVqcnJpT2lwdExxNStoS2Ric0dQVW1pSm5VK1Z0YzROZ3FzTk5VZlNHSzl3OVYvc1ozODJaK3ZVMUwwdGFnOGlaNWVxSG42TE5Ka2xVTWloeTJrTTFuM0xtcWxIU1lvb0JtcVl4aStkQXRhU1V5cmlLNlVYTnpNSG56S2RwV3NYNnR4elhtVUljWGUwRXFpQWlJaUlpb3FiREFDTWkyak5tYTdGdENCT3hZZTcydUdZVStkVTlScSs2SWJXcnRDbkZqTkdpUW1STitYZEtzV0VyVWJPU0VDT2xJeHRNbEZHeC9mNDZOLzJ1enc4eFltdTZuUGtoUjlTdDl3OEw5MmREM0UwaHY2ZFJESVIyNG04ckVSSHRIUkp1a0pqZnZpaUsxdlM0UkVJekVwNm5FSzJWaFBpa2J4RENFNGFoRFRXUythMzR2bzljTG0vblMwbUlVZFZNOHAzV3QvaU95djJDV2hYaE5TRXpRdFl4blZsYnVFbDlmVkxMcnBQMVdKaHVwVmF0bUhXcXJMZyszazIyMjI1V0wwclNOckFvc1FGR2lRMmZrNzlsYmtPTnpGeUNoTXhPMlp4cUtxUWNEV1V1SitiY1VXOVN1ZUhDT2tuRFBIbHEzenlYSFRWU0d1ck5uN1BlcUMyY3ZJNUcvSHJjTEVSUHdvdVNSS01XN3MzZnFVaCsxK2NuMlE0clVhYnNRdTNpc0hUSHo1b3BBeS9mWVRzM08xNTY4YmJZOWVGRU5YanBQSFJRQmhFMXI0VXd0anEyc2Q2VDdQc3ZFODg5YVNjengxMnN6eWRxTUFtd2MyUzhHS0p0WjhzNXpHNStzaHhpcEZqRjRPeXErNWw1OVVsMW1YbXJPZHh0Tng5dE5nUWdvbDBybFVvalgyaTU3dnBTY2M3VUNkUkFSRVMwMi96SzMvcVQyWi85OTAvTVFydWhPZEJuaTlSTllLcWpJMU0xM2ZEUmZKWlVjOXNjZlRTQXNqWHJwanBkcnoxUVpxR1VuSnFMZlVkTkpZYTAxRkJOK0JZNVNpbkdGelUzblVCR2NTbTVLaGtxVjVMaXAvN2FrOU1nSWlJaUlxS214QUFqSXRyMTVvTFl0dGY5alJkR0VDVXNqdHgyNVdxOXBEby8zNGx1cFpLK0lMS2R5R3p2cVZ2b1V4VTd2ZDhic3FPaCsyeVVUYlFqU01oWUNnSGU0bzdoWVhjQ1g0Z09ZRmhuTWFiVGlHL1V6dEJ4N2NBY1NTWnZPNWM2NWRtVjcyZjJLMG0rRGRyejZ5T0swcWI2ZjE4WngyMHRLZnlEdDk4R0lpSWlJcUpHZTlNREQ5bmdvRi8rNS84N3JtMTVNanA4RlMrZWVnNTNuN2pQL0hYc3BzczVhWlp6N1BpOStPWlRUOXJSaW1kblp4WURpODZlT1kyLzhmRWZ4Zy84eUkvakIzL2tKNURONVd6bmdBVURseTZZKzd5TVgvckZmNFNweVlsbHkrM3RPMkNEZ2o3NjhVOWdMWHI2OXR2SC9NbnYveTZlZXZKTEtKZEx5NEtJWkgyNmUzcnhmMzNxUDhGUHBXelkwUnV2ZThodWsxLzVsLzhFVjRldUxGdHVXM3VIbmQ3ei91L0Q5M3ovRDJLdnlaanp3SXlmUXNGTWlVNVFqZVBGQUtPSlNnWGxLRVI3T2dYSG5DdTJtUGRZU3FXeXZtZURqSnhOYkkxV2l5TlVvc2lzaTdibFY0SDVXd0tMVXE2SFVoaGl1bGExdDE5THdwYmt0bzBPOUtmTTYvVzlQRHgzYnNYYnU5cnJRVnEzSDhqWkVKOHJJeFhzRmVtVWc3N3VEQTcwWkhDd2QrWFFMMDhGNk0rZVFoeDBZRGc3Z2Jsb241MWlMUU9JcnEzYzRVVEhFSHBqczMyYnBJOVJ2di9OOEhJZDZEajVQWERTK1JYdjQ4cjFadXA4OEFmczN5TmYvWGRJb2dDVnE2K0FpSWlJcU5IYzZSR29Ha01UaVJwSit4bm9iTUdjQUxkQ3AvWmUyREUxQnhsd1RzS0xudmpVbjZOb0xyODJXY0w2Nk56OGhmL0J0amY2dTc5NzJCVHluY0UvKzhndmdvaG9GM25yNCsrMDlRRC80Vk8vYXVzMGhBeHFJUFVWVXFlUXlXVHgyT05QNE1qUll5QWlJdG90aWc3T0Y2Qit6aHpwdjg4YysvOWQ3SExTdjBWYUxPeUduZytlaTFyQlY1UFZDSjJSMWh2dXA1aDJWYlkxcmJJeVFPNWFCMnlZTTNlUDVRSzdEVFdkcktleXFiektqaFYxTUJmcnNuYVF0aDBEdG9tRUtUa0tjMmE5M0gwNXR3M1VGTXkrc1dpS2ZDYk1HL1NVMHVvODR1aHpqb3ZCWC9wSkJoWVJFUkVSRWUwVUREQWlvbDF2c2hLaEdpVTJ2SWo1UlUxQVN0dWxIRm5DaVdUdXVzdHZFOUtCOEJZamEzcDJLRFZ0dzR1NlZNMk9nTzZ3cEpsb3gxRjIwdlo3TEVybTIxMHozLy9nWnZVUk5zaklQR3ErQStmU2tYaTFCQmJKZm9YRElHeVp1VnFNU1MrMHY3TjJ0KzV3MnhNUjBlNGw0UmF1NXlHVlNhT3RiVzN0RmlRUUpaM08yQkFKSWxvOWZ6NUlLSmN2Mk5HR1pYVGhCUkw2TXpFK2lrcjUxcDFiSFJsSzBIeC9EeDdxdDQzOXo3N3lNc3Fsb3IwdGppTVV6WEl2WFRpUGJ6MzlGTnJiTzVhTmJDemhSWU1Ecjl2N1ZDckxuMnYvd1VObzcrakVXc20rUU5Zblh5amdqcVBITURSNDJRWVRMWkRueXBqOWhxeFBKcHRGVjllK3hkc0dCeTdaMXo0Mk9tTHZ0MVJIWnhjT0h6bHE1elFmU21TMnRaeDN1bzVqejFra3ZFZ0NnV1RhNmlIMHRLNFBPbGtPUTdzK01uU29oQnVGRXJTa043ZGNLK08zSVlpSzlyT245Y3JqVHJia1BSdGcxTmJpWTYvSXBCejd1aVhJYUNYU3VUSXgyNm9TUm1iYjFKQjFwczJKci9sc0lVS2dzMlpidXVZK3ZpMm5pT2JuOWM5ZVpFbzJZbk5KeWtBVGVDcTBsMU1ZaGE4aU5BczMwd1l2Yi9aaDd1cmZjN20vQkJnUkVSRVJFUkVScmRiQWROa0dGOGxVQ2VObHQzbW1mbG5xbVBjWE1xYjh3a0hLZFJhRHBxVU91aHJGbUs2RXlYUTFUTXg1dXBNc1R4UHVoVlp6K0x1L2M5U2NpRmZ3VDM3NENvaUlkb0dGdXBFMlUvOVFDMnFZSEI5YnZLMHlYemNpOVFSRVJFUzdTYTVzVGdGeTBUUzBPMlhxTXNkTnhXYk9uQm5rc0l0SlhhVGVCZDBmWEhPZTVydElCNGwyRVdQOVRFVzJPVDBNelRtaHFaRmRYN0JOYkdwczY3V3hiTXZjYk5UODVKaXpldCtUYy83dEQvREtlTW8xbjkxdEMxRWlVNWFqWmEraHA1VlNnZGtmVHByUGlEU0VHalc3ZzVmTTljTmFKNldvN0RSUEl3c2lJaUlpSXJvbEJoZ1IwYTczcDVlbU1GdUxVWWwyUXo3OUxpRkpVa0ZvNC9hWEJSZ2w4KzlSRk44eXdLaERTYnlKeHZ1OUlkc0pMYlVyeGg4ZzJudGNPM1NDeHFQdXVPM2s5N21vSHpQbUd6Mm1iMXdYb0wxVS9VTFZyKzhyNHZDTjIvdzBkRG9IN1hpMmt5cHR2dWRINW5Dd0pZMXltRWdmVHVSVHJNY2hJcUxkeXpIbkw0VkNBUWNPSElDTzE5YmlwcWUzRitsTXhvYW9FTkhxTFFUeEhMN3pMbmkrajFkUHY3aDRtd1Q1akkrTzRJTWYvdUZiTGllVlN0dnArei95bzNqOGlmZmdmLzM1bjFrTU1LcFdLcmg0L3F5ZFpEVGp1NDdmaTk2Ky9ZdVBsZEdNYitTRGYrbUhjZUsrKzdGV3J0MmZ0T0RORHorS1QvenMvNGovK0J1L3RpekFhR0Y5dnZXTlB6ZnJjc0NzMDRuRjIxNDg5ZHppaU12WGV2RFJ0K0lIZitRbmNNZlJ1N0hYU1VlM2pPc3RObXNzaGdFQ3M5MXpubS9EZzNMKzFvZjBTQkJPemZ4K1hKNmJnMmZXSWV0NXFFWVJxdkhtdHJYeW5BejJkenlBbEpjM3hYRVp4RWxvaXVIQzYrNTMvRWpCM0tiUjI1WENYdUY3Q3UydE4zNjl0cU5rR0dOb3BteUtMRXZvejE2QnRMdE5UUFhhYkxRUGtVNmpHSGVhN1paQ3ljeTFWb2hOdVViR25VWFdtWVd2S2phOHFNMGJ0cUZHV1hOOW15NllKVGZIZHpSMzhBUXlQWGVhWTV6VlZ4ZTIzUGxXUk9VWnpKMy9Pb2lJaUlpSWlJaFc0NWUvL2hwR1N6VzhObmw5MkVZKzVhRTk0K05qRC9YamNFY2VoOXF5TnRSSVNPRFIrY2tpL3Z6aWVQQm5yNDNWU21HU0RlUWsvQTN2TnlmY2c2WUFLRWFFWjh6Zm53RVIwUzZ3VURmeTZGc2Z4MlZURi9Kblgvemp4ZHRrd0lXbm4vb3E3bi93RVJBUkVlMG12L1l6VDBvRi9xbWYvYzEzZFNxbHBDTHF6V2JxeHk0bDRVV1M3N29iQnVnMmRhN1pOdVZtWmVDZUlGNy9DNUx3SXQ5MXBud0hlWE5lV01BNlZPUjBrbU5pTnlVWllNcFV6Nk0xNHlBVFEwMVdrZzE5WGpiS2RaU3pMK2NXT0c3djl0RUtsOHptRHhUVWt4Slc1Q3IzQzRsVG52emxqMzE5QUVSRVJFUkV0R014d0lpSWRpM3BYQ0lGdXBlbXE1aW9NSEM1NlVqb2lBUVd4WWt0YllhTW5pYVhieEZjSkVGRjBrWG9kbFZFQmpHYytYSE5pV2hua3hBamlTRzdYWlV3Z3dCRjdkbHZlSUFiZC9EWGZzcnVSMVFjbWdKc0pZa0NOaFJOTTdob1MwaytvSVFFWHBtcm9aQnlHV0JFUkVTN21vUVArYjZQZkw1Z0E0bldvcVdsQlg0cXhRQWpvblhxM1g4QVlSZ3NDekJLcFBGYlVNUFk2REFHQnk2aWIvOGhHM0owcStWa2N6azg5SmEzWTJ6a0tzNmVPWTBvQ2xHclZoZnZNenM5YWNPU1YrSjZIaktaTEk0Y1BXWTdFTngyK3gzbzZUdUE5Y3JtQ2pqWWYvdGlSNE56Wm4ycTFRcEt4Ym5GKzhqZlM4T05vdWlOY2k3WnAyUnplYnN1c2s3M25uekFyazhta3dFdDU1aDMxWlVHY2E1ajVsdTdMM2FVWTU5N2dkWlNiaW1OOFdMRU55a0xzNk1QbXNjNWFtT2xYOG9XdmJuSXBEclIxM0UveXRVeGxHcGpDS0x5ZFVGR1VreVhTZStkMzZvYmZSYWlXTnU5d0tBcFc1WkdrekxGODYySGxTMlBqSkZ4aW9oMHpaWm5hdk5kVERzbCs1akVsR21rSEFrdXFzSlhnZG4yc2Iyc1RNbEh4dFh3bXlHSDNmR2d2RFNVRFlCMjZ4K1MxVDQwbFlNVDFrQkVhK2VZOHN0Q2V5ZWlJQURSYnBOS1o1QXl4OGxFamFmbUIwdG5lUXJSbXVpMWhhOFRiWmJ4VW9CeUdHRmd1bXdEakphU3V1VytRZ1ozN3l2ZytMNFczTmZiWnY1T296T2ZXaXdMQ2JJeFVxNHl5NGduaXJYd3lndkR4ZnpJWE1XYzBDcnB4RHdmWktSYnpZL0ZQZWE2RWZ5TjN6R0Y5NmVyK09RbjJWQ01pSGFGSGxPbkVZVEx5M0NsL2tEcURFYUdyOXA1WjNjUFBHL3ZkQWVRdWlLWmZIOTFRZnhKa3FCU0xxRmNMbU5pZlBTNjIzdjNIMFE2blViTzFMVVFFVkZ6U0ZReTZVSTlvK0VjTkhXOGZRbTB2MUJDUk9zWEowbFdKODZtSERUSW15TURvUHFPaXRLdVRvSVl2bDdIZSthWWlwU3Nyektlcy82K2puSXl5RktSNXVZcGFVQ2hrZkZVWWo0M3VoTHByVHlZbFkrSFRwc245bDJsWEdVL3V0UklHcUZTU2xyRlRKcmRRS0toeTJZYlIyYXFhaWdKcWl1YSs4eVl1OFRtNzlmTnZpSXk5ejNqS3E5WVZ1WEpPRXlLSUNJaUlpS2lIWTBCUmtTMGE0V21PQ00weFIzZkhDcmlhcEdOd1p2T1lsaVJLWXJ5M1BvVXg3Y01NY3FhWXVXc2l2R1lPNEdDQ3VHakdYcjhFTkZHU1lDUlRJKzY0NWpUUGdaMUhvRjJNSW4wRFIrajB6bnBzUXpVeWphOFNLY3kwRjdLN0U5NGlMdVZhbWEvWFRLMWpTK05sN0V2NStPMjFqU0lpSWgyS3drS3llVnlkdHEzYngrSWFPdElNRTliV3p1Kzl1WC90bmhkR0laMmV2M0NlYnp3L0xQb2ZHL1BMUU9NanR4NXpNNS85R04vRmNORGcvaTN2L1RQNWdPQ3JpN2VSeHI5anl6NWV5a0pCdXJxM29mM2Z1RDc4ZUNqYjhQSkJ4NUNXM3NIMWt1V0paTTBpSklRbzg5OCtsTVl1SFJoV1lEUnpQU1VuVllpK3lWNXZJUVgvZFdmL1IvUmYvaUluZWg2cnVzZ2xYakllTDQwaU1OVzhzMzdsTGh5cmxydnFKZElpRzhpWlpjM0w5ZVNFUWhUNW5HZXM5R2dXQWx1U3FPUTJZZDdEbjBJVjZkT1lYanFCY3lXaDFCTFpxNTd6cGE4ajcxT3puV2xpUEtGb1pJTm1hcEZiN3hYU3RVRDFuUHV0UDI3MVJ0YjlYTGJmSTJjM3Y0aFB4M3pQWEF6QlNnL2JTNnZycVBQQWkvZmVjc1FlaUphbWVPNjJIZndNS0lnQk5GdWs4cmxrV3R0QjFIRDJXTmhaUWV3SUtJMUNObFZqNXJEd0V3WkE5TVZmSHRvNXJvQW85NldETjUrZXhjK2ZHSS9Qbnp2alFQQzM3Uy9EVysvby92aWo5M2YvL1dmK2IxdnQvM2hxMVZKVGV6RFlvQ1JhalgvdkJkS3o2TEY3OGJvaVhGSVp6Z2lvbDNnM3BOdk5uVWp5K3NnSnNiSDdIVHV6TXZZZitBUUhuNnNjMDhGR0ZVckZUdXRKY0JJdHBjTWhDRjFTZGY2cnZkK0FLMnRiUXd3SWlKcUpubWNkMHY2TXpIMGNWTWpkWmZTZHF3YU5nemVvRmlybGtodlRrcTRIWlRIRk4vbFV3Z2N4d2xuYW9sanFsZlgvSjVKbUV4cnltbnpON0NXNGZ4RXpTdmxLbE5EclpDa3RhbUcxMG1sR0cvbDl6czArNVNrTmEyVTd6cG1VaXg0YmpTRm1xNm5xNzlxNXBHNVlqQXg1VFF1bENtdlNTNlozZEFsRlVmbkhRL0Z6a3RQekg3eWs1OWtoekFpSWlJaW9sMkdoVGhFdEd0ZEtRWVlLUVVvQmhFcUVSdG5OU1VadFR5SzZoMWVwTU5Xck92WHJVQTZCVG5RT0t5S09PaVdiWkNSdDQ3d0lxbVF0cVB3QkRYVWFsVlFjOGxrY3JielpYWVZEUUlxbFRLMGpKQlVLWUdhaTU5S0k1M093SlBPY0d0c1VDNGhSaG5FZU5DZHdIaVN4cmVUVHZOTlYrYWE2MnVqdEhMc2dMdXhCQmw1SHJTYllnUDJiU0tCZ1MrT2xuQ2tJMlArYWdNUkVSRVI3VzdTbUZ0Q2YrNDhkczkxdDczMThYZGlNN3p0bmUvQzdNejBpczk1N1BnOU5zUW41YTgraE9QRXlmdlJmL2dPZEhSMllXcHFFcSs4K0FMSzVTSXE1VEtDSURERkZTR3kyWndOY3hGeW5pTU4ySHY2OXVQb3NlTzQ0K2d4ZEpySHBqTVpOTUtoL2p2c2Eram83TVRNOURTKzhiVS9NMlVZTWFZbUo4eTZSR2FkYXJZeHZyOGtvS25kUEwrczQ4TnZlUnN5MmF6WkRpZVFMN1JncldRNzFLcjc4UXYvNGxkUkxpMC94Nzc5amlNNGZNZWRhRzFmZTJkMFdaK0R0OTJPZi9scm43N3V0bnZ1ZXhONmVuclgxS2xpbzh0enBWV3I0MnpMMEp4NTg5NmwzUmpqNWZyMlhXMkpsdSs0NkRUbjE1a0dkVDRKWWhmamxSeStmcVVYZjNidUNLYkwzU2dGTEI5YmlVTFZsRkNZLzJyZmdiU3RTNnZWaHhUZGpBUVlwWnFnK1oyT1l5UlJ3Q0Fpb2kzbXVCNzJIN2tibGVJc2lIWUwxM3l1Slp5cjUrQWQ2THZqTGhBMWxxb0hHTWw1bWNlUVRhSTFDWG11UjgzaDlNZ3N2dkg2SkdwTDJtMjFaVHdjNmN6anNkczY4ZEg3YjBOL1IvYVd5OGw0VHR5WmQ4TzM5Ky83MmgrK2RPVXlmTzlONXVvdU0vVXYzaWxSaDZHVER5UG5mY244OVJLSWlIWUJxY3RvNytndzlRYzl0cDVnYnZhTlFQckxBNi9qMVBQUDRJR0gzaUtON3JCYkxBemNrQzhVVnJ4OXlQd015SG5vM2EycmE1OGtkUzBUNDZNNC9kSjM4RWVmLyt4MXQwdjlRbXpxWVE0YzZzZE8wZHJXam9QOWgyM2QxYldxbGJJTmE1TDd0TGF0YlFDT2J6Mzk5V1dmc2ZwenRlR09PNDhoYXdmNVljZ1RFVzJOMDZkUlBYRUM0MDVKUDIwcXMwek5tdnFnZ3VvR2JaU1BUYTR0VHp0T3lrOXBVN250eG1HU0pMUFZCRnBKNlo2NmFlR2VXU3Zka2xhaDd5Z241WnBxL1EwT1NKU29lcXF0dENpLzlSa25iWmUwYXc1bkhDZnB5dGhCb1BSTU5hNlkybXRQUTYxdEJKNVZNQitwcXZsWVJHMXBaWjdXOFFvcEJVZHRSK3VSeldHcS9XZk1GK2sxcGZTNDFzNjRlV1dUQ2treFVlcDhFdXUxZDZiVFNjRnpuWU0zZjA0VndJbG56WE5WbzloWmJHemtxQ1NTVWFFYzZNbFlPWWtYcTNLWVJKSFpNMVFSbzFoMms2SjA4OE9WMGVCZi8yK2YxSi84SklpSWlJaUlhSmRoZ0JFUjdWcFQxUWhEeGNDVWhtaEV6R1J1WGphd0tLNTNsdEUzZnFPa2VGQUtrZmM1TmZTck10SXF0a0VuYTZYTjg4UnhaRHRhL3YvWit4TjR5Yks3UHZEOG5idkYrdFo4dWErMXFLcFVVa21GaEJBQ0FRVVNTNE50TURadTdPa0c1STB4WU1idG5vL2Jucys0WGRNZmV4cC9aanhtak0xbmpHRWszRFp1SXhvRGJteVpSVTZEUUJKb0thbWtyQzJyS2l2WHQyK3gzZjMwK1o5NDkrWEx6TGZFV3pQaXZkODM2OVo5RVhIanhvM3R4cjFuK1oxT204RTMvY2EyUC9aOFUxbXdkV1YzbXNUMnZXeTNPSEJldnltWjkwVTZqWGJEaTNZUVlHUyszeGZRUnVEaytMTFpMV3o0VGJjVkI0NnBVaXRCU3dOMk5sNS9hRkt6TDVmZ3dIckFBQ2tpSWlLaW8rQ3BwNSt4ODJmZjgzVTRLSTgrOXNTZVB1YXAwMmNCTXozK3hOdHR3L1dSa1ZFc0xTN1lxZDF1MitEam9lRVIyMUJlbE10bG5EaDFCdWN1WE1TNzkrRjVTMk44VStwaGc0eUVCREJMY05IdG05ZHRvSktVWVpUS0Zic2RoVFBuenR0dC9MYnYrQjdzeHNqb3VKMS96L2YrV2V3bGViM0VJNC90VFVmMjNhN1BjUlRjL09FMFFBdk01OGlYOENSekhtdlBjWHNNalpFR2M3VWdzTUZMZXlIWENzMGt3TldGSWZ6QnJlT1liWStnRmFlZ0I1V2NCdVRkZXJMK09seVZvTFJIUlE0VktiN1lsM0ZOdDhzVXVPVHBwdVd4UkxUM1hGTm1PanB4Q3RXaDdRY0RFdlVyQ2VhU3ozWnRaTXgrdm9uMm5OUUYyUUV0Mkx5SmlHZ1EzVnpxNE1wMEEyRjI5L3hUeWprdWpGYngxSWtoZlBDUll6MnR4MVZLMTRNZys5dmY5cmFYL3M2SG5uZ0JmL3RYSjJFYkM2d0pNRkw1cVBuZGVOYWMwSDhPUkVTSGhOUmxTSHRIQ2ZOeFEvZWVjSm41MlJuY3V2NFdraVF5bDdZL3VFRy9VdVozUWdacktKZlhqeHRZWGxxeUExNzBTdXBiV3MwbXBpZHY0OFVYUHYvQTdRdno4enNhSE9KaGtzRXRaSkNOSUhpd2IzK1daZlk1MllFNXRobGdKSFZTTXEwMWJ1cXZUcHc4M1IxQWdnRkdSSFJBTGo5L09iME1OUC82eDc3dHFxbXVDMHpONmplYXF4bGd0SHZlZmc5dTRudktrMTRmRmEwalAzZXk1VWhEbWYvTXY4MERqRXdSWU5WM010OVIyblBVcmdzQzVWbEd5aWJoTU1Db2owbGdsWms1dFVEQkZCdm9aV1VxNXJVTU00UTlEekF5RDVRNFNrVmx6eW1WWE9VRmpzSWh5aTh5ZEdLZTBRMXo3bkJOSWIrV3dibnV3Smx2NnZRekgvdExsN2VkZFA0akgzMXV0QTduMmMyV3lWUWFsalFtMnpHYVAvZWpuNXpGRHFqblFVUkVSRVJFaHhCYitCRFJvZlhpVEF1L2QzMFpqWGo3Z2RGMHdDVEVTSUs5TnlrVFA2dmF1T2kwOElocVlnelJ0c09McENLLzNXcVlDdnNZU3d0enRtSmFLbXVwdjVSS0pmVDYxc3I3bHlZSm9yQUQ2aThTTHRWcE5WRWZHa1c1VWpGVDFZN0MzQ3VwRDVEdnVhbUh3dGU1czNncnIrRXRYZDl3ZWUwRk9HUzFDQU1uTWZ2eFA3N1RsQW9rdE16dnJ1OHFCRzVmOU1na0lpSWlJdHFTTk9EKytnOStpdzBNa2lrMzU1dFNqaUFkc1FzU1pDUU53U3ZWT2c2Q2JJK1VYVWg0a1RaeitWdTJRYTBKc3BFd0k4OW5rR3V2cXA2UHNuU3dmd2puais3SyszWnVlQmlaK1d4Tk5wc1NIMlBmMS9zVjcvQUo4MW56WFJjVjh6bmM3Y2gvMGc2MWxhUjRjV29aZitjVFg3V2RCeWViSVpKc3ZVSVljMTE2aE1yTWJEYXkwLzFqemV1YzVOMm1yRmRiSDREdmhLalhaODM3WU01M25RaTdjYlhwWURoUkdNYkRwYzErTGs4aVpGRUxXV2NaVHFsK3ovNWxNNTNwMTVGMmV1OGdSRVIzS2NmRitLbXpPSG5oVVZ4NDhsMVltcHZDMHV3VWlBYlpxVWZlaHVObkwyRms0aVNDTXJ1Q0VCRVIwYjJrRE9LRk8wdUkxb3c4ZDNhNGpKLzRnRGttSHQzRnNZT1QveHEwcXBycEg2OWVwOVdvT2IxLzFzelpzWGtQdEtNRXpVNXN5b2syRHIrT1RYbFRoK0hZUlBzdUNFcjQwSGY5Q1V6ZXZvbi8rQnUvdW5yOXkxZGV4QnRYWDhFUC90QmZzblVKSjFjR0FSaDBNaENBQkFxVjFnem9RTDJUTnBYTlpnTmpjVzhoZ1d2OTdpZitQYjc0dWMvZWM5MWpUenlGeHg1L3d0YVpqWXh1THhDSmlHalhscE12b3VKZU1aV3Q3OVhRVGZNcjhaU3B6ZU1QeEFDb2VQQTFISDF1V05sdUlxMDRiNWlxNlN6TThnUTJud2E1SXovNjVnUnVPSERIUFJkdVBYQUNaUzVqajZUbVlicTFuMnhmM3U5S3J2bEF1RkNuNjI1TlBpZnRSRGZpWEd0enVxbHo2SnJXTytyN21ycEt0WHhYdXhYZjhTdWVDbndIWmQ5Um5xTU9SN2NEODBYNkFwU1dqbEcvWUY3Q1ZwVGhtdm5NaDY3V29RcWFuV1plelQ3MmtlMkhGNGxMYjZGNTdXTDZ3bWJMSkg0bDk1Tk9mTzBPV0RCQVJFUkVSRVQzWUlBUkVSMWE4NTBVZDFveGFFQnNFVnBUVVJuR1ZZeXltUWRxK3lPRFM4ZkRMRXR0c0VvVTdhZ2NqZzZBZE56VFBZN3VJQjA0dTUwNEdVVFZiNHIzcEZ5SnpmZk83L2s5TFRneVpJclNxT2pVZnUrblZYbmpmWVE2SkxVSUF5NDFOWXdMWVlwbFUxc2svVis5L1Iya2hZaUlpSWhvVC9tK2oyTVRKOUJQK20xN0RnUFBlWGdocTBVQWtZUW9KUkpHWmR0aWFxeGJ3cVdVYlVKWjlqeTd6WHV4M2RJR1ZNN2Jsc0xFZGhvTTAreWVqb1AzTFF5bHQxLzJOcWowQmcxVzg1WHFzMVkyZ1pKdTJzc0t1MzlkV3FtQzN4ZEZXUklvYjhyV01tbjF1YjMyaEhuVWdvNVp2a3EwRXpZUXNWeEZxVlpIZFhnVTdjWVNpQVpkelh5V1I0NmRRRkFxdzNGZEVCRVJFYTBsZzk5SWVjUmFGZC9GNDhmcXFBZTdPSGJJM1d2bVJMMTZUME1DaGJLNU9HcHVaSnZZUFpESndIQm0ycXljU0lLNk04M0dBVVQ3VFFaWGtIQ2lLTHkzVEc1eGZzN081ZnI3Ynh0a2ttWGdTYkMvdzRIVGRrS2IvWFltZzNYazJ5L1BucHE4Zyt2WDNyam51bHE5anRCOHZyS1UvZEtKNk9EOXpFLysvb3pNZitLakg1cFQwRXM4OGh3Y3JsTDJoN3ppU1lDUnpwTk1wWEd1TXlkVHNUWW5HYVpHUEhlVWxwcHhWVEpuY0o0NUFEQ0x1bnNaTnFUUjg1aks5SkM1am9KalBndU9EeS9KekdGSG5rdnpoanhWV21mNWp0OUdiVmFiZUs3S1M2NXl5Njd5QTFjZHN2SUNMU2NFTjgxMzU3TXhFUDcvL3ZMbFNleVI1NSsvTEFkL0hOV0lpSWlJaUloMmhKVzFSSFRvTEVjU29KRGh0WVVPcnN5MlFZT3RqQXlubkE2ZWRKYndibWNCTzdHOE5HL0RpMmFtN29DSURzN1M0cnlkeG84ZHQ1MFhoa2ZHdDNYL3VrcnhialZ2YXFTNkRTcnU2QXFXZEFEcVg4dFJoay9mV3NaalkyVThQc2JSdG9tSWlJaUlpTmFTQUNQeHpNUUp4SG1PS0UwUm1US3JPTXNRdUs0Tks2cjV2ZzA0Y3RYZWRjNW9tdkxTajMzK0xWeWRhejdRYVhBdHQ3Vm9nNVhVRVFxbnNRRkdyb2U4VklFdXlYbnNnMEhKcmxQRitQZ1BJSTFmUTlMNVBSd21pMS85VDNDREtrNTg4Qy9DclF4dnVteWVSamIwYU9ITC83dVpNVkNjYURjdVB2bHVuSG5rS2J6NEI3OXRwOGxycnlGc04wRTBTSTZmZXdTUHYrdnI4TXdIdndQbjN2WTBpSWlJaU5hNnR0QzIwNTNtdldVTUYwZXJ1Q1RUV0JXNzhsTi8rcmZzL0cvLzZ0cHI2K2Ewdmp2UnJyMTBZeHFUalE3Y3h0eUd5OXlaV1VEVjBjRGJUNE9JOWsrbFdzUDNmTjhQNEl1Zit5eCs2V00vOThEdG4veXQvNENSMFRIOHRiL3hQK0F3a09BaWVUNlY2dnE3ODlzMzM5cFd1RkVTeDNqeGhjL2o1dlczMXIzOXFhZmZpWE1YTG1HUW5EaDEycjVHOWZyZS9PU0ZZY2VHWUdYcGcvVUhJNlBqK09Cekh3WVIwY09VSS91cEFDam4ydjBQNW5qL25Ea0NIUUlOQkZkMXc0eU9WZFFZRHBDME9wY2hKS1QyZDNzdDErbGhrUnA2dDF0MVh5cDdUcW00UGx1Skw0ck5IM211OHpERGt0WTZOUmRYTzRxWnoxakZWUEg3WlJjanluemVTcDZ0Ny9mTitpWndDQ21vbnpLdnhpdDVPLytWbi8zeHk2eGdKQ0lpSWlLaXZzTUFJeUk2ZEpKY281UGtkbFJ4R213S0dvSEtVVVVLZndjam5CZWp5TWpvTHhKZ1JFUVBSNVpsOTR6c3ROMFJzanp6L2ErczdBZGt2NkQzY0lRTjJsdjJOempON1p5SWlJaUlpT2l3MEJ1TUpLL1V6czlQblpYN2Q4T0s3SWlDOXUvOWt1ZDY0NkVKaStlbjg3dC9IeEcybkVHZWN6SFpLeDk4SHh6bDdPdjc4N0JvVTJhYVp3blN6cEo5SFp5Z0NtWEtiWlRqM3YzYzY4ejhaOHAyd2tYekVjbk5sRExBaUdpMzdKakNDcVZ5RmZYUlk2Z096OER4UENSUnQzTjNHc2RBc1g4aTZnTXJnMlhEQ3dLNG5nL1BEMUFiR2tXbFBndy9LSUdJaUlqb2ZyazVsczJrTE9LK1ExcDdhcjJYNTljYWl3OWVxWTVPTXZORHB0VHV5c2VJcUhlZUtUY29sMHFvVkt0SUVsT2VsOXdObWxsZVhySmxlb2VKTCtlZnJydnViZEwrTE45bSthVGM1LzV5bHVJMTY1YUhEdGJySi92ZVlydGwwdm5kdHJXNUtjdU40MmhiN1dXemxmdmNUejUzemlIN2JCSFJZS3JFcHRpOGhoU0puamNYcTJaUHlBQWoycEw5ZFpUVEZWYTFETFRpTFN5S0UweWR2YU9WTXBYWitXcC9XSFBCbFlNaXFmc3ZUbEVQNDVtcU9aeHRteU96dHZsc041V2JNN2lJaUlpSWlJajZGZ09NaU9qUWVXc3B3aGVtV3BocUphREJKUVdJSlZOMFBJRVEzK0hlTVg5dnYxTk1wOTIwRmJFejAzZEFSQS9QMHVLOG5ic3JqUnJxUTZQYnVUc3VxUlpPdXlIK2Mzb0tUZmlJNGRnb0krby9qVGpENzkxWVJzVno4UFpqdXh3MWs0aUlpSWlJcUE5SXA0YU9LVitTK2RxczFySTV4L1YzMFVITGsvTmphZmp2KzlodnN0M0xVWXBXdEg3NW1wS09ET2I1cVhVNktCd0ZLay9ocERHMGVUKzFYektsa3ZkMnlIQWNGOGZxeDlCcTF4RzFjYWdreTVOMlB2MEhINFZiSHNMSVV4K0NVNnFqY3VKUjg4RkpiVmhSTkhjZGFYc0JqZGMvamJRMWo3UTVCeUxhSFNrbmxlbGQzL3lkZG5ydGhVK2phY3BRcjM3cHMrZzBHN2o1NmxlNm5jMmlEb2o2UVZBcTJ3NlJsOTd4SGd5UEg4YzdQdkJ0Tm56citObUxJQ0lpSWxwUDI5UWJ6N1FpaE9tOWc1V1ZQQmVCdTVkQkNQci8rOEJWZWZZeTZFQ1VmUmUxd0FVUjdTOEprVGx6N2dLYXpTYSs3VHUrQjYrKy9GVzg5dktWMWR0LzQxZitqVzJQOVQvOGovOVBIQVpCVU1KVFR6K0RGMS80d3JxM3Q4enJJRk92Skx5b3NieUVzSE52NFc2MVdqV3ZyWS9oNFJIVTY0T1ZnMUV5NStreURabHRsKzJYRUtzaXhLalQ2ZUNWSzEreHR6M3kyQk05clc5dVpoclhyNzFoUDJPRjRuTTNjZUlraUlnZXRuLzBvNWRuWmY3WGYvRkRQNjB6ZmNsVTZmMi9RTFFKK1ZWc1NPQXF3NHNHbnJQU0pNUDFiSVNSVS9VeHNuTE5Pa3NmN3I0Rlp0LzNXeHI2MTNOa24valpINzQ4Q1NJaUlpSWlvajdGQUNNaU9uU2lMTWRTbENMT2N0QmdxeU5CRmFuNXNjcmhiQ1ArM282WVk2WWtpWkVtTVlpb1A4UlJhRHY5WlpYVWpnVGx1TDAxWkpQdnYrd0h5c2pzZm1FSkFRT00rbFNhYS9NYm5ObmZZaUlpSWlJaW9rRVhtL0tsekV4aG1pTFgydng5dDN3cTF6azhjNDRyUVVhT2pIYU0vbGIybkEwN0NHb2J4S1Nnblc2VmtRVDZIQm5LanNOb25yc3BmVER2cDk0Z2xFcGV1a005em5TYUlEZmxxUEhpYlRoK3hYd29NaHRlSkNGRzhmSVVzckNKUE82WXF6bG9BTkYrcU5TSDdYemk5RVZFWWN0Mk91eldjUnpOWURucVAwR3BZdWNuemorSzZzZ1l5dFg2Nm5WRVJFUkU2M0VkWmNzaDNQdE9zd056aGVmdVlTbUt3clVIcm5QOFJkQ3UrYTdhTW14S2JxLzRoN3JFaEtpdkJFR0FFNmRPNDliTjYvZGNMd004NXJuQzFHUjNrTWVUWnBuRFFBSjBSa2JIRUlhaEtTKzVHL0s4dkxTSXVkbHBiTWZTNGdLYXpjWTkxOVhxUXlpWEszQzkvUjlrWUw5SThKSzhSdTEyQzBuY2JTZWJaUmxhNXJuR2NlL3Raa1B6K3NwcmxLYjNsdi9LdW12MU9vaUkrb1hPOUx5cHZDcHJPSk9tZGpZd1Y0MkRhQU42WlNJYWVCcW13bERQS0tWdW0zM2daSlJGN0NCRlJFUkVSRVI5alFGR1JIVG9UTGNUWEpsdDJ3QUZHbHdTVC9LNDI4Q1lLVytycWUxMW1vcmpFR21TWUhGaHpnYW1FRkYvbUorYnNTT0x5MmpObmgrZzdQYld3U0ZRdWQwbm5IVmJVRnJqU2phQ0JBR28vN1NUelB3R3QvQU5aOWw0aFlpSWlJaUlCdDljdTJWRGpOcW1uQ2t6NTZOUmRyZU15bmRkZU1yQm82T2o4QjNwa05lL25iVThSK0hVVUFXTDRRWmxiRzYzcWtoWDZwSU1EdFZaeGxFaDRVV21vQUxhTDBNSFpheEhSbldzZWdwUmJ6bk1BeWxwelFGbWl1ZmZBaEVkdkhPUHY4UE8zL2JzQjBCRVJFUkVkQmhVZkJmajFRQ0JkMjk1eVhnbHdIQnBENXVzL3RTZitSaG9YNHlhOXlyWll1Q2k0N1VBWjRjWmJFbDBVTWJHaitIRDMvVW5iZERNQzUvNzdPcjE3VmJMem4vM0UvL2Vodko4NzUvOTh6Z01qazFNNEpsbjM0dnIxOTZ3VStGem4vMERuTHR3cWVmMVNEalBpeTk4SGd2emMvZGMvK2pqVDVySE9HNkRrZ2JWbzQ4L2dUUk5NVE05dVJwZzFPbTA4Y2JWVi9IMmQ3Njc1L1ZNVDk2eHIxRnJUY2hUcVZ5eHIvOGo1akdJaVByRlAvMkxuL3prWC8zbnowMEVnZnF3dVhqU1ROOEZvZzFrS3hQUndGTjRYVUg5dHZuckUvL2tJNWMvQVNJaUlpSWlvajdIQUNNaU9uVGFTWTZaZG9Jd3pVR0R5NFhHT2RWR0ZiMkhGMm10a2VjNXdrN0hUQzFrS1l1ZGlmcU5qQnplYkN5aFhLbkM5d000amlsUzc3R1Q1N2lLSVV1K3JvWTRMRWFmU25PTjVTaXpJWUxMVVdwSFc1U092RVJFUkVSRVJJTWt5VEpJeVdLYWQ4c1hKOHc1clB6ZFRHSWJZaFNaMnpOeldTczVCNHJnbWZPZThYTC9kdGFTem9MUG5oNnhRVHduNnlXMDRnek4rTUV5TnkxQlJxNHBYOE1SQ3FWVkN0cnhWa09jN3VjNUdvR1RZeXhZUU9LMXNSZHk4N2xwT3lFYXB2eHkvdm9pYXNlcUtOVVkxRXhFUkVSRVJFUkUvV09zRXRqMkhVVFVQeVJRNXNLbFIzSHkxQm1Nakk2aDNXNnRodFlJQ2FDUmtDUGc0QUtNVHB3NnZScWdWSkNBSlFrY1dseVl0K0ZCcFZMWkZNTXFiTmZ3eUJpZWVPcHBHNnF6TnNCb2RtWWFmbERDMU9SdEJFRmdudlBFaHV1UWJaSHRrR1dsVGVuOTIzNzIzSVdCRGpBNllUNExZUmlhNStDdlh0Y3huNHRYWC80cXZ1Ym0rKzN6cjFTcjVuVXFyWHYvek5SMUpLYmU0L2JONnlzQlJzM1YyK1IxNlg3ZVRvT0lxTDgwVElYZDZLOXBqU2ZNejh1ejVvcjZ5alJ3NU9kUjZtOTM4RE81STZaS2U5Rk04c04zNkN1RDVVeW1EWTBTRHVqRkpkb0gydnhuUHNHUm1kM01vUzZibzdkcklDSWlJaUlpR2dBTU1DS2lRNmVkWkF3d09nUzhsUUFqRDcyL2o5MEFvd3lkVGd1dHhyTDltNGo2UzI0RGpKYk45eFdvMVljaGNXV3UyOXQ5eHhDanJsSlRvY1R2ZHIvS3pQdTZIR2VyazJ0cVYzM21GeEVSRVJFUjBZQkp6TGxyWms1Y1paS09GY2VyVmNTbW5Na05GWllpMkFDalhNcWh6TlNNSXpqOUhtRGtPbmoyekFoU25lUFVVQm1UalhEOUFLT1ZUZzdhWTVoT3daY0FJemZEV0drQlRhK0Z2WkNaZnhKZ0ZMUmJtTCt4Q0wva01jQ0lpSWlJaUlpSWlQcktlRFdBdzVHbGlQcEt1VnkyZ1RJU3ZDTUJSbW1hUGhCZ2RPS0F3MllrVEtteHZIVFBkUkthMHcwT1drQVVoalk4WjJjQlJxTjQyMVB2d0Z0cndvdkUzTXcwWE5mRjlPUWQxT3IxTFFPTWxoYm03YklQYnZ0cCszb09kb0JSOS8xMjF6eUhUcnVOMTE2K1lrT0o1UG5MODlzNHdDaTE3OUd0bXpmczU2ZlpiS3plVmdRWWpVOGNCeEZSUC9tNUgvMjhqRGp5YXoveEM4OTlMWlQ3RjFhdUhzd0FJek9aYXR3RGk5anhsRnB5SFNVL0NvYyt3RWpPWk5ybWhhMFVGNGdHa0xLOUxWU2tvRzY0eUM0dkFpR0lpSWlJaUlnR0FBT01pT2pRYWFjNTVqc3lFam9EakFiVnVJb3dnc1FVR3FmYktwU1BvdEJVaUM4aTZuUVlYa1RVeCtUN0dZVWRMTXpQb2xZYlFxMCsxTlA5QXBYQjA3blpSOFNtQk43RnJDNkQrbE1qU25HckVTRndITlQ4SGhPcWlJam95R3F1R2NtUitvczBKcGJKOTMwN0VSRWRGWEdXMmhBam1lU014b1labWJMR3lGeWYzVGZ5ZkdvdU8vcmh0SHBzdFZvMjBMdlY2aTFZWnpoTjhKZWVIc2VYWmxwNFliS0oyNjBFODFHRzJKU25zdDFtbHdQemZpcU5pYUJsTytrOU5UeUxxcGRqYnJZRkZXdWNyMXpFYnJuYWdWT3FRTG9XemM4M0VWMUpVWHJ0WU02ZHgxU0tjL2xaREo4OWdZbHpYNC9keW12SG9PdG5UWm04aThiVWxPM1VJc2NPWTJOak8rcVVSRVJFUkVSRVJFUkVSSnM3ZCtFU3Z2NkR6K0dQUC9NcHZIbjFidURNemV0djJ2YVRyNzU4QlNPam96WmNhTCtkTmR1eXVEQy83bTJmL3RSbExDM080N2tQLzFjbzNUY0FRS2xjUnIwK1pBT0l5aHNNRG5CczRqamUvWjZ2eFJ1dnZZSVhKazVnMGF3clM3dkIvR0duZzQvLzBpL2k0aU9QbWVjNmprcTFpbXExdG5yZk1PellRZmIrNWMvL014dmlzNWJVZVhwbWV2ZDczb2Qzdk9zOThJUEJEWmQvNXRuM29tWHEydVc5bHRMWWhmbTUxZHRlK01JZjIrZi83ZC85dlhZNWVaMWxNQVloOVFxZFRodHZ2WEVWWC96Y1ovSFNpMTlFdTIzcUcxYnFQMGJIaitINHlkUDI5ZmQ4aHU4VFVYL3lsbkUxSDgxK3l0VHVmYStHK2xObTcyWjJXR3FnK3NkSlhacHI2aU5kcGFYYU1OSFFKYldQejhGenRISnh0Q3J3cEE1Y2poNmNsWWxvc0tqSWZJcC9TeXYxNVZ2WHB0djQ2aFYya0NJaUlpSWlvb0hBQUNNaU9uU1NUTnNRSXhwY1ZaV2loZ1NCMnQ3N21LVUpPdTBtMGl3QkVmVTMrWjdLOTNXakVaN1c0MGxWa3RLb21IMUUzVlFwemJKM1pkOEtVNDNGTUVNeXhOOWpJaUxhV3BJa3RnRXA5Ui9iV01wMWJXTldCaGdSMFZHU2FtM0RpeVM0cUFoaGtWOHF1WHgvMU0vRC9BV0xvc2oraHZZYUJxaHpqUStlcmRwZzRZVk9nbWFTMnltV3A4aHpiRXZDaTF3ekRYc1JmQ2ZIWTlVNUcyVFVha2IyOXZIZ0dIWk5pamZNejJwcVZ0bHVSNGlYSWpnSDFOVFFxWmR3NXNRWWd2RVJESmxwdDJJVm9PMVdFV1VLWVZQS2VRSjczREE4UER6UUk1Y1RFUkVSRVJFUkVSSDFxN0h4WTNqMDhTZncwbGUrZE0vMUMvUHpjRDBmMDVPMzdlV0RDREFhTjl1aU42am5mZTNsSzFoZVhNQmpUN3pkbEJmZVd4WXB3VVZTTEYwdWJ6eDRuWVFTbmJ2d0NJNGRQMkdYYnphWFZ3T01KSHpuQzMvMGgyZ3NMK0hiLzZzLzJTMkxYQk5nbEpybFpOblBmT3EvSUk3amU5YnJtTHBQYWE5MitzdzUrem9Pc3VJOUhoa2RzNi9GMmdDam05ZXZJVEhQWFlLYWt2Z1orNXpYQmhqSmJYT3pNM2p4aGMvajlxMmI5bktoYWw3NzRaRVIrL29URWZXckY1YlFmSFlVbnpDL1FrK1ppNGtFL3d4aWRhZlRIVmdzTS9XUmNkNE5MOXEzQ2piSFBKS3BDejF5STVCb3NDcWNCbGFrNEZ6SnRYUDk0ODlmaVVGRVJFUkVSRFFnMkhxWWlBNk5UcHBoS2N4c3B4c2FiSStyQmtiUmV3aVJWSjQyRzBzSXd6YmlLQVFSOVQ5cHZDTGYxNWI1N3NyZlE4T2pkblNyWGp5aW1qaUdHTmRRQi9XbjJVNktWK2M3dURqU2UwQVZFUkVkWGJZQmFjWUJndnBSMFlpVkFWTkVkTlM0RXVCbXBpaEwwZFlhTDgvTjJ1dmpQT3VMeG8wdnZQQUNscGVYY2YzNmRYdDVPL3RwODNSUXluSjhzNW0rWWRqOER0ZTFEV2FpTHNtcmtsYTduaU92aVVKSm5iUFhPL3Z3VTZoazRHcmZaalhiNlNCa2pzSkxrY0pyVXc3Y21RaTdwVTM1akZZdE04Mlo2VFY3bllSK0RRME5vVmFyNFp1KzZadnM4VVF3d0tPWUV4RVJFUkVSRVJFUjlaT25ubjRuenA2N2dDOTk0WTl0K014YW5YWWJuL3l0LzRCM2ZjMTc4Y1JUVDJPL2ZldDNmTGNOVEhyU2JGT3IyYlNoT1lVM3I3NkM2OWRleDh0WFhuemdmbC8zZ1cvQ0QvK1ZIMGVsV2tPdFByVHV1bjAvZ0RmczI4YzRkK0VpL3QvLzRIL0V0ZGU3WlpEU1hsVFdLOU9uZisrVE9IdmhrbDJtOE5ZYnI2SGQ3dUFOc3czcmJmTjMvNmsvWSs5eldQeVZuL2liOXJYL2YvenR2N0Y2M2V6TXRBMDArci8vOXorT3FpbXJmZnFacjBGOXFQdGF5K3QzOWRXWDBXd3NZM0ZoSG5IY0xTdXUxdXAyY0p1LytYLzduOHhuN0R5SWlQclo1ZWN2cDg4OS8venluWXQvOEs5THlEOWphcTMrdWxMT0IzV2UxeVduQndPa2JDcW1SOHBLdGVKY21mK3dYMFpLem1udmlNVVhTZlNoREFVa2tZa1ZFQTJjWlZNZC8vL1BzbllEUkVSRVJFUkVBNFFCUmtSMGFPaThPenA2emc0M0F5K0FScUMyMXl0SVJvNlh6bHFhN3ovUlFDaStxN25aZWN2M2R6dmZYWGNIK3dnNldQSmJuT1RzQkV0RVJMMlI0d0FleC9jbnZqZEVkSlJKQ0l1d0l4R3ZsRG5sZlRJMlk1SWtDTU1RN1hZYk95RXRkaXZGSHdQVmZQY2dGYTEzZXd0YjN2RkRISEFqWVNsTk1hZnJTQ1E3TXR1THozT3hEbG5oM1VENnRkOGZIa3NRRVJFUkVSRVJFUkh0SFQ4bzJkQ2ZqVUxETysyV0xVTStDTlZxellZUUJXYWI0aUMrNXpZWnhFYW1LSHh3UUVvSnpwSGJOZ3ZubHpKR21lUXh4c1luVUtsVTc3bGRRbmpFbmRzM3pXc1NvRnd1cjk0Mk5YbkhCaW9WeTl5L3pjY21UdGo1WVRFK2ZzdzgzM3Y3dGVkWlpxZkZlTjZHRk1sekRqdGo5cmJZdkM2VDVuV1Q0S0xPbW5vR0tkYVZRUG9Kcyt5NG1ZaUkrdDN6enorZi85aEhuMnM0OENmTlhxOHhxSlZTZHYrckxPd24xMUdlT21JQlJrSXlvVmhkU1lQS0NkTGxMQjZOUVVSRVJFUkVORUFZWUVSRWgwWXp6WEJqT2NaeWxJRUdVNERNOXBsNjNGbkdpT3F0bkMxSllvUmhHd3Z6cyt3TVF6U0F3azdiTmxRSlNtWGJhYy96Zkd4VkNYZkJhVUdiaGNzNFk3dkpSWEJCL2VWbUk4S25id0h2T1ZrSEprQkVSRVJFUkRSUWhrc2xPNTlwdDVFckNXZmR1QlBGUktVS3p6bVlGS0N2Zk9VcnVIMzdOaVluSjIyQUVWRy9rbkN0VHFlRFgvM1ZYOFdKRXlmdzdkLys3U0FpSWlJaUlpSWlJcUxkSzVjcmR2cW1iL3NPRzJUMDY3L3liMWJEYTJUK1N4LzdPZHVXOHYzZjhNMFlHUjJ6MDM0YUd6K0cvL21uL3puZXVQb3Evc1UvL1VlWW1yeU42Y2s3MkNzWExqMXFwNS85MkwrMW9VUi85Ly82NHphZzZQYk42NnZMWEwvMmhwM1dJNEU4UThNamVNL1hmUUEvOEJkK0JHOTc2bWs4OGRRN2NKaDg3ZGQvRU85ODlyMDRmdUtVZVI5ZU1lL0Qvd2RMaXd0MktyejR3dWMzdkgveE9ma2JmL3Z2MmRmbXlhZmZhVU9waUlnR3djOSs1UEtrbVUzKzVDOSsrRzg1dWZxcFRPWC9xN2w4eWt3akdCQmx6eW1YUEpSenJaWk12ZlJDcXZVRTlONDFqQzc3YXQ3VVp1ZFZYeDI1MXJ3eVFKRkU5WFU3VGg3QjlDWWFXQnI0UmFVdys5TS9jbmtSUkVSRVJFUkVBNFlCUmtSRTFEZEtwcGpZTjVOcm8wbDZJNlBreUdnOEhNMmJhREIxdjdiYWZvL2wrK3k2M3BZQlJvNVpYcnFPVnBFeXdLaFBaYmxHbE9aSXVWOG1JaUlpSXFJQnBNdy9VOUtFc3VmQ3pSV2lMTFBubjluS2FOQnkxdW82RGp6bHdEZHpWeDFNZ0pHY08wdHcwV2FqVWhQMWs4eDhkK1J6SzJGR3Z1L0Q4MWd0U1VSRVJFUkVSRVJFaDQ4RTVKdzVkeDVmODdYdmZ5QjgvdWxubnNWK0dCdWZ3Q09QUDRIM2ZOMDNJSW1qZTI1NzU3dmZnM0s1REhlRDhyaXYvK0J6RDF6MzluZSt5ejZIb0xUOTRKcGF2WTVqeDAvZ21XZmZpeE9UcDIyQWtid09VZGhaczh5UWJSUG11cTRORVpMQUhObkdYcFVyVlR0Lzh1bG5jTnBzcDl4ZnloOWw4THlDbEozTEpJOGhqMVVxVjJ5QTBia0xsL0NPWjk2TjhZbmpxRlJyMkM3WmRsblhlcS9iNDArODNXN0xUc28rTjNzZlNqdDRIMlE3VHAwK2kyZk41M0IyZWdvelprclRCSmtwb3kwVW4wOTU3WlY1YlNTbzZQaUprNWd3azh6bHZaVDJlOXNoQXhiS1k1ODVlMzdkNXlTM3lldTNYY01qSSt1dVQxNGYrYzRSRWEyVjVtbU1ERTN6Ry9DbXFlZGROUFc5NzhlQThVeTFjOFZUZmp2VlVodWNhdzBmdTJCcXZIUGxxS3hrcXJ3ZHBZNWtRMnRieDc4eUp4b0lXamZObDFjNlNOdzArNEZaRUJFUkVSRVJEU0MyRkNZaW9yNXhVblZRVnluS3BxallSMjhkc1phWEZtd2xxOWJzdUVVMG1McmhZKzFtd3paYUtkbUdLWnQzL1BSc1ZaTEdCYWVGMkN5N2tIUEVwMzdUU25MTWRCTEVHZmZOUkVSRVJFUTBlQndickt0d1ptZ1lhWlpodXQxR211ZG81akZjNldEaE9CZ055cWo2UG9hQzBzcnkrMjl4Y1JHVGs1TWdHZ1JTM2lPZFlScU5CbTdmdm8yeHNUR01qNCtEaUlpSWlJaUlpSWpvc0huZjEzL1F6ci8zei80RkhKUVBmOWVmTVAvL0UvaXJQL0hmYit0K0V1YnpiLy8zLzR5OUlnRTRqejcrcEowKytDMGZ3dFRrYlJ0ZzlPckxWOHo4OXVweUVtNGtJVDhTQmpRMmZzeHV4M1pJT0k3NGgvL2tYNWh5eHc0Kzk1ay9RTFBad0p0WFgxMWRwbTNLOGlYTVNSNURIdXZDcFVkUnFWYnhiZC94UGRpTnQ3L3ozWGErbDYvYlhxK3ZYSzdZMTFpbTcvaWU3ek92LzFmeG1ua1A1bVpuMERLdlUrSDZ0VGZzYTNQbTNJVnU4TlRFQ1JzbzljUlQ3OEJPeVhxS3gvNlJILzFKN0pYdk5NOURKaUtpWHZ6c1J5N2JTdFFmKzlpMy9XTkhLMG05KzNjWUVNNUtWZk5ZMmFsTDYrZzdUVDJmNU1palZFOWdGM3hYdFR4SFJjZkt6cmdyaVg1SGtMUmdscGpIRkVTRFFTdGNOYnVFSlUrNXY1THBQQVlSRVJFUkVkRUFZb0FSRVJIMWpURVZZeFRTRVd6cndBc1pGVWFiZjdHcGNOWjVCbnE0WEhkWGd6eXNrdm9SMVdNZGlTeW5YSGZQSGp2TEV0RERreVFSTXZOZFR1VzdyZEhUcUZUSEVhTER3OW0rRk9jYTdUaEhtblBjRWlJaUlpSWlHbHdTVmlUbEQvVWdzR0VzZ1pSRG1Pc2NSNkhxZXZieVFVUVh5WWpSTXBKMHJWWmpBQXdObkxvZHNkdkZFVzBYVFVSRVJFUkVSRVJFZEtSVUtoV01tWExzaTQ4K1p1ZUZFNmZPMkxMMWNybHNBMjkydy9OOHU3NnhPRUpneXU4TFNSemJ0bWRCcVdUTEpNY25qc1AzQXh4Rnd5TmpPSHZob2cyTGtzQ253c1NKazdhc1ZxNHZsU3YydlpCbGlZZ09DMGVuZDB5OXJxOVU4QWx6OFlTcDdYMm5ocFpLcW9GcGJGenhuYUNVYXppMnA0UXkxY1E2MGtycFhBdDVIdWFDMW9HcHFKWmhka0x6UCtsNGtkdXFiU2pYVS9CY0IxN2dLZCtWNjlRQmpjYlRoNlFGYzdveUorcEhTaVBONVhzTXZHeSswN05tL2lYemVWMXNPKzE1UjVmWVNZcUlpSWlJaUFZU2Uzd1RFVkhmT0swNk9PTklITW5XeGNSeEdrUG5PY0pPQy9Ud0tLbnFNUFVhVXVtL0Z6emY3eW00UmtnakE2bFMyS3ZIanNMY3JrODZCZExCa3pBeUdlY2lpa0w0UFg0T0huT2JhR2dmbitKYjFuZENVNTFpcDR6VmZrUkVSRVJFTkxnQ3g1UTltS25zN1UxNDhrNUpoNHNvaWpBNk9zb1FHQm80MG9GSXBtNVpIaEVSRVJFUkVSRVJFUjFtRW9ZajA3a0xqMkMvU0x1eUo1NTYydjc5am5kOURlaEJwMDZmc1JNUjBWSHpUei95ZXkvSy9DYysrdUYvcUZUK1RxM3g5ODFGcWV6dCs3NXp6a3JNMExHeVk1UCtHckZDbmlOdEozb2gxVm9udWNxeVBLK1k1K1JyUUNyZVBFZXBwbEpJelgwalY4RXBPYXBTOWxFdGU0N25PeWk3enBITkxyS2tCYk41R1cySUVWT01xQi9sM1JDeXVWeXJYemNmMVU4MWtiM3dzWTljWGdRUkVSRVJFZEVBWTRBUkVkRjlwSmcyVUJuR25RVG4zQWcxbGRvcHlHTnpHMHN1OTBOcWZvNWlPRGlqT3hoRzNOUEk5WTV5VE5HN2cvRmpKL0F3U2FjeFJ6cXp5YkFGUjNDQWd1NVRWbnZXQWNuMS9KNDc0cFVyVlJzMnRGZWpKR1ZaTjZSZWhxYzRhdXh6TnBPOEJsby8zRFFnQ1M5eTNkNE9VV1YvVVRiNzYrLzNyd05IdTQ1dDE3VHlrSnY5YWtlN2lNeisrS3Zwc05rM0t5eG1QRjBnSWlKYVQ2dlZ3dExpQXBxTkpZU2RFSTNtOHVyeHBKd1grSjVuajFmcjlTRU1EWTlnYUdqWVhDNTN6eDJJaUlqMmtKU05URTlQMjkraE9JNXhHRWhRMDlnWVIzemVLNTFPZDNSdENjSXFTUG1iSExQSWFPY014U0lpSWlJaUlxTHQrTlNiYy9qVVc3T0kwMXc2MnVFSDMzME9ReVVQWjRjcklDSWlJaUlpNmdkTnBDK1hVOHg2cnZOVENuZ1BvTDRIMElHWkQweWoySktucEcyM0gzak9tRFovWkxtMDlIWmsrNVhPdFNNTnAwMDFYOTBzWkU3TlZPNTBMM3V1ZVk2dWE1Wmt3MnA3emlvMTZCbUkrbzJhTVYvYkw1cnY2ZFU4enorckhmM2xGakJwYmdoQlJFUkVSRVEwNE5nam1Zam9BUnFCS2E4ZGNUSmM4anNZVjdFTk02cGtIYmlheFpmN29RTWZvZkpSVGlQekd2Y1duaUtCT1JLNlVxMFA0V0Z5SGRjRzZFaUhIOFhPUGdlcUNDNHFsY3FnM1pIdmtzNXpKRW1NTEgrNCt6a0pMMUtxdCs5U1JXV29tbW5DNlhiUVBJSVpZbnNtTTNXYW1lTmpVZnRvYXc4Mzg2cVp1K0FRRGtSRVJPdEw0dGdHR00zT1RLUFpXTWJjM014cWFJU2NHOGd4cW9RWEhUOXgwaDVybFVvbEJFSEFBQ01pSXRwekVseTB2THhzZjRlaUtNSmhJTCtiREREYU94SmNKTWNqYXo4ZkVsb2s1YXZkNHhPV2FSSVJFUkVSRVZIdnJzNDM4WWxYcDlGSk1tVG1mUE9EajB6Z3pGQVpaNGRCUkVSRVJFVFVGejcya2N1VFAvYlBubXQ2VmZjVHBxWk1CckgrRGdYbERkSVF0NEVqamFKdGcrcnFKcU84YnRDSW5nMnFDOUlxbmtPWVU5L1JPakw3cEpjMG5CYzhKL3VOVzdYcDlzZi8zSlhETVdJVkVSRVJFUkVkZVF3d0lpSmE0NndYSVZBWlB1Uk9vcXBTMUhRS1QydjRrbGZmWTdBT2JaKzh0aElPcGJaUlBGeDAvSDNZSFlCdGNCRlRVK2dRa0FBdVB5alpmZDVEM1k3dGZxZk01dWE2RzE3RWIrTE9PWGttUTdKZ1ZDZVFkcVhmNlhZSGNQaXNjd29ON2VMVnBBb2lJcUtqN3JWWFhrS3oyYkR6VHFlTmhnMkxpSkJuRWdTWlFLK2VNeW9iQk9CNUh0NTQvVFg0dm0vRE4wK2ZPNGRLdVlKM1BmdTFxTlZycU5YcUlDSWlvdTJSd0taV3E0VXdERzF3VTU3bk5weG5yOG52dUpSUG5EbHp4bDR1bHpjTzBKWmdJTmtHMlphMTk1ZUFJRGttV0Z2T0ljY01zcHc4ajBKUkZySmVtSkFzdDE0d1ZhVlMyYkQ4UkI1RFFvdTZ4eWNhMVdyVlBtWVJ0aWdrSkVxZWs2eTcwK21zYmtPdFZzTkc1RFZmK3h5RlBFZFpGeEVSRVJFUkVSMGRrNDBRTDl4Wk12WDBHbkpLdnRpT01SS3dHU29SRVJFUkVmV1htZVBITzhkblpxN0N4eWRjMzVtRXhuOWxLc1RlWTI0NmE2WUs2TkRMVFhWcWFFNWNVN1l3cC83UUJsUkxJZjhGN2FnN2FacjloelRMRmwrOWcrWi8vbnRYTW41S2lZaUlpSWpvc0dETk1SSFJHaFVuUjAybE9PKzJvVXhocFl1VkRobU1YZDlYVXRqbWJQTkY1c2pnUkh1bjZQQTJpR0ZjM0QzdkRRbVFrOSs5WU9WMzc2eVQydm1ZK1UwRTgvdUlpSWdzQ1M5YVdKakh6UnR2SVk0aXROdnRiZDFmem1HcXRScXlORFlUTy9vVEVSSHRoQVRvU0RDUGhPazBtODE5Q3pDU0FFSXBKNUgxYjFWZUlzc1VVMEYrOXlYYzUzN2FkdTdVRHdRWXlmTHJQWS83bCsyRkxDK1RoQmpKTmhYbHFHdWZSeEcyS09GRnNweGMzcXE4OWY3Z3BmdlhTVVJFUkVSRVJFZERsT1pZQ3BQVnkybHV6bDAxYSs2SmlJaUlpS2kvZlB6UGZWd3F0cHIvM2M5LzRMcEdIWm5LdjlaY2JzR2N3akRQNW1pUU0xVUpNZUlwSy9VRFU3ZWVhdWltK1R5K29uUTIrYk4vK2ZMVjFkdWVCeEVSRVJFUjBhSEJBQ01pSXFPaU1uaW1jUEsvOVYrSEZGVjZtbWtOQjhreHI3ZW5KVHdEUkVUYkp2MERwYitjNDRMMjJMZXE2NWgyS2toTER1WXpGemZTTW9pSWlJNmFUL3ptcjZQZGJ1R0Z6Ly94aHN1Y1BuTVdsVW9GdFhvZGFaTGcrbHR2MlhDRk9JNVdsN24rMXB0Mi91YnJyMkZvZUJoLzdzLy9NSUlnd1BqRWNSQVJFVkZ2b2lqQ2pSczNiTERQMnNDZ3ZTYS80K0xhdFdzMnpPaHRiM3ZiQTh0TVQwL2I3Wm1ibTFzMzJFY0NnYzZjT1lQUjBWRjd1Mnp6cTYrK3V1RzJIejkrSE9WeUdTZE9uTENQLzlwcnI5bjd4WEg4d0xLbFVzbXUvK21ubjE2OVRwYVRRQ0lKSnBMd3BKR1JrZFVRSlhrODJjNGlFRWtlcTFxdFltaG95TjR1Z1ZDeXpQejh2SDIreGZYaTl1M2JXRnhjdE0vMS91Mlc5Y3Z4akt4UEppSWlJaUlpSWlJaUlpSWlJcUorOG8vLzhxZm56V3orci83ejkvNnRhakFVWkVyOWZWT2I5MDR6ZlF2b1VKT2FUUm1lTGdIUlE5VTBVK1pxL1lPcHh2V2YrWXVmdkFJaUlpSWlJcUpEakFGR1JFU1FBQ01OVjBtQXp1RkowT2xsNVBHSFBVSzJYdjBmR0cxUFJMdG1keU1LQnpJd2l1NXhuL1d3OTdON3dUZFZlQ1dWbXhNSEIwUkVSRWRKcTlXeWN3a0RpS051RUZIeDIrNEhBWHpQVElHSHdBOXc3TmlFRFRDcTFHcEkwd1JoSjBRVVIraDAydWErM1NDakpPbUdEOWpqQ1BOZm83R01XcTJPTEUxdEFJRnkrRnRMUkRUSWROeUdUbVBrV2RMOXZWQ3UrYzlNWmc0M3NNc296d2Z0anZ5TzJ0OVNaWDQ3UFJkWnJwSHNRN0dpdjNJNkw0RTlHNVVCU0JEUS9jRkZheFhiS3Vzb2x0dXNQRUdXS3laWmZyT0FwbUs5TWhYSEo2dXZEZFl2ajVCZ0k3bGRqanVjKzQ0N2l1WFhydXYreDlscU8yUnllRHhEUkVSRVJFUkVSRVJFUkVSRWZXaWhGZWhTMU1sUnIwMUM2UWx6MVdMM0ZqVUtPdFEwN25aWkdmeFczVjFLNjl6V3pDbzI3dTVYVW51dnpQOU1KZnlrdVpScDdjV1p2ODdvUlVSRVJFUkVSSWNNQTR5SWlJd24vUlltM0FRdTltL1U3b05VaktTOWthSWp5VU1QMXRCRlliQm15U2tSN1poZU0xY3JJVVlIOHJncm5mUTI0cnF1WFdiUVE0eXFLc1g3M0ZtOHBPdDRNNjJBaUlqb3FQajhIMzhHc3pOVHVQTGlsMjBBa1ZES3NVRkZGeTQ4Z3ZlODczMTR6M3UvRGhjdlhVTFpYQ2UvL1dzdHpNL2h4bzNyK1BJTFg4Q1h2L1JGdkhIMUtscXRwZzFFbXB1YnhjZi96Yi9FcWRObjhkMS84aytqUGpSa3BtRVFFZEhnYXIzMHUwaVhwdEMrOGp0UXBScTgrakY0NCtmaDFzYmdIMzhVVHFtTzBybDNnWFpQenNYZCtqREtFMmZ3eWxLSzZYRHZ5M1FmcXp2d1RZR2xNL1hxaHFGRHk4dkxhRGFiNjk1V2hBazFHbzE3eW1rM0swZG90OXYyT0tGV3F5RkpFa1FyQVlycmlWZmFOVXJnb3BUMWxzdmwxUkFoQ1NvcWxVcjNMQy9YWGJ4NGNmWHkvV1VWc254UnppSHJrN2xzZzB5ZFRtZkRiWkhsNURaWlJyWkZqcFBrc1lpSWlJaUlpSWlJaUlpSWlJajZ5Y2YvNXFjN1ppYlQzNWZMUC9uUkR6OXZhdlZHVFUzZy93VjBxRWtOYldvbWFkbDFXQUtNaHFBYVplaDhHaGdEOVNVRkZabi9tWXAyL1E5Y3VDL2NxdCs4OHZFL2Q0VUJSa1JFUkVSRWRPaXhGVEVSa1ZGWGlTbkVHOHl5b0Z4M083M2ttY3lsazBtM1E4Mm1BVWJGaU5xT1l6dXJGTlBEQ0RiUyttNzRDQkhSYnVpVjhLSzkzSU1WblJTN0hReTdIZm02KzYzdXptdXpqb2RabmtubHc5MTlyREw3WEdkbC96dEFvVVlTN2xmUkNVbzZCUkVSMFZIUWFiZlI3clF4UHpkanBsbHpidFg5RFpTUW9iR3hZM2piRTAvaTVLblRlT3l4eHpFOE1nTFg4OWI5YmZlRHdDdy9qc2NlZnh1Q1VtQ0RBU1RvNEswMzM3QWQvZVdjcmRGWXdodFhYOE81aTVjWVlFUkVOQ2pTR0xtWjBzWGJ5RHJMWm40VDJsd08zL3dqNktpRlpQNG1ITCtFdkRHRGRIbktCaGZGVTYrWjZ5cUk3cnhzemd0ZHVHV3p6dzhxOE9vVGNHVWFtZ0J0VDJMS1FqdGhodXVOQk5kYkdmYmE4Y0JIMVhOUTIyUVpLVXN0d242MldrWnNGSVJVS0k0bkpCUnhzM1hldjM0aGdVWnlIem5lS0s1YmI5MWJrZkFoMmM0aUlFbTJwWmY3Rm1YTGd4N2lURVJFUkVSRVJOU1BacHNkcEhsdnJhc2FVV3FXQmFKczQ3S0Zlc2xINENwY0dLMWl2OFRtOFdPeklkZVgybmErbWFydjJpRHBzcmQxMllKdnl4K0FrV29KTHNzaGlJaUlpR2dYY3VnWFRNVlkzUnlEZnNKVWowbUY3Vk9PVW9HR0RrQ0hpcHlSU08ybkRBRnpXQWJkZHFHVFRLdWNQWEg2a2M1TjdYbHE5aVd2bWdzdm1UZnBWdVMwNS9IeGQyVEFGUkFSRVJFUkVSMTJEREFpSWpMR1ZJUlRUdGd0blJ3d05rekRUR21hMnM0bFNkSjd3RVFScXVHdGRMaVYrVUYzTkxIOWRsaHVTa1M3dFJLR1p2ZGVlN3dMazMxcm1pVm1YMnZtYVdZdjk5cVJVTGJGZFZ3YlhpVDdXTmR6N1g1VzFqRW9uZm84ODhxTzZRNHFLSU9JaU9nb1dGeGN3T1NkVzdoKzdVM016a3l2WG4vaXhFbGN2UFFJZnVnamZ4bmxTZ1VqSTZPYnJxZGVIN0xUK1FzWDhRRnorY3pwYzVpZG5jRXYvYXVQMlFDakpFbXd0TGlJejN6NjkvQUJSK0hDeFVzZ0lxTCtsOFZ0NUowbGRLNStDdkdkbDlINDRyK3p3VVY1WjNuTCt6cVZZU2czUUhENktYaGo1MUMrOERVb1AvSStCaGp0UUR2Sk1kdEs4TVhaRUM4dTdIM2c3dFBERHZLZzIxSjVJeEx1SStmNjhwdStVVGlSTE9QNy9xWmg4d1VwTDVEbEpZU28xektEWXQyZFRzZmVyMWFyYmJxOW01SEhMSmZMOXZsSTZLTDhMZE5XOXl1MlhiWmx2ZkFrSWlJaUlpSWlJdHFkMTZlWEVLYTlCVGhmblE4UlpqbG1PaHVYbDF3YXE2RWVlUHNhWU5TT015eUdDWDd2alZsTU5xTk5sejFkOHpCYWNuRzhHc0IxTmk4VHFRYytQTmRCdldTVzlSaGdSRVJFUkVRNzkwOC84cnUvOWlNZmZhNWNoM2ZUSEZsK0VFb2YxOUFqNWlZR0dCMHlpWG1EUXpOMzllSHBST2xEUlZEZ3lMUjlhQ1c4cUdNK2R2L1pnZk94ckoxYy9ia2YvNE1taUlpSWlJaUlqZ2dHR0JFUlFRcUpOSndCU1MreXdSazZ0MEVhMGpuRkJoaVp5OTM1dGxhMTJyRkcxaU1kVkdRZDdzcW80Qkt5b2RUK2hoblo3S0lldDFtMkxjOHp4R0dJSkUxQS9hOWNycUJrcHUxb1pvNHBTVmVZUzEzNytXamxqczJpa1V1Qll5YWxNZVptZGw0eWwzZnk2WXpqQ0oxMkM5VC9wSU5jdVZJMSt5UzNwdzV3c2ovUmU3RExrbjFqTjZRb1c5blA2cFY5N0RhQ2k5YXc5eldmV1cycUk3Szh1NytWNTFZRXh3MEsyZEpBNVVqTmk1eUREUUdKaU9qd1dseVl4NXR2WEVYWTZkakxudWZiMysxditkWVBZZnpZQkdyMXVyMXV1enpmaHg4RU9ILytnZzBGdUhuanVqMU9rTWVSeDd4eit4WkdSMGRScWRaQVJFVDlRYWVSbVdJa3MyL2FnS0o0OG1Wa3pUazd5WFZaWXhZNmJOcGxlbHBmWXRhWHBVam1yaU5yTDVuMXpBS09CM2Y0Skx6YUJGU1p2d0dEWkdob0NJSDViVzgwR2l0bGwzZkxET1M4WDZacXRZcEtwYkphRGxzM3h4SDVTaGg5b1FpVUh4NGV0dXNyeWczR3hzYnNzaEo4V0pSVkZHUzl4WEt5VEZGT3ZCZTZJZm5KNnJaSUtKSmNKOXR4Ly9PVWNvMGlPS21Yb0NNaUlpSWlJaUlpMnI1Zi9jTHJtRzJHUFMyYitoV0VtY1pVdUhFNXdiT25FNHhYcFUvMkdld1hDVnhhN0NUNDNLMUZYSjNidkkzT3NKT2lySExVVE5IQ1ZpMUR6bzhQb1JwNHVEUmh5bEU4OWlzbklpSWlvdDI1OUJiU3lZdnBOVWU3eWxIYVZPQ3BweFR3cExucGFUTU5nNGhvbTNLbGJ5bU5QekkxL0MvRVNDWm5acVo3YTFCQ1JFUkVSRVIwU0REQWlJZ0kwdmhCb3h1WDB2OU1RUmJ5ck5zcHBSamRXK3VkYjd2Y2QrMEk0Sm1yNENnSGdTckJOWC92WjRDUmZmd2VsN05CSW1tS1ZxdUpNR3lEQnNPMkE0eHlCNUYyOEVZVUlETWZqcG5NdDk5TjM1VGkxcHdjZFRlSEY4UjJIbWdKZ3NHMkpYR0U1YVVGVVA4TC9BQyttZVNJZGFzQW83M2FneGY3MDZJellaS2t1K3NBcUx2NzdiWGhSOTNnSXQ4OHA4RUtNSktCRGt2bXV5alBJdGNNTUNJaW9zTkx3b1N1U1lCUjJBMHdrdU1SK2QzK2xtLzlzQTBncXRlSHNCUHl1eTlCQU9jdlhETEhvNHQzQTR6Q0VBdm1NU2Z2M0RLM2x4aGdSRVRVUnlUQUtJOWFpRzUrR2VuaUxUUy84R3RJbDZlUUxVOWpKMlI5SXAyL2J1ZnhyUmZoRFo5RTZjelRVSDRaSGdPTUJvb0VHRWx3ajVRZlNQbnEyakpXK2MyWFNXNlhzS0cxOTVIbE9pdEJpVUtPRWFUY1F3S015dVd5L1Z1dUd4OGZ0K1cvRW54WUJDc1hKUFN3Q0VrcUhuc3ZBNHprT2NsY3RrVkNsK1M1TEMwdHJUN1hnbXh2c2QwTU1DSWlJaUlpSWlMYUg3LzZoVGR3YmE3UjA3TG56NTFHeHhRUlRHNlJkM1JxcUlUOUZLWTVGc051Z05HWDdpeHR1cXpxTk9HWWNqTWxBOXB0MFFidVhlZU9ZYlJhd2c5OXcxTVlxVERBaUlpSWlJaDI1L25uTDh1b0k5ZCs0UG1uYjUrOWVPS0xLZHpuRlBDY3FTYzdCNlVZWUVSRTI2WTBicG1UMjArWUd2d1hmdllqbHlkQlJFUkVSRVIweEREQWlJaklLT2NKcWlwYTl6WS82OEF6VXpscndzbFQ3SlZXY0F5WkV5QjFTdEJxcS9HanV1SzRPOHExQkdyWVFJeDg3ME9YOHN5c1YyVUlvOUFHR1pYS0FSUmtOTys5L2NtUVRkOU83bEtuM1VhenNXaTJxNE1zMmJ2M2dmWlBWcXR2dVV5Y0s4UmE0WTI0aE1uRXhWVHFJY29kdE0zMTh2Rkl0SHo2WUNmWGxPYTY1by9Yb2dEU0hlcHRwUmcxSjhQVDVjZ0dxM2lxdHcrVWhHRkZZUWZVLzVJa052dUtIUFdoVVF3TmovUjBIL2tVeVA1RndxMjJHN0dUbWMrRzdGZmpPRGI3cDl4Y3pyZTNvK3FSN1FpWUplWUI3UVViYUJTVXVvMERldzJOQzlJV2hxSXA3SlhjOFpBckR4MS9CTEc3Zm9kWkdmSHd0QnViNzZtUEpmVDJ1MFZFUkRSSVdxMFdacWVuTUQwOWFjNDlHcXVkODkvenRlK3pIZmZIeHNmTmIvWFd2NEhTc2YrVmw2NWdlWGtKMTY5Znc4elVGR2FtcDgzdmZXQkRBRDcwN2Q5bHo3VysrSVhQMi9NN09jK1RaZVE0VlVJTmprMU1nSWlJSG81MFNjS0pwaEJlK3h5eTlnTEN0ejZIdkxPSWRISEtoZzlselZtejBONE9qdGU1K21uN3VLUGYrdGZndmZNN3NSTys3OXZmbENpS1FBZEhRbjNrSFAva3laUDI4dHFBSWZuTmwzTjhlVy9XT25iczJEMGh4MEtXSzVZdEFwemxzaHgveUhJeXYzLzk4dGlGSXFCK2JiRFFYaXFaTWd0NVBBa3B1ajlNdndoUjJpcDRtb2lJaUlpSWlBNnZmL1BIcjZIbUtmeHk1VzY3b3FVNHczS2M0eXQzbWlBaUlpSWlJdXAzNzhDVjlQSmJKNXBQbk00KzVibjRTdG56ZmorREhzMjEvZ3ZtNWhPbTl1NmRvSUVWUWtOaVZhWG10Z3dPNEVyN1FvS0tJck92K1BlNVRyK2tGVDZCTmxnb1FrUkVSRVJFUnhJRGpJaUlEQWU1MlNHdVAwSzEwaGs4bmNEUDJ2RHlCSHNsekllUXErMk5TaTBkVnZKYzc5bG8yaHVSUGloYVJ2VmVDVWt5QldoNDJPTm5aMWxxTy9abWFXbzc5bEwvMHowRXY4Z25PVE1WQWZPcGEwTlJwaElYa2Q2Z3c5UEs2cGF5N3FkeHdrdVI2ZTQ2N0cwOTFpZDB2MFA4REEwQzJRZlo3MzIyZzlDeWJYd20xdDVIOW4zUzRlLytEbmw3clFpZ2s5Q2tYa09MMXZMeUdLV3NoYjJTYWQrRzZvVjZhTU5sUEpXajR1UTJNQXo3OTlJUUVSRTlORWtjbzkxdUlRb2pHMEpVT0g3OEJHcjFPb0tndDlHSTVaeEZ3b3VtcDZadzgvcDEzTGorRm03ZXVJN1RaOCtpVXFuZzdObnpadjJKN2V4ZmlLSVF5MHRMNW5vZXB4SVJQVXc2RFpGM2xwRE1YZXNHR2IzNXg5QlJFM200ZiszS3N0YWNPVWMwNVYzSnpzS1dpL0FiT25oRmFJLzh2dmVxVk9ydGVFTGVVOC9ydlFwdlA4c3dpbU9XN1d3UEVSRVJFUkVSSFIydlR5K2hiRTZScDlaaytIWXlhUmRsNWdrcmxvbUlpSWlJcVA4OS83dzBSNytjWHdabXpjWFovKzdubjROeS9icFcyZmRBbzhiYTJNRW1mUTJrRnhEUFVHa2Z5V2hUeStiVDlycmpPTmQvNWtjK09Ra2lJaUlpSXFJamlxMk5pWWdHZ0l5ZUxwMVE0bmp2QXBTMnBMdmhJWjFPMk8wSVZlbDJuSEhkM2Y5MFNIK2EzQWFGYkwyc2RCenV0SnRtT3hxSW94QjBPS1RtL1cvbkRsN3NWUENWVHRuOHJSQkQyVUNpWHIwY2xteXcxa3ptNGFTWDRJUDFOdWh3a1RBaCtkN0w5MTg2eTVVclZmaCtzTVY5elA3RkFkeHQxQlptSzRGVzdYWjdOYmp0b0VoWVV2SFlubm1Pd1VwSFJuWStKU0lpT25oUjFNSE05Q1JhN2NZOTE3LzNmVitINDhlUGIzQ2Zic2pxdi96WXY4Q2RXemR0YUpFRVppNHZMeUkxdi9OcGt0cWdna3ExaWovL2YvcGhYTHo0Q0U2ZE9ZTm1zNEZ2K3Vadndjek1ERDcvdVQ4eWp5bm5QRzI3RFVSRWRERFNoVnZJNHpiQzF6K05lT1pOZEY3N2ZlVHRSVFBOSTA5TkdWd1cyOXYzV3g0dVEwY3R0TDc0RzNhYlJyNyt2NEZUSGVuNS9uTCs2UHYrUGVGN2c2b0lZeHFVYytKR28yRmY5N201T1NSSmNzOTdJTC8vTW8yUGo2TnFqZ01LMTY5ZnQ4dUY0ZDF5VGdrR2t1ZDgrdlJwQkVGZ0E1R2t2R0JoWWNHVUI4ZFlYRnkwZ2ZaU1BpekxTWERTOFBDd0xTdVIrNGo5Zk4za2Vjb3h6L3o4dk4zMm9peERIbCsydDFhcm9WNnZZMmhvQ0VSRVJFUkVSSFQwdkQ2emFBbzRNcmhyQmliU3lrWHVPa2g5YzA3czlSYm1TeHY3N2IvNWZUMHYrODgrOHliZVhHempmL3ZxSFF5S0gvL1dkK0tERjQvaDNhZUdVZlkySDJMUGM1V1pISndhcm9LSWlJaUlhTC9jL0UvSDM4UVBmTlU5M2pyeFl6bk1ZYXAyM3crbEg0SEc5MEhobUttWmV4eEVkR1NadXZ1clpqWm42dWgvMSt3YjVwSGsvOWJlMEtrc0E2OUZJQ0lpSWlJaU9zSVlZRVJFMU1lNkkyZnIxUTRxK3ptUzl1YmJJRzJOTWlqUGhiTnllYmNkWW5vSkwrb3VseU5MRTlzeDVtRThmOW9maVZabzVTNmF1WVBsekZrWjFXQjduNmxJTy9DVU52ZDNVVkk1d2x5Wnk3RFgwZUVoMzN2NS9zdCtJTS9NanNQdjRUNnlmM0hSRTFtL1hhOGgrOXFEVnV6VzVMRnp4MEZ1Tmw1aGNEcHJFaEVSSFNaeXpORU5KT3AyeW5mYzdnR0ZkTWl2MXRmdmtDK2hBcDEyRzB0TFM1aWNuTVRNMUtROXZnak5lb3JmODVxNXY0UVgxS3AxakptNWhBNDR5a0Y5YUJqdFRqZXdTQUlVTS9tWFpqWVF5ZlZZWkVkRXROK1N4VnZRY1J2SjNIV2tjMjhobWIrT1BHeEFodzBjS0Z2bWx5THJMQ0JkdU5FOXFaWEovRmIwU29KazVQZGwwSFhEMHdmbnVVaG9rVXh5L0NEQlBtc0RqSXBBSWJtdUtOc1ZzcXhjbG1PSWdoeUR5SE9XVUNPNVQ3bGN0dGZMTXNYNmk3TGhZcjF5bTl5bldLLzhMZGZyWFpiZDNuLy9vbHhHSGsrZVM3SDl4V1BLN1JMQUpOdGNiQjhSRVJFUkVSRWRMWEZxNnJqTnVXSzZVcll1dEp6YXkrQm1IdHR2N0lWTEU3MkhCdGZLUHVxbEhocFc5SkZhS2NESjRhcDVuaEpnTlBobFhFUkVSRVEwK0Q3KzhZOW4rRGpNU2M2VnlSLzU2SFBsaWxKdnVhYXFUNm44bW9iVE1UVjNkVk1yVmphMVkyV1pnL3FhbkpubUszT2lIWkNHQU5IS2xKaFBVZ0tGNjZaMmZzWVVpTnd4ZjAvK3pGKzVmQk5FUkVSRVJFUmtzVGNVRVZFZlMxZUNlNlNqeXNNTTc1SEg3b1NSN1VBa3hleEZoNWhkcmJQSDVkSXN3Y0w4N09ySTNuUTRMR1V1ZnFkUk4zTUhNWGIrV1VxMXd1M0VReXRYK0tOMkZSZUQyRXdKNkhBSjJ4MGtVUXpYODFFcWIxN1BwOWZNdC9wa0ZmdlZNQXB0YU1EREpKMy9aRjh2KzdvZ0NPeEVSRVJFQjB0Q0EyYW1wOUJ1dGV6bDRlRVIrNXM4Y2Z5RW5kYno0cGRld0J1dnY0WXJYM2tSMDFPVDk5em11QjdLcFJLKzZadWZ3N2QvNTNmajlObXpxRlM2SXdKN3ZvOExseDZCdWkrZ1lYbDV5VzdEOFpNbnpma1hpKzJJaVBiVDVDLzhpRGtYVEpFdDNrWS82THo2S1lSdmZCYkRIL2doK0JKMlZ4bnA2WDVTVGlkQmVWSld0N0N3Z0VFbXY3dkR3OE9yQVQ3OWJuNStIczFtYzkxeVN3bjZrVW5DZllyemZTbUhhSzBjWjZ4bGc1dk5ORGMzdHhvR0pJRkJkKzdjZVdEWklzaW9lSzlQbkRpeFdwWWdud0Y1TEZuSFRzcHVaYjNGdHZwK3Q2T2pYSmJ0V2x4Y2ZHQjVLY3VRNDZjaWVLbGtqbnRrY3QwZVU2V0ppSWlJaUlpSWlJaUlpSWlJK3R6SFBuSTVOTFBQckZ6OHRSLzc2SE9uSEhoUGFXVGZaMnJrbmpYWHZSdFFvNkMrSmVrem9YbXpiSzB1VTR4bysyNlo3L2hOVTBQK0srWURkTjJGL2tMY3h1elAvdmpsSm9pSWlJaUlpT2dCN0FsRlJOU0hpbENOM014ekc2clJQeVdsdVhUSU1RVzRTcXNkZG9UWlJuaVJCRGlsbVgwTkhtYUFFKzJ0T0ZlSXplY25OSE1KSU5vTG1WbFBJM01RNVJ6bC9URFNLL3RDMmYvSWZzR0dxYWt0UnQxYjJkZHN0cHZxZHZyTHU4djJ5VDZtKzF4ek84aytkcmRoY1VSRVJOUzc3dTl3dG5wY0lKMy9mUnNHNEd4eW54eFpsblpQZE80ajRVWG56bC9BK0xFSmxDc1ZHekN4bHF6Yjg3MzcxbWVPYmUwMmdJaUk5a25lV29ET1l1Z2tNaGRTOUFzdHpTVk51VWEyY010c1c0anl4ZmZjYzd1RWZHdTlmc0MzL01iSXViSUUzNlJwYXFkQlV6d0hDZUxwSlFESE5lZkxWZC9CZU5uRG1lcmUvM0JXUFFlKzgzRE95WXVRb2w1SjJVRVJXdFRwZEZBeHh4MDdEVWFXMENVcGs1RDF5WHZDTWxraUlpSWlJaUlpSWlJaUlpS2l1OUlZcVJla2l3ck9OYW5sVlZDbTRobkRwbUx0WEhjSmRjcDJzekJWbXFDK0lEV2VHWmhkUkp2VE51ZEtoK1k3M0RiMTVHM3pKVjR5Zjh2STJtOUI1ek1TWXFTZGVDcldYdGlld2VBMXlpQWlJaUlpSWpvZ0REQWlJdXBEUllCRm12UlhoeVBacGlpT0VaaC9idURhN2R4dXVFYXZBVWJ5V08xV0EzRVVJc3NTME9FZ1FVTUxtWXY1MU1WMHVuZUhJYTFjNGFXd2pERTN3eE9JUVlkTE54Z2dSeGkyb1J5RmFtMEludWRzY1ovdWZMTmRsSVFoeVQ2Mm44S0xaQ3IyKzRFTlRHQ0FFUkVSMFVHUjhLTFluTy9ZUUNKamFIZ1k5WG9kemliaEJYRWNJZXgwN1BuTC9SNS80Z2w4NzUvK0FSdGlkT2JzdVh0dWsyQ0c4ZkZqV0p5ZnYrZjZKSTN0TmpBc2dJaG8vN1JldlF3ZHRaQTFwdEJYRXJQL04yVWFTMy80aTNCS05aUi82Sit2M3BUbU1UcHh3OHdmTENjc3dtdmtOMHYrWGx4Y3ROTWdrZTB1bFVyMk9VeE1UUFIwTGx3dnVUZzJIT0NidElNbngwcllhOGVyRW1Cay9sakNnY3V5Yk4xamk0M0ljWVdFRmkwdkwyTjZlaHFuVHAzYVVZQ1JsRWRNVFUzWklLelRwMC9ieTdJdFBDNGhJaUlpSWlJaUlpSWlJaUlpNnZxNUg3MDhhMll5dlNDWGYreWp6NTB5TlhQbFhMbC93MXlzbTVxMVAydHFPMzN6ZHhYVUZ5UzhTSG9YOUY0RFMwZVJncDQwczdlVTBsOHc4K3ZReVcrNXltMy85RWN1WHdNUkVSRVJFUkgxakFGR1JFUjl5SVlYMlZDTi9pb21MVHFyRk5zbm5hTzJ2UTcwRm1Ba2p4VkhFWktFNFVXSGlYeWlaMU1YUzlsZUR5cWhrSnJQVEZzN1dEVHJycW9jZ2NQT1ZZZU43SGRrdjFDcDFMWmNWcStaMzkvdHNRZ0trbEFrbWZxdEkxNTMyN3FkRmFYVEprT01pSWlJRG9ibkJhalhoOUJ1dGV6bGhmbDV0SnBOKzd1OGtVdVBQSWFob1dGTVQwOWgrTTZJbmZ1K2o0c1hIOEdUVDcvRGhoZU5qSXcrY0Q5WjU5VGtIY3pQejkxemZibFVzZHZnT3B1SE5SSVIwYzdGZDE1RzNsckF3NUFxQjlxYzRuWE1iNFUyNTNybXJBK0o2eUIyWE9UbXNseVhKYlBteEhBWndZdi9GcmtwRzR6ekJEbzNkMHFCWWVjTUttcDAzWFhMNzQrRTJCUy9XeTN6ZTlaUG9iMGJrYUFkQ2VBNWR1eVlEYzdwNVR4WWJ0ZUpLVGRjbk1GSW1NTkw5LzQ1bGxzS2ttRW8yeVN2N1hxcTFTb2M4NXN0d1VGeURyLzJ0WmJuSkpQY1g5NlhJcEJJeWxPTDgvNjF6MGZJY3ZKNkZJOVhxOVhzY21FWVB2RFlzcXc4dGl4YnZHYnl0OXduTW1VbmMzTnpOaEJLSGsrMll5UEZkc2x6a01lUzUxUUVLc3Q5NVRIa3NlU3oxRmtudExGNGpzWHI1UEFZaG9pSWlJaUlpSWlJaUlpSWlJNlNOcHFvUWlyMFBxR1VFK1E2dTJwcS84WTExSGt6bjlEUUV3N1VCVk9UV0RWVFNUM1lySm1JRG9qNVBrNmFMMkNvdExvSnBhTWNhc1plTnRmbkduT21tbncyei9VZHBiUU1kVFJqSm5abUlpSWlJaUlpMmlZR0dCRVI5U0dkUzZoR2lyd1BPeGdWSFd5a0U0dDBVTmx1c0VidlQwa2pqaU5rYVFvNlBETHovczlsSHBienZlM01KQjhyODZsRXg2eFh3cEU4VHlNQUE0d09telJON0Q2bmwzMmozaVRCU1BaajB1R3VtUHBOMGVteDN6dVpFaEVSSFRhKzc5a3dvc1dGYnFqRjRzSzhuVzhXWVBUSW80L1o2ZlhYWDBPMVdyTWQrNldULzdQditWcGNNdGVmdjNCeDNmdDFBNHdtYlVqU1d1Vnl4VzZEWXVkL0lxSjlrOXg1R2VueUZCNkd6T3pmTTNOZTJ5aVY3RHgxWExSOEgyMHpKY3BCYm02ZlQyYVJadzdhWC9sbEpIbUtadEpDeFIzQ1NQazQzbm44T1p3ZFdqL0FTTXJwSkh5bStEdU9ZM3QrdWRudldEOG9tZGRDZ25JbUppYnNPZjlXQVRqRk1qYkFLT3BnMkZ3M2pIMndVaVJaSGgzZE1NUmR3b0prKzl2dHRnMWh2ei9BU0c2VFlKL2lmUkVTOGlQdnlmM3ZTeEVVVkFRQnlmT1U5Y3Y3dUY2QWtheFRIbU50dUpJRUQwbG9rWVFSeVgySzlXd1dZRlJzODlMU2t2MjhqSTJOclFZWEZjOUR0a2x1aytjbzI3TldFWnEwV2RBVEVSRVJFUkVSRVJFUkVSRVIwV0gxc3o5K3Vibnk1eWRXNXIveFYzL3h3eGVDWEw5SFF6OWxhamlmTXZNaE0zZVYxZ0ZITlNWNnFDYk50S1FWUG1PK2s4dm03eXNhMmFLcFVYOWhXU0g4MkVjdWh5QWlJaUlpSXFKZFlZQVJFWkZ4NHVScG5DM0g2OTVXVFJiTnRJRGhLSUdYUjlncjA5VlRpTHlxbVVhUXEyNkhFRk00alR6TEVZWWQyOG1rSHdPTWhHTzIxM0dVN1ZpN1VRZWUreFZoSE5ldjMreDUrYkRUQmhoQ1EwUXIwaVN4b1dhNng5QWgyWVdlUEhYYWRyWmIyd0ZTT3R0SlFGb2NtL1hsL2R1UnMyWTdJM3EyQStMOTlaVWprWStUelhuc2xjUXBJWFVybUsrY1Fzcy90dTR5QzIwUDJVSVpPalBiMG4rNVQwUkVSTHNXbEVvWUdSM0R6UFM5b1JiWDNud0RqZVZsUFA3RWt4dmU5eHUrOFp1eDlNNGx2UDhEMzJnNzc1ODRlUksxV24zRDVlV1k1dXBycjZEWmFOakx4ZkdLaENpeDh6OFIwZjdJV3ZQSW94Ymk2YXRJRnlleEh6cW1uR3ltVmpOekh3MXpMaWNoUmRwTUVsQWs0VVZTQmlnbFhaSG4ybmtPQjVuYkRUS1MweXhaTm5ibGI0VXNhZHV5d3UyU2MwajVUVGwxNnBRTm5KRmdtdFQ4N2toWll6K0U1UmEvZVVORFEvYnZrWkdSQjg3Yk55UFA3L2p4NC9iNVNGRFBmajJuSXJpOTJMNzFTSWlRQkJHZFBYdjJnZTJRNTFPRUVxMTlibWZPbkxIeit3T001TEVrQktnb2E1WDdqSStQMitDZzBkRUhRNnVLOTNrdHVhOXNrMnlIaENjdHJJUXl5bnBsL1hLZmdqeStmQzZLNEtWaUdibi8vV1VRUlVDUnZHZjNiM2NSb3NUakZ5SWlJaUlpb3NFazU0UnlmaWoxNXhMUTM0dFd1NDJka3ZQUVRxdUQyZG1aYmQwdlRkSnF1OU9adUg3OXpVdlBQLzkzRGtWbndxbXBTVyt6ME9HZGtxRGxLTnE4ZlpzTktZN1VwdTlEcTlWRXV4TnZ1cDVtczJuS25ueXpudUNCMithWFFpd3RSejJGYTNjNmJiT2VSY3pOWmloNSt6UEFnNVJkeUVBVVVwNnlINjg3RVJFUkVkRTl3b1haR0dOZk1MV0FyNWM5ZkNyWDJhL0JWYVlpem5uS25JaFZUSDNjNDZZcXVLNlZQbWVXbmxCUUU2QjlFMHV6WjNQK200RFpVWWZVdkhsbm02YU1vNk9saVFiVXkwcnJXQUtLdEZKTmM5VzhlZXZuMDB5M0hFY3RLbVNocVlhZmhlTkZjWXlsd1BQVFd6ZHV0ZkhWSy8wOU9oUVJFUkVSRWRHQVlJQVJFWkZScTljeE5yeCtnV1F0TnFYRGNZclJ6Z0tDZk84NncrVDFHa0ovQkcxLzNKU1NkUnRmRktPaSsrMEFydGZQblQ1VXR3UFA2Tmc5SFY4MlV6UkllV3NiQVVacG1vQ0lxSkJscVozblBRUVlGWHZyb2VFUnU1OWEyd0JOR2w1S1VKdzB5dXVsc2R6RElvM25wUFBoL1owZHhWaW5qVk5PYi92ZlhzUnVHWWxiZ2FxYTE2dTBmb0JSMVRHdnFvdzFvUmdzUjBSRWg1TUVCMWFxVlhqM2RjQ2ZuNXV6eHgrYkJSaWR2M0FSNTlHNzFCelhTRkJTMFNGRXpxL2tlTVUxdi8ydXgrSTZJcUw5SU9GRmVYc0IyZkkwc3NZVTlvT0VGTTFYcWphOFNJS01FdVVpZHhTV1NpVnp6clhOamxINXpzckY1RHl5bU9UM1N6cXN5Zmx2MFhIdFlRY1l5Zmx0RWJRaklUc1NFTFRkK3c4UEQ5dS9HNDNHdmowZmVaeU5BbjBLUlhDUGhQdjBhcjB3b28wZVg0S0R0a1B1STJVZ1V0WWhyN0VFUEVuUWszUkVsZWNnNVFzRitVeklaRVAwemVmazlPblQ5cjdybGZWdTUva1JFUkVSRVJIUllKSHpham1QbEVHQUpJeW1GN0xzVHNsakpXblM4Mk90UG1ZVUJxMW1zejQvdnpCaHpvQlA0UkF3cjhHK0JCakoreVBuL0p2cHZnL3BwdTlER0lWbVhTbTJlaXlwNTFodlBlMjIzQmIzMUNaamRUMHRaY3JROWlmQVNNbzhTcVZ1R1FjRGpJaUlpSWhvdi8zY2ozNWVrbCt2MzMvOVgvdm9oNy9lVnpBVmhxcVZLejFxYWlHbGtaSWNxRExBYUIvSm1VMXFRNHhBaDFQVHZMVUxwbEo4V1VIbkN1cEw1dnNWbXI4bnRjcm5YZTFkYjZUTjY3L3dseis5ZHlNSEV4RVJFUkVSMFliWUk0cUlxSTkwT3hXRnlOSVUvYTA3b25qUjRFVTY2bXpVa2FmUTZZU3I0U05ia2RjZ1NYYmU0SW1JRHJja2lSQ0dMc3JseXBiTHR0c1NWSlJpZUhqSTdyZnVqaUFaUC9ST20xc3BBcFlxRlhZVUpDSWlPZ2dWYzJ4eDZ2UlozTHorMWozWGYvNXpuN1VOMnovd2pkK0V2WEREckgveXpoM2N2blZyTlpoeFpIUVV4eWFPWTJob0dFUkV0RCtpRzE5Q2RQM3p5TUpsN0lmZmZlUlJSSzZIMldvVnFlTWdNWk5lS1M5TG5mM3BlTFVaRzR4bnB1UEhqOXZ6M3hNblR0anpZZWtNSm5PWjVMd3ozY2R5U0NremxGQWRtVXVnamdUaHJMM08yY0hySXM5SmduamsvaEordEYvbjlrVlpwNFFzYlZYdTJXOWttK1gxT1h2MjdHcUlsU2pteFRJU2tDVEhPUEw4NUwwWnRPZEpSRVJFUkVSRXV5ZmxBdlB6YzdoMTZ5YSs4UG5QOTNTZm9VYU1IL0h2dHVseGhsZkNjdGIyQkpWVFRIT2VxUjF2dFh4RURDKzdxSFVjL0tkUGZCbmJZY293SGsrUytGU24xWDZmV2VHaGFGRDBPNy85Vy9zU3hDVHZ6Nk5wYnQ2ampjdDg3cjRQVnpaY1JpOTJVRGZ6SHhydmJMaU1ldk9MdUg3YncrS1ZCNXNoeDJZYndremoyem9SM3U5dlBralZxUnZYY1dQU3dWSnAvNEtGamgyYndEZDg0emZhY3FXeHNYRVFVWDlwTmh2Mk4rbjMvdk1uYlZ1cEd6ZXZJNGtUdE50dEhHYmxjZ25sVWhrblRwKzJiZHZPbkRtSHMrZk9ZOExVR3hQUjlzaitJbzRqZk9tRkwySnBZUUd2dlBLU3JVT0tvczBQSGFWdVpIaGtHUFg2RUI1Ny9HMDRkODU4RDgrZXQvVXNISHlLOW9PcHFYMDVLOEZ6SXJ6c1pQRGdvbTZPZ3NzNlJka0wzQW56c1IweDFYc1hsTktCT1pjNmhSeDFyZlRqcXl2UU9HYyt0d3c3b2tORlE3OXcvM1htY3o1cFpwUEY1Uno1ZFFWVEhxQlZVNWx5QVkxMFhqbXFxUlBkMHE3cUtLMnozTEZaVmJMc1loQW5lUnI0Y1pSR2NTa3F4Y3VYejNWQVJFUkVSRVJFQjRLbGFrUkVmVVk2bGVSOUhxcFJzTnVhNXowdEt4WExhYnIxcUZwMnZUcUh6bnRibG9pT251NitwN2Q5aERSdXViOURwRlJNOTdydmVwaTZ6NUhEZlJBUkVSMFVDVmFRaHV2ZWZZM1FabWRuYk9mK3ZkSnFOZEZ1TnhHR2Q5dEYrSDZBYXEwT2g2UCtFaEh0bTZ3NWkzVGhOdmJMdE5tUEo0NkxwWElKL2FBSW81Rmdta0lSVmlUQlJVVXcrWDRxUW9wa0crUzN0RnF0MnQ5Wlp4ZUJUdks4WkIwZUc0MXZTRjVmbVlyWHFDZ0hXUnRnSkVGUThwNnNkK3hEUkVSRVJFUkVSNGVjTDhyZ1A4dExTNWlhbk96cFByNlpIbGw3YXIvcGFYNTA3OFcwTzAxdHY5dGdmV1U2cFhBNEFuaDdmYjIzeTErWjZwdTlMejI4RDBWcHdjWE5pcnJhTVRwdDZZUzlzUlB5djYyS2dwcE51NDc5N2swcW4vVzlyTzhob3IxVEJPN2Z2bjNMRG54NTliVlhUVjFxaUdhamdjTk15c3lydFJyaU5MRkJhN1ZxSGFkT25RWVJiVit4SDVtWm5zYnN6RFJlZWJrYllDUURlMnhHNmxQR2p4MnpnMDdKd0JtalppN0h5R3kxU2Z2bFl4KzV2TGp5NSt6OXQvM2tMMzc0Z3FQVnVGSzZvNkVEcFZXVUt6MXF6b0JXaysyMHdyNEVvUkk5VE9ZenZuVC9kV1lYUHVWQTNSMkZVTGxYZ0N3MGUrN2xWS1ZoU2NLTnRGNzg2Yit5K3AwaUlpSWlJaUtpUHNGV3lVUkVmVVRyYnNNZ0Nmc1pCRm5XN2ZSVWpOUzltV2F6YVN1VmV4R0huUVBwUkVVSFR6NGxaYVhSM3FmMlpHV1ZZOVRORUxENjhGQ1RrWEpFdFZyZmN0bmw1V1c3anhvYkc3VVYwbW1hOUJ4KzlMREpiMEYza3JBbHRhc09ua1JFUkxTMW9GU3kwNlZISDBmSG5KTmNmZVZsTzlybkt5OTFSeUQrUi8vd0grRGMrUXY0ci8vQ2Y0dWR1SDNySnNKT3g2NW5ibTd1bnRzZU1ZLzVnUTkraXptK3FZR0lpUGFXVGtMb05FTG5sZDlENDNPL2pMMTI1ZmdKeEs2TDJXb1YvVTZDYXFUaE5SMHRRME5EZGk0Tjc0bUlpSWlJaUdod1NUc2E2WmpkYXJXd1Z5VHNkbWxwQ2UzMmZrZkhFRDFjOHQyUnozcTNQZHJoQ01HaWgwUGFTRW9vdUFTRWwwcjlFV1kveVA3Z1U3K0gxNisraGovNnpLY3hQeitIbzZiZGJ0dHBkbVptOVRvSk1xclg2L2hUMy9mOU9IUDJIQzVlZWdSRXRERnAwekUzTzR0Zi83WC9EVjkrNFl1Mm5mcDJCcmVVWmVVN0tOUHJyNzFtNmxKR2JWMmFmQWZmL2V4N1VDcVg3VDZmNkNEOGt4LytuZXRtSnRNTHZkN25yLytyNTg1bEljcU82NTBEYldrWTZxOWx3TGVZYi9XRXVUalFYKzZhVmxjeWFPbVM4V3ZtWWwxRFA2NDFBbk84S2cwWHpwdHB2TGMxNlpmTi82Yld2VVdwZVVmamVxN1FkclNLMTc4N21scmxzeHBxRVhaNlVJNTA4V2MvY3Jubnp6VVJFUkVSRVJFTk5nWVlFUkgxRVlsY2tZQU5tUWFCYk9aVzIxcmNMcFU4dlZZS2FWMzhqdzRqWCtYbUFNU0JzcDk0dFNkUlE3SVcxNVRBdTBxYk5XczJOVHJzdHJHZkxQWTkzZVgxUU8xakM0TzR6VVJFUklQTTgzeFVxbFVvUjlsR3lNWHZjTmhwMjhadmk0c0xLSmZLdHFHYTJDck1WUnJGeTdRd1AyY0RqSFJ1ZnR0WHpvMGtTRUltMy9kdFdPRlc2eUlpb3UyVDhLSThYSWJPSXV5SHhPeS9rd01JbkZWYTJmTmJobjdUb0pGakhEa1cyazZIQVNJaUlpSWlJbnBRVVM3UTYrQmh2U2hDa2FSc1dnWUdJanFzSE5VdG41Q0JCZmZ5TzBSSGo1UjFGZlY2dEhQeVBZeWowTmE5ZHRwdDBGM3lleS83cThYRlJWUnJOWnhOejl2cnBVNlppQjRVaFJHV2x4YTNIVnkwa2VJNzJBbTcrNmlpWFFoUnY4ck1LVjN1SXRYbTV4VzBKUTg2MGhvSkRrSDdMRWZsYVFhVmFvVjVwVlhIN01IcTV0emVoMEtsMnc5SExjdGkzYVgxeWx5bDk2OUhROTh5cjhic3VnK1NxeVZ6VDd0K2pYemRoZ3JtdGpiY3ZKbW5UbHM3YXQzUG9jNlFnb2lJaUlpSWlJNE1sbVlURWZVUjZjZ3FGUitESWswVFUxbVRiYnBNRWJ3aEk4WDBPZ3FjZE9iVjdOQnlLQVdPeHR2TEVXN0ZPVjdvVkV5TmlVYTJCM0ZEZ2RJNDZXYzQ1bVVZY3ZuWk9lenNmcVhIZllUc2Q2VFJwVlFzWjFtR09FNEdyc09jN0dlbHJvd2orUkFSRVIyTVJ4NTlET2N2WE1UczVCUnV4TmZzQ05SeS9QR3AzLzh2R0I0ZXdhMmJOL0NPZDc0TDMvWGRmOUkyVnR1cXNlaWQyN2R3ODhaMS9OdGYrbC9zdk4xcDJYTS9VUjhhd3RlODkrdHc2ZEhITVR3eUNpSWkybnZoalMrajg5cnZJNWw1RS92aGp0bVh0MzBmKzBtWnFodzNyMkIyYWg0ZDdNL3pJTm92WlhPOEpKMERwVlBYeU1nSWlJaUlpSWlJYUdjYWpRYVdscGJ3MWE5OEJmdmg2WGM4QTZMRDdOYk5XeURhTFFrdmV2VFJSMDI5M2doT256NE4ycG1yVjEvRmYvcVB2NGxyYjd5QnVibFowRjBMQy9OMit1WC85Vi9idG1KLzkvbS9iK3VqejU0N0R5SjZrT3hQL3ZYLzhqRTBscGR0MjQ3ZGFqU1c3ZlQ3bHorSlYxOStDWC9xKzc0Zlo4NmVBMUcvK3RtUFhKNWMrZk1hYUV2Zi95OCsvSnlwZmI5Zy9wd3cwMEEzeWg3VjdoMUFOMzdtUjM3bmY5cG9tUi83WjgvVmd5cThQRTZHdGVQblAvTlhMdDhFRVJFUkVSRVIwVDVqZ0JFUkVlMHJDV1NTMEJDdE5landVSTVqUitCVGNEWmRaajFTMmw5MmMweTRLWlp6RjQxODl3RkdaVWZqcEplZzdtejlPWE1jWlNyM04rcFlxTzAvR1htQW84SWZIckwva1k1eTNBOFJFUkZSTCtRNFZocURYbmprRVpRcVpieCs5VlhFVVdUUGE2STR4TXpVSkY2dlZQRDcvK1V5amswY1E2VmFRN2xVdHZlcm1Pc2xhREUweThkUngzWW1tYnh6MjA3Tlp0TUdLOHJocHF4L1pHUVU0eFBIY2VyTVdkVHJReUFpb3YyUnR4Y1FUNytPTEdxQ2lJaUlpSWlJaUlpSWlJZ2VqbmE3aGVtcGFkeTZlUk56czdPSTQ5MkhqUnhXUlp2YnI3ejRaZFJxTlp3OGVjcUd4RHNjQUkvSUNzTVFTNHNMbUorYlE5anBtTy9NM3JiM1hWeGNsS1lkZGdETmpsbS90QVVoSXVvditVaWVZOU9SbHR5c2tyUmpOL2VUVGlzc3Q5bUlub2lJaUlpSWlBNEVBNHlJaUdoZnhYRmlSN1ZnR016aEloMnVYZGVEVXQwZ28vV1hlZkF3UTViMEhZMmF6dkZvT2NaYnNZOUdIR0MzeWtyalNiTytFVGZiY2xuSGNSR1VTaHZlbnVkWmQ0cGowT0VnalRuYTdRNlVvK0I3UFB3bElpS2l6WFdQZFYwODg2NnZ3Wk5QdmNPR0Qwa29rUTB3Q2lOY3Zmb2EzcngyRFgvMDZUL0VZNDgvZ1JNblQySnNmQnhCVU1MSlU2ZnNjck16TTVpZW5zTHJyNzJDaGZudUtKbjNQOGFGUng3RnhQRVRlUHZUSE5XYWlHZy9KZk0zRUw3K2FXU3RPUkFSRVJFUkVSRVJFUkVSMGNQUmFyYncrYzk5RnRmZWVoUFgzbndEdERFWk9GVDhwMC84SnNiR3h2RjE3LytBcldNdU1jQ0l5QXJERGw1NStTWGN2SEhkRGlhMTE2YW1KdTAwT3p1TjBiRXhCaGdSVWQvUnVUcW5GTUxObHZtWm4veVBSVnBrRzBSRVJFUkVSRVFIaEQyNGlZaG9YeVZKWWtlNmtFNjh2U3FWU25BOUQ4UDVHUHBaRWQ3akhzRktZUWtCVXM3RzRVV2lYTjY0d2s0Q2h5NEdNVkt0RU9VT2xqSUhvWGF3WGI1Wnp5Tm1QZU51WnNPTHltcnJvQ3cvS0dGNFpPUFBsb1RkeUpSbktZNGFHWVZHNis3VXp5clYycm9CV1J1UjkxUDJRL0pkWllBUkVSRVI5YXBTcmRyZ3kyZmU5YXc5bG5qeFMxODB4MHVwSFYxUDV4bmlPTWIwMUIwMG04dW8zSzdhMFM3cnI5ZVJtMk9wZHF0dHBxWU5MK3FFblh2V2UrN0NCZFRxUXphNHFGcXJnWWlJOWtjZXRaRE12STUwN2kza25TVWdIZVNnNGd5NVNzenZSeFhIZ21NZ0dpUlMxanM4UEd6S0Nzc2dJaUlpSWlJaUlpS2lvNm5WYW1GdWZnNVhybndGU3d1TG9ONjB6ZXZtZVI2dVhYc1RvNk5qT0hQMkxJaW9PMUNwN0ZlaU9NSis2blJDK3pqSGo0T0lEb0VjVHR0QnZxaWhjZ1VpSWlJaUlpSWkyZy9zd1UxRVJQdXFDRERLODk0RFVZSnlCWjVaM3ZOOTlEUFhjVzBuWmQ4UFFOdFRkaVRBeUh3MmNnY3RNOFhhUjloN3h0VXFUMms4V1k1UWMzS011cjJ0SUFoS2RxSUhKVW1NUE11UTVUdDRNdzZRaEJjNVR1K0JWMFdBa1cvMktiVmFGVVJFUkVTOWtOQkU4YzUzZlkwTlpIM3pqYXVJbzhnR0dNbjVUWjdIbUp5OGcrMDZmK0VTUmtmSDhmWjNQQU1pSXRvL09tb2l1dmxsSlBQWHV3RkdBMHliZjdtekVtQTB4QUFqR2l4QkVHQmtaTVFHR1JFUkVSRVJFUkVSRWRIUjFHNjNNRDgzaTVlKytsVlE3OXJ0dGgxbzhxMXJieUk5bHpEQWlHaEZsdVoydjdMZkFVWlJHTm9nTVNJNkhKUksyeHJPb2pMVjcyQ0NFUkVSRVJFUkVkRytZSUFSRVJIdHF5aUswR3cydHhWZzVFZ3drSmtrcEtTZktTVlQ3eUVxOUtEelFZeGpYb3J6dm8rRnpNWHJVWUNtRFRWeU43elBtSnZCTnpVSHo1UkRESHNaTHZnSlhIT1pkaysrYzY2RWNtbnBITm0vbE5wZXJaRUVHTWwrcUZ3dVkyeHNGRVJFUkVUYk1USTZadWZmKzJmK2E3UmJUVng3NDNXMDJpM016a3hqWVc0T2pjYnl1dmVUa1REbCtFUHVMOU1qano2R2FxMk9NK2N1b0JRd0JKV0lhTCtsclhtMHZ2cmJTS1pmeDM0YWJiZFJOZnY4VzBQRElDSWlJaUlpSWlJaUlpS2lCNzN5MGhYY3VuVUx0SDFwa3VDem4vbER2T3RkeitKZDcvNGFFQkVSMGM2bzNGbldqcHFFMGltWVlFUkVSRVJFUkVTMEx4aGdSRVJFK3lyUE0yUlp0cTM3T0E1RGdZNktxcVBObEtHVE8zQk1QY0ROUkNQY0lqbEh3b3ZLNW42bi9BUjFKMGZkN1QwY2l6WjNXTDk3RW1Bays2SHRCS2tSRVJFUkZZSlN5YzdQbnJ0Z3c0b2tHTkZiV0xDajdDMHRMbXg0UHptMjhud2ZsV29WSXlPak9IWG1uSjBQbTRublBFUkVCeUJMa0MxUElZLzJkMVRVc2puZjNHN1FMaEVSRVJFUkVSRVJFUkhSVWRKb05OQnU3Mjk1L1dHVkpBbm01K2ZRNlhSQVJFUkVPNmNjSFVNN0lUaHdNaEVSRVJFUkVkRytZWUFSRVZFZmtjNU8wcEZWd2paazZuZXU2OXBwUFZFVTJTbU9FeEJ0NVl5ZjRxU1g0dkZTaEZRckxHY3VNdk1WYU9tN242K0trNkhtNUNncGN3QWpJVWFzUEtCdGtnQWoyUzlKc05vZ2tkOEZwUmh5UUVSRTFBK0dob2J4OUR2ZmJZOG44aXhEWmdOYmN5U3hIR05vTEM4dDJYT2s4WW1KN3ZtZFBjZHo0WmpyZk0rY1Azayt3NHVJaVBhWlRtTWtzNjhqdXZWVmhHOSt6cHdNcGhoVWw0SU92bjlrR3Jremd0VEwwZkZERE82eklTSWlJaUlpSWlJaUlxS2o2c1V2djJBSGlxSHRrelp2ODNOeldGcGFSS2ZkaHUvN2RpQWRJaUlpSWlJaUlpSWlJcUord3dBaklxSStVZ1FZU1lYaklBUVl5Ylp1MVBsV25rT2FaZ1B4UE9qaGM1VTJFeERZU3hybVQrVG1vK090K2ZqWUFDT3puRzl1ZEJoZVJEc2crNk1zay8xU2pzR2k3TzhERVJFUjlZZFNxZlRBZFVrYzIzTWcxNXdmU1lEUjJOZzRpSWpvNElSaHVQcTNCQmpGU3d1SXdqWWlTVWVHYTA2clhPd1hVMUpoempOZHFIenZxMXRVN21ETVNaQTRLVktWSWxNNUE0eUlpSWlJaUlpSWlJaUlhT0IwQjhPTVFUdlRiWStiSWtsaTIyYVhBVVpFUkVUYmwrZE9ycHdCSGdGcExRY2w5cVlnSWlJaUlpS2lmc1FBSXlLaVBpSUJGYjRmbUVyR3hGWTQ5anZwbU90NTYvK1VTSVZ6bzdGc253dlJkZzI1M2MvL0NBWXRhSWI2bWV4WE81M095cjVyL3pxdjdoVnBiQ0svQzdLOU1oRVJFVkgvOG9OdUZPZng4aWtRRWRIQmUvbmxsN0MwdUdqL3p1TTIyaTk5RW5uVVJGSjlEL1piR0FmUTV0eXRzbndjZTYxY21VY3cranFVTnVWcktqVnpOa0VrSWlJaUlpSWlJaUlpSWpxSzJ1MFdidDY4aWVQSFQ1aDY2VEtJaUlob2UweDkrN3lwMjcrcDlLRVlOK2haRG8xTFJFUkVSRVJFL1lnQlJrUkVmYVlJckJnRWpuSTIzTjVjbTVMZE5CdUlJQ1lpT2lvMHNpeGIzVy9wUHUvNFdXem5vUHdtRUJFUkVSRVJIVFE1eDVPcHNieU14Y1VGZTUyT093Z1R4NVJKQmNpY1lleTMwUEVoWjVkT1dzSmVjek9Pb0V4RVJFUkVSRVJFUkVSRVJFUkVSTFJyR1ZMdDVxSFNUZzQyelNZaUlpSWlJaUxhRnd3d0lpTHFJeEpXRVFTQjdYaVZKT2g3cnVmQjk0TjF3elZTOHdRNm5ZNTlMa1JFL1NETGM3TmZDdUc2TGp5ei8wclR0SzlEakdRYlpWdUppSWlJaUlob2ZWTDIxR3cyOGZMTEwrSE83ZHRyYnFsMHA4b1lEa3E1aVQzbks1YXJFUkVSRVJFUkVSRVJFUkVSRVJFUjdWYnVwb3VPOWlhVjBybG1naEVSRVJFUkVSSFJ2bUNBRVJGUkg1RWdvQ0t3b2dnRjZzZHdEUWxhY2h6WHp1OFBMNUx0bFZDUU5NMXNlRkUvaDRNUTBkRWkrNk5pdjZSVWQvL1Y3d0ZHbnVkRHNZNk1pSWlJaUlob1hYbWVtektvaE9WUFJFVFVsV2RBWjhFVUJPWkFOZ0NqUkJEUndRbHFwaUxXQWNyRElDSWlJaUlpSWlJaUlpSWlJaUlpSWlJaW9yM0hBQ01pb2o1eU44RElzZUZBMGdtckgwbDRrZS83NndZWWRUdU9wWGFTb0JBaW9yNmhzUkpnaEhYM1gvMUd3b3VDSURCL01jR0lpSWlJaUlob1BYbWUyVElvQmhnUkVaRWx3VVd0V2ZNRGtRSnhHMFJFcTRaT21vb0Jqd0ZHUkVSRVJFUkVSRVJFUkVSRVJFUkVSRVJFKzRRQlJrUkVmVWhDSzhxbEVxSTR0cDJ3K291eTRVWGxjbm5kOEE4Sk1PcUVZUjl1TnhGUlZ4RzBKbHpYN2J1d05ka21DWXJyenZzL2FJbUlpSWlJaU9oaFNaSUU3WGE3YjBQQWlZaG9IelZuZ0tnQjNIN0J6RnZBOUV1bTRNK1U4MFZOMkFUem5IVVVSTFNHWHpaVm5BNVFIUWVDT2pCNndVeG5nUk5QbXN0VlV6bGJCaEVSVWIrclZDcTIvdmp4eHgvdmFmbkp5VW04ZnZVcWFQKzAyeTBzTFMxZ3FENkMrdEFRYUhEZHVYUFR0dEU0Y2VJMGlPNVhxOWZobWMvSE81OTVCcTduWVh4OEhLVlNDVVJFUkVRMFdKd3NqWjNjYWVlK3l4R1NpSWlJaUlpSWlQWUpBNHlJaVBxUU5Eanlnd0JKSDRZWFNaQ0czVDdmdC9QN3lZajNhWklnei9zckVJU0k2QzV0OTFXeVA1TkpPcnJLNVg2aGxBUFA4eGhlUkVSRVJFUkV0QVVKcEUzaUdKb0JSa1JFUjQrRUY3Vm1nY212QW8wcDRMVlBnb2hvUzZVaG9ESUtuSHN2a0xhQXNRdUF4NDdIUkVRMEdJSWdzSFhJSjA2ZTdHbjVSbVBaVHJSL2xoWVhNSG5uRm81Tm5KQldDS0RCZGV2R2RmaCtnRXFsQnFMN2ViNEhiZmJCc3YrVmRqd1NLQ2VCVjBSRVJFUTBXRHB1T1MwckZTdndCSTZJaUlpSWlJaG92ekRBaUlpb0QwbHdoVlJ5U3ljc3FmU09wU05XSDRScmVKNkxjcm15MmlocVBiTE56V2JMYkhPeTRYb2tMQ1JzTjlFSjIxaGFuQWRSWVhob3pJNVVOWGJzK0piTHltY25UV0lzTGZFelJIZlZaV1REK2hES2xScWNEUm9MeWY1SjlsTmpZNk9vVnF0WVhGem9pMzFzRWFoVUxwZFFxVlEzM004U0VSRlIvN2pSVExFWTVYaGpPVUVuNjRabnVJN0NzWktEbXUvZ1JNWERhT0Jnck1UZmRTS2kvUkJGRVphWGw1Rm1kNE8wZ3p6RTI4SVg0T1VKNm5tanAvWEVLa0RicldQYVA0Y1pNNjFWemx0NGIvTy9iTG1PejU0NWk4U2N4elZMSlRocEFEK3V3NHZxNXUveTZqS1ozMGJ1cEFpSEo5R0xkbWtKUkVTMFFnWk5TRHZBNUJYZ3ltOENVMWU2d1VWcGJIYXdNWWlJZWhLM3VsTnJEbmpkSE9QOTBjZUFDKzhEeGk0Qjcvb3p3RkJ2Z1JCRVJFUVBnN1Fsa3FsVTZpMTg3MmE1akZhckNkby9ZUlFpTStjcWNSenh0UjV3OGo2cUxPSDdTT3VxRDlYaHVnN0d4OGZ0WlE1R1JrUkVSRFNZd3Q4WnV4WCt3RmNueDVmUHhvY2x3ZWcvL0t2bnpxVXRoSC9xUnkvUGdvaUlpSWlJaUtnUE1NQ0lpS2dQRlNFV1NqbDlWZUV0MnlLQkdzWDJiVVNDUUxZS0E4bk43UkoybENZSmlBcHBsa0E1dlgzbWMvUDV5Zmtab3Z0a1dXcjNMNXZ0ZzRwOVZMRlA2eWZGL3JYWTF4SVJFVkYveTNLTjJFenRMRWN6NlI1L3VFcWo0aXA0amtaaWJzdjdJQ2lSaU9pd2tuTTdDY3ErL3h5d2xJZndkR3pEaDNxaFZJWk1lZVkrNmJxMzk3SWU1VVJtY3BDNzVud3VkNkZWL3NDd2pkcjhSc0JNdWR0YldZWjJXZVpCUkhRUDJkOG5iYUE5WjZaNW9NVzIyRVMwVGJvYlBtejNKVEtKbHRtZlZNWk1KVlVJSWlLaWZsYlVIL2Rhanl4TDljTkFQb2Vhdkw2NnQzWlMxT2MwVnQ5TG92c1YzM0VPUkVaRVJFUTAyUDdjeHorZTRlUElmdWZueitLd1VFblpjNE9RZlVPSmlJaUlpSWlvYi9Ba2xZaW9qMVdyVlZRcUZTd3VMdGpPV01sRENtcVJ4ay9sY2dWQkVOaHQyb3lFRWpXYlRlUkZBK0IxYUhOYnM3RnNSeUFqSXRwTGNSVFovVXRRS3NIZDRGQTNUbUtrYVlxeHNUSDR2bytSa1ZHN1gxcGNYTVRESW9GMU1sSm12VjYzRFo3WTZJbUlpS2cvM1c2bCtNM3JiYnl4bk9DejB4SENWQ1Bkb2pINzZhcHJKZzgvOEZnZDUrc2VIaG55NERzTUtpUWkyaThPTW95bE0vRHp5TXluZTdwUDZGU3hySTlod1R2K3dHMnV6bkFpdnJIbE9oeC95Q3pzSWluSHlKMEVUaGJBZGJKN0gwZTc1bmNEZUN1dncxTXhLbDZJa2hPaDVNYnJyalAxZXd0Z29tNlpwR2kzMjdZY3RkVnEyWE4vS1U4dFFxN2t0bUs1N1pDeVVUbGZMMGdacVV4eUh1K2E5N3hjTHR1NWxERVEwVDZKR3NEMFM4RHYvTTltWjdvRUxFK0NpR2pQWFB2RDdqVDNKbENiQUw3MWI1bEsybEVRRVJFUkVSRVJFUkVSRWZVekwwMHZtYXB3YVFEUHlqTWlJaUlpSWlMcUN3d3dJaUlhQUs3cndYRnkyK2xHSE9Sb1R4S2lJWjEwUE0rekhYRTJJeDJBOHJ5M1VjVXk4MXowRGpvTUVSRnRSdWQ1ZC8reXhXNUk5bFBTZ1ZIMld6SkFwUVFJeVg1T3JzOGV3cjZwMk1mSy9yYlhFVE9KaUlqb1lHUXlxcXFadjdxWVlLYVQyUkNqdVRCREp1YysyUHJjSnpMTE5aTGNoaDQxemJ4aVRxdXFub05qWlJkRVJMUTdVbFlXaGgxN2ZyZVcwamtjNUQydG8zc2U1c0JkS1FOYmorZDE5OW5kYzhsN3k3NFNVODJTUXlGT1NnaHpEOHZKTVB5a1lyYXRDcFg3OTFUQ0pPWnlZclpzSnB5QTU2UUlraGlCRTVrcGdhc3lPQ3EzMXl2eisrS2I2MEtIWldmM0s4N25aWjdhOC8rNzUvZnlkeGlHOW5JVVJmYTZibmxsdmpwSytrNFY1YkpDUGlkclIxMlg5Y3QxRW1Ba2N6bS9MOEtKR1ZKTXRFY1czZ0tXN2dCeDIreE1PVEFDRWUyVHpsSjMzcHcwaFFFaE1IUUtSRVJFUkVSRVJFUkVSRVJFUkVSRVJFUkUxQnNHR0JFUjliRWl5R0pvYU1oZWxvNHlSWWVjZzFJcWxXMG5tN1dqaks5SE91ekVjV3luK3p1TjNVOXU3M1JhQnhyRVJFUkhRNUxHU0RPenI5eGtQNmxYd2dhU0pMSDdyRktwdExLZjZ3YkZOWnROSEJUcEpDdVBQVEl5c2hvV1IwUkVSUDJsazJrYmp2Z1B2ckNBZHByalZtdDc1MlB6WVc2bjE1WVNlL2tuM3ptQzB6VVhIenBiQlJFUjdZNmN2MDFPVGlJeDUzWUZDZi94ZEF4SHB6MnR3M05kK0s1bnpnMEQrL2Y5SEVkaHhKU0w1U3VCdDVGNXJDaE9WbStmYzRhUndjRjg0emlXbkNwZVNpNmdrZ1FZaVN1NGhBZ1YzTjJPcFdRRVRlM2g5NXVQckY0bndVVXlEZmtObE4wSTQ4R2NEVEk2WHByRmNEWmpsbmdGZEZjUlRpUkJSYTFXeTg3bC9GNnUyNnBNY3Fla0RMUFQ2YXhlWHZ0M29RZ3drdkNpYXJXS2NybHNKL2s3Q0FJUTBTNTkvcGVBMWl5d2VBTkVSUHRtOHNYdS9Nd3p3TWhaNEpudkJ4RVJFUkVSRVJFUkVSRVJFUkVSRVJFUkVmV0dQYVNKaUl3b2swNnBRT1hCUGtySTRTSnhTb2k4WVdTWmo3MlNPWUZkOTNaSXB4ZmJVU3FLVmtjWDN5L2RFY01kMjhGbW85SG4xeXBHUGQ5cW00clJ5WGM3NmprUjBYcTZ1eFhaditSMkg3UFova3YyVjdMZmtnQWo0YnFlM2U4VisxcTViYi8yVTBWQW5ZVEVGWDlMa0ZHdk1zZER4eDNHWGtuZEVoTFhQRysxOGVsQlpsNktScXJ0bklpSTZDajU2bnlNVnBKaktUYkhEbnR3YlBEeVVveUYyTVd6NHlVRXJzSlEwUHN4QUJFUmJVMlpmWFdnUXpqNmJ1Q2NuSE81cmdNNVEzUWN0eHNnYTg3QjdGeENpOXdhbHB3aDVFN3B3ZlhKdVpzcEo1TWczQ3ozY0FQSDhLcXVZUTVEYUtPRVJhZG1ibEc0a2wxQ3FEM01oc2N3bkN0VXBPd095WmJiS3o4dE9SeUVXUW01TnI4SmVoU08wa2h5SCtlYzNrS1lEcXZpbkx3SVRKZmdJSm5MNVNLMFNPWnlEdit3eXhtTHNscVpTNmhTc1oyeWpWTE9LcE9jOTFjcUZidjhkc29BaUk2MDlvTDVncG45K2NKMXN6Tm9nNGpvUU15OUFTU2hLUlEzeDNLbXpnRE85dXB6aVlpSWpvcnVnR2hidHlkNldMU2NwNXU1bkpzZk5kTHVRY3JDcFB6QmRmdjNXQ1kxWlRwWkQyM05IallwZTVKdHpQdWdESXIyajN4ZkhQTjk0Y0JqUkVSRVJJZWZPYXB2bS84MVRUVi9IVVJFUkVSRVJFUzBwMWpUUWtTRWJuaFJJMTAvd0VoQ0hTSlROdG5VR1Z5OWQ1MkdZcmVPekMzMXRHelJvYVZlSDdLQkd0SnhTanJueEd0R2w5ODczU0NOY3JsaUsrUWx5S01YMGo0ampoTzdYWnN1SncyRThtNjRDQkhSM2xzSlNKUDlqTm5mS05sL2JoQmlKUHRUMlcvVmF0M0xFdGdtamM2a0FaL3NYenVkOXI2RkdNbGp5TDU5ZUxnYlFyVGRqb3V4VTBXamZCcDdSWUtMTXNkSDZteTh6dy9OYm5zMjdvYitFUkVSSFNXLzhXWUxjMUdPNmM3ZS9BaisxbzBPanBVY2ZNUEpDdXErd3BQbUdJU0lpUGFPTXVlRnRheXhldGwyMURLVDczczJyS2dVbE9DWTg4UnF1VnN1SitWZmFUNXF5Z2RQSU1scmtpWjBEMGM1cUZXcXE1ZXZlay9obDUyMzR3dTRoQnRxNHU2Q1JaRllCSnhTYll5NVMrWmN5NXhFYlhHNkp3SG41aFRXbkgvVzBUS1hGekMyZXRzeGZiU3JjSW9BOUVhalljL1hwNmFtVnNPSSsxR3hYVkkrMm1xMTdOOUZZUEhZMkppZG56eDVjdHNoeGtSSDJ1SjE4K1V5TzlaYlh3QVIwWUY1NDFQQXNDbC8vNGIvcy9reE41WEhRUlZFUkVUMG9KcXBhQTlLdmJWN2VoZ1NVK2N2NVFwSE1jQklncVZXMjMydGhDbjNvMDY3dmRvdW81OURqR1Q3MGpTeDI4c0FvOFBMOXdQN25ha1BEWUdJaUlpSURyMEZLRWpyY1FZWUVSRVJFUkVSRWUweEJoZ1JFUm1CQTVRMkdIQXFjd0tFeWtHaVNuQ3dkNDBsSkNRaWQxeG90YjNSeUNUMFFocVhCRUVKcFZLNk9zcjQzWkNON1RlVXNDTUlyWXk2SlpYeDhyY2ZCTFp6VisrMGJheVI1NXQzNmsyU3VHODdHUkhSNFpGbWlkM2ZCS1V5TnRyTHl2NUs5bHRyRzVnVkhRaExwY0NPU0pna3FWMHVYbW5jS1B2Ym5TajJzZExZeWU1anpiNVdPaXdxdGJNUktSTzNpcVhTS2V3WkpiOXdqZzN0MjRodk5uWElSN2RqTFVPTWlJam9DSGgxS1VZN3lmRm1NOEY4dExjTjU4Tk00OWZmYk9IeEVSOVBqakxBaUlob0w4V21ETzh6UTkrNWVsbkNpdVRFVU03RjVCek1Xd202ZGROdVlhQ1RLNFRheDZLdW9ZVUhRMTFEK1BqMStHdFhMMC9xRVZ6MEhkUXdqelphNjI1REdSbkduQmlqdURkOGZFS0ZHRll1dnM5N0M3MTRtenVEbzhTT1pHOG02VmdZaHFHZHBCeFI1djBjWExTWm9peEJRcGprTXlobHVWSStJSjA4ZmQrM1ljb3l5WFZFdEk3Ylh6WTc5aGFJaUE2VUJLZEZUZURtNTRIS09IRG1YU0FpSXFJSHlTQnNsV3IvaHVPRW5ZNHRUNWlmbjhOUkkyVVFwVkxKRGxyWDEyRXN1dHVPckNnVElpSWlJaUlpT2dpbUNuY2VDbVVGWEFRUkVSRVJFUkVSN1NrR0dCRVJHYTdxQmpPc0oxZG1WMm1tekNtakgwaEhxOEFQb0QxdE83a1UxeFdOT1hZeTBsTXg2cmNFYWtnREZnblkyRW13aGp4K2xtM2VvQ1RMTTdNY0E0eUlhSC9aL1pIWjM4ZytjYU45V1o3cmRSdkJGYUZ1bnVlYmVXejJhNmxabDluSFp0bXU5clBka0RqZlR0MTFieWNrN2w2WjQ1dHBCQWRKZmlzclpwT2JPOHRjSWlJaUdqaHpuUXh6VVk3WlRvN0ZlTzhEakw0MEh5RURSK29sSXRwcmlWUENtNVYzYkwxZ3NRdmVJcUJWd28yK2xGMjY1N3BqcnBsc2VOSDJRalhxU3NyRVVveTdVVS9MbjNlWGNOUVVBVWJ0ZGh2Tlp0UCt2ZE13NFg0aXowTjBPaDFiTGlCbEMxSU8yeTEvOEJoZ1JMU1I1VHZtaTdNSUlxSURKZldZU1FkWXVONE5Nd0lEaklpSWlOWWpnYnlWU2hYOTdEQ1VLZXlFdEUrUWdlc0NVL2JReis5UnA5MHhaU01zRXlFaUlpSWlvb09sb052UXFnbTJoeVlpSWlJaUlpTGFjd3d3SWlJYVlOTEJSVWJMRXRMcFJTWVptVXFrYWJaeS9ZTWRiWXNPTWE3cnJZWnFGSUZGTyswc0k0L2RibmNHY2lSMElqcWFraVF4KzYxdTU4aU45bjFGSjBJSkhKTGVyY1crVmZaMXN0L0w4NDBiUEVxSFJMTm5oV1B1N3ppeWozWE11aVMwYVBzQmNVUkVSSFR3UGo4YjRmWGxGTTEwNzBPR2NyUEt1VEREN1ZhS0Y4empuS3E2Wm1JeEhSSFJkcldhVFV4T1RpS0pZOUJna282RWNuNjl1TGlJMkx5UEVsb2s1OXh5dmN6WEN4N2VUQkVXWElTMFMyZEt1VTdPN1lzeTBHSXV0MjJrT08rWHNnUFJEVzd2YmxPeGZiSzl4ZlhiQ1R1Vyt5OHZMOXZ0V2xoWVFLMVdzOXM3UER5OEdueE1SQ3Vtcm5SRGpJaUlEcHFFR04zNEFqRHhPUERrZDRLSWlJZ2VGTVVoM0U3L2hzOGNsbERrbmJCbEdxYmN3alZsRDUxT0cvMHFUdUtWY2hVTWxERHNyTHpHdllXVUgyYjFvZUVOUTZpa25ZMlV6eFh1YlYrajdobjBLODI2WlhIZVNsdEdJWmVsSEUzYTJheDlERnR1Wi81bDY3UlJsTUN1U3JXS3FwbHNHYUE4aHZsOGhWR0kxSlR6TFM4dDJzL2NVZDAzRUJFUkVkSGhvL1A4Y1FWUEt0TmVBQkVSRVJFUkVWRWZZTThvSXFJQlZWVFdyNjNvNzlJckRUdlVTcWlSODhCOXBXSmY3aThOQmJyejNmOGN5R05KNWY1Mk94VVJFVDBzc3M5YTJ5QnFQY1h0UmNDUjQzUTdKY3ErMDFUNklNMDJEaUt5QVVhMlk2UzNHaEpIUkVSRWcyTXh5akhkMlo4R3pITEtGcHRUcDA2bXNXVCtHQzA1SUNLaTdaUE9LbEVZZ2dhYmxDZEtHRkJvM3N0MnUyMHY2eDMyWEN2T3Y2VzhVODdMSlJpb0NDK1M2NG93bzdYQjhPdVI0Q0xaQnVuczJBMHd6dTNuVGE2WCs4cThDSExmYm9lbnRjRklRdFluMTBtUTBWNlUweElkS3AzRjdrUkVkTkF5ODF2ZFdRQ2lCb2lJaUdoOWVaYjNkUWpJVVc3RFZBeUNWd1F2OTZ0QmZYOWt1M1B6dXE0dDM2RUhPU3RsY3V1UjhydTE3WFZ5M1MwUExJTEhoYlRKeVoxdWVOSGE5UlRMcnZmSmRqM1hsZ2RLa0pGbnlnYnRZMGdiSDBjaGtuV1o5YkJ0SXhFUkVSRWRKc3B4NmptY0NvaUlpSWlJaUlqNkJGdENFOUdoTVZyeThZNEpGNWVyMngraCtvMTJ0MUw3L1dPREh5NFJCQ1U3bDhyNGZsU3QxcEVrTVlpSTlsT3BWTEg3bTcxV05JbzZTaDBLTXcxRU9UQm5kdDF2dGtDMGI3NzZsUmR0cCtYRFFrWjg3SFE2V0ZwYTZ2ayt6VVlEZDNEYmR0cVdVU0VIbWJ5WDBxRjd0NDJpMTNZMjM2aUI2LzNrOWR1THh0aEJFS3gyY21jSTNmNGFHaDYycjdNMEp1NG5OMXNaWGx2YTM4Ym5uVlRqVmZNWWRkL0JwU0VRRWRFdURYa1p5aXJHMC9yTmJkMnZxY3VZMVVOWTFGVXM2ZHJkOWFrUVpaajF1VGNmdU0vMWZBVHpadm5memg1SFc5OWJIbWxLdnpDaElqT0ZxS3U3STRFdjZzQ3N6Y0dWZkJTOWVDYUw4SU00bkpyTnBqMWV2SEhqeGdPQlByMlFZd2M1VnF2WDZ6YUlTT1p5dVZMWm03YVpFbjRrNUpod0s3THRjdnk1dkx4c241TThOd2srNnZYOHB0VnEyV2xoWWNFZWQ1NDRjY0llKzU0OGVSSkVSMTdjWW5nSUVUMGMycFF0TGQwQ2FoTWdJaUtpOWQyNmRSUFVuNlI4WW41K0RrUVBVNmtVbUhLN3UyVjFhOXNMS3VYYzArNG1OUFhxRWl3a1pYdHFKZGdveTFKb2M3MlV6eFh0SVlYVXdVdTRVYkttN0sxaTZ0WkhSOGZzdkZxdDNic2hwcnl0VnF2YjYwZEdSakUzTzJPbjNZU29FeEVSRVJIMUQyZFVhYzNSUUlpSWlJaUlpS2h2TU1DSWlBNE42VklzL1lwMzByZTRsY3Fra2V2dW5SMzJUOTUzcTZNbHNTRUFFZTBoQmt6c3ZUZ0hHdVkzTXVJZ2RMVFBvamhHSEVVNExMVE9iVWZtN1l6Z0tLTkZTdkJSbWlhMncvTWdLenB4WjVrOC81MGY3OWtSVEtYeHFKblNOYU53OXZMWXV5Vy9LZkxZems1UE1xaG45WldSZ1B0RkxxTzJIdERteU9Na3ViYVBTVVJFdStmb0RBNXlsTlgyd25CaXVQRHNmZS9kSDh1Nk5scGZGUkVTNVNBeGQwbE5tV0tLdThjcWdibVBYTTd2TzRhUXNzZmNsR0tHdXJkZ3hoU0g1eGlrK0syM282T3ZqRkF2bmVuME5vNERIRHZpdXJNNlFydDBjaXFDTHVXNmgxVW1VRHgyc1UwU2ZsUjBnQ3FtWG81UGk5ZWhlRjNrTlNxZWMvRTRSRVJFZElCeVU0R3NXVEJPUkVSRVJOVHZpcks1WHNyUGltVzNVNDlQUkVSRVJJZUwxaW8yVmZFeGExK0ppSWlJaUlpSTloNERqSWpvMFBCZFpTWVh3UTdTaHo2ekFIeHBHZmo2OFc0UVVxVzNQa1MwUTlJUUlDaVZiY2VkTk9sdEpISWlvbDQ0NW5mQTgvelZ6bjIwZTNPeHhxL2VCbTZIREZhZy9YWDF0VmZSYkRSd2xMVmJiVHZOek15QTZDaDU5bXZlZzVJNVAzaGdSTlNIWkNIS01XZW1UcnIvRFpmalRPUE41UlNQRC9zZ0lxTGRxK3NHUnRIRysvM1h0blcveVh3VXI4Q1VVK1V1Rm5UOTd2cFVCNlBLck05N2NIM3ZYNmxkK1dqeUR0elVKVnpMeDFadk8yWHU4M1ozeVd4UGd1RTE0VWZMOE5IVUhqNmRuVUF2dk94d0RaUW9uWUptWjJmUmJEYnRKRUU5MnpFMk5tYkRnY2JIeDIxb2tZeSszZytLSUtWUzZlNUk4TjB3ejh3K1R3a25sZWRkWExlUkl1eEl6Z2VrL0hScGFjbU9Pbi8yN0ZuN2ZHVWlJaUtpQTVLYjMrem10Q213bXdjUkVSRVJFZlUzM3c4d1BESzZhWUNSM0NibGEyVlQzaWJMTmh2TEF6K29FQkVSRVJIdGtJT3JEakN2Z1c4SEVSRVJFUkVSRWUwcEJoZ1JFUm54U3IvVU4xb2FVbzk5cVdJcXJNMjh6RDRoKzBZNkc0azBBUkhSbm5FYzErNWZsR0tBMFc0azVuZFI0b3J1aEJwVEViQVFhelMzMTYrVWlJaG9ZTWs1b1p3UGNwUXRJcUwrSlNFdkVnU3pWNk5reTFwQzdTUFYyeitYUEtVYThKenNuZ0FqdWt2ZUszbWZKS3dvam1PRVlXai9sdXUzVW9UMlNEaVFCQldYeStYVnZ3Y2h1Rmkyc1FoYXFsYXI5bldRVGxFeVQ1S3RDMFhsTXk3THRkdHRXOVloNnluV1NVUkVSRVJFUkVSRTFNK2tEQ3pMN2pZMFdSdnM3VGhTdm50M1dSdnNMY3ZuR1pUdWx2bm1XVzdXb2UxODdYcHl1YVBlZ3dHNFdCRklSRVJFZEdTcFRHZHdWTXBqUWlJaUlpSWlJcUs5eHdBaklpSmpQdTdPZi80dGpiclpNLzdnV1lVeEh6aGJBZTBEQ1JnWkhobEh1OTFFRkhaQVJMUlh5dVVLaG9aSGJZZEcycm5sRk1nMDhFczN6ZCtKeHBVR2lJaUlqZ3pmVWFoNnlweTNzSlVLRVZHL0trSmRKQkJuTDdSMUNaTjZGRTJVc1YwL0dMeUlwZzV3T1gwVTlLQWl0R2Q1ZVJrek16TTJ2S2pYNEttaG9TRWIvSFBzMkxIVk1LTkJVV3pyeU1pSW5ZK09qdHI1M055Y2ZUMWtYb1E3clVkdWs4KzNUUEpaSHg0ZXR1dXExV29NTUNJaUlpSWlJaUlpb3I0bjVWcHJ5NzRraUtpZ2xJSmFVdytYcFZtM3JLelRzYmNKRzJoa3loSWpuU05kRzRTMHN1eGFqcmxQcjJWbWp1b0doSnVhUUJBUkVSSFJFZVZBaGozM3UwTzlFaEVSRVJFUkVkRmVZczl1SXFJMUZtS2daZXE3ZjNkR28ycnF0TWNEb0d6cXFzdGIxRy9MZlZvWmpneFhkYWU2ZVYyOG9pN2ZQSDhuRGVEbENXcGIzRjhhR2dSQnlYWllLcFVxU0xQRU5qZ2dJdG9weDNYaGV3R0NVdG51WDVTemRVT2pxY1JETy9QeGhUdW1Dc281L0pWUVErYkkzMVBkL2ZaR2NReVIyWmVuNXFXWWk3c0JSamM3R2xGdi9VcUpkc3gyWU00ZWJHUklSUFN3bEtUQnRPL1ljNTc5NXBuSE9tWk9PcXNlRzBrVEVXMkhqTllkaGgxN0xQbXd2ZDJaUmd3WG84cHNqM2JRUkFsU2xGZzJoV1V1anZZSlZSaUdObXhxY1hIUi9wMXRjZHd2SFlkODN6ZmxoU1U3U1hoUkVBVGREa1Zxc0lNRmkrMlhBS0p5dVd5Zms3dzJFbWJVNld6K1daYU9Ydkw2RllGSGNyOTZ2VDd3cndrUkVSRVJFUkVSRVIxZU12Q1lsTzBWMXBaL3Fmc0NoeEx6VDhxOVpQbWl6RXNDajNKVEh1WjdQanovYmxQM1dNZTJuTXdVa2EyUzVkSTBzWU1xT2x1MEY1SXdwQ2d5WlpYNUVXcnNTVVJFUkVSRVJFUkVSRVJFZEVBWVlFUkV0TWJpU3NYMkoyZTA3YXdxd1VXalBqRG1iOTRaWkRyU1pzS1I0WnQ2L3NCTXAwcEFaYVZYcjY4VjNwWUZxR3IwRm1CVUt0dE9TNlZ5QlFqQkFDTWkyaFhQOGV6K3BDUUJSbWJxeFdUcVlrb0grTXh0MlEwZC91Q1VVMlhaWndOVlIyR2pQbzdMaVVhWTN3MHdJam9JYVpMWXhvbzY1NGVPaVBwRFlNNXhaSElQSUJSQXpxMk9tUlBQaXNjQUFpS2k3Y2l5MUFhNlNLZVVoKzFwZDlyT1IxVm96aTA5TkhYSkJoZDFBNHlPTm5tUFpKcWJtMXNOMzltTWRGcVNjSi9oNFdHTWpJellUazZPY3poQy9vcm5JUUZHOGxySVhGNmI1ZVZsVzBhNldZQ1JMQzhoUnpKMU8yY2xOdHlwMTFIbGlZaUlpSWlJaUlpSURsbzN3S2kwZW5sdEdMZFNqcjI5SUdGRnRqMmhINndPV0NabHdCSTJKT0ZGYTllVG1XWDFmZVdNZWQ0dFg1TlZibFdlS0cwVUpWUmNCbGtpSWlJaUlpSWlJaUlpSWlLaXZjVUFJeUtpRFVnZit0RFVVeStZZVR2ZHZFTjk1NGpWWjJlNWVXM01TeklWQWI3cXZqYXVtVVdvNGhRVUx2YllyMGdhRjR5TWphUGRiTUwxWElTZDlwWWRtZTducjJtZ1FIZEpZd3c3T3IzNWh3RWFqVjBDYUZ5M3Q4T1RvRlNDNHpxbzFZY3hNTFNHL0xOQkhacEJIZXRKazNoYnI0MDBZS3BVYXlpVktxZ1BqOEJ6L1o3dk82OUx1SjdYa09Gb0JBWklTRjh6a2JBbnZlRXpqdk51Y05IMjlzUkV1OU5vTkxDMHZMVHRZd0Fpb3YxMmFjaERLOG54K25LS2RKK08zZXErd3BPalBpYktEQ0FnSXRvTDg3cU90am5YKy9YNGE3ZDF2Nll1WTFZUElibXZ5bVE3Ni91Z08ydk9wWlJaZmg0MXBKaHdJdFJ4YjhEU2hBb3hyRng4bi9jV2V2RTJkd2FEcU5WcTJYUDdxYWtwZTV5ZmJkSVpTTXF3WkJvYkc3TWpyRXN3ajh5bEE1UGFwekt0ZHB6YXN0K3NoM09Ra1VxQXZTYlBTNTV6eVpSdFNWQ1Q3L3MybEdoeGNkR1dHY1Z4dk9GOUpjUklicGR5UDVrbUppWkFSRVJFUkVSRVJFUjBsRWtnMGZ6Y0hPcERRNmpWNnJiczdmNnlSUWxFaXNMSVRDRVNVNzdHOWdsRVJFUkVkRGprVDVralg0NGtUa1JFUkVSRVJIMkRBVVpFUkJ1UTdxa1M0dERPdWhQZFphdnZ6V3ZUWEZQVWFhcjlrYW9TSEpYS2haNjRub2VLbVdSRW96eFBFY3ZvUnR0c0hPQjV2WWVWSENYU0VFTTZlMGxqREJtMWFsRDRmZ0NueDlIakhmUFprUU9aY3JtQ1FhRjFianZ3S2NXR01CdVJBS1B0a005NHFWUzJuNE5LcGJhdCt6YTFoM21Vamt5QVVWajhsdkUzamZwTXU5TkdZM25aam9wSVJOUlBSZ01IcDZvZXJqVmxoRmZzQzg4Y3k4aGpTSkFSRVJIdFhrZVgwREhuZVF0WkhYdGhPK3Q3bTlQY2NwbTZsSnNoeGJnYm9SZm4zU1VNb25pbEExQ3p1ZlZySXVmMUVzUXpQRHk4R21DMDN4SlQ2Q3ZoUlVrdkFVYllIL0s4SmFTcG1DVGtLUXhETzIwV1lGVGNKaUZSVXY3SEFDTWlJaUlpSWlJaUlqcnFzalJGdTkyeWcrSFZObWc2cEhOdHl0WWlHeVMrV2VBNkVSRVJFZEZnVWFjME1Ba2lJaUlpSWlLaVBzRUFJeUlpMmhNeXd2eXk5akdOQ3E3a296aXVRanYxb2xLdG8xeXBZdXpZQ1J2dXNoMzdOUkw3WVdERGk3cC9ZV0JzNC8wc0JXVWd3TFpEYXg0dWJjUFJ1aC96N1gzV2o0cnQ3Z05FZCtTMDNvTzZablRaVGxPNll2ZGIrUkVKTUNJaUlxTHQrZUNwQ3A0ZXkvQ1YrUWhSdHJmSGJvR2o4TVNvanlkR2ZEd3k1TUhsNFFnUkVSMENFbGdrSFlCdTM3Nk5OTjE4a01keXVXeURpeTVldkdndmwwcWxQU25uYThjWjBqekhUS09ES05Wb1JqSENORWVVWkdhZW1USUFqU0szcUpjeUNOZnRscSs1cHV5aDVEb29CeTZxdnBrQ0g4ZHFKUVRtT1F5VlBUaTcySGJmOSsxMC92eDV1MDIzYnQyeW5hZ1dGeGMzdk0vU1VqZmNTc0tQNUxWa2tCRVJFUkVSRVJFUkVmV1QySlRMU1doUVlXMW9rSlFESnM3ZGRqNkpLVXVVUWVIUXVkc1dVTXJKTWxPZUYrdll6bGZYdTg3QWFCS21Ib1VoWnFlbnNEQS9oM3A5eUpZOVNuc2lXVThZZHJvQjRwMk9IV2lSaUlpSWlJNDJyVlRUeWJXajJWNkxpSWlJaUlpSWFNOHh3SWlJaVBhTWhJQkkvNThFRHJKdEJJSTR0a0ZDNytFalJNSngrSm1oblpIOWsreW5Vak14dklpSWlJZzI0cnRBemQrL1kwNEpNWkxKZDNnOFFrUkVoNGQwRnBMd29xMENqS1Fqa3BUdEJFRmdMKzlWT1k5MFNKSmNva1JHVkU4ekcxN1VTVktFU1dibUdmTHRCaWV2UEEzZk5lV2RubU56d2wyejdiNmJJek9Qa1R1N0R6a3NPbVZKR0pHUXpsVmJ5VmRTbUhwNXJZbUlpSWlJaUlpSWlBNWFkNEMzdTJWbjk0ZUozM3RidmxLdXQrYTYvTzUxbTkxMzdXVUpLWksvMHlSWnZkNWVOdVZuY2h2TDBZaUlpSWhJS0luYXROMWUyR2FMaUlpSWlJaUlhSzh4d0lpSWlQYlV2QzdoRStrWmZMMDdnekUzTmo4ME9WenN2aU1QRWRGdWRRUFdYTHlTRCtNejJYSHpOeXVlaUlpSWFHTlBqbllERmI3clFoV0xjWTdmZkt1TnZWRDFIQnl2T1BpYjd4NUZ4ZVh4Q0JIUlhqcnJ6S0ZzenZiT09mUGJ1dCs4cnVONlBvRVFQaUx0OTdRKzZlb2lvYml2NTZNMkpQZmZKZTlldlcxY1JiaWdXcWlhcFFLVnIxNi9xQVBFWnRrcjVqNWIrY2JzRGFSSmhFSFFicmZSNlhRd096dUxack81NmJLMVdnM2xjaG1uVHAyeTg1MlNJS0kwMTVocGROQ0lVbHlmYjlxQW9sYjhZQ2NreDNYZ21pbW9CSEFrUUxEc1E1bTVYTGVWZGlPMHZhMnlQTGRoU0UyNWZCL1BjZUI3Q2hmRzZxajZycDFMNEZIZzdTeVU2Zno1OHphZ2FHaG9DR0VZWW5KeWNzTmw1K2JtNFB1K1hhNWVyMk5pWWdKRVJFUkVSRVJFUkxSL3lxV3lEY1VwN2FKczY3QlFhdVB5cnpnS3pZUnRTZUw0d2VzUzlFemVGd2txV2xwYUJCRVJFUkhSaGpTdW1QL3pnSjZJaUlpSWlJaG9IekRBaUlpSTlweDB5MnBvSDVONUdhTXF4b2phUmtzQ0lxSjlFbXNIVTdwczkwK3luMkswR3RIZ0dob2V0blBmODlHdlpKVElOTXVRcGFudDBOMEx6L05zNTJQUFRQMzgzSHFSbStjdm5hNGhvMXBpNXh5bG9PemsySGt2c2l5MUhkcDN5ekdQNlRpOVB5N3RYS2xVaHV1NjZGY25xeTVHQWdmakpRZXArV3d0eHp2N2ZEbXFPMjdYaGJxSDgyYVM4S0l5QTR5SWlIWkVqak1rc09YK0ViTURwQ2hEeXFLMkZ6cVhhTmRVbG1Sd2NPL3ZrVy9XVjVMNFc5VXh0eXAwWkZsemJDRDliaUp6V1lKeHA4eGZjazhKSnlwNGNpeG9kdno1ZmJ2NVZDdXp4bnVYM2NoRXRvU1J2SWwrVm5RSWl1TjQzZmRqTFRtbUNvSUFsVXJGL1BhWDdISFdkbVc1dGxPWXBEYThTQUtMNWp2bXNlTU1pZmxNeUcxcVpiMSt5WU95djczS0JoaDVacEs1QkJmWjIrejFXLzhPbHlxQkhOTGE0L3M4TSs5cjRuWkhibC9aRnJsUjZXNFpRenRPN1hXenpSQWwzMFhKYzdwQlJtNTN2dDNqU2prL0tGNHplVzJURFhwcnlmZEJicFAzSVlvaWUxd2w5eVVpSWlJaUlxS2pUYzVWZGQ2dHI3RjFOclRuVW5NK0xxK3QxQWV1Rjd4Q2c4T1c5MnhZdjlpOVRhOHNaMnQ3VnNxZGpyckRVSTFhdk8rYmZ3YUlpSWlJaUlpSWlJaUlpSWlvRjJ6QlRFUkVlMHBHbm8vaDRwVjhHTGQwRmMrNWt3d3dJcUsrTUs5TCtFUjJGazN0MmYwVUVRMnVwNTkraCszd1BEbzJobjRsSFlnYnk4dVltWm5HRzYrLzN0Tjlob2RITUg3c0dFNmVPbVgrSHNZZzYzUTY5alhJMG14WERUMkxVQ2MvOEh2dWhMMjh0THhwNS9sZVNVZHhlV3pYY3hsaXRNL1NYWDVPOXRzUFBqWms1MjgxVTh5RkdUNHp0YzNoWWxlVUhBWFhUSC90SGNNNFZYVnRpQkVSRWUyTUJFUk9UVTZpMmJ3MzRPZUVXc2FvYXVOWjd4cTI0MnAyMHBSampTUFZEam9vclY0L3BocW9PQjE0L20yRXBzenJMZVZoRWc2bWxJc1pNMjhvQjFrZVE1dS92OWc2dG5xL3g5VVN6amx0bEpHaEcvWGQxWVJ2ejBtL21CM2JjcHQrSWY0U3Fzbk9mbk1PaW9RWHlYSGY0dUlpNXVibU5sMVdqcTJPbVdOZE9jNHQ3M0IwK2pESjBJb1R2REhiUkRPTU1kMTY4UFh4S2hLTTZPRFlxVkg3dSt2NzNRQWp1VzRuaHNmdi9sMEVGeVZ4YXFld0U5dFFvOFpDQzNHcWNjUE14ZFdaWmRRQ0Q3V1NoM09qVll4VlM1aW9sN2RWRWlIbk95TWpJL2E0Vmw2ditmbDVMQ3dzMkU2Ujl4ODN5ZnV3Yk00OWlvQ2owZEZSQmhnUkVSRVJFUkZSTjRnM00rZXZZUWRSR0lMMlhoeEhkbUNOZHFkbEIvZWd3U1hsS3pLZ3lucnl2QnRzMDYzM3pOZVV1N0RkeVdHZ1Z3TGU4and6MytPZGxTRVNFUkVSRVJFUkVSRVJFUkZSRjFzd0V4SFJ2a2pnb0tOZDNNcXJjRldPczZxTkFEbWJiaERSZ1pLdW9ySS91cU9yV0RCN0lka3Z5V1VpR215bFVnbU80OXBPMFAzS2N6M0VVV1FEY0hvbEhhdDkzME81Vk83cjU5WUw2VlB0dW1hZm02VGRDenZVRFM4S0VHd2p3Q2lPNHRYTzI3c2hIY1hsc1QzelBKVERBS1A5MUc1M2JNUHdmdmZ1OFJJVzRneHBEalNUSExmYUtUcXB0cGZYSTU4YTEveHZLSEJROVJTZUhnMVE4UjJjckxpb2VUd2VJU0xxSjlyc3RSTTd2OWR0VzVMbG1uTkxIN0ZTTnJ4b1dZS0xWcFlYYWlXa3FPSXVJdE5tdWJ5RzNUaXJGODNaYTRZcUlwU3crMURHL1ZDTVJoN0hzUTNPaWFLTmc1YmtHRTZPcStUNFZ1WVN6TE5kUzUzWXZMWWFzNDBJa1RsbWFJUXh3cFVmWUdYV0w4ZHFkcjNtUGFvT1ZjemZFbHprd0RHWHBkL1pYaC9KeVhHNzU3c282MkNsQTF1M28xTVNwZWFZSmtlV1pEYTJxbU9PRzJaYkVUcm1zZ1FmU2FEU3NYbzN2TW5wTVNCVGpxbmxOWlRYVDQ2WFdxMldmZDNYSTdkTHVKY3NXd1NCTW9pVGlJaUlpSWpvNkNwT0NhVk96WFhaVEhRL09HNjM3SWF2OGVGV2xLOUl3STBFR0pYTGRkRGhFWWJodXFIaFJFUkVSRVJFUkVSRVJFUkV0SDJzTlNVaW9uMFJ3YlhUUzNvVU43SWF2czJkeEFrVjJpNWZSRVFISmJOaGFoNytLSnRBVzd0WVFnQWlHbnkxZXQxMjVCMGRIVU8va2s3Y01xcHRzRmp1K1Q3ZHp0MFYxSWVHK3ZxNTljTHpmUHNhU0pEUWJocDdCamE4S09pR0NmVVlCaVdkeGpmcTFMMGR0VnJOUHE2OEx6dnBhRSs5aStOa0lEclhmOThqTlN4R0dSNGQ4dkhxWW96TGQwSk1kbEkwNHZVLzQ2NTVUbVZQNFV6Tnc2VWhEei93YUIzbjZ4N3FuZ05tQ1JBUjlSY3ByWXFoa040WGRmTkZKMERvNUxqdGJod3U2VGpkOEo0eC96YWl2SXE1ZUhjQlJ1L0piNkJtU3RXTzZiWTVvKzNmY3JRMFRlM3gzc3pNak8zZ3N4RTVscHFZbUxBaHBQWDZ6anAzM1ZudUlESEhlQzlQTGRsanl6VFh0aGVta25DZmtnL0hIQ2M2Z1E5bGp0bkdUd3paZDdIazZUM3ZkS1RzWTZwdThHaGdxdGVxM2V1SHgyczJ5S2pkNkNDTk16UVdXMGppRkowb1FTUHFSbDAxb3hTKzJiNlJhc2x1bitQMmRqQWdqMWtFRWcyWjg0UTdkKzdZb0tMMXdoL2xHRmdtT1g2Vys4bnIzV3NJS0JFUkVSRVJFUjFPRXF3amRUWUtMSlRlRDFJbVVyekdwVkx2ZFlMVWY2UXUwTmxnUUJNSm9uYk4rNXliOGhnSk1Sb2FIZ0VkSGxLZjNhMjNzeW5sSUNJaUlpSWlJaUlpSWlJaW9wMWp5MlVpSXRwWFRlMGgxQzQrcDQ5aFdNWDRXbmZPTm9zYVZnbUlpUFpMVS91Mm0rZVg4akg3OTUyOFlpNnpVU1lSRVJIdFR0MTM4ZVNvYjBPSm5oZ05NQjlsYUtVYWpUaEhsdDhia2pCY2NuQ2k0cG43S0RQSjN5N0tFbGJBUXhJaW9uMGpaNEtlU3RlOWJkbnNnRHR3Y0Z0MVk0RmVWOTN6UnJtYzUxV0VrTEJFRnpzMTZ0MUdNeHZISEM1aE54WlV4WmFsOVRQcG5EYzFOV1ZEak5ZTDBpbU1qbzdhTUIwSmhwUUEwbDdGYVlZazA1aHBkckFjSlpoYzd0amZXWGtrRzFwVTltem5RT1YxSjhlOGg5VjYyVHlHZ3U5MmY0OFBlc1IwNmVSVXFnUUl5dHFHRzBtQWtVeFJKN2J6K1hZRWljVDh3bzA1MU16dFowY3JLSmx0cndXOWhYUktFSkdFRW8yTWpOZ3dxT25wNlEyRG81ck5wZzB5S2dKQUdXSkVSRVJFUkVSME5NbDVwSVN5K09hODBPVkFEZnNpVGVMVjExaktRR2h3MmVCcWpqNUJSRVJFUkVTRFJ1a25IVWZOZ0lpSWlJaUlpS2hQc05VeUVSSHRxM0NsNDlkTlhVV0FNdDZKSlhPTmRDQmlnQkVSN1o4WWp0bkxPSGhMMTlIUXZ0bnpzTEVnRVJFUjdaN25BS2VxSGs2WnY5ODI0bU14enRGSmM4eDJNc1QzWlFnY0t6dTROTlJiS0FFUkVlME5SK21WY3FjSGhWQm9Lb1ZieWpYbmpBcC9yQUl6QjE1V1BzYWRBQmZOUFgxei9VN1BIcXZ1SWpLOSsvMSt4MnlGN3ZQT1VoS2MwMmcwTmcwdkV0VnExWGJlSzVmTDJJN012SVZ4Wm41Zld4Rm1taUdXT2dseXJXMTRrWFFrYzgwNjVXOTNUZmhQRUVoSFFYT2RLZ0tNY0tCa3V5UzR5RzVMeVY4Tk1KSWdKWms2NXJuSWN3alRGb2JMUHNhcTNVOWFyd0ZHc240SklpcGUwOW5aMlEwRGpNSXd0QUZHTW5wOEVXSkVSRVJFUkVSRVIwOFJ5Q0xuMEk3YjMySEpnOHBkQ1J5VzE5ZmpPZmhBWTRBUkVSRVJFUkVOSm5YSzFFZFBnSWlJaUlpSWlLaFBNTUNJaUlnT3hESjhPRnJqTjlKejVxOGNUenVMR0ZZcHpxa1dBbk01VURtSWlIWXFoMEpxcHBtOGhCbGR4c3Y1Q0JwbWJ6T3JTL1kySWlJaW92MVE4eFFxcm9zaDMza2dLQ0Z3ZVF4Q1JIVFFYc3pPd3pWbmdWL0tMajV3bTRRVlplYjhzTFZ5amxoVkRrcG0vb3lFRnVuQVRDWHpsM1BQZlk2bHg1Q2JNaXVaYnlVMTkwKzFqdy80cjJGSUphaWJzMVFwODFycmxPb2dOby83STJhWmpZem9qcDMvbXY4aG5Lek00c1A0US9TVHViazVSRkZrSjcxQlNsQ3RWb05yZmgvSHg4ZmhPRTdQNis0a0dSYmFFV1lhb1EwdWFrUXBrc3k4YTc0UHoxRndxNVhWVG9Gd3V1OWp1ZXlqVlBKUUtabmJIYjNoTmgwMDE1Zk9vUTQ4ejN3aWM0M0dVZ3Q1bG1ONXZtV2VWNEl2M1pxM1FVWW5ocXBtS21Hc1V1cHB2YVZTeVlZU25UaHh3Z1lZVFU1T1ByQ012QVlTTGpVOVBXMlhmZVNSUjBCRVJFUTBtTXl4WFdxTzVPWFFUK1pFUkVSRVJFUkVSRVJFdTVRcGQxYTUybk95L3FoYkppSWlJaUlpSWpwTUdHQkVSRVFISWwzcEFIWmJWMUZDaHRQb21COGhiZjV5a0lPRnYwUzBPOXBPQ3FIWnN5d2h3SlN1WU5ITWlZaUlpUGFUdnhLZVVHSllFUkZSWDFqUWRUdWY3YUdveVZ1Wk5vdU5LZW15UGVHc29JcWVPYzBOYnlxckRHVlRHamFzRW16bE5rN0FkVFAwbXppTzdTVGhPUnNKZ3NBR0Ywbll6bmFrV1lZd3lXekF6MEluUnBacjVGckRjeDBvc3o0MzhPMXlFbUpVOEgzSFBKNXJ3NHZrWjdsUDhvdk10cGlOTWNjSHJ0c3RFNDA2a1EweUVvbVp4NTNFYm1zMVNIQ3MxbnY1aGJ5dU1wWEw1VTNmQS91WVVZUTBUVUZFUkVRMDBIVGVyUVFDQjhNaElpSWlJaUlpSWlLaTNjdkxVYWlTc3VlZy8rcmppWWlJaUlpSWlBWWRBNHlJaU9qQVJYRHhtZXc0aUlpSWlJaUlpSWlJcVArMTIyMWtXWWJwNmVrTlEzRWt1TWp6UEp3L2Z4Nis3L2U2YWlSWmp0ZG5HNWhyaFhocnZnV29ia2lSVjYyWWRmcHdTc0U5b1VXaVhQWXdORlNHNzJxNFNrTnIzVGZoUmVzWk9UWms1OVhoR3FKMmhLbGI4MmdrT1phbmxqRGZqREJVOXZHMkU4TjJIcXlFSG0xbWJHek16dVY5a1VDcHhjWEZCNWFSNjhYdDI3Zmh1aTVPbmp3SklpSWlJaUlpSWlLaVFlTG5FUUlkNFhoeUMwUFpJdlphSjIrYmNzVnVXS2FidWlpMUtnOHNVNXVxMjNMUHVkK2NCTzNjTzF1ZlFXTEtMQityN3YzN2VGU2NYRzdEL2FNRmhMVWE1c3hFZzZkMDlobTQxVkZVbnZnbUVORmdlUC9mZS8rd3E5eXlnL3pwTEZXanJsTFBiclNzY3ZVTHByb3l6YUZ1Um9qbVAvLzg1NitEK3RKMy96ZVhiOHI4dDMvKzIwRkVSRVJFUkVSRWU0c0JSa1JFUkVSRVJFUkVSRVJFTlBDVTZnYnJKTmdlUnp1UWYvZkwwZTI0a3FzYzJ5SHJnM2JOOW1pb2V6Znc3cDhZTEJKYUpBRkdtM0VjeDNiazJZNG95V3lBVVpUbXlISnRYeU41bVpSWmwzTFVQYStaVU1YdGR0NTlmWFUvSnhldDZqNlAzRHhITGR2dXlHY2t0MytiL3lQSmM0VG10ZkJkQmQvcGhqL2RIOXEwSG5tOTViMHBsbDN2dFNqZXQrSzJYdFpMUkVSRTlMQm9QSGdNU0VSN2dkOHJJaUlhVE1xVW9UazZoYWRqRzJhMDF6SklDSGkzL0ZlWk1tSS9mN0NjMkUxTnVhZjVsN2NadkxNYjh2NHBwQ2lyN1piZ1U4SExPcVpRdldHcUh6SlRiOEhYY1JEbFVRdks3WDBBQ0NJNmVFOC8vM1JnWmtFTnRicGNyc1R1Uk9vNnBkek5Uam1lVzBlcVJ6ZTZyMFord3N4U3Bid3MwRTcxRzUvL1JqaHhtTGdCa21sMGxtV1pLODlmaVVGRVJFUkVSRVJFZElneHdJaUlpSWlJaUlpSWlJaUlpQVpleFpsRnBsSzg1V1RidWw4dHIrRllPdkhBOVMybmlkU3NyK0Uyc0IxK05vUnFlaElWblNGWUUzN2tlRzYzTTdaZmdRdHRidHM4ZUtkY3FhQmZ6TS9QbzkxdXJ4dGlKSUU0RWw1MC9QaHhqSTZPYml2RTZJczM1NUhtT2E0dnRMcnJNYStSV3lyQks1ZWdYTGNiWXJTRzV6bm1NY3pyWjE0NzN4MlU4S0p1SUpPODk4MG9ScDQ1S0kyTklJdGpwTzBRODJHQ3VWYUV4WFlFejNYd29TZlAySzdGRW1hMGxkT25UNlBWYWlFTVF4dGtGTWNQdG5tZW01dUQ3L3VZbUpqWVVjZ1VFUkVSMFlIeUFodjBTRVI3Ujh2M1NqcEpLd2RFUkVTRHBxSmJHRWxuY1NGOEJTZVRtOWhYY2hqYVdlZjZsZXNXcC80TGFPZWVMUDdvbjJMdndkTytBWHo1QzVBb3I3MlA4NktEVUhuNncvQ0dUNkwyekhlQmlQclRhRng3Mm5YZFozUGxmSmVDUHBWNmVEK1FsUjBiY21nT0ZqWTd0VjRKUXBUaFMxeDRzVWJlTWVma0wyYzVYaDV4Z2w5UlVEZWZmdjdwS3d3eElpSWlJaUlpSXFMRGpLMlVpWWlJaUlpSWlJaUlpSWhvNEtVcVJPd2thRG5iYS9QcG1uL3JTVlNDV01VMnlHZzdLdHBEUldXU3JuUFA5Y3BPQ29IblFuSjVKTVJvTTU3ajRtR1RVSnkxMDNva0hDY0lBanVYZ0p4ZXRPSUVlYTdSQ0dQazhqSW84OHJZOEtJQWpyOFM5SFNmY3RtRDZ6bzJ2RWhldjhFSUwrbytqeWpKN2ZQTnNueDF1NVY1ZjkzQXQ1K1RYTVo2bDl0MWpybFdhTjU3QjhmcjVaNGVRUUtKNnZVNm9paGFOOEJJSGkvUGN4dEFKZThSQTR5SWlJaW9uK2xTVlE1d1FFUjdSenUrRFFmVERnT01pSWdPSTZXY2JtYTZLWjl6MU5hQjJBOUxraVIydmxFWkl4RVJFZEhEOFBUelR3Y2pHTG5nSk5tb1Z0NGxUK25ITmZSakN2cThxZEViTi9PZEZsU1prM0R0YTYwbXpNSGFZdzd5NzBEdXpJeGk5T0lIbi8vNnBRalp5elVrNGVYblgxZ0UwUzVwVS9QOHkrYXpmQnduOG05OS9qSVB1SW1JaUlpSWlPaWhZcXNmSWlJaUlpSWlJaUlpSWlJYWVKSGJRT2gyTU9kMnRuVS9OMTQvS0NoMFFqdk4rYlBZampIbFlEUkxBQzBwTzNjN2lMcm1lZ240R2FyMEZrempsd0k4YkJLSTArbDBiRGhPMGNub2Z1VnlHU01qSTZoVUtqMkg0eXgxRW9SSmhwbVdqQk90YkdpUmhCZjU5WnE5WGEzVDJXcG9xQXhIYVVpKzBXQ0VGeG1Pc3AzSW1zc2hzbHdqTmM5WnlQTnpmYzlPTnJ3cFRoQkhNWFNlNGEyNUZrcmU5Z0tNSmlZbXNMaTRpS1dscFFkdWwvQWk2UmdtdDB2UVVhMVdBeEVSRVZHLzByVVJETWlSSGhFUkVWRmZrTUJ2S1hNY0dSbnRPVno4WVdnMkdzaDF6Z0FqSWlJaTZpc25nQ0RMOUFlMXE1NVYwTitYQXlPbThtNVVidHRsTktRbnc3ZVlsVHdHQ1VUSzFRZE5yWjI1V24vV0hCSk5saHozcDJOQXdvdGVBTkV1bWMrcWMvemlpV29qcnN0b056emdKaUlpSWlJaW9vZUtBVVpFUkVSRVJFUkVSRVJFUkRUd1FqTkY2SU5SeGxVT0I0blpFaCtEVGdLTUdvM0d1aDJMSklUSDkzMGJYQ1NoT0s3cmJybStUcElpeVhKTUxyZlJqTkp1ZUkrajRGWEtVSjY3dXQ2MXltVWZqaXpqYVB2dURrUjRrWDBPeXJ4K0dtbVdJRWt5NUJ0c2Q2bFNnaW9IaUZ0QW5tWllhRWNJWEFlM2w5b0lQQWNUdGMyRGpLUmptb1FZU1pEVTBOQ1FEWnk2Ly8yUzE2emRidHYzSzhzeSt4cjNjNGMySWlJaUlpSWlJaUxxaldQSzVGeFR6bE90Vm5zT0YzOFk0aWl5UWR0dHRFQkVSRVQwTUwzditmZWRNa2RRWlRmRGQ1bXF5NHFwTi90bWMvVXAyUEFpOURiQ3lBNlptdEd6cHNad3hOVGQvYkFEZC80Yi91NzduMUt1dnVvanZqcU51SDNsK1NzeGlMWkpRd2VtV3YvVUtPeG9OMjBRRVJFUkVSRVJQVVFNTUNJaUlpSWlJaUlpSWlJaW9vRVhRdlZGZ0pHQ2hxTVNRRXNnejlhaFB2MHNpaUliWUNTaE4vZVRBSnhTcWJRYVlOU0xUcEtoSGFlNHM5ekJVaWVCY2wwek9mQ3FGWHY3L2VGRm9sb040THJkQUtPQkNDK3lKSmpKUVpURUNLTU1hWnB2dU8xQnBRVGZONjlEbmlKUFVpd3N0dUNiMTBSZW8zckozekxBcUFpU2t2ZENBb3prdlZvdndFaUNqU1RrU0c3dkpXeUtpSWlJaUlqby8yRHZ6NE1zeS9MN3NPOTd6dDNlbHZseXJiVzd1bnFabnA2ZUFhYUZCbWJIb0FoaUdaRmdCRmViRE5zS0J2MkhLTXFtSlFzS0tXUUlMRVNZTWdtQ3BMd29URU1PaTJIUkJNTVNUUVFGRXNBQXBCdWFEVU5NQXoxYlQwOVBMOVhWMWJYbW5pL2ZjcmVqMysrOGwxbFpWWmxWbVZrdmw1ZjUvWFRmdXZtMisrNzI3bkxPUGQ5TFJFUkhYMkFEWDlaVHJ6ZDhHZEZSMVdxMXRpeGpKQ0lpSWpwb2NzUjB4Z0lUVXAzM1Y2V0w1YW1QNE9EcW1KL3czK1RNQy9Mdm5GVHpQWXZDL0JhQ3l0d3BwUG5yQUFPTWFOZU1NN0d4NFpsTzZSL2VBQkVSRVJFUkVkRWhZb0FSRVJFUkVSRVJFUkVSRVJHTkRMMVRkNXFtRHpSNFdUSVdIVmdjTm9jU2hmem5NQ3BoT3cvS3Nzd0gzbWluZjI4VnZxTU5vcWFtcG55QTBhTVVwVU9hbDNoL2NRMDNWenBvWjdtL0RqZ2VxMitFRnQwZlhsU3BhQ2hQaUVyY0Q0VWFqZkFpbzhsT1ByU29tMmJvZFhOWlQ3Y09Md29DaXlRT1pmNEZTQ0tMU3RDQWsvZDIyejFZbVJkWEYxdVlrSW1mcWtXb3lmdnE4Y01ib01WeGpJbUpDYi9NdXQydS81M2NUd09wNXVibWZOQ1Jka1JFUkVSRVJFUW5XUkNFQ01KQXpzT3RMNWZJc3RTZnd4OUV5RW9VeFREVytQQVpwZCt0NS9KYm5jOFRQY3o2T3RQdGRwRG5HWTZxTEUyNWZoTVJFZEdodUhUNVlnV1luZWdWNGMvSVlmK1BtTUo5M0JrekliVjZ6MG9WWkhDSTk4ZHBHcGpQeXZjL0s5V29mOTY1NXYvNG1WLzR6T3RGVUh6eDY3LzA5UlVRRVJFUkVSRVJFWTBnQmhnUkVSRVJFUkVSRVJFUkVkSEkwSVprMnRqbC9sQ1lIZ3l5UTd6QzlEalJobm9hWEtUOTdZS0R0R0Zma2lUK0R1K1Bvb01vNVo5MldtQ2xLOE4xL2MvYk1Od1kxdjJpeUNLT0ExZzQ2TXNqa1YrRS9yU1VwWlA1VjZMd0RRKzNuMzlCYUJFT09pTlZkazdlYXdQcjUzbW5WeUFPY3ZUeUVrbjQ2SW5YNWVEbnFiVmJ6aytseTNPcjhDOGlJaUlpSWlLaWswalBvVFZBYVAxY3VpanNnUVdzQlBxZCt2MXlQcS9sQURvT2lnRXZ0RnZySWVwYTNyTmRtZEJSb091NWMxeS9pWWlJNkREVXBFSXlxQVRHUFM4MWRDL0pRZFBINWNrSi85TGhIajdwM1V0bXBHdklFZDJUTWk3WERCeURpNGlJaUlpSWlJaG9wREhBaUlpSWlJaUlpSWlJaUlpSVJrYTMyOFdkTzdleHRyWjJ6L1BQOUo3MWZZZmROWVFKdHFrcU9aV2Y5djN6Nlhuc2hwVWhCdjVtbmZkZThhcUJRRXJIZlNlcVk4dkFMQTZGenVOYnQyNXRqUE5tMmhDcVZxdjVybDZ2NzZoaDFFSzdpKy9mWHNaaU8wVmVsQWpyVlJnTjNBa2ZERCtxVkNJWmRvdzRkQWl0TnNCeUl4QmVaTFRWSTdLOHhNcEtGM2xXSU05MVBYeHd4SVBBb2lyVHFBRk45V3JnazVuSzlRWm1WaGI1K1NrVTh2bGI3ODlodFpmakQ5K2Z4M096NC9qUWJJakFHdGlIekc5dDdEZytQbzR3RExHd3NQREE4dFB3b3NYRlJmKzZManZ0SCtXR2JVUkVSRVIwT0g1ay9odDRZdTBhSGxjN3JLRVRWUEZtODhPNFV6a0ZJcUtqcHRtY1FHT3NnVnExNXNPRXRNd203Zld3dExTSS9UWno2dFRnL0x6aHl3WG1GK2JSNmJTeHVzTDJ5clE3bVpUM2FBblF0ZmV2NGloak9CY1JFUkVkdEIrNy9HTm5Lbm4wT2FtYi9MaFVpUDA1ZVdwS3VpYU9XRHM2NTF3aVZZMngxQzMvQmVuL3FjQ1pTNS85eGM5MEkxUDhQRXplZmVYeXEzT2dmU0hWcEsrNzBqWGtqd3NnSWlJaUlpSWlvcUZnZ0JFUkVSRVJFUkVSRVJFUkVZME12VnUzM2xIYzNaZHFFN3NZd3hTNmZoVktPS1NxbFBYeGRUTHVPMUhzOEgzRHBvMko5THZ6UE4rMllWRVVSUWlDd0FmbVBIUll1cXlrNitVRjJtbUJySEJ3cGgvMll6WEFhRk40anY2dEQ4UEFJdFQ3b0ZwOTdjZ25GMkg5MXF5bDZ3Y3RGVVhwNTV2YkluVkpwMUVuUzBPTVpQTDk5UHAzdWJ1dlIxSGdoMmpEQUs1MDZHWUZ1cmwySlJMNVhCeHVIVGkwUGk5MXVlankyV3JaOU85MDd6YVdyemFVSkNJaUlpSzZYMVJtcU9kckdBWW5SN2RobVlPSTZDaXl2Z3hDU240RzU5SHIzVUVJZ3RCL3Q1N0RGK3ZmYlE3bXUrbDRXUytEMHJJZUlpSWlvcFB1OHVYTC9xRDZpL2ppVE5oeHMyV0NwK1JvNlVtcFJqc3ZoUlJWZVNuQ0VXUDZsWHphMWJTVEd0T25wT2F4VjVyeWdrV3k4c20vOGNsMGZucSs5OVpmZjZzSEdpcXBpKzFwOWV3bzFFZ1RFUkVSRVJFUmpRcGVtVXhFUkVSRVJFUkVSRVJFUkVRK2VHZGxaUVZyYTJ2SXNtekw5MmpqdWxPblR2bWduRWZSNEtJYnl4M2NhWFV4djlhRGlVSUVTWXd3U1dDamU2dW9raVRBMkZnRm9YWFNZY3NBb0tQSVdJdENSblYrc2V2blg1WnVIenpWYUNRSUE0T3hldGdQRTlvaUlDcXVSQWlqQUZPbnhwSDJNaXpkV2NVdG1ZZHBWdUxabVRITXlqeDZtTEd4TWZtZWhsK08ybkJ0cXlDc1RxZUR1Yms1ek03T29sSjUrUENJaUlpSWlJaUlpSWlJaUlpSVJzRnZ1dDlzVkUzVm1yTDgxU0t4MHdidWN3Wm1OTzZaTWlCais1TCtXNVRodnl4UlhnbWQvWWVuYmsrLy9oYmUraUpveU15S1c3OWJEUkVSRVJFUkVSRU5CUU9NaUlpSWlJaUlpSWlJaUlobzVPVW1nNVAvU3BTNytweUJSZXppQjU0djVEOGRYbUYyZC9keXZRZzJkSkh2bXkydWQ3UTdDUDd4NzdNV2gyRzcwQnVsNDZUQlJkbzlhdncwb0NjdkhGcTlESjJzUHc4MTdNZm85SnQ3NTBzVUJRaDFtTWI1T1RZYTRVWDlhY2hrR3ZPODlPRkYyNDIydFVidm51ckRpM1R5ZlhqUkk2WlJRNHpLb3ZTZkxlUzlPZzgxRUVxL1R3T2VqSG40dGJRYU5CVkYwWmJMVXNkVmwvT29oRVFSRVJFUkVSRVJFUkVSRVJFUmJlZVRmK09UNCtoZzNKYjIyVHpJcTFLTE5pMjFjVTJNTUprR3FWazBkYW5OZXphQUtUNXorY2R1bHdpV3V1Z3VUV0NpOWNybFYzWlhpVTNIbGpIT1NzMXZ4UlUyQmhFUkVSRVJFZEVoWTRBUkVSRVJFUkVSRVJFUkVSR052T1ZnR2JuSjBUTzlYWDJ1WHRZeG5jODg4SHpicnZuaHJRYXIySTJLcTZCWk5IMklVZUR1aGhWcDZJK0d6aVNWeW82R0V5Y0pEcG9HMjdSYUxmUjZXOC9EYXJXS1JNYXJWcXM5Y2xoWjZkQktjN3c3MzBMdUhJdzFDSk1ZWVNYUlJKK045d1h5L01SRUZZRnhpSUpSQ1MrQ253WmRuaXVMWGVSRmlTd3R0bjFyclJyNzZSK3JoLzN3b3ZMaElWczJzQmlicUtQYjdtRjFxWTIxck1CS3Q0T1pSaFgxSkVPekdtMTdLOUQxWUtueDhYRlVaRjI3ZnYzNkErOUowOVFIRzIwWFZFVkVSRVJFUkVSRVJFUkVSRVEwS29JQ256S0pmVkVxMFA0RFZ4WVRCcVpwTVBJYVVtdjZuRlJIL20rY3dVMWJodDgzcnZ6MVJsQjViUWxMcjhuclN5QVNwVE94dGVhTVNWd0xSRVJFUkVSRVJJZU1BVVpFZEd4b280dE9wNDNxMmh3dTlxNkRpSWlJRGxjdG5VR1dqU01NSTkrb2s0aUlpSWlJYUQrdDJUVmtKa1hidG5mMU9idE5GSXdHSWFVMnhYS3d1MnMvaTdLQmVsR1g0UWIrdjNWNlhxVGhNbkc4c3hzZlJ1SEJWdUZvZUpFRzJyVGI3VzJEYlRRUUo5bGhzTkppdTRlVmJvYTBLT0YwMnFNSU5naDBSbXpNOFZvdGxubGlFRnFuVDQ5R2VKRS92elhvOWdxWlowN09lL3Y5cllTaDljczhTYXlmVGcwdTJzMFVhcEJSZmJ5S1RxdUxUcTRoUmlsdXJSbzBFcDJYRC8rc0xpY056ZHBLT1FoUTBqTDFicmZyMzh2emRpSWlJaUphTjVmTUFrTTRORStEQkQzcE91R2pBMUNKaUlpSWlJaUlpSGJxMHVVWEcybGFmeTZ3NGNYUzRLTFVjdjJRUEgxT3VxWjBCMytYbUgxbk5Nem9LV1B0ejBwOTZzZnJaZVc1SC8rRlQ4OTF3L3ozcmJQdHIvL1MxMWRBSjVkVXQ1dlNUZGpTc0JDT2lJaUlpSWlJRGgwRGpJam8yTWl5RkN2TFM2aXUzY0hGM2cwUUVSSFI0YXFrVDh2K09VTVFoR3dJU1VSRVJFUkUrMDZEaTNxMmk5VmdkOWRuSnVYVzE3QnFlRkZYaHJjYzdpN0F5QllHZVo0amN2Y0dGV21RVFQvQWFHZlh6SVpSaElPazRVRWFiTlBwZExaOVQ3VmEzWEVBMDJJN3hXbzNRMWFVc0dHQU1JNWdnZ0JHNXNHNmVqMzJZVVlhWURRUzRVV2U4ZFBRN2NtMDVhVXM2M0xiY1E5bHVxTW9RTFVTd01wNWNibE5NTlIyQXZtOEJoamxXWUhPV3M4SEdCV2x3OFdwQnFMZzRRbEdHamExSGxSMFB4MWZEYW5xOVhvYm9WbzhieWNpSWlLaWRYY3FzMWlOeHZDNENoT2d0QUhhWVJWRVJFUkVCQ0lpSWhxU05kUWJsU0I0Q2NaZGtwcTdTL0xVdEhRTkhGOE5vOVBuTkt6SjN5em1EQ3h1MWRQb0NxSmlUbDVuZ05ISkZnSjJ3Z1ZnZ0JFUkVSRVJFUkVkT2dZWUVkR3hjZnZXVGJ6NkIxL0hqZmMvUUhUak9vaUlpT2h3M1hxcmlkZUxOWHo4MzNvWmRvY05YSW1JaUlpSWlFYVZYaXBxNWI4WUNXcW1MaFV3QVVhSkJoZHBDTzNEN0NiQTZNWnkyNGNYNlJXMEpnd1E2T2NHb1R1MVd1eURjNktnSC93ekV1RkZHdkJqTEhwcGdUVExrYVk1Y3AwK1BEanVHbHdVQmhiVlNvZzRzbkJsaVhJUFgrbkRoWkpvbyt2SzkvWGFYWFN6ZmhCU0pkcCtIUXRrWHErSEUrbjgzV3JacG1ucSsyTmpqOTg0bllpSWlPaCtGVGttbXBIalB1M1RhT21FVmFSMkNQVTZHdUlwWFc0T05weVY5aTRLREVJTjMyWEFLUkVSRVJFUkVSMFJseTYvTktHMy9janl5aWRnaW9ZeDloTlM5MVYzeG4xTWF1bk9tSDU0VVFVbmlFejdTekx0TFJkZzJwUm02YlAvK2FkK1Q2b3NGOG93ZXowQjVsNjUvT29jaUlpSWlJaUlpSWdPQVFPTWlPallXR3V0NGQxMzNzYnkzQjBFeTNkQVJFUkVoMnZwMWdlNG5rUjQ4V00vaklnQlJrUkVSRVJFZEFKWVl4R1lFSWxKNEFiL2pZbzh6MzMzTUZFVStXNG5Wcm9aQ3VkZ2pJR3hBVXdVYmhwT2dEZ09aRjZ0QnhoaEpPaTBGSVZEdDFjZ3kwdTRjdXNSdDliSWViQk9vMFVTV1pSRmdiM1FOc09oekt2MUxwVjVtdWVGRDRhS0FvdEhqYXQyWVJodUcyQ2t5MXREamtZaVFJcUlpSWhHamdZNk5xU09JTFFNUWhrMW1ZMmxBNTFBR2x3VUJ3d3dJaUlpSWlJaW9xTWtxZ0JCQmFaOFVVNVh6MGpONHArM3ppVlNDM25tNUo2OURxYmQ0RG1aRHkwcHhpbWNjVGNEUkF0ZFFQNEhBNHlJaUlpSWlJaUk2RkF3d0lpSVJsNVpscGk3Y3hzM2IzeUE5NjllZWVSZHdvbUlpT2hndkhmbENtN2Z2SWtmKzlTbllRT0xTcVVLSWlJaUlpS2k0eWlRL3hwMkRNOUZ6eVBKRWdScGdOemtlS3o4SWhPZ3NGV1VkbWVCUVkrcjFXcWgyQ1pvcDFLcGJBVGRhSGxzRUFUYkRtZWgzVVZST25TeUFzWWFCSEVNRy9hcm82clZHRWtTb3BySTg5YU5UbkNPRFh4ZzBWcXJoeXd0cEF5NjJESjFTWU9MS2trazB4aklOR3FqWCt3NXZHaXpTT1paZlZ6V0JabXZHbUIwWTZYakE0dytjcWI1eU05T1RrNzZaYmFabHFGcmVGR24wMEdhcGcrOFRrUkVSRFFNTTdVWW43czRoWC96L2dKdXJuWnhmYVdMVHY3NHgwWkV0SDgrOGNRa1B2LzBETTZQVjBCRVJFUkVSRVIwVUM1ZHZ0UW9vcUphWk4zek5nOW1qREV2T09PZWtOcTRtYncwRjZWaXJnNGZYbVQwVHBwVFRtb2hRWjdNSTVrbjdtZGwzcVN1eE0rR3hzMTk5aGMvTXcvajNyWWxidVJCL29kU1pkbU9VWCtydDl3cnZ2YjN2OVlCRVJFUkVSRVJFZEUrWVlBUkVZMDhiVnpSNjNYUjdYYlFhYmRCUkVSRVIwTnJkUVhkVHRzMzFtUmpTQ0lpSWlJaU9zNnNzWWhNakFrN0NXY2NJSjJSLzl4akpCanBKNTNSb0tDRHVmNVdBMjIyTzNmVDhLSXczRm1WVXBxWHlFdUgwc2s4Y0FaaEVNQUVNamVNUVJSWnhISGd3NHMwM0djMDhvdjY0MTRXR3Z3ajAxYVVQa2hveTNmSys0SlE1NVZNdC9TZHpNOWhUS09HQWdlUnpNZkJiV1RiV1k2bzNObDZFY2V4RDZiYXZQeldnNnEwUHpJaFVrUkVSRFJ5YW5MY04yTVNqRmRDTkpKUWppbEJSRWZjVkMzR2M5TU5WS01BUkVSRVJFUkVSQWNvVE5NMGlVd3dJUlZpNTZTSzhUbXBlWHRCYWx2UHlHdlB5dDhOQTlxSzhRRkc1c3pnN3d0U3did2s4MjFaS3B0am1ZOTFDL3VPNlFjL2hVa3pBUkVSRVJFUkVSSFJmbUtBRVJHTnZGNjNpNjk4NmZkdy9mbzFFQkVSMGRHUlphbnZ2dnV0YjZJeE5vN1AvUGhQZ0lpSWlJaUk2SEUxR2cxY3ZQZzBybHg1Rjh0TFN4dlBYMGd2d0tGRWJvcGREUzl5OFpiUHp4UXpLSXNTMC9uMHRwOU5yQVlWeVRqWkNGYitxdmFXa1JZV3ZUeDZJTGdteXpMb1phT0xDL1BZaVRJcDhLM3dveGl2NURnN25tSy9yYTZ1Ymh0bTB4NEV4NitzclBnd280bUpDVlFxRlp3OWUvYUI5OTVZN3NqMDk0T1FUR0FSVml1bzFHSTBKMnFJQW9mQU9QODlvNUNiWTRJUVJla3dQOTlCSWV0Q25tMjlibGxqVUc4a0NBT0RzWHJvZzR2S1luZnI0Y01rMVFSeHRZcDJLMFczazhvOGJ2dnZmUG5KNlVkK2RtcHF5dmRuWjJjM250UGdJdTArK09BRGRLVjhYZGZOZnNCVUJDSWlJcUpoaWVWWVVMdGYvT012NEQrOTlHSDh3MWZmdzVYRk5sNjd2Z3dpT2xwZVBEV0duM24rTkY2WWJVZzNCaUlpSWlJaUlxS0hXY1RDVDJSSXU1Lzd4VSsvc3Y2YzFQNHRTWDNwa3RTZTNwUUgzYTArNTR5N0tIV3JGemM5OWFKVUdjWjUyV3RxYmF1L3c4czlTVVdNTGRxRGlVSDNsRDR3cGYzZmFUOUh6L2MrKzR1ZlhwUCtnc3pacTF0ODlqVWpOWjNPMlpYMUoyU1puWkYvenhpWUJ1NXJneWlMcXluRGVRa1BJZXRGS3UvNW52elprdmZQeWZweFJhcUxyeFNCZTgzQ1NtMy8wdXV2WDM1OS95dkR0MkxNRW93THdQdTlFQkVSRVJFUkVRME5BNHlJNkZoSWV6MFUrZkFhaEJBUkVkSHc5TklNVWE4SElqcDZ5ckwwRFplVk5ySWVsalJOa2VlNTc5eGp0RXpYeHZIYWtGcjdPeDIvOWU5OVhEcU1US1pEeC8rZ0w0VUpCdzNITFc5TFQwUkV0Q3ZHV1g5dG9kM2xGWVptbTcyOWNjYS9adkdRZlhJcHh3cnljU2Z2MWFPR3NqUitpRnNkQWpuMGp5dDJlbnlVRndHNmVZUktZWkJySUE3MjU5aGdmWHo2b1VJN0c3ZjE0MGp0MW8vWjF1VXlUL0xCc1pzeE12Y0M2OE4yak5uZDlCK3UvdlFVZmpyWDU4dlc0NjNUYnF3WlRPTmdQbUo0K3V1VmsxV3Q3QitibXY3NlZXcGMxK0JZZGZQODN5bjlUQmlHdnRQaGxrTThIeUFpSWlMYXpKZnZ5ZUhLVkRYR1NpL0RtYkVLaU9ob21aVGZaeTBLRUZrMkRDVWlJaUlpSXFLZGsxcXh6UVU5TmFseXl1UzVwdFN6YmxrQUpHZWRkV2Z1ZnFaZnZhYVZYNkNENEh6MXJaRzZ3VkJtK1FQTFNNcnhOTlg0dm9wcE55WUxyaWFmcmNpeXU2OE5vdGxSbTBSWjdwSFVSQ2J5WjAyS0hzWmtQWmswcFRsckFsTWRkK05MbjczODJYUVJpeHFhbEI1a21GRS9YRW52ampUeUsyRGdUQmtYSlFJUUVSRVJFUkVSSFRJR0dCSFJ5RXZUSGw3LzdyZjhuYUtKaUlqbzZIbnJCOTlESENmNFl6LzFNeUNpbzJWMWRSVzNidDFDdDlNWlN1alBjWElIaCtmOEUwK2dWcXVoWHE4enhJaUlpR2dYcXE3YS8yTkkxeGRHTHZiOXhEMjZnZlg2a2RSRHI2WjAvUkNqTE11d0U0dFppSzljZVFGUFRIWGhraFhJQWNLK0JDdXVCOWZzZEx6MC9VdExTMGlTeEhmcnh5M3JicmU2YUtjNVRCQWdTa0xNbmg1SFlCeWlZRlRDaXdDangyREdZSDYrNDhjNTdXMS9yRnl2eFFoQ2kyYWpId1EwekdCUUgwOWtBcXgxZTJpdHBVaGwwRGFPMFpQSCtsM0xuUXloWHVWYmlYWTEzRUNXalhiVDA5TStoRXJQQlhTNTZ2SWtJaUlpR3JacUdFZ0gvRHMvY2dGRVJFUkVSRVJFUkhROGxIQVZBL1BKZTU0MGc5dUVtTzNyQk8rNXVReURpdzZXUVNEemZGeVd3Ymc4ZXZLQjF4MCs2ZXNucmR2MEViUCt4N1kzQm5yNFY1cFlodmFpdWZzZC9xWXdQbW1uS0NHMW5OOXpLT2FtM2ZqL3k3bmlwano3V3pnZ3hwblhEZHlhak5KUFlJVEpORlJsb2IwWUd0d0VFUkVSRVJFUjBTRmpnQkVSamJROHozekRHZzB2eW5mWXdJYUlpSWdPVm10bEZVSFlBUkVSRVJFUjBTT2xiV0R0RHRCZEJZb1V5T1Jjd3QwYkNCTXZMR0J5NlJxeTNrMkU5dGJHODZYUjk3bGRYK2VxRjFwYTkyQm9vSlhoV2FPWGFPNXVpSnJSVS9oTExnMDI1L1dZd2JBQ3MzWEFqUnVNVFg4WXh2OWRTamNsQTRrN0Jubmg5dVVhWGcydzJVdXdrSDVHeTJiWFA1c1dwUXhMdXRLaGxPZVNXb0k0Q1gxNGtUV2pFbDdVbi8rOXJFUXAwNkhUczkxNGg2SDE3NDhpaThDYW9VK2ZyaTJ5YUdSY3RBeDhNQjdXd2dSMzE5VjJtaUVPQTR4aGR3Rkc2OEl3MUR1cCt1VllEakY0aVk0L0o5dm5zcmVHc3JPTW9yTUNsM1ZsWTVMRHBROXVzeC9MOGp6UTJVT1prcXpYR2dacmRRc3Z2OC9RQnI1UFJDZkFZSC9zajBmS3dqK1V2V2gvUDdlWGZmWGMrOEIzZndkREU4aStOMHhnNGlwc1ZFWFlQQzM3OXdnMnFXbUNJb2lJaUlpSWlJaUlpSWhPRXFlQlNzYTNiZnlzMUNvdmZ2WVhQaHU3TUwyNmhMV3I4bHpyOWN1dnA2QkhNTmJCeFRJdjJVYVVpSWlJaUlpSURoMVBUb2xvcEtWcEtsMFBhNjBXaUlpSTZHaTZmZXVtVkkreDhRVVJFUkVSRWUyQWhoZGQrME5nL2gzNWV4NW8zZWtIR1czU2tETEJDNTAyVG5XNytGRFUzWGcrTTVtUEx5cXh1L0NNd0FXSXRnaUFpVzNtUTR6aVlIZlhST1psZ0Y2Um9IUWFWM1QzWENnd2hROHdxa1VQaG5FNFozMWdUWWwrS0U0cDQ2UWhSb1ZVNHhSbEE5bkthYlNuSFBiajZrd3RZOTFyZ0pGK05zOXovN2lUNXVqbUJmSkJpTkZrczRZb2tua2JqRXA0RVRTMUNzWll0RmE2ZmhyeXJOajJyWEVVSWdndDZyWEFMN1hoQmdEcExVd0RXWmR5TEs5MjRXUmMrdmxGRmlhS2tKdU9UN3hhYUtlb3h5Rm1HeFhzUlJ6SHZyK3lzZ0tpM1hCNWhuemhmYVEzMzBSNjYwMlVyVGtmYUpRdjM1VFhlaGlhK1p1eVVkMzk4S3o4amhOWnY0TWdRQ2lka1ZVOXRLd1dKem9wTkVneGsrMVVtdVZ5WE5JUGF1eEtmZktlamtkU09TYjk0dC9Gc0ppa2pyQXhnMkQ4TkVMcEtzOStHa0ZqV3JaVEZYOE1Ra1JFUkVSRVJFUkVSSFNpR0hQZWw5d2FmTWdZMHdLS256RkY4T3NUd2NTdlN3MnBoaGd0Z0I3QldlTk1UZVpsRENJaUlpSWlJcUpEeGlzMWlXaWtMUzh2WVhWMUZVUkVSSFIwWlhrdTlXSzh5ejBSSFl3c3kzemo4Zm01T3hpbU9Fbjh0aXlPWXFSWmlsNjNpMkdwVkNxb044WVFoZ0dDZ0VVMVJFUjBBbWs0UlhzZWVPL3JVdUIzQTdqOXVqeGVraDE3RzBqWGdQTGVFSmxBSGxka254OFdPU29tMzNoZWc0dmM0TC9kMEgxOHNFVTBVQ0RETTg3NTc5c041d29rT2k3RzNETW0vWWdpaDdETXR4b0xIMUN6SG5qVWY2Znh3VWE1SDd1dWRNVytCQmhwQU5Fd3duZlN2TUJhTDkrWS8wRmdZQU16R3VGRi9welZJRTBkOGlLVFk4ckNoeDlzSlFpczc1SWtrT00zb3lrSnNxd3hOTG9PNkR4cnRYc29pcklmWHJRK21yWWZjTlh2NUQwOURkbkNZMXNQb1NKNm1MS3pnckxYUXZ0Ny94cGxkeFhwelRkUXRPWjk1MlI3N2ZKVW5sK1RkWGFJNjFPdnAybEoyQzNkcnV0MnpZZCt5ZC9kTkVJZ2YxY3JpZnhtOUx3dXdtSFMzN1NVbG1GTnhxa2xYVS9IVjM3THF6YndFWHdGam1ZNTJsU1orekdyeUhhcHFyZEVMZ3JaUTIyTzZxUGRTbzJHRlFJTFFZQk0vdFpPamo2d0pPdkNVUlRLOGc1azJkZGRpVWo2VlZrWHh1WHY2bEJEL1BaRzk1MGQyV2JvYjcrWFpySVBMVGJDaTdUTHkySnZ4eVFkT1I2ZHY0cGhNV0dNWXVrNmJOTHdZVWJwalRkZzRpb3FUMzhDdGphQjJvYytwenQ4L3o0aUlpSWlJaUlpSWlLaWs4VnB3ZWhwcWR6NW5OVEJUcGpBL1A4L2ZmblQzMCt2cDIrLytxdXZaaUFpSWlJaUlpS2lJNCt0NG9ob3BLMHNMNk8xeXJ0REV4RVJIV1ZGd1lhUVJIUndzaXoxamRTdVg3K0dZUm9iRy9jTnhodjFCdHJ0TnBhV2huZHpwL0htQktKWXI3OUlHR0JFUkVRblU1RktRZDlONE51L0Rxek5BUXZ2UHZUdHdhRHpEaUxqWVM5dDhrMDJ0T0dsVXBYVE0xMnNZbmRCU2p1bHgwN2FQYTV1VVdJdHpUWFB4d3REaThDT1NwaXQ4Y2Q2UFRtVzdQWUs1SG01YmNoQlA3d29SQ1d4aUdRYVN4K09nT0V4MW9jdnROYlNRZWpDcHRjMGpNWDI4NWIwYVozZmNmajQwU0VNTUtLZDBOQ2lmT1VXVm43L0g2Rm9MeVA5NE5zNHlqTGNYYTgxeUdpOTB5Q2p3dzR3MG9DaVhIN0lTMEdBVzJHSUZSa25mWHhUemdjMXdLWnJqbVlrMElleUhxeHNmQ2JLQXBPeTdhdHBhSTNyQi9UUjN1ankxZ0NyNjJIa0E2MDYwbVd5Zmx5SmptWjRUZFdWU0dUSE5Ddmx2YnI4ZFQySXN3eFZIRDROSHV4MGUzNmYxdXAwTm9LTEhsdmVCbnJEQ3pEYVRtUHBPcUxKSjFCOStzZmtSeFV3d0lpSWlJaUlpSWlJaUloT0lLTUZvMmVrbTVEcTBCOTFSWm1IMXBqMEhMU1FsZ0ZHUkVSRVJFUkVSQ09BcmVLSWlJaUlpT2hBM0w1MTB3ZDBURTVPZ1lob3YvZ0crSG1PMVNFSG5RWkI0QnU3Um1HRVRxYzkxT0hyTUhXY3kvQndHOUVTRVJFZG1qZCtHMWk2S2ljTmJ3QjViOXUzYVNQMGJpLzFEZFR6RXhTVVdpUVJVdHVSYVQ3YUFVWWErdE5KaTQyd2dDZ09mU2pRMFdaOEtKQ0dGblhUREwxdUx2Tmk2L0FpSDF3azA1UWtBYXFKaFRIT2h4Y05pNFAxNHpPLzJFWlo2ckFmSEFkalRIL2NkTDVLcnl2ek80MzNrckIxTHcxTUl0cE90blFkTHV0Zy9sLzhUZVIzM2tWNjgwMjRjclMyd2JxTzYyOW5hYVYvSHFjaFlCcGtWRWtTSENRTnEvbkRTZ1dMUVloMzVmeXZyWUUxeHFJWWhKTDFURDhLNktqR0FTM0lkbEJqNlFJWndWam1wM1puNVZ6MmJKN2hJMmtQNHhwbUkyTS9LdEYxaDBIblRpcjl1VERFNjNHQ0QyUTlXQWlEL25vZ3o1ZW1uM1BZTzZJaFZuYlF2ZU1pdng2RU1rVU4rWDNwdXZDUlhoZmo4dmRMMGo5b3k2MFdNZzB1YXEzNTQ4UlIzSzkxMy80cTBxU0JvcjJJYVBaWlRQemtYNVBqS0RtV2lpb2dJaUlpSWlJaUlpSWlPa2tjWEd4Z1F1bitqQlQzL216RlJ2YXpsejk1K3l1WHYvNWxFQkVSRVJFUkVkR1J4Z0FqSWlJaUlpSTZFTDFEYUx4Q1JDZVFjNzVoYXA0TnQwR3ROdXAzZzBad0dqWTB6T0d2RC92b05sTWxJaUxhWjZ1M2dOYWNuRFNzUHZSdHVxY3NkRjhzWFo3dlQ1alBVVlNFeGJhaE9zUGdCc2RQajhzSEJtd2FqdFdnQzNQMFl5eDBIRFV3S012NjY1Yit2ZDM3Z3RBaURJMTBkcWpoUllOdjhLa3FhVlk4OUxCUXgyTzlLL3p4S1k4aGFYOXBlSkhyclNGOTc0K1FMOTlBMlcxaEZPbDJMczM2TitmVmJlcGh5STJHQUlXNEdRUzRFc2ZJNUhlZmo4QjJjbDBIRDRicWFPQk9KQnV0WHBiSzM4YWZrOVAyZE83b2ZGbzFGcmZDRUZlanlJY1pqWjY3NjBJa3kxeURqR2FLZkIvMmpUdVR5VzliQTR5eVluU1BEL09WMnpEQklreFM3ejlSeXJRYzBTQXJJaUlpSWlJaUlpSWlvdjFrK29XajJqM1RyMFZ4TXdhV2QyUWhJaUlpSWlJaUdnRU1NQ0lpSWlJaW9nUFI2WFJnMk9pQ2FHVGtlWTdidDI2Z3RicUtXN2R1YlR3L2Urb1VvampHaFFzWEVVV1JmODY1MGdmNzNMbDlDM2Z1M01iYVdodFptaUlJQW0yRGpSYy8ra01JNWIzMWVtTmpPSjFPRzJtdmgzZmZlZHYvclExSWpUVVlIeDlIbzlIQWhhZWU5dHNNYTNlMzNZaVRpbnh2N3Nkdm1LcTFtbThrWHBOK2tpU29WbXNZbHJwTWIrTEhtOFUwUkVSMFFyM3gyMENSUHZRdHEzSjhVWlFGRnBhVys5a3VKeWdnb2N4Q0ZNRWFzbUs0QVkzcjlGeE5qLzBlVjArTzU5cFp2ckZvd2lqQTBTVUhxWEtjbWVVbFZsYTZ5TE5DNW9GZTgvcmdlbVg5TVdBc3g3NFc5V3JnMTcxaEJqUTRmKzJ0d2FLTVJ5YmpVUmFQWHJmMU9GbFByM1YrOS9MSHYxWjNiVzF0Sk1LbTZIQXMvdmJmUmUrRDd5S2J1d0pYN3M5MjZLRGRXVnhFUmM1ckE5cy81NHdINTdiN29TZS9iLzFWLzhQSlNlVHk5L3RoNUVPTC9KdzhCais3YXpJOU4rVmM5bDJaaHpYWlB2NjVsU1UwWlgrUU1LRDNIaHBlTldkRGZDRHo2WXRTTnRLVmpYamJqRmFBMVhaMDJuSm44TlZxM1ljWkxkb0FEU2tqK3VuMi9vZWRyYlU3L3Zod3RkMlcvZWZvdDExeFJZYjA1aHZJTkN3dWJhUDYzR2N3Y2VuZkF4RVJFUkVSRVJFUkVkR0pWcHIvVkVxQXkwdC80NVBmZ01tN3IxeCtkUTVFUkVSRVJFUkVkQ1N4WlJ3UkVSRVJFUjBJdmROOTZYZ1RGS0pSb0dGRUdrcWtqZG0xNjNZN0c2KzExOWFRRkFXS0l2ZU5uTU13OU9GRFdaYksrN3FEOTJ1QVVlWURqRlJYbmt1MDdXTDk3bmRvSS9sZXI0czBUZjFuOUR0MWVCcUtwSDE5WHYvZWJZQ1JNdktaY01nTlVIVTZkYngwZlBUdllRN2ZCejNKY05sb25JaUlUcXplQ2xCa1c3N2tCbWs0dVQvK2tLNDhlZWNVT2cvOGZOaW4wQ1ovcmphRStlcEtKOHVwOUFHV1J2ODdzc2MyL2ZFcS9YeUZQNWJ0SC84K09IOTFHalJrTXdnczlOQldKNmtmb0lXaGNESXVNdHY4dU9oNDVEc05YN0E2aDYzLzNIcG5CdU83cC9GWVg4ZUlObkY1VDdvVVJXY1orZktOL2pib21Ld24rcHZQNVp4Vzl5djd2YTFhbGUySGJCa3hIOGk1c3p6dTJPTVY3cDBQUW5pV25VVlhIaTliTFFjd09GVWNqN0NyWVhDRC9jNmk3RWhhc3Z5MUwyc2VzbU5TQnVDblQvN1hJem1kcGdWWjExTlRZazNEd1dTYkVlM0hkbVA5K0xDVVk4TzhrTjkwZjE5NEhMZzhnMGs3eUJiZVI5eGFrTWZ5eTdKU0ptVjVhUThSRVJFUkVSRVJFUkdkVkdaV2lwL0x6TGd6VWt1NklFOHd3R2dUS1IwUHBMNHJsdnJtbzN5SElTSWlJaUlpSWpvaGVKVVRFUkVSRVJFUkVkMmoxK3VoMSszaW5iZmZldUMxK2ZsKy9YK2owVUNsVXNYcE0yZVJwajI4Zi9VOUxDOHRZWGw1YWVPOTJoaFV2Zjc2ZHpBeE1ZbC82K1VmMjNqdDl1MWJ1UDdCTmFUeVhlc041clhSdEE2ajArN0E0QzNNbmpxTlU2ZFBnNGlJaUk2NTF1MXRYeW9Hd1RKemk0dWdvMjB0SzdEY3pSREVvVjRoaWFOS2d5TUxKOGUxaTExL0hKcWx4YmJ2YlRRU1dHdlFiSVQ5a0o4aEJtajFBeDhDckt4MjBPbm1LSXVkQnkvWUlJQ3pEa1ZQd3h2a0dMcVRJUTRzNmdtci9XaDRldTkvRTkxMy93RHB0VytqV0xxTzQwYUQ4UlpYVjFHclZKREVNZmJMNzFVYitDQ0tjQ3M0M3IvUHBjSDAvWCtiRTVqT2MvelZwUVZRWDAvMmlZczJ3RCtVY2hIZDQ2VG1lSVZZM2UrYjhwdXF1QktSN09rdXBDbCt0TmZCc09rZVUvZkxyYlUydXZJZDVURUx1Q3g3YStoZCtRYUMyZ1M2Ny93Qm9qUFBJeHhuK1JnUkVSRVJFUkVSRVJHZFdBMHRHRFl1K0pVU3dXdnkrRDhBYlRET1ZPV2ZGNlVLK1RVUUVSRVJFUkVSSFRKZXlVeEVSRVJFUkFmQ1d1czdJanI2eXFMWUNCL2FUbEdVRysvUlJtTjVubS9iWU13MzlyN3Z1VHpMNVAyRmYrMkI5OHQvL2JDQzNUZEEwMGJsT3Y2ZFRodkRwTnN2WXd4Q3FlbFAwM1NvdzdjMjhPUHNBdDRFaVlpSVRxZ2cwWjI0SElSa0Q3emtZM0JrSHh5RmtYK2M1Um5vcUhJYngzMUhNNzZvUDFaWm9jZXVwVDkyZGR0a0JtbG9VZi9ZejBCUFkvMTB1WjBIREQyS2hoZnBvWE5XNUhKTS9YakQxamxlK3ZrK3ZQRWpVbVd2aFh6bEZseWU0cmpTODg2eTdQOEcxL2MzdzZLaE5UMWowWmJ0U2VjSWg3b05XNDcrdEMvSStXMGs4M1hzbUFYTDdNV3k3RWp1eVB6UUVwU1R0S1Zla3VtZWtPbnVTRCtTMzFrNHhLblgvWjdmandORDNUOGZOYTVJL1hZNG5Ed25qeGhnUkVSRVJFUW5rNTZ4RjVCektoTWhOUW1HcFg4K29lSGdVazYzZy9mcnFiM1paU0N0MVhKdFg3NW9mZitrNjNhNzBEbGZGaXdyMkN1L0xzWHh4clVMSjVXRytxdDJMOGQrQ1dVZUIvS1RqOFBoenVzZ2FjQW1kUkFSMGQ3SUhxQXBtK2VwSDd2OFkyZENoT25YTG4rTmQxTlF4bGR6QlRLRGVQRWhFUkVSRVJFUkhUb0dHQkVSRVJFUjBZR29WQ3FJby8yN296MFJEVSthOXBCbEQyK2ttcVVwZ2tIZ2psNWtxSUUrMndVS2FOQlJ1VVVnVXRyYitqczB1Q2hOdTQ4TVVkcHl2R1M4TlV6cHh2VVBNRXlUVTFQK1FzQ2ltTVRxeWpMdTNMbU5ZWm1lbnNIRVJCTldyNEFEdDVORVJIUUMxYWVCdkFlMDV4OTRhZjE0WTZvNWpxSXNNTGU0QkRxYU5LTkNHdzVVZkhqdEVXdzhNV2pVc2JMWVJTN0hyMW02L2JGbXJSckR5RFNNMVVQZmtxa2NZZ0NIajBreEFicFpodVdWTHB3UFQ5blZJUHk0cmVkQTlCdGFsUWhMTm9LaTRjcnV2SVAyNjcrRG9yMkk0MGlEaTlJMFF4eEdzazBvRU5nQXc5eDBYWlBoem9VaDNwT3lzTnZoeWFtU253OUN0STNGMTZzMVRCVTVQdG5wNEtUN3Fzd0xEWFJLemNrSmR1L0t0TDVXcVVyZjRFa3BLOUoxWVhvUFpUemIwZktpTk10OS96Z0hHT1VMMS94MldBT01vdGxuUVVSRVJFUjBFdVVhWEJUVXNCcE1JblREQzdmUHBMaXZjQWEzVTZuLzNYUmFzVlZJa1pZcGFyZmI2MTJTeUdKMnJJSmFFcUJSSDE3NDBxaTZlZVZkZng3WEs3cWd2YWxYR3BpWm1VVVFSVDdJNktUcWRUSmtlWWwzYnExaXY0eFhJb3hYSTh5TUowakM0V1ZCeEtlZlI5Q1lCaEVSN1kxVTQ3ems5RkxrSXZpQzFOKytKVTk5R2FSMFo5V1FRMXdlZEJJUkVSRVJFZEdoWTRBUkVSRVJFUkVkaVBIbUJNS0FweUJFb3lCT0VqajVUd043dENIWVZvM0I2bzB4Vkt0Vi8zY1FCaGdiRy9kQlJ0MHRHaWRXNUgwNnpIdStJNDc4ODJtdjkwQ0Q4TUNHZm5qM2YyWW5qRzh3Yi8yd2h5bU9Fei9jTUF6OWVBMXorRHE4L2wwU1QwNWpSaUlpb251Yyt6alFYZ0N1em0vN2xrU09IY295UkxQUjhNY3BPTDV0MVI5UVZHdklLaFVVY2o2MWYvY1RQc2I4M1pFTnVyM0NCNVprV2IrL2xURHNIMHNtU1QrRXlaWER2UnU0SEdHaktCemFQUTBNTGZ2aFJTQTZtc3JlR3ZLVlcwQ2U0amh6ZzVBeS9lMzdTOStINUphY083NFR4ZWdjeFVDM2ZWYklkbGNEbklZWFZ6T2FlaklmZEM5eVUrYkZZbkF5YjNyY05vR3NDeUVpK1owTk04Qkk5K081RHkvQzhTYmIzNks5QkpjUHI1RTJFUkVSRWRHb0tVMkl6TWo1ZFZCSDdNWXhMTG1VeWhVYWJseEtYZldta3d1enpXbThNZkordDd2U1dXY1NGUEVZWEwyR2NIb1NKOTNhKy9QSVpSNnVuZlFDZzhkZ3dpYmMyRm5ZYWdXaDFCbWNWR1pwRlVnemROTDlDMTZ2U0wyTS9uNXRjMGJtOWZDeUlJTG1XUVIxYmcrSWlCNkhISzVOeUQrWFlJMWVqTXdBSXlJaUlpSWlJcUlqaHEySGlZaUlpSWpvUURTYkV5Q2kwWkJvZ0pHN0cyQlViTkhJck41bzNBMHdDdnFCUTUwdHdvdVV2aSs1TDR3b0RDUC9mSjdsRHdZWURRS1JrbmozRjRMNWNRNkNqWEViRmgxL0RVZUtvc2lIR1ZXSEhXQWs0MnpNeVd2WVNrUkU1SjMvT0xCNEZiajY5VzNma3NUeDRQakViQnV3ZUZ4bFNRMnBISHQwNUhpaEI5bzk0NC9qdXIzK1habHo2YlpiZjBJNURvMGlPWmFzQkxBYVBGRU11VFdOc2NqTEhLMjFkTEFlZytqSTBnQ2pZdVUyanJ2MUFLTmg3MWR1eTNueVczTHUyRG1CUWJYYW5QTURPZWVQVHZoR1RnT01jdWx1UkNHVzdBa05NSkxqTmwwWHBvZThQeTFkNmN1cW5CdHUwT0JSVStZWnlzNHkzREVQa2lNaUlpSWllcGdDQVRJajU5ZTJnVEFZWHJ5N2hoR1Y4bDhtL1h2T0xSNTJLcnZMY3hzVFMvbGlNZzVUbjBRMGZSNG4zVnJ3TnJJaXhYTEptUDY5U29JbU1INFd0bDVISk4xSlpRc3BzK3gyMGNtK2ovMVNONUgvL1FZVDU0YzZyOFBtR1FRMVhqOUhSUFNZSmh6TUpXUGNISWlJaUlpSWlJam95R0dBRVJHTnREaU9FVVlSaUlpSWlJaG9lSUlnOE1mYXp6NzNJUjlLdExLOHN2SGErUGlZZjcxU1NSQ0cvV0lGRGZXWm1KeUNzY2JmaWE2OTFrS3YxL1BEMEVpZUo1NjhJTWZ0OXhaQlRFMVBJMGtxbUp1N2cxVGVxKy9YeHVXTnNZWU11K3FIdDVkamZUdG9GRmlyRGZlQ1BSMVhPd2d3MGpDallRNi9Jc01PR0dCRVJFUW4yZE9ma1lPTWM4Q3RONEMxT1dEcDZ0YnZNK2dmZjJqd0MwNFFtZVpTT2cxdm9sM1FZeXRqMFVzTHBGbU9OTTJSRjlvWTZjRzFSNE9Md3NDaVdna1JSeGF1MU9aTHcrT2dBU1lHU3lzZGxLVkRXVEM1aU9pNDZzaTJweVBuaml0eWJyb20vZU1kcjdJMUovTkFwMzFWdHNFTGNxNmJ5RGExZmdMRGpPWmwyblZkS0hCeTk5KzZIbHlUY3BTTGVRWWlJaUlpSWlJaUlpSWlvc2ZsNEdJRE0yMk1lZXBUbHovMUl4bXlxNjllZm5WUFlVWmxXVjZWWXV3YWVNM2VrWE5XTC85c29ORTFtQWlpZTl1K1pnNnRHNHU0Q2lJaUlpSWlJanFTR0dCRVJDTk5HeXlGQVRkbFJFUkVSRVREWkl3RzljU1lQWFVHcXl2THlMTzdkMEZzVGt6NkFKLzFRQitsL1ZxdDV1OU9HY2p4dWJhdDErY3E4ajRqZlEwcnVqK2NwMXF0K1dGa1dZWnV0d3ZUV3ZXZm1aeWNRaHduZm5oN0czZmp4MStIUFV3K2pFbUdyZWNnL1JDajRRMWZoNmZqekFBaklpSTZzYWFmazM4Q1lQSkMvL0UyQVVheWwwZHdBa044eWlDUTZiWisrbWwzOVBpcUtCeTZ2UUpaWHNLVld3ZG9hRGhVRkd1SXB4eEhSaGJsTHUrbXZvTVIwWC9RNmVvZDNSbGVSSFNjWlJwZ0pPZDNYZW4zVHVnNW5tN2xkTnE3dGo4djVIL1VoNzFkSFFGZG1mQlZHNXpJRUt0MXFhd0hpeHJreFBJT0lpSWlJaUlpSWlJaUlob0M0MnNkMENoTFRFV0J1UkNnc3Fmd0loVUVkc0doWEFFZE9WRVRTU2JMT1NoeENnWHV1VkF6QWhhbHh3QWpJaUlpSWlLaUk0cXBIMFEwMHM2ZWU4STNiaVlpSXFLamEvYjBhUVlPRW8wZ2JleXRRVVhSOUl3UEZkcDQzbG9mTkxRZVhyU1poaEpWS2xYL2ZsZVcvcjBxMkdJYm9JRTlRV0RsbVA0Y2lxTDA3MWMyQ1BBNDBsNVBocGZqNm50WE1Fd1RrNU4rbXNmSG0yaTFWakYzNXc2R1pXcHFTdVpkRlVZNkRUTWlJaUk2aVc3R1ovSGwyZjhGYmdTTCtIYjdPanJ0TldSWnV1VjdOVFN4TEF1a1dZNHN6VGFlajVEQk9vZkk1ZGlOM0FUU2hTaGc0SEQzR0NlUVo2dzhVd2w3L1Nmc3pvSm44aUpBVmtZb25MMW5lS0hKNVJobzAvQjJxQ3IvVFVSTmZNNmR3ZE9nUi9OcG1ySitsRmhkNnlMUEN1UzVIbXMrdVB6MGVMUmEwWEJLNlNlQnJseEREUy9xTDMrRCtjV09QK1l0QzRZWEVSMTN1WWFWYVhnYTgxclFrL1ArbTJHSUtkbXVUcDdBQUtOVjJSY3RTWGVTQTR4SytSMTBuVUZMZmhNNkw3UkZDVXVKaVlpSWlJaUlpSWlJaU9oeFNiSHpzMlhwL29yVXpDeGpqMkUyVW5XN1lnM1dRRWRPbWVKRGlQQUpxVnI0eTFMcC9zUjlMNzhpM1Y4RUVSRVJFUkVSSFVtOFBveUlSbG9ZaGdoQ2JzcUlpSWlPTWcwdkNybS9KaHBKMndVVlBlejlLdGhCQ0pFR0pQWDdnWHp1OFVLTDd1WGduRU9lWnhnbURVVnl6cUlzU3hSNVB0VGhGMFhoeDFrN0lpS2lrNndWakdIUmxyaHR1MmpiR0tuWk91akhRZmJIOGwvcVV1bnU3cE5qK1Z0akF1SmRCaGdWTGtEUFJQSkpnOUpzQ2pCeS9RQ2ptdXY2YjhVT2Q5VTVaSGd1ZmpEQVNHTXQzUHJ3ZHE3dUtqS3NHanFPUVljN3BjZWFyb1FjdThuYThvampMR09OSEkvMk8xZnFlekZjR21TaXg1QWxqL1dJVGdKbnREUGdMNzR2bDNseFVnTjhkRjBvemNsT3NuSWFLamo0VFp6MGVVRkVSRVJFUkVSRVJFUkV3K1FTQXpOZWxHYlBkMFBYS3dIMVVrT3crUHJJc1NFaVdTNTErWE5TK3FjM3Z5YUw2elNJaUlpSWlJam95R0lyWWlJYWVkWVlWS3MxNUhtKzdWM1o5MXNZUmdpakNHUGpUVlFxMVh0ZTA4WXhhZHJyTjBndWo4ZGwydTIxRnRwdGhzMFQwZkZWcVZUUUdHdml1TlB3amJWV3l3ZG5sT1grM1FXOUl2dnBLR0pEV3lJNkdEN2dWTTRSSnFlbU1FeGpZK013MXNxNVI3VWZrRlRzTGhqaFlScmo0LzU4WXJoQlRrUkVSS1BqMHE5K0NVdWRETis4dVh6ZksvRWpQbG5IMER3c2FhS0g0ZHJsWWNTMEMzQXhqdkRKc29xakxBNHQ2bkdJTE5kNHFjTmhndEFIQmMzUGQrUmN0MFNlYlQwbVdxWmNieVFJQTRPeGV1akxiY3RpZUdQdGc2dU14ZEpLQjUxdUxzTWVicFNKanFzYkJDSkZnY1ZrTGZIVFJFUjBsT1N5V1ZvSUFsVEx3OW9yMEZIUmxuM2l2T3lqSzFLZUVoNlR1bElpSWlJaUlpSWlJaUlpT2t6bWpQeHp4Z2I0MnVjdWY2cmJRdmUxMXk2L3RvUVR6QnA3K25mKzY1KzZsS2I1RzMveTMzL2xKdWhZZUxLT256RWgvdVA3bjNjRy94SWxicjYvZ2w4RGpaeUhMVmZqc0haMUdiOEtJaUlpSXFJUnhRQWpJam9Xa3FRQ2E5TUREekN5ZXVIMUlKUWhqR0pVYTNYRTBiME5xN1J4ODNwb2c3VVd4MEZaNUF3d0lxSmpMUWhDTkNjbWNkd1ZlWTQ0cmlEdGRkR1ZMczh5SDJvMGJMSHNCK1BLbm05eVFrUzBLLzBRSU9NRGg0YXBXcXZCR0N2YnpRUmxXUTUxK0hVNWo5Qjl6M0U1WHlBaUl0cXBtNnR5THBJWFByeW9sVDRpMWNjTkdydWZ4RWJ2R2xSVDJydnpZQjhNNHpqRW1uNHdrSVlCdWVIbTlleEFQN3duelFvVWhmUEhhOXVGeVZzWlVaMWVEUytTNHQxKzhEeUdSMi9ScWVPUWw3bnZ1MzJZR1RySXpjUFZwZmM0OFVWR2xwdGhBQklSRFptVnpWUlZ0c1hKZ2U4VDZLaUpaSitsNjRKMVhCbUlpSWlJaUlpSWlJaUlhSGdNeWlsWG1PZUNKUGkrUER6UkFVWjBQRWw5V3lDMUt3ODBhcEFxRjYyQ1k3dmdmZlJrZ21mTEVBMjluK3JHa3hZZFY2Q2JBcmZ1ckdIUFFXRVBXNjV3UTcvTkdoRVJFUkhSZ2VLSkNoR052Q0FNY2VyTUdTd3ZMMkZ0cllXRHBPRkZ6enozUE9LazRrT1VmRk9YKzY2OTFZWWYrcjR3aXFSL3RPK1N2bE52ZlBkYldGaVlCeEhSY1RVOWN3by85TkxMT082MFFXZFJGSmk3ZlF0emQyN2g5cTBiV0YxWnhyRE56SjVDNVpqc0E0bm82S3RVS3I3LzRSZGVCQkVSRVIxdC8rU2IxN0RVemZETm00OCtEekZsNGEvVU1kbkp1MDVIQXhwdHhlMWJnSkdHcnc4anZDYldzUGM0UUx1Vm96am9nQUpyL1RRc0xYVjhzRStXRnR1K3RWYU5wVXpaWXF3ZTlzT0xoaGlLcGVGRk1ESVBlajIwMWxJWnR0dWZNQ2NmYXRVZnNDNjZNSGk4QUtvd1pIVWhFUTFmSWh2QTgzbU9zYklBbld6anNxOTlZaCtDODRtSWlJaUlpSWlJaUlqb2hIUDJDOGE0VDFieTREVjVkQU5FeDB3WjRMUUJIbWpVWUlIZmRZYWhYZnZKSlBpbEFIZ0tCcC9iOVBRN0NQRk9CZmc3OHZlZUE0d2V0bHpsKzNoSEVDSWlJaUlhYWJ3aW1ZaEdudDR0dTFhdm85dnQ0cUFFUVlEbXhCU1NKRUVZUm40Y3RydFB0ejZiNTVsdlFLTWhFWGJRbUlhSWlPaXc2ZjdJQiszVmFwaWNta2JhNi9uOTFPcnFDc3BpZUEyTDRqamVDQlFob3FORmYvTjZiQnZMY1czQVJzdEhSbUFmcndFNkVSSFJxTGl4MnNXZHRVY0VFcTJIOXFTRHNyK1QyUGk5MExDYUhOaW5VQ0E5TDdSRE9QNElBNE00dEQ1UVJ3dEZpN3lFc1JqS3NMZlhMMmROMDhMbitSUkY2VU9KdGh5LzBQcjNSNUVjQTF1ejdmdjJTc09MOUZTNmwyWElzdjU0N05kVlpjNlZ2b3NEaTNBSTgxZlBDWnpqTlhCRXd4REpiNmxXbGdqNWs0TFduR21JVVhSQ3R5OFYyVEZWVFltVFhDTm9kZmxMUCtCMTFrUkVSRVJFUk1lV252R1ZHaW92aGFQdHRFUW5LOURKQzZSU1BxeEI5ejdzWHY2LzRhb29iSXgyekd0bjk2cVVlVmd1ZEJHdkFVbVNJUWtEU0ZFM2FuR0FTTXFKcDZxeFp2MFBwY3lZamcrdGk4dWs3dVRHU2hjOStWMjI1ZmZabFc2NU05cjFiV3RyYS9qZXZNWHR6aGplYXp5SC9YSXJ0YWgzY2hEUjBTVTFzZzA5dXBDcW1hYy9mZm5UUzh0WXZ2cjY1ZGRURUJFUkVSRVJFZEdoWU90RUlocDUxbGhNVDgrZzF6dklBS01RVHozOXJHOThFeWVEUUlidHJyMlZDdGcwN1plQlJsbmtHNGJ6anRaRVJIUVVhQ05WM1NkTlRFNzVUdmRSOWFVeHROOThZNmdCUnZWR0EvVjZBMFIwOUdoRFpRMFlpNktJRFphUEVOMDJXNGFlRWhIUkNmRHRteXU0dnZxSU1yMnk5RGNYQzdwci9jY244SmpGUmpJUDhnQ21ITjU1Mm1aNjdER013UFZZamkzcmNTUW5teDMvT005eUdHdWsvSFFmRzB0WURlYTFhTGQ2eVBKU3ZuUDdlUlJIb1p6M1d0UnJnZDYxVGxhdEVzTWo4ODhFeU1zY3k3Sk91OUx0NzZvcTY0SXJTdFFyRWFwUmdNZkY4bXFpNGFtV0d0aFRJR0ZnQzNUcjFKRHRWWEpDeXhzYVpUKzg2UEczMHFOTHc0dnFNaDlpbGprUkVSRVJFUkVkWHo2OHFNUnlOOGZObFI1dVN2bm96VmJYaDZOMHBNeTJWeFNEc3RLSi92dnIwNkM5K1NBRHZudE42MHI2OVNVYVdLUTNGWGlpV1VGZHlyOWZPamVCVU1yTUd3a0RqT2l1dCtmWE1OZE84Y1UzYjJHbGwrUGFjZ2RMOHZ2ODVzMWxqRDR0ZlRvUG5ENlAvZkxIaWliTVNvYlBnNGlPS3FrdG5wTGVWT0NDSHpHRnE1OEs4TisvRGpEQWlJaUlpSWlJaU9pUThJcGtJaHA5eGlDT0UwVEJ3V3pTb2loR0ZQZTczY2p6SE8xMjJ6Y1FENnp0TndwaW8yUWlJanBDbXMxSjFHcDFYSDMzSGQrUXN5aUdjL2NnRFVjYUd4c0hFUjA5R3NpcDRVVjZiTW9BbzZORGc2VTBWSTVuQzBSRWROeDlzTnJCKzB1ZGg3N0hwaDBZRFZqbHNjcStHVnFBVVdoUmk5YURHQjJ5Tkpkam1nQklNSHkrYk5XaTJ5dVFTYmxyS3QrVkYxc0hFb1V5RG1GZ1VhMzIrMDdPZDRjWlhlUmcvZXE1TE90eldUcVV4ZjZ0cXpydSttVStJRWs2bmQ5NmwrM0haZGZMcTRub3NZV3lWVER5TzUyUWZkY3AyVDR0eVBsZGZzSitYMWFtZjBhbWYxcTZ1blFudGNuY2xFeTdoaGdscmtSWGRnMlpPWGx6WXF3c2NERkxNVm5zVHdnakVSRVJFUkVkZjA3T3FRdG5HUk44UkdsSVVTcm52dCs0dG9odVZtQ3BtNkdUbGRJVlNLVzh0dkRsbWFCOTB0SXkrTno0QUtsWXlyNXZ0M3FZcU1aNFliYUJaaVZDc3hxQlRwNjV0UjZ1TG5mdzdSc3IrUGF0WmJ3MXQ0WVZXVmR1ckhUUnl3dTA1VGVhRC9VR0QwUkVSNFRGRjZUNjlPV3lNL212UC8wZmZycjQydC8vV2dkRVJFUkVSRVJFZE9BWVlFUkVJMCt2KzlaR05qWTRtSHVZYW1PT0lBamxPeU9wVzNVN3JtQXRYWWtzUzMwRGNhVWZZNU1RSWlJNlNtcjF1dnhiUnlqN0t0MW5EYXRkU2ExV1E3M1JBQkVkVFJxV28rRkZKUzlRT2pMMDNFYlBPeGg0U2tSRXg5MUtKOGRpSjN2b2V6Uzh5T1M4UWVKKzhzY2RReEJaZ3lTMEcyV2VoUVlLMmYwN250SEFuU3d2QnlGR3BRLzAyWXFWY1lqaUFIRmtFY240bGNNT1VaRHgwT0NpVGpjLzhGQlFEUy9TaGltUEt6aWdzbldpazBDM2Vsb0JYNU56N0hIcFZtVWJlK0lDaktUVGFXL0lmbUEvTXV4R2hhNERGVm4ya2V3YmRDdWI0ZVJKWlA4NEsvdmRtbU9aRXhFUkVSRVJQUVovWHMxNjA2T29teGRZUzNPOGVhZmxBNHZhR1FOc0Q1TE9jOGdzN3d6bSs0M1ZMbVpxTVU0M0VuL0RnU1lZWUhRUzZlL3c2bElIWDd1NmdOOTY4eFp1dGpTNGlHVXpSSFFDT0R3bng0eFBSNEViNzR5WFMvSU1BNHlJaUlpSWlJaUlEZ0VEaklobzVBVTJ3Sk1YbmtLN3ZZYURNRGJlUktWYTY0Y1g3WVptSFJtSE5PM0J1UkxWV3QwSEx4RVJFUjAxMVZyTk4vQmNXbHpBTUV4T1RXTnFlZ1pFUkVSRVJBVGE1TU96WS80dXdOKzh1Ynp0ZThxa0NrUXhnclZsMFA3UU1zcTlobG1hVGFFY1NhUmxuUWJXYUhSRmlWNDdSWlJFVXFDS0lUS2FTT1FEaTlaYVBmUzZlVDhvYVl2Z29DQ3dTT0lRU1JLZ21sZ1pWemZVOENMbkl6cmszSG1saXl3clpkajdIMTdrWlB4MVdhMEhKVFdTRU5YNDhjT0hOTURJTUR5VGFLZ3U1aW5HNVBmNnUvVUdPa01LaWhzVkd0anppVTRiNHljOHRNYmZCa1hteFVkNlhheklkdllibFJwT2trU1d2NFlYdmRUcG91SFlnSldJaUlpSWlQYW1rTE9yMGdTK282T2preFlvNUp6M3Q3NS9DNm1VaTdiU0hPVUJoN3ZUMXBhbHpQekxWK2J3M0hRRHJla2NzNDNFMThQUTBXQkNXUmJCL2l3UERTNzZ2M3psTGJ5ejBNWlhyeTVnUWVwb0Zqb3Bzb0svVGFMSFlmbzNhM0UyTUMzb29Za3gzVzNmWExoSjdjaytNZEdhUk9hNkh6Q0hxbFIzdWl4d2Z6WXE3VTE1NWxkQmREeThqYTNXNXdKL0tLZEppNkJSdGUxeWRRYTh5eHNSRVJFUmpUUW1aeERSeUxOQmdGcTlqaWlLY1JDaU9KYnZpb0M5MU9uSVo3U0JTWjRmL04yNGlZaUlka29icnhiaDhDNldxRlFxdmlNaUlpSWlJdHBzb2hyNU96US9qTE1CakFZL3JJZXJzRXh0NkRTNHh1NHhYRU0vdXg1OEUxaURNTGc3bkxJbzRZcmhYNW1yMzFmS2FxT2hRWVdVdFphbDIvWjlRV2psSEZmR1MvckREQzhhZklOZkw5T3NRSkVmekhycFYvOU4wNnZ6T3hoQzhKQTlZZUVxUkFkaHpBZkRGVDdNNTZUUjRKNXAyVkJYeTVQZE9tTjl5enFoK3lwenNyYXp1bWZTS2E2NlVxYS9RTWpqTnlJaUlpSWkyaU9ucmRBUlNNZnc3YU5FdzR0eUthZTgyZXI1RzRIbUpjLzdqb3BNeWlIbTJpbG02aG5XMGdKVFhEWkhqT25YZWUyRGRwcmpqVHN0dkRXL2h1L2VXZ0VSRGNlZ0dzNUpFVzh1L1Z3ZTk3WjdyeFNIbHZvek55V3J0QStGVkEzN25zVlRodUZSZEp3NEgxTDB6djFQeTdyZWt1MU9CelNhSHJKY3dRQWpJaUlpSWhweEREQWlvcEVYaGdHZXZQQVVybi93UGtaQlVSUys2N1RieU1JUWxXcVZEVVNJaU9oWTBuQkJEVU9xMVJyUzFVRkVSRVJFUkxUWm4vL1llWDluNXQ5N2QyNzdOd1doenhFdm1yUDl4ME1Qb1RuNmlrcUFzaHJEaGZ0elY5NUdvNEc5aU9NWVo4NmNRUkQwNzM1ZWowUHBaSGhKQ0wwWjZlcHlHOVY2Z2lrME1ReEcxZ1VOQzFwYTZzaHFVQ0xQdGw0WHJER29OeExFa2ZTcnN2NW9jTVFRMXh1bmtRekdZbjZ4N2NlblBNQzdGNWRaaGlMTk5pNTZmbktpN3FkM3I1YVhsMzNZZnBWbDFFUkRkMForVzJlUTQxS25oWVUweEcvV3gzQVNmS3JUd1ZTUjQwTnBEOVIzcWIyR0ZkbkdYcFA5ZUVmMkh4OUV4LzhTamJyc2UvL2l5aEltWmY5YjVXM0dpWWlJNkFoYmE2MUsrVUtHMWRWVkg0VGNrbjVSNURnSXkwdUwvbHk4MVdyNW0rRzExOVprWE5nK2pXZzd1WW1RbWdTUlMySEFSSUREOXVVcmM3alY2ajN5QmdWMGVONmFiK0dLbEdGZmVtWUdINTRkUXlNTzdya0JBUjBPVzU5RU1INGF3L2FYLzd0WGZYM2JQLzNPZFJEUjNtbVZtdzFNVjdxZWlZTFMrSHVadUtaR2o4bkxrNDhjUUh6UHdIcGw2ZHF1Y01ZVnBTbXlzaTcxZTh4NlB3Z09mOFVaM1A3eHk1LytsdFFTejMzbDh0ZS9qSlBqakt6Rmw2SW9XcEsvYjRLT2hmZGIrSTcwdnJQVmE1ZUE4Q3BvRkcxZXJzODloK1N0dCs0RzVGM2ljaVVpSWlLaUVjY0FJeUk2RnZwM0NRLzhoUjFPU25iZENKVHU2amlXZzR0MjlXOWplSmNnSWlJNlhnTFpMMnVBRVowYzl4K0Q3ZlNZVEJzOFY2czE2ZTl1ZmRHR3R1c2UxZGoyL21NdEhuc1JFUkVSSGI1R0hHNzAwNktRYnZ2ang0MVhUdUp4bk9uZmFSejdmSmZ4OVdQa2h4M0hyNzlIaitHMTIrcTRPcENuUW12Z2N1ZURkc3JTb1grQjcxN0h2Lys1b2l6OThQcmo1N1lkUHlQZnJhRSsrblcrckJqRG8zZDYxK25SRzZnZWREbjArdmRwWi8wc01mM3AzY0huL0x2MWJ2V2J4bGNiUjJyUXZwNVhKVW5DQUNPaWZWS1ZiVWJWbE5MdjF3ZDFqdWx2clRLWXZscFpTTWZBbXEyTTZYeVJ4Ui9KdGxpYmQ1Ykg3SmpHRFBZeE5lazNaRDNRNlF4QVJFUkVkTFQxeXkzay9Gak9qZlc4V2Evak9xaFQvV0lRdHF6ZnJlUGd2eHRFdEIzOWZaUTRYdWRSbzZoZlBnbmtVdDZoSFIxZDYyWHBoUlJIWlBvUHo5SVBtZW4vYjZWZXhRN3ZXcnFWYnYrNnFWWXY5d0ZHUkxSSHZoN1RWd082ZnQyYnI5VzAvVnE0UGU3dm5EUDk0Q05uQm5WNnZvSnpVMTBkRDJ6Mm1aeGh6VmhqTzVjdlg3YVgvOFpseHhSTU9vNWVrVU56ME1qYkhGNmtYdUZ5SlNJaUlxSVJ4OWJFUkRUeWpKVHRhb1AzUm1NTWsxTlRhTGZiNkVoMzFIVjdIWmllUVJ6RnZuRklHTzNQSGRTSmlJZ095NFRzbDhlYkV3aENYZ1J6a3ZnTGJNdCtZMTV0Q090REd3ZVBzeXk3NTMzNlhKSlVNSHZxdE85Mm95aEszTGx6WitQeGVnUHFkUnFlNVM4b0dIUnhIQTlDTCszR2MwUkVSRVIwdUw3dzRWTysveHR2M01ETjFTNSsrd2UzdDMrekRlN3RueUJPejZrMDdOUHNiK2hGcFZMeHgramRidmVCMTlhUG83V3Z4OTFuejU1RkpPV1owUlpsbXJQalZhUjVpZVZieXlpeUhPM1ZqcFI5QnFqVUV1eUYwYkFQK2U3NStZNC9qOGpTN2UvcTNXaG9FSTlCc3hIMkc5TU1NVVREK2F1WEE2eDFlMml0cFNpTGd3MHY4bjF0MU5oTDBheEVmanByOGFOL0Q1c0RqSlRPUTErRzN1bGdibTRPYVpyaXhSZGY5T2RNUkRSOFA5enJiMU0xdUtnajIvRlhhblVjUnkra1BVekk5dVduMnkzVUdXRDBBQTB2K29zclM3Z2wrL1BmYVRTd0tNY3oxNDVadldBc2UwbzlVdm5UclJVa3N1LzVTTm9ERVJFUjBWSFhicS81N2pDc3JxNkFpSFl1TlJWMGdqSEVSYm9Sb0VvSHI1UDFiMFJ3YzdXSEQxWTZvS09yMFBBaVhWYXREZ0k1WWYvSXFUR01Cd3l4UHl6OTRLSUE0ZGdwaEpQbk1TeGYvTUV0WEpQZjRqLzk3blVRMFI1cFVsRmd0TXZDT05DZFd5SlZhdVA5RngwZUkyY29Oc2JGSnRRN3Z4Z0VpZFVDMDI3ZUsvUlF4dVJwdWJlS1U5b1JxU1dlUVdsK1JaYmc3NzlpWC9uNnBWKzYxSDBGcjNSQlJFUkVSRVJFUlB1T0FVWkVkR3pvWGJXMUFYemFTekVxOVA3ZmVrY3RiVVRDQUNNaW9xTkQ5eW5hQ05QZmJiRW9RSHVqODdCYXF5RTRwbmVXUDJrMkdzeHU2cTkzbXgrdkJ4aXA5ZU9jemE5dEhwNGI0b1dGOXc5Ly9lLzFzQ0lOVDFyL2UzUGo2L1gzYk81YnJyTkVSRVJFQjZLWGF5Qk5nZG5xR294TDhmeGs2aStxMTBZUXBSN2ZQZUp3c1g5M2V0ZS9sZkFtZTdsNW90djA2ZnZ0cFVHTS84VDlvWm5yUVRMWW5ha2d4SGhRUVdJcjhxaUMvYUxCUk5zZG82OGZTMnZJVVpJa1BqQjB1K1BtSkxDd2c2bjBkK09XNVduc1hpL3VsV1A1UXM4ZDFvTlN0MzZYaHZubytJVjZnYkhkaC9NTkdZL1MzNms2OTJHcXd4ejJqcjVmdjArbmYzREtFNGRXcG5WbjV5MjlYajlBWWoxZ2RqMmthdjE1aHJzU0hZd3AyWDVvZ05GNUtaL0k1V2ZYc2dGU0xhOFkwZCtnMVZCcTZhcmF5ZmJwVkY1Z1hQYnBNUnVSYmt2bldVVTI1R2Z6VFBicHBWLytYZTJzcmdkMlpHLzlITXMwSlhMUU5pM2xnQnBpTkY1d1BTQWlJaUlpb3VFcmpKNUhKeWloWlk4TXpqMHN1Y3o2N3FEOG5rYURscSszMHdJRkY5bWhNbUVDRzFlbGdHZzRUWGUwL2t4L2h6ZFd1N2l5ZVBSditEdks5T1lQV2pkR3g1TVV6K2IrL2lYV2hNYjZ3dnJBR0djZkk3VG9ZWHh0cWRQdmNVN3YzNTNwR0xqU3NVM2ZQcEg1SFVnZGJ6Tkg5NlVjdUlKK1IwUkVSRVJFUkVUN2pJVWRSSFJzVkdvMW5EcDl4amRrR1ltN1ZBMHFCTmZXMW56am9JUVZIRVJFUjBhVUpHZzJKL3cyT2sxN0RESGFvK21aV1R4NTRTS3NEVURIZ3paMDFVYXZlcnkxM3ZnMVRkT05zQzkzaUJlcGJRNU9VanArRDJNR1FXWGE2Rm92TmxsL3ZEbllpSWlJaUlqMjEvWEZLOGlMRkQvNXhCVjA4eEtmbU8xaW9aM2k2bEliN1N6M2QzSitHRDBXemJMMG5tTlJEUytLWEw2cjhmRGhOSVBPbWZ1T0JXVzRVYmE3QmpGT2ppbExxOFB5RjZGdVBHOEdpVXhodnJ2aDFTdFZUTmNuTUJaVTVkRTQ5a3ROeWxkMVh1cTU4UDAwc0VqTE1KOSsrbWwvM1B3d3A4ZHEvc0w1YjM2d2dDS1g0YTEwVUd0VVVCK3JZbGQ4OEtqRnltSVhoY3k3TE4zKzNMeVNSQWhDaTdGNjZKZlo1bk9EeDZkWExnZm9aaG1XVjdwd3BjTkJuL280bVkrbGZMOHIrL05BNTdHR0dPM0UzTnljWDY3ejgvTVB2S2JuUXV2blFVUzB2ejdaNmZpd292TlNYbkZUdHFkdkpCWGNDa0xjRGtlenVyNHVHOExUTWkzUFNkbnBoMlJmZkQ3UFVDdlpnSFE3dXBWTjVJampUSkhqNTFxcnVDUHJ3RHR4Z2pka08zd3pqT1N4SE5lWTBTeVBla0tPMldaa3VqN1phV05hOWxOVExFc25JaUlpSXFKOTBBNmE2QVpqY3M1eEd5T2JBSHNNTEhWVExMWXpaQ3dER0JsemF6MnBmeW53a2ROajhvZzNXVDBzNGVSNWhPT25ZZUpkMXBOc281djM2OUQreFJzMzhmdnZMNEwyeitUVUZFNmZtUUFkVDJGczE3UXlVdnJyRzhsb244S0xWS1NITUZIa3k0R0xJTENMWlZGR2VjODFtUXM0ZkFhK3dMMGhOZllmUTRuL01uRDRCL0w0SDRDSWlJaUlpSWlJOWgwRGpJam8yS2drRlIrVXNMSzhoRkhTdjN1NDhYZTgxbEQ5S0k1Qlc5QzdnMHV2eURPWlg3ejRtZWhrTXI1QlhSQ0d2Z0hqZmphdVd3OHdxVlFTaEdHQVhsY2JTMnBBaTE2QXc5ckNuV3FNamZsOWN4QXl3R2pVckljQnJUY0VYMys4M3JsTkRZTFgzK05HckNaZHgxZkhmWDE2VkpabEc3Ly85UzcwMjV6K2MyelV1M2VkVHRzZjc4N2R1WU5ScHV2QnhNUWtFdGsvMU9zTkVCRVIwZDY4UC84RExLN2R4aHZYdjRFMDcyR2hkUXU1SEplMWVnVTZlWUdneUZEUjRDRHo4RVlRMWFoQVlZc0h3bW9DdDh2QUlmUkRqUFEybTI2TEYyMnl5Mk5kMHgrZUJoamRjNDNyWURDMjNOM3dhbkVkWTBtSktPaGhQMVdyMVcyRFFOZURUUFVZV28rSk5NeG9PMGxrZmNCUFBRNzlKS2ZkREZFUytuTnFMZjgwOWhISDFhWS80OUxVSVpkMUlYdklIYjNEc0gvY25pU0IvQzN6Zk1nTlp4eXNQMTlvdFhzeUhtVS92QWdIVDZlclNPVjhSY1pGNTJHekdxRVM3ZXhjdXl0bEd0c0ZPdWxkZ3hsZ1JDZmRyVjZNYjg4MzBUTVY1UHRjZFM1VlFWaTBJVnF5M1pxVDdlaGFZTkdXemtRT0k1TmRvM2QzVHcwSzJSNWxlWVIyRWVPYTdCdkdwZDRtWWl1TEhXdkxPckFnNjhCYzBGOGZPcklQSy9TKzNpUFVqdEFWc3Q5Tkljcy93S0xzWjlwNWpKcXNBOVVEYU1SYWR5MDB5bFZNbGgzRVlKM2hVWk92M0VLeHRvRGVsVmRCUk1lRFRlcG8vTWlmQVJFUjBXRXFqSmJUR1hSTUhabVY4NCt5QlRwNFdlRjhHRTVac2d5QWFDZU1rWEo4S2Y4Skd0TUlKODdCaGdtRzRlcFNCemRYdTFqb3BQNDNTVVM3RTRTbXEvZTJzWUZOOUxKa0hMUitkVjlOdnQrRXNWU0hsczY2UXJwK3BUVU5sZE9HT2FlbEx2UkhmL3dYUHYybnk5RCs0VmN1ZitVcWlJaUlpSWlJaUdqZk1NQ0lpSTZOcEZMQnpNd3NidDY0amxHeTNtZys3ZlY4d3g4R0dHM05sOGZMZk1yekZIbVdnWWhPSG0xTTF3OHUwb2FTWnRDZ2NmKytTN2ZKMWxhUUpLNGZYT1FiYTZaZ081eWRhelRHTVRNN0svT1JBVWFqWmoyb1NBTm50SytObGRmRGZvNlRZbkJIK1BzYmFlczJRSU9MdEV1U1pMQTlHSldXaEVkVHA5UEJ5c29LM243ckJ4aGx1azVjdlBnMEdtUGpEREFpSWlKNkRCcGc5TTd0NytDYlY3NkVYdDU1NEhXdHVBanZELy9aaXNXSnFPV29CbU1ZcjVoOUR6Q3ExV28rMUhNcmV1eXNuUjQ3Ni9IeHd3S01Lb01RMjNvU0lzMUx0RHNwa2pSQ0tlZldSbDU3OU5tOGhoeFo5TElVM1o1K1o3bHRZS3FHRGtkUmdFcGlFWVZXdm1QSUYrcExHWVNlQjdYVzBrRndLdzZGMC9PeFRPYTlYdEZzTmNBb1JpM2UyY3F2QVViYnpUODkzOUVRSXdZWTBVbDJzeGZoeTUwbTV2SWFXbTQ0RFloMnpEcjROa3cxM1Q1aUpHaEdZTkd5YUV0L3NUQzRCaG9HRzVkK1hiQzEwU2w4THJzR3hacXNDNFBIQjFuaWN6R3llRG9xOEZLeWhKaEZ6MGRPc1hJTDZaMTNzUEw3L3doRWREd0U0NmNaWUVSRVJJZk9TY21ZbklhaUV6UVF1SndCUm9ja0s0dCtnQkd2blNMYUdSdkFScFYrZ05Ia2VhblVHTTcxNFZlWDJuajk5aW9XT3BuVXN4MnZhN21JOXB0V2lkblE5R3hnTXh1WUdSd0dmeTlYVTlNUzl6QUlVdG5CaG9VckxRckgvS0toTTdyaFBTUGR5N0FJa2VWejhqY0RqSWlJaUlpSWlJajIwWWtNTUhyeDhvdnhxY2FwY1Z1bVRhQnNSa1ZseXRtaVVRWnVxb1N4WWJtN2dxalN1WllGcmttUlVXWnlrOEVXQzFrUXRiSWkrMkN5TTFuOHh1WGZhSU9JOXAwR0dFMU56NkJhcldIVWFHR3pCZ1NFVVlnNFR6YUNNd2krY1UyUjU4alRIdEswczNHM2R5STZlZnlOVHVUL1BFMmxidCtpV2gvMzIwdTdqOXRMcmF6VU83aFZhelhmQ0xMVE1YNGJsTW80MEtQVkd3M1pOMDh6K0dVRXJEZEdYZzhzV2c5WVhBLzJXWDk4VXF4UCszcDRrNjdENnlGRzJxamJiM3U0WHUrS3pzZGVyNHZsNWFXTjV6b21RZGVHZUNNNmo3WTU0RWFpT3pCVHJHRE1kZkJFdm9qWTlSdnlSMUhrRzRCWHFsVVFFUkhSN2kyczNjSmk2emJldmYwZHZIUHJPOGhMaGxRZkpmRWdXRjFERzlmUEMrNjN0cmJtaiswbUppWWVPYnp6RXpXc2RqSXNkVkk1ajg3UldtcWpObDZWY3R4bzZ3L29TYml4NktVRjBpeVg0NjRjbWI5ejhJUG5Ja0dnZ1VVQnFoVXBUNDBzckhGRERTOXlQaDNMWUdtbEE1ME5aWEU0NTBPdWxPblNjeE9aRHhwaU5GNUwwRWhDUkRMOW9YMTQ2SkNXWGF5SFRtMUh3NHYwSElmbk4wU0hwRFQ5TW9pMjFjM2ZhSkROb2ZPYkZRYWZEVk9aeS93c3RBeHVoT2Jya0RNRDZmZ29lMjJVclhta04wYzd5SnlJN2dwN2F5QWlJam9xV25aQ3praExqT2Z6L3N3MGNzTzdma2N2aVNpbFhOQm82YUFaUm5tZ0RFblRhb2NkSHE0M2Y1UHlQRmNXR0dyaSt2cHdpNjNMWlBjcUg1UzFoa002a2V3UFR4dEFETzhhVXAzYUFvRmY5c0ZRaDJ0a3VOYXZzOEVRNTJuUlgwczExbXM0SlRUN3RPeU43YS8vcnNneFRDNElwUnYrOVlLRkcrTHZYMi9VS05NZmpwOUdkUFo1aE0welVyRVI5YTkvSElLMzVscjQ4cnZ6YVBWWVFFTzBJN0lodHRZVU5qUXVzUHI3TkZYNW5SNzZ4V3JHYnl5MDJrL0dLSlk5UmVHNlVpZVpGM2xaQnd2aGgwcTI3QmNjWEVQV2cxdWYvODgvZlNGcjRaOTk3ZTkvcllOalJxWXhsTDFaelFYWmlXd3JTa1JFUkVSRVJFZkRpVHdwUFlWVHRoS2drUnN6YTExMHhwbjhBbUNuakRGUFdJZlFHVnpjemZDazNFaGJZTDRtWi90ZEY3b3VUSEExZEZoSXJWdG9OVnRhTzhZQUk2SURvQTFyTkNoaHZhSE5TTkdRSHFtazA3cHFiUmpFOEtLNzlPTDlVaXJiMDdTTGJxZmREMDg0UVFFS1JQUWd2VmhDTDVxbzFCcnl3R2lyUmV3ZlgwV0lPSW8wdFFKWjFtLzhSenVUSkFucTlZWVBlNkdqVFk4L2ROM1dZQmJ0bjZTd291MzRFTVZCc0pOYUR6SFN4cjJjUDd2bjE3RmMxckhPM1hyL1pXdXdKdlAxKzZoakxoakhVZk5NbG1HbXpORklNNHlYL2ZFdUJ3M0FpNEtCbWtSRVJIdlI3cTFpYnZVNjdxeGM5MzA2V3RhRGk5YkRiTFlLTU1ya0dHbW41M2hUdFdUanl0cFNqcDk2blZUTzViWHNOdHIyTXpyc29wREtsbDdodzR1MkN3N1M5MFZ4SUdYQkZrbGtoeHBlTlBnQy9RZWRiajdNOWhxN0orY2VXZzdpQnN1aUp0UGNyTVkrd01nK1lqbjBqMXVMaDRiQjZ6SWZ5Zkowb3VORXl6ZXp3OTNVMEJFd0NDNXlMSHFtNDZESTRESXBaMTY5QlNJNkhteDg5RzVBUUVSRUoxZlhWbjNBU0dFaUh3b1REZm1FMm0yVWFBNXB3S1lmM2pOTVdqWnFOQmhKcHQ4Tk0yeEdRMnhrdU00VVF5Mm9jREpjUDErSGROTHIxbE9nM1hEcjdFdWRmcWRCUThPbHd3MzhOU2JEWEZtTkg2NlY4VFZER083Nk9qWHNaZStEa2Z6eUgyNkFVZjkzTmR3MDhQNFNHdTd2WCtlcHJZd2hucjdvK3o3UWFVaHV0bEs4dGJDR1Zzb2JoUkR0aE5TcE9SdVlJZ2l0OW5VekdzdFAvU2hVa1Buc1BDUGo1UGZzeG1XeVRlNlZCZlJ1M29hWEtBNlBMUFVwK1ZjNjk1SVV4eWRvNHJmazZXTVhZR1IwQjJsY0hEamV2WWFJaUlpSWlJZ096N0VOTUhydWYvdGNNajAxbmRUSHdrOGEyS1p4NWlVcGJKZ3kxbnpPdVRMSWM0eEx3WEFnWlRvYTd4ODRLZk14SmNKQjBmT3U1b3QrUmdveGZrTHZrZW1Ma0F3SytZNmlqakJGWHVLbmYrWHozNVYzTGNtNzNpaWRtN09CZmN1MjNiZC8reGUrZEFORU5EUmpZMk9vMVQ2RTczMzMyeGhWMnFoa1pYa0oxV3JOTjQ3M3dmb25OUFJCRytYMHVoMFVlWVoyYTBXMnNDWERBb2pJODRGdmN2QzFOSDhiTmdqUW5KengyOHNnMlA5RFd3M2owWVovVVJUNWJYYW4wK0cyYVFzTjJTZVBqWTJqMlp4QXBWTGRhUHhLUjlkNmdKR3V6MXludDdiZTZGZm5FOWRwSWlJaW9yMjV0ZlFlWHJ2eWUxaGN1dzA2bXZSWWQzeDgzSWVidGxxdEIxNWZXbHJ5WWJXblRwMTY1TEJtNmhXcGVER1lyaWRJaXhLclMyc0lrOUNmd3lmVldMNXJ2ZHhUTDZXMFNETjV6MW9YZWFhaGtYcjgvZUM1U1JCWVZDdVJuSmRiMUt1QkQvZ1pabmlSRzl3TmZINng0ME1ydHd0UU9nZytWRlhLSGpKWkRuckQ1MURtMStteEdwNllyQ0hhd1RtSkxqOWRqbHZSY05iMThDSXQ0MkR3TUJFUkVSRVJFUkVSallKeUVGcnlmdkloQkM3RHFmUURoRWhSTGZkMm4xbU5xeW1sN08zZGZCS0ZNK2k2Q0dNMnhlbGdGWW5KRUpxOWxRLzJuSlNEUmxOWW12MFIxRTZmUnYwakgwYjZ3WGVScjl5RUs3TTkzY0RSaEFtQ3NXbEVwNTVIY3ZvNVpITlhVYlFYMGJ2MkxiaThoNzBLeGs4aEhEK0QrTlN6Q0JyVDZMejFWWlJwUjRiL0x2YWk4TkZTQWQ0T3ptSE9qR1BaanNsekZwL0x2bzBZT1JwdWI4dXFnOFFQNS9lamo4cmZFZXF1aTBtM2lvL2xWK1RaUXI1eGI4dnFqbW1pWldyNG1neTM0VHA0cXJpRjArVUN6cmdGN0ZVcWErVmJ3WG1zMkRyZXNlZHdRWVo1b2J5RmFiY3M0NzM3WmFWVGxzc3c1MndUYjl1ejZKaUtkQWsrWHJ5RnNiS0RDZGVTZWJEN1FDZGpRNWlvaXZqMGg2UjdIa1d2cFhjalFQZHRYUWZhY01YZXduRnNmUUkycnFINnpHY1IxSnZvWHYybUQ3cnRmZkI0MTNiSHA1NkRrZUdXcDV2SWwrZXg4S1UvUUd4a25iSXA5cUp3L2UySi92NmQvUDdibTM3L1RiZjM2NEpNRUNOc25rYjEyYy9DVkJzeVA2WUhvVXZEODhGS0I2L2ZYa0hKZTI4UmJVdERnZVNubDBXaFhaV05aR3lzcWV2ei9Sc3A0MGpXamNrNE5tU2M2M0VZNlIyZnk3eFh4aksrVnVvcmVUZVNJWkc2NEorUTJ1VlAyZEo4NzhkLzRUUHpoUWxlczY1ODR0alVsQm8wWmQvd29zdkRKbWpQemxmeGhBMHdJZlB6UjJYN1VaRkQ3WDlaQytVUXFZV2hYZWd5QTR6SlljSlRjb1J3cWd6d3ZKeVR2RmFtdUQ3WnhjM1g5WER5RUp3ZncvTlcxaUdaN3BkdGlZYjBuOWF3TnpsTTBoVFpxL0tXWlhsOFhUYWgrZnNyK0xYZERQdnBDcDdLWTN6R2xlakpQTzIyTEw2NnRJU2xoNDRQTUYxV1VBL2xjL0w5RXpKT1Q4b2hXaVRqY0U1TzAxSzlINVdNeXkwWnY5dnkvRmVLRHBZLzNNWDFWekRzOU15Umswd0NsZm80UGlQYnRna3I4NnMwcU1uZkgxNS9neG5NTnptVW5KZDV1ZGFKOFJ0emMxakZBVHBWbDhQdUFvbWM1djRKMlRYSGdZeWY5T1VFQlhVWnAvZEtpL2U1WEltSWlJaEcxN0VOTUhwaStnazliYkttekJNNW9XdklDWXFjMzJGSytoZE1QNkM2c2ZGbU03aS94V09VT3NoSEsxZ3Z4SExBdmVWWlpsRUtqbXBTeUhYYk9KT2EwdFdLc0l4QVJFTmxwWlJvdlJ0bDJqaWV3UUY5T2g5MGZwUWxiemxMUlBmcWJ4K0tqYjhORHFiNlNCdHlhc1dsOXRmL1hoOEh1a3ZualRhRURBYnppVVlEMTJNNmFBNXNKRTFFUkhUUzVHV09YdDZWUHU4SWU1VFpoNXpMclllZjdrUmd6VVpuY3Yyc2d5dmRwdURVdThlRGVuNnROOHpXOTVTUENGWTFWcy9MNFFPUStzUERjTW00RkRxZDVkRTRSOUpwMURsbGZIaXpRUlRzN0R5N1g2NjZkZXVGOWJJTmM0SUQ5SW1JaUlpSWlJaUlhQVFOeXJKeTMyNVZ5czQwRk1UdHZYekxEME5LM3pJWCtEQ1QxSVhJWFk3MXU5bGlqNkU0L2M5TEdWMVlnWXVyc0VrZEp1d0hpVDlPcWFNR3p0aW9BbHNaOThOMFdRZVBxei9NeEFmRDZIQVJ4RERCNDdRTmxXbVU2Y3dRb21zU3JKbUtENTRxWlZrVmp4RUs0d2JEWFVNaXc0MWxpQTRWcFA2NS9qcXd0emxibUFDNWRDMVQ5WTk3SnBMbkxQQ1l4Y09aREVmbmdRNVh4emMzb1pSOTcvM2E1djQ4RGZ3ODFmQ2l0dEdwajJTKzl2WStyaktkUnN1SlpmbmJTcjAvR0tuSDhjOWo3K3VxTnRQdzRVanhZRjJWZFhZb3BlMTZmYmlNS3pTREpPN0tldlg0WmR2cnYzOGQxb08vLzczcGw3a2JQMDgxZU16c3d6WHRXcGVTSGVJTkdJaEdnUm0wRVRONm0vdCtZTkdScnhBYmpLUCtLOVdsUnZkdU91WU80Tzk5YUl4TFpCK25PNU1HVE5semdjbXRNNWs3SXZYQ2o4czRQZGd3c1kySzBXNVFkY2hpaDBEbVlDSS9QUTJDcXNqaFI1aG5HUG84bFVQUXhKV295Mis5R1phb09mbWVkaGVIZHRHOWRZaGxYR0lmaEdYUWtHM1JMSHhiV2VpQnNwNTQ2QzJxV25yNGhGMUtJeVNCd1pnY1ptcEFUVkRSRTdwSEtCcXdjWUJRNWxGVnhrWHpKV2YwdmsveTkybnA5MlE0YlZsR21kSDgyQUkxV1U1cjZPTEV1eWlyVnRtVXhWa2lrZms5VmxvZi9sU1huY3JwOWZmb3ZiU2dweXhHVGxOd09PdGNJcjh6MlJwcnUvYW1oUS9LMHZWTjF6OGQxelVacnhVdVZ5SWlJcUxSZFd3Q2pDNWR2bFFKNi9pVWczc3hNTzVuSE1vUHkrSDBDeHZIMFpzVGlnNjhiTUY5ZkZEYzlSUDlPZzBwOGdodCs2ZC81Zk9aak85dnlhT2JRV0QvUzYwRCtjMi8vc28xRU5Gam1aNlp4Zk12dklpYk42NWpaWGtKbzBZYjUraWRzZk04UjYxV1E1d2tPR215dE9mdkxyNnllQWRFUk50eHZqRmhpWVU3TjVCVXFxaVBUZlNEN0lMOXJYZlIyc0ZxdGVZYkFWYmtlenVkam15M093eWcyMFQzeGM4OCt5R01OeWRBUkVSRVJFUkVveU9RYytyVHAwOWpjWEVSS3lzckQ3eWVaWmsvOTUyZm4wY1VSUmdmSDMvbzhNYVNHQzgvT1lOclMyMTgrL29DbHVkWHNicTRoak1YcGxHcEpRamkyQWNGemM5M1VCUWw4bXo3Y0tTeHNRcEN2YXF0SHZhRGpZdmhoWjQ3clV1U0NweWxsUTQ2M1Z5R2Ziam45MXJtMFZ0ZTlYMjlZUGJVZUJWbm16WE0xaFBFandndzBuSmxMYU5ZV2xyQzJ0cmFsdTlwTkJxWW1KaEFIUE9HclVSRVJFUkVSRVJFTkhvS0UvcnV2Y3FIRWJzdTZzVXFxdExWeWhiaXNnT05JOWxLNlVOd0xGWnNEVDM1L0xkNlRmU2tMTERyN2w1T3YxWkd1RlUwTUduYnFOc01VMEViaVNsUU1kdTMwL1VCU0ZMR2VMdW8rNUNlYTNrVDAva3BUTWROdU1ZWnhHZWVSelQxQkZ5Um9mditOMUYybHBIZGZOTzNIQzJMZE52aEJvMXAyTGlHNU1tUHd5UjF4TFBQYnJ3V24vdUk3MGV6ejBnWllvN3V1My9naDUvTnZZdUhNVUdFYU9acDJNb1k0ck12d0ZhYkNHcDNyKzlwL1BDZjhQMVV4cTlvTHlIOTRGdHdhUmRGZDJYTDRXbEpxb2IxckpnYTdwZ0pmR0JucEp0RkI3RThmM2UrL2xyOGt4aHphM2l4dUlxbWErRmNPWStLMHdpZXJjT1NVb1N5akdJWlpoTnpkZ0p2QmVkOUdKQStyOWZoM3phVDhtK0o3d1RQNEVKeEMwK1Z0M0RLTGNsM3RCRzYzQWNjYlVXRGY3Ujd5NTd6dzN2TG50OFlUdzB2bWcvSFVYTlBvNDRlbmltdlk2WmN4cE15L0FnUEw0KyticWQ5dU5CcndYUHl6Z0EzN2VUR2E5OExudkxkN0dEOFhpcmVSdUl5R2ZiMjF6ZHIrSkdHRnIwdDQ5bVRiLzltK0p4TWV6L0FhTjF2Ulovdy9aZUt0OUJ3SFR4WGZJQkFXL25LSjdaak5WQkhPbDJuZFAzUzlRY2FOaFNFQ0FiRi9kSE1VeWpUTmpvLytMTHZGd3ZYL0RybXRyc1JxUTBRSkEzNS9HbS9yb2VUVHlLbzM1Mys2dk0vN2orYlBQbkRmcDNxWGZzMml0WThpclY1UEl5dTg2R080MmtacGd4Yk94TlZnTzkrQjZtdDROdTlNL0s3ek5Hd1BVellEaWFETHFwRzVwSjVlUG4rVWxGQngwVzRtWS9KYnorNjUvZmZLbU44a0kvajQrRVpURXllQWVyeSs2aEcvZlYvbStzQ2ZWaVR6SVBraVkvN01Lakswei9XRDRFS1dmNU9kSkJzWUZKclRCRW1wZzFqWkhkdlp1UnBEY2lZd2VnWjEvWm5VYzFmQzUyVkxsaDBtbWlVbGFZb1hOV1Zjdmh6VEFKM0RvLzdGZDNQL3MxM2wvL1BINitINS8vMGRBVjB2RnhvUWc5R1hwYkR4WitSQThQLytQN1g1WERoZnltNzl2ZXVydUxMRys5MStEazV3UHhUY25RNkt6L0JzVTE1aHEvS0ljT2k5RzlzOFQwdlMwOC8venNQaklURC8xdUc4ZC9xNTY4dVkvSENHRDRucHdyblpiRC9oYy9pQk02dE4zbVYwNG0vSTcwdmxrMzVudVY3NDFxZUhNTmZsa09ML3dZUCt0dXlKYmp5L2pMK0FmYmdJbENSNzZ2S2ZQamZ5OC9od3pJc1BSR282MnNia1cvM1JiK3RaOGZLZFA4bk1nKy9MNC8vbmh5aVhyKzZnTmUzK283elk1Z09MUDRMR2Ziejh2Q1NETzkzcGYrN3RzRHZiemRlVHpid01SUGdUOHFmZjBHNmw4Mm15eVBNL1g4TStuYlFmN3VKZjNCQjVvbk03NytOSFRoYndRVTVmUHRMK2oyRDc5dUpaN1NUci95cEM4MXQzdUh3MnpKdXZ5S0gvSysvMzhiMXJkN3lzT1VxM2VKT3AyR2RUTXRUTWkyZktIVTlCdjZVZlA4WU5QREpiWkg1TzNpOGZ0aGN6L0IvcURYOWlkbi9yQ2l4K3NFcTNzUXV5SHp3ODBTbSsrZGwyRCs3K1RYNWltL0sxLzM4K25vaTcvWExWWjdYK1g3QnYyZWI5VzNUY3YzUDVJM3pNazkrRlVSRVJFUTBFa1k2d09qVGYrL1RVMG1leDZHTEw2TE01ZVF0ZkNrd2VFYUtacWJsSkxPR294MlNyYmNuMERMeVdUM1ZMTXZ5azZaMCtVLy84cVVaT1FIcHBsSjNvU2VkcjF4K2hUbWhSTHVrRFdlcXRacnZqeXJmQUdkd2gyeTlvL242M2JDUHUvWGdqeUxQa0dlN0R1WW1vaFBLMzdHc2NMTGRTQkZLeGI4NXdHMm1mazhZQm42Zm93MEVkWnZkMzVTZDdNckJNQWlSSkJVRTRiSEpTeVVpSWlJaW9pSFFPL1phRStpLzJLMXlVRzUwRW5OajlmNkk1UUhlVzFQTElyWFRNS1B0d25wN3ZkNk9RbnoxOUR5VVljVlNlVk9OWkhqeWhBWVdhVkJSbHViKzd0WkYwUzhMMWJDZXJjZkg5TSsvWlJpYVdhemZPOHdBWVczc291T1FsN252SDNZNHNROHRLdnJ6dzhpNGhETDlpY3k3bW5SUjhPamZqcFpQckFkTmJVZVhieWpuN0NlaHpKbUlpSWlJaUlpSWlJNDNMZC9UQUIxckt4cFBoTnlFc0s2VVV1Z1M5NWVxYXJCTUtXV1NHbDZTRmdhNXZLZDBENGF5YU5HYVJ1QjB5eENyU05BMUJYcURsclAybm5DVWZ2bGE2Z0xrenFKZFJINTh0aXlhMDgvcmpkbHFFejd3eEUwK0llOTFzR25iajZiYkZMcWtZU2c2N0tBK0JSTlhmWkNMaWFwYlRqK0N5QTh2R0p2MUFVWStaRWJMVUl2ZUZxTVErVkFWZmE4R0k1bXc0ais3RmYxZUsvTW1hSjZGeTdvd3ZTYkt6Z0k2NlNvV3BLeDIzcVNEK2EraFFGV3N5ZnhmUmgxdFZHVGVCVDRzNm40Ni96WG9xQnpNeDRvTUkvSmhRejVhYXVOOU9nODEycWhqRWl6WnV2OU10akhNZTRlcnorbjdGazNEZjNJVlZWbGk2ZURkOXk0ckRablM5N1p0Z2xVWlprZmVXUmk3eFhoYVA0U1dETXNZTGFQdGo2T0dEdDFQMXpRZHhweHRvb2ZZaHczcGRHNUY1NHNHTzgyYmNRU3lUdWwzV0ZsV3dSYmhTQnBVcE9PaDA5WHpNVTg2UlZzUFZ3T1pTbWR3MDB3aGxPRldYVzlqbnRxZ2drTEtnbDNqRk1KbVRaWjczUWNZYVhDVlRScjk5ZEpzMGFKWm5nL3EwN0x1Tlh6RFpyOXVGZW1nM1BudWZPMkg5OGh2VHRaUjI1anVyNnZCTnRkdXkvTzYzdW42cCt1aHZoYytHQ20vNzl2dDRMMnlEdGFhZmx4MVhjVVd5MHJYcFV4K2UvcWJEcVR1SVpYM2FIaVZybC9tdnQrL3poR2RUNjFTMWhBWCt0OXM2Yll1SXkvbHQxS0U4djFqTXQ4YXNoNTB4M1VtM0RldS9ib0xuWjkrSHVqMDYyOTN5M2xLUkVNbFAyZmpmOVpHZjVTQi9PUUNHL2pmcFA0QW83dVJETWVDYnZ4OHFwMU9ualdsZFlFUGU4aWQ4MXZsUVNVNjRrR2Zkc1BoZkZhNldkQ0o5V1FONStTMFlEWXM4TU55YUtBSDZCVzlOQUZEVkhZeExkOVRsZTNXQzZiRTAvTDdyY2hQTlRuRW93WDk2a0FPaWM3SnFjTUZtZDRucE5QZndjN1RGMlUreVlaNHlwWXkzNEFKbWI2bFRodXJjNUREOFlIelkzaGVadVMwYktqT3l2Q25CNS9yeWZ0WEEvUGdBZkRaczZqWkZwNlExejlrK2lGQmsvZCtaWC9ZQmo1b1J6ZjAyaVpYRGlweE4rR3p4Q205SkVXL1cwNHpPdGM3ZUI4bndKa0dabVc2ejh0TStxak1sOU95NHdqWGR3Y3kvLzBCckx5K3NXeWNMbXNuODgzNGpDQTlKZEZsTHdmMmVGa09aMi9QQURmazZEdS9Camw5ZVh4R0R0UERJTU9FQm43SmQ3MGc0L2VrUEo5Z2h6OENmYjhjOTA5cjJGaGJUbzNtNXU1T0N4RVJFUkVkVFNQZG9yaVdCNSt3UVhoR0Rwb3Z5Mm1IVEV0NXZ0OWUzQUJIdnR4WGFndjh5SnFmMUgvbEFQelBPMmVraHFmOHVweUZ2UmJtOXRmekJGZmtwU3Nnb2wxcE5pZHc0Y0pGek10WktYQUhvNmlVa2lEdGVyMStJNkZLdFhvaUdwUG90T29Hc2JXNk5OUTdxQlBSTVNmYmppenRTaTlIdGRaQVZTKzZBUFo5dTdtNVFXZFZ0dE5yYTJ1eTNVNlJaZW1KYkZDN1diM1J3T25UWjFDcDhLNGtSRVJFUkVSMFZ4QkVTS0txbkVzRnUvNXM0UWFOUmtxY09JRjFTTXQraU5GKzZ3ZjFob2pqR0xWYXpRY1ZwZW05ZHdEWDhONzUrWG5VNjNYTXpEejhwcVdCTlJpcmhKZ3BFbHlZYXVER2Noc3JhWTdXY2hmZFRnNVRONzdCUTVadVh4WllxMnBZc1F5bkh2YkRpOHJoclFUT044UUkwSmJwYkszSitYenBEdjJjdmt3elA0M2FELzM4aXpEYnFQajV0eE90VnN0Mzl5ODNwY3RYeXpLU0pFRkR6dDMxYnlJaUlpSWlJaUlpb2xHV21RUlprS0FWVFBqSEdycWp3U1ZKMlhrZ3dDVFY5OW9FcVpRSDV2SmZEKzhqdjI5NFB2QmN1c1dpNWgvZkxNWjh2Mkx5L25EdDNVOW8rSWtHMkhRSFlTaWJGZmNGbzVpbzRpOXRyenp4dzNlL1M2OFRiYzM1dmdiRXJOTmdHUk9Fc0pXeExVTmJOZ3ZIVC9YN3pkTjN4NnZiUXJFMi84QjdnOFpNUDNBbVN2QW8wZFNUdnArYy9VZy9GRW5HYi9WYmIrRjZmQnQvY09jRGZKRDE3OCtyWVQwMzdTUjJRb04ydmhjOHRmRzQ2bElmelZOelhSL1BvM1NKYVNCVlYxN1JrS0dIY1RMdk0rbXUyVm5mclp0d0xSOGpGRzhLSE5Ld29KNHNmdzBENnBtSDN4eTFaMklmUnJRYzNGc21lNzZjZStDOUxWTkZWOTZ2dzNlUHVIbkRvdEhsT1lZYnRsK3VMbXVqRDNCcXVyVUgzbnZITkdWOTNkbE5YTiswVC9oV3ZkL0Nzd2hrL2EvcjJNdTA2L0NmcWRjd1cwL3c1NTcvSVRUT1RDQVlQLzNJNGZtUUsrbXF6MzFtNDdteTE0THJyY0hsR3A1L3R6dy9xRTMwZzdtU2g1ZGZhN0NQQm5KQnVuQ3dicWxjMS8vZXZkTnZBdm4rK3FRdnV6Zmh3K2VCQmhGcHQxejJBNzU4Y0pYODBHbzI5VUZHbTJrZ1dkZnRiSjdteVRnNmpRdElYdmhKTkU2ZGt0L1VTdi8zMmxuWk5FMWgvM2RhSGQ4K1lJeUloc3IwYyt4Y1lHMnZuMTlvbDYwMU5hbnUwaDJHL3NDMWZkeWpkM0tqeFZlMytndzd2ZG5MSU16T2xaQ05wOHZLd2hWU3JSaVVSVG5qNjFIWi9HSjNEUDc4MmdtOC9vRDZTb09HamZCejF1RjVPWlQvai95VCs5RDBRRTQvUGkzRHJjcFA5RzlLZjJhZnZtYkhYcFR0WmFzcGg0eE9wdDNnMzVFanB1ZWxHOXZWUUF6T3lUU2NrL24yU1JuT1YrV3dkU29ad3l0WXZSc3NFOGc4bFovWG1MenZUMjM2NUx4c3k5L1VyTkw3QjZuaFJmb1pIUjk1ZU9uQnI1VFA5Zk1ybDZXTDVYRmQrbWVsTzdmeEhvcy9XL1lEa2lJNVJQeStQUFgzY016SkROQjdZVjB5RHBma0ZQU3Y2YnJWYjBmVGYxMzZjaER2NS9kMzFqOGo3ejJyeTFDZXIva0FLSU16ZzVmK0gvTGFxN1VtM3BkMVl4NUxqOSttV2ZOZ1pSekdaSncrTFEvL3BJeldVMjd3TzlncCtleS9ONWljMzZwbFdKVCtxeUFpSWlLaUkyMmtBb3d1WGI1VWtVUGppVERBUlNsWW1UQ20rTHdjaFVxTmcxN2lMblZPR0hIOWxON1RnVE1mbG5Lakw4aUo4SlUvL3N1WHJzZ0oySlcwbE1QK051WmV1ZnhLRGlKNnFFZ2IxOVRyQ0lQZE40UTZhb29pOTNkd0tZdTRmKytZUTI1UW9nRkRQbHhwbjFyeDVHblBENy9mVUlpM0FDQ2kzZWczWU5UdFpwYjFFRWJKWXdVWStZcTh3WFpvcDhNSi9RVVQydkN5OU52TDRnUUhzV2x3MFhoekFuRzBzNHMraU9oa01yemxFeEVSMFluVHFFemd6TVJUbUZ1NUxnWGVPMU1NenMxVzAzNy9KSjVxNlYyNGs4RDVFS2VEc2g3V3ErZTM5d2ZoNlBteVBwL25PYnJkcmc4ODB1NWhZcW5ZbWFvbFdPNm02R1lGc2pTVFpWa2lHSnhMYnowTzFwK1RSNUVHQ0dQbzVZVytJWktzVDcwc2s3S0VzbDhXZ01QakJnbFZSZHEvaTdYT2xXb1U0SFNqaWtieTZPcTg5YktNVEtaSGw4dFdkTGxxZUZIRTgzVWlJaUlpSWlJaUlqcW0zS0M4TVRjUnpIMWxpbzhLbUhtWWZpQ1JrV0hldlM1VkE0eWN2MVlJZStLdlNkSmdJNmNKOXZIZEY4TFloOExzdFdtemhxcVlwUDdnOHpZQzluSU5xdWtId1JkQmpDeW9vbU1yYUE5ZUtoK2orWFh1STJiNldSUEJvSFRXRFo3UEhxT0pROWZISWxucGdudStTNGRaUE1iNHR2SGdqZHpTeHhobVAyb3IzSEs0ZTUydnBTd3JEZlFwMFErWDZwZ0t1amFSOWF6cTE3VTlzMkYvWFEwaW41cXhRUitidmYrdWJGakJBN2tSc3E3NWJnL3Jxdi85YXptNXN3L013ZUl4ZnY4Nm5SckN0UGwzNWEvblhoOVhva2VRK2h1L0V4bjBqd1duRTJOUTJzRDZTaW16eFlWZ3ptMzhGRGU5NWtKNVBwUmFyUUIzWDlkOVlxNGJHR1BzNW9wSjNmRktaM1NIWWF4eGZtY3BQN3ZBNzBPdHFjblhKc1loS0kwOHdyR1p2WSttODBLcVdtV21GSUhPSXd6U25iUlZuVE9aek45Y25pN1J2NWVNekNKZFhHYkhVVDN5ZnRuS0dZZUhMRmQ5ai93VHlCZkVndzhSalF6NTFkUUc2K3pMc2tlZjNZL1YxK2xCYm9tR2JNRitTQjQyNVR1clIyRXJ0VnpGcWJERWo1VVdMOHF2ZkFvR213OW1OQUgwbW5RdCthMWZYMzlTeGoweVBrWU5UOG43WTVtNGM1cytvMm1tTDhzVzRaM3p3THlyb2lhZjFhM1I4ekw4eEIrZTZXR3FIS0pCRDFWTDlGYURlN2NZWnl0NFNqWlN6d3crYy9hZXpibkRhNEEvL2ZnZDlDK0xXSk41cW5lN3JzaDRmVVNlKzRoODVrUHlHWCt3SzMvSDh2enpPb2p6WTNnZXE1ai9RTVpycTNuUnJXSTVLUEJ0K1hQTll1TVVCNXVtV3hNOUoyUllHMm1wOHZlcVBMOHEwL0V0K2ZzV3R2YWF6TlhyTXNQYUR3NTFxT0tzaG1iczhPbEI4Tk5tVjV5ZXJqaDhROFp6UmNiMzdmVVg1UEcwek1kWm1lWWZsV2w1d3ZXbjBhOEg4dmVzTFgwWTBoczZERHdtR1U1VGxzbkhaTGpQNmZvbWo5dXlySy9MOS85QXZxd3IzM3R6NDczOUVNSkpHY0duNWIzOWRXM1RTYkU4OTJuWmtiMEZCaGdSRVJFUkhYa2pGV0FrSmtLREY2U2k1ay9Md2VwTFVvVHljWDFPWHpnbVpSMjZQRjV3eHIwZ0pUbGZrSW02SW9mWjc1WE8vWHBvZ3Rla1JPNzNBVERBaU9nUnRHSE45UFNNRDA4WWRWbWUrWVpBbFVyL1RqTGhvUWNZRmI3QlVwSHZ6NllvN1hXUVoybi9qajBNTUNLaVhkRFNhQjllbFBiOFk2dDNOM3FNYmFZMldkUUFJaDNHb3dLTXpPQzJMdXY3blg3WVc0bE9aMzlMbkkreVJtTU1aOCtkUTdWZUJ4RVJFUkVSMGJxWnNiT3c1a2Z4L3Z4YnVMRjBaVWVmS2JUZGhoUVR6Ylg3eVVYbENTd3k2a2xaV1dSTFpBZVlZQlRITVNZbUp2eTU4ZHJhZzNkLzFqSkxEY3JSMTdRODlsRUJSbU5KNUx2VlhvcGVWbUMxbXlJdk5aZ3A5RmMwaDVVSGI0WWFSWUh2NnJWQTFodURjcWpwVmYwR04zbVpZM20xT3doVXg2SFNZR1lkaWJ6VER4OEtBNHRhSE9IRHA1dUlna2VYY1dqWmlDNlhkcnU5NVRKVEdsdzBQajd1eXpDQ1kzQURBQ0lpSWlJaUlpSWlvdnM1bjNFQXBFTU9GY2tHN1hxemNvakRsWEVOcWswTW00a3FDS1BoWFQrcnVSRUlMWXFvZ1RTUjhsMjdna1g3K0UwUU1oUDZGdEpkRTJPWXVtWlEzanprRnVLTHRvRmh5clhaZ05GMWRYaUI4eHJTNWVmbllKNnVCbU9vaHduS3l2aGpyV3RXMTZkbytOZGsyMHBEeG5oNDg3VWNCSGgweXVHdVUxWURvTFFmODFvNDJodm5ZMlhjc2FxWXNkWVcxdGdpU095Q05UNGQ1OEdnbTlJbjFlbU5rOHU3ejVtNlBGSFhON3RON2Rrc1RDWVZncW14WnVudWQ4Z2oyUWs1NndNTkFtTmNaUHFwYWVzLzh1cjZMZlJPVUhTUkovT2xxb2NtL2VrMjJMeGJsanJEbnZ5enBrRkdlajhYcVlJTTVMSG1PdTY0QVlnTVA5UzdjRnZaL2QvL21pNVhwemtTcFl0azJVYXV3SlMvMGNySnZlY3JqU0JaaDJkazI2WGJwcitBZldwYks3L1BtbXpjVHNtZlB5bmRNOFp2c3c2Zi9LNWZsTzNxWDVQeGVjWUh4ZHo3c29iSWZVTm0wQTNacnY4UEc4K1dxTW5XTjVINTlwZU13NWc4c3puQTZCbnB6c2dtNllwcFlsSGVlMWFtVzZmMTB2ckdlUkJlMUVZL2ZLZ2RMZDI3UFlvU2ZFSmUrK2ptejZ4ekJ2OUtubnJ6NmpKKzlmNXB1ZERFVDBudnArUTlmMG5lYzZIL1pVams3MHN5L21jRGcxZlJsRzU1NndDanhVVXNMd0wvRXR1NE1JNS9oSDVvMDBhQWtjeURPL0xQTy9MYzM1ZHgraUlPa1V4L3Zjd3hJOVAvbDNGMzM5am44RzJaQnpka1BQKzJuTXJOdnlQVHV2N1NSYUJTTm1VWmxmaDVlZml6R2pDMEhtUWxmNS9TOVVOZSs2Znk4Ri9nOFkzTHNQK2toaWJwVjh2d3Z5djlHekw4WDVOMTRhck13OTlkZitPVE5aeVRVNk1Yb2I5TGc3OGd1NVpBTHlmYW1DU2RUb2V2eTUrL0JpSWlJaUk2MG81OGdOSFBYZjY1V2lkWk9tTkMreW5uaXVla3RPblREdWFpVC9kMHFCenprcVlabVU2WlJ2cy90Njc0MmFEdWZ2TW5mK1hIMjdWVzh4OFg4MFh4bS8vWDMreUJpQjdRR0J2REdTa1BxZFZxMkE5TEMvTklLbFdjT2ZjRTlwMFB3WGMrQkVNcmdjZWJ3NitzM28zTzJocHUzNzZKMXVveWhra0RrVFI0Uk1PTDhpeGpBRDhSN1ZtZVoxSzNXU0t1MXZ4MmM2K044ZHF0Rmo2NGR0VUg0alhHeG5mMVdXMjQ2VzlaSXNlcDJ0Q3oxeHU5UTdhMTFpcTZld2hnQ3NMUU40S3NOOGFrYXlBTWgzZUJEUkVkUCs3RVhUcENSRVJFamFTSk1Jang0dmtmUTZQU3hMZmYrd3F5SXBYenVPMnZabHpxOVlON1RtSncwV0hTb0J1VkpJbnZOTlRjM1pmd284L056ODlqYW1yS3YyY25JY0JueHFwb3lMQmZ2N1dFdFRSSDF1NzR6NWpBK3JzVld6bVBEOFBBaC9kVUt5SGl5UHBnbngzZkRuUUh0QUdIVHNyeWFnZWxyRmhsY2JncjEvcDh6VHNkT0NsSDBEQ2xNREI0ZHFhQldod2lrZm14azR6bWJyZUxwYVVsMzkrS0xoOWRUaHBncEFGVlJFUkVSRVJFUkVSRVJFUkV0UCtLb2dpTHNyREg2bElwNHdKb21wQTFVNFBKZXFEQ3pReW0yR29jd2pyblFqZ1R5aFAzWE53cmI0ejZ3N1FiejF2L3ROTzdrbWlRa1Fid0dGNXU5bWd5cXhJL2Y2M1JTbFlOSWRLVUorT00yWEdWcTh4c3JmZ2Q1RXpkOTVyMWwwZkxnS1ZxVi80Y1pEc1dVc2NwbmQ3L1ZSU3U0aXRsNlVESmIwVGJpTlprYTNQazI0b2VPb2VYWk9VdUJwYzNYSmZ1VzdMRzM5WndtckxFdkR6ZjJuaHZnZGRqaTkzZkFkN2d2UHo3by9KZE5iODFjL2dmcEw4bTMvT21kTzFTZzNEV3Z5TEFONE1VdDRJMk90Z241OGN3YlFMOGtDM3hTZG15dnFoQlJQZjh3QjIrS3YvZWtkZi9LM2s5TFhPOHR6RitEb0dNdjk1ZityYThMNUhobkpQM05EUTBTUHFSNlUvajUrVTk1MlRlVGNoSDF1OWdwZFB6Ry9MYUZYbnRqK1Q3M3NZeTNyM1REMHJhVElPa0p1OTc3b3A4bDM3Zmx3cmdlMXROazh2d3VvbXdLQnViVDVZT1ZmbHVEY214L2NuQnRIU1g1SUdHRjcySzQrbEhaYzk1UnRjeFdRNkJYNTBkVXZrN2sybi9va3o3RzRQd29uc2FoVnpSZk41bGxPZWIrRmRSaWJkS2k3K0w5V1ZtRU10d1ptVVl6ejh4Z1V1eU1ibHlaVWsvc21mYXNQT2lqTmROOU1PaWZzZmxlRDJ2NFAyd2czc2FKc3I2djFEVThIb1o0aXNCL0RyMWI2TWZmRFFZTmN6S01qNXpjUUlYOWI1cEg2eHVIVXhGUkVSRVJJZnZ5SitVdHBxdE9NcktjU25sK0lTVU5uMUVEb0IvUnA4M0o2SGdxWDh5MTVDemh6TWFTUzRGU1hxaTJwSjU4dDhEL3VTWEFVWkVXMWkvZTNRWTdVOGpEQTBUS3N0aE5wbDVCQ2s1eUxMOGtZMS9Ea0thcFZoZVd0eTJFY3hlNmZ6c2h4Z1Y4amZqOTRsbzc3UlJvOTR1UkJ2OFNWSDVJRWhvOTl0UDNkNHRMUzVnYkpmaFJXcTlrYWNQWnBOdDJ5Z0dHS1V5em52WjF1dTgxdjF3dnpzU040b2dJaUlpSXFJakpJbXF2anM3K1RRQ0crTE42NjhpTHpNOExNMjZsenQwY3FZWEhUUTl2OU9RbS9VdUg1VGRiYVpsZXUxMkc0M0d6dStPM0t3a3FNY1IzbDFvb1pNVnlOTE1CeGZKeVh6L0RZR0c5UmhFY1NEZmEyVjlzU2lMSVpjWHlyUnBjRkdubXo4UXluU1lTaWtETHJQTS94M0tQRGsxSnIrWDBQb3dvNTNJNUxPdFZzc3ZxNjNvTWczRDBBY3ZINFd5WmlJaUlpSWlJaUlpSWlJaW9wUEF3UVdsSy9kMk44NGp5dmc3bEVpVnIwWDlrZTk5eUtOTndzRnI4ZjJmN24vQ25ZdzJaTU1SeWVMcFg4aThFU0cwMit3bnM0TjM5TjhUOUw5REtsMU5VZVF1TjRVR0o3bFluckJIcUNyMlpEQ1FtbmJFSnJjTWozb0VZM0ZPMXRyMVJtRjZ3ZnlyenVBZDZiOGovU3ZYaGhPTW9rRStUOHZ3NnY3WFl2QzYwUkFYZzYva3pvZXZ2SWtERkJhSW5jWHo4ck44UnFiOTNQMC9UeG5QOTR5RzFiVHdldzhaakE4MXV0REVkZE1QSExwZ2ZFNGRFdW0vSVAxWkdiWmVRTEorQjJRL2IwdUhiMTliOGVFMTIzbFp1c3E5STRUYjBIRXE4WU1QV2x2UHEvZmJQbnpxK3BQak1qNEdGMlNhSnMxNmdGRi9uSFI2cDNGOFBXMzdvVTNKeGxiYm9KQy9VNW51dCtUUnErOHNZbFg2OXplQTFJdHc5QktnYndlQkR5ZGF3OTBBS1N1ZkhaUCtyUHp4dkh4UVAzOEZlMlQ2Z1lYVHNqeDBuZm0yL1AybDk5Zndxdi9HKzF6UjlVV1c2WVV4dkMxTDhheTgvelBZdFB3RzR6VXUrNWJwcUg5VXhRQWpJaUlpb2lQcXlBWVlmZlp2ZmZaQ1ZFWnhtSmQvQ3lZY2s0UExGNDF4NDlobHNjbHhJZ2YrbjlWK1dCVC9CQTN6M2svOXltZi9XNHR5N29zLy83VTNjSWgrOHYvNGsrZExXMWJqcUx4UXdtbEw5YWVscXhwbnpqdmpZbU5OTE10dnhzQTFkek5jT2JHNFpmUWtxVFMzTmIxWWhuMVRBNXkwa3hPWE94bUNaVGt4ZWVPVnk2OE1OMG1GUmw0UWhMQTJ3TVRrSkdaUG5jYml3dnkyalRiMnpHQ2prY2RCTkhKWkQwelM4S1QrbmJJck9FamFTT2phdGZmOHZMeDk4enF5SWMvUEl1dWhzOWJxQjQ0UUVRMUJUN2FYV2RwRGZYeEN0dGU3ci9kZFdWN0NkNzcxUno2RUtKWGhURTNQSUk2VFhRMUQzeCtHa2Q4dlpWa3EyL0RPa1dvWXVaVTh6L3crYzYvam1WUXFlUExDUll3M0owQkVSRVJFUkhTL3ZNaFFsRG11emY4QVA3anhSMWpydGVUeHc4dUR4bUtEU21ndzN6bkFRSEhhb0dFM1UxTlRjbTZjUGhCZ3BQUzV0YlUxek0zTllXeHNETFZhN2FIRGl3S0RNQWp3a2ROTmRQTUMzN2c2NTh0YU14bEdFRWR5SHEyaFJTSEdhb0cvdW5LWTRVWDltM3dhTEsxMDVUeGRxaDZLd3oxSDEzTnZWNVFvZXIxQmVKR2NqNWRTR1hhbWlWam13Mnlqc3FPZ0lWMEdXdWFnWVZMYWJSVytyMlhLRXhNVFBteks4bnBWSWlJaUlpSWlJaUlpSWlJaTJtZUoxTTdWcFB1TFJSc1ZsRGkzS1QraExYVjJQZWwrM1ZTeFpDeXVtLzNQZDRwa1hMUUIzV2ZMSG1aY2laZVJicnlXeXJpc1NmZUdDZkY5NmQ2VnJnM1dxZTJVMUhzR3hocGpBNW5OVWhkcFE2TUxPODE2emkvME1pOFB0dkhMaVdVYnpwWFBsakM3YXJ0M0lqbDhWTHFPVk5uL1IvSkxYNVNxK2xmTEFOMmloYzRkb0lQaE9JdCtLTXovWFg0SmI3a1VYNUxmeUpwVTZhOG0vUUNaQTFWYVRCdUhuNU5OM2NYTno4czhtRGRBcnl6eFg4dFkvV0JIdzNMNHV6TC9mbGgrN2k5dkRBYzRKYjFwSFpaZUNtRU0vbDE1WDZ2TThLVk9CU3RiRGVmaUJDNW1oUSt1MDNsMXowWlhodk9XZlA2cnN1dFl3aVBJZDc5cCtxRkpzK2lIM0tpYVBQKzhmUDdpa3pXY3k5dFl1cUc3bjJORTV2TlB5SFNQMzlQVTJ1RzZQSDYzTUxoOWJYbkw4S0lOTjF0WXZnaXNsaFA0cG56dUZuQjNlYUsvN3I0c243Nk94ek12dy82YTlQK05qTmYveDA3SzhKWWYvZ0dUNGJwTDhLcE0xdW9EUVZ1eWZPWDVsMTN1MTlVcklDSWlJcUlqNmNnR0dGVkMyN0NsbklRWTk2TUdSbHVMbnpuSjRVWEsrWG5nazZxcjhtakN3UDZtS1l0RFAzblM4S0lvUktORWNjYVpvQ0Zuak0vNXhGeUQ1MlJjSzNMYVdURW9uNVF4bjlyTmNBMmNwdmZtenVCYUFiTmdEUm95RDVhY2NVc3dwZ3dkekpBamFlaVlXRytBb1hjR3IxVDJyNnhURzQ4Y1ZCQ0Y2NWZkYnRsSTZDQm9RN0wyMmhxNjdRNjYzZUZuaG1tam1yTElwU0NMTWZ0RU5Cd2FQT1N3OTIxS1Q3WjEybW5EUDkzdWxjWHVHOG9HUWJEUjBMQ1U3ZWhCQnQvdGxkOGVsM3R2Rkt5MzA2blY2b2lpQ0VSRWoyTEFZejhpSXFLVFJzL1RTbGRncmJlQzVjNkNmd2FQT0NZSXBXQ1lkOU04UEhwdW15VEpRME52dE14U0E0NTJjcjVyYlg5aGpsVmlWT1g4MDVleFFpOWFMV0REME5jQ0JmSWVEVEp5OHZwd1Q2RjlLajNTckVDUkg0RmpVYi82T3ovdDVhWXc0WEdaTjJGZ2tJUTd1MUJiUDZkaHhGbVdiVnQrclBOWnk4czNsMVVRRVJFUkVSRVJFUkVSRVJFUjdSZHRyRmFYZXF4bmtVdS9sUDdkZXF4bFdIU2w3dTYzalVQdmdLNGgwOXBPclgwN0plTnlYc2JsNHk3YmVLMGo0N0lpNzJoSi82WUpFT2tvc1VwdHgweS8wamZ3OVpEOS8xUDV0elNta0FwZnpzbUQ0MkpaR0xGVTdlOS9JdGpvMDNDV2pySDRWbFppOVhvSDcyUDRxdHJKRCtBOTJieDhhNnlIcTY5alUzTGFBWk5ObTdiTlBZZTdBVC85NStIejVMb2FYdlJCQjlkMk1peHI4S1pzVXlmTGU0Zmo3M2JsK3RzQWJlNzVxZ3d6OWZOMm0waW9Ja2NqNkk5WDlmNHRSV213SkUvZFRpMHlQR3JhSEZibDg0djNQTmZmNUkvSkh6VkVxR1F6OG5nT3g0cHNjay9KTnZiK1JwUGE0Rzh4S256L1VjMXUweXZ5endVTmlUSkk3aHQyeGVudnhQcjFlTytjWDcrdW14SlhyNjdnblVlRkYzbTJQdzF1aS9FMy9jT0x5ZUp4eDR1SWlJaUk5dFdSQ3pENnFWLzU3T2VNc1JxQTg0dXc1WlFjV2piWnBQRUJUWmt2bjVUNThzOWNFTC8xVTcveSthL0lhZHYvODNkLy9pdGZ4ajc1d3QrL2RERXJpcHFjMVAyTWdUa2pKeUl2T0xpTE1oN1NsWFY1UzJqa1hHN2pmUEdlRThlOWx0NlpwMXgvV00vYVFhRmsvN3I2d2JEazdDVWV3OHBQLzhybjlmejJsZGZLZjRPTDNXZVJsSlVuSzJVTlJHZk9udk4zbnI1ejU3WnZ3REZNZVpiaHJlKy9qbXExanZNWG51cmZMZnNBQWluV1dpMkVZWWdnQ0gyaklmMTcyTkswNStmWDh1SWlzaXpGRzY5L3kwOWJwejM4dkxRaXo1RDJldEoxZmRnSUVkR3daTEl0VTBVamd3djdEUzczNHR1dnZlcTdpY2twMzlEdkozN3laLzMyZDd3NTRSdjhQV3E0K3Q3MTdYVzlYa2RMdHVPOVhuODdlNVNDakhSN3J3MGQzLzdCRzVpN2ZRdmQzdDdDNmpTODZNTXZ2SWlabVZrUUVSRVJFUkhkNzhxZDcrR3RtOS9FOXo3NEEzeXc4UGFPUHRPSSs4RTVtbnVqcDFGcGNmSnFER3FSUVRNeGlBL2hKcDhhWHFUZDFOU1VEL2hkbERMRCs0TnYxOWJXZktmbnVYcHVPVDQrL3REQUl6Vlc2WmRyL3RTSHBRdzNLL0NWZDI2aDdQYXcwdTZpN05SUTlHcW8xaFBFeWVNSDVEcTlITmxZekMrMmZYaFJlY2pya0N1bExMa29aQnA3eU5iYS9mSUIrZi9GTTAwZlh2VE16TmlPaDZYQlVUcnYzM3Z2dlczTEdiUThRNE9HejUwN0J5SjYwSWZpZWQ4UkVSMDFaWHNCdld2Zmx2NGlpSWlJaUlpSWpnSzl0clRkWHZNM3hLVFJvTmVFZGJ0dVR6ZnZJeUs5RGpWRnI5c0I3YzEvVnF6Z05BcGNjQS91TjVvb3RWRVUvazlsUDhuZ3F5YngrUmJYemZCelY4SkJ1c1BIWElaek1pNFZUZHE1N3oxVmVhNHE0L3B6OHZyUEZWMzhUVHVHTnhCaFR1b1lDK2J2N0lHSjlkKzRHbWpkcUROZGRLUVhTRDF0REtJalFHcldmODBZWExtNmpGZXhmM1RZcjhwaDJDc2ZyT0pOSEtJTFRUeGpIWjR2RFY1KzRFV0QzNUIvMzJsWHNJb2Q3dkprdnIxemZzemZsK2xYWlY0K0wxdkpTeHVEYzdndXcyenRhTjRHK0J4OEc5a3RPSHhYaHZPN04xc3lYbzhnMy84RDZiWGt1LytzUExqL2dnc05xM3FtMnZhaE9JOGMxb2o1cVFkMlVRWTM1TjlYODJMbjArb012bXo2eStHbk5wNXpPQ2ZEMHNlUDlSdVJZZCtSWWY5M3NrdTl2dFBQdk5mMjAzRGp5U1pXdVFjbUlpSWlHazFISnNEb3hjc3Z4cWRtRWJ1V21UQ0JtemJHMzRiWEhLRjIzVWVUYzdHVWlkVmRZYWQvK20vLzlMbXNrK2x0cS9ISzVWZjIxdXJjd1Z6K3Bjdm1IMDM5bytpSklJNmkxdmx4LzN5UlBXRkxVeXV0MHhNM1BablRoS0JJVHRnUGRSazViYmRpSUdWWnFKVStXclZBYlBENExScm9XUENCRWRIK3JRNGF1Tk92M092NnMvT0RDcUxJZ3hCQk9BZ3dDdllod0Nqcm9aRFNpcDVVTm1zQWlHOVE0L2FuOHRLM3pmRjNVdWZHbm9qMmh6YXFOSHJSVFBCNGxacWxOaXlVYm0ydDViZS9SanVqKzVvZER0ZjEvOUZHaGFuc093b2ZZSVFqSTh0VDVGbnVLOXp2YjRpNkcxYm1zKzU3SDlWUWxZaUlpSWlJVHFaU3pzK3lJdlg5M1RLRHExTHNDYnc2SmRDQytNSGRLZzl0SFBSODd4Rmg2bm8rdVI3WXE1MHhqeDVoTGVBUDVHMlZNRUFxNTkybGxFWHFjSXBjdXFMZnQwRi9PRHNaM3YzMGhwNSttQ2dQTElUK29lTXpLR3N0eTd2akUvcUFaT092N2d0M3VZSnJZSlNXVnp4c3VuUzU3VWNRUGhFUkVlMHowNitMZ09IbDJVUkVSRVJFZERRVWd6SmdHaDE2Z1QxdkxrcTBkOFhndWxIYW5YQlFiNlhCUWVFT3ErYVNRZDFpZlIvYUxHZ3RXU0xqRXVsM1lHY2pwSUZHRlowT0ZzME5oVEhyTmIwYmxacWNzM1NvaklQZUtibUhmU1JyZTI3MitUdDJ5bG5mNWpMYWNoUG9mTERQcnR1Z1dzMTNrL2xvdENubjVsKzBrVTB1a0Y0YXRGbCtSVi9mYnJ4a055RzFJSkhiYW9zZ0crelZaZXhvcDFBYVpLYVVidXN0U3lETE84NGZ6SzRiV2MvQnoyT2tXN3cyeFBYT041WGhucENJaUlpSTl1TElYTEY4dmpieElyckJTeTdBLzFxT2JUL0hMSXVkTWhma2RPeUNuQlY4QWtHNmFHdmwvODJhNEMzNGM3emR1L1JMbDVKWG1xOVVudW1kK2hGbmd3dk85djZLRkJXTnkxbmx4L1VteGZhK3M4cERYMDRPamNFby9IUnBjclNETlNrcE5sSmdXQVBScWRObkVZWVJ2dnFsVjlEdERQZnVCMW9aTVhmbnR2LzdnMnZ2Z2ZhbUtETDB1bXMreUlPSWFEOTBPMjNaRjJpb3p1UGR0R05scFgrWGwzLzV6LzhwYUh1VkpNR3p6MzBJMVJxUHhZaUlpSWlJNkVGTDdUdTRjdWQxdEhyTHUvMG9HdEhKRFVxdEJnSEdOYm4vRU5PYnBxYW1mSDk1ZVJucE51RzNDd3NMV0ZwYVFyVmFSUlJGaU9OSG40czNxeEhHS2lFKzkreHBYRjl1NC9XYlMraTJlbWl2ZGxHdEo0aVRDTk5uSmhDRVVqc1I3Rzc2OVJKaytSRFd1ajIwMW1TY2k4T3ZlTXFsbkxyTUMrVHR1K1hWVDAwM01OdW80R3l6aW1xMHUycTdxMWV2K3JMcWg0VVJQL0hFRTNzS2Z5SWlJcUxEWmNJRVFXUEc5NG1JaUlpSWlJNkNSU2tEL3VEYU5YUzdXbDdQTXNkUjBGcVYrcGhXN3N2MWlXajN0RjdzVHFDWkRoZEJPM2NLcFE4QXV1QUtUTzhzZXdJdmF3ekRFV3BEOWpHWFlkYVUrUC9KbEt4eG4vZFlqRFVtckpwS21Uc04xZWlXcFF1bDQwM3I2VkE1Z3pkbG0zTUYrMGpXOTl2eXozZHNqaFlPbVd6Ty9xVDBudG42Ulh4WC9uMzE3Q0k2aTlnNW02RXR2K1R2eUh3Y3UrK2xpL3JQTzAxY3lDeHlMT0xxZHNNSUhNNDZpNWt0WHl6OStPem80aUpyY0VlbUk1ZHhlVEIxME9DMDdGNStLQWo4ZUx5UFk2QXpocWNDKzhCODk5Ylh1ekNXOWU1eG1sRWF4RExmWXMzekF4RVJFUkhSTGgxNmdORW4vOFlueHhzeG5paEw4N0sxK0pTQm1RSHRSVVB2c0J2QWZsNksrSjY3OU11WDNvQ2M2TDN5ODYvTVBmUlRsMkV2elY2cXlXbkpSQmhrRitYa1lzWVZ4VXlKNEJuanBNd05PQ1BEVFhodE80MmlXcTJHUEo5QVlJOU5VUEt4NHU4d1hwWW9IM0dIY0NLaXgxRVd1UytOcHYybERTSGpSQnVXVnBCVUtnaUNJNU9UU2tSSG1PUEZIVVJFUkVRalE4Lzd0QXl2WHEvN2NLTFYxZFV0MzZmdmFiVmFjbDRZWUhwNmV1T3pEeDIyZExGZVhaVkVPRDhoMVJXZERDdTlUTTdwUzZUU1gxdHR3MG9GVW0yc3FoZTR5ckFmSFdhbHg1cDZROXhlbGlITHlzTXJmOVF5VU9tVldhNjN1a2FaWnY0NW5lWnFIS0JaaVRGUlM5Q29oTEM3cUlocHQ5cyt0RWp2ZHI3ZHRHbUFsTTYzTUF3WllFUkVSRFNLck41M3VDcjkwYXJyenVVZ3JDZkhZYTN5OFc0c3NST0p5V0hsYUV0dm4weDAwcFJPVytUb2JjN2wzTWZ0YitCdlhMSk5JUkVSRVJFUkVlMWM2RHRlR1ViM01vSFVXSVpTbEpjYnEvV2x2TFNiRHBNVUthL0phcmlHL1dTUVdvZFZxYW92Y01oa1dzZGttMXpaWnNPOFpBM21YOGZ1eGpNUGtNcjJmcjZVNm9BdEIxdmluSlFxYW9UT3RnRkdVcXo1bmhSekxzaDdmL3VCMXd4dVlvZktIS2xzV1hveXIzZVdtamZpQW9lb0tQMWxOc1Boc0NUekx0OXFzeXpyVHVQSkdzNDkyOGJ0VjJTeGc0aUlpSWhvQnc2OVpYRWpqcDh3TVg1Ry92eFpPVHY3QW1pdnB1UmtZVXJPb3Y5WDFoZjIyZCtTZnpUdS9hRUJScGR3eVZaU3pPUTJ2eWluTUgvWm9uaEJsc01MTXB5cTlHTi9nMklRamFibXhBVHFqUVpzd0FDam8wYkxuRFc0U084T251Y1ppSWoyUzViMUVKUU0wOWx2MmhDeUlmdmNzYkV4NlkrQmlJaUlpSWlJamhjTndsRlRVMVBvOVhwYkJoajV3SExwNXVibS9Qc25KeWY5ODhFanltZjFuTEtlaEVqQ0FOUDFCTzh0dFBEZVlndHJhWTVPTjBNbWZYM1BtVGlVc2w2TG9QcW94dkJhc1JHZ0orV095NnRkdU5MaDhQS0xuQzhNemRmYWZqeUtOUFYxTHFGTXgxUXR3WWRQTnpGZWlWQ05kbGQyc2JDdzRNT0xIbmJYYkEzNDF4Q2phclVLSWlJaUdqMG1TT1M0WjF6Nit4OEVORXhwSnNkd21Sd1RGblhzdDZtZ2pkZ1VDSGpOUEoxQUdsN1VMbU4wWGVpNy9WUXBhaUFpSWlJaUlpTGFxUWdPRmJBZEV0MUxxbnVETUE2Q0hIcnpHWU95WklnUkhSN1pQczFMYndIN3lXR3ROTGlERUNrT21meitabVY4cHJaNnJTeHcrMm9MVjdCTHZWV2tRUk5YekhidFZpMWVkQTU2WWNtcjJ3M0RGZmlxQ1pESUF2bm1BeTltZUIwNzVDeDZWb3BMVDh3MkpVQWxBSVpXQ1dNY3JzbG11YkxsYTdydVJIanhuU1k2V01ZaWlJaUlpSWgyNE5CYWM3OTQrY1g0ZkczaXhkS1VMOHRaeWM4YVk1NEREWTFEK1FWVFlPblM1VXV2clo1ZExWNzlkMS9kU0FpNTlNdVh6cUJBSlE2TFR4VmxPVjZXK0lpVUJVM0lwejd1WUdiazVGRk8vdVFVa0lWQk5PS3NEUkJGQm1OajR6NGtaMlY1R1hSVU9MOU1OTVNJaUdnL2FVUEJVcm9pei91MVh3eTEyeGM2WDZkblpqSGVuQUFSN1oyR082YTlIdHByYTc2aDhVSFFZN0lzeS9vTnE0bUlpSWoyV1JKV01WNmR3bUxyTm1nMEpVbml3NGswRktlVXlnVU5NN3FmQnV0bzRORDgvTHlVejBZYlFVYVBvaGxKVVdBeE8xWkJGRnJjYVhXeDJzMnczTXNoZFJsWW5tL0orYWRGV2s4UVJnR1NhZ3dyMzJQczNjdWZIYXcvdG0yMWUzS2NXL2JEaTNDd2ZKQ1RqSytUNC9zeXkvdjl2UERQMStNUUZSbjNzODBheGlxaGZ4enVvcXlpMCtuNDBLSjJ1KzNuODFaMCtXaFhyOWRScVZSQVJFUkVkSkJhcG9FN3Jvay82cDdEZnZ2a3YvVXhURTgyTVhWcUJrUW56Y0xpTW01OGNBTTNiczlMTjRmOTFPeWR4bytEaUlpSUNEaGZjZmhvbzhTZDk5L0JuWlgycmo3NzRrYy9pcHFVV1Y1ODZtblE3dWkxSlBNTDg3aDU4eWJlZk9ON3UvcnNtZkdxbEVYSGFCZ0d2eDRuNTl2djQyTUwzOXpWWjZhbnAvMk5Eejc1cWMvZ3BGbGFXc1QxNngvZ3pwMDd1SE43ZDNXVVQ0V2Z4Ym42L29jMEh6ZXJNTkJiZWhSYWhUZWlsNlRsZzJtZzRiTUJVZ2VUdWg2cVVxdktpN3IzZ2RUVlYvL1pmM05wWXVJOXRQN1k1VmQ0RUVCcVV1OVZ2SG1UTEgvbnNwWEw1UGs5TmVxU0VzbmVVeG11dXhCTFc3NUJzK3pjdzhPYjVNWGJsUXlCaXg0TXh1blVaSGV5ODFPT2VaTmh0WXo2dTU3anJpZ1J5OGF6QXZ2Z2E4N0ljaTNSV1ExUmdvaUlpSWpva0J4YWdORXBuSW9SRkM5WmgwL0o2ZkVYUUVObGpmbUNNKzRtbXZnSFoyK2MxUk8rYk5QTFo4SVFFekxmLzZLMU9PTWNQcWx4cVdyalJJMXRWK2tZQ01QK0ptNjhPWTZ5TEJoZ2RKVDRNSkZNQ2s1WUhrcEUrMHdET1Z5Sm90REdrNVlCUnZ0RVF3Tm5aazZoeVFBam9zZFM1SVZ2ak56cHRCRkdCM082cm8yb0M2bk4wdTJqTmpJL1NJWW5ua1JFUkNkT0V2VURqS0l3QVkwbURURFNZMGU5eUYyRE1MY0xNRklhWUtUdjIzR0FrUnlQeHFIQmJLUGl1MGdxTU9iREhwYTdLeWdMaDVXRmZvQlJsdWFvMUJKRWNRZ1RCdmRlT2l6bi9ocXMxRnBMKzBGQ0Izekl1UjRNNm5JTkw4cVFkM29vTndVTjFXc1ZOS3N4WGpqZDlOTWIydDBkZzJ0dzBYcFhiQk1Pcjh0SHk4WTF3RWpuUHhFUkVkRkJXck1OekdFQ3IvWDJQOERvaHo3OHB6Rjc4V2xNZi9SaklEcHBWdDk5Rjh2ZitEcXVkTCtENzczL1hleW4yZlFVaUlpSWlOVDV4Q0VmS3pIWGVRdHppM2QyOWRrL2QvWUZ6TXhXOEJPWFBnTGFuU3hOOFlNZnZJbHZsZS9objM5dGQ2RTFaNnZuTUZHZlJNTmtvT1BqaWJXcitLSEYzYTBMejgwOGo1bkdMUDc2VDUyODMrQVZPWDk2MVYzRjY0dlg4YjNGM1owL1BSVzlqUE9OQ0xRN3ExSmZwNWtUbzV5Y29BRkdHYTl1MnhmR21qUXdXQ3V5TWtZQlh0UzlENXd6dFlxcFRGeDVxdHVGcnM1RXdLUnN6OFkyUDJINjdVeTdadStiNi9TOU5tNDhPWWJsTFM4OU5xajZMTGlIdU5YQ1VPNSs5c0VxNXJWL29Ya3kxbmZqa01qV3M3cmxhL3FidCtpR2kzc0xwaUlpSWlJaUdvWkRDVEQ2NDcvOHVTL0FGQk53NWorUmg3d1YyajV3emowclp4Mm53cUw0SjczYTBzcFAvL0xucnp2allpbnNpVjFaUGk4bkpHT2x3VVU1YVRtMEVDdWlnM0w2ekRrMHhzYngvdFgzUUVlREZ1YW52YzQ5alhlMm93M3BiUmpDU21XR1BVckJJODVKeFhDL2daWTJpaUk2N3F5MWlKSUtqaEkzYUtpWHByMUh2Tkg1YlU0UVJvamlHRFI4Mm9EMHlRdFBZWEp5Q2tTMGR5c3J5ejY4Nk02ZDJ6NFk3Q0JVYTFWTVQ4OWlZbkxTTjNBbUlpSWkyazlubWhlUWhCVXN0ZTlnc1hVTGFhRWhNeXhYR1RWYVJqQTdPNHR1dCtzN0RkTFpLa3hIWDlOQUg3MHJkS1ZTd2NURTdrSnZUNDFWTUYxUE1GbU5VVXFCNHB1M2wxSEk4TnF0TG5yZEZLM2xOdUlrbFBQOUFMVm0xZmZYZXFtVTFUa2ZlSFJReWx5bjNTSHY5dURrdTUyVWVlcDY3VFFvMUljeUJiZzQzWkMreGZsbXpZY1dSYnNNTHVwME9uNStMaTB0YlJ0ZXBPV28yaldiVFl5TmpmbDVyc3VLaUlpSWlJaUlpSWlJaUlpSTZLRDBZSHowenpkTWpDbVUrSlRiUHIvaURnS2ZvUEZGVy9GSkN5a2VyRU9MWlZoNkpkMi9YWGJRbEw4clc4UUt2U2Z2MEdGOXgwYm9ZT3Q2dUhNdTkrUHp3OUp2YnBQWHNTcWZYWVhGdDJRNDd5S1VZYkd1YmRpa1ByTXFTeWlXdWwyOUhVMnZLRXE5c1B0Zzc3eDR6RmxYanB2Y25UbmRxUzdJd3k2SXRpQmIwbm5yY0UwMm5XM1FTSkY5NHJSc1FNOXV0ZVYwSmVhN3EvaitIY2d1aklpSWlJam9rQnhLZUkwTnpCa0hNeU5uT3krQTlvVXhhTWg1U0UzbTg2ZWNOUXZHNGFvVUEwcFpuWFR3NFVZTmY1N0NZaDQ2QVdxMStzYWRyK21JME9MbXN0elpjdEVBbzBGNFVSQWNuY3cxYllTa0RZSzRidEZKb2V2N1Vmb05LcTArM01sdlVOL2h0emtNRzlzM0dyU2krOXVrY3JSQ3JvaEdUWjdudnRQR3lRZGx2R2lpMFJoaklDTVJFUkVkaUVwY3h3Um1FUVZKUDdDUjkvc2FTVnBHb09FNGVnd1pTSm5kZHNlUytyd2UzMnJ3VGhqdXZreWhGdmMvbytGRnBaei9hd0JRbXBjb2luNlhJVWNwL1RBS0VGVVR2VjBuMHF6RVlkd0t0UjljVlBpeWh6TEwrdVVWOHIrVmNRNnNSYk1hSTVHL0oyc0o5a0xuWlNiRFRkUFVkOXZSWlpNa3lVWjRrVEdzQkNJaUlpSWlJaUlpSWlJaUlxS0QwNjg1TkxnRHFTZlRxcXFIMU4xMTVQVmMzbnZGQkw3cXVMdEZZRkRGQnhnNS8vcDJWN2hwNk5DaTFCVytZOEp0QTR5c0RLT1UxMUszL1EyWWRWeTZVcisyUEJnZTdZdEFLakZsMVhDYWRjV0xGdmVCY1NhVzJ1dEtyK2h3SmFadHlaWXlkUWF0SXVQdmNOU1VGckhzcXFwYnZTYlBwM2VBRm9pSWlJaUlEdEdCdGtMLy9OLzUvTk5SNnFwUzd2T0xVZ3BsbVo2enYvVGFlQ2wwR0RQRzFOQlBWcFV5bmxJZW1nQkVKOGlURjU3eWpUcitGWDRUZERSb0E1NHM3ZTJvTFpFMmJocWJtRUsxV2tlMVBvYWpvc2d6M0x6Mkhnb3BzVXQ3REthbjR5K3AxSER1d3JNNFNqcHJMZVR5Vzd6MXdaV0h2bTlqbThQQXNYMFRSUkdlZWU1RGUycVFTa1JFUkVSRW8rZjFHd3MrUUthZDVydjZuRjRTcWtFMGsyTS9qWTgvL1RKZXUvb2xkTk0yYmkxZEJXMnZGdGRSdUhIMGlnaEhnWWJpYURoT285SEFNODg4ZzdtNU9keTVjOGVmZDk5LzdxMmhPNHVMaTJpMVdsaGFXc0xzN0t6LzNHN0NkY1lxL1hQTnp6MXp5Z2NZTFhaNldPNW11TEhjd1ZvdlIwZld3MjRuaGRXd2NlTkhFRWJPVDQzdGg2SnJIOUx2LzcySGVpbVpKZzFLOHNISUdwQTgrTHZRb0NJTkxpcUxRWHF5OCtOUUNTeG1HZ2xtNmhYZjFaTVFjYmkzYWhrTmY5TDUyMjYzZmREcHc0SkhhN1VhVHAwNjVmc2FZa1JFUkVSRVJFUkVSRVJFUkVSMFdQNjVxU0tSU3JUdjJSQ1QwdjlZbVNHV2ZpamRGUk5pQVJaZnM0a1BITG85Q0M3YXFpWnNQWUZGdzRsT3V3SWYydUl1T2QrWDczaE5odjRkR1hxNlRUdTFIOGpuTlFqcDZ6Ykd1UFIvdHV6NmQxYmxXNWVOeFhYNXBqZE5KTytMc0NTdnJPRlE3cHR5WWdTUnpWM29pcUlzRTcydk5JaUk5bWdXYU9TeVdkRjJ0TnlZREpjenFNaXV0MWtZc0MweUVSRVJFZTNZd2JRd2RqQ1hmK215ZWFWODViU1VDVFdNS2FmUkQ3Q21mV2IwbHNOTzVyVkJ2MlVENzdaTEoxQzFWbU9nd2hIaUd6TEI3U3BJUkJzMEJiSU13K2hvTk5MeURQb05ua3B1Vitua09GSy9RYUhiaFoxdVM3U0JId09NOW9jZE5BalZ4cEhjM3hMUmRyUnh1bTRqb2pqZWVDNjJzVlJ1aFpnSlpSc2RGRGhxbXRLTnliRmVMUDlGWlgvOGRQeDl3M2VlV3hNUjBRblRMODhCYnE5Mi9PUDM1bFo5RU5GYW1tRXZXbDJITkt0aXRWdERWd2F4bXRaQTIzT29vaFlteUl1amM4Nmx4ME82WG1pZ3JUL09rMzZlNXlpS0I0L3I5SnhjWCt2MWVqN1FTTHQ0Y0Z5NGsrTXFPM2hQSlpMeXdhQkVyNURobGM0SEE1VjZCVnBXSU5YdjFmWFV2MVdEakVxWVFUbUE5dGR2N3VxMExNL2drZCs5VVlTZ2YyaUEwWHA0MGFZQUl3eTZZUERtTUxEU0dWUmxmdFRqZmxlTEErbDJ0OXpXeXk5MFh1cDgwM0IrbldmNjk1YnpSOC9McGRONXFsM0E0MVVpSWlJaUlpSWlJaUlpSWlJNlpLdkdJcFVhdXBzSTBKYityTlRmUlNpaHRZUTM1YlVGZVg1ZStob2oxTnRCZmswaDd5bTBEbXlMUzRGemVhMHJyMlhhYlRPc2ZzMjJ3UjM1M280TTVKWUpmRGhTVlo3VEFLTmI4dWlPUExmZ3g4azNnd1B0SStPTXRVYWJ1R25GcnRTUkdnc2kyaDlPTnJQOXplZ0crVFBVY0Jyc25kblVIVFI3U2Jydm4wVWN0WkhZRXFmekVrZXJvY3N4b2JjTGs2MXpuRE5vam9pSWlJaDI0VUN1ZG4vNWwxNnV2dEo4SlE3ejhxOGFZMTV5RHVNZ0lqb2dGNTY2eU5DS0l5UkxleWlMbzlkQW5ZaU9NZGtIRkhubUF5ZG8rSm9URTVpY25NVGsxRFNJaUxaVHI5ZDl3L01YWC96WUE2OWRRaXIvenVQbzBmcTJzVUhYcDQzQlowNmRRclZhQlJFUjBVblN5WEtrZVluLzhKOTh5WWNZL1k5dlhzZHdqQSs2TTZEdFRkY2lQRFZSeFl2VE1xK08wS21YaHVUbzhkSDA5RFRHeDhkeDgrWk5yS3lzYkJsaXBNOXBkK1BHRFI5NGRPN2NPWDlNRlc4S3VOeUowRnJNTmlxK2UzWm1ITDFNdzR4S1hGMWNRMXZXMDJ2UzE3TGdkaS90Zis5VzR6MjQ1NTROdDc5K2JiMzgwajJrSERPVTRlZ3g3dGxtRFpVd3dKTlRkVVNCeFZRdHdlTllEM3pTZWFYQlJUcFBIMGJuNFprelozeXdjS1BSQUJFUkVSRVJFUkVSRVJFUkVkRlJvTUZFZjJqNjlZR3ZCSTlYaHpZczc1dit0Y1RmQzFpdmRwaWtydG5mNVNnTWc1WFNPWk9uNVJpSWFIOFlmTWM0UE9tQVQ2dy9KWDlma0g4dUdJTko3RTF3b1lreHAzZmtPbUN6czZpOWsrSlUxTWJMOHZEbDB1RG5iSWh6Nk4rM2xJWkkxcE9tTTdoZ2k4Y0t1eUlpSWlLaUUrWkFBb3ltcXBVSlpPa3BZOE1KQjFjSEVkRUIwcnRQYTZPVnBGSkJXWlRJc2hSMGVIUlpPREJRaW9nT2h6WUMxQWFXMnRGd3hFbUNhbzJIK0VUM1cyL01IWEI3NCttOGlPSVk5UkZ2VUszVG9RM0V0ZEU5RVJIUlNiTFE2dUhtU2h0M1ZqdFlhdmRBdEprZSsyb1pyQjRuYVNoUnA5UFpNc1JJYWRtZ3ZxYnYwYi8xYzJxdngxZDZ1SzBoUXRVNGdBNXF1bDd4dzYxbE9Vb3BndFJ3bzFLL1V4NW8zK2ZjbS80SDliWHRyTi9lTXdqNmY5bEJXVUpvKytYTmVwd2Z5MnQ2VjlDSmFvdzRESHg0VVdUM2ZtTlFMYlB3NFV2dHRnOHcwdkFpN1Q5TVJjcThOYmhJNTEvQTRHWWlJaUlpSWlJaUlpSWlJaUlpR2lIT0dtdll1SVJvWHprSHZmQmd5NHM0WEFDOTBDQWN2TDdqMytKelFMRFd3MWdjb2ViTWx0KzVhb0ZWRE1rVDZBY2x1VEU4YVZxWXRCR2VLWUVQeTFjL1dScm94UityOHJkZW9MejNpemFJaUlpSWlHZ29EcVRGbmJPNFpFejRpZExoWldQMG5JR0k2T0FrU1Qvbzk5U3AwK2gydTdoeit4Ym84T2pkeTh1eUFCSFJRWE5saVR4TEVRUWhBZ1pQRE0zNTh4Y3dNek1MSXJwWFlDMXExWnB2eEUxU2N5anpRcnVKaWIzZXJJV0lpSWdPMDIrL2ZoVmZmZXNHWG4zdk5scTlIRVNiYVhpT2RxZE9uZktCTysrODg0NS9mcXNRSXczbFVUZHUzUENCUUJjdlh2U0JRT1BqNDlpTE9PeGZlM1p4cWgrVStlRlQvWkNrZGxxZ2srWlk2V1hvWkFXNmVZSFZib3E4N0Y5dnA0Rkc4MnZiaDNGVm84Q0hGdFdUU1BwQUxZcDhZRkV0Q1ZHUFF6VGtlZTJpWUhpQnBUcHZOTVRvMnJWcmZobzA1T2xSenB3NWcwakdiYS96ajRpSWlJaUlpSWlJaUlpSWlJam9zQVNSQ1Z4cFlHelp2MGwyQ1NJYU1tTjhrTkNXRnlBRUphb1htaGk3dW94bDdDTEFLRzJpRmdIUHV4S250dm5PTitXMUxvYkVObkZXaHRsMERuL1Z4WGhlTmhXWE1CaGhBN3dxdlRmbHdTbDVFSUdJaUlpSWlBN1Z2cmJjZnZIeWkzRVR6UVpNOEF5Yys0Z1VLU1FZUVhyNWVXQk5ZUTN5MEpyY1B6YWFNT3YwK3ZXdFdxTm1wVE5sNlpETDZ5NTN6c3BKVjFBNGwramRmUXRtUXhNZGl2SG1CS3hkQVIwdTUwcmZFUkVkQm0wQUNONm9ZNmpHeHNaUWw0Nkk3bVdzOVkyNDQ2U0NlcjJCWHEvckczTVRFUkVSamFKYksyMjhkWHNaYWNFeUhkcWVCaEVGUWVEUEV6VzhhSEZ4Y2R2MzlzL1BnWldWRmY4NXBVRThsVW8vakY3RGpmYk9hSjBPa2pCQXd6aFVwTitUZGJjUmh5aksvanFzL3pZcjIxKzNGZ1hXajBORkE1S2tuOGgwU2YyUUQweEtvc0NIR1praFpSZWxhZXJQRlZxdGxwOXYrdmY2L05sT3JWYno4eTFKa28zNVIwUkVSRVJFUkVSRVJFUkVSRVEwU294emdUUEcyY0IwdGQxZENjZndrY2RVMnJKU0d0ZW91aDRya3FuUDREb2NKclo2eVFHenBzQzVGNEcxMTRFVU85VEprVlFOcHB4Rlk4dExKd0pjTDBvOHprWFQydWJabms5dzBZUklUSW1mbGVtb09JUG5qY05wZWEwbjMzMUgvcjRsZi8rdWJEL21qTUZMOG5jRnREc09pOW8rMnJHSkRSRVJFUkVOeWI0R0dEWEhtNDFHbmx5UTA5OGZnekUvZ3hHa0Y2Q0gvdUowcEVsb3V0WFFkQUtMSXJhMlptQkNhOTBEQVVaeXdKNXFWeGlzbHFWejNkeUZlZW5pYm01bTA5S2h5SGxFVDNRWXpwdzloOFVrd1h0WDNnVWRucklzL0ozRWlZZ09uSmFxU3NmQzFlRTZkZW8wcG1kT2dZanVwWTJJSzlVcUdtTmo4aHVad2Z6Y0hQSzhCU0lpSXFKUjlQYnRGWHoxN1pzZ2VoZ044TlR1MUtsVFBvQkh3NG0wdjFWWm9QUG41dzUzN3R6eHg4NjlYZytOUmdOeEhQdmdvTWNKTU5LUFZxTEFkMk1qY0hPOWRydU5UcWVET1RsbjBEQ2puWmlhbXZMeld1Y1pFUkVSRVJFUkVSRVJFUkVSRWRGSU1pYTJRQkZHZHJFc3lxZ3NYQlAwV0p3ekRhbHhuOG1USkFhUmNuaGQvcTF1OVpJeHVBQ0wxdUpadklzYk93OHdDZ3ZFU1BDMEFXYTJldjNxZ3YvT1BUc0x4RkZUdnNIaFV6QTQ2NEMvNWNlMy8zSlAvbWliRW44ay9hL2tLZjd4OVE3ZXY5REV2NDl0eG9lMkYwYTRscGRnNEJrUkVSRVJEYzIrQmhoVnMvQTVaOTJmbDVPRDV6QkM0c0NmZ0pWanNWMzFOOVExdGhwWTdjTUdCb204NXZSR3d2TFdMUS9PTlhWVS9nMERsTEY4M3RWa0FISkNaS3J5NFVJS1ZvclNGV25oeXF4MFpTZHpsZExCTXNxRGFQOWR1UGcwb3BDQjdJY3R6N0pIM2tIOHBPamZIZDBncWxSOG82d2dpSHpmQml6N29jY2d2Njg4eitIS1VnNDZjcFR5dC9iNXUrdm5GK1Y1QnVOL2U5d2ZETXY1Snk5Z2VtWVdSTFExYlZEODFGTVhVUllGQ3RrRzlkS1UyMlFpSWlJYU9WRm9VWTFDZFBWOGs0Y3k5QWdhUXFUSHZPZlBuL2ZCUkFzTEN6N0VxSkJqNHEzb2V6WEVKNU55dzI2M2kycTFpbHF0aGlSSkVFWEg3L3hkNTRNR0ZlbTgwZW5XVGg5dk4zL1VlcWpUMk5pWW56ZmE3NWN0RWhFUkVSRVJFUkVSRVJFUkVSR05NQWRycklidVdHTUNCMWZxRFd0QmUyU2NHWk1LK2hrVDcyK2JVUm9kNVRMZVJRMm5UWWc3TUtnWVlHempSWWVQT29OR3A0UGZrVWZ0blE3VFZERHRIQzdKbjJjMzM1NUtodlc2S2JIbnU3MWVhR0lTQWM2NkZKK1hjZnVJak8rTDh2UmtmMVJSR0llcjBuOERKYjVrSGQ0c2dlOTNLbGhCQjBSRVJFUkVkRVRzNjhtb01XN0t3SDFDVGtpbUh1Tm11UWN1dEFhQmpQaFliTHZTMThlYU1oc011azIyTFJHSlpObzFzeWpSYU5mK2h3eWlmbmF4ekE1VHJLVmwzaXRNbVJaRjdEU2xsSVVyUlB0dWVub0c3ZGFleTBGb1NGeFpzTkgraG43RG96anVCeGhGc2V3MmpFVVFzcXlZOWs1L1gxbmE4MEVaV2RwRnByKzNzbGgvRVNlYlZHcTVFcXpWR3E3bXhJVHZpR2hyU1J6TGNlZzBidDY0ampDS2tQbGd1UUpFUkVSRW95VHlTZjhXM1Z3TCtubE9SUThYQlAxYWthbXBLUi9PczdLeTRzT1dIeFpncEFFKzZ3RkcrajRkUmlobFpNY3h3TWdOd3FjMXdHaDVlZGxQdXo1K0ZDMC8xSURVOGZGeEgvSmtScW5pallpSWlJaUlpSWlJaUlpSWlJaG9LLzBtRlJYanRFN1VQK1lsNzQvQkdTUUd0bUZ5QmhoUjN6Vmc0WWtROC9MN1doMzh0RFlDakp6RnJQN3NLdm51N2c1dFM4UXl2T2ZkNWpBa1AwRGNsdC93SGV5UnkxQ1Y4VGxuTEQ0cncvbU1QSFZXT20zWEM5bEc1UExjZ256SDIvTDZGNUhoK3Z0dDNBQVJFUkVSRVIwcCszSXlldW0vdXRUQUdwNHpLRitTRTkrUHk0bERBMGZZb0h3REV4WGJDcXdwNnBGcFd1Tk1aTTJrdkJCZ2lCeGNvR1VyMWRCRUZSbHlQUXFMMHFGWTdCWkdDMWhhbVl0QlJQdml5UXRQK1FZd05GcTA4Yzd5d2gyMGxoZGg3VkEzeVk5Rjd4cWZwdDFkaFRIMTc1UnVmVkJSR0VhSWtvcWZKaHNHL1gyUkNmbzdKS0xIWWhCcWFxSVVJWWR4aktxc3E2VTJqRXQ3eUlzY3ZjNGFuRHkzMnlDeGJyZU5xMjk5RDBlSmhqVHBiNUVPeDhURXBHelBaQjJyMVpISTlveUl0cWFoUldQajQvam9ELzB3UHZ5UmoyQnBhVkdPSVRJc0x5MGRpU0NqU3FXQ1dxMkdPRDUrRGNPSmlJaG9lRjU2Y2dhOXZNUS8rNk4zc05UdWdXZ25yTFUrYU9mSko1LzA1YkpMY2d5c2ZRM3MyWXFXVmVneGNxdlZRcWZUa1dQVTJBY1pUVTVPK3I0Rzk0d3FuUjZkdnZuNWVUK05HdXlrZlMzN2ZGZ1pqUTg5bDNNS25YYnQ5TmhkZzUwWVhrUkVSRVJFUkVSRVJFUkVSRHUxdXJMaVUwRis3NVYvalpQbXp1M2JlTy9LdTFoYVhBS050bStZQ0EyRXVMcXBpWmNtV1dqM0I0anh0anlmOGtMOGtXWmxjWWF4V1N0U0pFWHBlR0V5MFJBRkJyZExoMzhzbThtUHlzTS9zLzY4Y1hoSmVtbHM4Q2VlYk9MRys4djQ0cU9HOWVRNC9wSnNiVitRUDgvSzU4UDdOcjFmaGNQM3NVdm54ekF0Vy9mUE9Jc2Zkc0Jma0dFK0lZT3RPWWRFTDQrUTUxNlJ0NjI2QW4rM01MaVZyK0RhSFJsdjBHT1RtZmlVek9DcTVTNlVpSWlJaUlaa2Y5SjBVNFNod1lTY0xEVGwySFVDSTBCUFpxcVJUZVdFckt5RVBrYkN5ajlERHhNeS9Uem9JQmdjMVFjT2hUeFp0akpqaWhML0UzdC9BbXhKbHBpSGVmODVKNWU3dnYzVjNsWFYxY3YwZEU4djB6MDdCcGdlRWFBMGdFQWFJbWVDbENBR0ZXSUFJU3NFMHhSTlVwU3NxYkZzMmFicG9JTVVIVUdFSGJKTmhSVmsyeFFJQWpNa01TUUt4QUN6ZHM5ZXZYZnQ2MXZ2dTJzdTV4eWRrNjllZFMydnF0Lys3dkovVmVmbFhmUG16ZTFtbnN6enArRFZxNGwyVDZWU0xScG8wMkR4UVN1WnZ3TDdVTlF0clY0ZVFBWUJWQmdoaU9MYlY2UW4yaWwrUzBNVW16R3JEUVZ2czZ1WHBVaFdYN0RwUzFQNHNLQk91d21pTldFY29SU1hpdlhZWGZNYUVkM0ZMeU8rVEUxTjNiN3ZHMno3OVdvL0JCajU0ZkZoWkZ5T2lZaUk2R0ZtNm1VY20renI2eFJRSC9MMVlINTcwNGZ1K0pBZUg4U1RKQjhjZ0pWbFdWRjh1SS9mVHEzVmFnTWZZT3kzL2YwNDhFRkcvbnY1N2thc2pjTTRqbEd0Vm92d0ltNjdFeEVSRVJFUkVSRVJFUkhSWm1SWmlsNjNnL201bXhnMWplVWxkRHJ0WWh6UVlKc1RDbDBZVk80SU1QS0JSWmtyRFhkTXJTMTRERzNnQ1ZoM0xEVFRRdk5xakVRN0xVTlBoTGdFaTJOM0JRNkoxWGEvVnVDSWUyNURQNVp1bFh2Y2RRNjVVcjR2Tjg1Z0FSSlhzVW1CUm1UREloRHBjZGZQNSsvNHJGdURpVG4zWjhIOUZQeElONURNQVIzUWpwQTV4dHcwWTJOTElpSWlJdG94dXhKZ0ZHWTRDV0ZPdTVzSDBjZDhocEJ5ZXpKVEpkbXV4U0x4b1V0QzdHMnRsZnY0MkhjUFZKUS9lZDNVSWl5MlU4VExpYW1DaUhaY3BWekJrMDg5alVaakdUZXViYnBPaEhhQWIyeGs3V2lGdFVtcEVKZktpRnlKUzVWaTVjK3JwTk5lOC9OZjVPcUk0M0sxQ0M5YVhyaFJMSXM2enpBcTNLWVdzcVFIcGR3bWNBemFwa2VPbjhEazVIVFJBSldJTm01NmVxYm9IajU4QlAyZzErdWgzVzRYamFnSHZWRTRFUkVSN1o0Ly9jS3Bva3hVWWl4M0V2elRINXhESzhudzNsd0RSQSt6RnNBek5qWldsRTZuVXdSNlhyOSt2ZGdXZlZpb3A5OUc5UzVkdWxSMHIxNjlXdXlEam8rUEY0RStQdGlvM3dKOWZGMkwzNjcyMzgyWGxaV1ZvdXNEaXpaVEorckgyWUVEQnhCRkVXWm1aa0JFUkVSRVJFUkVSRVJFUkxSVmk0dUxSYmw4NlIrQmFORE1WZzhnRGtvNGR1eVRLSWRsSUhqL0JPRG9Wbm1pY1JrSGVzdDRjKzUxWkRwRk4yT3V4VUFTSW5TSGwyZFVLRE5oYmRjWUc3cXlLKzBlaVViTmhRNnV1YzV2SHErN3JzQ3pzRGdNSDFwMGl3RCt1dnV6ZEh3Y3g5MXovalgvVERiUVBRLzBEdFV3R3luVWpjVXZTZ0hmM3ZYL2RHLy9MWERHOWVNdEEvek9sUWJld2lhNHovdzE5NzRuM2Z2Lzgvc0NrU3orbVh2czJzVUdmaDFFUkVSRVJEUVFkbnhIL3VYVEw1ZXNSVWtJVzNLN0wzMWRVZUIybW13Z1hWY1ZPMXA5Y1lhN0QxQlN3c0lWVjg4Q2Q0c0pGMFE3U1NpRklBeWhlSlhxZlROcTRVWGlWbGlSY1BQY2FtZ1JWK3ZVQjl5ODZJTzFqTkVnMnFvZ0NJdmZWQnBzNy84dXIvNUcrVHhYdHk4SFdwOXZHTDAyeW55WGUydEVSRVEwYWliS1VkRTlNbEZCTjlQUTJ3eEF2THJTSzdxcFpwRGl3MWloWEhIYm9rT3dBU3FLT2dsWkJCSDU4S0sxZlpLTmhHbXVoUVA1WUNQZkR4K0U1Ty83c0orMXNQQzFNS085Q0RXNmQ5alhndHY5OThxeXJCaE9mM3VqUWFGcjM4R0hNdm52NUVzL2hUTVJFUkVSRVJFUkVSRVJFUkVSN2JaQWhxNEVDSlhydWpKZW1rUWN4Q2lGNVNMSUtBcnV2NEpwSmFwQVc0MnB5cFE3OXB3aDdFV3VteFRGK244ajFuNWgwQWtmV1NLTFNVZEVPMHhMZEpURmdsdTh4dHd5WnZ3cEhQN3hXKzFxcFh0ODBqMW1aSTdqcUtOM01rTmlGS2FWUmxWSVRMcm5xM2YyejYxZWMvZGU3VXJMQnlCaEV4Ni9kVW5xQkpoMkgxeTI0djcrdXBzTHdtQWV0Qy84YVRwdVBobWRLNllURVJFUjBZN1k4WUNob0lwUHVjNExFT0tUNkdQSzdjVk14RkpQbDFYdWRwQks0cDRkcVAzZ3c0dHFvWENEWlpOU2lPV1Z4SmFicVMyRGlIWk1xVlRDWTQ4OWdVdGhpS3RYTG9QMm5zNUhxTzdDWDJHK0NQaUlVSitZQmxFLzhJM2Z2SW5wQTBqVEhocUxjNnNINW5od2pqYnA4T0dqT0hyc0VZUUJRNHdHbmRaK0hTQ2haSVJxSlFJOVhKSDladjM2bENGR1JFUkVOSHIrd21lZUtycS84U2VldzA3NHhmLytqM0cxMmNNUHJ6VkFENlpMQ3FZVzNuVTEwVUZWTHBlTFVxMnVIcEs1ZE9sU0VmQ3p0UFRCNTdINVVDQmZ1dDN1N2NlaUtDb0NmMnExMnUydUR3THkzZDIyRnFEVWFyV0tvS0oydTEyRUZ2bjdXK0hycnYxM09IYnNXUEVkL0hnaUlpSWlJaUlpSWlJaUlpSWlHaVVIcWdmdzlLSG44TnpoRjNGczRrUVJaQ1RGNWk3NjhlN0MyN2krY2hYLzRzM2ZSaS92b1oxdTdmZ2Q3UStocEFtVU96VGN5d05oZUlvNzBZNHkrQUVrL3FhdytBOGg4QmZjOGxVWEFvRmJ6T3BZTFgvZEwzSTZ3TjhxWG4vck5CV3QxdStkZTY4LzRlZThlOC8vSUlCL2VhV0pKallvcWVFSm9SQzc5LzIzVnR6WFg5L2diOEdWLys3Q0NsNEY3WXRpK2dwY01nbzlFQkVSRVJGdDBJNEhHQm1MeDJWZ0RxS1BMNWdjU3BoeUlMSTRLSUtaRmF6cjlsR3JVeWtnUXluaU9MQTJNNktYYVJOcEszaVpYYUlkNEsvc1BUWStnVXFsQXFMZDVoc2ErZkNpZ09FZTFKZmNCb2RTYnIwWUZZM3NSaXBjakhaRXJWNHZmbE9sVXFEQnRacGZ4Z3ZWYkVZeHpyQTYzZ1RUaTRpSWlJaTJKVlFDa2VJMjFTankyOUorbTlvSERma1FvS0p1d3BVa1NZcjd2bXlFZjQvblE0MThhTE8vNy92dCsrUDV4L3g5WDladTN6c2M2bzc5V2o5TS9yUHZ2UXJyMm1OcncrYUxEeXZ5M1Y2dlZ6eTNGbWkwR1ZMS3UwS1kvTENzTjV4RVJFUkVSRVJFUkVSRVJFUkV3Nm9TVmpGV0dzZlJzVWN3VlpuQkk1TW5VSXZybXc0dVd1UGZlMmpzQ0Y0NDhqRTBla3U0dEh3Unk2NmI1TXhmR0FpaWFPY1hDaW1OKzU5b2JmMlZPWGtBZFlPRU93enZqbHBQUlZMeUJHKzZUeElqcmVWWTBNQk5JWERWUFhRS1cydGYzTERBUmJlc1huYmwrMjRCdlp3MTRVL1UyUEFwNlZiZ0NXRXdodlZYOVdkZGoxN1BOVHFnZmVPbXF6WUdpVC9GQjBSRVJFUkVHN1RqQVVhdWN1Q3pzUFpnUDljTkJCSjZ0cXJhU3FBc2hPaTdTOWdxS1VKZjNEanNCTksybG51bzZkeVdRRVRiNWdPTURoODVnb1g1T1JEdE51SCtsY3BWQ05iOVVoOFNQakhSSGQrSjNUeWFwajBHR05HbVRVNU5GYitwdnJFbERUWnJ3VXZVYk5idDhlVzdQQzVPUkVSRXRGWGxNRUFsM1BIREZEUUExdllsWjJabWl0Q2Zjcm1NVHFlRFJxTlJoQS81TUtDTldBcytXdS8xUGdnb2p1UGJvVUJydCs5OWpmL3NOYjQvYS8xY2MyYzRrUTh0MnN6d1BZd2ZCejY0YUd4c3JBamM5MTFmZjAxRVJFUkVSRVJFUkVSRVJFUTBTcVlxMHpnNi9nait2V2YvUEFJWm9CUnVyNW5Yd2RvaEhLZ2V4S05UaitIYzRydjQzcVZ2NHMyNXM3alJ2QWJxZndJaWRIOUNkeWkzYllWTXRORWhMRS9VM0NnaE1TVXRqdWNxNkx2MmtyVC81dWZSbkFlYXg4Znh0bHV1emdxTFdiZDBiWHBlc1VERExaUmZOY0NQcGNSWGF3MjB6d0tiT3BGQ0NmeThGZTd6MXlFTWZoOFMveVJ1RlNGTHRFLzg2VEp1bmRJSkFRMGlJaUlpb2czYXNaWUJYL2pQdmhCM3A3dEN3RHdQSzJyb1EyN0h5SllEa2NTQndHcDRFZnE2WlVRZ0VaWWdLckVTZ1RZV3VRSGpTb20yS1F3alRNL01ZbXg4SEVFUVFwc2MxbkRKMmt0S2pVNmpOQjlhcjl4ODVvTmlpUHFSY0J0RGZwbGNLOE5PdU5weHYxd0tCdTVzUzdsY1FSaUZLTVdsb21HbG40OW9jUG5KcDl6T2tjL2pzZG9VRFhJdHc0d2V5TS92UVJnVXYrMnJzejduZnlJaUlxTHRPRFplUXNsVmhQL0JPZEFJODl2WlVSU3RibThId2UyQW9GNnZoeXpMaXJLVi9SUy9mK1BmNjBPSGZGaVF2MzF2Q0svL1RCK2N0TVlIRjkyN1grUnYrOGQ5MXo5M1o3alJacTJGS2ZuQUl2OWRTNlZTRWFEa2J6TWdtSWlJaUlpSWlJaUlpSWlJZHNQVTFEUXExUW8rK2FuUFlOUXNMeS9oNnRVcm1MODVoN201bTZEK01sMlpLYzdyL1psSFg4WllQSTVJUlpCaWh5NGNMTngvSzRwd3BHY09QZStPUzVkd3MzNmpDRFJxcHkza1p0TVhmczNkNGJ6V2ZZOWFLT3MveXFJdjI5RU5NaUhoVDFLV1NzbTBPRmFyYlFuMGdheXgvcW81Slhka213ZWc2VDRIYXpnUUN6emhicjdrMWw5UHU5WGtpbHRkdHR3Njh4dHVNY3ZkN2VNUGZMTkZyL2dyY05hOWJzbmRmaFVLTitRU3VtZTNFSERqMXAxUHVEOUg3amtWZTlrOWRrVUxYSFV6OE5KNXQrNEYzVVhZWW5vdFBlRHBpZVBqT0NVYnVIb2V4ZlFpSWlJaUl0cHpPOVpTZlhGcU1TNlBsNlhiM1hnQmZVb0syR29razlEVmFFblJueUZMZHdxa0NIMklVZVRxM3pJamtCZXRpa0ZFMitDREZtWjhnTkd0cTFuYjFMclZGdXN6OXBJS1JpdkFLT0JWMDZtUENjaGltVlFtR0lsbDB6ZEtkRWV4R0xpelRlVktHZFZxcldoazZZTUJhYkN0QnBtSjFjYTQ4QTF4Y3dZWVBVVFJzRG9PaXZBaXJrdUlpSWlJdHUvWVdCbTFhSFRxaW1oOWZ0czZqdU9pMUdxMTJ3Rkd5OHZMNkhhN1JmRFFWdmg5bTYyK2Q3ZjQ4Q0lmMWpReE1YSDcreElSRVJFUkVSRVJFUkVSRWUybXFlbHB6TXpPNHM5ODhjOWgxSncvZHc2dmZ1L2JPSXVmTU1Db0QwMVhaeEdxQ0o5OTlQUEZmU2wyTG05RkZBbEd3R1I1cWlqVnNJYUZ6aHlXdWd0SWRiTHBBQ1BYcXp3UW9uSHY0d1kyOGxFN3ViVTg4TGZEaEJTUlAwdFRLYkhpVzlNeHdHakRpZ0FqWlJVRGpPZytib1YxQUJLZmhROHdFbmhHK0JBaUgwWms4UStGUWZmV2MrdXlBZzNoVjN2QUs5MEdzam1zRStxMkdhdEJTaWZ2ZmdoTDduUE91aHRYTHk0L01LUm5wQm1McGx1NEg3UStuSFRsbEJsMzQ2N0JBQ01pSWlJaTJoODcxaktnWGd0ZnRDWjNGUzc5dVgrcjNCNU00R3FneGlOUkhiU1dwdFZRdGlObGtyU05jVmVwdFVOeDRrU2p6Vi9oK3BIakozRHp4cldpSVF6dG5mcjRGRWFGNEZYVHFjKzVBenRRN2hoRkhFdEVZWXlodDVvNEFzbGxjMXRtWncvaXlORmpLSlVyb09GaHJUdU1ialh5UEMzQ2pHaDkvcmU5N0k3NTdQWnFKTTh6VjNLODgrYWJTSkllTGw2OFVFeWZOSDMvcElsU3FWdzBlSDcwc2NkUXFkWncvUGhKRUJFUkVRMmFtVXFNVXNncWI3cWJEL2p4UVQ5QkVCUWhSRDdReUhlWGxwYUsvUlVmYW1TTUtVcS84b2VoMW9LWmZKQytEeXJ5OVJIVmFyWG8rc2RZUDBGRVJFUkVSRVJFUkVSRVJFU0RSQVdxQ0FaNitWTS9EeU1NdmpEMnk5aU9hbFF2dWtYWTBDNDdXRCtFbWRvc0R0UU9JZE1wdEwzL1BFbHRkRkZhYVNQTGRHYUZNS0cxdVZqcVhIV1BaMUVuWFQ3WXkxcFk3Rnk3ODIzQ3dvcmNGT0VldHB2Wk5IYzk3K1cycHkzS3hoWFF0c2hRVlB4YzRnNFB0Nnl4eW1qTGNVcTBTVThEVWJPQ0dTdnh2THY3NTkySzYrQ3RWZSsvc2dadlpoWS9MTFdRcFdWY2ZGQS9Rb0hjZHk5MDBIU2RMVjh0OThnVUhoR1pXemRheFBldS9vMFBSYko0MCtZTUwzb2dpVTRSWXNUcjhCSVJFUkZSbjlxeEFDTXB4SXpiOCtqYnhHaFJORllYSWxCaTRDN25IRWprUXNqTVZZZUJpSFpHRUVhbytNWWlpbGQ0MzJ0Qk5BSWhLVVFEcEFneGtuNWR5UFVoYlV5NVVrR3RQb2FBdjZGRHliaWpVTDdRK3FSZHpVTGJiV3VOc1plV0ZvckcybGV2WENvYWF2dmJhMnExT2txbEVxWm5adDB3c2VFekVSRVJEU1lmWHBUYkxaL1RSRVBLSDgveDRVVytlRDdzeHdjWXRkdnRJdWh6YmJ1NG53T012TFh2NFlmZkIrcjd3Q0lmWkVSRVJFUkVSRVJFUkVSRVJFUTBpSHpRa0QvbWRXRDZZTkdkSEovR29LaEUxYUpiajhjZStKcE1aOGhOanFYdXZNMTBZZ1VNdEVrUnE4dzlsOGpscmk0MVJZcE9ldTlKaEFMYSt2TXZyUS9aTVc0OFphazJtWUdOd01QaDJ5YmthanRBTjh0cDQ5Tk9ORWNxMFdhdEFFcUdLQWtMditJKzdoYWxrbi9jR3R3UUVoZExrMmllYjZHSExwYXh5M3g0a1pLb3I3ZCtkRXQ0NnY2MHBHQWoyZ2U1Tlc1eUVCRVJFUkgxcVIxcmRlenFXZjZpNnh4RG41b29pY1ZvOVdxMlV4Z3dicWRzVEVIVVlnV2wzSjVZd2wwd29tMnIxK3M0OWRnVFdGeWN4K0xDUElpSWlHaGpEaHc4aEZPUFA0R294RUE2b3AxMjdjcGxYSFhsdGRlK2c4c1hMNkxSYUxoOWJZTThXejNPZEdlNGxIUkhESDBJM1ErKy96MEVRWWdubjNxNkNEWDZ4WC8zVHlHTVlqYU1KaUlpb29IdytIUVZxV2FBSmozY1dwRFI0Y09IaTY0UEx2SkJSbG1Xb2RQcEZGMGZhdVJEUDMzSTBWNkxvc2dkdkZGRlNKSHYrcUJSWCtJNExrS01WaSt3d2RCUklpSWlJaUlpSWlJaUlpSWlHbXorbkxUUUhSdWJIQis0WmxrYkVzZ0FTaW9jcWg4SlRYRWhIbHNrRlIwWlAxVThyMjBPYTdUcmF0eG9ua2NyV2NDbHBUZlF5OXU0M25nUDBoMFlISXRRY3UrTXAwcXFsaG9yY3cwczk4eHlidDFoVFdPblhHOFZhRXRVSk92S2lreElzV3l0RFhWcXFpQ2lEWkUxK0JYWmJ3aUJEeG1MY1FuY2RHdTRkMFNBYjh0eHZIcitQSHJZSTRGRXphMGJ4NVhFL1NkU1dDeTVGZStQM2ZNTjBMcHlnNVlTL2lmbi91ZmNOQzI1bjZoeExUYitXK04rczU0UWJwN0FPdjF6RDEwU2svakd5ZlBJTDRLSWlJaUlhR08ySG1Ca0lVNS81YlQ0NCtvL0thZGlxdXlxWXFiZFp1a00rbFFvaEEwSDlQeHdmM3E3Ni9qd0lyTmEvUVdlNlU2MFRXRVFvVnlwSUhCZElpSWkycmd3Q0l2ZlVOOG9rd1pmY1l6OTlpVXN4TzNHdGJRK0llU3RjYmF6Zk9OcjdjcktTZ1B6ODNOWW1GOE4yZlNQK3hNaHFwVXFwRDlTZDBlajU3WDNkRHVkNHY2Q2UxL1M2MkZ4Y1FGalkyTkY0Mm1QRGFXSmlJaW9uL25VL2xSeis1TWVibTBmWlMzSXlQUDdwUDV4SDFya3QzbHRjVFZUVTRRWmVmNit2V1BqL2M3N2RoTWI5V3VmZlcvWFc5dlc5a0ZGZm5oODF6L211ejdVeUJjaUlpSWlJaUlpSWlJaUlpS2lZU0hrNmpsc1VnN24rYVBGK1pPckNRNysyb0szQlRLODc3V2RyRm04ZHFKOEFKMTBCYzFvOWFMYWllNElZNDJ3dHk1VzZIc1RoMEpJRFdqampsUUtXTzA3Rmp4WmM1UGM2Skx1cUcvZ1V6djhFVitqWUh6YlJ1dkg1UzZjMTBrMExFNmVSRWt2b2V4V09NZmNvakx1cjhIa2xwdkVQYlhrbHFMZVhvWVhlVzRZaEZLUUQxaHV0VnRQcGtwQVk0TWVkNnRaMzAweEd1SU12VHhBdUY1RWtRU1VrSWh5ZzQzL3ZnaVUzVGd2My9rRzYvKzdmKzZYTEx2czVvL3pJQ0lpSWlMYXVDMEhHTDM4bFpmak0rTm5TaW9mKy9jRG1FL0Fpbys0RGRZYStsUXBGTlZRRFhiZFRqMVd5NjZpeW5SYXVtK0Rvb2dHUlcyc2pzY2Vmd0kvK2RFUFFFUkVSQnMzZS9BUUhudnNDZEN3c0xjQ2VmeEpCUUhpdUFKNk1IKzZnQjlmeG1CSHRWc3QvUFRIUDhUM1gvc3VmdkRhOTI0L1BqMHpXelNFL3BVLzh5V1V5bVVjT1hyczluUHZ2UFVtNW03ZXdQZSsrMjBzTFM3aTNMdHZGK2N6dlBQMkczaitoWmZ3djNEdjhXRmpsUW92TWtSRVJFVDk2L0hwdmoya1FIM09ieWVYM1RheUwvZnlBVVhkYnJjSS9mU0JSa1g0cDlaRjhYcTkzb1pEakh3SWtkL09Ec093NlByUDlVRksvcjcvN0R0RGxZaUlpSWlJaUlpSWlJaUlpSWhvTkJ5cVB3cTQ4dmpzUzhYOUs4dHZJc2s3K01HVnI2T1ROckRVdVk1QUNsZUFjcURHL1d0YXFlam1Gc2xjVytmV0hYbzB0bi9iNFBVcmQ4eFdxUWdUN2xhcUl0bk1VMTAyMmthdWdDRkdST3N6Uy9pc05Iak9TdnppN1FjRjNuWi92NTZudUlrQjE2M2poSktvdTNWQWpCR0loVHZYd3dYZlBUNSsvM00rb01yOXZoeVhHaVZza0JCdTNMbjMzZldZUmVyR1pjZU56ajBOdHlJaUlpS2k0UkQ4d3Q5NitRVnNnWkJtek9TMjdtNTgyRzJWSG5RUFJlakRyWHpmd05RUGxiZzdBSHNnU2I4ZndWeG9vaDBoaGI4U2RxbG9hTEoyaGU3TlhIbWJpSWhvMVBqZnk3aFVRaFNGb09GaXpGcUkwZW9WaExqSDhYQkZnSkUyU05QMDF2M3RqYkJlcjR2bHBVVmN1M1lGcldhemVLeGFyYUZhcStQUTRjTkZnK2labVZsRWNWdzh2bVo2ZXFaNDd0UmpUMkJsWmhsdnZINjIyT3MxV2hmOXZIcmw4cTBBcEljM3FGNXIwRzEyT3BXSmlJaUlhQk1tU2lGeXQxM2FTbk1RN1FTL0QrdkRodnoydXIvdHc0dlc2b0Q5ZnM5R3QrUHZEQzd5L1ZtNzdRc3ZpRXBFUkVSRVJFUkVSRVJFUkVSRVhoU1UvZVVrTVZOOUJPMndCbU5ORVdqa2l6L3AwUDlURXRJYUs4cWhjQjByRTQzTTNWQUdRb0kyeXgrc1ZlNllyVzhhNUVZc2N1c1pCT2pIeG8xN3lNMXJaVGRleGlIQnEvRlF3YTJDWnEzQXhKMExodlh0Z0MxcWJnVVV1YnQrWHRIWW96UElkUTR0QkhJcGNmK0p5eGFoVzRJbnhjWUNlUHk2VTdwMTZ5UHVPeDV3L1N4amhMaUpWWngwN3Faci9ZNEhTMzc4QlFZYmJ2RGg1bzJhc0ppODYwRTNmZHpmSmRlL0xvaUlpSWlJTmltQU1QODNiSUhic0QvaGRtaFBydDdwMzMzN3lPMktLQ2tnaFkzRWdOZEJ4SUhmdHhCc1ZVcTBBOHFWU2xGcXRYb1JaSlFraVZ1dmFSQVJFZEg2YXZVeEhEcDhCT1Z5RlRROHRMYkkwdFdHdkc2dnllMDc4VGo0QjNFSHVKSHBETjJWRnZ6Ujd1MEVHT1Y1aGtzWEwrRGExU3Y0NTcvNzI3Y2ZmKzZGanhiQlJFODkvUXlpS01KenozLzB2dmMrOXZnVFJmZXpuL3U4bTRZcC9uZi85WDlSOU8vaWhRdDQ1KzAzc0x5OGhJKys5SEZYUHZFQnc1QVhJVVpoR0JXQlNFUkVSRVQ3NGZuRDQxanVadmpoOVFhSXRzc0hDNVZLRzc2WUhCRVJFUkVSRVJFUkVSRVJFUkhSdHN6V2poZmRZeE5QWWJGekZaZVd6dUx5OHB1NDRrcXFlMFVqdkhJZ1kzKzJZU1gwNXlEYWJMbHJHbDF0S29sR0JiUlpvVHNzSEFiUjZqbXZKdGR0YTJTV0pYckszUldqZkcxemQ3ejhoT3VjRU1iV1FBUS9UK0JsV0J5NTZ6R0xhUWg4eU1TWU9WN0M0c1VHL0FrN2U3UGtTSFQ4TmFuVyt6UXJNU3VBbDFEQ2UwZ2UzcHVUUUdUR1VYYTkrZmZkZDN6ZTlhODhTdkZsN3F1K0JSUUJWTS9lOGFDZnppL3BBUFVQR24rMzMyTHdnbnZmNFh2NmZkT04xMWZkaldzZ0lpSWlJdG9rM3pyeEJMWkNZQUlESUpTaUd5aWgzZkQ2bHRZRHZSdWlwQ2hiTzhyVktFUTdiM3hpb2doajhJM0dlejBHQXhNUkVUMUlwVnhaRFRDcWpOVEZDWWFlbEFJcWtERGFRQnNEYTVpWCtqQmFheXd0TFNKSmVyaDVjL1dZekhaMjBiSXN4ZmwzMzhaS1k3bTRQelkranJHeGNYem9xYWZ4NGFjL2dnc1h6aFVCUTYxbXMzanVJODgrZjE4L3l1VnlFWEwwdWMvL0NiUmJMYmRkZXcwNnQxaDJ3M25oL0RrM2ZjTWlzRk5LdGU0d1NIY1UwQWNYVGMvTUZPR2VSRVJFUlB2aFVEMkdIT2xySUJJUkVSRVJFUkVSRVJFUkVSRVIwVEFvQjNVY3JKOUNLR09NeGRPNHRQdzZ1bG5UbFZaeEJVVi9hRndKcUZvc0s1RkdtR3FnbDl0ZVptMnVOYXJ1QlR4NnZrbEN5bGdJR3dheDFHNFVHNU1YWjNZS2F5eXY2a2dFVEFxQjJwMW5PMXVCQThJOUlBWCtrcnU3Y0dJQ2IybURucnQvMDYyU2pESkl0RUpMV1RRN0llYm01OUhFemxrUUdacHU2WFFyUmZpR2ZMY2JKN2pobkliRlM5cmlEMDhDcGZOQTZoNis2K1QycDRHb05ZNXFMdkM4TkhoT3VvZmNWem5zMXB5NWU2Ky9vdS83Vjd5eTdyWnczMThoeGlhNUZmRU5JMUMrWjRVODZjb3AxOStwazZ2RGwyQ3ZncC91WmZGVE54MXI0czRBbzF2RHB3TE1IaC9INUsxZ3FuVWJCeHlxWVRaU3FCZmhWaGFIN3Z6bGNXOW91YnZ2dVp0TElDSWlJaUxhcE1CdFhKN0VFQXNrdXBFU21ZVHdPek1LQTh4dCtGZjlsWU9KYU9lTWowL2k4SkdqV0ZpWVk0QVJFUkhSUS9qZ29zTSt3S2pNQzcwTUU3OTdFYmlkcHN3ZHNZV3g3ajhEakI0bTF6bHUzcnhlQkFXZE8vY090aXROVTd6OXhrK0trQ0xQaHhjOWN2d0VudnJ3MDNqdWhZL2kyOS82STZ3MEduanZuYmR4N0pIakR3Z3dXbDBtUC9mNW4zZmJ0UFA0M1gvMlQ1RmxHWmFYMmtXQVVidmRRWDFzQW1FWXJqc01wVktwQ0M2cVZtc01NQ0lpSXFKOWM2aGVRbTZZM1U5RVJFUkVSRVJFUkVSRVJFUkVSSU90SE5XTE1sYWF4b0g2U1hUU0JwYTYxOUhMT3JBd3hjVjlwQkl5Vktqa1JycGo1VUFqTVluTjBEUFNscTBkN0xadiswRklVZkt0N29JQWlUWFc1c2I0QkNPcHdRQWpJbWZTQW5lZElPeFdRN1B1ejZ5NytZeS83NTcvaGdSVzNNMGZTNHNjRWsxbGNOVzk1bHE1ZzU1N2ZNY0NqSzQwc2VDN2o0eWo0NGJEOS92OXF5c2JUTHZQZkNtd09HekczZU1ONUxnbmdHZHVGbEU1eGFRYnprKzYxMzdSUGZta1dQMStqU0xFQ0hjRUdJbWkzNVBDSU1JbVdZR2Jyci8zTnB5WXZGV21iZzJmRDFqYW54T2VCTTZLMVdHNVV6RjhidjAzS3dRbVgzYlQ3Y3dEQW96Y0NEa0FIL3dFSEhYOU9uaFhyNjJiM29JQlJrUkVSRVMwTmNPL0l5NWxEdXVxY1ZDRUoyTVl1QjNDWXMrR3pUbUl0bTlzZkFLSERoL0JtMitjQlJFUkVUMVl1VklwZmpNclZRWVlEUmNCNFMraGdlS1NNOGl5RkZvenhPaEJzalRCMHRLQzY2YllMbU9NRzljNXVwME9pbXY5T0krZWVneWYvYm1YY2ZqSXNkdjMyNjAyZnZ0L2VnV1hMcDVINGo3L3NWTlA0S1ZQZkxJSUpGTHEvZk1VeHNiSGl3Q3Faejd5TE9adTNzQzVjKzhWdyt2RGxxcEZNRkVJSXRvNWFaSzQ1YmVOWnF1SlhyZGJCSkhaQjlUVWhFSG9sdGtJazFOVENOeHQvNXZLZ0dvaW9yczlOVnNERVJFUkVSRVJFUkVSRVJFUkVSSFJzSWlDTXFRSThNemh6NkdicmVDN0YzOFh2YnlOZHJKOCt6VktDQWhsTVJhTGNqVVVVU2V6UHM4b2J5V21aNEZBVzFSQm14SDQ4N0pVSksyRnpZV1JEYXR0YkRSS3hYbWFiSWhISTBnYS9IMGpjTndLTk4weTRJT0xUZ3FMMEhWdmgvcTR4ZU5EN3I0UEUzckVkZjJTa3JrL1BuV3Q0MVpqeThmSDBIT3ZtUmYrY3JrQ0Y5eHFxNTBMM015QnVhckJCZDNDeXZuVk1LTE4rTHJyLzBIM2ViOTZlemdFUWpkc0ZTdnhLKzY1WjAvVzhmdTV3ckl3YUx0MW8xSUNqOWdNeDkxeno3dlhQdUdHNTZRYnpwKzR0eWJGZC9LNVBBSWZ2LzBKcmw5dWxUQ2J5enRDa2piSTVMZ2twRnVOeTNXZUZQaWMrOXpKNCtQNDUxRG8zdldjUmkvVWFHMXhuR3g4K0N6T1NJc0RibHkxM1hjUDNEREZhOC9KMVdDbmwzNWF4ZDgrMWtiak10NGZ4c05BcFZKRExWSDRqUHRxSDNQdmV6L3d5U0oxMzZ2aHh1dGIydUNNYUdJZVJFUkVSRVNiTlBRQlJzSllLd0toTVVTS05tNnNOeUhhRWRWS0JlUGpFMFVEY0NJaUlub3dIN3d3UGpGUmRHbDRyT1pucklWbzJDSlFSK3VoMm4zYVVWbWVvZHZ0SU1zeWJKYy9HTzVEakh4bzFKcnA2Umw4NkttblVSOWJ2ZERKMU5RTXF0VWFybDY5Z3RMaVl2RzUycFVYWG53SlFYRDM3bnk1WEVHZTVUaHk5Qmh5TjV3K3dDalBOWktrQjhOcFNyVGovTHF5MisxaWFYRUJyV1lUYVpvVXkvUjZTcVV5U3VVeW9qaDJ5K3JxYlFZWUVSSGQ3VkM5alBuMjlyZXhpSWlJaUlpSWlJaUlpSWlJaUlpSStrRWdvNkljSEhzVTFocThmdU9QWVdIdUNqRHlweEFwQ0pRRGNldmtYTk8xN3RYZFRQU010U0VEakRiSm9yZ3FwQXlFdjIyRVJFLzduQ2hqMlE2UFJwYVIrQVBYT2VXV2ltZXNEL29CanJqVnpsMnhQTzZ4MlZzM0g3bjkyRDJuT0VxQmkrNzl1WHY0VlIrRzVIcndsbHR4bmNzVUZqb3o2R0orMDJFOTc3Z1BucnRuT0tRUDRuR2Y4M0gzK1UrNTVYZEZXbHh5ankwRkZwRjcvRm0zSUQvcDdyL3NYdXVEZDhydStYbDMvNW9yNCs2NXU2K2d0dHF2dXR4S0cyb0Z2N0tlV084cFlmR002L2VVQWQ2UUdvMDduM1BEMDNUakJGc2NKeHZtcHNkYlJxTWpKZEpiVFFGdUJ4aFppNmZkK0R0ZWxmaC95RWszSEV2dkJ4aUY0NGd6b09iZThpRjM5eVUzemtwNGYxb2I0WU91RE9hdU5QRVdpSWlJaUlpMllPZ0RqT0pBQkhHQVdBeFJ5N0JJRlNtcFNOZ0dsV2piWmc4ZFFtMXNESEZjQWhFUkVkMVB1bHJ0S0l3eE5qYU93MGVPRmZlSmFQdDYzUTU2dmRYalFUN2M1TUNCQXpoMDVDaG1abWZkY2xZY1E4ZlRIM20yNkpiTDFTSmM2dUtGODFpWW44Y2YvL0UzOEtVLy82dDQ0YU12WVhKeTZuYVlVVndxNGFNZit3U0Vrbmp0MWU4VndVV3BEekN5UE94T3RCMXBraFNoWTY5OTc5dG90bFp3OGR5NVl0bHFkOXB1T1ROdUdUTW9Gak83Zm9DUmtQNll1anZpcjFSeE9SNi9uRmVxVlR6ejdBdW8xZXM0Y2ZJVWlJaEczZE96ZGF6MEdHQkVSRVJFUkVSRVJFUkVSRVJFUkVURHhZY1krZWljbjN2OHp4ZmhSV2ZlK1IrUTVRbWF5ZUo5cjYyRW91UVROOHBqaUgyN3NWUmI5MXFiZHJSdEpUbGtaaUNzc0xXMW9CNTZDQ0VpS2NTTUNLMUVDSmpjdG94Qm1xZDZ3bzAvbmd4TkkrTmlvd2pZK2Y3Uk92NW1vaEdOV3dTSndzZWx3aWZjc3ZBWDNDcm5zT3RlZFYxL0FxUy9BcXMvS2ZtKzhEUzNUanBTM0JBNGFJc09VdmUrMUFwa2xSU3ZuUmpEWlEzOGYzU0thOWQ2dVBoQncyVlMvSTRwUVlZRy84R3R6ejE1KzBtTGFmY1prKzVEL3JLNzNYT2Z0WFp5Wml4c0VVb1VDVkVFRzExeXovd3R0NnA4M2QzL0Q5eUs4YVI3N3Bld0EzUVZaMVFiUjl4bi8vamU0WE9mOFNFM0hJOUpINmgwNy9jUytFT2o4ZmRsanJhNzI4UXU4ZE4xQnNqTDQvaWI3dTRuM0hEK1IzY00zMlBDWDlkWTRsKzRZZWtlSDhQMzhQNlRKOXcwT3luOE5MYW8rSkNuMjA4SnZPazYvMGUzaG53WFJFUkVSRVJiTlBRQlJzSlZ6VWozRDBPa3lHSmlBMVNpSGFHVVFoaUdyc3Y2UnlJaW9nZnhtOVArTjNNdEpJV0l0czhhVXdTaXJBbmNOcWxmeHBSNmZ6a3JsVlpETnFWYkJxMDdocDZtQ1ZxdEpoTFhiYnV1RHlneXhpZmIzdjJlSUFoWFA4UGExYy9nL2lQUnRxd3RTejUwck5mdFltVmx1UWcxNm5RNjJJcTRGTHNqdzdwWXB0TWtBaEVSQVZFZ0ViRitqb2lJaUlpSWlJaUlpSWlJaUlpSWhrelJCZ3dDMVdpOE9KZFBpUUJhNXV1K1ZxNitHUDYwWFgvaFFtTUZqSEwvTll3UTF0MnowbDlyRFVQVlNtNVhxVnVqRkVKYU4vSjh0Z2lLNUJXZVZra2pwQWovdWRMRWd1L091M0s4anVPdXMrU1doZUpLckc0eHllM3E2L3d5WXRaYlBOeHIxazVXWHV0Vy9iSjBhM1YwMWEyZ0VnblVaWXc1OVBDQjRoS2F1U25DeEh3UVVuTG5lczE5bG4vY2w1cDd2SGJYOEx6L21kcUhHMm1ENXBVMkZoNFpSK3B6MzdCRHJsMUQ1MFFGYlJ1dU8zeCtIUGhTdXUrTjFvMERoU0RPZGoxb3pvUnVITGpCV2hBV1hidk84TG1IanQrYXhwZnVlSjhQWlRxMitzTDdlK3I3NTRaOGF5ZkhFaEVSRVJGaEJBS01NaU55cFcwYVNWOUJ3eG9hSXJwYnJWWXZ5dlRNTEJxTlpTek16NE9JaUlqZVY2bFU4ZmlUSDhMQkkwZEJSTHZEQjRSVmF6VkUwZnBCSnFjZWV4eXRWZ3ZuM251bkNEM1IzUzdlZnV2Tkl2RG8wNS81MldKYmxvaDIzazkvL0FPc05CcjQ1amYrWURXOHFMZUJvK29iTUhmelJ0RzljUDY5WXJtZm1wN0JoNTkrRmg5KzVsbU1UMHlnWEttQ2lHalVuSnlzNEhxemh4TVRGYlRTSEF1ZEhUdWZpSWlJaUlpSWlJaUlpSWlJaUlpSWFOK0Zxb1R4OGtIOGU4Ly9OZHhvbnNlL2Z1di9qU1R2RkdVOVVnaVVBcmdpU21QeCt5RVp1Ykh3WVI2NTlpa2oxdlEwR3RiYVhOdjNBeWRDaVRFcFJTbVFLRWtJVVFrZjNKNU8zMG9HNldUR3A1YmtuZFRlU0xXTnU5cjZrNWg4dThNUVEwQXFXWWRDWFVWeXhWL1BMdXZwTUFpa0QwZ3BnV2hFUEZMRFI0VENMN21iUDE4VWl6Y2g4S293K0ZVVjROcDdTMmdjQThweUhJZGhYSkU0NHBhWFdiYzZxcnZYZnNTOU52YnZjMnVVd0swNjZyZDdMUEFKOS9jVDdyRi94ejJYSHgvSEw1Z2M2ZVUyZnZ5Z1lmR2Y1YnYrdGE3Zno3aCtmTmwxajdqdTB3LzdEdTR6ZnV3KzQ2dnU1dGN2TnZCMVBOeWtLNmVrdm1OWU42SGF3VUpySEwvdVB2Tko5NW4vdWZ2d3cyNzRqcUJQWEhPcmJqY1dYemxjd25mQ0dHZXdObDNoaHROTngxc3ZLOTk2YkYzdWUxMTAzOCtuNnYyNnU3M2t4dW1ySUNJaUlpTGFocUVQTVBKN0phdi9oNGUrVmRsRVJEdW5YQzRYUVVZTU1DSWlJcnFiRDFieHY1SGxVaGxFdElQYzBieTFLL3NZWTlEdGRwRmwyYm92UFhqb01PTGxKVnk4ZUI2Qk8wSllxVll3TlRXRDZla1poT0hkNXdha2FZSThaNE4vb3Uxb3Qxdm90TnRZV0pndkFvejhjdVdYMDkxZ1hCMVBtaVJZV2xyRWxjdVhrT1VaSmlZTktwV3krdzBlL21vN0lxSTdCVkpnb3VTM2JTd1dlQjB2SXFKOUo4dmpDS2FPYitvOVNhL25qbVBxWW51YWlJanVOajR4V1RRNFVzSEc5dmRWZlJiQjJFSElVZzFFUkVSRVJFUkVSRVEwUElTUWlGUUprK1ZEV083ZGZHQ0EwWVBmajZLVm5PLzY5SjFRSXJCV0NnVnpPNGhIQ1JGS0tXUWc4WUV0Nm03MXpyMW50WjlSSUNJcEVRcjNmbXV0RDB3eXZoMmI5cSsxL3NSSENBd3c5MTJWNy9qeDR5YUZ4SkF5MXRaKy83OS9lUUlYMFByODZUTTVCb2liN1JwdVFsMTBjOXEzM2QyTGR6K0pIMzdRKzhzTjVOMXhMTG4zWDNMVCs4eTl6eHVKeTI0ZVg4UTJhWU9ta3NVOGRlYStKd1hlOEdFd25SRGJIZmZMNi9iZjRFMHJjQU1iRTh6TW9Cd25PT3o2OVlRYnJsT3VPKzRHM0EvYmVXRnhRMnVzSkUwVUp6RmZkbC90UklhdUcwOE5xeEc0ZjduN3ZDWDNWVU0zYmZ6eVUzS2ZYWEw5T09CdVY5ejdIM0czQTdkMkNIeXdrVjlCQ0lQbjNFckpuOHo4T2xaWE1mcEJBOWR0SUhPSFFwYmRUVDl0NThUcU9rdTVjZWhQSWxLM1ZuZkZlSFNmZjlOMWZPalNlNjY3ZEdkLzNERGRkTU1wM1hObjFoNXovV3E2OXpmOU5NY1crZW5zK250VEJVV3dqdzhHdXVhK1VkbDl6dTExcnY4TWNldDd1dTVaZDJOSlJlamd3YXYzQjA1WDE5OU5YMm5UcmVzemQ1aitwaHRSL3YwMVZ4NTMzNzNteGtua2Z5cnM2blM1ZXpyWVlucHI0K1pWZDd2bjNyc1UrTys2U2NMTkt6YkVrbkhUeFgxR2ZNL1R4WFRLdTV2dnIvWEwrcjIvTnRabk51R2l6RGM4N3hNUkVSSFJQaGo2bGxDdWtzVG1SbGkvaFQzUU5TUjNTRFNJYUljZFBYWWNZUlRqd3ZseklDSWlvdmVWS3hVODhlUlRPSER3RUlobzU4aEFRZWFxdUowa0NhNWR1WUpXYy8zak0vL09MLzR5enA5L0QyKy85UWFtWjJaeDZ0VGorT1NuUDRPUFBQdjhYYS9UN2dqaTB1SWlPbTIyK0NmYWpvdHV2L0Qxc3ovR08yKytnVlpyMDhkTk55WFBNeXd1TGhUbEI2OTlGeTkrL0pNNGNmSVVudm5JOHd3d0lxS1JVNHNDdkhCa0hPOHN0SEZodVFzaUl0cGY4YkhuTVBicFg5M1VleTZjTzRkT3ArMjJwMzhDSWlKNlg2bFV3aWVlK2d4QzE2Mk5qVzNvUFNLdUlxaE5JeGc3QUNJaUlpSWlJaUlpSWhvTy9xS0hvWW94VVRtSWw0NS9BYTlmL3lNMHVqYzMxUS9sb3p4RUVWamgreWpMUVAzV005Z0tlYXV4WFNVc2VoalVRc3l1UGRmTmJON05iYnJjMWNhYUl2MWk0SytHNnI1dXRSaC9zY1Jxd3ROd1VsSStsdWVpRlNEL0ZvQ0JDakM2MUlJLzJPakwvNGd0ZUJOb29sR0V6Zmp5OTdCTHJqVHgxcTJibjhjdXVkVEViN25PYjJFYmpvKzdkVVNHVTVENE5iY01QK2tlZXRrdEFsMjNIUGlUSS8rZnJyejZXQWMzejd3L242UVhPa1ZRekxXSDlIUFM5ZU1sWWZGcEsvQVgzVU4rdmVIWFJXWGZodGRLL0YvZEN1T0tlOTFYc3dZUzE2TUhudGc4QjdTd09zMy82dUVTVG9ReFBtRXRabDMvNjY1Yjk4Rkk3cmtsOTFsdE44eGZEVFZhNzdadzM0cno4akwreWEyYi8zZnNrTE51WEdCMU92dnlyMDVVY05pR09PSnVQNFBWTUtPQ0c5WlhqVVltRlZwQ1l1SENNczQvckw4N01WM3Y2bDhIVjEzSGx6L3c5NC9WM0RSV2Jwb0lQT0xHWWV5R2I5em4wUW54ZnBDUW0wWStMS3FaVi9DNzE2NWh5eWVlM3pHdnZJb2RkSGtGZnhsRVJFUkVOSkNHUDhESWJXUnI0eE9NbEJ6MEJDTzdtc0xxOStQWWdvMW9oMDFOei9pMFpSdzdmdUwyWXpyUGthWUptbzBHR28xbDBNNTQ0cW1uUVVTMFUvSXN3L1ZyVjRyUWpqUkpRTnRUcjljUlJUSEdKNmVoZ3RVRG1UTXpzeGdibnlpQ2pJaG81eWdacklhVHVLTkIxaDBCeXR6NnJMRzhoS3RYcm1CcWFncWw4dnZIK1NjbUovR29PM2I0dVpmL0JPcGpZOFZ5T1Q0K2ZsOC9mUkRLbFN1WGl5Q1U0ak9VUWh5WGlpczJFZEVIYTdkYm1MOTVFOWV1WHNIaXdueXhmWEV2dDhRV2w5MktsY2FZeWpBVzVJaWtRZGtWOFlETGxYV05RazlMck9RaHRIdlZrdS9hOVpkTC8vbStOd2NPSGk3V0E5TnVYNVdJYUZSVW9nREhKOHBZN21XZ3UwbjM0eEM2NHVzcU94MERva0hpdDZsNnZSN0s1WUUvbDNua3FMRURpSTgrdTZuM3BJc1dYYm1DYS9sNUVCSFIrMnEyRGp2ekJFUzFpbmhxZWtQdkVXRUpzbFNEaUdzZ0lpSWlJaUlpSWlMcUIzbWVGd0U4eHF5ZVV5UGwxZ0p6eUo4L0dLSWNqV0dzTklPcHloRzBraVdrdXY4dTlPTmI0c1VLcWhaSm1WbFlIMlprakJYdXFIVUVJaG9JdDBLR2p2bndJbmY3OEszMnRUNEE2SUs3dVJCcU5NOEFtem9aeFRUUWsxTzRhalhlZFAwOTQvcnpPZHdPVXl0RTduTXF4dUpKTllZRnJPQ2RqZlRYQnVpNC9wMlRBZ3Zhd2gwb1Fja05zM0w5YVV1TkxCSm9ObHJZdDVXbGlORDE0eXd6ZU50MTU5Y2Vsd0d1NmdBbTBPaGxHcnQ3MWN5TmtMaml4bVBMR2pTdFA1M2NUUXMzRHhocjN4OTNRcnZuRlRwSHJpRzdCaUlpSWlLaW5UTUtBVWJsM0lqWWJXUVBlSHhSd2RYM01NQ0lhRGNjT1hvTTB6TXphRGRidHgvcmR0cG9MQy9pN1RmTzRzckZSZERPK09pTEh3Y1IwVTd4NitxNWExZUs4S0pXZyt2cTdacWFuQ3lDVTU1NTdnVkVjYWw0Ykd4OEhJZVBIRUZjS29HSWRrNGN4L0M3ZHo1a3lOclZ4dWpYcmwzRlQzL3lRenp6a2VlSzdkTTFSNDg5VXBTbm4zM3VvZjMwb1c1bmYvSWpMQzJ1cmc4ajl4blZXdjEySUJrUlBad1BEM3IxZTkvQzlhdFhjUDNhMVhWZjR5dVhmR0RSZEpEaXNVb2JwOHB0ekVZSlpzSUVzVnovR1A2Tk5IYWxoSGU3VmJUZFVlb2ZOaWQ4ZmRXNkxsNDRWNVNaQXdkUnJWWVpZRVJFSTZVU1NieDRkQkxMdllHNjhOK2VjRnVNS0VtTjFPMERMek5ublFaTXlkVW4rUEFpdjIxRGd5VSs5S0dpYkVheVhNWEszRTI4a2I0RklpSjYzM2hsQXViVTV4Qk1US0oyOUNpSWlJaUlpSWlJaUdoMENMRmFob0cvU0o4eEJybk80WnRvTWNCbzZ3SVpZcXB5R0FmSFRpSFJYVnhjL0NrV08vMFhZQlFwb1h5SkExczBacnZhTk12K2lMNHhsZ0ZHUkFQQ0N2eEY5ek0wNjI2K2ZFZnIycmRkK1hxVzR1MExYY3hoa3k0RFhTemk3TkU2YmlpSmQ5MEs0b0RyOTJOM3ZNU2ZJREFwQlY0MkZqOTJ0emNVWUhTOVZRekxwb2RucjV4ZmhqOXJ4NWZ6NkdPWFY0cnB1eUdYUUVSRVJFUzBzNFkrQ0NmVEpsd05keDU4dWJGdFk2My9McnhNTGRFT0d4dWZnSFlWNlI5OThXTzNIL1BoUmRldVhzYVY4KytpdWJRQTJobDNqbU1pb3UxYWFTemozL3pMMzBHZWRybXUzZ0hSRTA5Z2Ftb1N6ejcvSWlxVlN2RllFQVNvMW1wRnlBclJxSk5TNHVEQlEyNjdVV055Y2dyYmxTUTlMQy9PbzlOdUZXRXA1OTU3RjcxZUQ2RmI3bnlabmoxUWZPWkd2UGJkNzZEUldNTGxpeGVSNTFteDdNNjY5NTk4N0FuVXg4WVJodXVmTCtDWDdUQU1HVkpHSTgwdk0yKy85UWF1WEw2RWkrZmVRN2ZiV2ZkMVBxeG9Ja2p4b1VvTFplWFdBMEdDc1VBamxocEsyQWYyZnl6SUVjbE84ZDdNU2h3dmRZb2dvMjh0VHlGMTkvM3RlLzM0QjY4V3krMnhSMDRVWVdUamJwK1ZpR2pZMWFJQVQ4M1djUGJtQ3VodS9uY21oa2JhZGR1UEpnUFJJUEhoUlRWWHJ6QXh3ZTBaSWlJaUlpSWlJaUlpSWlJYVBmWldHUVpabWlJVEF0Lzc0YmUxVUJacXFxMktnS1lOWG04K0RHS0VNc0xoc2NjeFdUbUUvZFRvenNGSDhxUzZCK24vU1lWeVdIZWxocjAwNWNaRDRNYkpTbThPSzhrOHRNNWcrM0NPOFJQYUQ5ZFVXVlF5SSt4Q1I3ZmRVQ3Bqd1JNUGlmclVpVG8rclJWaXQraCt6QURSclRWMTExcTAzR3I3QjlENDNXNEpLOWhHZHRxVkpwckhnSE5pSEc4S2kxT3V2NC9pL1hhdnZ2SEJTUWxjQlJFUkVSRVJqWXloRHpEU0Z0SWFWM3o5ellDbmxtdGpVL2MxZVBscG9sMVF1dFZndTFwOXY4SzVVcTI0U3ZZRVVSU2gxMjJEZHNZakowNkNpR2luTE16ZkxLNU1ZMHpPZGZVT0NKUXFnb3VPSEQyRyt0Z1lpT2h1UHV4bmJHeTh1SXBVdGJyOWh1TSt3R2g2ZWdaUkdCWUJSZ3Z6ODJpdXJPQ0ZqNzZJNDgwbUp0MXpHdzB3dW5qeFBKck5GU3d0TFJidjhhRkVmamsrZE9nd3lwVnFFV2owUUc1RkdnUU1LYVBSbGVjNXJsKzlncHZYcjJGeDhjR0JpRE5SVXBRWHhwYUxJSWxvZzNuWlphbUxNaG1zcmplbXd4U05QTVNQbXVQRldUenJCUmhkYzhQanRWcE5sTnp3TWNDSWlFWkJJQVVPMVV1WUtQRkNqZmZ5aHpiOG1XVCtoT0N1NllGbzBDUkpVZ1RCRWhFUkVSRVJFUkVSRVJFUjBlQmFPOTV6L3ZLN1ZnUUdBUmFLYzNpbDJGaGpyVGlvb2hSV01WRTVoRW5zcjI3ZWhMKytmRGR0dWVGWENGWGtqbG1IZXg1Z1ZJbkdpL0ZTRHVwUUlvQVdPV0Q3TDhCb0xhaXFFb29vTjlZc0NkRzJzQUVEaklqNmx4RTRLUzNxN3VhamEydHA0ZHVsQ3JnVklDNWRiT0VuMkw3ME1yQjR3dUM2bFVWUTBXSGNIV0EwN2Rab2RSQVJFUkVSMGNnWStnQWpWeG5paWtXdTBaSUNSZ2tNYkV2c1RvYWFObjFZRTBWRVJFUkVSRFFDZkREUTBXUEhpcTRRMjAvSXpmTU1CdzhleExVcmw3R3dNSTl1cDRPT0syZis5ZGZ4dmU5OEcxLzRwVCtOK2xnZEgvdkVwKzU3YjVabFJlaktxOS81RnBZV0YvRGJ2L1gvUjVva3hYTXpzd2Z3N0hNdjRQRW5ueXFLOGlGSUR4aGUzNDl1dCtPZTNsaFFFdEd3OFVGQm5YWWIzMy8xTytoMTF3K0UrTlQ0QW1wSzQ1T3VHeFhCUlJyYldXS3FNa2NZR3Z6NVF4ZXhrRVg0Vm1NYWMybU0rU3krNzdWL2VPYnJPSERnVUJGMjV0YzlRUmlDaUdoWUtiYzlVb3ZjdGt3MXhHTlRWY3kzRXpRUzV2bDdxWlZZMEFIR2poN0Nrek1NZUtMQkVzY3habWRuTWNhZ1pDSWlJaUlpSWlJaUlpSWlvcUdROXRvS1FZNlY5cVhWQnpaNEtwMFBDbEt1VEpRT0lKUVJKaXVIaTlDZ3ZaVHJGTmI5Kzg3NWZ3WmpEZHJKY25FdW9QL25oMFc1VW9zbml0dEh4cDlBSEZaeGJPTEQ3bG1KUU8zOHNFb1JRQ2lKZy9WSGkvSDR6dHlyU1BJTytwVS9aMHE1a1hXd0t1dTkzTnI1anVtNTRmWWhKVHlwaWFqUHVGWEtMMXJnMkoycmFIZC96cFV6N3NaNTdENWhmWUFTZzg2SWlJaUlpRWJLMEFjWXJhWDlXSUhVWURXNmRWQnBpMUJiTU1DSWlJaUlpSWhvSC9qd2tFcWxzaG9pRW14L2Q5cGZ3Y2szNXZYQlE2VlNDVW5TZ3pFYVZ5OWZMa0pLbHBZV2tPdHMzZmNhcllzeVAzY1ROMjVjTDBKWTFsU3IxU0xFYUdwcUdoTVRFdzhkaGw3UGY2WXBnb3g4bDJqVTlIcGRkRG90TEM4dFBmQTFoNklFVlpYallKUmdKNFRTVmZCQXUzNTJFVXVEdWoraEsxLy9IQjYvakVkdVBlR1h6NTBJVGlNaTZtZCtOUmNJaVZLZ1VJc0RMSFpUMENvTmdRUVM1WElWOVRyUDY2TEJFa1ZSc1I4Vk1vaVJpSWlJaUlpSWlJaUlpSWhvS0ZpcmhURVpVdDNGVnZpQW5qVGYybnUzeXpmSjh1ZnRMWFd1d1ZpTlZuTC9PVVBqNVFPSVZJeXg4Z3lNKytkZmoxMDZiV2MxUEVtaEhOWGRjZkpKOUR0L1hGKzVnWGFIOUVQalJveTcyL09Qc3FrYlVSOFNPTzZXMFdOM1B1U1cxTFo3YkE0U2U1R1U1bGR4Z1Z0QjhBcXJSRVJFUkVRalpPZ0RqTmFzSkxvVVNZR3A4dUJGR0ZtTHpPMDA2azVtd2t4YjdyUVJFUkVSRVJFTkFlRWI2SmZLZU95SkovRnIvOGx2NEx2Zi9pYSsrNTF2b3JHOGhFNm5qWC8wLy8ySHhlditwMWYrRVVybE1tWVBITHo5M3F0WEwyRmx1WUUwVFZ4WmJkenZYL1BTeHorQms0OCtqazk5K21lS0VDUWllcmh2ZnVNUGtPZnJCNFc5V0Y4cXdvVSs2cm9WcGJFYmZDalNyOHhleGZkV0pseVp4SHdXbzYzZnI2NWJhVFNLMExUWHZ2ZHR6TGgxd0pNZitqQ0lpSWJkOGZFeS91eEhqdUQvOTVNcldPcG1JQ0tpd1pGbk9USlhwcWFtc0I5ODJQREJRNGVMa09EcG1Wa1FFYTE1OTUyM2l6cTA1a29EKzZGV3E3djFZL3JBc0hJaUlpSWlJaUlpSXFKQklyQzlQSjgzYjM0SGw1WmV4NS84OEY5Q0xaNUFxUGJ1SWk1dnU4OXVwY3RvSm9zUGZNMUtiOTU5UCttNnYxZWtiL3pnOHRkUml5WnhZdm9qbUNnZndvbXBqMkNuSFIxL0VnZHFKM0QyMmplS2dLZCs1cWQ5NFA2VUFvbXBNa1NpcldpeDZyUC9XQnl3eWh6RDdPaTBIYVZWUjhzNEpoVW1MSERTelFkSDdyeHVvcnVadWNjYnd2andzWjJqSmFhbHhTTldJTHJqNDNydUE3OWhnTGRBUkVSRVJFUWpZMlIyUWpNdEZOeGVrUFhSMThLSFBnL1VaZXVOTWI1WWFTd0dhYmlKaUlpSWlJam9JWHd3aVRjK09ZbUpxU2xNVGM5QW05V2dsR1p6cGVqNnhwOXhITUg0S3puZGN1UDZqYUxCMVZwSTBkajRSQkZnTkQwOWkvR3hjWGU3QWlKNk1KM25SYmZWV2lrYVdkOUpGcGY4c1VWNDBYU1FvcVFNWW1td1c2b3F4NWo3cklrd1Ewc0g2R2hYaFhXcitzZFhDS1ZaaHNiS01zYmNzazFFTkFvcWtjSk1OWEpkbmtPM1Jyc0RBNWtyeHZLcWxUUjRpcXZHM2lvMEF2cGdNbGVyMWFMTUhqZ0FJcUkxRnk5ZUFCRVJFUkhSZHZoVGovMXhHeDlNU1lQUFQwZXRkKy80SHhFUjBiRHpoMzIyYytnbjF6MTBZTkhOVmlDRnhIaDU5d09Nak1taGJZNU8ya1N6dDFCczN6MklmODRkblVXUzU3NzVXZkhlM0tTWTdCMHF3cFo2V1JOS3hRaGxoSjJpWEwra1ZLNi9FUUozMjM5ZVAvUEgvcFN3Ymh4SW1SdnR4cGMxd29JSEJmdUkyNE9KWVh3NkdMZDdSMDFvRVdpSnNsOUUzVko1MThrMzFxMXUzRklhU1F1RkhYRDRNQ3F5Vlh6V21PdHYyVDBrNzN6ZTdVWXZTSWt1aUlpSWlJaG9aSXhNQzRCMlp1SlErdjJlc09sMml2ek9WZzBEb3BOYjNjdHRsbHVVVEYrYytrdEVSRVJFUkVRN3hZY1lsY3NWZk9vem44VkxILzhrZnZyakgrSGExU3Y0eGgvK1BucmRMcnFkTnJyZE5wYVhsKzU3NzZIRFIxQ3BWUEduZnVYUElneERuSHJzQ1JEUkIydTQ1U2xOVTF5K2VQRys1eWFDREZOaGlrK05MZUpvYVcrT25UOVZhZUpFcVlQZm5UK0VqZzdRTS9KMmlGR24xY0wzdi90dDZDekRSNTcvS0lpSWh0MU1KY2FuamsvanEyL2VCSzFxWlJiblZqSTBNNTVZU0lQSG42TmNMcGNSQkF3bEd3VitPb2RoZ01YRlJleUhTcldLbzhjZXdjenNBWHp1NVg4TFJFUnIzbm5yVFZlM3RyeHY2eWZ0ejFRSkl3UXFCQkVSRVJFTnBpUkprT2NaM24zN1RSQVJFUkhSOXZUeU51REtkeS8rYmhIVzgwdlAvS2ZZYmRlYjU5SG8zY1FiTi84WVM1M3JHMzZmZGY5UzNVUGE3ZUVIbDcrTzhmSUJYRzI4amFjUGZSWkh4bmZ1WEwzVnVzTVFSOGVmUkxmU3hIdnozMGUvVTFMSWlUSmltWXEwbFltbWdTMWJZT2RTbldpYnhJeXc0aGdxbzlOMmxGYVpBRlYzbUg0Yzl1NHdJYzg5UHVzZS82eVJlQTg3SUdyaGVTdnhGOTJ5LzdJcngrOTV1aTBGdmhwcXRFQkVSRVJFUkNOajVIWkNFMjJWa2xEeElJUTZXMnNzaFBFWCtjaU1WY1l5dklpSWlJaUlpR2hZK1lhOVBzeW9WcTFoZW1ZV2p6NTZDbm1XbzlGb0ZNLzdLM3F1VVlFcUdvWWVQSFFFcFZJSjVVcWxhQVJGUkJ2VDZYVFE3WGJXZmE0c05hYUNGSUd3MkN2U2ZWWWdES3J1c3lmY1o4L25zYXNMZXI4YXFMaWliNTZqM1c0aGNzdDZHSEY1SjZMaHBhUkFMVktvaEFweElKRnBDMlAzYnAzY255eHk0eS9VWUxIUTB4aUxKRUxKd3dYVS85YjJjZnkraSs4U0VSRVJFUkVSRVEyYXRmb05mMHpXR0I2ZkdSYSt6dG02NDI5cGxoWmRJaUlpMmg5SjNrRW1Fc3kxTHJyam56SEd5alB3MTN5WFl1ZU9LMm1Ub1p1MXNOS2J3MUxuR25LZFlqdU15ZEZPRzY0c281VXNvUnpXM0RIdW5Rc3VqNE55RVpvMFNQeWhhM2Q0WDJRR1FuUFRpbWpmYVlGTUdYVGQ2dlMrSmRMdENvVnVrWjEwTng4L05vWlBHb3ZsNHRTY0ZLbGJsbzBJOGNBclBwb1VGVzJod2hoQnBoRzdIazI3MWRYenJoeDIvYXpkMmVyVnJjVXVDb3ZMSWtkM3NZTUVSRVJFUkVRME1rWXF3Q2cza1BNZFhZdVZ3TUdxUXI4elFxUnV4ekJwWjdyY1NtMDA2azAwaUlpSWlJaUlobGtRaEVYNThFZWVMZTcvek05K3J1aGV1bmdlV3V2aXFwNXJwcWFuVWEzV0VNY2xLTlgvKzdkRS9lYks1WXRZWEpoZjk3bWpjUmVmSEY5RVBjaXdWMkpwaXZKNHBZV3kwaml6Tkl1MVQvZmhSV21hWW5scENSZlBuOFBNN0FITUhqZ0lJcUpoTlY0S2kzSnNySVJEdFJLdXQzcEk4dEd1SGZkZlA5Y1dyeThuaUFPQlR4OHNZYnJFYlVEcWI3NXhYeGlHYnA4bFJxMVdBeEVSRVJFUkVSSFJJUElYbGZETjBZOGRQd2thSHFrNzlwN25PYTVldVlTY0FVWkVSRVQ3NXNiS3VhTDdoKy8rSTB4WGp1TFRqLzRLcEZDUWF1ZUNJeHU5T1Z4YU9vczNiM3diTjVybnNGM05aTEVvNWFDS1R0ckFZek12b1JaUFlxY2NIRHVGVENjNGUrMFBNU2dpcWVSRVNZVExQU08wWWNzM292Mm1MWmFVUXU1djN2dWNBR2JoaThBcENmeXFPNngveHQyZkMwSmNNaEpkV0Z4OFVIOWxpSTlJZ2RqZG5Bd2xEcnQrL0xKYjR2MEt1N3JPNS95UDdzL1NoUTZ1Z1lpSWlJaUlSc3BJQlJoNS9tck5QaSsybFFvZEt5RkRKZnJ1a3EvVzU5bEM1TDNjeUY2T09OVlFyTU1oSWlJaUlpSWFUV1BqRThWVkgzUDkvckhFU3JsU05BYjJqWUtKYVBOYXpSVXNMUzNlOVpnU0ZwRXdHQXN5VElVcFFySDNKeXRQaHF0WGVRdUt6NzQ3bU1LZlNMM3NocmxXcjRPSWFCUThOVnZIeTZkbThNL2Z1b2ticlI0SWVLZVJvWk5iSENvcnBPNVl4K0hxeUIzaW9RRWhwU3lDVmljbko0c0FJeUlpSWlJaUlpSWlJaUlpSXFJSFdlbk5JemNaZm5ENTkxQXJUV08yZGh6MWVBcWxzTHJsL2lWNUIvT3RTMmowRm5DeitSNWE2UkoyMG56N01ucDVHd2RxSnhHcUdIRlF3VTZvUlpQUVp1OHV1cllUcExTcUZBZ2JLcUdUM09hQWpTejZyNjBlMGFnUUxiUXhqbHdBdjJjdFpuelEwRG92SzdreTZWN3pVVmkwTGRBUXBnZzlhanlvdjFiZ29QQW5OVnFVM08yNldPM0gya21PZnNYbHI4LzFFN0hhajYvRGdDZjdFQkVSRVJHTm9KRTZ1OTFuQUdXbTZOcE9VU21Db0I4RGpBU0VqMW5La3h6QlNtSktQblNKK1VWRVJFUkVSRVNqYVh4OEFrUzBzNXJOWmhFR2RLZkExYjZVbGNaWWtHUDZWcERRWHBzS00xVGRNS2gxc3NuV0FveG1aZytBaUdnVVBIV2dqa0JKZk92U0ltNjBRRmdOTUxyUXpQSFI2UmhTQ0FZWVVkL3k0VVUrY0hWcWFxb0lNeUlpSWlJaUlpSWlJaUlpSWlKNmtHWnZBZTFrQ2N1ZDZ6aFlmN1M0cUo4UEJkcHFnSkh2bnc4eGV2M0dINk9UTnJEaytydlRGdHBYaXZMaGc1OUJMWjdjdVFBajF5OXI5LzZpYTlzUnVBa1d1TU9EZ2JRZEtaQnBLL3lCYkI0a0pOb24xNEFPR3VnOE1vYmZjNnRUZjdYRTlRS015cmZLSkRaNEhWVnh4NDMxVG04c2lzVjMzSk9YTGpid2RSQVJFUkVSMFVnYXliUGJ0WUZvcFRaME8wdVpFcVlYS2hFSFVvVFlmOWE2WVVweUsxcVpEYnVaVnBrR0ROT0xpSWlJaUlpSWlJaDJUS3ZWUkdQNTdpdXJWVldPUitJT3hvTDl1NHBaSkRRQ1pWQ1Z1YSswUWx1L1gzV1hwZ21XbHhmUjYvSENSRVEwR2g2ZnJ1SlF2WVRQbnAvR1RDWEdIMTFZd0tqekZ6dkkzUUdEZjNxK2pjbTRpKy9NeGY1a1VEdytIaFFIZTBKaE1hWjgwZGlLaFZ3VkYxUG91cmZYUllacDhmNXZUaEFFeFluQ0owNmNnRklNVGhvV2VaNjdBMVBXYldNc1Erdk56emRSRkNHTzR5S3N5Ti8yeGF0V3EwV0kwZHA5SWlJaUlpSWlJaUlpSWlJaW9vY3gxcmpqb1FrVzJwZHc5bHFDaTRzL1Fhd3FtS2djUnFRaVZLTUpLQm1nRXI5L01jRGNwTWgxaGw3ZVFwWW5XT25kZ0RFRzE1dm5vVTJHeGU0MTE4MnhHM282Um1aQy9PTTNseEFGMTFBS1YyNS9qKzN3M3dtdUh6OWVlQkhsb0l1WmVCNWwxVVU5N1Arci9wU1ZrQ0lXcXBFYW9RY3JnNGxvS0FVcC9qZ05FVXZnZndPSkNRRThDWXRKOTlRUkM4d0tnVmxzZ1h0dlcxZzAzYzJMN3ZhUzYrODFLL0NPVzNYZGNMZmZkTjBsRUJFUkVSSFJ5QnJKczh6ZHpwRkl0VlU5alNSVW9xZms2cm45MkdlM2NvcDBacTNxdUpvc0gxNmtHVjVFUkVSRVJFUkVSTFNqZkJoUXQ5dTk2N0ZJR2t5R0djcHlhNkVQT3lHVXZpTElJZzRNWW5ja3YzM0hvUGdUcXZ3dzUvbitCU3dSRWUwbEgxN2srU0FqSDlyREFDUDNXK0QvdUorS041YlQ0djVDWWxCU0FzYVdpdkNpaXZzZG1RMDFkTGkxMzdJclNWQmNVS0dSb3dndml1VDdKOEdHVVFRcEphSW9MZ0pyYURna1NWS2N4TzNEaTN5WTBXYjVrS0xWK1NKQ3BWSXA1ZzMvMk5qWVdQRTRFUkVSRVJFUkVSRVJFUkVSMFVZWnE5Rk9WNG9TeUtnSUxEbzgvampLWVIxVGxjTUlWUWxDdkg4TUtzazdTSFFYemQ1Q2NmdjZ5cnRGY05GYzZ4SjJXMm9pSkNiRzIzTXBXbnJGRFZ2aUR1VmFkK3h0WndLVFZub25VQXRhN25od1V0d2ZoQUNqMEIwNkZBS3luUWwzYkp1TjRZajIyN2tlTHFBSEhCL0hQekcyQ0N4NjJUMThCQUwrdno4cFowc0JSdTY5cWZ2VGNUY3Z1SDVlZFl2N1dabmh1emJFK1l1Tkl0aG9kNUxqaUlpSWlJaG9JSXowWlhJN3FTbjNNbE1xaHlxTGxlaE5sWVZWdmk3TGlqTDJtblgxWlFiaWVrZVhjbU9RYW9EMU5VUkVSRVJFUkVSRWUwTzZJK3V4MEZEWWYyUHVpTDZ2dFZ2TUloQVI5Wk0vT1BQNzZIVGF1SGJ0R3ZaSzNWV1dQNTFyUEIrUEliRVNiNlFWMEtyM1ZsWkQ3YzZ0cEtncml3T0J4c2RxUFV6VVVtekZ1WlVBZ2NreDFiMkpCQWJ2NGYwZ3BEQU1JS1RFM0kwYkVFS0Fob080RlRJa2xkOEMydngwOWU4d1JzTmFDK3VPYlJXemhqOHIrU0hoUlNkUG5zVFUxQlErL1BRemlPTVNpSWlJaUlpSWFIZVVLeFVjUFhic29hOXB0MTA5ejlVcm9DMXkrOEJUMHpQRi9uVzMyd0VSRVJFUkVlMGNIMFNrYllaTGkyZmRzU2VmakxQYS9FMko5OC9zV2IxTW1ISEhxa3pSemZYZVpXYjhhUGtqT05jNmhVU1hrTm5JSFRjckRwUzVzalBuK2hoN3dQMDlnSXZ0WXpoWnU0QlB6bndiSlprZ2xQMmJDMUlLWk9nT0c0Yk4wS3dZQVozbGRncTBiNFFVSjkxeDNFcmFpM2dDMm9nNzFjQkYxN240b3ltOFhzNFFaaHBCYUJDRzl2MTJ4VHJHazI0MVdyWUN0UWYxUnh1OEZ1Zm9LckY2TWtsYm9SY3A1SjBRK2NRczBuZmVnVCtKaGExaGlZaUlpSWhHM0VnSEdGbDNCRm03UDhaWW9mMUZpcTMwNTFoalAwNjl0N2QyMExRYkZuK0ZZOHZkTlNJaUlpSWlJaUtpUFNOYzFZd1BNUkppL3l0bGhIVERZbGc1UkVUOXA5dHBvOVB1b0xteWdyMFUreUxxN3E4QnZTKy85VnZSZEtQRkhlaEF6WTJmTERld1d6d3hOOHY5aWJBNVJPN2ppeXp5dThhM0xVSnBmTU5HS1JsZ05DeDhBMHNmU0JYRmQxK3RkcU44YUpGMjg1c3ZSdXNOdmFmajVxRnF0UW9pSWlJaUlpTGFYWDQvUGdnZWZucW9EeXkyUEZGeHkvdyt0VkNyamFjNUhvbUlpSWlJZHBhOTFjcEtZL1ZZRkpDZ24yUTZRaWV2SURPQlA1S0tuYmU2UDlmVkFWTDNXZGJ1eG1mc0xPSDNrc1JxbXp6SmcvdjlRTGxwRW5GdmxjNEFxeWVSTE9LQkovczhFcURtRnR5eUZCaC8wR3VDR1p3N2Z4Njk5WjZibndjUkVSRVJFVkZocEFPTTFuUnlHN21DVm1hTGlwSmpkVFh2YWsxa3BMRHJhYy9kM0M1cVk3TnJMWDNRVndxd2JSb1JFUkVSRVJFUkVSRVI5Wk0vL3FOdjRMMTMzOEVQdnY4YWttUi9UZ3o5Qk41Q0RvbFR3UVJhb29TYmFod2RFYUVqNHczM3c1OHRLVzhGdGd5YmtyVVlOMENTR1Z6c2JlemtWVm1jU210UmNXUFdCL2s5bmMvQkdJTnUxaTJleis1NGJidlZLcDVMa2g0YjVBMlJLSW9obGNMQlE0ZWcxT1lQR2ZyNXdRY1NkYnNkOUxyZERiM25uYmZmS3JwK25xcldhdmprcHo0RElpSWlJaUlpMm5tUFAvNUVVUjdtOWJNL3dYOXorbjhMb2xGWHFUQnNtWWlJaUlnMnBxZExhT1kxdEhVVnFZbXdGM0lUb3BtTlFRbU5VRzd0WWpaN2FiWXN4LzBSNWZjVzg0NFZSVE85TW1qditXc2crY3NmbWJELzA2OW8zMTFxNFNjZitLSUdpSWlJaUlpSVBoQURqTzdnVDdyM2xTU2QzSVlDVmhrcmlrY0RKVE5wcmZSdEcxYnpvTEhwMWcydXorNi9xeTF5SGUxckFFelJmOW5USnRTMmVKYUlpSWlJaUlpSWlJaG9VeFlYRi92LzdEUWFlTTJWRmRucjlZUTJ4VVVTOXpYOUo3WVpjaWlNbXpaaWthSmlOeGFvVkp3WDZmN0xBYmd5NVZiRTdtdFZqRVVvclJzL0c3dVlwUjhUUHJnbzhVY3RYTmY0Y0NMWGp6elA3bnV0djZvcGc0dUdqN0dtdVBacHI1ZEF5aFNibGFVcHNpd3J3cTAycTlQdHVObk5XdmM3dHFrM3U4K1N5MHZMQjI3Y3ZQSFk2ZE9ubDlkN2pkYTZycUFldDhJZUZSaU93REkzbm0ybjA3SHV1NXV0ak8rOTBtbTNwWitmZ2pEY2x4RWZocUdmbjIzWGpTczNiM0dsUlVTM3Bhay81Y1B1Ni9xcDJXd2FDSWxTdVR6VTZ5ZjNQVVczMnhWN01hN2Q1MWozZVZ6bjAwaHFOSmI5ZG84MHh2cmxEYnNwaUVKZi82VFJCOXd5TDkyMnNYRHI5S0ZKSm02MVdrWUthUmNyKzdNdVcxbHArbmxvRUNwTHJLK3pzSVhodUVTa1ZFb05ZOGoyb1BLVHd4VlhQNks0WFRFaWZLaTMreUYxMDE2NjM1V05uVW92M0V1eENUNU1mN3YxRkd1L2VhNitTejNvTlc3ZTFXNTlzdTE1MTMvV25lWGU1LzFuckt5c0ZOL0ovWFp0ZWh2RXY4K0hvYy9QejkvMW1mY093NzJmZWUvOXRjZTIrcDE5L2VLRHZ1Tk9Db0pneDQ3ZitUcFl2Ni9WNmZZMnZhL2wxbXZGNzZmN3pUZHVQc1F3OE9QQ0Zlem1Ob3piemk3bTJlVkd3NmlnLzVyYitIMkJyZXgzK3lZcm02MlRIM1IrbVY5YVhoVCtPS2V2R3dvM3VlNXl4ekxRV0dsZ2JtN3V3Uy9hd0pUdzY4L0UxWjBQeWFic0tyOGFIWjVkczAwUjd1QmFLREozWERZcnV2N1l0ZDIxWTlDMk9KNHJpK0NpckFnd0dnVEZybzZiM2NOYnE5QjBNQWFiaUlpSWlJaUlpSFlBQTR6dW9HL1ZCOTVvNjNGZlh4SUhBcEVTdmJISXJJUkt4SkVVc1h0SjVKNVRtKys3eUYyZFp5czF3dmEwTWMzVTFOSWNwZHpZT285NEVoRVJFUkVSRVJFUjBWWjg0eHZmYUlOb2wxMitkREZjWGxvTXJERzcyeXJ5QXdRd21ORk56S0FKZW9BR3NObVZ3Z3BvVk9YWmFsalZqV3RYc05mT3ZYc3VDYVBJZHJySnBwS1RzaXdyTHk4dC8xc3JLeXVmY0t1RTFucXZVVUw1NDU4MUFUR0pJVEcvTUo5M09oM3RTaHJGVWQ4ZVdyeDI1WExRN1hYbDVPVFV2dnhlQkVGZzUrYm44MWFyYmRMY01PU1JpRzdycFdtc2pSVnUvYlNGY3oyMkwzSy9lVys4OFVZU1I3RjlwMVliNm9hQ1M0c0xxdGxjOGI4RnUzNzUrV3ZYcnFWTnQ4Ni9jWE9PVGFCbzVQamx6RzMzQk1aWXVkdnJ0aUFJamF0LzZxSVBYTDkyUFhMN0FxSGJML0RmZVNoYXlyNzV4cHRkOXp0aDNubjNuWDM1ZlZoYVhQVHpVQmw5THM5ejdibHBuL2QxcXVzbTFHdTFpdkRwSnRRWGxBcDhwaFFxbGZKSWhUcU1zaUJRdnA1SmxDdFZxZk9IVnlIY0NzMUJGTWVibWovaVV0bTQzMnZ0cXIvTThrcHpTL1VVYnBXbnJMVXlTNVBLZzE1VEtsZDhsZkMyNjR2OFovbjBoU3hMeS9lRzJkOGFCejRBeDlWUnRZMzdic3I5Zm14cUhlYkdSZWEyMzIyUzVyZ2pRTWgxZmFEUTZzZllXK2tQL3JHMXovUVArOGZjS3JOSTRuZkxhMTZFRndsc2FYbDFQeWVobStaUjhYMTNLWG5ERDdjYlJ6dDIvTTcvOURXV2w5VHk4ckxhYkwxYkVJYkc3US9iSC8vb2grbjU4K2VIWWgzbjl6dlROUFg3K0RGMmlkdk8xbTZlTmErOTlscFc3c01nNGw2dkYyMTJYbkFMalc2MTI5WnQyMi9zeWlCRHdzS0dLeXNOZGZQbXpUakxOY1luTjNmWTRQS1ZLMWhlV2NHVjY5Y2Uvc0lQV0pzc3ppK2kwKzVnU0RabEM4S3Fvb3lpV0tWRkdROGJHSThhYUtUanlMQTdtL1krdkNpVU9jcXFWM3hXSURJTUFpVldMeTQwVlZaQ3V4WFFYSnZWZDBSRVJFUkVSRVNqZ2dGR0Q2SGRFWkZjVzlYS1JDblFJZ3lFVUVyNk1HZ0JLYUNsc01aVnJEeXdFdGRWK01mK01FUnVFYmlES2lvM2lOeGpTTjBkMzk5aENsQW5JaUlpSWlJaUlocGt2cDZtWitYdGdPdjkxTk1LSFQyYUozclI1aTNNTCt4cm9BeU5obDZ2RnhocnBiOVNyMmRZdVUxRVcrUVB0QUVTU1pxcXpCMDAyK3p2bURaYXRsdnRzU1JOSWd0YmZjREwvSWVVWEtsaFNLUzlWUHBtYUVLSTBPbmJsWEMzbDZna3lVUVVsL2FsTWJuN29STHU4NVU3eEN2ZHZEV2FsMzRtb25VWjdSdkJ5bjFiUHltbFJLdlZEcnBCWXQyNmNxZzNwanVkdGt5VFZPN0Z1TzUwdXdHRThtMy9HUDVBSTZmYjdVcTMzZVBYYmJ1K3ZFa1Z5SDZwZitwME84cUhUVmdNejZxMDJXd0dQb2pUMWIzc1Mwdm1icThqOSt2M2NUUGNLSkxHYXNUR0NLM3RVTXdBVWFra2ZUWUhxQzhvNlRZcmhFU1c1cHdtSXlMWEJuNXRFcGNyc1ByaHEyQlJuRFV1b0VLMXFmbkRuM0x1ZnEvZC9OVVJXNjJuOElFK1B1aEg2d2ZuSDRYdHJ2K2QzdmE2Y2UyempORllKOENvS0oxT3Q2ajdDY05ZdXVNRW0vcE92czdHSDF0WVdGajBQYjhWWUxUYUQydlhvai9zMnJEYy9zelYxeFlQS3g5YzVMUGZpZ0NqTFg1bkgxemtpaWhpVFhicEo4VU5ud2lDem81dFAvbHRuMjZuSTlNczIvVHZ0cFNoMzJhMGpVWWpTTk44S0g1RC9YNW5udWU3dkk4dmkzbDlhV25KaDg3MDNYaHpxeTIxMmUvdjFrbFN1emVPMnJGbHQveW9UcWVqM1B6dnh3SGllSFBabmIxZVVyeHZ1NGRHdTUwdVhIM0pycTEzOXNYN3EvR1JkYkIwcytqTzkyYVFtaENKS1dHblJUSkZQV3ppWVBtR3F3RFRBNWZrR3luNGRuUUlsRWlzc1VwYnRtRWtJaUlpSWlJaUduYmMrWDhBWHpXWWFWZGNuVWtudDlIYWNRNVhnUUozNUJpeEVwa1V5TjM5aFFmMXc5WHpUL3RLejU2MlJlT09WS01LSWlJaUlpSWlJaUxxTzVtVmFPc0FhUjljSWE2UmhWaktJeEJ0eElVTEZ5b2cyaU5oRkJYaFJUb2ZqQ3M3RWxIL0NjSUlTZ1ZvdHRxaGJ4aTRzdExjeWtaUEhTT20yK3NxWHhxTnhrQTBMcW5XSnJCZnV0MmVjZ1dOUmhORVJIY1NNdGpYOWRQYzNQeElKUlh2eGJodXQzdktGWGRySGtTamFxL1diYTcraWVjWTdwTDUrZmtZKzJ3L2Z4ODNnWW4vdENlNlNRb2FKUUxqNDlNYmUrRVdyZFZUTEN3dVlSZHRMbzFqYS93NHVMMHVEc0pTVVRaamRWekExUWUyTnZxV3V6N3pEb05RUCthSGZWZU8zMjMxZC92bXpmbHcyUGFkZG5zYnhpKzczZTUxOUtzdGZIOWxUTEZ0UDdJWHg1RXkzUFI0NjNhU29tQmhWOWZqQTBsWTVjcG9aMG8vV2p0ZmxLdmR3K2pwTXVaNk05aHBGZFhHaWRwRlJDSkZLSE1NbWtvZ0kyMnNLU3NzcHhDeDFwYjFDMFJFUkVSRVJFUkRqanYvbTVScm4wQnZmWEo5SUFSa043Y1BQSHFsTFdKWUNETk1TZWxFUkVSRVJFUkVSQU51WW5JS003TXJtSitidS8xWVd5dGM3cFp4c3RUQmZ2SERrQmlKeENxazV1NFR2VXB4MlEzelFWUXF6TWNtb3YwVFJxWGl5cUEyWXNnYUVXMk5sT3JXbGROSCs2cThSRVJFUkVSRVJFUkVSRVJFTlBnbW95WGtwb1Y2c0lLZEpvVkJTWFVoTWJodDB0eGhRVEZaVXRWdWJzeEtZdHZhMkRDM29pOU9PQ2k3dzVVUkQxa1NFUkVSRVJFUjdTZ0dHRzJTOFgrc0R5ZTZuZnpNbGhwRVJFUkVSRVJFUkFPa1ZDcWpWaCs3SzhBb3RRcEx1VUJYNzk4VjRueG9VZGNFeUsyQXZxZFJmeENGcU5mcmlPSjl2eUEzRVkyd0lCalppN0lTRVJFUkVSRVJFUkVSRVJFUkVSSGRwYXg2Z0N2MXNBbTZueFJDVkVMRTdsYlN5MjAzY1RlZzBSY2lJZGdna0lpSWlJaUlpR2lIRlNFOC9rS25vU3dxQnJRU0lsY1NQU1hRRGQwZFlZc0xvWnFIOUVNS1dKRVluK216K29DeENIT0RHbUJsN3RPUmpRLzhBWTB3MytUT3pTaUlsVWo5WEJVcExMbXVpS1dWYmhiemM0ZHg4NGgwTTVFd3hpci9ubTV1cDN3MzZaUEtLU0lpSWlJaUlpSWFEZ2NQSFVZY3hUai8zcnUzSDNQMVdVaXN4UFcwaExPdE9rNlVPNmlxdmEyVXVKU1VjYkZYUWMrbys1NnJWbW80ZnVKUlRJeFBnSWlJaUlpSWlJaUlpSWlJaUlpSWlJaUkrbDltQWxnSS9HanBPYVEyeE5OanJ5T1FPV3BCRzZNaURrUXdVMUgxVm1yeVZtWldraHdWWTFmYk5PNlhxZ0JLQXNOTDRISEE1bEoyU2lBaUlpSWlJaUxhSTZzQlJpakNpNG9rb2xEQ0tJa3NrQ0tKZllDUnNNSTk5OEFBSS9jVzZmNUxxNjBQTUNwaWlveTExdlhUR0o5TTQzcXFEZE9MUnAwUEwvTHpXS2lFY1RkdHBFVGlaNitTRXNyTk5qNG1TMmZhU3UxbU4vY0NaZDF6cVRGWURjWGkvRU5FUkVSRVJFUkVPNmRVS3FGU3JkNzFtRDlSeU5kQStQQ2dwZzdocWluY3ZiME5NR3E1ejEzTzE3KzJWeEJHcUZackNDTmUrNHVJaUlpSWlJaUlpSWlJaUlpSWlJaUlhQkNzbnBNa01aZk1GcmN6R3dJR0kwVUpLS1dFU3FUSUF5SHlwQS9haWJuaGNNTTF6QWxHcUsyMkdDVWlJaUlpSWlMYU84R0hwc091cndseCs5d3hWZ09OZkNtN01yUDZrZy9hV1YxOVBnbytlS2MyTjNiT0dLU04xUGlrWk5sSzdiaXhGcHI1TkVQSHp3MkJGS2lHb2xXTFJMc1VpREYzMzg5WGE4bk5KKzUrTlJDcnUrZWhxWkowTlhYV0dDc2FpZnZUeWF4b3B5YnU1SmJwejBSRVJFUkVSRVMwWlNkT25rS2U1L2phNy96V2ZjKzkwNm5oU2xMR1JKZ2lsQWF4MUpEWVhRdFpoRVZYZnJBeWpqYzZZM2M5RndRQmF2VTZabVptY09qSVVSQVJFUkVSRVJFUkVSRVJFUkVSRVJFUjBlNnltWVZ2OEdaWHpLMUdVZ0lpY3FXNnVUT0p2algvU2N3bnM3amVQVmpFOWpUU01jekU4L2k1ZzkrQUVybnI3ZDVlWUcwL2pjV3k3TXQ4UjY4azJ1YnQxRXdZaU4wK05ZdUlpSWlJaUlpSTlvZ1BLOXE3T0YxYkJCUnJLWHpsZ3BVKzRNWVlhNFd3MWhSLzExN0dpTjlCNWdPby9RUU9aSkZJN2ZpNzI0bWxGdExYUmlsWHorZm5tVkFhbzkzOFlpem5FeUlpSWlJaUlpTGFQQ21WS3daUkZCZjMwelM1L1p5dm4zTDFWR2pyQU8wOFFCenQza2xDL3JOOGRWaGlKSnJ1czFLcjdudE5FSVFvbGNwUXJrdEVSRVJFUkVSRVJFUkVSRVJFUkVSRVJMdlBkbzJ4MmdJOXN4cXdFd2hZSzYyTTNXUEt0NUo2ZUR1cDNDaG9CSzdyeWgzbkJCa3JrZGtRUFYxQ0xIc0kxT2dFR0sxUlFpZ2xZS1FVRnU2Zk5xc05DajlvbkJJUkVSRVJFUkZSZjNQVkp5anRWUXhNb01TazcwNlgzLzlBYlZWaXJHMTFYZTFMSjdOUk83ZGhwbTBBR2toK3lzYXVGaWxXc0lkcWdXLzlGN25IcXRncUlYeDkxSGpzcXZ0aU43ZU94YktyclZ5ZWErdHFPN094dGlBaUlpSWlJaUlpMnBSS2RiV3E0dWxubjBPYUpEajdreC9kZnE1bkZYcTV3aDhzemFDbU5QN2N3VXVvQnpsMmczSEZoeGI5c0RtQk0wdXo3dmI5bFhTMWVoMmYvdXpuTURVOUF5SWlJaUlpSWlJaUlpSWlJaUlpSWlJaTJuM3BkenNyYUJuWXJwMVllMHhPQjFxZGlqSjFJQWhSRnc5dCszYTlkd2hYT2tkeHNmMEltdm5ZN2NjWDB5bjBUQW5mWGZnWVR0WGVjK1VjUnMxa1dSWW5iNjJrc3BkcFkrZmJSWUtSdEw2Tkl4RVJFUkVSRVJFTnJIMFBDcElvWXFSTGtZUXlJWlNVUW1jYUp0V1F2dm9oTXd3ekdoUlMrQlJzMkVvb2RDQ0xCbmNLMWszaUhReklFc0lxWlVWY0RvUnY0NWUwTWh1NStZUUoyMFJFUkVSRTJ5Q2wyeUZUQ21FWUZyZnpQSWUxVEF1OTA5cTQ4WVdJaHNmUlk4ZlI2YlR4NXVzL0xkWjd4cGpiejYza0lWSWpjYjVYUVVWcG5DaTE0ZGNBY2dkcUlVeHhjVGFGcGc1d09TbmpabHBDN2g2ejl3UVkrZkNpc2ZFSlRFM05vRmFyZzRpSWlJaUlpSWlJaUlpSWlJaUlpSWlJZHAvSUVacjg3dlpLTmpmR3RFeFBUbHQvQ3RHNjdkMXlvNUNhQ0kxMEhQTzlhZWlpMmR6ZE1oTmkyVDIva282aG1kVlJVbDJFY25jdXNOYlBBZ2tsaGJDMVdMcFJhMjJpMGJPd2diWDczOTZSaUlpSWlJaUlpRFp2MzNmb2hSQ2hFZ2hkalVNUmsyeUFqcXRveUJhNk9qUUdZamxoZ05HZ0NOMDBERnk5Mm14RnBhNWF6bGZHbFhZNldraEFSa0lpR2kvSmRzMmltNnprWWU3bUU4MjIxVVJFUkVSRVd4WUVRUkZnNVBiUGl2Q09UcWRUZE84TThoaFZQckRJajVkeXVWeU1Jeit1aUdoNFBQL0NTMWhwTE9PYmYzZ0dXdXU3MW5zTFdWeDB2N015aFZnYUhJbDdQb2dic2RqK3V0Rm5NUy9sRVc2a01iNitjQkFyZVlCc25aT1ZabVlQNE1EQlF6ang2Q2tRRVJFUkVSRVJFUkVSRVJFUkVSRVJFZEhlc0ttdElydTdzWkx0MnN6ZXpGdjJZQkM1dS9GNjcwdE5qS1YwRXRlNmgvRmVlLzF6Zm55QWtYKytGclF3RmpVeEc4OGhsRTJNbWtvZ1FuOGVWYXdzRW0yenVZNXA1Qm9WM1FmdEhZbUlpSWlJaUlobzgvcHVoMTVZaEQ2bHBob0taWDA5anhBZFl5RTdtUzM1K3d5cTZWKzFTQ2FoZ3B0Q05oUytCbW1IdzR2dVZBUmZ3Y3BxSUxzYTFqWVNXd01SRVJFUkVXMlpEK254NFR6VzdYaFZxOVVpeE1PSGVmajdlWjdmRldoazdmRHVtUG54NElPS2ZIQ1JMMzZjK0c0WWhrV1hpSWFMWDhaTDVUS2VldnBaTEM3TTQrS0ZjL2U5NW5wU1F1QXFPcjZ4UEkyYXl2RmtwWVdTTUtnR1c3dnEyZVZlR1IydDhKUDJPSm82S01LTDBudkNpOVpDNVQ3c2htdHNmQnhFUkVSRVJFUkVSRVJFUkVSRVJFUkVSTFRQZkl1cDNGbzg1QnpLVmw3RmhmWnhMR2NmZk02UER6cDZ0L2tvSXBtZ0hIU2doSUhBYURXYzgwM1BwUHNUU2FqSmtxaGtSc2cwdDFsUHcrVGErdE5WNDkxdG9UYmtJaEYvOWU5K0lmN0YzL2hhQWlJaUlpSWlJcUpkMW44QlJnS2hxMVVJcStGcXc5QTRFSTBrdDJHcVRjblZPMEJyVUo4YWkyVVNTRDhKVWRydHFpRmZOK1ViOGxVak1XOGhkQ1BSRERBaUlpSWlJdG9pdjIzdCtaQWVMNHFpMjhGRlBzUW9UZFBpOWxxUTBUQmJDeTN5eFk4UFB5NFlYRVEwdkFLM25KZkxGWHo0bVdmeDNydHZyeHRnZENNdEZkM3Vzc0tCcUllWk1FVmQ1VnNQTUVyS1dNb2lmTHN4QldPQjVKN3dvbUs0M0Rxb0NEQnl3eFVFSVlpSWlJaUlpSWlJaUlpSWlJaUlpSWlJYU45WitNWnQ5c0VwUTJzQlJwMjhnZy9pQTR4V3NqRWNLVi9EYkdrZVNxUVlSYXE0OEtTUWtVSWwwU1pMRlRLYm1Od1lXUGMvc2hBTU1OcWkwSWc0blZxTTNVMEdHQkVSRVJFUkVkR3U2N3NBbzNzcGdmRnlJTVNocW9LcmhEQ3QxT2E5M0FhWkFWdVE5Z2szZlZJcGhKWENsbDEzVDZkTEtaUmp2cXVFTGlxc2lJaUlpSWhvWjRqaWdMQXFpZy9Tc01WRmcyd1JZT1JMbG1YRi9iV3VIc0MwV1I5UTVMK24vMzdlV2xqUld2SFBDZTVuRUEwOXY1NDdmdkpSeEhFSmtWc3ZYTGh3RGhmUDN4OWt0SktINkJtRmYzTHpLS3BLWXlwTU1PdktXSkJqSmtvUWk3c0QzalFFY2l2UXpJUGl2VmZUTW5wYTRYSlNRbUprVWV3NncrTEx6MzMrRjFDcjFZc2lKTmREUkVSRVJFUkVSRVJFUkVSRVJFUkVSRVQ5ekZpSlMrMWp1TjQ1akVZNkRyMkJabS9hdmNkWWdSdmRBOFg5eDhmZVJTeEhPMmNta2tJcEtXUWtaV1JLRmowL0lpMncyTk9McmhQa0JtT2dEZE5LSEpkSnhaK0E5a01RRVJFUkVSRVI3YksrRHpDU1FvUnd1OGxLK3BocWFVTmxUS0o5MVlNRjlRY2ZYaFM2T2pNaEVMbEp0YWV0NnBUN3pGdkRBRGJuSXlJaUlpTGFXVDdFNTg2dWwrZjU3U0NqdGVBaWYzc1ErWEFpLzkxOGdKRy83UU9NMWg0am90RWhsVUsxV3NQNDVDUm1EaHpFM056TmRWL253NGh5cmREUlpWUmtqcmE3N2F1bmNpdFJsbTVkcVBSOXI4L2NjOHQ1aE1Vc3dxVmUyYjBuY1BmRDRzU2pkWWZsVm9EYTRjTkhVS3VQSVFoREVCRVJFUkVSRVJFUkVSRVJFUkVSRVJGUmY5UFduMWRVUWRlVWtObU5udk1qWUYzcDZqSmFlUTFVbk5jcGZXUEgxZXRTK290UVdoaGJ0QnZMakdWYndrM0xWVTBKVVFZUkVSRVJFUkhSSHVqN0FLTTd4UUZrcEdSY0NXMG56MjIyMERPMXpBeldkeGhHdFJBclVTQlROeUVPWXAvbXFiR1NuRk81akpCaUhFUkVSRVJFdEd1VVVuZDFxOVZxMGIwejBDakxzdUsrdiszNTd0cHplOFVIZ1Bnd29yVndvclZRa0RBTWkySDNqNjJWTlhmZUpxTFJNekUrZ2RwSG5zZkU1QlJPbkR5RjE3NzdMYXlzTkpDbWFiRU91MVBYS2lTcHhGd1dRL25JYmJGYTdtUDl5VWtDQnRKMTNXMklkY09MNGpoR1hDcmhwWTk5RXNlT244Ung5L2xyNjFraUlpSWlJaUlpSWlJaUlpSWlJaUlpSXVwdmlZbnhnNlhuMGRVbGJOYVY3bEhjVEE3ZzZmSFhFY3NFOUw3bzFpbFVqNHlwR1gvK1ZaSmI5REticm1TMnBhMnRXb3NZUkVSRVJFUkVSTlFYQmlyOHh6Yy9oWEFETFZFTWVSaUkzR1pHNWxaSTBINlNhcC9iK1lZQ1d2aDJnRVJFUkVSRXRLdldRbjd1RGZ2eDRVQSt0TWp6M2JWd0lCLzY0YnRyejNsMm5hdmcyQzFjR1dlOXdLRzF4OVlDak5iQ2l0WUNqUHg5WC94dElxSTdxU0FvU3JWYUswS01wcVpuL0VXOHNMeTBWS3lqOGp5Ly9WcHJSUkZHcExkNVVTOGZzcVpVVUlUQlZlczFqRTlNWVdKaTBnMkhLaDRuSWlJaUlpSWlJaUlpSWlJaUlpSWlJcUwrcHEwc2lnOHZ5czNtei9uSmpZSng3ODl0Z015OVA1UTVhSlZjT3lkVVFFa0R1RkhseHJWRjRGdVFHVmhqclQ5amxTZUVFaEVSRVJFUkVmV0JnV3dKVlZLaUNpVVFTZEd3VnJVdXJ1UXp2cjJZMldhak1kcWFTTWxhSElpS0cvMzdsbU5VQ1lRMlZtZ21HQkVSRVJFUjdaKzFrS0F3REIvNEdoOEM0b3NQTkxvejFNZ0hnNnc5dmhFK2xDaUtvdnNlWXpnUkVXM1hnWU9IaW5MaTVLUEZ1dW1mLys0L1JhZlR4dm4zM3NWT3ExU3FlT2JaNTNIeTFPTjQxQlcvL3ZRaFNrUkVSRVJFUkVSRVJFUkVSRVJFUkVSRU5CZ1cweW0wODZvck5XeUZSbEJjU08xSzV3Z3FRUmVuYXUrQjd1ZFBEUzFMZ1pKUzBWaU1xVWJQdEx1NVdXNW5kc3pZd1d3alNVUkVSRVJFUkRSTUJucm5YSWpWNFk4Vk10L3Q1QWhCZTA5WUNTc2c5aXU5Q01XOG9DU0VaSUFSRVJFUkVkRmc4R0ZENG82ZENCODY1QU9NeEFaM0xPNTkvOXBqUkVRN3hRZWllZE96c3hoTEo5RHJkYUZ6alc2bkEyTzB1OSs3SGNxMjBmNzU5VlJjS3J0S0RJbXhpUW5VYW5WTVRjOFVRVVorUFNnWXdFWkVSRVJFUkVSRVJFUkVSRVJFUkVSRU5GQ01GYkIyKytjdjVqWkFhdGcwYnFNQ0NSa3JFU1RhNXJtRk5UNEpTb0Fua2hJUkVSRVJFUkh0azRFT01BcWxxUHJ1d1dvd254dklUak9mQXUwNVY3TVQ3bmM3WVNWRXJBWFRzb21JaUlpSSt0MmR3VU5yNFNCZUdQS2dPeEgxbDNLbHFIYkNML3piLzI3UlBmZmVPMmcyVi9ET1cyK2dzYlNFYTFjdkk4c3lhTDJ4T09WeXBZd2dDUEg0RXg5Q3JUYUdGei8reWVKK3JWNEhFUkVSRVJFUkVSRVJFUkVSRVJFUkVSRU5wdHhFcm16L0hNaVZiQXlKamtFUDUwOUI5V2VmanNXeTdEcGxBelI2dWMxNnhrd1o4RXFZUkVSRVJFUkVSUHRsS0FKZnBFQkp1ZXFGU2lDUzNGaVZHZ2JaakJwWHZSUzVJa0ZFUkVSRVJFUkV0QXRxdFRxaUtFSjY0aFE2c3kzTUhqaUFicWVMTk10Z1RBNXIxMytmRDJqelFVV1ZTc1YxQXh3OGROajFKeTZLbER4ZmhvaUlpSWlJaUlpSWlJaUlpSWlJaUlpSWdFQmtDRjJoelNrcEVVa0JsZVRDdUx2Vy9WT2dncFNtWXFTc2dJaUlpSWlJaUdnUERFWFFUNmhFTFpEV1RKYkZjanNWY1pvWUJoaU5HQ0ZRRmJBZ0lpSWlJaUlpSXRvTnN3Y09GdDJqeDQ3ZmZxeXh2SVJ1cDRNa1RXQ01XZmQ5UHZpb1hoOHJ3bytrNHJreFJFUkVSRVJFUkVSRVJFUkVSRVJFUkVSMHY3THFvZVFLYlU0MWt1V3E2ellTbXhqajg0c1lZTFRHQ2pIcE9pc2dJaUlpSWlJaTJnUERFL1FqSUVwS1ZtMW9rV2lSNWdZcU01WVZEbnZBVmV4azF0ZHBBQ0g4bE5pUFliQm9Xd2cvdlVzZ0lpSWlJaUtpRGNuekhPMTJ1K2hxclVIOW9WUmEzYlVOZ2dCQzdNdHVObTFRdVZKQkZNVXdSc1BZOVlPVnd5QkVHSVlRVW9LSWlJaUlpSWlJaUlpSWlJaUlpSWlJaUlaTExXeEJDSXRBNURCV3dHd3hQMmNzYktBYXRFR2JJLzBwZHRhTnYxallUQXVzSkhZRDd4SjNsQ0ZtTWUxbXlPWnFzNy85SWpZeVFZaUlpSWlJaUdnSURFMkFrWEJWUGFGQ3JBM3lXSW5NWUJzMVByUTVWaGozMTdqYWhIQy9hak9zUmVxS241OFpZRVJFUkVSRVJMUkJ4aGlrYVlvc3l4aGcxRWY4OUZDS1ZScUR3SWNYSVFJUkVSRVJFUkVSRVJFUkVSRVJFUkVSRVkyb2t1b2hOd0ZrMGJ4S0ZnMnN0cUxzK2xNSnVxRE5FYmYreEVxNmFlQkdmckxSZDQxQWdCRmtSUUtWMDZmMzU0dTZ6eDMrOENKcmgzMG1HaXlDZ1ZrRnpwZjlnL01rRVJFUmpaaWhDVEJhRXlxQnliSzBzbWVRYTF0VStuQUxiM2ZseHJSVExkSllpdEJ0VU8vTFBLV3Q3YmtKelNhRFJFUkVSRVJFbTJDdExVS01kSjRYb1RsRVJFUkVSRVJFUkVSRVJFUkVSRVJFUkVSRU84VnFDOXN4c0czVFF0dTJyTEF4bEFqVWthQXFRaWt4QkVLUm9heTZlRzdpUjFoTUovRmU2N0ZOdlg4Mm5zTlkyQ2hLU1cwb2ZXZGRObkhqT1hYanU2VlgwRUhIQmlpN2gyVndJcXBqQkZSQ0VlWUdtSE5qQWo1SkNpSjg4S3RsMGQ3UURIbUFVUzZzOExGTy8renFxM3Q2UmNYNmtaZnN5Mzcwam9LMWNKTFRwNGRpZlRhd3Z2eGxOaUcrMTFlK3doQ2ovY2I1a29pSWlFYlEwQVVZS2VtckVBUUMzeFVDeG5JYmI3Y1pLM0pqc2E4dFhZczJ0N0NqVWJGQlJFUkVSRVMwdzN5SWtlWCtjOS93MDBJSUhqY2tJaUlpSWlJaUlpSWlJaUlpSWlJaUlxSUI1MXY2NUs3MGJHNGFPa0VFS2RSd25Sc2xoVUVvTTB4RURYUjBCWnRWVWwzVXdqWUNhVnpSMkxKYjQ5cTJiV3BYVENKSzhCZXFINWxRbFVCQVdiR2FTeVRnYjN6UWZDWnVsZUhsUm9Zd1FvcFRSMHA3K2tVbkQ3OEtYSHNKbytTTFR6L05rejczMFROZldlMmVMbVo3OGpoUDdxOW56bjdSNGlzUXB6bFBFaEVSMFlnWnVnQWpGUFVOQ01aaTFhbUd0bkcxbFk4bkdpRm8xN1F5NjhleENhdEM3ZGNNMVVoTlJlVW1pRUZFUkVSRVJFUkVSRVJFUkVSRVJFUkVSRVJFUkVSRVJFUkUrOFlBdG10Z0ZuS1RmS3VUQ0lPcWUzUmk3V2s1RXdJVkExRWRqbndkSDJEMDRmRTNjTGg4RFVkY3VkQSs3c29KWkNhQXhmcmY4V2o1Q281V3J1SlU3VDNNbHVheFZkYllJcmdvZnlmSjg5ZVQzRnBNQ291WnRlZE4wOHlMTVJtR1Q1WEdNZVRjbU5ibHdNNXJhK05VcXdNUENpa3k3cFZ1N25PamJianpuWXdPbERFeW5NTmNoRDJTTk9aMGE2Rm1mdlB2aVF3anhJZVYvUFJwTjFPZC9ha0M3Wm4zRHZlS2NKaFhUdnUxb0dCUXpCb2g3RFBXMnArKzhvcWJKNS9tUExtSGJzK1RYM2J6cE9BOFNVUkVSS05uR0FPTUNtN2JUdmlVYUNuOGJWY1p3MDI5M1dPdGNQL2RLSGY4K0M3RytCNTk5SzBwNityYWlra05JaUlpSWlJaUlpSWlJaUlpSWlJaUlpSWlJaUlpSWlJaUl0cFhWdnVHUmo1U29talpkVmVibitJSk0zd05nYVF3Q0VXR2t1cWhGclNRbXFnSXk5RkczWHBldTJLTCtKeEswRUVzRXdRaXg3YllZbHpEbXJXMEhudDNFNnZjK3NFYW1UWlhibTRUcTdGRXZzblorZ0ZHcTZPcGFCS0hZYmJhMGs4aEs0ZTcvMFVYVmp0emozN1VOQmEvUDNJdE9VK2ZodjNpUDM1L1ptc3RYR1E3eHoxUVI5bUExblg2SzEveEhmdEZQRjNjNXp5NSsyclR4NHQxMzZ2WG1tek5Ua1JFUkNOcmFBT01sQkJscFZBdUJiSUlxdXptbGlGR3U4U04yOGlQNDJrVEpGSVVkVnd4OW9pcnhFeDlmZEZLWXNZalkxQUdFUkVSRVJFUkVSRVJFUkVSRVJFUkVSRVJFUkVSRVJFUkVlMFhhNncxYzdwblZveUV0YVg3WHREem1SUFNwMDhNbGJHd1daU1Q5ZlBRTmtBakhVZG1RbHp2SG9TRndGUzhoRWdtbUMzTlE0a2NnZERZTnQ5bWJzSDFwMjBVak92dFBZRTkrbUkyWlhzV3dkTVlma0tJa2hKaFptelF1eDFncE5aNW9TeWVzMVpobU9XaUpEV0NZRktWZHIydG41VmRIWlpxOW45MTZQSDg3T0xqOWpSR2piRFBuRDF0ZjRvL2l6bk15ZHIwQVFuYUEwMDkrL1JjRVpVSHV0dnAwOFlIMnMyZFBsUE1pNXduZDFkNXpEZHpYbkczb2h4ZmZsa1hqZHFKaUlpSVJ0RFFCaGl0S1FYb3Vib0gyOHR0eVE1Zk1IZGZzTGYrOUxUMWdkM1lpMURtTmQzY1ZXaWExZUIxYnRFVEVSRVJFUkVSRVJFUkVSRVJFUkVSRVJFUkVSRVJFUkVSN1MvaFcvcGtTS0ZOdU43ek5vTVdxbWdLTkpSdDI0VDdhaElhSmRWRklESk14UXV3VnRoSzB0U0IxdFl1K0ZaWVJ1UnVOTWlxbENLU1FFMG9JY1NtRzJWWkRXMDdKckVwL0xnT01jSWtyQWlWS0JtN2xscmtnN0o4U0pTL2UrZW9GVVdnMVBDM1JiUFRicmJyNkVUdWZtTy9kbFBYcDhmMDJiT3dwMCtQWmpPLzAxLytzbjM1SzJkTWVhRXJNRDFrNld4OWFLR1IybU9mbnJPdm5EM0xacVVQSkd6ejhQZjBnWi9jbEp3bmQxZDNKUko2YWx6WHIxMjJEQzhpSWlLaVVUYjBBVWFWVUhWS2djMVdFaHVaWVk5RjNpZjJWbWtreGthdVBxTWM3dDFvWG5HZm1idEtUVitkWkxsWlQwUkVSRVJFUkVSRVJFUkVSRVJFUkVSRVJFUkVSRVJFUkxTdmZGaVA3ZW9lZXRhbngxVHVlejYxbVlHeGNramJ0aWxoaWhMS1puRi9LbDZDdjJxOFdjNVQwekphdjUwazJ2aU1JNnZraVRDUWs0RlV2a0hXVnNhR1JtNFc5Uks2eHFkVGpIU0FFU0JrckRDK0dwL2paejEvdzdjNmMzUGFYU05YRmdGR0dzUGQxTkI5KzFQdSs0ZkdtbDFiemxSdWJCQnF1ekpkVGkrMUYvTi9lRnFzTlRVY1BVTFlNMEQrMGovNG5waGVDWU8wdlNqR3l1SHVoMGVOSU5OZDFCT1BCdWFWTDM3Uk1Dem00Vjc5dFpkeXZBTDU4dGt6eGU4RDU4bmRZYm9sM1YyOHJNL2dEd3lJaUlpSVJ0alFCeGdwWWN1dWlpRUtwSlYrVDBSejgyL1hwTnFHUGtzb3pVVlhDQ0ZESldMc2twNjJPdGZXSk5vR09aT0xpSWlJaUlpSWlJaUlpSWlJaUlpSWlJaUlpSWlJaUlpSWlQcUNFTzUvVlZaaDFyOFl2VzNvcmcyRmIrVlZ4Z2l3SFFPYldPaUxhWWdNeW1aV0NRdGhEWVJaME5KMnJCRGpNaGVSZ0J4VG13c2hNaGEyNWZxUjJYVkRLVVNJbGxCRlVzOUlqT3U3cmJVNTg3T2FEelR5VFNrRnFtNkVsTnhNYW9wZ28rRmxyQlRhU3FtRDdpNEdXOWtzRW5GMkUzUG1MTTc2RVQzeURmMU9UYjVrV3NuWDhzeWtVY2RXM1V3MkNkb1pZU1czWVRlM0xkVE43S0c1M1AvWTBBZndBVStuVDd2bDhuTzV1eGQwYkdtNFYzeDd6TStUT2luclpxTnR2em4rQndhbnYrekc5V2tRRVJFUmphcWhEekNTUXBSZHZRSUNJV0hkdHJibVB2Q3V5UXdDVitkbEVtTmJyaFl0Q0pYYXRRQ2pKRGU2bTBHNy9jMlM5VFZIUkVSRVJFUkVSRVJFUkVSRVJFUkVSRVJFUkVSRVJFUkVSTFR2cklBVUZWbXoyZnJ0dUd4RDk5d3JmSmpDTkVhQTdWcll0aEg2VW5ZN1NHWnR6TmdsWFJRY0RydTJKQ3cyR1dCa2N5dHMyMHJrWnYzMlZZRnNJNVMrbnlNWVlPVDVNYjBXWU9TYnVnblVoRUpaK0djVWhwbjFMU3R0SUVJcGR5M0F5Q0RPa0NwOUFMUG03T25UQm9SWHZnanp4VmRhT1g1YWkyV3BKUE00WmR2SEhkSnNhMXZ2aGJxOHVHSmYrZEtYTkdoalRuL1pOdi9CcTNwNkpWUkN0WWQ3eGJmSHBKc25WUkxrRS9tc1FiRU9QQTBpSWlLaVVUYjBBVVpycXBGb2FCK3UwN0dNck4xRnhrTE1kVXpkN2Nwb2EwM0RkZU5JaVJLMnlWcWt1Yld0VG1iTFhWZDZ1UWxjL1pwaWVCRVJFUkVSRVJFUkVSRVJFUkVSRVJFUkVSRVJFUkVSRVJGUi94RFNsUWtGOFlBNEU5TTBSZnN1MnpYKzZ2VVE4WEEyRDdLNUxmSno4dGQ3bVZueGR4QTk2TFg2Y3RxMlNtajFTRmpCSmdoakE1dTQ4Zm1BTkI0eHJTVEdwTVJJMDdlS0gvM1NqYW9JeGdwb005ek4waklFSW9lU09oYzdIbUJVY3JOMVIwWnAzT3IybGt0NTY4eVhYOWJNN2JoRkNQdUttK0crOEhlL21seGZYRklUdGxKT2JUVGl5K0QycVV6YitsUTU3U2JkenBucDd6QXNhMU9FZmZYWGJmNzBQLzZwT0RBM0p2S1ZwZEQvZG9DMkpSS3BTY3JUNWt6eVFnOS8xLzIwL0QwUUVSRVJqYnlSMmNoMHUzaFp5dDJTWGVjRGhWS04wTHBibWZ1dkxIYWtnc1AxVHh2WHY4ellxS2ZkRFFPcHJRVVJFUkVSRVJFUkVSRVJFUkVSRVJFUkVSRVJFUkVSRVJFUjlSRWhJQ0xYVVE5NFByZXJGMHN2Mm5yNTlrRkRHaVJqVjR0cDVNYTIvWmQ5OFBkMHorZFdDbzFOc2xaSU54NGZHSXdrSWlGRU1Pb1hrTCszVWVGcWxvd2Q4dEZpaWk4b2hiSzdFR0FsUXNoY1d4T0grc3pwbjgwWlhuUy9DNHN0ZXdDelJrY1FaYXRHZkJuY1B2OXpFblp6K3pVZmxpVSt6NGFsbXlac2VlbDdOdXFFTmg4ZlI3bmQ1RHk1VFRyemY1ZUIwOEp3SFVoRVJFUzBhbVFDakVxQnJLaWlyb0VwUm5zaDB3am4ydmxVcUlTSVhCMUhOY1J5ckVTM0ZJaForR3F2aDNDVkl5MVlvWHU1N21nTDFVenRnY3lZVXVZcTA0eUJ0SDdYaUx1WXRBY21KcVpRZTI0YzMvM21INEsyNzlISFBvUnlaVk1YQWlBaStrQlJYTUxUejcrSWMrKzhpWXZuM2dWdHo3SGpKL0hNY3g5RkhNY2dJaUxhS3d2ejgwalRGTlIvbEZMRmRzSFU5RFFxM0o4aklpSWlJaUlpSWlJaUlpSWlJaUlpb28zeWJYLzhKZEhMc2lmS2FzRm1wbzdjanQzN01uMCtYUkYxR2FqajBWQ2VuS0l2cEN2R0J4TjFNV1lOSHBwZzRzYURHMmVieUpQUUZtYkp3SzQ4dksyY09obE5pUkZwUWVqR2hHNW5aakZiRFhRYXYvOFY3ZUt2UmRXOVZrQVBlZE5LYlNOcGJLZ2cxWTZlSEo1bFdaNUlrY1UzNW0vV2ZyYVZnOVoxOXZTWHNyUFc0dWYveHRkakxTdUJqRE9lcEw5RkdUSno4Z1NXZjV5K3JpRSt5NWFsVy9UcXI3K1V1eFZnL29YVDMxYTY1bjV4a2xpWnZNY2dvMDJTZ2JGSlhyTGxxUU9ON3VMbFRRY1BFaEVSRVEyemtRa3drZ0pLQ3VzRHZJdndHKzZsN0Q1dHhhM2NiMWZybzRXYkJxNFlINksrZmo3MTJqUXgxcjNRMWNxbHRnZ3pRbW9NdEtzVnlnM1VYUzhrMm1VcUNJb1NsOHBGU1hwZDBOWlZhelhVNm5VUUVlMjA4ZkZ4eEhFSnRIWENieVM3LzM0ODFzZkdRVVJFdEplMDFrV2gvbVJjdll5MXJJd2hJaUlpSWlJaUlpSWlJaUlpSWlJaW9zM3g1NmNXN2JpVTFkRHJYNUhlZEsyUmtSMjZxOVVYNTl2NC96MHIwUFpmejhwYlkrUCsxK0xXeVRsbHFlUW1XL3JaekJpYkc5L2YrL3N0VnNlcmlJVjhlSFRTY0RIV2F2Zk5IM0JDMnVxb0Z2QnQyNFI3cmNSd0U4TDRKbjNTS093UTRVWXdZcEhIblliKzJ2VldqaTk5Y2VpVzN4MVVOR2JOLy81UE5OSTVJZE1RY1NhRmRnVzBZU1lNdEJUS2Z1ZkNKWE1BMTNneTQ3YXNOdXp0L3YzZk41aURHU3Zid0lEejVHWjE4MjR1UTIxdnh2L2F2SXByWEFjU0VSRVIzV0ZrQW96Y3ZsN3NONk5qNVNzWExGSzJpOXNUdWRzbHpIT2dsOXNKUUUrc1BWNVpKeEU4ODhuZnRnZ0FyOTU2aUszbnFTOGNmZVE0UHZHWm44V1BYdnN1R3N0TG9LMTU4dW1QNE5qeGt5QWkya21sVXNtdG96K0hORTN4Ky8veWQwRmJFNFlob2lqR2lWTlA0Sm5uWGdRUkVSR1JWNXhFSnVWcTJDRVJFUkVSRVJFUkVSRVJFUkVSRVJFUjBlYjUrQlRsQTN6V2U5SmNTSzA5RU5qZ2lSaERwV2Q5ZUJITWxheHVsaDdlaUUwSWtidXhwTlVUOFl5c2JpSkV3bGhqbDNYRE5vMXZIM2pmMWFhRmtrMmYwU1BIMVNSR2hDaVNvMFRpTXpyV3Q1b3pFY3RsQklpZ01ZdGhab1NxYXF0cXh0b2R1MXF3bFNiTnU4bWxjTHFiNFpVdnNZWG1Ccnc4OTB6bjZ0VlgxYm5IZXBWV2xvaFNxVFF5YlhwM1FqbFJMV2x6Yy9ZclgwclBnbmJDbWJrLzZMeU16L1ZNSmc4aWlKUlYyYkNudWUyb3ZCRzBBL1N5VjMvdDE5enZ0MkNvRmhFUkVkRWRSbTVuUi9wTW5hTFZsZDJ4NUdEYVBHM3UzeTczajFodXJsTWZxbFpybUQxNEdHRVVnVFpQeUNLdUhlTVRrNWlhR2U3S1hTTGFIK1ZLeFpVYWF2VXhwRW1DTkUxQW0xT3QxakU1TlYzODVoRVJFUkVSRVJFUkVSRVJFUkVSRVJFUkVSRVJFZTBJSDhjVENvR3NhTXQxMzlQV2lrQWFLSnZab3RHWFVBTitvUzNydjVPRjdScGpHNjdrUmZzMXNmNUwzYmYzbmJLRUxBc3A0Z2U5OGlFZmx4aU43QUh2VWpDUWdnRXo2ekpGNW9TRWRoTkF3QXhwTTBNM2cvbTVxbXlnZHlTY1JGcDBMVXlhTk9aMDgrcVNBVzNJNmRPd0w1OXVXcDJyVEZYZGtxa1JtRHgxeSsyTzVVb05wVnpreFR6V3czSmVFMDNPYnp2cE5IRG1pM1AyVno3eG9heVRaTVpheVpseEE2VHUyTnd0dnZXNHFaY2JMUTFlRzVTSWlJam9QaU1WWU9TMkIwMDVGTTFVMnlCWkoxbWE5azdDNmk4YUlDY2ZleEtsY2dVL2Z1MjdtTDk1QTdRNVVSZ2pERU44NVBtWFhIa1JSRVE3S1F3akhEditLQjQ5OVRpZStORFR1SGIxTXE2N1FwdHo4dkVuOE5HUGZ4cXpodzZEaUlpSWlJaUlpSWlJaUlpSWlJaUlpSWlJaUlob1J5aElPUzRqbzYyeTNYV2V6MDNkOWdSc3kwQkVBcWdPZGhxQUR5OUNEdWhyZWFyZlNCS2IyeW9lMEg1UFFPUldJZzhmajBOMU9BeGxTUUp5RTk5ZkMyUG1UTmVtUlVqTi9mMGZWejBSaUJ4MEh6ZmEvYXlKc3V3aHRSRzZOc1pRc2pqc2M1b0NJWGZtQytibVFnQ1ZmL1B2ZktrTDJnUmh6NXlHL3NMZi9lb0tGdHp5V28ycXdvWWlEQ3pqVHg3Q0dKTzRzV1MrOWw5OXZnWGFZYWNOWGdFdVB2UGJyVHJxc2xZcDgwcllHMkdDSk5KQmNtWG1RUGZWci94aUJpSWlJaUs2ejJnRkdBbGhBeWxTVTlRR0VSRnRUSDFzdk9nZU9ub016ZVlLNW01Y2g5YXN3OTJvbzQrY3dPekJRNWlZbUVRVURXbWxMaEh0dTZtWjJTS0FCOS83SmdPTU5rRUtnU0FNY2ZqSUkzam11UmN4T1RrTklpSWlJaUlpSWlJaUlpSWlJaUlpSWlJaUlpS2luU0JDb2VTQm9JTFVobnA1L2F1aDI5d2FzNWozNUpoU29pcjd0OUdCUm1CVFc3V1pEYXkyRUQ1c2FDMSt4THIvbWZ2VE1ybStrV1ZtWGd1ckVRdFlhWEYzUm9tRnRUNjhTRTRyaUNrVnlBbjN2VXUrWHh2UE1paytLekhTZHN5WUc1YjFBNUltVkUxRXdvRFdwZHdFTFlrTy9CUkpFTHQ3eXQyU0dEYkdmU2RydDllRzFDcDBwVFltRGVMbHJ1aHhudG9hV3p2VXl1ZnFzeUsrRW5kMGdGQllXd2F0STRIVW9RMXIxVzVYQzRiRTdLYXIxN0tiUjNxaVprNGx1YzBrWk1DR2YrdHc2ejlyQTZXRmxLa1VhZWZVMXkrWlYwRkVSRVJFNnhtdEFDTzNveGRLcE5yNkdpSU5JcUtOcU5YSGluTDR5REcwVmxhd3VEREhBS05OT0hyOEJKNTQ2aG1NVDA0amlsbVBRVVM3d3djWXZmaUpUeGZoUmQvSHQwQWI0eXBRaTNDNVErNDM3aVBQdjRoU2ljZEFpSWlJaUlpSWlJaUlpSWlJaUlpSWlJaUlpSWhvaDRSQ3F0bWdZaGNmM0k3TFpsYWJCZDBSU3BZd2k3NXRkQ0NNRFV5T0tqSWIrR1pwVmxpSXRkQWg2MHBtb1plMHp0OUp1MGh0R2NhVzd3MHZLdnJqWG0wbGNoOWVGSnlLUTFFUkVQRW1nM1BjWjluVVN0czE0dzk2aVJ5VGRWRWF2a0NlblNLRlJrbDJZWXgwdHcxOERwU0J3ckJ4MzhuUGhOdHJRNnBGRGlPenIvL05qelZBVy9iS2w3NmtYejc5KzZJTTFXM25Wb2d3SGI0WmJnZGtXbGtaYU52dVpyM2VSS2tIMmpXdi91YXZGd0ZSSi8vV2QxS1RwcUV5Z3ZQa09reWd0TkxHNW5HZVZvOWQ3Ynp5MTcvRXh1bEVSRVJFRHpCU0FVWmU0R29VcExFV1JFU2I5TE4vNHQvQlU4ODhqMHNYMzBPejBVQ1NKS0FIRzUrWXd2amtKRjc4MktmeDBVOThHclY2SFVSRXU2VmVIOGZ4UngvRGN5OStBczFtQTkvLzdyZlFhcTZBSHU3SXNlUDQrUy84c2h0dkgwY2NseUFWNjV1SmlJaUlpSWlJaUlpSWlJaUlpSWlJaUlpSWlHaG5DQ2xnSTNlakludWlMQkxyZzMwMG9ydGVsRnRyR2xyTHVqUkFpSDVsWVpVMEF1WjZudG5FOXRRalVSbVJMVTYrdGU0NzVHOG1IYlNNUk05VUg1YUVJMnBLQktlaVVFNG9KU3B5UzEvWkxPY2QyemIrWm1XZHAzTXJyQkVUS3BRVktUQktoSUQ3RjFwck45eG1NaElKeHRVU0d2a2tNaHU2NlR4Y29VL2F6WXJDaWdoYlU4eEx0bWV1QTBFTHRHMW5Ucitzbno3OVNtY3FQaXlDUkZVQ0dZZUJTdnQzeGJjUDhyQzBnaVRyaFdobmYvVFhmeVlIN2JxbGEzbGpiTHhiMWxHMXFtd3UzZS9keUxVN1g0L1U3cmRkV2F1TjdObWtzcndTcjNUL3haY1lYa1JFUkVUME1DTzFJZWxyWEh5d3RWek50U1lpMnBRVEp4L0g0U09Qb0ZZYlE3ZmRab0RSQnloWEtwaWVuc1dKVTQvamlhZWVBUkhSYm9yaUdOUHhBUnc5ZnFKWTU3ejl4bGtHR0cxQXFWekJTNS84TEE0ZE9ZWXcydXB4S1NJaUlpSWlJaUlpSWlJaUlpSWlJaUlpSWlJaW9uVUk5ejhVa0tISVRTUjdjSCt0dnFkWmw4L2g2VmpZck44dldDK0VHOERBTkV4WHBEYVIweW9XNnRiVlF4TnJ6ZFU4Y2Q4aGhrYjVvWDBKaFZDSHcwQ1VCRVM4eFh5aGpzbHN4Nno3bEJWdWpBcWhSY1dOOWNwd2hmRjhFRnZNY1ZZSnNmRVVJaVUwS3FLTGxoZ3ZScDVkYllHSVlXR3NGRnNOSTNIdk0yNHVOWEZZYjhhWldBTHRBR0hQbmtiNjh1bWZSSkZxYXlXelNFQ04xb0w2QVdwYVpMMlM3RTZlZWpuejR3dTA2Nzc1ZHo3VGZlbjBiNHRaNVg2SGM5Lyttdk9rbDhQYVFHa1Q1SUd1anExMGs1VWtBeEVSRVJFOTFFZ0ZHTGs2QktHRWphWG80emh1SXVwYms5UFRNTWJnci95WC93MXVYTHVLdi9QZi90ZnVmbzVlajBGR2QvTEJSUWNPSGNYUGYrRlA0UmRjbVppYUJoSFJYbm5tdVJmeHhJZWVRWmFsdUhqK0hMN3pSMmZRN1hSQWR4dWZtTUt2L3NmL1Mwek5ITURUYnB3RlNvR0lpSWlJaUlpSWlJaUlpSWlJaUlpSWlJaUlpR2czaUZsVkRhSlNPWDhya1hZdXYvdEpnOGoyekl4cEcya3pDeWozZXRtL0FUS21wV3VpaldyNlIxcUk5MXVvU2ZjZEpxeVBEbnBRK0Uwa3JIcXFsTWl5KzNiak10cE9SazUrUld1MDFnOHdVblhWRW1YWmxVb2N4SWkxSFpUdTYxY2pPZFBOTFpxcDN1QzdmR1NSeHBoYVFrbDJNSmNmUm1hSHArbWhSaWpjZkZuZXdsc2hSWFErei9WTnBjODFYem45eXd6dTJFRXZmL21aenJkLzQydFg5WUhxRVlTbDBJb3NORVlNVDNMV0ZvUkdKaVdKRlNOYks3LzMxMzZtTmRJall4KzgrdVZmN3Y3SnYvMHZMd3RiSG5OVDQ3Q1BndFBRSXgxa3BLS29HNlJtTHN2cTNWZisxeC90RFZHMkhSRVJFZEd1R2FsS2lGWENNZHhVSktKTmsxSVd4WWM5WkZsZTNMYVdnY0xyQ2NNUTFWb2RrOU16S0pXMlZNOUpSTFFsY1J3WHBWcXRvMUtwZ2g1c1luTEtsY2xpZkJFUkVSRVJFUkVSRVJFUkVSRVJFUkVSRVJFUkVlMFdvWVJBTE5RRFc3SlpLR0dMYnQ4VFB1L0dGMk5oNzRwMCtlRFlKUmtMSzJKcHR4M1FsTG5Qemg4d3N2elFLUmlNS0RkbU4zVnAxOVVwWVNHRmNiTm43aWRzTVhtSGhmOHVVbXd0R01ma2lZbWtTTXM0bFJkelB1MlkwMjdTZlBGblcvblNlL1hiQ1RHQkhPMEFJNWxabTZ2SXBMSmkzQ3pMK1cwZnFGam4zWGJUVnVOcFlZc1Z4MmpQazFwbndzU1JybVdKanlma1BFbEVSRVMwQVNNVllPUXJJTnlPM0VFMTJ0dk5STFJOano3MkpJNGRQNG4vN3YvMUN0NTcrMDM4NXQvN3Y2RFZYQ25LS0l1aUdNODg5MUdjZXVKRCtMWGYrR3ZGL1lpaEdFUzBULzdEdi9TZkZ0MGp4NDdqK3BWTCtOM2Yrc2NZZGVWeTJSMk5DL0FmL1NkL0dRY1BIOFhuLytRdmdZaUlpSWlJaUlpSWlJaUlpSWlJaUlpSWlJaUlhTGVKcWl5S3VoazAwTEU5MHpRek1QYXVuQm5idHJtK2xHWHFRQkNpTG9hcXpWdndXTFNDbWhTdVc4YzIySzZCanlheUhUMWx1K3RuS2NpRGFsb2VDS2Y5MkdVTHVvMHJpYTRiWVYxTUJqRlNXOExON0FpR2dVWVFIZ3d2UFpIWUtGblVCK2MyOGg0RHU2Q2t1Q0NzUHY4Ny8rWFBiZWc5dEVsQzJGZmM1SG42SC8vaytyRUxlaUhXNGVNNTBtMnRId2FXMGxya29wZEd1dkgxdi9HeGk2RDk0ZWJKcndISjQvL1pWNWRPSEJaWkNEa2pySjNGaUpKRzNKU3ExUG1kdi9yOFBJaUlpSWhvdzBZcXdJaUlhQ2VWS3hWTVRNL2dxV2Vldy96Y2phSzBteTEwMmswWTQ2cnI3UEFINndhaHE0NFFFbE16QjFBYkc4TVRUejJESThjZWdWSUsyNzRpQUJIUkRwZzljS2dJN2ZIcnB6VHBZV0Yrem5VVHBHbUNVZUYvcjhybEtvNGNmUVNsY2htSERoL0Q1TXdNaUlpSWlJaUlpSWlJaUlpSWlJaUlpSWlJaUlpSTlsUWtsS2pKRUIwamZSRFBuYXlYbU13YStOWUlROUhtVFlRaTl5bENvaXFsKzk0UzI1VWh0NW1CMWZEaFQzYzEyckJ1REFyZmtlN3hXSWhSYmRQaHY3Yll4bGNQM0VndXB0bXRHZlNlbksyQjQ3K0ZnQTBDSVhJM2h6eDhIcFR1RlJhWmhFMlJpeFdrcmRFNTZYNi9uRDJMRkxNNmxHT3BscUlua0Zjd1FtU2dqTXlrTVZwM1pFbjJRUHN1bW03WlZqS1YxVW8yRXpMUGd5d0lEUFQyZjc4R2hKVlMrNjR4c3V2V2dTbUlpSWlJYUZNWVlFUkV0QVZoR09IWThVZHgrTWdqZU9iWkYvQ1RINzZHbi83b05Yem5qLzROenIvN0Z0cWRscS8ySFhwall4T0k0aGhmK3RYL0dBY09IY0xuLytRdmdZaW9uL3p5bi9selJXRFJjeDk5Q2RldVhNSlhmK3NWWEx0NkdkZGRHUlZISHpsWkJEajk0cC8rSWc0ZmZRUUhEaDZDQ3JnYlFFUkVSRVJFUkVSRVJFUkVSRVJFUkVSRVJFUkVlMHZPcUpxb1NKajUvTDRtRjdaalVqdXZHNWd4VSs2Vk1ZYUFuSlFkeERKWGowVVRJdDUrZ0pGZXlydm9tRnhZak50N0Fvd0VSRzRsY2prUmhHcDJORThXOXNGRnBVREFiT09DNU9OcXVlak95U091UHhJZEcyR1FhYXVrRktoYll3SUp1L0t3MTFvdEVxblFza0plKzlwLzhhbXpvRjEzOXZTWFVqK2kvK1RwUDFvUU1teEpFVDZKRVNKMG5sdU5kczlrRjVwamRRM2FkMzZlZEozMEMvK0hmeFBEUkNVYkJGTlN5eEFqUWlpVENtMXRKMjlmTy9QVHVSRm9IVXBFUkVTMHM5aHltZnJQV29LNjM5WHhtL2k1V08xK3dPYStyMXhLOHd6S0pHam5IUXlyTk1nd1B6ZVBMTXRjeGRySWhOZjJMV3NOa2lSQnQ1ZWlWQjdEMFJPUElZaktXRnk0Q2EwMU9zMFZmeFVBcEZrQ2F5eHlONDlxbmNQb3dhbFRLWlhMUlMydWRMV1FTZ1VJb3hpeEsyRWM0K0NobzRqaWtudXNqQ1ExdUhqaEVvaUkrbzFmNzdZN1hWZVJHT1BJSTQ4aEt0ZFFHNXRFdDlOQ21xYm9kZHJRWm5XOTdPcS9rZlM2R0JUU0g4ZDA2K2hTYVhWZEhhaXdlS3hjcWJyZm85QjE2MFZvMGVUMElheXN0TjI2ZXdGSmxrT0t3YjRTQ0JIdG5IYTdoY1hGUldSdWZaaTdkU0QxQnlrRHQyNlAzWHE4RExjbGptRTNQN2RRN0N0Ui8vR2hoMUVVdWUyakZPM1djTlMxTEM4dm85UFo1ZTlpVjY4STZEYlE3R3FYaUlpSWlJaUlpSWlJaUlpSWlJam9GdUdPeDkvS01CRlNnQjdLSDNnWEhnYlc1Z2ZkK0hOYVY4ODlRRDh5UVFvak0vUVd0elpaYkZ2Qjlnd3lFL2d2ZWZlVE9aUm95MUt3TEpRTTluZXlwN2tiVG52bnVWdldUVTBMZWF2cjU4cUhEYUVJUkM0aWFEa1RoS0xpRzJQczBIemNNNmx0bTh5YSsxdFppZEI5Wm9pZSt5dy80S1BkWmxBSTdjWjRhdjE0c0xndmVNT2ZTZjFCRTZRdWw2RnRpSTZwRkZOOVVQbTUxZ0R1RjBlNTJkYysrQ1J5Tjg3Y0QxUEg1UHFpbFdZZXRLZFNwSjA0RnprQ21SaTM2aEJXRG5aeTFnWnBiUm9oVEtkNXVLNWYvZnA3QnRRLzBsYVNoRWNhSlpQWGpkUUJqRkxXNktIZmVGVmQwOUlxeW9yd29tZSthUEVLaUlpSWlHZ1RHR0JFL2NmdmFscTNMOU1XcTdkYmNyWDdBZnMzUHRXNmF4TGtyZ0pUNitGdEc2YVV1aFZNVU1iMWF6ZEEvYU0yY1FCUHZ6Q0JwNTdWT1BmTzY4aXpGQmZQdlYwY1FHZzJscEdtUFhRNzdTSVlJOUdERTQ0eE5qNEZmOHduaXNzb2xTc1ltNWpDdUMrVDB6aDYvREZVcXJYaWRVbG04ZjNYdmc4aW92NGw4TXlMbjBHN3VZSjJhd1hYcjE1MDYrY2xYTDEwN25ab1I5THI0T2IxS3hnVVVxMkd5L2wxdFErWTg2RnpLZ2h4NU5pamJuMDlpWU5ISGtGY2N1dnZVZ1dOWnNlVkN5QWl1bE1SNU5idEl0ZTZiMDk0R1VYejg0c0lncUFvQTMzKzFRWXRMUzI1L1NZZWQrNUhvZ2hJVklqajJHMVRsREFNTGw2OGhPWEZCbmFURHkweXh1clZXNVpYaFNJaUlpSWlJaUlpSWlJaUlpSWlvdHVLWS9GaEFDbWtQemVFQ1VZUEo2d29FbVEya2pXeUE1K0duZWN2ZjdUSkh2ZjhoVGd0K3ZaOEdoOWdaSVZHMnR0aWdKRnhrOU1xSDFwUlhDVDZMaWxDWktLdXJzbFFkdmQzOGNpejZJN2hzOFZsNkh4NFVlQytleUJNRVFrakhuS2xkbEVSbVJoWFhYa2lHcFBqYXNmYTc5bVdUZlNpN2hWWGdiOVhMRkk1cGxvaUZqNzRKTVlJYzlOR0t5Rld0TFZWTjZMdUN6QUt4UWMzcWp3WVhrTnFZOXpNRHhkOU5BTjZNVUkzM01MTndZRVdKbkNMWHZpZzF3bmpWcmttNzZrOGZLMk1FcStJdWNmT25QNTh5M2YvN2YvOU56dlNRTW5BVmpBQ1lxbXVhV25UVjMvOVk3d0tacC81bXZoQzY2WFpWN3VscFhUS3JSL2N4cXVKcExCRGYxVldJL1VOa2VvRXIzeEpNN3lJaUlpSWFQTkdLOERJV3BOYkxPYlcrb3FZTWREKzhsVmx2Z2xYNm1wOWZNVmx5eFZmd1ppSTFiQ2k3TlpyY3JIYXRSOFFZT1JLMS9hUTJMVG9EaXNmWHRScXRxQUNoU2dhNmZyRXZtU05MaTRDMEdvMVhJVzZSbzZ5UDJ5Q3FCb2lLQnZFMWF4NFhPdkJxY3Z6b1VYK29Ja1B5WEF6SG5wWkFMUFNRN3MzajZWR3p4MUFHNGxRYnlJYUlqclBrR1VaT3AwbWRPb09JcGFuWFYzcTZrSGVzS3doNDBrTUNpblZhc2ljMnlidzYybmgxOVh1c2FWR0Y2MnVMcnBLaGF2cmNDS2lkVmkzL3N2ZHRtbHhMZ01EalByR2FuQ1JMTmJ4b3hCZ2xLV3Btd2NaWU5TUDF1WkI1Yll2aG1WN290MXFGZUZ0dTB3WVk1UWJkejRiYnVnUDJCTVJFUkVSRVJFUkVSRVJFUkVSMGNiNTQvQ1ZhcmxvRjFBYWtvc0o3U0ovNEgyZ1Q2Q1JXMGhGYWl5dkZHMW8wbnpYejIvWUd1blBNek13aTFzTU1MclZOVmtFM0gveGNqL0tRckhnbHBDVi9aM3MrcDdoODJGRmZrNzBJVVpGY0pHd0NJb1FJNkFrcytLeFVPYVFzY2hFVmFUcVVDakY0YkFxU25KSHZvajF3K0tEcmRwbTByWnNqblhPU1JGVldSYXpZU0JpTWZLTmpkeU1aRU9KM00rcStUcW5SdGJkMkN0L3dQS3AzTnREOTVycDRBWTZwb2FHSHB4enpPK2szVGN4VmdiV3FGQlk4Y0FHUUVhWWJ3SEJ5dGQrK2xLQ1o4QVRTdmRKTTErNVhBcnFZVW1KQ1doL3RXTTdsTzEvTGV5OCszSm1wVHZUS0UrOXp2bXRINTBXNWxWWSs4bS8rYTJiNVFqTmFpd2ZOMVlwRVppaGJKeGloVm5Lb2R2aVpyZXpzUEo2bjI2RUVSRVJFZlcvMFFvd2dqRGEycll4d2llSE1NQ29IL2hRSWg5UTFIRmx3ZFgrdEZ4cDN3b3cybXl2NERPUDFrSmhobnNmd1FjWTBZRHdkWHMrbVQwZW52cmYzTGpTemRGeFpiblJCaEhSb0pOaDlhNGplT1BsQ1F3eXYwM1U2Ymx0SWxjYUt4MFFFUkVSMGI0UTJJdXJQeElSRVJFUkVSRVJFUkVSRVJFUjBVQ1JVa0FwNllwQ29FYXNTYzhJMHRpOGJyY0hmOFdrUGJoQTB6WnQ5N1FJdFg1UHJYdWlMNXJNckROODl1N2JnWnZDOG5hUWtVWG9wN2dTUmxaVklpWlZXYzBHTzllUVpEVTNDc2hNR2VuNkY0c1RzWWhrWFVRMkVEeHB4VTBRSldCeW56UzFUaFpQV1FqRUg1Q041dDRPbjRGVWswMW9HMkJRcjJObVZ3T01sSkZDV2ZQZ3RxVEt5b3MyakRwNFJXaThBdG9ueWVIcEpiSGNLNVhXMWtIR0R1bVZqRTFpaE1uUG5INjBCK3Bqd281UC9yQmxkTll6Vmhzcm5DR2RKelZFTDFDaTJhMUZ5YXQvKzlkekVCRVJFZEdXc0xhVDlzZWNxN1RwdW9xZWEybzF3Q2dUcTVsRDVsWWhJaUlpSWlJaUlpSWlJaUlpSWlJaUlpSWlJaUlpSWlJaUl1cERHaExhQWcxZExnS0RXamEyY1NpQzJwU3RSMlVwZHpMaHdYWU1iTmY2SzcvZi81d2pKRkpSVTByT3FnRGhCOGNYbVp0NVZ5L210MU95d3FkSzR4Z2lVaUNzaEdMY0NCdGwyOGdDazhKZ1hDMFVZVVpkVzBiWFZGeXBZcEQ0bUMwaFRFVUNQcklwdXZkNUEvR0dlMEZ2S2M0dnpaMjd3bFo5Kyt6VlgzOHBmL3IwVDVOcTBIbkRScGlPclg0Y1F5U3pRUmRHNjh4MnJrcGxHVjQwQVA3bFgzMnUrOFZYSUJiZitjN2xNTXhMMHBnbk1VUnliVHZRcW1QQ2ZDN3Q1RGZQblA0OHc0dUlpSWlJdG9FQlJyUS9FckVhWUxRc1Y0T3NOUzlJVDBSRVJFUkVSRVJFUkVSRVJFUkVSRVJFUkVSRVJFUkVSRVQ5ejJLMUxWUnVWNk9LZktDUlZGYWFDTzZ2eFdxRHFSMlMrL0FpdTI0dmhZQzFRaGdvU0JGTGJJUnBtOXl1bUF4RHlrMFpJYVVJSmV5MmNxVGNxRVVrVW9TM1NvTFM3ZWsrT0lTZlJRSUw3ZHVSM2pjK0pFeFRXTkg3NWwvNVRCZlVCNFE5aTlQNWsvbWZibHFSMURNbE43WlFEd2hoL09wS21rU1ZPcjJKRWdPTUJvSDdmWG5GZFY3K1AzK3JFL2EwTUtFYXFublMvVTRZOTB1UnlaN3NuVG45ZWM2VFJFUkVSTnMwVWdGR1JVNk9nY2d4Y0RVRmcwOWpkUUs4RmE2R0Y4M0pPeDduNUNBaUlpSWlJaUlpSWlJaUlpSWlJaUlpSWlJaUlpSWlJaUtpd1dRMDBKMFhJbGtDb2hvUTFnU21ualVJNjRBTWlxQ2hMYk1yZHRuTVpUMmIybWwzTjd6cnlWQ213VlN3S0d1eWZ0OXo5L1ludGJCZEEzMDFxNWxyV1hYdDhWNVRMOHVTbE9FbkttTkYrazh3MkcyOWxCQ3lHcUtVYU95SXVseEJKWG9EVjdJVFNMSVNFdU9EakFZanc4TkFxbGlrQjJCc3kxaXhzUFo0SUxIa3ZrUW4xK20vbWMrWEc2RCtjZnEwZWVFMFZ2NVFmRUdGeWdZeXhVRURITVFnazBJTFdDTWgzbW5xcEhua3RldWRWMTc1b2dFTmptNzN1cW1tc1V4S0I2MktTOWJZQXhoZzBzMlQwRHJOUkhxOUU0VHY5cTR5VUl1SWlJaG9KNHhVZ0pHWFd5c0hNT3A0Y0swRmhtZGl0WFJjU1cvZEppSWlJaUlpSWlJaUlpSWlJaUlpSWlJaUlpSWlJaUlpSWlJYWVFTFlITkN1WkhMMWV1L3Bpb0J3dDhPNlJSRU10TVhNRzVzYmF4SnI0RHIzUGFtZ2JPejZIR3dnSXNtLzI0ZjY1RzdvOGp2YTE3VXNySEVsTlFhaGNEMFNnOTN3eXcyOVJQRTlySjhxN3J1cDR1NFcrWndMNlVaY0tCUEVzbGNFR0psaTlQWC9hUEpCUzlZV1UxVzVjYUdLZWNBbnlWalpFOElzNjZEU2VmVy8rcmtPcUsrY1BuM2FmUEgwbjAxV3NOS3h2aldtbTNpUVVtRkF1YldMYjlhYmFvMU1hZDE5NXBtejlwVlhoQVVOakRPblA1OS80ZTkrVllrOGJsdGpoSjhuM2JyRnJWbmtZS1M1M1VlazdtZXY2MzZ2ZTcxM1M3MVgvOEZMT1g0VFJFUkVSTFJOSXhWZ1pOeGVUcExiYXFydHlBVTM3UnNmVnBTNGN0Nk44bm0zTDlJVHE0RkdSRVJFUkVSRVJFUkVSRVJFUkVSRVJFUkVSRVJFUkVSRVJFUkRKdThLVjRBYjMxSHdrU01IUDYwUlZvQjRZbXVOcXN5S2pleU4zRWVBM0JkZ0ltTVJCc2ZEdzZLK3dReUovUDVoc0Ywemdkd1kvVTdhbEZNcXhDTlJCUVBNeHdvcDk2ZWt4SW92S2NTVXRyYUtiWnBWTnpBdWwvRlQ4MUdzbUVuNFdLTitEekd5VmdvamxESldoUUsyQkNseUZIT0Ivc051ci9lOU0xOSt1WTIvQWVwRHI1eitTTXQxM3ZtRnYvVXRJWTJvdVlrNEJXRmpEQ0JoY0ExQ1hHaFU5ZlZ2L3BYUGQ4K0FCdEhYZnVNWDB5K2Uvc21QVjRMZU5FUTJMUVhLd3BvSUEwazBNaVcrblpUaXpxdS8rYkdNNFVWRVJFUkVPMlBrZ254eVl3UGpzNlZwZC9tNkxKL0k3U3JjMEhTbEkxYnZFeEVSRVJFUkVSRVJFUkVSRVJFUkVSRVJFUkVSRVJFUkVSRU5PMVA4UjlvUTBEMkwwRWZvQ0VCdXRFV2Z0YkN1QjBKYmFhMElCT3o5MTVVWHJvZWg3eW0yelhhTVFFVUthNnpycmVqM2JKNFA1TDVDRUNqRXViVks3MEM3TnVHbXBrS09rdXk2dnlIYXBnNDNhZERQM0pSMHM1RVFxd1Z1NHRxTys3dWt0V3dsalRrOTZOTjRGQVFXWFEyOTVDYm11SitwRFV4L3ozUjNVRlpvYlcwQ3E3b2lzSjI1WU5tQUJ0b2M1a3d0UjViR2xXVzNkbkZyRUZ0MjZ4WmhoUm1ZdFlrVWN0bk5sKzFXZ216aEd1ZEpJaUlpb3AwMFVnRkdyb0pHSmhwMVk3ZVdWazJiNEN0MU9tNWYrSW9DTHF2Vis1WTFHa1JFUkVSRVJFUkVSRVJFUkVSRVJFUkVSRVJFUkVSRVJFUTAvSFM2MnAzL2dVUlFzWWduREdSZ0VZMXQ3UDAyZDM5U0M1dWFNbktEZFZ2RUJZQ2NWSURDdHRnTUlyK1VoZTZta2ljaVdHVWgxR0MzQll1VXFJNUZzcXExUVlidHR5Y01SVjZVSStFbEpMYUVzNzBYb1B1OGVhYUJFQVlxY0hOZUtBUmlRRnlBTWQ4dEMzSHA5LzdPbDdxZ3ZsZDc5T0sxMXZYYW5PbE96c0NJbWpRcXRFWENXUDl6YTYrR2xmWjZqdXpxdi9yclAzc1pOT2pzbWRPZnoxLzZ0ZTgxRGorSkgyV3AvckNiRTZjaEVBZ2JERVN3bGh2ZW52dHBmVFBQODlhM3YvSXpLeUFpSWlLaUhUVXlBVWF1aXFGbnJIQjFOYmJFL0tKZDVNZXRyeHp6NFVVK3VLZ2hWNlBDR2NkTVJFUkVSRVJFUkVSRVJFUkVSRVJFUkVSRS96Tjdmd0pseVhXWWQ1N2Z2UkZ2emJVeWE2OENDanRCTENRQkxnQVhVS1EyVXpJbHkyTkxtdTd4MkpUYjFranlNdDA5NDdZdHFVK1grM2kwZU9aWWM5cW5OVzExMjliNDlEbmRJa1ZaMW1KYUZCZVFva1dBRWtnUUJFQVNXKzJveXF6S1BmT3RFZmYydlpGVmhjcktyS3JNcXN5c2w1bi9IM0FyM291SUYrKytpQnR2aWNqN0JRQUFBQUFBTzR6UHBieHROUE82VWFsUEdyclB5eWFTdVZIb1VPWnpQNXQzZk1lWGRYVkVrWkV6VlR1bnFrM0RsTDcxeURNeFRxbHJPKytuc3FicFMwcnFOMXU2NzJFYVYwbGlsRnAxdzgzY2UxWENlcnZsRlZXMzg2cjRsZ2JzakZxK3BqazNwRjdsd3N2MU1iTERxQk5lL3luci9VbDVmM3cyYXk4SVc4S25YbjdaLy9oREQyWHpyKzg1NVZ3KzUrVWZEQnUxckI3bWpmZlcySWFzbVhKR0o1UzFaNFJ0NDdtRDc4NC9QdjljUTFVekdkcmttNm5zSHUvOUtxUDViaCtiK21tVG1ZVk0vbHduZFIwQkFBQmczZTJjQUNObjJ1RkxjQXlicmdvYkt3dkhjV0wrY2d3d2l1RkZqdkFpQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUR1UGR6SEFTSnA1M2FvNjZqVndaeGhSOWtwdUVHRGtPejV6MDNsTGJXZDFWWUNSTWNhWnVwMjFkVnN4aWVuVHJZc2R3RXFtN2R0dU1tL1p4TWowMnkzZDl6Q3hwbGhwWVQxM3c4MnVreThYWVQ2M3FNL09GOE9CWkVhSnl6WHJkcWxYK2NVQUl5dnZPMkdMbnZKZUp6L3ppeDg4SVd3ZFI0KzZUNFhCRHg3OVQyZVVsaTRZNVcrVDlUZUtQN3U5dk1uRFAyM25OWjNXSmsvMjc1L1BoTzNqcUhGL0lEWCt3ai85OHFSUnFTTGpCc05uVW0rM1NSVjl6T2Q5Nm1lLzhBL2ZQeVlBQUFCc2lCMFRZTlJ4dWUrR1h6ellRT0ZuWlpGSGZTdzBxODdGKzU3d0lnQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQTdtSmRjSm5XbXBjbHZHL1h0bDJvSGltZ1pXWHVOaDNSYzdxWmN5M2Q4WmRsRUsyUDJwdjNxVzBQSVVIeWVzcEZKcnQzZnk3ZDg3czVuYmZYYmt0WDJVRTJzOVdXZnpyUmQ4Y0pUR2ExSDBzWWQ2UWsxZlYzbnMzMXlZWWxkWDFZUE1qV3pVSGV5czVOZW41VXBueGUycEtHSFBqRGRmUG01MUZmOU1aZjdBVmwvcjNxUThiR0hxY3ZTVEMvYWtwbjYzY212ZGZYM2o5S3hkeHVhbmJoN2VuRG9WTnRYL0xEM3BpVHY5eHByZXZHakl3dnQwdWZHZnNkM05Tc0FBQUJzbUIwVFlKU0ZuemlaRXpaU0RDdktRcGtJdnpFeUVWNEVBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBSkdUOHE3VU9HZFU2dk9xN2ROaXFOQzE1TWI3QlpmNVRNdkNQN3lWdGYyMmFtcDI5V0VSSnZ4Zk1zWHdXbnlvbjV2M3VlMzRiZE1UcjVUSWVoay8yd212TDZ6Sm1OKzBIZ2tiUSttRXlxNFpscGNYQVZWZXZaamI0Y01tNzVhOWtmdk1Meno1c3JCbGZlb25UR2pCNm56c2w3ODI2YTNKcmZIcmtjTzE3cnhjWnF6TndxMDMyeTNUMUQ4NVNxL2ViZXFydjNaSE13eWFIL3Z2LzlPY1NjeUNNekxHMko1cmw5Nkh6elBqbmMxYjR4cWJKOEFJQUFCZ0ErMllBS1BabGh2c09vSmFOOVJyNGJkRkl4ekJtU080Q0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFDdTVET2p6b3pYM0FtamJzTm82RzZ2NnVnMStyeTE4cHFieWc0VWNVVlhwUTZaMUJoN0lLMnVKVFBIcEdGSk1iM25ldkVTdVMrNWhXellkVW9sNlVhdkpkUzc0NVdmeitiVWNLMVFwNUkzM3FUM1ZZZlVRNnFoWHRWRXBlbVdGcnBPYnRScVVPdWtZbHQ2dlBhbm1zNTI2MXZ0OThqSHBLQWVDVEt5eHFsaVd0bmp0YStlenBSY0VMWUYwN2ZyaFhUeTlFQmVyZDZkaCtadG5ObXRIbUprdjJqbE80OTNuenovM3gyVk4vOUUyT1ptK3MyTG1wMStmU2dkR0FrTllNQjVzMjd2c2V2QjIvd3JwbE9hdUhDNk5QM2N2M3dxMDc4UUFBQUFOa2d2eHZwdWlQQ2wxOFlpYkp5dVdTeitZZ0VBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBWE9hZGtjdENhY2ZoZGVhTGZlR2NVcm1WKzhURkVDT1RtTlYzNGdxekdtdUs0VFZuOFRJS3oydWNicnhjZjdIa2NyN2xuZSs0WE4xUTR4NWp3d3UycG5qUkx0VFh4MVcybHRWMkkxWGJVam1VUzRwVjJBUGxrcHBkeVBydFRDWnNDNS81Ky9lMzU2VlcyRTl6Rzh2aWJ0MHp4Wmk4bFptc2RmU29jZUdPRjdhOXpuZktXVVdWaGsyc0MxdmM5MXFidEM3dGV1TWJBd2Zud2xzamJSSUFBR0FqcGRybXVrNlR6dnR1Sy9lN00rY1RZZjFOaG1OZ25YQlE0MXl5T0FRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQXJLZzlaVUtSVE1rbzcwaDlCN3pzeFo1K3Z1M2t6dWZ5ay9tS2o3VzdrclBxVDd3cG00TmFaMTVLVFF4TnVrN0VnMjg2bDcrWnRmUHpXZUtPZDhwaDFOREZVa2p1clNqbTU4VFgxa3QyMTVLU2wxL1g4SXFZTURWb3A1V2ttZDVlZlY2VDJXNmQ3TjZyWHZCbytjL1VseXo0RVh1aEZWNTFSOWcybmo3NmtZVWYvK2RmL2QvbXVxVTc1ZkwvUzl4dnJmeHQ3U3Zzblk1NW84Wi8vUGtQZkVQWVVaNzdqZmQwdzZEN3ZmK3ZyLzUra3VaSnlTWC9wWHFCTWEvTCtEZXM2MzduUC82M1QwMEpBQUFBRzI3N0J4amxycFNIWDlqT2V5dXNyMHVIYTVwbXNmUmNQallBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBOUNiWGx0b3pVbTIzWk94aThVN2V0MzNIZDEzc0QxZTYrakcrYkZOYnRUZWREaFNlSTVNMVdYaVdzcnlXOUxtTEFUOWh3VDRNNC9LWFBVZW9sVUxkNUdaRDNScHV4ZjU2UHZNOUdXQ1VXRmt2czY0QlJwZVhyVngxTTYrbXFhdXNkcmlYS3J0TmVUSmwyeTZDbGFxMnFhcHBDTnZVN0dCdSt6c3Q1L0p6Um41WDJETjM2VFl3eHVSeXhubnJwbzB6MDhLT1ZlcjZibVpLbVRGdUlueUlsTHp4dzdvTmpFOXlLZTk0bjh4YjR5YVQrSGtIQUFDQVRiSHRBNHptT242Z25YdHR5SkdGblM0R0ZybHdJT2wwSWsySDQwMTVieDFVQWdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUlCZU5YZkt5cHlSQmc3bE1vbFhVZzRqTTNYYytleUNuL1AxY0c5WktFbXlQeDB3ZlZZM3JXcW5UZDBzK0liMnlmdnFsWk5DYlhKdjFUSEd4T0NrcGVGSnNZL2VkQzQzbGR2OHU2M0tOWmMvNzBJbGpWUlRUNm1sZHJIT3VkWmREQXU2cS95YXltcHBPaDh0U2tjVjNRNURacXFvejhIU3FXSkl4OHJ0eVBoUEhWWG4vZi84VDhkSEUvdkhlYWIzaFhIN2RCczQ3eGVzVWR2NjVMbStXbjVLMkxIKzZPZ0hKdVB3WTcvODFXZU5ON3ZEelEvck52QmVzOTZZODA3NWE1LzV4KzkvVGdBQUFOZzAyemJBS0h6SnpNS2hqaXp6dnBJNWIvaWh2UUZhNFVCU0k1VE1MQjdJWUIwREFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQXdLcDR0emhzVFJrbFRhbi9vSmZKbkhIekxsWEhyWnhTVkRXSnFkMzhoZWh0eVppOGFveWFxKzhNNXAyWDczcWZuOHVjYitYeHlhK2RvSlJjTER0UTFiYTBKM2xUYlY5Vk82OG84M0ZGM1B5MldndHJYTmdvVHFQcG1QcnRuRkxUamM5dHZmSDk4cW9LMjA1bHR0M3Q5STNNeURZbXJYUGp4cGpoOEo2eXFkRmgxcGl6M211aTIrbTBEby9XTW1ISGM5NmZpNTllNWR6UGVHdkszb2Yzb00xaWJXaUQrYnp4NXRXTzhSTUNBQURBcHRxMkFVYTVWeWQzdnRFSnYvSTcrVlZwejFnZmMrRlh4Rmc0aU5JTUIxSHl6VG1RQWdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFEYmdsc01NWm8vWldSVG8vNkRlYnh2TkpPWHczREZ2bi9KY0ZJeS9WWTN5NWVOdGYxSjR1YWM4ZmtLMDFkSzNJbnp0YjJ5NzdTNlBtYVdTT1ZyTGQ5VTdXWmw5dlNjb1dSSzlXcERqZWFnRnZ5QXNqd05tM2h6MHB4U2RWV3ltZTRvSDlQZTlOemlTQi96WmJSYnhnOEwyODdUUno4YUE0UEcvOEt2Zk8xazJNNkQ0VjNrN1dGYkQyb1Q1VFo5M1dmdWhkTEUxUGh2SEgycUsreDRuLzM1RDN6bkIzNzFLN1BoSSt3aGVUOWlqTjJsVGVCOS9QaFM1bXp5WnJtVmZHbnVUZEVlQVFBQU50bDJERERLdy9mTXJObFZzdEIxL2JrM3RqaHNndldUWHl3TDRValNaRmk5NU9JQ0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQXdFMXBucGRNSW5Vbm5meTBUNVg3dXZ6UzVCdFRVc05iT1Y5U1g1ajNwaU9DVE4zVzdVaFM4ZWV6eExlWDlydno4b2wxUnI3cEVqZWJ5L1RaVUM4ak45NXQrZ1VYNHlFcU4zemlzdG14QVVaaDg2aGsydHBYUHFXcWJlaVY5c05xdUg3bHV2bkFxUnMvcHcrcjIydC82VTJOSk9kVk5hM0wwN3d4MW5nLzZyM1oxRkFiYks2RjZmRTMrNGNPTFhqZjdEZmU5anRwbDdFYjJPZ1UzeXZNV0doM2IvamNueWhuZHFMMjFBOWwraGNDQ3QxbWR6S1grMG81cmJ6Tlc3ZFh4bFIwbmVDNzlSRGU3WnE1eTc5b3UvN01IN3owdnJZK0ZTTUNBUUFBc0ptMlk0QlJESG5PdXk0dkxYUjlLWGVFRjIySVBCeEZhb2ZTMktGSGt3QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQmdIV1FYKzJpNXB1UmJNdDZwY3ZVOFBqRmRZMDNYV2xNUHc1c1BNQ3FIWmRldGxLNjBDR044N0hNWUwzN2ZDcmVxWVJoamxHWmQxODNIWktPbG9Vb3JMciswYy91YnhiV1hoSlczeTA2cVdtcnJaT2NlTmRXdmpVeDBpcjBuWTRqUlVES2xmYVUzVmJITnQrb2piOE0vL2FGZU5XSGIrc3F2Zkh3cURLYis0cTkrZGNvNTM3S0wrL0VOOTlWYkVkNkJRa016SjN5YVRQN0JMenplRUhDRnAvV1J6c2YxM0d1NTdRNkV0cEtGZGxtVE5SdmFKdVZkWGtyTWQ3TmFlVnFmTXJrQUFBQ3c2YlpkZ0ZFMzk1cnJPQzEwZmZoVzYwVjgwUWFZRHdkTVRwYWtHY0tMQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUdBOVRIOWJuYVRyYmQ4Sy9mNlMwZFNvejFxVmRFdE1EQzhxNjdvOUM5M1pidGFaeVRNem5MUk15VGgvTmt0ZHg5bnJMcmVzZWRraU5HSklQU2krNU0zcURkZG41MVRUZ3U0c3ZhRmR5YVMrMDM1RUcyVWdtZFdoOUtUMnA2YzBrb3lINXRFUmRpYmJzZC93dHZ1R3QrbmZNUEs3dEJoQnRyNk1YZkRlblhMZWZxZWs2dGRhclVmbkJGenRxSEYvY05TM1B0NzV5cW1zVnZsRFk5d0g1ZjFEMmlCTzl1blFKdWVTcGoxeDRYVjFCUUFBZ050aTJ3VVk1VTdxNURLWkYrRkZHNlVURHRVc21NVWhBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBT0NXZFdlTmw1ZGJjV0xGR0ZzenQ5NmhLelV5TVlyb09uRkV2dVc5T3JsVHJxN0tKbmNMcmlUbnIvdmMzcHJjV05PendSR0pOaS9BcUhSeE5mUWw4M0ptWTUrNXJIWjRuamxWVFNzMGtiYXdjNW01N2dVLzVPWlZ2SVVVYmM1cW5ZV2xoamNIc3lDWHovN2hMN3hqU3NDMUhEVnUvdWdYWnl1K2NzNDRsOG1ZZFcrUGw0UjJPV0hrRnY3ZzZQc2FBZ0FBd0cyemJRS012UGR1dnV1bUZ6cXFUTGRkbjdEK1lpSlVLM3lWbnd1L0V5WTI3TGNDQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQU93NDgvT2xTdGtZMWRPMmpMd1M4MWFXVWJJdkhiQzdVNW5rMXZwMW1YUXhUTWZVa2tsVDgxM2ZkUHRXbUswa3A1S2Z5ZXRlcTVNY0xGazdZQlAxcUpvMzJ1d2VjZmRYWGlxR3A3dDNLZmVKeHJLRFdpOWwwOUx1OUx6dUtMMmh4MnJQQ1BpOWYvYWh1VENZKzZGZi9yTi9LNXRYNVB3dmFGMlpjY20vNXRMYXJ3OGRTWG8yckF5OTQrbWpINTBPZytrZit0Vm5Cb3czeDUzYzl4cXZmVm92WG1mRHY2My8rUE5QZkVvQUFBQzQ3YlpGQ2swTUwzSmVlWjdMcnZhQUNHNVMxK2dhR2Q0QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQWdGc1ErOGM1YitRdjMvZGV4anRaSXhtdEc1UEttMFMzM0IydnFLcVZNMlZyVmRvZS9SWFhXOVUwVkxYTklwUXFscmpTYjZVWU9aVk50MWh1cWh2bnlIaGp6TkdqUjIxc1NjTDI1L0syWE5JTysyYkR5V1J4KzY5VG1RN3ZSSzI1Wk1IcFpRR3I1b3p2NU40dnFHaVA2dDVxVzR6TDlJdi96eWkwU3dFQUFLQW5wTm9HT3JrbXMzQUk1bHpEalFnYko0WVhIUXROcHNGeENnQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlliODViemJtYUtxYXIvcVFsazlpR3NlcVltaGt3ZGJ0dS9RSE5RT0tNVTY3NWptNkY3VS9tUTkzYXlWMmxJVHVjOUFuTGZLanZjMXB3QTNxemMyZFk0VEUxNnRZMlk4VTB0U3M1WHl3M01UY09NREpleWZjY2VYcnc2ZC84U0V0NnVpVnNhNS81aFNlTGVLR1AvZkl6WDdKT3U4UDd4MU5hQno3SmZqMHp2dm5WLy9wRFRRRnI4RWYvemZ1L0hnWmYvNkZmZWZhZ2w3blBldjhPM1FMblRWdEd1Wlg5dmNTNVZ3UUFBSUNlc0tVRGpMeFhKeFEvMTNGVlIvcnZ4bktoNUtFMFF1RVFCUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUNzT3llanJyZEt3OUNIKzdZU0JpWHJaYlcreXFhc3FyMzVQbm1KbksyWXJ0bVRKR1l3cVpyVTBML3ZHaEoxaTlDaGcrbEp6ZnNCaldjSGRET004Y1Z3ZjNwYVEzYXlXRzVTZFBxN1BpOWZ6cHJaU0ZXYUVyMERkd3dqOHgxdjNaM2hac01ZbXpqbjY3b0o0VjNpUkdoNW5ieWh1WEpsOE1hSldjQTEyTngvSjVlZDg4WS9HdS83bSt6amJxMDVuZWU2a0pmVEdUZmZKVkFMQUFDZ1IyenBBQ01uMzNKU050VnlJMTdZVUhrNGZ0UU5aVElSQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUdEOWVSbTFmVW1KeVl2YjZrdThIYkJPSmJPdVhlaE16VmF0Vkw1eC9NM0tpdkNpMFhRaHZidmNaL2VrTnhXTXNsTlViRnVKei9WUTdSczYxYmxiWTlraDNReWpQTFlJdmIzNnpTSVFLUzUzVlkvenBxeFM5Yzc1TEhOYURESENEdkNaZi96RUZ6NytTMy82WUc3TVI1emNnREZtV0RmRDJtL0l1Zm5QSHYzZ3VJQmJNSG5oNURPVm9UMUpyVno5YXdvTk1yeWZsWFVUY20rK0hkN1l2cDdsL3NUbi9zbVRzd0lBQUVCUDJKSUJScGwzSFpjcm4rKzZVdmpKWEhLa0YyMjgyZkJUb0UwSU5nQUFBQUFBQUFBQXVMSCsvbjRsU2FKNnZhYU4wbXExMU8xbWFqYWJ5dk9iL1pOYWJDY0hEdXhmTm81MkFnQUFBQUFBQUFBQWdLM0tlYXVPUzFXcDJVcTZ5eVltTlZicnlKU1VLTCtKWlNaeXRzKzJ6VWlpNUZDcFp1czJFVzdJeW1rb21kUkNNcUE5NlRrdHVQNVFCdGEwakQzSm1CS1RGY3RKbFFtNGtVYmRUSlVhN3ZQR213ZThNWHRrVEdLOFg5MCs2OTFNYUxtTlBIUGZzdFpOQzdoRmxhRTkzWEdkeis4eWQzNCt0TVc2OS82SDF2SjRMek1WMnVXWjhQSDRoalBKaVZKOXFDVUFBQUQwakMwWllOVE4xYzJjYjgrMi9XRFhLU1cvYUJQTWhtTlJYUUVBQUFBQUFBQUFBTnpRd01DQXl1V3lSbmVQYUtOTVQ4K28yV2lxMCtrUVRJUENnWU1IbG8yam5RQUFBQUFBQUFBQUFHQ3JjakxxK0ZTVnVpbmJJVnRXc3M0WHAwOU5haXBhcy9DbzNBd2x6V1IzV2tudUtQY0pxMktOMDNBeXBXYmFwejM1T2Zuc2dPYmQ0SnFXc1RzNXA0cHRGOHNCVnVQYzlNRFVvZHIwNXhPdnJ2SCt3K0dOeFlhM2x0SnFIdXV0blEvTmRpSXo1b1hQLytNUFRBaTRSVThmL1dpUnZIYjNMei96QmVmOWFMajVvMnQ1dkRHYWx6ZmZVYXQ3N0hOSFAzaFNBQUFBNkNsYktzQW95MzNXeU5TYTc3aTBsZnVCY0QrSkIyS3dDYzRtRW4vVERRQUFBQUFBQUFBQVZ1RWQ3M3BVdTNmdjFsTWYvcEEyeWplKzhieU9IenV1UDN2Mnp6VTVPU25ncDMvbWJ5OGJSenNCQUFBQUFBQUFBQURBVnBYN3hEZnoxTmVyeHBoaFk5YTdKNkFac0RFbGFTMjhxWnBaTTV3bTZhUFZBVnV4Vmx0SXF0N29URG1jVE9peDJsZjE3ZFk3MUhCOWFycCtaVDY1N21NcXBxbXk3ZWlCNm92cXQ3TUNWdXZsLys3aHJ2N0pTeGNPRHl4ODI3YmNieHRyM3UybGQxL3ZNVWErSys4ejYvVWwrZnpMbi92NUQwNmFueGV3YmhiYS9kOHRwNDFkYWVyK2cvZnVrRmZ5M3VzL3dyZkRwK0I0YUxzdk90ZityV1JrWVZ3QUFBRG9PVnNxd0NpWGNWM244azd1eTUwOHByd1NYclJwV21GZGV3RUFBQUFBQUFBQUFOelE4UEN3ZHUvWnJYdnV2VWNiNWZTcE01cWVtbGFhSmdLaWxkb2I3UVFBQUFBQUFBQUFBQUJiVmN3V3ltWGxZeSs2OHZyM296UHBHcGRwakpNMVhWT1I3R0JTMGhhVFhDeTNXODAyVlZOVGZYWkJxY20wMkdudit0c2lzWGt4NzFBeXBYNDdKMkRWalBFdlM1MkR2L0xuVTlicWRCanpnTkVORXJPOHlZcmVwQ1k1a3liNTZ3TFcyZE5ISDVuLzBWLzlpc2w4ZWk0MDB1RWJ0VW0vK0U5YnhrMSs5aGUvNTVRQUFBRFFrM28rd01qSnpMYkN0OURwWmw3dk9sZnE1RDUxM3BCY3RGa1d6T0xScnBZQUFBQUFBQUFBQUFBQWJFTzdkdTNTVC8vczMxNDIvcVVYWDliOC9MeWVmZVpaTlJ0TkFRQUFBQUFBQUFBQVlQTjRHV1ZLVFhmQnFUMHRsZnE5N0czc0RXZ3FKaWs5VmgweHBhM1p0YS9pd3pwVTc3aXY4bTN0TDUzU0YrWitSQmV5ZlhJeHJPcXFJQ056Y2V5N3FsL1RuZVhYVkxmekFtN0cxQnM2cTRQSkg0MldPOTU2YTQzMTc1ZnMwSW96RzMzZUpmcE1wOU41NmZQLzZJUHp4aGd2WUozOTNqLzgwTnlQL3VwWC9tMHJUejZVSnZhZ3ZOOGZHdHIrcStmemNnMWo5RjJmNkZmVHRwOFFBQUFBZWxiUEJSajU4QzJ6R1ByRlVNeXU4OHE5OXgzbmxEdVpuUENpemRXOUdHRGtXZTBBQUFBQUFBQUFBT0RXemMydHp4OVVObHROZGJ0ZEFUdEZEQm1LeXVYeTVYRjVuaGNsN2crdDVxMWRrV1Rmdm4zTHhwMDZlVHFjdCtWdlVRRUFBQUFBQUFBQUFHNlB4ZFFRbHh2bEhhL1NPcCsyOFc0TkN6VGVoU0pUUzJ6djlVaGNIWHV4OUlxeWFhdmZlZzBtMDJyNFBzM2xROHNDak1xbXE0cHRxVzdud3J4enVtbEdhWjc1cW5GYmRldmhWajMzRysrSmYyRFIvZUYvK3A4bWxmcXpZVzlvaG5lQi9uQTYrSzBUME42MHduN2VEdTFsMHVUSjJWclNuU1c4Q0JzcGhoaDkvSi8rMlVTZVorUGhJMjlBOGQzS0xIMnJEdTlib2MwbTgrSHRjcnlXV3E2OEJBQUEwTU42OEFlbkRUK0VmRDdUOGwwbjc4ODM4aUhoOWpsdkYwT01BQUFBQUFBQUFBQUExc0dYdi9SbG5UdDdUcmRxN055WVptZG4xV2p3dDBuWUdYNzhKLytxN3JuM0hqMys3c2N1ajV1Ym05T3JyN3ltejMzMmMvcmNIMzllTjZ0Y0tldVJSeDllTnY3RWlSUEs4MHpHOU5LZmNnTUFBQUFBQUFBQUFPd3M3V21qZUxxbVZQZXlKYTBiditDa2JIWHptc1RPbVlxVjNaM1ExMitkbEV5bktPK3FQcU9Xcit0ejgzOUpEZGUzWko2N3lxL3BiWlZ2YVU5NlZuMzI1aThXNUtYK0pFbWVWR0xpVlZGZUUzWXNQemJ6ckVaR25qY1Z2OXZMUHhMS0ErRjhjUEhPNHVYR2pUZWZ6SFAzcDUvOXhTZS9JV0F6Wk9iRlBFMStLYkg1WHcrZk5rZkNtTHF1NlB0dWpQL2x2SnROL3RFdmZ1RFcvOWdJQUFBQUcrcTJCeGlGSHpnKy9oTWptTDN6UGcrM2MrOXRKM2VKTDM0YjQ3YktEUUZHQUFBQUFBQUFBQUJnM1V4UFRXdDhiRnkzYW5KeVNzMW1RM21lQ3dBQUFBQUFBQUFBQUFDMks1OUpXVnV4QTk0Nkw5ZDdkWXYrZXplOG1rV1kweW84Zit6OFoySlhNM3ZqL21iZVhld2R1TklwM1NTVXNBaGo2YmRXc1dIamhuVmJNd3Z5WVV2RUVLUEU1S3FZVmpHdWFob3FtYTZBOVREZTN1c09HR1hPZDg1NFk2dGgxR0h2L1dEWUcrZU5NVk41N2s4Wmw4NEkyQ1FUTTIvNGdhRkRiYVYyUEh4bXZCYktnK0c5c0d5OG53aTMyN25UWk83TW5BQUFBTkR6Ym51QWtaSEp2VkczM2ZWNU0vUDVmQ2VyZFhLVnc3R01pbkQ3ellhRFFHME9CQUVBQUFBQUFBQUFnUFh4amE4L3J4ZSsrWUlBQUFBQUFBQUFBQUFBQURmV25wR3lsbEYrajlaWFV4M2ZkREVXcVhiRGVaMHZGWUZFTFYrRTdKamFEZnFieGVDaUxBdzZQaWJ5TEp0c0JzTkNFck9LNktUdGIzYzZWZ3dQbDQ1cDFnM3JqYzZES3B1VzdnajNENVZQaEhKU3dIcDU3amZlRTlPd3VqLzQvMzcydDlNODczZmV2aWZzaWFVdzdsVmo5TUpuZi9IOXZ5VmdFMzMxMTM2aUdRYk5ILzZsWjc4VWhtZTk5YjlndkhZYm1TOTZZK2IrNkJlZitKb0FBQUN3SmFTNVZ6aDg0Uk5yVEVtYkpIZCt3WHVaekttY2hXTVdtZk5KMTNuVHliM05uYXozd3UzbUxwWXMvUHpzQ0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFDd3lWeDJjZGcxb1hqWk5OeFpqK3ZWTDRTbHplZTVWaE5nNUpXbzdaV2Y2a3JXNU9wVDJ5YkdxMnJmNmduWTlTWUdGL21XRHpYMHhyZDlXYkh6NEFwOTA4eTBpUUZHM3U1T09xWmtFbE12WHRXT3RpODlvMzQzcTZsOGovcnR0QTZWam12UVRnbllDSGxYczFtMTNpbTNtOThJKzIxZDFuNHo3TDduQk53bUxWK2ZTVFJ6T25IbDU0ek41NXczM3pUZUxRZ0FBQUJiUnVxOG56Y3lKV3MwcEUzU2NYNHlmSG0wYzIwMzBzNTkwc3pDd1FqMGxuaGdLdzhIZ3BxaHROYmppQllBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBWUMxY3g0UWk1YTFRMmtZbThUTHIwTjNMVGVVZE41RjF3ODNWOUNzc3FldlZmYjRwSmNwTVh6S2xtdkhKVUpKZm1zRTN2Vkh1alR1ZjljdkwraHYwR1RSbCtmVHQxWWJxTmsyUGxBZTB3ejFjZTE1TlY5ZU1HOUd1NUlMZVZmdWFnSTN5K1o5L1lpSU9mL2hYdi9wSjQ2MHR0Y3JQVG1zNkUzQ2JmT0VYSGgwTGc3RWYrbWZQL0o2YzNWOXVsejVuWlJvQ0FBREFscEdPTCtUOVlXaFNHOE9QalpKdzhDSk5iQ00xdmxHeUp2NG5LNStZU0JxODBRSXo1eTljdkdseTUyM21qZTA2WHd1M3k5MDhoaTM3TUk4WjhYSW0zQzk1NzYzUWU5b1hnNHU4QUFBQUFBQUFBQUFBQUd4am5YWkhYM3I2eTh2R256eHhVcE9UazNJdUZ3QUFBQUFBQUFBQUFHNnY3b0tSTFhzbE5lbFc4b3ZjVEo3N3BuTnUxdlg1aG5OYUs2ZFNlTnd1dGVYemhyL2MrOHpuM3NoNW1keW5maFZWOU03NGZEeHYybDIrb2szUUYwcFp2YVBsVXJWOW9zL01QcVRKcks3TVcyV2hodU5adjFKVDBaL09mMWcyckd4cnZKN29PNkg3S3VjMWtIUmlYMDhCTisyLy9lU2o2aVNQaGwxMGY3aFgvdExNaGYxR3VXM2s3Z241c0QvL3c5L3BocjN6VzFMK0xjMXBVci8rRS9NQ050SS8rdVI5OHNuN1Fyc2JrdXpRbDJmRzk2VXkvVTJYM1o4NTN3MXRzaFBhNXBudzRmSWxkVFN2WC91SlNRRUFBS0FucFhNZFg0MDNZbkJSTEpYVUtIV3VVMDdNZ2pFK1NYTEZCS01rZk1GTFUzdmpReHU1MTBMOENSeURpZkx3KzdqamZOcktYRGtMaHpKYW1ZL0hJT0xVUHFHM1pXWXh4SWpqR1FBQUFBQUFBQUFBQU1DMjF1bDA5TnFycnkwYlB6NDJybWF6S1pldi9lL1dBUUFBQUFBQUFBQUFzTDVjUjhyakJldGpCNzFFTnkyR0YvbHBsL3RXVnZaZGI3VldYbGFacnlzTE45djVDcE5YS1pmM2MzbFhWYlAyT3R5RXNveXE2aDFaV0kwdFg5YTNtZ2YwV251UE9qNEo2KzVTLzgxWTA0R3dtWjFTNDNTNFBGT1VmdCs1dGZRcW9Kc2NDbTNvZldIdnUwL0c5Qys0N3VMNDJLN014Y2JsWTJmajBobFZ1b1FYWWVNbHBSSGw3bjBYUTdYMkwrVFpwU24zWC9GKzkxcVk3MXNxRisyVkFDTUFBSUFlbFY2NmtmdDRjTUFyNy9yNE82TS9mSytyV21PS254d20vT0lJTjh4cWZ0Mkc1ZXk3ZERzbUpYdnZUVGlrVVFwTGtDY01aK3RvaERKall5STJBQUFBQUFBQUFBQUFnRzBzQmhoOThmTmZYRGErMVc0WDRVVnhPZ0FBQUFBQUFBQUFBRzZ2OXF3SjUyNjgrZytGT3lXdG1lOTYrWlpUL21iWHU3T1o4ODNiZStuNzJISFI5Tm15S3VZbVhzM1dkNm96ck8rMjl1bGNkMUN6ZVVWdWhiNmJGL3QyaHZuMnlIbWo3eHQ4UlFPbXJiVXkzdmVIRnZBdVoreDNoSjNwRS8rbXFqMTl3MkhIZTVlYytWaG9EN3RDMHlxdk9LOHhYczd0VjduOHlYRHZUd1ZzaEtOZlROV1pma1JaL2lFWisxY3V0c2RydGNsZHl2M0g1Sk9YdzcyVEFnQUFRRTlLcjd6akxoMXk4TVg0ZEhuZThhcU9TYXdRUkd3a3dvdTJsdHhLR1hITUFBQUFBQUFBQUFBQXdIYlg3WFkxUG41ZUFBQUFBQUFBQUFBQTZGMCtrMXpuRnZwN3hRdmRoMlg0aHBOZmNMZjl3dmZleU5qVVdDVm1SM1ppYTdxeUp2SSt0WHdhTmt0eTNYbG44bG94NzAwelNzTUtIemJPVjRXZHFkNlh5cGFxOG41WXh1OFBZMktEU2xlZU9VNDNNektPOW9JTmREeFZQandzYS9mSTY3Q3UvMGt3ZjdIZEVsNEVBQURRdzFJQksxa0kzL1luckpRVFlnUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUF0MU5yMHNnbWtzdU5FdmxWUDg0M25jdmZ6TnI1K1N4eHh6dmxNT3BTMlRoR3pxUm1SbGE1S3JadCtvMnovY25seUtUa1FIcElaWnZhMFdTZk5vbjMvbUptVTIvMGwzdThmcm9vNzY2ZjBuUmUwemRlOUdwM2xzNXorRUFzUmc5V3hyUy9OQ2ZncHYzNlQ4d3Joc0Q4bC8vdVYxVFIvL1RCc1MvOTAxVDVJNm5ydmwwWDN3OHlrN3gycm43b2Yyd25wZWVQNzc3dmVhbmJFTEJSanY1VUsvejd0UDZyVDc2Z1d1bTNIaC8vMm84TlpQTS9scmpzWGlQZmYybTIwMzEzL2xlNTg2ZGYrNWUvOE5zQ0FBQkFUeVBBQ0V2NUs0YTNPVVViQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUtDaXI1ZS9tTDNqdldSV2tjUGpuWmZQdkZ3N1BETFh1dkR4MmVQekZ5bEt4c21HbXRoUUhSditqUkt6bUJHVXhqSEdtN0lTVmExVnhielZXODJHR2F3Mm1iL1ljODcwUm9MUlJWWFREU1ZWNHNKcXZLby9YeW1zNHFxSnE1S09mbGduK1lLVHIyV3A2N3BFemlVdXY5eWxOTEhLMHl6cmVPTXkrVERmMllYVko2VUJOMnNoZkRwVlRTZnhXWmE0ekZtZnkvaTNtbDdSSmhPN1RwOWdBQUFBMkVnRUdHR3BlQ3dqSE94USsySUJBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBTnhXZVdkeDZNTFFsYVdrZE9QSCtCa25ONW5aL0lWbVZldkV4Q1NneExSTnliUk1mekp2UnBLcXJadlVEQ1lEWVZ4cTl4WmRGbU04MFpCNlNPNlV4VmlNVUxPeWVzaUQxZkZpZURLcmEvNnEvbndQbUk0ZTYrc0tXRGYvNHEvTmhuOW5ELzc0ajAzR29SWjdsRjdTM05zNDk3SXluWDdsMTM5eFZzQm0rSTJmbUFuL3p0ejc0ei8yUGhQYnBBOHQ4SXEzd3RIVytaZnpUTk92Q0FBQUFMMk9BQ01zRlg5dWRyVDBaeWNBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBNExhTFFVYTJjLzBBSSs5OE1YVGpXY3N2dUNUY1hFWGMwWFdVVE1Pa3hwZ0JXMU1jVmsxaXlyWmtLcWF1dWtxMmJCTlR0ZktKZW80UHE4SXJyZzlqNUx5Uk5kcDVqQTFyb2V4TkwyNGhBQUFBQU1CMlFJQVJsdXFHQXpDdFVISUJBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBSHBJMW9oeE5FYWxQbi90bVdMZnNEQTUrMjU3WHE0SUx4clNMYkQ5ZGtaVjY5Tjd5elZWakVuMnBPVXdPcGIrSytmcnhXaWdQTVlYaFhWaFpkSWRtVjBVZVcrTk1YWGp6SzBGV1FFQUFBQUFjQTBFR0dHcExCeUZhWmpGSVFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFDZ1orUXRJNXY2Njg3ajN1dzJmZWE5Ny9xNm5LeldxbXc2dG1JN1pqU3BtYkpKekZEU3I5VElESVpGSlZ1cjMxa245NjFPcnF4cWZWL2RtSjNaYWM3WWNtZ1YrNHhkR2pnRkFBQUFBTUI2SWNBSVMzVkRhVm9DakFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFDZ3gyUnR5WlJpMzY5cmh4aGxiMlpOTloxVDErL1dUU2pDaXdidFFuSjNxV3o3azhUVTdNQk54Q0QxaEhhdTlrTEh0Mm8xVStzekp0R081TXRlWnIvem5nQWpBQUFBQU1DR0lNQUlTK1hoNEZVN0ZDY0FBQUFBQUFBQUFJQXRLVWtTbGN0bDdkdS9yeWlEQTRNcWxkTGlkcWxVS3VacHQ5czZQMzVleldaVGpWQ092WEZjNDJOamdsU3IxVlFQNWREaFF4cmRQYW85ZS9lb1Vxa1U0L004MXh1dnY2R1o2Um1kT0g2aVdIZHhIYTZYdSs2K3E5aE9lL2ZFNXl4clpIUlV6anROVDA2cDJXanExT25UR2pzM3ByR3hjVzJtcTlmSjRPQkEwWlppL2J6M2FyVmFSZjBtSmlaQy9jWkRPYWVadVRsbDNhNTJzcTJ5TC9iVjY2cFdxN3Izdm52VjE5K253M2NjVnJ6MmJyVmEwL3o4dk02K2VaYnRDZ0FBQUFBQUFBQUFla2JlbHV3MWVnWDZPWmU1cHN2OFJOYnZXMzR0VjdqM3BtcG16YUF0SllmS2RkTnZhN2JmbGxVekpTVmhNVnN3dk1qNXhZaW5UdWJxemE2djVWVWxXc3NhQVFBQUFBQUFxMGFBRVpaeUlyd0lBQUFBQUFBQUFBQnNhY1lhSldtaXZyNCtqWTZPYW1Sa3BBakR1ZXZ1dTR2d2xLalJhQ2hOVTgzTnpSY0JKV2RPbnhFV0ZhRXpsWXBHUmtlMGQ5L2VJclNuWHErcnY3OWZuVTZuV0YvTysyS2VkcmkvbmdZSEI0dHRkdURnZ2ZDY05lMC9jS0FJVFRvZnR1WGMzSnptd25QSDhLVE5kdlU2dWRTbVl2MWl3Rkpqb2FHWm1abWkzY1VnbnFtcEtkbFExNTF1cSt5TGFhbFViTjlkbzdzMFBEeXNJM2Nka1RHbXFIY01wWXB0a08wS0FBQUFBQUFBQUFCNmhjOFh5MHBjMXptMXZmTmRYMUcyaGdBalk1eXM2WnA2bXRoZGlVeWZUV0xSTnBCNWxYSXZBQUFBQUFDd2dRZ3d3bEx4NEZVcmxFd0FBQUFBQUFBQUFBQmJTclZhMFR2ZStRN2RkOSs5K3NqM2ZrUzFXazIxZXEwSUlySFdGaUVwVjNyczhYZkpPU2Z2ZlJGU01qODNyMy83Ly85Zmk0Q2M0OGVPNjJiODViL3lsL1YvK2lzL3RtejhiLzN2bjlUNDJMaSs5dXlmYVMwKzlOUUg5Y0ZRRGg4K1ZBU3JYUExpaXkvcGpkZmUwS2MrK2R2WGZYeTVYTmI5RDl5bmh4OTVTRC95b3oreWJQcS8vUC85aHNiR3h2VHFLNjlwLzRIOSt2RDNQS1czUGZpZzN2NzJ0eFhySzRiUEpEYVJUV3l4SHFPNHJEekxsV1dabm52dUczcnV6NThyeXR6c25OWXFCZ1BGN2ZiUXc2RitmK25qT25EZ29IYU5ESWZ0Rlo0emh0OGtpMzhUSFFOa29oaWdkT0hDQlYwNGYwRmZldnBQOVBwcnIrdjA2VFBLdWwxdGhEMTc5K2lKSjkrblJ4NTlSTzk0eDZPWDEwbHNUM0Y5WEtwZmJFTXVkOHBkZm5uZGZQbExmNkxKeVVuOWh6LzhUTkcyVnVQalAvb1hkV0QvQVgzNEkwOHRtMVlON1RtdXF5c05EQXdVMitQZTBPYi94ay85OVJXWCtjYnJiK2lUdi9XcEltRHA5S21WdzRIMjdkK24vODgvLzJmTHh2L3haejlYdklZdmZQNXBOUllXdEZxM2MxK01RVnRIN3JwVFR6MzFvV0xmdWRxdi9OS3ZGa0ZKSjQ2ZjFKRWpkK3FKOXoraGQ3L24zYnJqanNPWHQyK3BWQ3JtamZXTmJlL0pNTStsN2ZydmYvZjNpMzNtMldlZVZiUFJGQUFBQUFBQUFBQUF3R2JyeklielUxZGR3TjdIaEo0d3poM3Z5SjN1R3QvMldtMTZVYksvZEY0Vms2UVBWVVpVQ3FkSUtsWmFmZlJSejJybnZ0WE0xQTZuZVdyaGJsa0FBQUFBQUdEREVHQ0VwZUxCcXp3Y1lTSlZHZ0FBQUFBQUFBQUFiQ0dWU2lXVXF2YnYzNmQ5Ky9acHo1NDlSWGhQcVZ3cVFsR2lHSDV6U1F5ZWlkT2pHRklTNStucjY5UCs4TmhhdFZxRTRrUnJEY2JwNys4cndtQ3VGcGNkeTFwVlExMTI3ZHFsM2J0M2EzVDM2T1h4Wjg2OHFWMGp1MWExakxodWhvYUdWcXhYclZZdG5tTjBkQ1RNTTFqTXMzZnZIdTNlcy91Nnk3c2t6aHZYZVg5NGJlMVdlOGs2WG8xeXBhekI4THlqbzZQRmRodmRQVklFMEZ4THZWNHZ0bFVNVmRxN2I2L21abWVMTUptTk1EZzRVSlJpbllUbnVuS2R4Q0NiNkZLd1VneStzV1ZiaFBOY2N1andvYUw5RFE0TXlJWTJOcnVLZ0tmWVJ1cjk5UlczMWJVc3R2MUtzZjFXc3JDd1VFeS9GTFowTFNzOVoyeGo3WFpiYTdFUis2SUw2emtHSEsybERvTVgyL1BWcXFITngrMDFQem9mdHVtZVlwNDlOMmp6VjdyanpzT0tXVjZ4empIVWFLMXRIZ0FBQUFBQUFBQUE0RmI1TEp4VHlhNGVGMDZ5ZEx4M1RTZlg4blpWQzBxMGVBS216OHBVakV3OVhzVWpuTE5KdGtGNlVSQ3ZuNUdIazB5NXA2ZmNKZUY4bkRsNjlDT3A5QkYzOU9qUjFaK0FBd0JzV2Y3b1hkVXdxR3FqN0Zrb3ZwV1l2M04rZFZmM0FnQUEyeFlCUmxpcUhRNHd6WVdTQ3dBQUFBQUFBQUFBWU10NDRzbjNhV2g0U0gvMy8vNTNsMDFyTlZ0RjBNd2JieHk3SER4VHE5VjB4eDJIaXhDU0dLSVRBMzZpLzhkLzgxOFh3Ny96TTM5UDNXNVh4NDhkMTNZVzE4UGh3NGYxTXovM2YxdThIZGJKV2p6MitMdUtFb09lNHZwOThWc3ZyU25RSlFZbi9kVWYveXRGSGU2KzUrNVZQU1lHT3NWeTRPQ0I4THlaZnVXWGZsVlRVOU5hVDRPRGcvcWJmK3NUR2duMWUvTDlUeTZiZnU3c09UV2JUYzNOelJlaE96RzRhbUJ3UVB2Mzc3ODhUMnlUVVp3MmRtNU0vL3AvK1UzdEJCdXhMellhRFoyNUdDcDJxL3JxZlVWZzBVLy96TjlldHMxVzR3Zi93ZzhVdy9QajR4b2JHeS9hUEFBQUFBQUFBQUFBd0diS21rWW1XWnJKNDg1bXpmeU5Uc1BQdUg0NVZWY1RRWlNNSnZPcTJLejgzdG9lYlVOdDU4eDB5MW5uZll4bEVvb0FvOEVuamxRUHp6V2V2aER1RWpRQkFEdEJ2ZjZnY3YyWU5zcHMvWnhpZk9KUi9iWTVTb2dSQUFBN0dRRkdXTXBmTEFBQUFBQUFBQUFBQUZ1QWpSY0JOVWFIRHg4cVFsT3VGQU5tbW8ybTNuenp6WEM3cGRPblRoZmhLVkcxVXRYOC9MejI3dDJqdmZ2MnFwU1dsSmJlT25WMjVNaWQ2bWJiUDhCb2VIZzQvcFZxRVNJVFgvL2MzSndXRmhwcUxDd1VRVVR0OWx0aFJBTUQvY1h3eUYxSGluVWUxLzBsTVJDbTNlM28xVmRlVzNXQVVReXNxVlhyUlVoUURKSzUwdHpzWEJFZ2RTcHNzMHVzc1NxVjA2S3VzWlJLSlZXcjFTS0FKZ1lPclplK3ZyNGlSQ2ZXNitybHpzN01hamFzbzlkZmZ6MjBuNFdpZmNWNlZXb1ZqWXlNRkxmNyt2dUtaVndTWDF1MzB5MldGMTlUZkczWE1qNDJyaXpMOWMzblgxZzI3ZURCQTZyV3FtRTd2TFd1NHJ6TlpxTUljSnFhbkZweG1iSDl4KzNhQ0hYZFNCdTVMMDVOVGExYmdGRnNxNk9qbzR0dFBsM2E1aHVobm5uMjFwVmVZcHVQYld6Zi9uMlhYOS9sNWV6WkcrcFpJc0FJQUFBQUFBQUFBQUJzT3U5Q3lTL2Q5dUdrVVJoMnZmVWRYd3Iza3hzdXdNckpLRmVmVFd5ZjFVYTZWTDlsWWkxanJKQmQvMkFoNzJQM09DL253am9KejJUanFVMVBoRkhCKzlSMlhMVlVwMThwQU93WW5VNVZTZWt1YlJnWC82Q2lvY0U5WmVtOEFBREF6c1VQVFN3Vnc0dHlEc2NBQUFBQUFBQUFBSUN0b1ZLcEtFa1QvZFdmK0t0THdrV2lHSkx5Nml1djZnLy80RC9vN05seldwaGZrUGVMVjNKSWtrUzFlazNmL3dQZnB4LzR3ZTh2QWtvR1MyK0YxZnhmUC9IWGRPSDhCWDNwaTEvV2R2YkJwejY0R0RwengrRWl5Q1VHRUwzMDRrdEZPWEg4aENZbUppL1ArL2k3SHl1Q2FmN2UzLys3UmZCTEROTzU1TU1mK1hBUlhQVFZyM3cxTEdkMXp4MURaQTdmY1VoUHZ2L0paZE5lZXVrbFRZYm4vdi8rOC8vaDhyZ1llQlFmYy84RDk0Vnl2OTczeFB0MDl6Mjc5QlAvMlk5ZkRzTlpEdzgvOGxEUkhsYXExelBQUEt1WFgvcTJudm5xTTBYOXJuVC8vZmVIOWZCVWVQekRldVRSaHkrUGY4OTczcVBaMlZtOS9QSjN3dnFjMExOZmZmYWF6LzNGTHp4ZERELzlxVTh2bS9iVFAvTzNkYys5OXhUYjRaSVlYaFMzMmVjKyt6bDk3bzgvcjl0cEkvZkZiNGQxOTl5ZmYxM3I0WHUvNzZORmVGRnM4M0Y3eFBYM3RXZS9Wb1NWdmZMZFY0c3dwU2kydDdnZDMvSE9kK2hILzlLUEZQZkxsZkxsNVh6OEwvMUZqWjBiMHg5OTVyTUNBQUFBQUFBQUFBRFlUSGxic3FXTGQySjQwWFF1UDVsWHc3QzZtc2ViaWwwd0ZkTk9INmdNMlYxcFNSdXBFK28zdS94Y25obTA0VVNSaVdGSzZ5NkdGM1hDVTJiT2xKMzM1Y0Z3N3FvYW5tdGpvNXEyaHJERys2MTErOHNOVFFzQXNETWs2WVBoQStCdmFLTjQrM3o0NkowSjMwbCtVd0FBWUVjandBaUw0dDhIeHpSclIzZ1JBQUFBQUFBQUFBRFlPbUxZU1Y5Zlh4RXVjaWsweFRtbnJKc1ZvU2xmZis0Ym1wcWNVcWZkV2ZLNE9FOGM5OGJyeC9UbHAvK2tDSjRaSEh3ck5LVy92MS9kYnJjSXlwbWRtZEhZMkxpMm8rRmR3OFhyZlBGYkwxME8xeGtmUDYvejQrTnFOSnRMNWozNzVsbk56ODNyeFJkZjBwNDl1M1h2ZmZkZW5oWURZZUkyMkRVNm9pelBOVDExNDc5M2pVRkVodzhmWGpLdTFXb1Y5Zm5XQ3kvcTFNbFRTNmJGa0tJWXNuVGkrTWt3bkZlZTVXR2VrM3Jnd1FlSzUxNHZEei82c1BidDI3ZGszUFQwakdhbXAvWDZhNjhYUVR6TlJuUFo0eVluSjRyMjFqL1FyeU4zM2FsNnZWNkU4MFNsdEZTODN0cXBxcDdWOXJTUisrSm9hRmZydFMrT2hHWEY1NHR0L3ZUcDAzcmgrUmQwNXZTWnNJMm5peEN1UzJKN2kyMCsxaVcyK2NPSER4V2hSNWZFN1Rzd01GQXNyeHRlNDl6c3JBQUFBQUFBQUFBQUFEYU5EK2RaT2w1K0lYZnVaTGZqWi9MWVR6Qzkva084RCtkeGNyc3ZMZG1SSkRGVnU2NlpQbjdPWlQ3ejNrL21iZU5sOHBiclV6YzhhOGN2bTlkVXd2bWsxUGprVUNremFhalZnRjIzZm83T0syL252cGs1SDA4aWxtMDRkeFVYM211OTVuSm5RbDJOenMzVTFPNm1zdUhjWXFXeXRKWXo3YkplRzNNYTdXK3B2OXBWYXAwTTNmOXdDMzd1NS82TCs1U245N1dhOC9lR3ZYTmZPR0diWE41RGpSMHBwZVdQR2F0bmZ1N25QdEdxVkhiTi9OcXYvVnBUd0FiNm1aLzU2NGVzcnozYWJpKzh5em0zejN0WDFoVWZHNlZTOVdQaG5mMTBhSlBuc3F6Yy9JM2YrSTBaQVFBQW9DY1JZSVJGTHBUTUxBNEJBQUFBQUFBQUFBQzJpQmlhTWpvNnFuTGxyUUNiR0d3VGcwaE9uejZqcjMvOUcwWFlUQXdqdVpMM3Zwam5qZGZmMFBueDgwVUlUZ3hJdVNRR2s4UjU0cmdZY3JKZEE0eDI3ZHFsaFlVRnZmVGkwMFZZeStmKytQUFhuUGZzMlhPYW5aMEw4NzZrKysrL2YwbUFVUXh6aVVaSFJ0VHRkRmNaWUhTLzl1emRzMlJjRERCcU5wdjYxZ3ZmMG5lKy9kMGwwK0kybkorZkw4cUpFeWZVQ1BXTzIvKysrKzlUcGEraTlmTElJdzhYeTcxU0RDODZjZUtrWG4vdGpTTEFhQ1VURTVORmllRkY4KzkrckFqeXVSUmdsSlpTUFhCRis5cU9ObkpmSE4yOWU5MzJ4VmpIOGJDTTJJN2p0dnp5bC81a3hmbUtBS1BRNWl2VldqRnYzSjVYQmhqRllLVjJ1MTBzcjlGb0VHQUVBQUFBQUFBQUFBQTJsdy8vZDBLWmw4dFBkTnArOFJUTWRmc0tHbU9jakRLek95a2xkNWFUOWU1WjZPWmM3cHZPNWErMEYrUjhFdTczWGZjQlpTTlRzMWtvTmxuUEFDUDV2SjM1aFh3eEFLTWN6OWlsUFpqNkU4T0x1cm5WNmNsK3pUUXFNaVduU3JKMG50bVcwV3RqUm9uMXFwVHlZbWprQmR5MFBMM1BHbjJzWEszY0YwN1Y3ZzhuYkMrM3V2QWVNWkpZKzdIUU5GdmgzdkhaMmRsNEJSZ0NqTERCNm9lczhSOHJWNnJ2ZE03dE45NlhyM3lYUzVQa1krSCtkMEtiL0Vwb2pwTmhGQUZHQUFBQVBZb0FJeXlLMytqYm9XUUNBQUFBQUFBQUFBRFlNbzRjdVZPSERoMWFNbTV1Zmw1dm5ubFRGeTVNRklFNHpsMzdDZzZ0ZG1zeHFPVE5zenArN0lUdXVQUHc1ZENaT0l4aE5NMW1ROXZWeXkrOXJLbXBLWDNwNlM4WElUSTNFdGZWOGVNbk5ESXlzdUwwR1BDU2xrcGhYUjYvNGJMdXV1dElFUUp6cGJGell6cDc5bXpZYnUwYlB2N2MySmltcDZmMTd6Nzl1NnJWYS9xYmYrdW5kQ3ZpYXlxVlVnME5EMnR3Y0hESnROaVd2dnVkNzJwbStzWi9CeGZuT1JIYVVueHRsY3Bpc0ZKaUUrM2R0N2RZMThORFEycUdkaG5EYjdhVGpkd1hhN1hxdXUyTDMzeittNkZPWjRzMkg4T3dibVIrZnE1bzgzZmZjL2V5YVVtU0Z2V0t3VlZuVHA4UkFBQUFBQUFBQUFEQVp2RzVmUHRVM2xZanN5YjNOZU9WM0NqV3hnNGszdTVQWExJcnpKb1dZU1c2cFRvNEg5T0M1TWF5bHB2TU16ZVZWOVQyaVcrNFFSOXpkbTdBT08vems1MnVHVTJUNUdDNmJsY3M4ZDc0VmpqeGxIazU5YkJHTzlWTXM2UjJKMVUzczdKeGUxd1ZZQlJYWXplVFpodWxjTTZ4b2tPN3d2bXkzc3Rpd2hid2lVOThvbHB1dC9zVDZ4OE11KzVUMWlhN3ZmZjF1TU5jOFY1UU16SjNlUGtuYkdobzFjVDlYaGczS1dBREhQM0lSOUlMRHp4d1gvaEFlMC80UVBvQmEyMzhRNVI2YUkzMnl2bGltd3hOTlA2NXdZZXNyYndjUnAwVUFBQUFlaElCUmxnVWoxRGxSZ1F3QXdBQUFBQUFBQUNBcldSNGVGajc5dTliTXE3YjZXaHljbElMOC9QS3V0ZS9la01XcHNjU1EyZmlZdzRlUExBa3dHaDBkRlFEL1FQYXJzYkd4b3JRb05kZWZXMVY4K2Q1cHNtSnlTS1laaVZEdzBORlVNMXFqSXlPcUZhckxSazNIYmJEMkxueFZTMGpick1ZSi9UQ04xOG9RcE51TmNBb2hpRFY2M1gxOWRWVnJWYVhUSXR0S2E2bjFkU3IyV3dXYmVuS1FDaWJXQTBORFdsZ2NEQThUMTFabm0rN0FLT3RzaS9Hb0tIVHAwNnZ1czIzTysyaXpjZnRlclZMOWNxelhBQUFBQUFBQUFBQUFKdkt5V2VUTGpjdDcxT24ybXE2aEptS2tkMVRrcWxhR2J0T0tUZ3h3R2dpNzdvM3UyMDNsMWVVRi8wVlY5Vm4wY2RUTEpQaHhGbHExaldTeDRlVmtUbmpuZS90am5LZHpHcStWVlludDNJK2JKdHJiSk9ZRTlYc3BpcUZlWjFyS3JGMEFNVGExUmNXMHZMb2FIL20zUUVaM1c5bGF6TCs2bjAxbnFBZHNkN2NaWnh2aHhQZFh4YXdRWTdmZFZmYWIrMys4QzUzUjJpVEQ4VjN3TVRhbFdZZGtWY2pmSExkNTQwbFVBc0FBS0NIRVdBRUFBQUFBQUFBQUFDQVRYUHZ2WGNYSVRocmNYN3N2TnFkam1abVpsWlkzajE2NkpHSGxveWJuNS9Yc1RlT2FXcHFXcXQxK3ZRWlZXdFYzZi9BL1NwWHlzVzRjcm1zaHg5K1NCTVh0dS9mUDczdy9BczZkMjVzMWZOM3U1bU9IVHRlclBkYmRkZmRkeTBiTnpjN3AvSHg4OHE2WGEzV3FiRHQxa044VFRGVXFWeGVmbkhYV0tjWFgzeEpDL01MTjF4T2JIZHZoSFgwcnNjZld6YXRFdHJVbnIxNzVGeGV0TlB0WkNQM3hZR0JnWFhiRjU5OTltdWFEKzFzdFJibUZuU3NjVnpUYTNnTkFBQUFBQUFBQUFBQUc4MTN2YzNPZE90SlRCQzZrVVFkVzdjemRqU3QyQVBwZ0JMZGt2RGM4ZzBuZHlIcjVxOTJtcjdwS3I3citydzM2NXRFZEpPYzk1V084L3U4OTlhb0YycTBzcEgrdG9ickhlVWExRnlub2s1V2x0ZlM4STdVZHBYWVhFZEdwN1M3UHF0U3VvcnRmVDNHSEpZM1Q2YVY4b1Z3NzV5d1kreDkrT0hHMDA4L2Zmcjk3M3puNzJTSk9abVdTdi9Qc0hmY3RYUXVQKys5VG5aZDlyODNHblAvVzZPUlh4Q3dRWDd6TjMrejlZbFBmT0taMGNIYW5ESGw2YlNVZkw5Tmt1Ky9lcjd3WHY2eWQvNjU4MVBULy8zZzRHQlRBQUFBNkZrRUdBRUFBQUFBQUFBQUFHRFRKRW1pU3FXeXRzZWtxWkk4WDNHYVhXRjV6amxsV1ZZTVZ5c1B5KzkwT3N2R3gyV255UzMrQlc4UGE3VmFhcmZiYTNwTURCZGF5N3E5bGxLcHRHeWM4NjdZRm11NUd1cGF3bzZ1NTNwdDgxTDd5RmZ4dW92MjE4MktrS0tWcEdraXUvSlZBN2UwcmJJdnRsdHR0ZGJRNW1QZEx4VUFBQUFBQUFBQUFJQmVZcktMNlR5ck9mVmtqVk1xYjlKMXloaHlSWkNSOXd2aHpGN3VqWnl4UFJVVjVKWDJjbmhSbEZoZmxEUUpKYXk5TEp3TDgzNXBuZU41eGRRNmxjSjh0eHhlcENJSUpBMHRwMnFjcDEvcERuUDA2TkhZZ053SDN2T2VoVktpQ1d0TlF5dnNJNkdOZEV0SzU4cmwvTUw1OHdzTkFSc29oaGo5ZzMvd0QyWVQ1eVpzbWpTc1dibE5ocWJhK1ZmLzZsOXQzNnVQQVFBQWJCUDgwQVFBQUFBQUFBQUFBTUNtK2VtZi9XbXQxYi82bi8rMXhzZkc5Y1V2UEgxNTNMNzkrelE0T0toNnZiWnMvdG1aV2IzNnlxdWFuSmpRclloL0ROby8wSzlLYlcyQlM3aStSeDU1V09WS2VjVnBNOVBUT25mMnJEcnRqamJiNk9pSURoell2MkpJVGd6VW1aK2JYOVZ5NXVmbXJ2a2Fhclc2N24vZ2ZyWER0TE5udDhjRlRUZGpYNHpoVXV5TEFBQUFBQUFBQUFBQU44Y09KT1hTNDdWOXBucHJnVDR4c0NoL3ZkUFdRdTY3cjNlOHZKSlFoblN6U3Nhazc2eFZUVzE5cnY0UnI1SFN6THphMmRMeGFYalpsUjdPTXFxR3l1VTJsRTRwdklhbHE2S1NlRlhTWEVuYTIyRk0yRHJLL1VrNDhaMmVremVkRlVLK1lpemFkTmlWcG4vNW4vM210SUJOME5lbnVmQk8rSnE4blZ6eG5hNW9rMzUxZjdBQkFBQ0EyNG9BSXl5S0Y3R05CMmNjQnpNQUFBQUFBQUFBQUVEdmkxZGRpNkVtV3FjTGhIYXpyaHFOaHB4YmZ0WEtJanlsdjErZGJ1ZTJCT3RzTnpheGk5dHVCZDF1ZHMzdHNORm1aK2MwTVRHaEV5ZFBxbHdxTFprMk5UVzE2dVhFdW1kWkhxOENxSjJBZlJFQUFBQUFBQUFBQU9EMjhCZkxkU1hxS0RWV0paUHFKa0p3Zk9ZWG42VGhNdC95dVp2THJWcmhSSmczb2ZoRU42dG12SzBuZVJGZVZORzZkV2h6M3J2Yys3aTh5OHVNbFl4bi85WWxKUWtBQUFBQUFLeUlBQ01zeXNNeG1VWTRETk1WQUFBQUFBQUFBQUJBenl1WHk2clhhMHJXNTJLY21yd3dVZndGcTNQNXNtbkRRME42NEczMzYreWJaM1gyN0RuaDFsU3IxYUtzWkdKaVVxZFBuMUc3M2RabWUrbWxsM1hzMkhHOStNS0xNbGUxcTdqdFY2dWJaV28ybTdjbGhPbDJ1QjM3NG9uakp6VFJuaFFBQUFBQUFBQUFBTUJPdFJoZVpJcHlQYlkvbWJLRHRtUjNKU082bWVkcGhuTmVXVGdIOW8zbXRNSnROK2QyYXgya0QxVGJwczhxT1poV3RVNWlvbExtMWM0WHM0b3FsOGJYcmRHdXhLN1g5VGdBQUFBQUFNQUtDRERDVytMZlVPK01DOEVDQUFBQUFBQUFBSURiNU1UeGsrcDBPbXQ2ek16TVRCRUljNlVrVFpTbXFjd0tmNURydkF2UGtlMllBSm10Sm9ZWDFlcTFGYWZsZWFadXB5dnZOLytrMWNMQ2dySnVWKzEyUythcXYxNXVYTlgrcnFmZGFtczJ0Tmw4aDdRLzlrVUFBQUFBQUFBQUFJRGJ3WVJ6TVdiWmVhMnIyYjFKMWZRbmlWYkxlZmw0blltMjYvcUd6L0twcktwdWVMS21MMnR0cDNtdnJtNGVpeDFOU3lxRldnL2F4RmJXNXdJWlZ6eUpDK2VubXVFVVZWbFhCQmpoQ2tiOTN2bjlwdVRYTFRnS0FMYUw3Ly93OXovcWZGSXpTWFpUb1grOTZuZE96RDd5eEo3V3ZHNVJPZkdkb1pKYlNJenFpZldqYjAzeEo4TVhrdk5LYittYkFnQUEyQVlJTU1LaStEZmdlVGhnNVlpU0JnQUFBQUFBQUFBQUcrZkZGMS9VdWJQbjF2U1k4YkZ4emMzTkxSbFhTa3RGRUk1Tmx2OVJhNTY3SW9TbW0yVkM3eGtjR2xSZlg5K0swN0p1RnJaZFc3ZkQ5TlMwMWtNTVFvb2xCaG50Qk95TEFBQUFBQUFBQUFBQXQwZW01SVlYczAvdXFReXRwUWRoRVY3VThYSmplVHQvczd1UVg4Z1N0WDBNQkJyVXJUQ21hOEtTMG52SzFnd25xUjJ5SmRsMTdzZm12ZS9tbXN1OWorRkYvY0l5eG11M2pCNDB1UjhXQUdBSmt5Ui9PWHl5am9SUHozZHBHL21UOGI1K2F6V2hXOVNmdW9YSFJ0dXYxeE4vdUhabGdKSFJ5K0V6K0x1YXZVQ0FFUUFBTzF6YVgxN3ZwR0pzUmE0YkRsb2xNY1pheWdVQUFBQUFBQUFBQUxBeFh2cldTM3J0dGRmWDlKalptVm5sK2RJekdMVjZUVVBEUTByUzVSY0xiVFlhT25mdW5EcHQvaTRHMkdqc2l3QUFBQUFBQUFBQUFMZUJEZjhQSkRJbEtla3ZMWnRzaGhJblk3eXAyekRUS3BibnZYZXpMbFBYeXplYzhWMVh0bjNoc1VrcFVlNTEweEtUbTVMSlZEZlc5Tm1hMlpWWVU3VXgwRWpyemhoVFRVdzl0MHI5RlMvYUprYnRjQ3ByUEl3cW1WdDRMUnVrRWNxMXpxYkZ5NFRFVnpJbHI5WTYxTjJGRnVFUzdUN3Z6Wk4vOTkvOFlGWFljZWJtMzlocnUvVzlmYk1IKytXdlNqY3p2cHpiN3U2c092dDRhQi9yY3dVZzRBWm1XNjhPSjgyaHc5WEduanZUYm0zWjlOeDJkdnVrL1VCb2t6K21EWGJzZC9MMytseERuV1p5djdhUkUzTnArdG04LzViZjg4djFVdDh6cFVIL1lHMSs2RDJWeWN2ai8rZTUrNTk2c1R0MDN5dmRvVWZ2L0xuMHFvODBKeHUranlRbWMxYk9MWm5ramNtVjJwWktwWmFyVkFRQWEyRENGOXM0blBXRHR4YTBDbUE5UFo5VzB3MzRzWTh0SjQrL05XMzh2a2VBRVFBQUFBQUFBQUFBMkRqajQrZDEvTmh4M2FweXVhSjZ2YTRrV1I2YTBzMHl6YzNPQ2NER1kxOEVBQUFBQUFBQUFBQzREVXo0djJaa3kxWjIxL0x6TkdaLzZrMWl2S21zcnUrZ2o1RUNMZTljeXhrdGhEdGVpY3FtYk11MzF2ZlFwTWFyYW5JemxKVHNZRktLL2RlMFFkMFpqYnhKRTFNT3o1Z3NTV213Um5rb2MrRjVlN0VyWmVzNi9mbGlaRkVNTVZvSTgzVFhvZTU1REtpUitoZXM3ck55d3M3alN0MWhvODZ3dDNtL3laY0dHSG41OEliaStsM2F2ak8wajNjSjJBUSt6ZnA5cWJQYjIrNkl0RHpBS0xaSm4yUWptOUVtYmNYYzdkcnFEMiszKzdXTnpHZUpYcHROZEt1U3JGSSt2WHZVeVNUVmUwck55K05mNmc3ZitjM095SjV3OHgzTDh3bkRwN0x4TVZjd2Zvd3QrZUR4NFd0S21GSXlUdkhiU3A4QVlBM014V1NNOEFheld3QjZnOUdSZEtqY2c3KzZzZW02OGF0ZitQN3B3cmZEcmdBQUFBQUFBQUFBQUhDSlRheHF0WnJTdENUZ1J0SlNTYVUwVlpKWVlYMWQyaGVUTkJVQUFBQUFBQUFBQU1DT0ZnT01oaFBaUHF2a3lBcm5wU3BtVFNlcjR0eG1seTFaRjI0NEx5OWppdlNjVzYybWxmWEdWRXdhYXJ6UnA4K01NZFhFOTNsWlUwdmVxcndONjZvZGhtZk5PcnlnRFJEUFF0dUw1ZXFlbm5rTUxnckRoYkF4OG5YWUlHRUovZDZvMnZINnFJei9vTERqT050TlRaS2t6dVlqZGxseWxpdUg2ZnZ5cEIzYWhudW5nRTJRS3c5dHNwTzZwTk8vMHZTaVRaWTZ1OEt0ZmRwZ3BYcXl2eHMvTk9hRkZiUk5PWjNXbnVGaGx5YXZkTjRLTURyVkhkMDdubzFlSTR2UEY4WEVMeGU2K29PNCtOU3pMbnhiOERMOGtRMkF0ZkVpSkFYb1FXa3BZZCtFaWlNeFNTaVc1Z0FBQUFBQUFBQUFBTEJFWWhNbFNTTExpUlNzZ2pYaHZGc2FyMXhIZTFsdmwvWkZ3N29GQUFBQUFBQUFBQUE3WFRoM2FjcXhoTE5TZlN2MitWL2JDUlVUVG5LVmpibTVCMS9YcHAxbGpabE9pVFhwNVh0WGNLRTAxSnY2UWxWVG94WHpuV0s5WFpqV2lrRkc2N01pMDZJWUhlUjg1czVrek1VTWtSVUN2WHlNR1RPKzZxMnJlcG5kQWpiQnBUWVoydDAxWmdodFVrV2JITlFHTTBsNEx5Wkc1NXFjTjdibHkrVjVYMVlzbDRSeGxhN25RbFFBQUdEeEJ5Y0FBQUFBQUFBQUFBQ0FhNmhVSzlxemQ0OHVuTDhnNEdveFVHZDBaRVQ3RHV6WDJ4OTZVSGZmYzQvdXZmZHVqZTRlRmRiWHBYM3h4UEdUQWdBQUFBQUFBQUFBQUFBQUFBQUFRRzhnd0FnQUFBQUFBQUFBQUFDNERtdXQwalNWNFRKcjZ5SUcvc1N5bFYycWYxOWZ2Ymk5Yi84KzdkdTNyeGp1M2oycW9hRWgxV3QxWVgyOXRTOXlOVmdBQUFBQUFBQUFBQUFBQUlETjRtV1VlYU8yVHpUblNnSUFBTGdhQVVZQUFBQUFBQUFBQUFBQU5zM282SWdHQndlMWxRMFBEYWxjcWVnbi83TWZWNjFXMDBlLzc2T1hwNTE5ODZ5T0hUdXUreCs0VHdNREF3SUFBQUFBQUFBQUFBQUFBQUMyc280U3ZabjNhODZWdzdEdjh2ZzNzejRCQUFCRUJCaGhrUW4vSjR0REFBQUFBQUFBQUFDQW5hYWJaV28wR3NyelhOaFlhVnBTdVZ6V1ZtS01rYlcyQ0N1cTFXdTYrKzY3MU5mWHA1SFJrV0pjYkRmZFRsZFQwOU02ZWZLVVRvVnl4eDJIQ1RDNkNleUxBQUFBQUFBQUFBQUFxMk5MUGhRQkFBQnNPQjlLNW8wNnNwcHpiMzBCeWVtWURnQUFMaUxBQ0FWalEyT29pWU5XQUFBQUFBQUFBQUJnUjVxWW1OVHM3S3hjN29TTnRXdGtsM2J0MnFXdHBGUXFxVndwNngzdmZFY1JUUFRESC84aEhUaHdvSmptbkZOam9hRmp4NDdwYTgvK21WNzgxa3Q2NmNXWGRQOEQ5MnZQM2ozQzJyQXZBZ0FBQUFBQUFBQUEzSmhOdktvallWajJBZ0FBMkdqT0d6VjhxU2puWFYwQUFBQlhJOEFJQldNdXBtNG5KRjBDQUFBQUFBQUFBQUFBVVF3dEdoMFowWkc3anVqT3UrN1VrU05ITkRvNnF2NysvbUw2eE1TRVdxMld2dmJNbjJuczNKaSsrOTFYZEg1OFhBQUFBQUFBQUFBQUFBQ3dHdE1URitUbXA5V1pkUEw1MG1scG4xRlNOeXFWbXJJMUFiY3M3MmJLV2szTnZIa3N0THRreVRTVGVpVjlYdW4rbHRKK0FadkNaYm5hemFibUw1eFQ5OXpFc3VucGtKUHR6MVFlRVFBQUFIb2NBVVpZWk1PUHk3S1JTV0xxTmlGR0FBQUFBQUFBQUFBQVFMbFUxb0dEQi9UWXV4L1RrKzkvUWtORFE2clgzN3FLM09URXBHWm5aL1c1UC82OFptZG1ORFpHZUJFQUFBQUFBQUFBQUFDQTFZc0JSdTFKcDhsVDAzS1pXekt0UGx4VGZWZE51L2FVMUVkWFVLeURMTXVVTmJzNisrWlp0YWE2UzZZbEpSdmFYRlZEL1JVTnFTSmdNK1I1cm00ejA5VDVDVTJkV0ZnMmZXQlBYWldSUlB2dTd4TUFBQUI2Rzc5YUFRQUFBQUFBQUFBQXNPTU5EZzVvY0doQU5ySEN4bXEzMjJxMVd1cGxwVktxdHovOGtQYnYyNitQZnUvM2FNL2VQVVY0VWFXeStFZWFKNDZmREsraHFkLysxS2VMMTNMdTNEbGwzVXk0ZGV5TEFBQUFBQUFBQUFBQTJFbWFyUVUxRjdwcU41dktyd293TWhVblgrNXFJQnNVWFVHeEhwekxsZVc1bXJOTk5hYmFTNllsMVhDT3RwU3IzbzNuYWdrd3d1Ynczb1UybWFuVmJHbGhhbm1BVVZMM012WFlIZ2t3QWdBQTZIWDhhZ1VBQUFBQUFBQUFBTUNPVjYvVk5EUTRwQ1JKaEkxVlhORXg2KzJ3bnpRdDZmRGh3NkVjMHJ2ZisrNWwwNmVucHpVek02UG4vdnpyY3M2cHNkQVExZ2Y3SWdBQUFBQUFBQUFBQUhhU3JOdFZwOU5TdDl1UnkveVNhWjJPWkR0T0xpZTRBK3ZEaC8rY3o5VU5qYXZUN0N5WmxqaXI4b0JWM3VQbjg3RzlYR3FUV2FlN3JFMUczVTRhM2grTkFBQUEwUHNJTUFJQUFBQUFBQUFBQUFDd2FVNmZPcU9weVNsOStIdWVVaTk2NHYxUGFOKytmZnJybi9ocnk2YTkvTkxMR2hzYjA3Lzc5TC9YdWJObnRUQy9JQUFBQUFBQUFBQUFBQUFBQUFBQUFHQW5JOEFJQUFBQUFBQUFBQUFBd0tiSnNtNG92WHZGeG5xdHJucTlyc0hCd1dYVHNtNm1acU9wK2ZrNVRVL1BDQUFBQUFBQUFBQUFBQUFBQUFBQUFOanBDREJDd1lhV1VCbnhTdDQwQWdBQUFBQUFBQUFBd0Z0aVlNM1pOODlxZm01TzJMNE9IVDVVQkJmOTlNLytMWTJPamk2Wk5qRXhvY21KU1gzcVU1L1dzMTk5VnJnOUx1MkxjUWdBQUFBQUFBQUFBTENUbVVTcTcvY0NBQUFBQUFEb0JRUVk0UzFrRndFQUFBQUFBQUFBQUN6anZGT2U1OFVRMjlldVhiczBPRFNvY3JtOGJOcjA5SXhPSEQraG1UREU3WE5wWC9Uc2l3QUFBQUFBQUFBQUFBQUFBQUFBQUQyREFDTVVqSldTVUd3aUFBQUFBQUFBQUFBQVhDSFBjaldiVFdYZFROaStIbnY4WFRweTF4R1ZTcVZsMDE1NC9nWDk3dS84ZTAxUFR3dTN6NlY5TVlZWUFRQUFBQUFBQUFBQUFBQUFBQUFBb0RkWUFWY0tMY0xFV0NzakFBQUFBQUFBQUFDQW50WHB0TlZvTk9TZFh6YXRYQzVyWkdSRXRYcE53R3FOam81cTM3NjlTdE8zcmdIVGFyVTBkbTVNMDFQVFJYc2pPR2M1OWtVQUFBQUFBQUFBQUlETlpVcGV0aVFBQUFBQUFJQ2VRWUFSbHJDSmxGYkNnYXhFQUFBQUFBQUFBQUFBUGF2WmFHcG1la2JkYm5mWnRJSCtmdDExOXhFTkR3MEpXSzFEaHcvcGJRKytiVm1BMFhlLys0ck9uRG1qbVprWmRUb2RZU24yUlFBQUFBQUFBQUFBZ00xVnFrc3AxNDhBQUFBQUFBQTlKQlZ3Qlp0NkpWVXZsMGw1WmdRQUFBQUFBQUFBQU5DTHVsbTNDSmR4emdsYnkrek1yTHFkN29yVDBsS3FTcVZTQkFWNTc3VVordnI2MU4vZnAxSnArYW5UZHJ1anNYTmpXbGhZRUZiR3ZnZ0FBQUFBQUFBQUFMQzU0b1hyTGIwQ0FRQUFBQUJBRCtGUUJaWXdkdkVBbGlHN0NBQUFBQUFBQUFBQTlMQTh5NVZsMmFhRjNHRDl4TENiYTBtU1ZLVnlxZGkyZVo1ck0xU3FGUTBPRGFsVUtpMmI1bktuMmRuWlVPZTJzREwyUlFBQUFBQUFBQUFBZ00wViszL0ZBZ0FBQUFBQTBDczRWSUVsYkVVcURYcVpzZ0FBQUFBQUFBQUFBSHBXcDl0Vm85RlU3cGFIM05qRXFsYXJLVTFMcTE3ZThLNWRPblQ0MElxUG1adWYxeXZmZlZVVEU1UENyV3UzMm1vMm15dE8yN1ZyU0lmdk9GU0VDbTJXVXBxcUh0cUx0Y3RQbmJZN0xaMCtkYm9JTWNMS2JzZStPRDA5SXdBQUFBQUFBQUFBZ0oycU11UlZIdWJpRWdBQUFBQUFvSGVrQXE0UTA3ZHRhQlhHQ0FBQUFBQUFBQUFBb0djNTU1VG51YlRDMytVbU5sR1NKTEoyOVNjOEtwV0s2dlg2aXRNNm5ZN201K2VGOVJHM1c3SHRWbEJzaDFwZGRoTXZHUnVEaTVJMENlZkhscmNYbDdzaWJDbnJkb1dWc1M4Q0FBQUFBQUFBQUFCc3JxUWN6bkd0L3ZvUkFBQUFBQUFBRzQ0QUl5d1JEMkNWK2hkRGpBQUFBQUFBQUFBQUFIclYyTG14b2pRYXpXWFRhdldhRGh3OG9JbUpTYTFXcFZwUmYzLy9rcUNWR016U1dHaW8zV3pyVnQzL3dQMHFsOHVDOU9LTEwxMXoydER3c1BZZk9LRGp4MDlJV3pTblptUjBSS09qbzZxSGRyZ1RiTWErR0FPU21tSDU2N0V2QWdBQUFBQUFBQUFBYkhWcFhTclZCUUFBQUFBQTBETTI3OUtsMkJMaWhXV045VEtydndncUFBQUFBQUFBQUFEQWJaTmwzVkN5SmVPU0pDbkNndEl3WEsxTGo3bGF1OTFXbHVkYXJTekxGeCtUTFgyTUNTZGYxbkw2eFZxcnRGUUtKVldhcGtYOXRwdTQzV0pJMUpXc3NXdCtyVEVrcDNZTFlVSGUrMlgxdU9SU3UxaE5uWXB0SEVvTTRCa2NITkJPczVIN1lnd3dXdXUrQ0FBQUFBQUFBQUFBc0czRkU0L0dDd0FBQUFBQW9GY1FZSVFsa3FwWFpTZzBEQzRBREFBQUFBQUFBQUFBdG9CejU4WjA3STFqUzhZTkRRL3A0VWNlMXA2OWUxYTdHTjF4eHlFOTh1akRxbFFxbDhkMU9oMjk5TkxMT25QNjlLcVhjMzU4WEMrOStMSm1wcWVYak8vcjYxTzF0dnFRblJpQ2MvZmRkNFZ5dCs2NTUyNzE5L2RydTRuYjdjMHpieTRaTnpBNG9MMWh1NjBVSm5VdFR6NzVwRDc2dlIvVnplcDB1MXBZYUJRaE9WZXJoVzIyMkpiMjNuQTVTWnFvcjc5UFR6enhQdjNOdi9WVE9uVDRrSGFTamR3WEc0M0dtdmRGQUFBQUFBQUFBQUNBN1NxdCtWQUVBQUFBQUFEUU13Z3d3aEltbFpKd0VNdHN2NHY0QWdBQUFBQUFBQUNBYldqaXdnV2RPM2R1eWJnWWZqTXlNcUxCd2NFaWdNWVljODNIMStxMVl0Nmg0ZUVpUE1mYXQwNmZ4VUNieVlsSnpjM1BhYlhhN2JabVptYVVaZG1TOGZFNWhvZUdpdnBjTDV3blB2L0EwSUFPN04rdmQ3enpVUjA4ZUZCcG1zcFlvKzFtWW1KQzgzUHpTOGJGOVJTRGYycTFxdEpTZXQzSGo0d3V6dnUydHorZ2h4NSt1MjVXdTlYV2JOaG03WFpIM1c1WDNyOTF0ZHJZUHVKejdCb1pMdXF6VWx1SzQrSjIzYmR2bjk3OW5zZDE5ejEzRlczSk83OXNlVWxxRjl2QURWN2JTdWJuNTR1MmRhVnl1Vktzczc3Ky9tdldiN05zNUw0WXc4VFd1aThDQUFBQUFBQUFBQUJzVjBrbEZpOEFBQUFBQUlCZXNmYS9qTVcybGxZWFM3TDZpOW9DQUFBQUFBQUFBQURjTm1kT3Y2bHVOOU5USDM3cThyaUJnWUdpN051L1Q4UER3MFZRVGd4QVdVa01GVHB3OElBT0hUcW8vZnYzTDVrV0E0eU9IejhSSGorcDFacWZYOUQ0MkxqdXV1dXVKZVB2dXZ1SW1xMW1VWjlHbzNITitpU0oxZjU5KzNYa3JqdjFvei8ySStydjcxZTFWdFYyZE9MNFNUWDJOdlhnUXc5ZUhuZkhuWWQxNE1CKy9ZYy8vSXpPbjcrZytlNzhOUjkvK1BCaEhiN2pzTDcvQjc1Zmc0TUR1bGtMQ3d0RmlXRktNY3dvN1gvckZHcTlYdGU3M3ZWT0hYdmptS3JWcWxwaGV0YnRMbmw4RE5xSjIvV1JSeDRKMit6alJiRFM2T2lvbW8zbXN1V2xTUnJtSFZLbHV2WnRPajAxWFlRQVhhbFNLUmR0YS9mdTBXdldiN05zNUw3WTZYVFh2QzhDQUFBQUFBQUFBQUJzVitWQnFkUXZBQUFBQUFDQW5rR0FFVlprUzE1SlZYSnRJMDhnTndBQUFBQUFBQUFBNkZHblQ1L1c5TXlNT3UyT2pERXFsVXVYcHgyNTY0ZysvRDFQNlUvKzVDdTZjUDZDdXQxdU9PK3hlT0lqU1pJaURDYk84L0FqRHhlQk0xZWFtNXZUOVBTMFhuM2xWYzJHNWEvVy9QeTh6cDQ5cTJhenVXemE4TkJ3VVo5WTUyOCsvNEphN2NXd21WaVBXSjlZbHhoQzg3NG4zcXVoNFNHVnkrVWlSQ25XSmM2VHB0dnIxRjVjdDNHN1hTbStSbXVzM3ZhMkIxUVByL21acno1YmJMTzQ3ZEpTcXNIQlFlM2R1emVVUFhyb2tZZDA4T0JCTlJvTFlYcG4yVFpjcTJQSGprbEdldXl4ZDZsU3JSVGpZcHVLMitIQnR6K29ILzc0RCtuazhaTkZpRTdjYnM0NWpZVG5qTk1mZWZUaG9pNHh2Q2dHRjcwNjhlcmw1ZDU5ejkyWHQ1MU5iQkZLRlIrelZyT3pzeXBYVm43Y3BiWis0c1JKVFY2WVdESXR0cUZHcUZOY2grM1E1amJLUnU2TEV4Y3VySGxmQkFBQUFBQUFBQUFBMkc2U3FnL25tMVNjMHdJQUFBQUFBT2dsQkJoaFJiWVVHa2N0WHMwMDNDSEFDQUFBQUFBQUFBQUE5S2pUcDg0b1NaTndUbU9sMEpRN05URFFyMjkvKzl0RitFc01UYmtraHFZTURBem95SkVqZXZ6ZGp4WEJNMWVLUVVRejB6TkZhTXBhek0vTjZkelpjMm8yRzh1bURlOGEwb2MvOHBSZWVQNEZ2Zkg2c1NKWUpnYmh4S0NlY3FWU2hPRDA5ZlhwQjM3dyt5OC9wdDFwRjJGSXNiN2JMOERvdGVKMVhhbDRqZUgvdHozNGdQYnMyYTJ2Zi8wYlJWQlEzSGFsVXFrSXQ0bGhRbkZkeFpDamZmdjM2ZGdieHpTWHpkMXlnTkh4WThmVmFEU0tFSjFMQVViVzJpSTA2TUczdjAySDd6aWtaNS81V3BqdmhKcGh2cmo5N24vZy9pSjg1M3UvNzZORjNhdTFhaEZlRk50TkVVd1Z4dDF4NXgyWHQxMTh2ZjJoM2Qxc2dGR3N6MHFPSExteldPYlhuZzMxS3g5Zk1xM2Q3bWh5WXJKNGJSc2FZTFNCKzJJTWpWcnJ2Z2dBQUFBQUFBQUFBTERkeEw1ZVNUak5aQ3lkdlFBQUFBQUFRRzhod0FnclN2dThxaU5TZDk3SU93RUFBQUFBQUFBQUFQU2tHTWhpT2thLy9jbmZMZ0pqZnZJLy84bkwwd1lIQjR0eFAvdDNmcllJQVhyajlUZUtjSldvM2xmWDNYZmZyZUhoSVEyRlVxMVdseXozdHovNWFjM056V210WXRESzNOeThudi9HODBWSXl6dmYrVTdWNnJWaVdxVmMwYUhEaDlUZjM2K0hIbmxZV2RhVmMxNmxVaXBqYkZHWEdQb1M2M3orL0hsOTZla3ZhOC9lUGRxN2Q2K3FsYXJxOWJxMms0bUpDWjA4Y1ZKZitQd1h0WGZmSGozeXlDT1hwNzM5b2JlSDlaUHB6aU5ISk8rVk82Y2toZ2xWSzBYSVUxL1lmdVd3UHB1TnB2N29QMzVXVTVOVCtzZS8rSTkwSzE1KytkdDYvWTAzOUw0bjNsdUVJUjA4ZFBEeXRManVZMERRQno3d2ZyM252ZStXeTEyb2xpKzJWUnEyWHh6T0x5em81TWxUK3NxZmZLVW83MzczdTdWclpKY2VlL3d4WGRXOGJzcnJvZjJtU2FyVHAwNFhRVVpYMW04azFMZC9vRjk3OXV3SjdhNno1SEZuVHAvUjczejZkNVdrVmpNek05b29HN2t2VGx5WUVBQUFBQUFBQUFBQXdFNlgxbjBvTWNCSUFBQUFBQUFBUFlVQUk2eklocFpoMTM3aFZ3QUFBQUFBQUFBQWdFM2wzT0tWR0U2ZlBsT0VuMXlwVkNvVjVkNzc3cms4N2xKb1Nnd1JldUJ0OTE5enVUSDA1ZEs4YXhFZkU4dlU1TFFtSnlhWFRMT0pMWUp3WWpsdzhNQjFsNVBsdWM2ZVBWZUU1Z3dQRDE5K25kdEpYRThMalliT2o1OHZRb211TkRTMHVDMWprTkMxdEZvdFpkMnNDUFNabXByV3JacWRtVld5a0JRQk8xZHYreVJKaXJKMzM5NXJQajRHVXMzUHordkMrUXVoVG1kMC8vMzNxMXBiaCtTaWl4Ym1GNHBockY5czExZXFWTXBGR1JnWVdQR3hjVnFzLzBiYXlIM3hac0xFQUFBQUFBQUFBQUFBdGh1VEx2YjVBZ0FBQUFBQTZEVWNzc0NLeW9PK1NPT2VQZWFscmhFQUFBQUFBQUFBQUVBdmUvYVpyNmxhclNxZTFianpyaU42OHYxUEZFRkJNUnpsa3ZzZnVPK2FqNStabVZHNzNkYW5QL2xwemM3TzZzVnZ2YVJiOGFXbnY2eG52dnFNdXQydUJvY0c5ZEh2L2VnTkgzUHNqV1BodWVmMDZVOTlXbzFHVTYrKytxcSs1eU1mMXBId2VyYXJHRjcwQjcvL0IzcmtrVWVLRUtQRGR4d3FBcHV1WjN4c1hPUGhjVi82NHBmMCttdXZoL1gwbXZKMUNIaUtnVWpSLy9RLy9rdnRHdG1sbi9vdmZrb0RBLzAzWFA4TEN3djZ3dWUvcURkZVA2WS8vY3FmRmdGRDF4SURxZmJzM2FONlgxMDM2MS8vTC85R2c0T0Qrai8vNXorcFdyMm0vZnYzcTVmMDJyNElBQUFBQUFBQUFBQ3dYVlREYWJUeWtKZloyT3RXQUFBQUFBQUFyQmtCUmxoUlBKQmxTMTRBQUFBQUFBQUFBQUJyRlFOZHBpYW5OSFp1VEpzbEJwNFlJNTBMejFtcFZvdm5IaHdjVXBabFNwTEZVMkxXTGw2MHdibkZjeUNkVGxmZSszQS8xK1RFVktqM3ZNNk5qV2wyWmpaTTYraFd4UHJFRXVzUkEyMm1wcWJDOHllaDJGQlBVOVExUEhYeC9GbldMUjR6RnA5N2RyWjREZkd4elVaVDgzUHp4V1A3K3VyRmE3a2tqbXRkSnlqbjZyckVVSmlWdGtlNzNTbW1yOVg4L01LS3kxc0k0Mk5acmZqNjQydWNqTzBsdlA1YXZWcXNwN2lPb2l1M1daNW5vZVE2Zi81Q01lLzQyUGt3SEMvV1N4eS9VbjBtcHlhTDlyamF1a1FURTVQRjg4WG5hRFFhR2hvZXVseW5TOXZ1VWh0cXQxdkY2NDNQUFJIcUZiZkw1WFd4MENpZU8wNXJYS3hETjJ6cjZXTGJ0WFN6WXYyNjNXeHhmZFZxS3BWS29ZMG5sOXQ1ZEtsTk9lZUs5UnUzY1Z4SDEzUE43Ym13K3UwWjNlNTlNUS9MV0d6enM5ZG84emRlRnl0WnFjM1B6YzBWNnlmV0h3QUFBQUFBQUFBQVlLUFoxTlBmQ3dBQUFBQUE5Q1R6OS83TjkzSFVBc3U0VFBKT092YjdpYklGSXdBQUFBQUFBQUFBZ0szbXlKRTdkZVN1SXhvWkhWR2xVbEc5WHBjSi95MDAzZ3BraVFFa01lRGx1OTk1cFFpRTJTaVB2L3V4SW16bThCMkhsWlpTVlN0VnRWcXRJdFRsOUtuVFJjalIxNS83aG5hNmQ3enpIY1U2aXVzcVRSUDE5L2VIYzFhKzJHWnhXNzM2eW11YW1KalE1TVNrTnNQUTBKRGUrYTUzcUgrZ1h3TURBMFU3aW9GQmNYdkZFSnd2UC8wbnhYQjhmRnkzUTYwZTJ0VGh3enB3WUw4T0hEeHdlZnp4TjQ2cEc5cldYR2piTVlUcHpPa3p1cDE2YVY4RUFBQUFBQUFBZ05zcEJyekhZOTh4bUQ0ZUt3V3VkdUhDUkJINmY2c1gyOEQyZE9oN2M5WDN4aEFqeWREZGE5dDQ0NC9IdEREZTB0eWJUYmxzYVZmUHlsQkoxVkFPUHptcVhmZjJDN2hWclptdTJxRzg4Ymx6V2hoYmVyR2pwR0xWdjYrcXZZOE9hZDg3aGdWc2hzNUNwdVpFUjJNdlRHdjhXelBMcGcvZFdWZmYzb3J1K1lIOTJtaHZmdGtxYXhvMXh2aVFYY2wwYlZUZk9QeEJBUUFBck1qbzZWVEF0WVR2MkVrNG9PWEtYcTdERjI0QUFBQUFBQUFBQUxDMXROb3R6VXhQeTNtdlVwcXFXcXRLWGtWdzBDV05abE90UnFPWWR5UEZjSmI0aCtibGNsbEpxRXU1VkZJNzNIZDVycG1aR2JYYmJTRnVqMFlSVUJSRGJoSnJOVGM3Vi95UmZ0eG1NVFFvaHZGMHUxMXRsaXpQaWpZVXQxV3owVlFwYkw4MFNjTDlkdGgycnRodU1jRG9kb2wxaU90a1pucW02T3h5eWZUc3pNVnB6WjVvVzcyMEx3SUFBQUFBQUFBQUFHdzFKcHdHc3FsWE9IMVc5UGVpbHhjQUFBQUFBT2cxQkJoaFJmWml5NmdNZXlXVm1CZ3FBQUFBQUFBQUFBQ0FMV1hzM0hoUmVzR3JyN3dtM05ocllUM0YvM3JGd3Z5Q3Z2bk5iNmxYeFhDaU02ZlBGS1dYOWRLK0NBQUFBQUFBQUFBQXNOV1VoN3hLZlZKYTg4WEY2Z0VBQUFBQUFIb05BVWE0cnFRVy9yRmVaSE1EQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBd09aS3lvdmhSYklDQUFBQUFBRG9TUnkyd0hWVmRrblZVUUVBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBTmxsYWs4cERrazBGQUFBQUFBRFFremhzZ2V1cURIdTVYQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUNBVFpiMmVWVkdQQUZHQUFBQUFBQ2daM0hZQXRkVnFrbmVDd0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUN3eVpLS1ZPNlRERDBCQVFBQUFBQkFqK0t3QmE0cnFTNm1GOVgyK0NMSXFIWEJDQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUN3Y1pLS1YzbFFxZ3g2cFRVdldRRUFBQUFBQVBRa0FveHdYU1paSENaVnlXVUNBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBR3l3Mks4cjl1a3k2VnQ5dkFBQUFBQUFBSG9SdWN0WWxZRTd2Zm9QZWdFQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQU5sYXBiN0ZQVnh3Q0FBQUFBQUQwTWdLTXNDb205VVZhdDR3QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCdkZTRGE1MktjcjRhTDBBQUFBQUFDZ3R4RmdoRlVaUE9MVmY5akpsclFZWkFRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQVdGOHh2S2drbFljVyszU1YrZ1FBQUFBQUFORFRDRERDcXBuUVdpcEQ0YUJYbmRSdUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFGaHZ0dXlMUGx3SmZiZ0FBQUFBQU1BV1FZQVJWczBtVXQ5Qlg2UjNBd0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQURXVjVJdTl1R3FEaEZnQkFBQUFBQUF0b1pVd0NxWlJLcnU5bkpadkcza1hSakpjVEFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBdUdXeC8xWlNYZXpEVmFyVGNRc0FBQUFBQUd3TkJCaGg5YXhVMitQVmJTNGVESXQ4TGdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFEQUxZcDl0bXhsc1ErWHNRSUFBQUFBQU5nU09JeUJWVE9oMkZRcTkwdURkenFWaDBqeEJnQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFJRDFFUHRzOVIzd1JSK3VTeGVnQndBQUFBQUE2SFVFR0dIMWpJcms3cVFzcFgxaFdCSUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFZQjNFUGx0cHhSZDl1SXdSQUFBQUFBREFscEFLV0tQU2dOZlFmVjR1dDJwT0d2a3NqUFFDQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUt5UnVYaWgrYUg3WEhFUmVnQUFnRjZTdUs0R1cxUHFWYzRrNnFabE9WbDFrN0lBQU1EbUk4QUlhMmFUOEUvNDdtYkxYa2tvV2NaUk1RQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQzRHYkdQVm1UTDVCY0JBSURlazdwYzFXNUR2U3EzSlhsajFMVWxBUUNBMjRNQUk2eVpzZUdnV0NqMTNlRk83alh6bXRSZDROQVlBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBS3pWMEwxZVNVVks2SE1QQUFCNlVLMjdvSWZQUGFkZTFTelZkRzd3VHMxWEJuVWhQU0FBQUxENXJJQ2JaTXRlcFQ2L21PeWRlaGt5akFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCZ1ZlS0Y1bU8vckxRV1N0MExBQUFBQUFCZ0swb0YzS1RxU0N4ZWpmRjRjTXlvTXhNR0hDY0RBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFnQnRLcWw1SlJlcS93NnRVRndBQUFBQUF3SlpFZ0JGdVdXMXZUUGlXcGhhTWZFY0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFnQnVvamtxVlhWNEp2ZndBQUFBQUFNQVdaZ1hjb3ZwZWFlQk9MNXQ2QVFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCdXJEcmlpMzVaaGdBakFBQUFBQUN3aFhGb0E3Y3NyWGw1Si9XSGcyWFpndGY4S1hLeEFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFHQWxsV0d2OGk2djZtNnZVaDhYbFFjQUFBQUFBRnNiU1RPNFpiWWtKWldZK0IwT251MFNBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBT0FhMHJwVTJ5MlYraGI3WlJsNitRRUFBQUFBZ0Mwc0ZiQk9Cbzg0WlMycE0yT1VOYVRtZVNNQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQWdKUlV2ZXI3cFA3RFRnTjMrakJDQUFBQUFBQUFXeDRCUmxnM3RoU09tZVZobUM3ZUJnQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQzg1VkxmSy9wZkFRQUFBQUNBN1lJQUk2d3JXNUgydmpkWGE5SW9hOXBRcEx4bEJBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQTdrYkZTZWNpck91cDE0QU5PQUFBQUFBQUEyNGtWc042TWxKU2x5b2hYcWMvTHBMNDR5QVlBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBTzRsSkZ2dFh4YjVXNVFFQkFBQUFBQUJzTzZtQWRXUmllRkZKc3NOZSs5N3JOZk9hMGN6clJ0MEZMOTh4QWdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUlDZG90UWZTcCswNzcydXVIQThBQUFBQUFEQWRrT0FFVFpHUEpobXBmS1ExSGZJcTNWQjZpNUkyWUtSZHdJQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFDQWJTdXRlNWxFcXUvMzRiYUt2bGJrRndFQUFBQUFnTzJJQUNOc0NCT09waVhwNGdHMjJoNnYyV08yQ0RHYVBSa21FbUFFQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBWUJ1ckRFdHBUUnA1eUNtcEx2YTFBZ0FBQUFBQTJJNDQ3SUVOWmV4aW1GRjluMU4xVjd4dmxXZlMzREVyQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQU5nV1RQZy9rY3BEWHVWQnI0RTd2RXAxcjZRaTJVUUFBQUFBQUFEYkZnRkcyRkF4dkNnZWZJdUo0VkY3Vm5MZEdHQWtBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBTmdXWWorcWVESDRVbDJxN1E1bGoxZXBUd0FBQUFBQUFOc2VBVWJZVkgwSFhURk1xMTU1MDJqK1RhT3NLYlduakFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCZ0s0bWhSZlg5WHVWK3I5b0JYd1FZcFgxZVNWVUFBQUFBQUFBN0FnRkcyRlR4QUZ4aGo5U2Q5MnBOR2JtdUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFHRExpUUZHYVUwcUQwcTFVY21XdlpLeUFBQUFBQUFBZGd3Q2pIQmJwSFVmaWxRWnpwVjNqTEttMUJnMzZzNUo3UmhxbEVtZEdTTUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUE2QVZKYlRHY3FEd2NoaVZwNkY1ZkJCaVZCOEl3VVZGRWx5Z0FBQUFBQUxERHBHN0JDYmhkNHZHNHhNY2Jwa2pUY25FWUR0cTVNQ1hlanZ6RmViMEFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQzJKaXVqYXFXa1VybXFnWUVCQVZlYlBEOHU3NzJzNlkzK1h0NTVPZm1pVGxjenhvUTJiVlYwLzluR2dUM21xbUVhMW9lOU5Bd2pVK1BET2dnbER5Tnora0hoSm9UOXpPZit1dE44eDRsK29GZ1B2aEhlMVZ2WGFHOXhkR3h2YmRvYk5zK2xOdW16YTdUTCtQN1k4WnZTSm4xdUw3NGZrMFFJQUFCd005TDI3ODhLNkFXVmkrV3kwdUlnODBrNDBHbkNNVHkrOUFNQUFBQUFBQUFBQUFBQUFBQUFBQUFBZ0sycFVxM3BYWTgvcUlIaEVUMzArQk1DcnZZLy9NTGZYN3lScUNkTXRacGFhSGZWNm1aeVY0VVkxU3RsamZUWFZESldwY1JxdXlvdTNtN2lwZHA5TVl3aFJXcGVMRUYrWW5HWUNiZzUzWW1PWENkZmJGdFg4VTB2MTgzVitXcEQ3VzhTS0lOYjE4NUNld3JGVGEzUTRNSWJtWnZJbFQzZlV2dDEraDFqYzNSeXAwNzhuakhYWFhGNjBTYkR0TTNvQysreUFYa2Z2OU5zMys4MUFBQUFHeWtWME9QaUFUNWZwSlB6cFI4QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUd4TlZvc2hLRnplR2RkaTVkVlR2Sk5jSGdiNXNnQ2pPTjRVYlRyV2UvdTI2c1Y5ZHJFQUFBQUFBQUJnWlFRWW9lZkZkUEtrT0k1SlNqUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFOaWFTalpYWXJ5c29YOEVWbGEybVhxSmNSMjV2SzA4NnlwM1Z3WDRwRDc4WDFMSkpLSGVoUHNBQUFBQUFBRHNaRllBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJyUklBUkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCWXMxUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQU94QTFqakplSlZ5STJ5c1RFa3g5R0pkQXdDd25SQmdCQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFEWWtheGM4VzlpdkxDeGNoL0Rpd0FBd0haRGdCRUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBWUVjYXRLMWk2SzJ3d2M1M2g0cTRxQzR4QndBQWJDdDhzZ01BQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQWRpUnJ2TEE1VEZqWHhoc0JBSUR0aFJ4SUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFDd1pnUVlBUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQ0FOU1BBQ0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBckJrQlJnQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQVlNMElNQUlBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBR3RHZ0JFQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUZnekFvd0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFNQ2FFV0FFQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQURXakFBakFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFDd1pnUVlBUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQ0FOU1BBQ0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBckJrQlJnQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQVlNMElNQUlBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBR3RHZ0JFQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUZnekFvd0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFNQ2FFV0FFQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQURXakFBakFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFDd1pnUVlBUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQ0FOU1BBQ0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBckJrQlJnQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQVlNMElNQUlBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBR3VXQ2dBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFLdmkvZUxRR1BXMG9wNm0rQi9iQU8wT3ZjSmZkYi9YdC9WVzJYY0E5SzRrdklIRTk1QmF1YVRFYnN5YlNYeXJjcmxUTzgvVnlaelFtNGJybFd0T20yOTFsRGt2WUtjaXdBZ0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBR0NWbkV6UnlUeFZiM2RRemtNOWpmZEtDTzNZRm1oMytEL1krL013T2RMRHZ2UDhaVVRrblZWWmQ2RlFBS3JSRGZUTjdpWmJKSnVYU0lya2tEcHNQNklrZSszeDJGcVB4dDZWOXB4NUh2dVBmWGIzZVR6UDdqeCtkclhQN3V6STYvWDRHVm1XWlhOMGoyNVJwQ2lTb2tpMjJHVGY2QWJRQUFwSEhhZ3o3ek1pSnQ0WHlFSVZxZ0RVWFZtRjd3Y09SV1ZFWnVTYkVXOW1kY0dvTDd0SnVDcGJGT3Z5T1hsWTNqc0F1bGM2NFNudU9ucDJmRUFKejlWZWFQdUJTbzJXcHBjcm1pNVVoZTcwNHNUd1BmZTlNam1uNVdwRHdNT0tnQkVBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQU1BRHRNSmJFWXhtYU1JZE1TV0N0clNESUVZWUJ0RnlyMzJoM2RjT1FqWDlRRnNSeUpFWllqdGF1OUg0MHRFVzB4cWhKM000N2RhOE0yR0VkaERjODVGbXZ2bmgxdWZieXVOdEpDYW1Wc3l4b1poNE5POU00aUhHeER0eTJ0RmNiRWFmTDUwUHNIaG81c3gyNXFSdjUyUndqdzlDc3puWXdaenNmQmJhcUZiMHg0Mis0ck1Rd0hiMFpaSkt4VjE5L095WTh1bWs5a0lRL1RkZnJkWFdZcVdoaFhKTmMrVzZLczIycHBiS2FrV2ZnMFNOdXNQbm5qNTV6MzN2eml3VE1NSkRqWUFSQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFEQUF6UUNWMjNGVkExdWhUdXlnZmtGNWRBa01yUWR0OElkR3dkbHpEYXpyOVgyMVdpMXRSVU5KNm5BaG1ROHhXT0JFbTQweG1pOGhHUU9wOTJhZHkzZnR3R0VNRmovdURENlkrTkY3V0RMODIzbCtESFBqcWpteEpXTTVsM084UlZHNi9nT0lsL29UbzNRVVNYd2JvZldiczNKMkRhdXN4OTlCamFqenpnLzJQaXhaazZhOE5aMjUyUXpsbEFRYyt6Y2pONDlTbnJSSjJOMFRKZlBRZ0JiTk5LVFZuODJxVi80OUhNYTdjMW9MNW1JVWIzbDYzdFhibXB5b2FRL2Z1T0tEUmtSTU9vTy85Vi84djU3N3Z1ak55WjFmYWtzNEdGRndBZ0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBT0FCZ21ocGg3ZmlRaWJhc1ZDcEt6UVJJbjk3Y1kxR3UyM2pIQ1pLY3pmZmhHYWk3Y3ZWdWtyMXByWWkyUk9YSEVlT2QydXN2dDBhMjNab0NRZHJ0K2FkU1dVRlFXakRXZXYyQlNaZTFGYXhGcXJXYkdrN0V1bGNOTTBjdVdrejFwZ2RzeE90RldQZUhUVkJlT3Y2eW1hTFlycFpyTmc1dVZVMm5CWE5QUk5xMjBqVGZrYjZtbG5lM2h4S1p2T1NLL3RaYUFKdTVsbGNNeWY1TEFUUXhSS3VLeWY2MEhwcWJFQ1BEUGJvN0VoZXplaS9DMTg0T2F6SithTCs2TTFKKzkrUFpoc0FkQk1DUmdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBOFEzSTUxbUdoSEVFcVZSc3RHTzFxdHJRV0dOc09HaDZJbk1jK3hWZmwwSU5kemJzVmpvdjhyZ2gySDJuN05PelBmYXMyMmF0cGVrQ3NYejVoK2tUSzZIVnRpM2gxcHQ2NnY3TWRMT1pxVGZudDc4K1orekp6MG8yZHExUnJhamx5eXJYak1WZHkraDR5WWpTWUJRRGR6blZpMHVEclJuN1czejQ3MjJiV0pHcjA5dGFpdnZuUGQzaVpnQktEYkVEQUNBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUE5cEFiVDhoTEpCVlBwdVY2Q2JXYVRUbXVLemRhOFBBS2drQmhHTm9JaFZsbjhnTjJYU3N1cWR2NTBUZ2I3Ylo5RFNZdUFEd3NXbkxsbXlCUTdQRE1lL00rclFkK05QSWdHam52MThQb2NNNjdVRTJibnZHalB3UVdqcHFXcVJiRitCVjFBRmp0V3hlbmJXQm9xMkl4RTF4TEtKZUs2L0dSUGczbVVuYTUyd2NtaG5WbUpHK0RScTllbTlldmZ2dWNiaFpyV3E3dGZrZ1RBTGFEL3pvRUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQTlwRGpPSXBGaTRrV21iV0oxQ2drSW9GYmd0dnp3WXNuRlBpK0RnUFRMREp4Q2o4V3lna0lVK0FoWWdJeU1SMHE1cnRONTNNbUpDUnpPQjNLZVJldXpEMC9aTjRkTllHWmo0ZHNUZ0xBWHBzdVZIUjV2cWl0Y21JeDVUTko5VVhMOFh4V1BhbjRodmZyai9hYnlGRnZPcUZpdlJsOW5kQkN1UzRBNkJZRWpBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFJQTlrRXpuNUhxZWZ2aHYvMk1wRmxNOG5yRGJGeFlXMXQzWGhJMk11SGZuMTMxaTBXUE1Zc0pIenUzOXEvY2w0dkY3UG5jOGtiRDN3ZllFSnNvVGhtcTMyL2U4VDdQVnVoV2p1dXR4WnBzSkVhM2VaN2RGKy96N0JJbysrVFAvaGRyTmhxNis4NW9xaFVWZGVmT3YxYTJxamFaZGdJZE5ybThnK2l4UFJwK3hTUjBXelZaYkM0V0MvT2p6elBmYnd1RnpPT2VkcjFLOXBtYkRMTVFWanBwc2I1OXl2WWRuUGdMQWZ2ampONjdxMzMzN0hlMlVDUm1aV05ILytsUFA2cE9Qait2WjhRRWxQTmZ1aTBkL0wyRDJmZWJKRXpvem5OYy8vNE9YOVlldlR3b0F1Z0VCSXdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUdBUGVJbUVYTmU5SFJLNmYweW9FN3U1TzNwandrVmhFQ2k0Ni83bW1EYXljdzhtdlBPZ2dOSGRVYVNIeFVibmVxUDdkS0pEOTJJalJYZHZ1eDB3Q3JYK1dtNldsMGpLY2ZtMUx3QUFBQUI0MkFUUno0NnQ2T2ZLWXEycDJXSlZaMGZ6OXVmTDVPMklrZUU2TVNVOFI5bEVYTDNwaEwwdkFCdzAvaVlMQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBMkFNRHgwNHEwOXNuTDU1NDhKMXZCMjVhclpZMnE2S2Q4VHh2eXhHamVEeHUxN0VEamgvWklGQzBtRkRUVnVKQW5TalJnK0pFQjhYRWkwNDkrYnptYjB6cTBtdmZGZ0FBQUFEZzRXRmlSR2I1Zi8zWnF6WmE5Q3YvNkxNYTdjM29BeFBESy9mcHl5VHQ4cE1mZUZRVGd6MzYwc3NYZEcycExBQTRTQVNNQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBZ0QzZ3QxdHFONXZxVnRzSitKakFVaXdXMDBHenlhSnRSSWhNdUdncndhUDlac1ptNWszZ3R3VUFBQUFBZURpMS9Wcy82LzdnMnB6eXFlU2FnRkhIeVlHY21tMWZxYmdyQURob0JJd0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQ0FQZEJ1TmRSc1ZOV3RUUHhuT3hFajdLRXdWS3RlVTd0WkZ3QUFBQURnNGRUMEE3djh4dmN1S3VHNStvVWZlZCs2K3p3N1BxakhSL3YxLy8vNlc3cHdzeUFBT0VnRWpBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFJQTlVQzRzcWw0dGEyRnFVbzdqcW5kd1JMR1lJemNldC92RE1CVGdPRTQwTDJJcXpNL0tiN2MwZC8yeUtzVWxIVFEzR3Bmbk9rcTRubnlIMEJWZ2VOSDd3b25wVUlsRkE0NUg3MlUzK3VQSCtMNXpHQjNXZWVmYXVlZEdMOEFWamhZekp3RUErK05tc1dwL05wdGVydGlRMFdBdXRiSXZZZjRiSVI3VGVIOU9wNGQ2ZFhtK0tBQTRLQVNNQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBZ0QxUUxkeUswSmlBa1JkUEtOdmJKOGQxRlU4bUZRUUVZWENMQ1JpWnBieThvRmFqcmhzWDMxSzcxZFJCNjRRbkFpOVVFQjZ5Y2dhd1I5eFlURTYwbUhmRVlVa0JtZEhhOTNJMFlpOUdTT1l3T3B6ejdsWUlML28vY2dnWUhUbnVZU3RxQWNBaGRyTlV0K3ZwUWxXNVpIeE53Q2dlZlk4MWVlUVQvVmt0VmdnWUFUaFlCSXdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUNBUFhUMW5WY1ZUNmJVays5VHVpZXYwZkdUZG5zWTNza1ErTDV2TnF6WlppSkhRV2ZiNnZ2ZWpoOEY1akYzNllTUkNDVHREcys3OTY5ZnVhNnJtQWxLeE5iL0VyOEpWZGx3dzJyUi9leGpibjk5Wi9PdFk3eno4dGVpYTlwV3ZWcFJHQng4b2lLWFNpcVRqTitlbHdJUXFjUVNhc3VSSHpzODhRN3ppKzE5dlJrNTBSdlpaSXh3K0J6S2VlYzZ5cVlUaXFkTVdDRXBIQzNWYUU3V0JBRFlUMTkvOTRaT0RHVDErTEcrZGZ0TzlPVlVhN2IxMVhQWEJRQUhoWUFSQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBc0lkcXBZTDhWbE90UmszSmRGcUpSR0xkZmRydHRnMFZoYXZDUXlaZVpNSkc0VjFoSTkzZXRsRlZKcVEwczJ0TVZNaTVPMEsweWtyQWFJUDdtUERSM1FFamMxODMybjZ2NkZGcGNVN2RKT0daOFRzQ2NFZkRkNlBQMlpqOFEvUlI2MFNmTjBuem1hUlFYb3p2RVlmUm9aeDMwZmZBZU14VjBzdy9oKzhsUjAwcm1wTTFlbWdBc0svbXlqWGxVdkVOOTZVVG5ucFNDUUhBUVNKZ0JBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCd3dFOFBaclB0R2lrenM2QUgzNlFTUkF0L1hWcGpITkZzdGRaTzQ1OTAzTXJRUkd3OHlNYUZOblBQN0hUdDI1NEFDOFBBeG55WHB1S2NnREpSd3Vxc3NFM2RqZkRRZFVkMDk3NXhvZk1TS0hrWm1Ub1p1OTMzb0pCeFhUbXpWZjdNQndDRldxRFZWYVc3ODgvaWpJM2xsa25FQndFRWlZQVFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFjc05nV1NoT3hIVllwZ2lDd01hS3RIc1U4eG8wZTIwMGMxNVc3MVlEUjdmdDdIcjlhQldCckhJVzNZaGoyTXpTMHdaWmJYM1hYWjZNYmk5MytYbkhyc3o1MmU1UTRuQTdMdlBPaWNabHlWbWUrTWUrT0xuTmRuVlhYTnVtNUNydHJPbHFlWTJLVXR6NExIY1dZandBT3RZYnZxKzF2L0RtV2lIN0dOVEU1QURoSWZBb0JBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFEeEhuZHNESGRWMXRWU0taRkFBOHJES09iNU1zTlJQQmlENUtld2V5NmtidDBKRWZyV3RCSUUrQkVqR2lIWWZaWVpsM1FUVEdJQnBpTWJnMTV6Sk9RRERtaUVwRzE5YUp0VmR1cDRkNnRiV2M1UDVvaDdjeVdyWGJBVTQrQ3dFY1p0Y1h5eHJJYlB6emVDWVpWOTd2d3BJY2dJY0tBU01BQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUlBSGlObi9HOHFKdm5EQ2JnNWhoSGFzWHJSMlk4SWhkNWptblJtdG1YY21uQ1hpUlVlV21aUE9xdXZiclI4emgrZTlBd0FBY1BnUk1BSUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBSGdBTjNZcmdKR0x0ZFhOdk52alRMamRQVTVzem1HWmQ0NVpvckgyTXUrT3ZIaDBuZU94N2c4Q0haYjNEZ0FBd0ZGQXdBZ0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCNFNEaXhtQktlbzc1TVVzZnpXV1dTY1NXajJ3UFpWTFIyN1gzQ01GUzk3YXZXYkd1NTJ0QnlyYUdsU2tNTGxicWE3VUI3cVRPKzRaNjBoblBwbGZHTlJMZGR4N0gzQ1lKUURmL08rT2JMTlpYcXJYMFpINEMxQ0JnQkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBRHdrbkpxWGpua1o3MC9yQXhMQU5CZldrRWpvN2tyZHJJd2hERldwTkxaVHJtbHdvNnRKOFVaZWp4VVNDOWo1Z2RHdDhKL3R6ZXZyNHdNcjRubzIrVHR3T0xMWDhRT1ZHYTJWOGIwOHZhYnBRMlpmeEFWaUxnQkVBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBRHdFUGpDczZkMHJEZWpseDQ3cHQ1MFFpZjZja3JGUFhsdVREM0p4RW9nS0l6K3RIeGZqWGFnY24zWXhvSks5YVpldjc2b1lxMnBQM3o5c2lyUnRtdExGZTJXWlBUY24zNXlmR1Y4Smx3MG5FdXZqSzh2blpUck9CdU83elBWaG1xdDlzcjRmdXVWQy9LRGNGZkhCMkJqQkl3QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUNBaDhEN3hnZDFjaUNuTDM3Z01TVmNSOWxrZkV1UEg4dm50Rnh0Nk5WcmM1b3RWbmMzWUJSMzE0d3ZGZDFPeDdlV1J1bU03MnZ2WGxlejdSTXdBdllCQVNNQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUNnQ3oxemZFQVRnejBiN252aityeXVMcGExR2YvSHo3Mmd3VnhLLy9nVFQ5dmIrWFJDc2R2N3FzMjJXbjZnU3pjTHFyWjh1ODJKeGRTVDh0U1hUdXJFUUc3bE9NK2ZIRlE3dXUvSmdSL1dkS0dpLzhPWHZxbFN2YVhKaFpKMndvenZrZWgxL3QwUG5iM24rTTdQTHF2WkR1dzJ6NGtwbTd6MytIN2xIMzNXQnBiTStFelE2RG9oSTJEUEVEQUNBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQXVsRFNjNVZ3M1EzM21haFB2ZFhXWnBoNDBXQTJwZjVvdVZzWS9RbkNVTTFWeHpNQm82VG55QS9DTmZmMUhNY3VvNzBaKzVpRUdaL25hNmZNK0FZZU1ENHp0dFVCbzdoNy8vRVpabnh1ZEJ2QTNpRmdCQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFIU2hSNGZ6R3N0bk50dzNYYWpvOG56eHZvLy8wV2RQNmRueFFmMlRUenl0dnJ2aVFCZG1sL1gxODFQNnpWY3U2dnVUY3lyVm0ycmZGUVF5ei8zMDhRSDkxSXVQNmFkZlBLT2VaRnllNnlpZlRpaWI4UFNsZi94NXZUSjVVei8vNzcrdVdxdXRlbXRyTWFPLzg4RXpPalhRcytINHpKaStmM1Z1Wlh5Rld0T0dqRFlhMy8vcVU4L3FrNCtQcjR5dlA1TzBYNXZ4L2VIcmwvWFBmLzk3MnhvZmdBY2pFUVlBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQjBvYUdlbFBMcDVJYjdTbzJXbGlxTit6N2VoSVpPRHVTVWlIc3IyMHdFeUlSOFRCRG8wbnhCaStXNlduNmd1OXBBVnRzUDdYUE1GcXU2dWxoYUZ3Qkt4VjBiQ2pJaG9WeTAzcXFSbnN3OXh6ZFhxcTBkbis0enZzSzl4NWRMSnJZOVBnQVA1Z2tBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQkExL25rNCtQeW5OaUcreTdNTE92N1YrZnUrL2lQbmhuVC8rSkRqOXVRVDBlekhXaTZVTkYzTGszcjMzempiVldhTGJ0dEkzUGxtbDNNNDZ1TnRuN3VFMDhybDhyYmZaN3JhQ3lmVmIzWjFvOC85NGkrZFhGYTgrVVpiY1dQUEhWQ0g0dkd1Tkg0dm43K2h2N05OemMzdnRIWDA1cGNLRzA0dnZlZEdOcjIrQUE4R0FFakFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBb0l0TURQWW80YnJSNHNpNUsyQTBWNnJacUUrMTFWYWo3Vy80K0w1MFV2bE1YTDNwaEQzRzZpT1l4MTVaS0dxbVVMT1BENEpRRDdKUXFldkM3UEtHSWFGTU1xNkpnUjY5bFY3VVpuWEdsMDE0OXh5ZmVjN05qbStxVUZYU2N6Y2NYemJwYlhsOEFEYVBnQkVBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBRFFSVjU2N0poNmtuRmxvK1Z1VnhaS21veVdtV0pWMVdaN3c4Y2Y3OC9vNmJFQm5lalByVHRHcGRIUzk2N002YjI1d2owZmZ6ZnpmRGVMTlJzVnVsc200ZW1EcDBmMTZ2VjViVlpuZktQNXpEM0haNTV6cytNemNhV3IwZjAzR3Q5d0xyM2w4UUhZUEFKR0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBUUJjWXpDYlZrNHJyUDNuNnBBYXlxUTN2WThJKzMzNXZSdVY2NjU3SHlhZVRObDdVczBFQXFkN3k5ZmJVZ3FZS0ZXMVcydzlWQ1ZxYWlSNXpiYkdrNDMwNXVVN003a3Q0WHZSY1dSc0tNakdqWnR0WE93anZlN3hjTXFGSEJudVVjTjExKzh6ck9qKzdwSnVsbWpiTFBLY2ZCSFo4MDhzVmpmVmw3enhYZEQ3TitJYWk4YVdqOGJVMk1UNEFtK2NJQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUF3SUhMcFJJYXlLWDFvZE9qK3RpWnNRM3ZNN2xRMUZ0VEN5cmRKMkJrUWtJanZSa2x2UFdCb0hxcnJlbENWVXVWcGphckhRUnErb0VXS3czTmxlbzJGdFNSOUJ6N1hDYThsSXllejdrZE5yb2ZjMS96T2hPZXMrRnpYVnNzM3pmUXRQNHhvUnJ0VytNenIyMDFNeVl6dnQ3b09WT2JIQitBemZNRUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBWU4rNXNaalNDVStQRFBab1lyQlhuMzNtaE40M1BxalRRNzF5WW10RE85Y1dTL3JXeFJuOStUczM5TXJrbk1yMWV3ZUlCcklwblIzSnF5K1RYTGZQaEg2bWxpdGFxamEwVmRlWHl1cEpKWFIydEc5ZEhHa2dGejNuc2J5dXpKVjBzMVM3NzNFNjQ4c2s0cnJYK083MytoNDB2ZzlNREs5L3ppMk1EOERtRVRBQ0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBRG9CcEZNVmRSNzNwaE1iNk1ucnFXTCtlT3pGa3Q5MGRNQ3JVbXJxMlZOWjh1YWJsQjhTSGtwNXJRejd1WGNjd2dqQlV2ZVdyN1FmYXFscjB1SEtqZGUvblRFYlA2Y1FlZUp6TmpLOFZoTnFxM1JvZmdNMGpZQVFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQnN3ei81NURQNnpGTW50RjM5bWFTZUhSK3d3YUs0NXlybGVVb24zRFh4b3VubHFyNXg0WWErZTJsV3YvcWRkMjNjNTBHR2UxSjZKanB1YnlxeGJsKzk2ZXZhWWtuYjZBTnB0bENKeHVqSzk4MFk0dXVmOC9pQXBwYkxtaTVVdFpueHBaT3U5bUo4OTN6T1RZNFB3T1lSTUFJQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUMySVo5T2FtS3dWOXZWazR6cjVFRFB1dTFCZUt2ZVU2dzJ0RmlwNjhwQ1NUT0ZxcGFqMjVzUmQxMmw0NTQ4MTlsd2YzczdkYUNJSDQyckhRUWI3dk1jUjBuUGxSdHpIbmljbGZIRnVuTjhBRGFQZ0JFQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUN3RFU4YzY5TVQybjJsZXN0R2pQNGZmL29EWFYwczZYLzg2NHRiZXJ3SjllVFRDWFdyYmg4ZmdNMGpZQVFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQWNBQk1wYXJZRE5kcCt0UFpWYTdWVmIvbTZ2bFN4dDAyODZHYXhwdDNTRGdMNVlhQnUxZTNqQTdBZUFTTUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFEZ0FKaDQwWFNob3FubFNyU3U2dTJwQmJ2K2t6Y21WV20ydFZSdGFEZVY2aTFWbytOMkl4Tno2dWJ4QWRnWUFTTUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCZ0cvNm5WeS9wdFdzTDJxNjJINmpjYUtsa2xucFQ4NldhamZnVW9xOWIwYjZ0Y21NeHhUMUhjZGZaY1AvMGNrVUw1YnEycXh5TnpVU1ZmRzNQL2NibkIrR3VqUS9BL2lGZ0JBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUd6RDc3MTZSZi91Misrb1c3aE9UT200Snk5YWIyUzZVTlZpWlFlQm9HWkx5OVdHZ2lEVWR0eHZmTzBnMkxYeEFkZy9CSXdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQ0FJNkFuRmRmSndaenltYVQyUXEzcHE5Sm9hWHY1b3YwYkg0RDk0d2dBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBREFvWmZ3WEExbTA4b2tQTzJGdGgrb0dTMWh1TDJFMFg2TkQ4RCtJV0FFQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFZRWVHZTlKNlpueFErVXhTM2FqYnh3Y2NWZ1NNQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBT3lJNXpoS2VxNWNKNlp1MU8zakF3NHJBa1lBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFkaVFWOTlTZlNkcElVRGZxOXZFQmg1VW5BQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBTmlCV0N4bWw4N1hxOWNiY1p3Ny83dnNZUmphNVY0NisxYXY3M2QvQUFBQUFBQUFBUHVIZ0JFQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFDQWJmTTh6d2FKek5wRWk4elhadTI2N3BxdzBXcUpSR0xsNnlBSTFHNjMxOTNIYkRmTXZrNjB5R3p6ZmQ5dTYrd0hBQUFBQUFBQWNIQUlHQUVBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUM0THhNbDZpeWQyMFluV0dRV0V5enFiT3RzNzl5K245WDN2WHQ3aDRrWGRkWW1YR1JpU1oyb2tXR2lScDNibmZzQUFBQUFBSUQ5NVVjL2t6ZmF2b0xiUDY5M20yNGZIM0JZRVRBQ0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQXNLRk9qQ2dlajl2SVVES1p0TGROckdoMXRHaW56MkdDUlBkaW52dGUydTIyRFJZMW0wMjdiclZhTmw3VTJSN3lDNGtBQUFBQUFPeWJWdHRYdGRsV3krL09zSEMzanc4NHJBZ1lBUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBTEFoSVJNbDZpd21UbVRpUVoySVVXZTdZZFptMjBIcmpDZVJTTmgxSjNaa0lrYSs3OXVsRXpQcXJBRUFBQUFBd041WXJqVjBaYjZvY3IybGJ0VHQ0d01PS3dKR0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFGWkNSWjduclN3bUROU0pCSFdqMVVHbHU1bGdrVm5NYXpKQkkvTTFBQUFBQUFEWU83Vm1XNHVWdXBwdFg5Mm8yOGNISEZZRWpBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFJQ0hVQ2Y2azhsazdOckVpa3pzeDJ6dnhJek1jbGk1cm10Zml3a3hHZWwwV21FWXF0Rm8yS0JSczltMHQ4MENBQUFBQU1CUlVXcTBkSDUyV1F2bHV2YkNZQzZwa2Q2TVBIZDd3ZVA5R2grQS9VUEFDQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBSGhJbVVDUkNmeVl0UWtZZGJZZEJaMEFVeWZVWklKR0psYmsrNzVkekQ3aVJRQUFBQUNBbzZiWjhsV3V0OVJzKzlvTGllam42M1I4KzdtU2JoOGZnSzNqSFFjQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBOEJEb3huMVFxcFhnOGJvTkZKdXJ6c09nRWpiTFpyTDNkMjl1clZxdWxkcnV0V3ExbTF5WnNCQUFBQUFEQVlkYjBBeldyRGRWYUcvK00rNW1uVHNpN0hmdmRqbHdxcnY1TVV0djlHNFg3amMrRWgzWnJmQUQyRHdFakFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQTRBanJoSHM2QVNPem1LOXg1OXlZa0ZNUUJBckQwRzQzWHdNQUFBQUFBQUI0TUFKR0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQXdCRmxZa1VtenBQTlp1VjVudUx4dUhDSE9TZG1TYVZTOW5hajBiRHhvbUt4YUc4VE1nSUFBQUFBQUFEdWo0QVJBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFjTVNZYUZFc0ZsTWlrVmlKR0prMTdxOXoza3pRS0F4RE5adE51eVprQkFBQUFBQUFBR3lNZ0JFQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCd3hKaHdrWW54NUhJNWU5dEVlZkJnbm5mcjE2M2k4YmlORmxVcUZiVmFMUnN5QWdBQUFBQUFBTEFlMlhRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFEZ2tET0JJck1razBtbDAybWxVaW43TmJadjlmazBpNGthRVlJQ0FBQUFBQndXeTlXR0xzMFZWYXEzMXUxTGVvN0c4aG5sMHdsdDFXQTJIVDAySzlkZG55d3h6elZkcUtqV2FqL3dPSjN4YlhUZnp2aHlxYmkycWpPK2pXeGxmQUEyajRBUkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQWNBUTRqbVBEUlpsTXhvWjNFb25FU3RnSVcyUE9tVG1mNWp4MnpxazVuMlliQUFBQUFBQ0h3Vksxb2N2elJaWHJ6WFg3RWlZUTFKZFZYMmJyOGVQQm5wUjlyQk5iL3pOeXVXRUNRVlZWbXc4T0JIWEdWMi82dXRmNGVwTGJDQmpkSHQ5R3RqSStBSnZIMzVnQkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQWg1UUo2cGl3VGphYlZUNmZ0OEVkei9PSUZ1MGljeTdOT1RVUkkzT08wK24wU2h3S0FBQUFBSUJ1VmFvM05WMm9xTnBZSCt0SmVLN0c4aG4xYnlOZ2RMSS9xOGRIbzcrRGlMc2JQdWZVY2tXVnhvTURRWjN4TlgzL251UExwYlllTU9xTTcxN1B1ZG54QWRnOFR3QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQU9KUlBSY1YzWEJuWk1WS2V6RGJ2SG5NL09ZczUxczltMDIxdXRsZ0FBQUFBQTZGYnRJRlM5NVN0UXVHNmZFLzJNbTQ1NzhseEhXNVdPeDlXVFNtejhuUDd0NXd6REJ4NW5aWHpCdmNjWFA4RHhBZGc4QWtZQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFEQUllTTRqbks1bkEzcW1IQlJKMXJVYmZHaUlBamsrNzRxbGNwSytPZEJlbnQ3bFVxbDFHM011UTNEMEo1M3N6YlJLUFBhcXRXcUFBQUFBQURvTmplTFZiMXhZMTdQblJ4Y3Q2OC9rOUxIem93cDRibjYzcFdibXpwZWJ6cGhsNU1ET2J0NHpwMi9nekJSb0xsU1ZkY1dTM1lKTnRFSDZvenYwMCtPMzNOOHBVWkxiMDh0YVRNR3NpbGxrdDdLK0Zhck5GdGFMTmUzTkQ0QW0wZkFDQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBRGlFVE1Tb3MzUXpFL3ZwaEl3Mnc5eTNXNjBPUlpuemJsNGJBQUFBQUFEZHlBOUNOZHZtNS9HTmYzWk54VDE1Vy9nN0JTZjZXVGdlM2QrN3ZkeXRIVDFmWjluUytJSzlIMSt3YW14dDZrWEFyaU5nQkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJ3Q0pwcGpsdjcrZnJ1T3grTTZTTlZxVmJWYVRjdkx5M2E5dExSazQwTUxDd3RxdFZvcUZVdmFEUU9EQS9JOFQvbDhYc2xrVXJsY3puNmR5V1RVMjl0N1lPZkJQTDhKR0pubmI3ZmJxbFFxOWpaUkl3QUFBQUJBTjNoN2VsR1g1NHY2b1VkRzlPUll2L0xwaEkzOEdFTzlLZjNVaTQvSjNQejkxeTZyMG16Wm1ORDlQQjBkNDJObnhqVGNrMXEzYjNxNXJQLyttMi9ybGNtYjJ1cjQvdFlMajBiSFRHODR2cW5saXY3cTR2U214dmZCUjRiMTdQamdodU03UDF2UWI3MXljVXZqQTdCNUJJd0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQ0FROEJFZkRvUm85anRYK2piTHliUVk4STh0V3BOUVJpbzJXaXFWcS9aY0ZHNVhMYTNUZERJQkl4TXZNajNmZTBXYzd3d0NPM3h6VGdDUDdEUFk0SkJqWHJEbnBkVTZ0WXZKNll6YVh0dXpMYjk0amlPWE5lMXoybGU5MjYrZGdBQUFBQUF0aXVJZnBadVJUOURMMWVidXJwWTB0bVJQbVVTdDM1ZWRxTEZjMkxLcHhKNjdzU2czVDlkcU5wSVVIQlhtRGNaZHpYU2s5YkVZSTlPRC9VcUhWLzdNM2M3K2htOTJteHJlcm1xVXIybHplcU03MmF4ZXMveGplV3pXeGhmN3ozSFYydTJ0ancrQUp0SHdBZ0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBRG9ZcDFnVVNhVFVUd2V0OHQrSzVWS2FqUWF1bkw1aXVyMXVtWm1adFJzTnUyeTU4OWRMTm4xMHRMU3VuM3BkTnJHZ3g1NTVCRjVjVStuVDU5V01wbFVMcGZUZmpEWEpaRkkyS0NTQ1JpWm9KTlpUT3dwdk9zWEtnRUFBQUFBMkU5TlA3REwxOSs5cm9WeVRmLzA4KzlmQ1FTNWpxT2VWRUtmZnZLRUhoM082Ly8zRjIvbzYrZW5ORjJvcU41YUcrWTlHKzMvMGZkTjZETlBuWWlXazJ2Mm1aaVFpUUpkVzZyb0Q5KzRvbHFycmMzcWpPL0xiMS9WT3pOTEc0N3ZKNTZiMElzVHd5dmp1N1pZaXA1VEc0N3ZwMTk4VEIrWUdObHdmTy9PTG05NWZBQTJqNEFSQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBME1WTXNNaEVlc3hpZ2puN3dVU0tUTERJaEl0ODM5ZnkwckthcmFhTkNKbmJyVmJMUm5zT1dydmR0dU13NDNJY3h5N0pSRks1bnB4U3FaUmRlbnA2N1BhOTFJbE1tWWlSQ1NpWnNKTTVUd0FBQUFBQUhMU3JpMldaNXMrN3N3VU5aT3M2TzlxM3NpL2h1ZEcybEQ1KzluaTBUdXU5dVlLcXpaYmQ1NWlZY2lLdTAwTTkrc0NwWVkzbHMydU8yNHgrN2pWeG9LK2V1NjVMMGVNYWJWOStzUFdZNzRWb1hJVmEwNDd2V0c5TEU5SHpkYVFUM3ByeHZUdXphS05IaHVjNlNrVS9oM2ZHMTVkSnJUbXVHVSs1Y1d0OHIxNmIzL2I0QUR3WUFTTUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQ2dDM1dpT0NhSVl4WVRNTnJyRUU5SHBWTFJ3c0tDTGwrK2JMODJBYU51Q0JiZHpZU1VqQnMzYnRqMXRXdlg3TG5LNXJJYUdSbXhpd2xBWlRJWjdhVk92TWlzemZNWkpnRFZqZWNNQUFBQUFQQndlV3RxMFM0bUFqU1lUYTBKR1BXazRuWjVaT2hKZS91VnlUa3RWeHYyYXkvNk80aFRnem5sb3YzRHVmUzY0OWFhdnVaS05mM2lsMytnVXIycGFyT3Q3ZmorMVRtN051T2JHT2haRXpEcXl5VHQwaG5mdHk3T3FONjY5VHlwdUtmamZabDdqcytNcHpPK2hYSjkyK01EOEdBRWpBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFJQXUwd25obUJoUElwR3c4U0t6YmEvNHZxKzV1VG1WeTJVdHpDK29YQ21yV3FuYWVKR0pCSVZocU1QQ2pMZFNybWk2UGEybHhTWE56TXdvbVVqcXhNa1Q5cHlhcU5GZU1ZR3BUblRLQkkzTStUUG43akNkUHdBQUFBREEwZlRyMzd1b1RNSlRYenFoa2Q2MFhwd1lrZWM2U25ydXluMU9EL2VxM3ZUdDE5RXVlLys0dXphbWZHbXVhQ05Ddi9QcUpjMFVxcm95WDVLL0N3RmZNNzVqdlJsNVRteGxmT2E1RTZ2RzkvaElYcTBnM05UNC9zUEw1MVdvTmUzNG1yNHZBSHVIZ0JFQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFEUVpVd0V4MFNMVEFqSHJFMFlaeThGUWFCaXNhaUZoUVZOWHBsVXM5bTB5MkZrWGt1ajBiQkxvVkN3cjh1Y3cydzJxMnd1cTcxa3Jsc25QbVVDUnJWYXpZNkhnQkVBQUFBQTRLQzlmbTNlcmo5eFprd25CM0o2MzRraGUzdDF3R2dnazVReTl6L09VcldoNVdqNTV2a3B6UmFyV3F6VXRWdmp1NUpPNlBrVGd5dmpjNXkxTWVmaDN2UURqOU1aMzUrOWZVM050cjlyNHdOd2J3U01BQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFnQzVpWWp1NVhNNnV6V0tDT0h2QnhIM2E3YmJlZXVzdHUxNllYMWdKRndWaG9LUENoSXpNT1R4MzdweU5DbDI3ZHMzR2pCNTU1QkdsMDJsbE1obnR0azV3eWp5UGlSZVppQklBQUFBQTRQQTVQN3NzejNYMDkvNzdMOS96UHE5Zlg5Qmg4cVdYTDlob2tWbVA5bWIwN0lrQjVWTkpaUkozRWlUSCs3TFIzdzFJTTRYS3lyYkpoWkt1Uk12a1FsSFZabHVYNW9yeWQvbnZEeG90ZjgzNEhoM3UxZWxvMldoOGpiYXZoZktkT05HRm13Vk5MVmYyYkh5ZitjWGZ2ZWUrd3pZSGdOMUd3QWdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQURvSWlaK0U0L0hiWFNuRThMWkN5WmFaR0pGOC9QekN2ekFCbzJPb2lDNDljdUs1dldaOHhsR2Y4enJQbjc4dUJLSmhQWkM1N3FaNjJnQ1JnQUFBQUNBdzZuY2FObjFOODVQNmFpNHRsUzI2NHR6QlUwTTV1UTZNUTNsMHVwSnhWZnVZLzVPb2gzOVhjSFZ4ZExLdHJlbkZ2WDI5SkttQ3hYVlc3NzJnb2tTclI3ZmNxMWhuMnVqOGRXYWJUdVdqaDljbmJPUnBiMGEzMUdhQThCdUkyQUVBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFkSW0rdnI2VmdORmVlZS9pZTVxYm05UGx5NWRWcVZUME1ERXhvOFdGUmJ0Y3VYeEZJeU1qZG5uc3NjYzBQREtzM2RhNWp1YTZtbUJVdVZ3V0FBQUFBQURkWW5LaGJKZHU5ZmJVa2wwQWREY0NSZ0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBTUFCaThWaWE5YTdLUXhEdTVpQWpsbnE5YnBhclpZZytiNXZ6NFU1SjlWcVZhbFV5bTQzRWFuZFpLNXJaekhNOVFBQUFBQUFBQUNPQWdKR0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQXdBRXo0UndUemVrRWRIYVRpZlRVYWpXOTk5NTd1blRwa2lybGlocU5oaUF0TEN6WTVmcjE2MHFta25yeHhSYzFNRENnbnA0ZTdTWnpYVHNCS2JNUWtBSUFBQUFBQU1CUlFjQUlBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFPQ0N4V015dTQvRzREUmp0cGpBTWJhaW9VcWxvZW5wYWl3dUxhdFFiTm1pRXRWcnRsbFNYcHFhbVZDcVZkT2JNR1h0dGtzbWtkb3U1dnVZNkd5WmlaSzRQQUFBQUFBQUFjTmdSTUFJQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBT2lJbmFtQ1dkVHU5NndDZ0lBaHN2V2xoWTBQZGYrYjRORnhFdjJsaXowYlRMdSsrOGE2L0QyTmlZWGU5bXdNZ0VrVEtaak9yMXVnMFlFVEVDQUFBQUFBREFVVURBQ0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQURnZ251Y3BIbzlydHkwdExhblJhT2ppeFl1cVZXczJYQlNFZ1hCL0p2cGtva0xuejUrMzErWDA2ZE0yWXBUTDViUlRKbUJranUyNnJqMm0rZHBFakFBQUFBQUFBSUREaklBUkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQWNFQk1KQ2VWU3RtNHpXNHlBYU55dWF4M3pyMGpiSjRKR0JrWHpsK3drYUhlM2w2NzdFYkF5RERYMlVTcnpMclZhaEV3QWdBQUFBQUF3S0ZId0FnQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFEWVp5WmlZK0pGaVVSQ3J1dnVXc0JvYm01TzlYcGRiNzM1bHNxVnNyQTlyWFpMWVJqcXRWZGYwL0R3c0kwTm1aQlJQcC9YVHBscmJhNjVDU1E1anFOR283RVNUZ0lBQUFBQUFBQU9Hd0pHQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBd0Q0ejRSb1RNVEloRy9QMWJqSHhvbHF0cGtLaFlML0c5b1JCcUZiUXN1Y3hsVXJaYzVySlpMUWJUTUNvRXpFeWthUm1zeWtBQUFBQUFBRGdzQ0pnQkFBQUFBQUFBQUFBQUFBQUFBQUFBQUJkWW5UOGxMeDRRdS83NE1laWRWekhUa3pJY1QwbGtpbDdPNTVJcUxpMEtML2RVcTFXVmF0UjEreU5xMXBlbU5PN3IzOWY3VmJUTGdCMmozbmY5ZVQ3bFVpbGxldkpyOXQvOGUzWEJHeEZMT2JZWUZFeW1iUkJIQk95MlEzbGNsblZhbFd2dmZhYWxwZVdpUmZ0b29XRkJiMzgzWmQxOXZHejl0cjE5UFRZK05ST21UbVFpRDVqVE1ESWhJd0FBQUFBQUFDQXc0aUFFUUFBQUFBQUFBQUFBQUFBQUFBQUFBQWNFQk5CY0Z4WDhVVFNMb09qeHhXUHh6VTBPbWFEUmVhMjY3bEtKRkx5RWdrYk4wcW1NbW8xRzZyVkttcEg2M2E3WmNNcWN6TlRxbGZLcWxWTDBmNFdJU05nbDdoZVhPbHNUcm5ldlBvR1I5ZnRKMkNFclRLOUlqZjY3TGZmQTZKbHA0SWdzR3NUd1RFUkk3TW1YclM3MnUyMlhVd2d5cHhqRTU3YWpldG40bFZtTWZPaGN4MEJBQUFBQUFDQXc0YUFFUUFBQUFBQUFBQUFBQUFBQUFBQUFBQWNrSjYrQWZVTkR1dkZUM3hXajV4OVNtZWVlZDZHak81bmNPVFl1bTJCNytzbi91NC8wb1czWHRYRnQxN1RHeS8vcFc1Y2VVOEFkaTZUemVsOUgvcTRUcDE5VWgvOHhPZlc3Zi91MS81WXdGYVlXRTF2YjY5ZDd3WVRMS3BVS2pwLy9yd3VuTCtnVnFzbDdJMHJsNi9vMnRWcmV1a2pMMmx3Y0ZEOS9mMjdFcUV5UWFRd0RBVUFBQUFBQUFBY1JnU01BQUFBQUFBQUFBQUFBQUFBQUFBQUFHQ2ZlZkc0c2oxOUdqMXhTc2ZHVDJuNDJMZ3l1UjNFTEdLU0V6MDIxNXZYVUhTc1k2ZE95NG01bXI4NXBVYTlaZ05IT0J5R3gwNG9sY3FzMmRabzFLTHJXRmVqVmxHOVZoVWVYaHZOajdiZlVyVmNabjRjRWw0OEljK0xLeGFMYVRjRVFXQ0RSY3ZMeTZyVmF2WTI5bzZKREpselhDcVY3UGZzWEM2bmVQUTlmYWNSbzg1OFNLV3pkbDJQM3M4QUFBQUFBQURBWVVIQUNBQUFBQUFBQUFBQUFBQUFBQUFBQUFEMm1Za1hQZi9TSi9UY2h6K2g1Nk5scHh6SHRkR0R4NTU2M2k1bm4zbEJoY1Y1L2RwLzl5OVVLaXlwV2k0S2g4UGYrcy8raVhyN0I5ZHNtNXE4cEttcmwvVHU2NitvZm4xU2VIaDk2aWQrV2ljZmZYek50dEx5a3Q1OTR4Vk5YamhuRjNRdkU3ekpEd3dxbDgvYjZNMU9tWmhPdTkzVzNOeWNYbnZ0TmRXcU5Yc2JlOGZFaTh4eThlSkZldzBIQndkdHZHaW5BU1BQdS9VclhpWkEyRzQxZGYzU2VRRUFBQUFBQUFDSEJRRWpBQUFBQUFBQUFBQUFBQUFBQVFBQUFNRCtjRDFQbzhkUGFXaHMzTWFMam8yZldyUGZSQXRNa09MQ1c2L0s5MzB0M1p4UnMxRlh0VkpldVkvbnhSVnpISTFHajAybU0zcms3Rk0yaXBIS1pGZnUwOVBYcjNnaXFjZWZlOUhHaTE3NTVsZUV3NkYvWkZUOWc2TnJ0cGtJVlh3bXNlTkFCZzYvL01DUWhvNk5yOW5tUnA4SjhVUTBQNkxQQVhRM3gvVTBPREttZERhbjNXQytUMXk3ZHMwR2pFeThxTlZ1Q2Z1ajJXaEczN1BidWpsN1U5bHNWdU1ueHJVYkhubmlXZFdyRlFKR0FBQUFBQUFBT0ZRSUdBRUFBQUFBQUFBQUFBQUFBQUFBQUFEQVBuRmRUOGNuSHRYeFU0L3ErUTkvWXQzK1ZyTmhBMGJuZnZDeS9mcmlXNitwWEZqV3dzM3BsZnVZYUpFNXp2cys5SEgxRFF4cFpPeUVqWmVzQ1JqbCsrM3k1SE1mVUwxV0pXQjBpQXdNajJsb2RHek50cm1aNnpaSVJjQUlmWVBER2g2N0s1UVNrNTBmTGdHanJtY2lVNFBSKzl1TEo3UWIydTIycmwrL3JrS2hvRnF0SnV5ZlJxTmgxN096czhybGNyc1lNSHBmOUgxL0tmcnE5d1VBQUFBQUFBQWNGZ1NNQUFBQUFBQUFBQUFBQUFBQUFBQUFBR0FmeEpNcFpYdjc5SkhQL1lUU3EySkRScm00ckhxMXFxLytUMSt5d2FITDc3d2gzL2RWV2w2UzMyNnR1YThKRzdWakxWMTY2MVVsbytNVUZoZlVQenlpWno3d1lRMk9IdGZRc2VNcjkzMzBxZWZzNDArZmZWclZTbG16VTFjRkFOaC9ROGZHbGVzYlVMWW5yMWhzNXpHeStmbDUxZXQxemN6TXFOMXFDd2RqZW5wYTJXeFdweDg5clhnOGJyL2VpY0hvZTNneWs3SHpwZG1vcTdpMElBQUFBQUFBQUtEYkVUQUNBQUFBQUFBQUFBQUFBQUFBQUFBQWdIM2d1bkZsc2ptZGVmbzVPYTY3WnArSkYxVktCYjM1MTk5V2NYbEIxWEx4bnNjSmZELzZ2NzdtWnFkc0JHTnhidGFHRG9aR3g1VEtaTmNFakRwZm15QkNZbm1KZ0JFQUhKQmN2bCs1bmo2bDBobnRoa3E1b2xxdHBsS3hKQnljWXJHb1ZxdGxyNFVKRCs0MFlHVG1TV2RkcjFZSUdBRUFBQUFBQU9CUUlHQUVBQUFBQUFBQUFBQUFBQUFBQUFBQUFQdmcrWmMrcHNHUjQwcG5jK3YyZmZzcnY2ODN2L2R0emM5ZWs5LzJOM3RJaFdHZ1dxV2thKys5bzkvKzVYK3BqMzN1eCtWNWNmVVBqeXFUNjFtNTN4ZCs1aC9xMHJ0djZ0MDNYaEVBWVArOTlObS9LVGNlMTA2WldJN3gvZTkvWDBFUUNBZXYzcWpyTzkvNWpvYUhodlhobHo0c3gzSGszaFVxM0lwa09xUDNmL3d6dW5uanFtYXVYUllBQUFBQUFBRFE3UWdZQVFBQUFBQUFBQUFBQUFBQUFBQUFBTUErU0tXelNtVXlpc1djZGZzYTlicEtoU1VGUWFnd0RMVVZuZnRYU3N1cTE2cHF0MXZSY2RaR2tESTl2V3VDUmdDQS9aWEtaT1h0UXNESU1KLzdqVVpqeTk4dnNIY2E5WWJxMGZmeTNib21KbUtVVEtjRkFBQUFBQUFBSEFZRWpBQUFBQUFBQUFBQUFBQUFBQUFBQUFCZ0g1eDk1Z1VOamg1ZnMyMXE4cEttcmw3UzVmTnZhMjc2aG5icTdSKzhyTG1aRy9yOFQvOERQZlBpU3l2Ymg4ZkdWUzBYTlhIMktaVUx5MXE0T1MxMHB6LzU5WCtyZERhM1p0dnl3cHdLaS9NcUZ3dkN3KzBiZi9UYmV2TjdmN1ZtVzcxYTBleU5xOUU4bVJlNlR5N2ZKeStlME1RVHoyZzNYTDUwV2VWeTJTN29EbUVRcmx5UE45OTRVMk5qWXhvN1BxYnRpaWVTZXVLRkR5dmIyNmUrYjM3RnZzZk5BZ0FBQUFBQUFIUXJBa1lBQUFBQUFBQUFBQUFBQUFBQUFBQUFzQS9peVpTUzZmU2FiZTEyeTBZSjJxMldka09yMlZDbFZMU3hva3FwcEhRbUxjZTk5Yy9HWGRkVkp0Y1QzV2Qzbmd0N283aThxRnBsYlppa1hGcTIxN1hWYkFvUE56TS83dFpzMUcvUGo0YlFmYks1WGlVeldlMVVHSVoycWRlajYxMGhadE9OZ2lDdzE2WVJ2UmZOMTdGWXpDN2I1VWJmdjNPOWZRcDhuNEFSQUFBQUFBQUF1aG9CSXdBQUFBQUFBQUFBQUFBQUFBQUFBQURZQnlOajR4b2NQYjVtVzdtNHJOa2JWOVdvN1U2WW9MQTRiNWZKQysvWTZNR1paNTVmQ1JpWmdNYkUyYWQwNC9KRlRVMWVGTHJURDc3MU5RSDM4czZyZnkwY0xoTlBQS3VCa1RIdGxPLzdOb296TlRXbG16ZHZDdDJuVnEvcDh1WEx5bWF6T243OHVEelAyMUhBS0ozdDBabG5QNkFyNzc2cDR0S0NBQUFBQUFBQWdHN2xDQUFBQUFBQUFBQUFBQUFBQUFBQUFBQ3c1MXpQaXhaWCs2RlVXTlRDN0pUOGRudGxXenlSVU4vQWtESzVYZ0VBOWtkUGZrRDVnV0h0VktWUzBkTGlrbHF0bGcwWm9mdUVZV2l2VGJWV3RkZXEyV3hxSnhLcHRJMWZwYk01QVFBQUFBQUFBTjJNZ0JFQUFBQUFBQUFBQUFBQUFBQUFBQUFBN0lONE1xMUV0T3lIaGRscFhUNy90dHIrbllCUklwN1U4WW5IMURlNDg1QUdBR0J6K29lUGFTejY3TjJwNWFWbDNiaHh3NGFNMnF2aWRPZ2lvZXkxS1N3WFZxN1ZUaVNTS1owNisvU3VCTEFBQUFBQUFBQ0F2ZVFKQUFBQUFBQUFBQUFBQUFBQUFBQUFBSEFnWE5kVFBKR1U0N3JhVGRWS1Njc0xjMnJXYTJvbFU1cWJ2cUZLdWFpcHlVdlI5cHNDQU95dFpEcWplRHloVkRabnY5NnBZckdvbXpkdnF0VnFDZDNOaEl2TXRSb2RIZFZPT0k1ajUwNG0xNnRjYjUvcXRhcmFyYVlBQUFBQUFBQ0Fia1BBQ0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFPaU91NlNwaUFrZU5vTjFYTHBlaVk3cTJBVVRxanFhdVhiZ1dNcmw2eVlTTUF3TjVLUlorOTZXeFB0T1NVeW1TMVV3U01EZzhUTUtyWDYzYlpDUk0zTkhNbm5ldFJMdDh2MzI4VE1BSUFBQUFBQUVCWEltQUVBQUFBQUFBQUFBQUFBQUFBQUFBQUFQdGdldktTNnBXeVRqeDZkbVhiNE9pWUhNZlRoYmRlalc2OW85MVNyVlRVYnJYMDcvN2IvN3ZDSUZDbFZGTGcrMnJVS3FyVnFnSUE3SzJCNFdNYVBuNUt5WFJHTzFHdFZyV3dzS0JDb2FCV20zalJZUkJFMzNlRE1MRFhMWkZNYUd4c1RKNjMvVi9oeWc4TzY5U1pwM1RsM2JacTBYOUhBQUFBQUFBQUFOMkdnQkVBQUFBQUFBQUFBQUFBQUFBQUFBQUE3SU5xdWFoME5yZG1XeUtaVms5ZnZ6d3ZydDNrdDFzeW1ZdjMzbnhWUVJnS0FMQy9rcG1zTWoyOWNyMmQvZXBPcTlWU3JWYVQ3L3NLQXo3UEQ0UFFmTitOL2wrajBiRFhicWZpaWFTZFM0N0xyNEVCQUFBQUFBQ2dPemtDQUFBQUFBQUFBQUFBQUFBQUFBQUFBT3k1S3hmT1JjdmJhN1psY2prTkRJL3FxZmQvV0IvNjFPZVZTbWUwRzFxTnVtcVZFdkVpQURnZ0E4TmpPdkhvazBva1V0b0pFOEM1Y2YyR3F0V3FjTGdzTGk3YWEyY2lWRHZSMno5bzUxSW0xeU1BQUFBQUFBQ2dHNUhlQmdBQUFBQUFBQUFBQUFBQUFBQUFBSUI5VUNvc0twRk1LYndkRllyRll0SGl5UFVjR3lYb0h4cFJ6SEhzOW5DSDRhRndqOE5GTnJSa3h5ODVqaGU5aGp2L05OMXZ0KzA2Q0c2dDY3ZWpHK0UreDVTYzZGdzZyaXZYY2VWNHJ0clJ1TXpZQXQvWHc4cGNKOC8xRkl2T2kyUE95KzF6MUdIT1R4Z0UwYlh6YjUrdlc5R052YngybldoWHpJbDE3Vng2V05uUEtNZTVOVy9za3JpMVBkcG0zMHZSZGVtOHI4eThZWjZzNWNYamR0eXIzMk5iMFJtL2lkL1U2M1Y3cm5HNG1HdG1ycDI1bG1ZeDc2bnQ4THhiYzhtTEp3UUFBQUFBQUFCMEl3SkdBQUFBQUFBQUFBQUFBQUFBQUFBQUFMQVBYdnZPdHpRNE1xclAvL1RmdDBHTFZEcTdzdS9KRno2bzAwODhvemRlL3BhV1kvT3Fsb3ZxWmgvNjlCZHV2NGFNK2dhR2RIemlzWlY5eXd0emFqVWJtcHU1b1hxdHFwZS85cWRxdDVwcU51cmFUL0ZrU3NkT1RHam8yTGlHeDhaMTVmeGJXcGlkMXNMTm1ZYzJZcFRKOXVpSjUxNVVQcnBtZllQREdod2RVNjYzYjJYLzNQUjFlODFtYjF5Tnp0V1VMci83ZG5UZGF0SDFhMm12bUxsa29oN3BiTzZlYzJsaGJpWjZUNVRzWFBLamE5ZW9WWVM5WjY1SnRxZFhFNDgvcmFIUjR4by9mY2FHVkxLNVhsVktSVTFlUEdmbnlaWHpiNnUwdkdUbnpsNDVqUE9rZjJSTTQ0ODlydTB5d1JzVHdDbVh5cnB4NDRadytDd3RMZG5GUkl4TUJDeVIyRjZBcURlYTgyWkpSKzg5QUFBQUFBQUFvQnNSTUFJQUFBQUFBQUFBQUFBQUFBQUFBQUNBZlJBRXZvMXFtSUJPTXBWZUV6RHlYRmRCSXFHK29SRjVpYVN1WHV5dWdGRThHbHM4a2RMQTBLaml5YVJHeDA4cEZvMDVFWTIxTjkrbnpLcW9nbm1kSm5nVFJsK2JvTW5wSjU5VnZWclIvTXlVRFlwc05YSmlJa21PNituRW8yZlg3U3N1TFVUTFluVE1pbzBTZGU1cnhwZU12aDRaRzFkK2NOZ0dlK1pucHUzOUhjZXg5NTA0ODZTOXIzazlIYlZLMlM2RnhYa2JSTmtxMS9Oc0pNaGMzNEhSc1hYN3o3Lyt5Z09QY2ZLeHg1V09qckZhclZSU3BWeFFMVHFQWm54YllWNmY2N2dhTy9Xb2NqMzVXK3ZldkYxNit3Zlh6RU56bnRLM1gzY2ltWkppanBiblpsVmNYbFMxVXBMZmJtdW5OcHhMc1pnUzBUbTcxMXlLUmVPbzVzcDJMaldpK1RNM2ZXTmJjK2tvMkdoK21MbGFXSmg3NFB3dzV6YVpTbW40K01sMSsrYW1ycWxScjl0NFdqeDZYNXU1MEI5OUhwbGxiT0pSOWVUN2xZL21pK1BjaXErWmdKbUpnM254aEwwK3M5SGpsK2ZuVkNrdDcwcnc2akRQRS9NWmswaW1vOC95dUhiQ0JJeE0rS2JaYkFxSFd5dWFuNDFHWTlzQm93NHpwOHo3endRQnpid0hBQUFBQUFBQXVnVUJJd0FBQUFBQUFBQUFBQUFBQUFBQUFBRFlCODE2VllYRk9iMzhGMzlxd3g4anF5SWltWjVlWmFMMXh6NzNFemEyOGF2LzdUbDFrNkZqSjlRM09LU2YvTmxmVUs2M1Q4Tmo0NXQ2WEJnRStzVG4vNlltTDV6VDk3NzVWYnMyeTFhWWNKRUpxdnlYLzgyL1hMZnYyMS81UTMzN3EzOFlIZk1kRzE0eDl6VVJxQy8rN1AvR0JsRDZCb2RYN2x1dmxHMWNaVzU2eXQ3K3ovNzMveWNiT1RwMlltTGxQbSs4L0plNmNlVTlmZjJQZmx2ek16ZTBWU1plOU1SekwrcnhhUG4wMy9pWmRmdi9peS84MEFPUDhmUC9sMS9VMEYzeG83ZC84RjJkKzhITHQ4YTN4WURSeU5oSkc2SDVlNy93ejlhZGs3dE5uSDF5NWV0MnEya2pHZC82OGgvbzByblg5ZTdycjZoVVdOSk9kZWJTNTc3NDkrMjUzK3BjTWxHYWIveng3MnhyTGgwRmYrZWYvRmQyanEwMkY4M1ZiMFJ6OXVKYnIwYkxheHMrenJ5SHpQVjk1Z012NmZNLzh3L1c3ZjgzLytML3JJV2JVL2J4Smw3MHlSLzdvczQ4ODN5MHZLQjdXVDJPYi8zWnJYbnkrbmUrb2VYRmVlM1VZWjRubVo2OC9ZeGZIUWZiRGhPOG1abVpVYUZZRUE2M3BjV2w2SHQ3WFQwOVBkcUp2c0VSSFR0MVd0Y3Z2VXZBQ0FBQUFBQUFBRjJGZ0JFQUFBQUFBQUFBQUFBQUFBQUFBQUFBN0pOMnMya2pJK1hpc3A1Ky80ZVY3ZWxSSnRlN3NuLzhrVE5xdDF0NjZ2MGZVcXZadUdlTVpMK2swaGtiK1hrNkdzL0UyYWRzL0NhUlRObDlRUkRJajhacUlqZlY4cDJvamhlUEt4YUwzUXJsUkdzVFRqRXhrdWMrL0FsN1BHUDIrcVFOTmUyVzBST25GUGkrUHZUSno2dTNmekE2cHoxeVhmZStqMWxlbUZPdU54OTlkU2RnWkFKRUp0NWlYc04yT0s1bm56dVpTcTE3cmxaMDdmZFR0aWR2WDhkTG4vbFJleTFXbnhQZmI5dnpWUzJYb3V2WFdIbU1DY2FZYStmRkU5RnJjZTIxZSt5cFoyMEFxVklxMmxET2RzSk9ocGszNld4dVpTNlpnSmNaa3hHRzRVb3dhYU81Wks1cDdQWmNNdGRuOVZ5YW41bUt4a2JnWmFlOFJNTEd5WDc0UjMvU25tOFRMeG9ZUHJicHg1OTY5S3g5UDVucjRVWFg2V0dlSi9Iby9aUEw5OWx4N0lUNWpDMlZTbXJVRzhMaFZxbFVvdS90YmUyVWlXS1p1UlZ6SEFFQUFBQUFBQURkaElBUkFBQUFBQUFBQUFBQUFBQUFBQUFBQU95VFZxdHBvMFQxYXZWMjRHTjhiY0RvOUJtN05uR2pTcmw0NEFFakV5OHk4WnVub3ZFOC85SW4xdTRNUXh0WnFoU0xXcmc1dmVveGFibXVaeC9YaVlrTWo0M2J4VERob3NMQzNPNEdqTVlubEVnbTljRlBmMTY1bnZ5bUhsTlluRiszTFozcnNlT09ld2x0aCtzNnl2VDBLbjVYd0tpd3VLQnFkRDMzazRuSnBESlp2ZlFqUDI3RFJLdVplSkc1ZG1aY3E2TXVKcWhsd2tVMllPUzRjaEt1SG4zcXVXaVJMcjN6cGhUVHRzTTBaaDVzZHk2WllJZm54VmVPWWVOWXVqV1h6RUxBYU9jUzVwcm4rL1hEUC9aRis3NC9kbUppUzQ4LytkZ1Rkbm4zdFZlaXl4azgxUFBFUzhTanNmUnZPNFRXWVlJMzVYSlp0WHBOT055cTBmZjhWcXVsblRMdlRUTzNuSmdyQUFBQUFBQUFvSnNRTUFJQUFBQUFBQUFBQUFBQUFBQUFBQUNBZldiaUcxLzd2ZC9Rc3ovMEVjVmVmRW01ZkY2cGRIWmwvL3MrK0RGVlNrVmRmdWROTFMvTWEvYkdwQTdDNmNlZjF2TWYrWlNPVDV4ZXMvM2QxNzZucFlVNXZmdjZLMnJXYTZvVTc0UkJUQUFuRm5QMDBtZC9USWxFVXMrLzlNTXIrNDVQUEJwdFMyanl3amxWSzJVYkl3bkRVTnVWU0tXaWN6Y1FuYStQcUNmZnIzZzh1ZW5IbGdxTDl2R3JtZENQQ1VwNXllMEZqTXcxUEg3cVVmVVBESy9adnJ3NHArTGlndmJUaXovOFdRMGZPNkhrcXRmWWJOUlZYRnJVK1RkL29BdlJVaWt1UjlldnZySS8yNXZYMExIamV1RWpuMVpQWDUrR1JvK3Y3SHZ1cFUvWVFNMjVIN3lzN1REWC9xT2YreHNienFWbW82SHYvOVhYN2ptWFB2Q0pIN0ZocW8zbWtnbFJMYzNON25ndVBleWVmT0dEQ2dKZmd5Tmpha2JuY21yeWttYW5ydXJtOWF2Ui9KMjNRYldPOFdpT0Q0Nk82WDBmK3JqYzI4R3JEdVpKOUxtVVRDcy9NQlN0TTlvSjMvZHR3S2dSdlc1MG43WWNtWmxVQ3VMUjF6RXRobmUrLzJSaWJXV2lyYmxvbllyNVdpNHN5L04yL2l0Y2lXUkttV3lQWWs1TUFBQUFBQUFBUURjaFlBUUFBQUFBQUFBQUFBQUFBQUFBQUFBQSs2eFJyK25kTjE3UndNaW9KaDUvU3FsTVJrcmYyVDkrK296S3hZSkdUMHpZMndjVk1Cb2NQYTRubm50UlBmbStOZHRuYjF6VjNQUU5mZjh2LzF6dFZ0T0djZTUyL0pGSGxjbjFySW1KOUEwTUtSdHR5K1g3NWNWdnFHMWlJdG8rRTA1SlIrZHVkSHhDdzJQalNpUTNIekNxMTJyUmRWZzdiaE12eXVTa2VHTHp4MW5OaEZUNkJvZnRjVlpyVkN1cWxBcmFUeWFrOU9pVDcxc1RhUXFDd0k3ajZvVno5dG8xRzdYbytyWFdQRzRzZXB3SjBCaXJBMGJIeGs5cGNQaVl0c3NFcHU0MWwwd2M1MzV6cVg5NHhBWnpOcHBMUFgwRGRoNjAyeTJGdmk5c3oyaDBmUlZUOU43c1U3VlUxT3oxU1YxNzc3d3V2dldxalJtWkFGREhVKy8va0oxZlQzL2d3L2EyRjc5ekhPYUo1SHFlMHRtZWFPMXFKMHhveWNTTDJxMjIwSDBDdThSVWthZUdITTJzK2liZUZ6WVZ4R0pLNmRaY005ZXhkZGRuN1haNDhYajBtWjVXTEViQUNBQUFBQUFBQU4yRmdCRUFBQUFBQUFBQUFBQUFBQUFBQUFBQTdMUEE5MVdybFBUR3kzK3A2V3RYOUptLytiZDE5bjN2VnlxVFd3a1Q1SHJ6K3NtZi9YbGRmdmN0NVFlR2RPUEtlOUZ5VWZ2QlJIaE9QdnFFSmg1L1dnUERvM0pjeDI2djF5b0tnMEIvL091L0VyMkd0bjBOOS9MMVAveE45UStPNkVPZitvS1N5WlFObzVpQWlBa3d2TytESDlYd3NlUDY3dGYrSkRwR1dkczFjdnhrZEt5UEs1UHR1ZjJjdjZYQzhxS3VYVGluV3EycWhkbnBsZnMyb3RzbUhOVnFOdXp0aTIrOXBsYWpzZUZ4ODMyRDluVXZ6czFxSzB6NHlEek9YTWZWaWt1TFdwaWIwWDRZZitSTXREeW04WW5IN0ZoYzk4NnZEVXhQdnFjdi9hdGYxTkw4M0Qydm5ZbGwvZll2LzVMZS85RlA2ZlFUVDY5c3p3OE1SdGM4aUs3bjU2TjVVTlhyMy8ybU5zTUVhUjU1L0JtZGVmcjVOWE9wVWEvYTk0R2RTMEY0MzduMDhsLzh5Y3BjU2tUbnVLZXZmMlV1UFI2OWJ6elAwL2UvOWVmMlBHTjdUQ3pOdkJlLy9nZS9xYm1aRy9yMlYvOUk3V1pUclZaVC9sM0JIL1BlV2J3NXE5NytBUjJQNXRrTEgvbmt5cjdPUERIejBNU3hOaHRmTzByekpCNVBSZWRtYU5zaHRJNVdzNlhscFdVYk1zTEJNV2UvS1VlRk1LRWJRVVp6U21vdVRHa3B1dDJTSzErM3ZtZTN3enRSSVRjVzJxMTlhaWdkOC9Wanl6UEt4WFllTU9xTnZqZkZvaityUDljQkFBQUFBQUNBYnNEZldBRUFBQUFBQUFBQUFBQUFBQUFBQUFEQUFUQlJpa2FqcmtxcFlOY2JSU3B5dlgzSzVIcVV5bVJ0aEdPL3VHNWN5VlJLOFhoQ3JuZm5uNTJiZUpFWlo3VmNzbEdUKzRVMWFwV0tVdW1Lalk5MDduY3J6aFN6VVJIem1uYks4MjZOc3pOR002NWF1YWpseFhuVnF5WmdOSFhQeDVxUVVTZG1kTGVZRTF2enVyZkNjVDA1anJObVd4QUc5anpzQnpOUDdIeEpKRFo4RGFYQ2tvM0MzTy9hVllvRk5ldjFOZHRpTVNjNm5uUHJ1c1ZpMmdwemplNGVqM24remx6cXpLdDdXVDJYZkw5OWV6eTM1cEtKeE5qWDYrM2YrK01vTXZQR0xMVnF4WWFNaWtzTDk3enZyZmRPM2Q2MzFXNnUyZGVaSjl2NXZEb3E4eVE2QmRGbmdHdlB4VTRGMFd2R3dUTTVvclljTmVTcUdub3FoWEVWbzhVRWpPN3hBTXRWWUIvbkI2SDgyTTVEVkxGb1hybDgxZ0VBQUFBQUFLQUxFVEFDQUFBQUFBQUFBQUFBQUFBQUFBQUFnQU5TV0p5M3kyLzlELzlmL2Vsdi9xcCs3cC8rYy9YMkR5cVQ2MTI1ejJOUFBXZVg3MzNqSzNybG0xL1J1NisvWWlNMGU2bHZjRWhQdmY5REdoNGJYN1A5NWE5OVdiVnFXZFZ5Y1ZQSHFkZXErc1lmLzdaT25YMVNIL3pFNTFhMlAzTDJhWTJNbmRCZi9ka2YyRmpLZHBueG1lVlgvei8vTjAxZWZFYzNybHhVdTlYYTFHTW5MNXhUTXAzWmNOL28rSVNOb014TjM5Qld4SlBKZGVmTW1MMCthY2UzSDRhT2pkdHJsMTAxaHhyMW10NzQ2MjlwYXZMU0ExK1RlZDNtK3M1Tlg5TzVIN3lzc1ZPUDJ2blFNWEhtU1pXTEJXMldDWENaOFl5ZU9MVm0rK3ZmK2FZVzUyYTNQSmZNNi92a2ozMXhaZnZ4YUh6bXRiNzExOSsyeDhQMnZQeTFQOUg4N0xSKzU5LyswcWJ1WHltWDdQd3dZU0I5WXYxK2M4M05lOXU4SnpmaktNMlRSREt0dnFFUkpWSXBiZGYwOUxRV0ZoZUVnMUVPUFJzZStndC9WTTFvZlM3bzAzWVVsVkF4bFA0OE9rNUNnZjd1d29JOHoxTStuOWQyZEVKY01XZm5jU3dBQUFBQUFBQmdOeEV3QWdBQUFBQUFBQUFBQUFBQUFBQUFBSUFENXJkYXFsY3JtcmsrcWNMU2dzNCs4MzY3M1hIZGxmdmtldk1hSFQrbDYxY3VxdFZzcU5tb0t3Z0M3UVh6dkNZb1l1TWtxN1RhTFRXajU5NEs4N3FhOWJXUFNhWFRLOCt6RS9WYXhRWkxxcFd5ZlI0VDM5bUt3RytyVWlySjlaeG9UTm1WN1Y0OEhyMzJoTGJDUktkUzl3Z2lOUnNOTzc3OWtFaWwxWlB2ajE3VDJsOFhzTmNobWpPYjViZk51U25hdWJhYU9YWXN0dmw0aHV0NmRpNnRQcjlHcTdXOXVkUnFySDJNdVU3bTNEc2VRWStkTU8raDB2TGlwdThmQnY3dDkvYm01OVQ5SEtWNUVvdkZvdmRmWEk2enM4ODM3SjkyR0xQQm9vWmRYQzBGQ2JXaXIwM0lxS21kWDhkYTZOb1FVc3NQRkhOQ2JaZjVYSThuVXdTTUFBQUFBQUFBMEhVSUdBRUFBQUFBQUFBQUFBQUFBQUFBQUFEQUFWdGVuTGZyMy8yVmYyWGpPZi9sZi9OTE5oS1R6dVpXN3ZQWTA4L3AxSmtuVklqdWUrM3lCZDI0Y25IUEFrWW1Vak54OW1rYkZGbXR1TFNnU3FtdzZlTzBXeTNOM3JpcW9kSGphN2FQbnBpd2E4L2QyVDlwbjcxK1ZaTVh6dW5hZStmdDgyeFZ2VnJWMVl2bmxCOFkwdkdKUjFlMlozdnp5ZzhPYXlzbXpqNXBBMU1iV1p5ZjNkYjR0bU5vZEV4UFBQZmltbTN0OXEzcnNEUTN1OW5EcUZSYzBtUjBib2JHeGpXczhaWHRUenovb2hadnptejZPTWwweHM2bHUrTk9aaDRWYnMvN3plak1wYnVqV3NOakoyNC9UMWJZdm90dnZhYUZtMU9idnIrSmNwbnJVU3hzUG5wMFAwZHBubmpSYytmeWZjTGhVVlpjeTJGQzc0VTV6WVVwWFEyeXF1M2lyMXhkQ1c5OUx5M1dtMHFIMG9DMnB6T3ZuQmdCSXdBQUFBQUFBSFFYQWtZQUFBQUFBQUFBQUFBQUFBQUFBQUFBMENXcTVhSWN4OVZicjN4SHFVeFc3L3ZneDFiMnhSeEhyaGZYWTg4OHI5NytBVlZLUlJ2M3FGWEsyaTJ4V0V5TzZ5bWVUQ3FWVHR1WTBtck5SazIxYWxXN0paWE4yVWpUZGw5RHMxRlhPVG9IUWVCck85cnR0c3FGWlNWVGE2TXBtV2hNSm1LMEZTYThZczdiYXVaNk5odE5CWDViZTgxeFhTVVNDWGxlZk4yKzBBL3M2NnpYTm4vdGd1Z3g3Vll6ZXZEYVNKYVpnNjYzdVY5Rk1QZnR6S1Y0TkxiVkd2WGRuVXYybXZYa3R4VFlRbmRnbnF4WHI5ZWo5OS9lZjI0OHJBTEZWQTFkMWVWcU9ZeHJXUWtiTURMeG9tSjAyK3pmQ3d1VnV2TGgzaHdiQUFBQUFBQUFPRWdFakFBQUFBQUFBQUFBQUFBQUFBQUFBQUNnU3l6TjM3VHJQLzNOWDFWK1lHaE53TWlFYWN6eVF6LzhXUVcrcjJ1WExtcHhia1kzS2hlMWUySktwdEpLWjNMcTZSdFl0N2RjS0VUTG9uYkw0UENvd2lEWTltdW9Wc3BhbUoxV3ExSFhkcGhBejhMTmFhVXlhd05HdmYyRE5oaTFGZVo4WlhPOWE3WXRMOHlyc0RpdlJyV212WlpJSktNeDlFZlhMN1Z1bndrOG1kZHBvbGViWlI3VGJEVGsrMnZqVUdaK3hKT3BUUjNEM05lRW5UYWFTN1ZLWlZmblVtLzBIRVBIamhNd09vU1lKK3RWb3RkZDNjVndFOVl5V2JiNU1HWGpSYThHQXpaZVZGQkNlKzN5UWtVamJlbHBBUUFBQUFBQUFFY0xBU01BQUFBQUFBQUFBQUFBQUFBQUFBQUE2REx6TTFPcVZ5djZxei83ZlkyT1QraXhwNTliMlJkUEpHMzA1OU4vNDZkdDhPaVB2dlRMYWpicktpMHZhYWNjMTlIZ3lKaHl2WG50aDNneWFaZnRhdFpyMGV0ZVhCZloyYXgydTZWU1lWSDEydGlhN1NZZWxkaGtwS2NqbCs5WE9wdGJzNjFjWExiWHN0VnVhcTk1aVlRZHcxYkhmUyt0UnNPZTIxYXpzVzZmNjNvYU8vVm9kTjZxV3BxYnVlY3h6Rnd5VWFYOVlPWlJJclU3cngzN2kzbXlYcnZWbGg5czczTU5HNnVIamdJNXVoam1WQXM5WFFoNjFJNXVtNUJSUzFzTDFtM1haTG10V0lMckNnQUFBQUFBZ0tObmYvNkdEUUFBQUFBQUFBQUFBQUFBQUFBQUFBQ3dhWlZTUVlYRmViMTM3ZzNOM3JpNlpwK0p4M2p4aE00ODg3d2VmOS83bGN2M0taUHQxVzV3SERjNlhsNnBkRWI3d1hYajhyenQvKy95dGxzdEc5SFpic0FvRE1MbzhUVzFtbXNEUStiMTUzcjd0QlhwNkRISnUrSkJqV2hzNWxxYWNlNDFNeS9NdU0zYzJBM21uTnB6Mi9ZM2VDNVhmWU5ENnNuZi94eVp1WlRKOW1nL09FNzB2dkRpd3VIRFBGa3ZDQUlGZmlEc0hoTXJha2JMVkpEUlpKalZlMkZ2dE02cElzOXUzdytMalVETHpWQUFBQUFBQUFEQVViUDkvNThlQUFBQUFBQUFBQUFBQUFBQUFBQUFBTUNlTWRHYjE3L3pEYzNQVHFsY1hOWmpUejJueDU1K2JtVi9JcFZXTHQrdnovM1VmNnJaNjFmMTVkLzY5MnEzVy9MM0laYXpXYjdmMXVTRmN4bzVmbExkcU5tc1IrZHVVb09qWTJ1MjUzcnpDb0t0UlNaR3gwOUZqK3RmczYxYUxXdDVjVzVmQWtiM0U0YWhqUkcxR2cwZFZwMjVGRThrQmR6TFFjNFRFdy9yN1J2Y2N2d01lNk1keGxTWHE1a3dIUzBwWFExeXFrYTNsOE9rZk1VRUFBQUFBQUFBWVBjUU1BSUFBQUFBQUFBQUFBQUFBQUFBQUFDQUxtUmlSTXVMODBwbU1wcTljVldqSnliVzdIZGRUNmwwVnNmR0oyeVl4dHdPZkYrK3VvY1pUN1ZjVXJQWm5lRWNNejRUOXJrN01HUkNKRnVWeW1TVlNLMk5wclJiYmJXYVRTa01kSkJNd01pODFpQTQySEhzUkdjdW1lc0YzTXRCemhQSGNhTFBnSlJjajEvVjZRYUJZbXJMVVRuME5CK21OQlZtVk9IWHFBQUFBQUFBQUlBOXdkKzhBUUFBQUFBQUFBQUFBQUFBQUFBQUFFQVhtNzErMVM2VEY4N3A5ZTkrVTUvNzRuK3FZN2RqUmw0OHJvbXpUOW00MGNsSEg5ZTN2L0tIK3ZaWC8wak5SbTFkbEdjelhOZlY4TmdKOWZRTmJMaC9jVzVHeXdzM3RWc0dSbzRwalA3b3JkZDBFQnExcWoydm8rT25WQzBYbFVpbDVYbnhsZjFQdmY5RGFqVWJ1cmlKOFUyY2ZWSk9kUDVXVzVpZHNzZmZqNWhLTHArM2N5RS9PTFJ1bjRsaG1YRnNSV0Z4M2k3bmZ2Q3l0c3ZNcGI3QjRYc2NmMDd6TXplMFcvcWkxOTJvVjNjMFhoeU1vekpQSE1lMUliTjRNcVdkK3IzcDZKT3g0Y2dQY3NyRldocUtkV2NFcnRzc2h3blZRMWZmQ1lhMEdDWjFMY3dLQUFBQUFBQUF3TjV6QkFBQUFBQUFBQUFBQUFBQUFBQUFBQURvZWlaSVZLOVdWQ2tWVkM0dHI5bm5PSTRONzZRek9mWDJEZG9RejNiRllyRjc3Z3NDWDM2N3JkMWl4bjIvNTlzdlFSRFk4eHY0L3BydDVweTZxNEpHR3pIalg3MnNPYTRmYkNza2RWVFk4M0dQNnh2NDdWMmRTN0ZZZDh3bGJOMVJtU2RCR0VSalhmODVzcjFqaFdySVZUbjBWSTJXV3VpcUZjWk03ZzJybVBNUlJPZWxldnM4RmNPNGlvcXJHVHJhK1ZVQUFBQUFBQUFBc0ZtZUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCZDc4YVZpM2FwMTZycUd4eldULzR2ZjBHNW5yemRsMGltTkg3NmpMSzllYjN3MFUvcTkvNzl2OWJyMy8ybXRpcm1PRXBuYzRxbmtodnVMeXpNYTNGdVZyc2xsVTVIUzBZSHJWWXBSZWYyUFkyZGV0U2V5dzV6VG11VnN0NTk3WHYzZkd3eW5aUGp4S0x6MXJOdTM5TDhyTDFtRHlzemw1TDNpR2tWQzh1N09wY1NxWlI5UGh3K1IyV2V0SnNOelUxZjEyajBPYkpUdFVDNjZjZjE1LzZFaG1KMVBlYVU5V1Nzb0dPeG1oSUs1SkF5c21xaHAyWjBObDcxKzdVY25ablhnZ0VCQUFBQUFBQUEySDhFakFBQUFBQUFBQUFBQUFBQUFBQUFBQURnRUZtWW5WYWpWdFhWaSsrcWIzQkl4MWZGTWt5Y0k5dVQxL2dqajZsU1hOYTFTK2ZWYkRTMFcwYkdUeXFaVG0vNWNZUER4OVROekRsYVhwalQwTEh4TmR0ZEx4NHQ5LzluOTVsY1RxNjc5ajZ0WmtPVlVzbXVzYkhSNHlmdEhOMnFnUzZmUzloZGgybWVoR0VvdjkxVzRQdmFUUTI1bWd0VGlzdlhZcERRY0t3UmZSMUU2NXJkNytyaDBRNWpxa2V2dUNGSFJTVzBIQ1pVQzEzZFZFcmxNQzRBQUFBQUFBQUFCNE9BRVFBQUFBQUFBQUFBQUFBQUFBQUFBQUFjSWpldVhMVHJZeWNmMGVEbzJKcUFVU2JiWTVkblh2eUloa2FQNjdkLytaZDJOV0QwMUFzZlZLVmMwbFlkUC8yWXVsbTFVdFRVMVVzYW0zaFV3N29UTVVxbDB2TGJyZnMrZG1CNFJQRkVjczAyRXkrYWpvNVhMUldGalUwOC9yU3l2WGx0MWQyUktSeHRoMm1lbUlDUmlaYVppTkZ1S29WeHUxeFZScTVDUGUwVTFCdHJxYzl0S2hiZGRoWG9ZZEdXby9rd1pZTk83NFU1VFlkcEZjT0VBQUFBQUFBQUFCd3NBa1lBQUFBQUFBQUFBQUFBQUFBQUFBQUFjQWhkdWZDMmxoZHVhdkxDT1NYVEdSMDdNYkd5YjNCa1RLbG8yNWxubmxPbFZOVEZ0MTdUYm5qc21SZHNvR09yK2dhR045eGVyVlJVcTVSMTBOcXRsbzBOM1IwcnlnOE15Zlh1LzgvdWUvb0dsRXlsMTJ4ck5lclJ0Wm5iMVhqVVVUTng5aWtOajIwOU1wUEo5VzY0dlZHckVvdzZnaDdXZVRLYVRhb1ZNMkdpNXNxMndPYUtwT2t3cFVVYjdRbHQwR2dzVmxNNjVpc2YzVGNSUFNaeFJJSkcvdTNYdXhnbTdXdS9IbVRVa0dQalJkWFExYUtTYWtUcnc4UmMxNEYwWEFBQUFBQUFBTUJSUThBSUFBQUFBQUFBQUFBQUFBQUFBQUFBQUE2aHlmUG5OTitidHdFakU5cFpIVEFhT25iY0xtZWVmbDZWY21uWEFrWm5uM2xCdTZsZUtkdmxvTFdiYlZXajg5UnVyZzBZOVEwT3kzR2MrejYydDI5QTZXeHV6YlptbzY3QzRyeWF6WnF3c1VmT1BxWGRWSzlXN1RYRTBmS3d6cE5qdWFTcVlWdDNCNHdVTFROaHh0NmU4ZE0yVnZTMFc5Q0FHbkpqb1hKaHkwYU1qZ0x6S3Z6YndhSld0UDVlTUtobTZHaEpTUjFXNXJvU01BSUFBQUFBQU1CUlJNQUlBQUFBQUFBQUFBQUFBQUFBQUFBQUFBNnBWcU9oTC8vV3Iybjg5R01hUFRHaFhHOCtXdnBXOXIvNGljL2E5ZHZmLzY0YXRhcG1iMXpWVHZ6cGIvdzdGWllXdEZ2T3ZmclhkbHdIclY2cmFPYkdwR3FWdFdHVGlUTlBhbW4rNW4wZm04djMyL08rV3F2WjBQTGluQnIxaHJDeHYvaUQzOUROcWV2YUxSZmVmRldWNHJKd3REeXM4eVNYOUpSdWhQZTlUMU9PZk1YMHRwOVhJdWJyVmZVckhXMUp4OW9haVRXVWlyNGVpOVdVak5ZalRsM2RyaDQ2dWhtbVZRampLaWl1aFRDcGt2MDZJWE1taXRIWG9ZMDRIVjcydWlaY2JaZmZic3YzMndyRFVBQUFBQUFBQUVBM0lXQUVBQUFBQUFBQUFBQUFBQUFBQUFBQUFJZFVzMUhYN0kxSnBkSVpHd0l5NjlXR3gwN1lkYmFuVjd2aDJxVUxLaTd2WHNDb1dpN1oyTTlCODlzdGUvNkN3Rit6UFJPZHQycTFmTi9ISmhKSnU2dzVYblNjVnJPcE1BeUVqZDJjdXFIcmx5OW90NWl3VmpmRXNMQzdIdFo1NHJtTzNKaHozL3VZbUU4N1drcUs3aGZHN1RZVEt6TGhJaWZhbm9tMTFhL0dvVW4rQk5GSXEvSnNzR2crVEdyYXhvd1NOdFIwMk1ORkhadTVydmNUQklIQ2dPOHJBQUFBQUFBQTZENEVqQUFBQUFBQUFBQUFBQUFBQUFBQUFBRGdrSnU2K3A3K3d5LzlDNzMwSXorbWx6N3pvMG9rMDNLOU8vOWMvQXMvOHc4MWVmR2NybDU4Unp0aGpyRXdPNjNkMG00MTFRMGE5WnFhTjVzcUZaZFZxNVNVVEdma09LN2Q1N3FlQm9aSDFXalVWU2tXMWoyMmIzQll2WDBEYTdhWk1OT055eGRWS3hlRmpWMi9mRjRYMzNwTnV5VU1mUG0rTHh3dGgzR2VtUGY5amZmT3EzL2ttSTJnYmNmN1R3N0pqMWVpcjVhMzlEZ1QrMm1HanM2RnZUS2ZZRy9HK3V6MnVCL1l1TkZRcktIZVdGTzlha2ZybHQyV2piV2orNFlhanRXMTEycWhxMVkweHB0aEtocXJxK3RoV3Exb3ZGZkRuRXlXeHdTTWdsQTJ3V1J1bTZqUlVZa1hHZWE2eHQzdEI0eEtTd3ZSOTVlaWplNEJBQUFBQUFBQTNZU0FFUUFBQUFBQUFBQUFBQUFBQUFBQUFBQWNBYVhDa2hyMXFzSXdsUG16V3JhblY5bmM5a0lhcTdXYlRiV2FEUjAxOXB6NWJRVitjT3ZyY08zNU16RW9wN2x4ZE1KMTNUV3hLSHU4d0ZlNzNaTHZCOExHVEVUbUtNNGw3SzdET0UrQzIrLy9JTmorK3o4WmQrMnlWWjNZVHp0YXQ2TjFJN3p6dVdWaVJhbG84UlFvRVF1VkRIMDUwYnB0N2hQYm44OHFNNzdBanMyeHNhVnE2Tm1nVVNHTTIyQlJTMXQvelllSnVhWTdDUmlaT2VXMzJ3SUFBQUFBQUFDNkRRRWpBQUFBQUFBQUFBQUFBQUFBQUFBQUFEamtXczJtNXFadjZIdmYvS3JtWnFiMDBjLzloQjU3NnJtVi9STm5uMUl5azlFUC85Z1hOWHQ5VXUrKy9vcXczdFRrSmIzOWc1ZjF4UHRlVkU5ZnY5M21lWEZObkhsS0M5RjVOWkdvdXozMnpBc2FHaDFiczYxVUxHanl3amtCd0hZTTVkTHFUN2VVaWdYeXc1aGF0OE5FTzlHUXE4a3dGeTMzdm8ralVEMnhsaElLbE5HZFVNNnhXTTJPWlN2cTBmTTFRMGVMWWVKV3JFamVTckRvWVpPTUJmWUttdXU2RTYxV1hmVmFlVjFrRHdBQUFBQUFBRGhvQkl3QUFBQUFBQUFBQUFBQUFBQUFBQUFBNElpb1Z5dGFYcGhUdFZSU3M5RlFQSkZRTEhZcmZHRkNQUG1CSVpXTHk4TEcydTJXUFlkQjRLL1piczZqRzQrdjJlWkZ0ODA1ZFowN01ZN0FiNnRXcmFsUnJRckF3eW53L2VoenBCeDlualMwRTA3TWhHOUN0UlF0b2F2OTBnNGR4YUxuTkFHaWpxTGkwZTJ0Qll5YTBlTk5lS2tlM2xxM2JSN3A0WlNLcnFPNzh3YVYvSFpielhwTlliQzFhd0VBQUFBQUFBRHNOUUpHQUFBQUFBQUFBQUFBQUFBQUFBQUFBSEJFek42NGFwZkhuMzIvanAxOFJBTWpvM0xkVy85c1BOZmJwK2MvL0FrYnB2aitYLzY1c0Y1aGNjNmV2eWVlZTNGbG0rTzV5ZzhPcTF3c3JMbXZpVUdaY3hwejdrUSs2dFdxcmw1OFI0dHpzd0x3Y0txV1M1cTVkbG41b1JGcFVOc1dqNFVhVFFRcStERlZXOW9YUWZRZG9tSi8xV2p0cnh2Tmhtazl0UFdoWFhBaUdTcmg3UHdFbGd2TFdydzVveUFrWUFRQUFBQUFBSUR1UXNBSUFBQUFBQUFBQUFBQUFBQUFBQUFBQVBhSjR6aEtaM3VVU0NhVnlmWFlLSTVaQXIrdE1OeTlPc1R5NHJ4bXJrK3F0Mzl3SldEa2VYRmxlL0pLWlhya1JsL3Y5bk1lQmZWYXhRWWlndUJPSE1KeFhHVjd6WG5McnJsdlBKRlFLcDJPOXNkV3RyWGJiZnQ0RXpJQzhIRHlvOCtCV3FWazF6dVJqRDViQmxLT2dtWk1zL3NVTU1MZTZJK3VZOXJWampVYmRUdTN3b0NBRVFBQUFBQUFBTHFMSXdBQUFBQUFBQUFBQUFBQUFBQUFBQURBdmpBeG5LRmp4M1hzNUdtOTcwTWYxL0dKUjVWTXBlVjZ1L3UvVFR0N1kxTG4zM2hGN2ZhZDZvVVhqOXZuN2gwWTNKUG5QQXJLaGFJV2JrNnIxV2lzYkRQUnFhSFI0elppdEZvcW5WTlBma0N4MkoxL2x0OXVOZTNqeTZVbEFYZzROUnMxRlJibjdYb25FbTVNaitROERhYjQxWi9EN2xSUFFvL21rOW9wRXk4eWN5c2dZQVFBQUFBQUFJQXV3LytQRXdBQUFBQUFBQUFBQUFBQUFBQUFBQURzZ3gvL3UvKzVjcjE1alJ3L0ljZjFsTXYzeTRzblZDNFV0RGczbzNhcm9OMnl2REJ2d3pxQjMxNjNMNVhLYUhCa2JOZWY4eWlvRkF2Uk9XbXAxV3F1YkRQUktYTytzcm03QTBZWmV3MWo3cXFBVWJ1bFVtRlI5ZHJPd2lXN0xSYUxLWkZNMmVoRmU5VnJ1NTk0SXFsazlCb0hqNDJwdDdkL3pUNC9tbGRYM3pzdlB6cFdyVm9SZ0R1YWpib0tDM05xMXV2YWlYekswNHZIKytYUDFmWGR4YXB3ZUowZDdsRi9ZdWNocWxxNWJPZFdHUG9DQUFBQUFBQUF1Z2tCSXdBQUFBQUFBQUFBQUFBQUFBQUFBQURZQjA5LzRNTWFIRDJ1d1pGaks5dW1KeThwbDgrcnVMeWczVlF0RitVNGp2ejIrc2lCRjQvdnlYTWVCZlY2MVVhSXpOTGh1STV5dlgxS1piSnI3aHRQSnFKdEdSdUs2Z2pDd01hTDJzMkd1a2tzK21OaVdiN3ZienBnNUxxdTB0SHJHejQycnFGbzNxN1dxTmMwTjMxZHpZWkx3QWk0aXdsODFhcGx1OTZKZVBUWmM2by9vMHUyWFVUQTZEQWJ6aVkxbk43NXIzQTFtM1U3dHdJL0ZBQUFBQUFBQU5CTkNCZ0JBQUFBQUFBQUFBQUFBQUFBQUFBQXdENW8xdXMyL0xKYU5wL1g2UGdwTFMvTXFiQTRyOTFTV2w1VXVWaFlFK0xaak1EM05YTjlVbjBEUXh2dUh4Z2RrK3ZGTlh0alVsc3hNRHlxTTgrOHNHNzc1Zk52cTFHdHFCaU50eHVZOEpBSi9KU1dGdTAxNlJzY2xoTnpsSS9PUjdhblo4MTllL0tEOXRwNTBmbm9hTlVibW8zTzMvTGluUFpicTlGVUlScHp2VnBidDg5eFhUdFdFeHVhdVhaNVU4ZnpFZ243dXAvNXdFZjB4SE1mV0xQUEJMS3V2ZmR1dEM3ZmQ5NmF1V1JDU0JzeGMySjBmR0xMYzZtbnIxOVB2ZkNoZGR1dlhUb2ZqYWUwcSs4ajdJK2pOay9helpiS2hTVlZvcVZjV0ZZNm00cytON2YrNnp2WlpGelBqQTlvc2haVExqYW5SaGhUUzQ1d2VDUVZLQjRMOWZoSVhzZDdrOW91ODk4UHpVYjk5cHhhVWhENEFnQUFBQUFBQUxvSkFTTUFBQUFBQUFBQUFBQUFBQUFBQUFBQTJBZSs3eXU4S3pwZzRqZXBURmFPczd0UmltYWpvZTBJZ2tDTldsWHQxc2JobzNRNm8wWW1vNjFLNTNJYUdEbTJidnVOS3hmbGJ6R3l0SmZNNnpkYXJhWmF6YWI5T2haZG0wUXlhU05BcTVsdDV0cXRmYnl2dWpsL3pmMS9UWDdidDJNTy9QYTZmV1orcGFMcjVtK3c3MTVjMTFNOGtWVC8wSWlHeDA2czJWZGNXckQ3dlBqOTU1bVpTL2VhaTRsRTBvNXBxK0x4eElaemFXN21obzFQNGZBNWF2UEVmQTZZeFh5T21zKzNNQXkwSFY3MHZzMm5rOHJFSFJ2QmFTb21oY0loNGtiWHpWdzdjeDNOc2wxbVBwbTVaT2JVdmI0L0F3QUFBQUFBQUFlSmdCRUFBQUFBQUFBQUFBQUFBQUFBQUFBQTdBTVQ2Mm5VS2hwLzVNekt0cjZCWVUyY2ZVcVgzbmxUaDBFcWsxT211ZlU0MHFrelQrbW4vdEgvZHQzMnBibWJXcmc1cGNXYk0rb21reGZlc1ZHVjRiRXZybXd6MStxcDkzOUljOU0zTkQ5elF6MzVQZzBmRzVmcjNRa2JtWGpSNUlWek9nanRkbE9WY2xHdDV2YmlWZnN0bWM0cWsrdlJWZzJObmRod0x2MzZ2LzUvNi9ybDgvYjY0T2c0elBQRWZFNWNlZmNOUGZiTUI1VExKN1JkdzBsSEh4bHk5WHBSdWw0WERwRXpQWTVPcEtKNTdHcEhsaGR1YXZiYVpaV0xTd0lBQUFBQUFBQzYwZTcrejNRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQURiVWJ0YlZhcXlOeTdpZXAyUXFwWGc4SWNmZFllRmdGY2R4NU1YajJvNTJxeVhmRDdSYllyR1l6SitObU5oT3M5Rjl3WjNBTitlZ3ZXYWJhODZwRjdmbjF0Nk9ycGU1M1dHdWJYRFhZL1pWR0NvSWdtZ1ZicmpiY2IyVnNXK0djL3YxdXZkNGpKa25ZZURmOXhqbVBzRUQ3ck1WRDVwTHJTNmNTM2l3b3pwUHpHc3lyMjJua3A2ajNwUm4xemhjT3RkdXA4ejNsbHZmWTNidmZRSUFBQUFBQUFEc3BwMy9MUmdBQUFBQUFBQUFBQUFBQUFBQUFBQUE0SUd1WEhoWDVXSlJIOVBmV3RrMk9uN0tMdSsrOW9wdVRsM1Z3czJaWFFrVTlBK1BLdGZidHlhd3N4a210bkhqeW5zYWYrU01ka01zNWlpZHpTbVJURzI0LytyRmR6US9PNlZ1VXlvc0szN1htRk81SG8yZlBxTmF0UnhkcTJ2cUd6NW1iM2RjZlBzMVhidDBRUWVsM1c2clhxMUUxN0M1YnArSkZ3Mk9ITFBScGMzSzlOeDZ2ZVoxcjN1dTIvUEVmOEJjTmZjeDEzODNkT1pTTXAzZWNQL1UxVXYyR3VEd09hcnpaUEhtdEYxUFBQNk1jdmsrYmRlWndheis4eDk2Ukl1djNOUjc1Wkp3ZUh6eTlKQStQOUdyM3RUMmdvSWRpOUYvRzd6Mzlxc3FMUzhLQUFBQUFBQUE2RVlFakFBQUFBQUFBQUFBQUFBQUFBQUFBQUJnSHl3djNKVGpPS3BWcS9JOFYvRkVjbVhmd01neGpUL3ltSXBMaTJyNE5lMVVKdGVyL01DUVhHOTlzS2JWYkVSam1ZL1d6UTBlR2RvNFRidmRzbXZIZGFJeDN6bEd1aWNuMzI5cnM4empzejE1cGRLWk5kc2I5WnFDSUZRUUJ1cEcxVXBKaWNMYWdKRVRjNkx6R1ZjNjIyUFBiU0t4TmtoUkxpeXJYcXZxb1BqUk5UTmphRGJxNi9iRllySmozMmcrM0VzczV0ckhtRG03MnVyNUVUN2crcTJaUzA3TWhwUTZNcm1jblJ1YnRUS1hVdGsxMjgxOGJyZDloZEY4d3VGMFZPZEp0VlNVRzcwV2Y0ZFJ1bmowbXZMcHBIcTltSHJkUU9YQUVkTzl1eVZqb1pKT3FId3licStkRzlPT05CdTE2UE45YWNOQUhRQUFBQUFBQU5BTkNCZ0JBQUFBQUFBQUFBQUFBQUFBQUFBQXdENjRkdW04eXNWbEd5R0lKeExxR3h4ZTJUZit5Qmw1WGx3WDNuek54bjEycW05d1NNY25IbDBUQXVtb2xJdWF2bnBwdzhlRllXaERDYzFvREdadElrdE80azcwWm5Cb1ZLbFVScHRsNGtkRHg4YVU2MTBiSUtsVnlqYWdGUGpkR1RBeUlTbS92VGJVNUxwdTlOclQ2byt1bTRsSVpISnJYOVBDeldrVkZ1WjBVRXc4eVN6VjZOeXVFNHNwbVVvcEhrOXUrbmdtQkdOZXIzbmRxNjJlSHcreStyNG1ocFJjTlI5NytnYWl1Ykg1dWQ2WlMvbkJ3VFhiVFJDc0ViMXV3aDZIMTFHZEo0WEZPZnVaMzZoVnRCT1paTnd1eHpLdWpzVjlYWXRlUWkxMGhPNlZjd01OZW9IR3NuR045V1cxVTlWeVNmTXpOMnlJQ3dBQUFBQUFBT2hHQkl3QUFBQUFBQUFBQUFBQUFBQUFBQUFBWUorMFdrMWRmT3RWOWZZUHJna1lEWTZNS1pYT2FPTHNVNnFVQ3BxOGNFN2I0Yml1WE5mVDhMRVRtamp6bEkwaWRaaTR6ZXoxU1MzT1RqM3dPT2ErYzlNM2xCOGNVdC9BblhIbStnYmtKVFlmd1RIeG0rRmo0K3JwNjEremZYbGhYdFZ5VVVIZ3F4c1ZGdWR0TUdLMVJES2wvTUNRUFRlVmFKOFhqNi9aYjhKUVp0OUJNK2ZWWERzVHNZcmZ2bFplTkNlT24zcFVzVmhzMDhkSnA3TWFpcTVkTXIwMnZtR092Ynk0K1ZDVENWV1p4MlI3ODBxbTBpdmJUZFJxS3pHT3pseGEvYjR4VEJCc2VXRk83U1lCbzhQc0tNNFQzdzhVaHMzb2VXOHEwOU1idlo5T2FDZk85Q2RWUE42andsUlR0WHAzeHQ5d3k0bWVwSjd2ajc0WForUGFDVFAzVFFpclVsaTI4YTJ3UzZOL0FBQUFBQUFBQUFFakFBQUFBQUFBQUFBQUFBQUFBQUFBQU5nbkpwNXg4ZTNYTkRwK1NzKzgrTkxLOXFGangrMnkwNENSaVJlWmFNM3c4UlAyV0Y3OHpqOFpyOWNxOXJqek05TVBQSTROR00zY3NNZGFIVERLOXcvWTBOSm1tYURTOE5nSjllVFhCb3hNa01GRWd2eDJXOTNJak8xdThXVEtSbEZNMktoVVdGb1hNRExidXlKZ1ZDcEYxL2lHTXJuZWxZQ1I2OFYxZk9MUkxZVmdrdEYxSGg0Ymo2NTNlczEyTXk5S3kwdWJQazZ6MGJDUENZSlFRNlBIVjdibmV2c1VodUdtajlPWlMzMERRMnUybTJ0aFhtOXpDNjhOM2Vjb3pwUEFiOHMwMmdvTE4yMlVhYWNCbzhmNjBrcUd2cjZ6c0t4WkFrWmQ3VVJQUWg4Wnoyb2tzL09BMFVJMGI4dkZKYlZiTFFFQUFBQUFBQURkaW9BUkFBQUFBQUFBQUFBQUFBQUFBQUFBQU93VEV5QjQvVHZmMFBIVFovVEVjeThxUHpCa296Z2RILzNjVDloMXZWcFJxOW5VRC83cWE1czZic3h4bEVpbTlPd1BmVFJhUHFLeno3NWdqMjJDUmgybHBVVzkvQmQvb3FYNXVRY2VyMW91YXZMQ084cmtlbXo0cHVPUnM4L1l0VG0ySDcyV2NxbHd6Mk9ZQUU2Mko2L25Qdnh4NVhyNjF1eWJ2WEZWczljbjFlN3k2TXhNTkViSGNUVnkvRVQwV25vMGNlWkpOZW8xTGN4TnkvWFcvbk44ODNvcTViSU8ydnpzbE41OS9SVWJjVEZqTmh6WDBlajRoSTFZbVhXNXRLeEtjZU5yWjJKSHVkNjhCb1pIN1gwVHFkU2EvV1plbVBteFdZMWExVDRtREFLZGZ1THBsZTBuSDNzOG1rTnRPNWZNdnVMeTRqMlBZZVoyWnk0bFVtdURTZ3MzWjJ5WXF4RzlOaHhlUjNtZTNMaDBRY1hGQlQzeHdvZTFFNmVIZW5XeVA2ZmZ1MXhTdFZiVDlTYS9FdFJ0a3JGUXczRmZ6d3hsOUpGSGo2azNuZEJPMUNvbFhYemorMXFjZlhCNEVBQUFBQUFBQURoSS9HMGxBQUFBQUFBQUFBQUFBQUFBQUFBQUFPeVRkcnVsNWNWNTVmTDlxcFpMeXVSNjErdy9kbUxDcmdkR2pxbFcyWHdNSnhhTDJWaFIzOENRVGo3NnVJMTRKSkxKdGMvZGFtcHhibGIxYXZXQngyczFHelpTWXlKS3EvWDA5ZHUxT1hiekFjY3c0ekZCRVJOb01sR2MxY3dZek92dmRpYXE0c1Z2alQyZVNOckZCSDF1aGFGaWErNWJqKzdiYXRSMTBKclJHRXFGSlR2WE9reUVLWlhKS0pYTzJuWDlQaEVYeDRuWjY1dE1wZTE5NzJibWhYbXRtK1g3L29aektaTzlGVmN5ejJYdWN6K09HMStaUzQ3cnJ0bG5ycEdaU3c4NkJycmJVWjRuNXJQY1JPWjJLbjg3aHBQellzbzRvZEI5M0Zob3IwMXYwdE5nTHFXZDh0dHRsWXZMOW5NZEFBQUFBQUFBNkdZRWpBQUFBQUFBQUFBQUFBQUFBQUFBQUFCZ244M2VtTlJ2Ly9KL3A0OSs1c2YwMG1kL1hJbGtXcTUzNTU5M2YrRm4vcUVORHIzdmd4L1g4c0pOWGJ0MFhzWGxCWldXbGxidWswcG5GRStrTkhyaWxQb0doL1RrQ3grMDRhSmNiOSs2ZU1kdi8vSXZxYkE0cjRXYnN3cURCd2M4Rm1hbjlmTFgvc1RHUTA2Y1Boc2RNMitETmgxLzcrZi9tYTVkUHE4Lyt0Sy9sZSszMTRSN2txbU1qWFY4NFdmK2dRM21wTE01ZFdJL0ppQlNxMWIwenV2ZjA5WHpiNnZSNVZHR0c1Y3ZLcG5KYVB5Uk15dmJIbm44YVkwY1A2bGNkSzdYM1BmS1JYV0QyUnRYVlZ4YTBITWYrcmdOTHBtNWNTdTRwR2l1VE9nbmYvYm45ZHAzdjZIWHZ2ME5sWXVGTldHTVZDWm5BMWcvOW5kK1Z2MGp4OVljdDFHdkt2QjlPeSsyb3JBNFp4L1RxTlgweFBNL3RPRmNNdVA5ai8vcUYrODVsejcxNDEvVXdQQ3gyM1BwbHM1Y2V1K3QxL1RHeTM5cEgzdFFmdTZmL3RmYVRYLzg2NzhTdmY5YjluUGlZWEdVNThuMXl4ZWk5NkJyeDI5aVlybDhuM2JpYjU0ZDBBK05wUFRQWGw0U3Vzc2orYlQrZDgvMTZmR1JYdTJFK2F3MTRhTDVtUnZSM0gyVlFCc0FBQUFBQUFDNkhnRWpBQUFBQUFBQUFBQUFBQUFBQUFBQUFOaG5RUkRhbUVYQkxJdnp5dVg3bGM3a1ZpSkcyWjVlR3pBWkdoMlQ1N21xVmtwS0pKTFJjaWZvWVFKR1pwdTVUN2EzVHdQRG96Wlk0OFhqSy9jcGw1YnRlbUYyeXNacWdrM0dPOHh6bTZWU0t0aHh4aE9KTlRHUi9xRVJ0VnBORFIwYlU3TmVWNzFXWGRtWHlmWGFnTkxneURFbG96SEdZbzdDTUxSTHZWWlJZV0ZlN1dhejYrTkZobjFkc2JYYnpEbVA1V1RQdGRGcU5PemFuSzl1WU1aUnE5YTBORCtuM3Y1Qkd6RHFjQnhIZlFQREdoZ2ExZURvY2NXVFNkVXFsWlg5Wmg2YWNJeTV2dWxNZHMxeGkwdUxOcXF4K2xwdmxubE10VlM4NTF3eTgrVitjMmxnWk5UTzc0M21VcmxjUFBDNVpNN2xiakxuS09iRTlMQTVxdlBFZk82YXBWR3RSdU4wZGh3dzZrc25vdU1GU2p1aHZWMExIcjY1MG8zTTlVaDVqbzdsVXNvbFhPMlVtUy9tZTJXcjJSQUFBQUFBQUFEUTdRZ1lBUUFBQUFBQUFBQUFBQUFBQUFBQUFNQSs4OXN0TGM3TjZpKy8vUHQ2ODVYdjZGTS84VE42NHJrWGJZRERkVy85TTI4VEloby9mY1l1ei96UVI3VWRYLzdOWDdNUm9wZi80aysxSGVkZS9Xdk56MDdwOHovOUQvVE1peSt0Yk8rTTYvMGYvWlNXRitZMWZmWFN5cjdSOFZOS1pUSTJLckw2OVRZYmRmM2dXMS9UdDcvNlI1cTlQcW5ENE1ia2U4cjI1dGRzOCtJSnUzUk1YbnlucXdJVDdWYlRMdC84azkvUjk3L1ZxNS83cC8rMURSa1ppV1JxNWRwOTRXLy9yS1ltTDltQVZzZkUyU2R0Q0NhVnpxNDc3dGQrL3pkMS9mSjViZGZWUysvcWQvN3RMOTF6THYxZi8rVi92T2RjU21kN0ZJdmRpclNFUVdDak5KMjVORDh6cFlOMjVwbm50WnZTMmR4REd5MDV5dlBrN1ZlK0ZZMHpxOEZqNDlxSkYwN2VpcEo5K3MwcDFmem92YmtnSExDMEcxMlA2R1AyOFdGWEx6NHlvcDB5M3kvTmZGbGV1Q2tBQUFBQUFBRGdNQ0JnQkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFIeEcrMVZLOVd0REE3cGNrTEdmbCtTNGxFU2dNang3UWRKdGhScjFYdDBxaFc3WEhOMTl0bElpcVZVdEVlNS9xbEMrb2ZIbFU4a1ZRaW1WeTVqd25lckk0VmVZbTQzZGJSYkRSVXE1UTBjLzJLRm0vTzJOY2JCTDRPQXpOVzE0dmY5ejdOZWsyTmVsM2Rwbkg3dWs5Tlh0YlMvRTJOblhvMHVpNk92Rld2SjU1SXJMbDI1cm81enExckY0YWhqY0NVaTh2UlVsQnhhY0hPaGUzeS9mYXV6S1ZHZEUybXJsMWFtVXNtam9XajR5alBrK0xTZlBSWlVWUGdSNTkvc1ZqMFhuTzBFNmNIc2paZzlNMkZpc0xvdHErWXNQL2M2T3liWDg0eTEyT3NKNjJkTXZQRExHYSttQUFoQUFBQUFBQUFjQmdRTUFJQUFBQUFBQUFBQUFBQUFBQUFBQUNBQTFJdUZlenk1ZC8rTlJ1VytkUlAvSlRTbVp5KzhMZi9vYlpqOXZwVlRWNDRwM2RmZjBXek42N3F4cFdMYXJlMkgrNG9MTTdiNVN1Lyt5WDFEWDVGUC9tenY2QmNiNStHeDhaWDd0UGIxMitYalpnWWlYbThHYzlmL01GdmFIbGh6dDQrTE13NXpEOGdBRFUzZlVPMWFsbmR4b3pkK05LLytuK3FmMmhFZis4WC9wa05GdlVORHEvY1ozanN4RDBmYjRJdnpVWmQzLzNhbityU3VkZnROU3dWbHJSZDVjS3lYVHB6NlhOZi9QczZkbUppeTNOcGF2S1Nmdi9YL3ZXaG0wdlluS004VDk1KzVkdnE3Ui9VSi8vRzMxSE1jWlJJcHJRVFAvZmhSelZUYnVwMzNudGJqVENtYXVnSyt5L25CRHFlaWR2ckVYZDNGcVV5Ym9VREMzYStISmJZSHdBQUFBQUFBRURBQ0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFPbUluRmhFR2c4Mi8rUVBGNFFtRzB6ZlU4alk2Zmt1TTQ5bXZYTll1clZpdTZieGpZeDRWQnFGcWxiSU1IeTR2eldydzVvOFc1R1MzTVRxdGNYRmJnNzA3OG9GUll0TS94elQvK0hSdmRPUFBNQzNJOFY2bDBadVUreVdSYVhqeXVlcTBpUDNyZWFxa1VqYldweWZOdlIrT1pzaUdSeGdOaVFCc3hyOG1KWHZ2di9mdC92VzdmOVV2bmJVRElqRzB2bURIWHE1VU5uN3ZqU3ZUNjJ0SHIzQzFmK2QzL29FeTJaODIyK2VnMXpzMWNWMmw1NndHaDR2S2ltczI2dnZxNy8xSEo2SHFaR0V3cWs3RmZkNWc1RjR2Rm92czE3TFZyVkt1cVJQTm4vdWEwcnIzM3JwYm1icXBacjJrM2RPYlNkLy84ajVYcnpkdTVaR0l1Nld4MjVUNkpSRkx4YU9uTXBWcTViTWRtNXBLSktHMTNMbTFYclZMUnhiZGV0ZGRoZXZLeTl0ci8zTTY5eGNoMUgvWWQvODExNzh1YlNKRXlTVWUzeW5aczE1SjhxeDBqUml6YkJYcDdjRnZBTHcxU3VIM29RNEVXeUZ2NzFyYytGZ1Zhb0U5QkhsSWdSWkdvUVF2WVZaMDRkbVhIdHFSWUlrV0pFaWt1eVYwdWQ1ZDduL3RNWjBhMVpNTnhyQ010VitUeTh5SCsvTStjbVowNWM4NS9ab0VGNWp0YTA3MWY4dDc5M2plZkhzZWtmdGJ1OXVZNFhMYTJmT09YUHVZbzdETjYzSmVlKzM1YXJlWXYzSDcxMHF2WjNTa2U0aHE5Qi8rcTk4Zm9lSFhiNy81OWNUZXVrMTlsOURuUmF1N202dkE5TlRrem13ODgrR2plaStsNk5VZW1Cdm5TbWRsYzN1bmxoeXZ2UGxiSHUvZjVVOU41WUs0K1BoL2xjaW52MVdoOWpBSkdvL1V5K2gwUEFBQUFBSGVEMGplKytxUy9aZ0VBQUFBQUFBQUFBQUFBM0VHbVorZFRuNXpNeHovOUc2bFVhNWtZWGg2Rk9rYkJqa1pqNTYwd1ViL1hIVWRMZHJZMjg4YkZsOGZCajlzVjgvbFpuL3pDVThQOXFlZlFzZU52YlpzN2REaVRVek5aWDdzNTNJZjJPUFl5aXQ3ODVWOThOOXdacG1mbjhzRkhQNXhEUisvTDRaODVkMVBUYytQd3hzNzJaanF0VmpiV1ZySzZkRDJYWGoyWDIyMjBsa1pocmlNblR2N2NmczRNM3dNL1hVdWppRlZ6Wjl0YXVvY2RsSFV5T1QyVHp6NzE5NGFmblNmeWljLy9WdDZyM1hZM3o3eDhOZjkzcVpuZmUzVXI3TDkvOTZtak9UMC9rUzk5NkhUMndwLys4UitNdzNuUGZ1dnBBQURBUVhTamN5ajlRU250VkxOWEdyV3BMTTJmemZiRWZGWm1UZ1VBMkdlbGZIdnZmck1EQUFBQUFBQUFBQUFBQUxBbldzMUdldDFPTHJ6d3c1VEs1WEc0b3p3Y3BWSTUvWDR2ZzM1L2ZML1IzR3EyeGlHajBjK01idHNQbHk2Y0d3ZHZScEdsbnhvRmxpcVZhdHJ0Ti9lbnVUdDhEYjFPdUhNMEc3dTUvc2JyV2JseExmWDYyK2V1VXFtTnZtQXdYbk0vWFZQdFZpUDc0YTIxZFBuaTIvdFRyYVZXcTcrMWx0ck5aanFkZHJoM0haUjEwdXQwOHRxNTUzTHE3TVA1OVU5OWZ2eTVQdnJjZkxkcWxYSStjZnErdE1zYnViQzZsYXU3eWJWbTJBZFBIaTFucmxMSzQ2ZVA1Y1JNUGUvVjZQTzNQL3o4SGEyUGJ0dm5IUUFBQUFCM0Z3RWpBQUFBQUFBQUFBQUFBSUE3ekNoa01CbzNybDNKbldoMStYcTQrL1I3dld5c3JlUk9ZaTN4VGh5VWRkSWRmcTdmdkg0MUU1UFQ0L2ZqS0VxWFN0NjFVY0RvOU5IWkxHNjM4dUIwS1R2ZGdZRFJQbmxnc3BRSHBzbzVlMlE2aDZmMklHRFVlek5PT0ZvZmc4RWdBQUFBQUhBM0VUQUNBQUFBQUFBQUFBQUFBQUNBMjJ3VXBtazFkblB6K2tLZS9kWWY1NE4vNDlmemE0OTlMTy9WUjA4ZHlpUDNmU3gvZEc0eFUrZVhjbTZubkoxZUtleTlCeWI2K2NERUlML3pxVWZ5NkxHWlBZa1hqYno0Zys5a2EzMTF2RDRBQUFBQTRHNGpZQVFBQUFBQUFBQUFBQUFBQUFEN1lCUXhHbzNtN2s2Nm5VNzJ3bFN0T2g1ejlVb215NE5VdFl0dW05R3hIUjNqbVZwNXorSkZJOTFPZTd3bVJtc0RBQUFBQU80MkFrWUFBQUFBQUFBQUFBQUFBQUN3VHpadnJlYlpiejZkYnJ1VHVVTkhNMy8wdmt6TnpPYTkrdHJIejR6SHYzajZ4Zng0Y1ROTDNXcDZBeldqdlRCZjZlZGtyWmQvOHZpWi9QWVRaN0pYTmxaWDB0emR6Z3ZmL1QrNS9zYkZBQUFBQU1EZFNNQUlBQUFBQUFBQUFBQUFBQUFBOXRudTltWldGcSttV3EvdlNjRG9weDQ2TXBWT3I1L21TanRiN1Y3YWczSjQ5K3FsZmc3WFMvbkk4ZGtjbjZsbkx6V0dhMkQxeHZWMDJxMEFBQUFBd04xS3dBZ0FBQUFBQUFBQUFBQUFBQUQyMlpWWHoyVnRlVEZmL0FkZno3SDdIOGhlK1dkUG5oNEhqUDdwSDcyVXhlRzgxQlV3ZXJjcUdlUjR0WmN2bmoyYWYvWFpEMmE2dnJkZnhUci8zTE41NVlXL3lNYmF6UUFBQUFEQTNVckFDQUFBQUFBQUFBQUFBQUFBQVBaWnQ5MU9ZMmNycXpldVoybmhVdTQ3ZVRyVldpM3ZWYjFhU2FWVXl1Zk9ITTZON1ZiKzdOcE9XdjFrbzFzSzc5eUoraUJ6OVVxKzlNR2orZGlKMlV5T2ptdDViMkpRemQyZHJLOHVaMnQ5ZGJ3Ryt2MStBQUFBQU9CdUpXQUVBQUFBQUFBQUFBQUFBQUFBKzZ6WjNCMlBoWXZuMDJrMWMvaXBFM3NTTUpxcVZaUGh3L3p6SjA5blphZVZHN2ZPWmIxYnlrKzJLK0dkZTJ5NmwrTXoxZnpiTHo2U3ZUYUtGMTE0N3Z0WmZPUDFiS3l0QkFBQUFBRHVaZ0pHQUFBQUFBQUFBQUFBQUFBQThENVpXYnlhNXU1T1B2VEU1OUx0ZERKNzZIRDJ3bFM5bW1QRCtXc2ZPNTFyVyswMFgxM05hcnVVdFU3NGF6dzRuY3hVM3p4dTAvVzkvZXJWNlB4dWI5ekt6V3R2NVBLRkY4ZVhBUUFBQU9CdUoyQUVBQUFBQUFBQUFBQUFBQUFBNzVPVnBXdmpzWFZySlJuMDl5NWdWS3VPeDljK2ZpWVhibTdscGV1cnc2MkRySFZLNFpkN2NDWTVNVkVhSDdlOTF1MjBzN0Y2TTh2WEZzWUJJd0FBQUFBNENBU01BQUFBQUFBQUFBQUFBQUFBNEgzMjUvL3pEMU1xbGZQMWYvbHZVaTZYVTYzVnMxZk9ISjdLdi83TkQrZWxHeHQ1Y1drenp5NDNjMkc5azA1S0dlVGVEaHBWaGtkZ05ENXpZaUlmT2x6UFU0K2N5UDF6RTlscjdWWXpONjh2NUpuLy92dlp2TFVhQUFBQUFEZ29CSXdBQUFBQUFBQUFBQUFBQUFEZ2ZiYTBjR2tjTUJyMCsrbG5iMDNYcW5uc3hGeGE3WFoyZDNiemwydWxsRXRKYVpBTWNtOGI1WnRHeCtLQjZVb2VtcXZtNFdQVHVYOStPbnR0ZEY3YnpVYVdyMTlKcjlzTkFBQUFBQndVQWtZQUFBQUFBQUFBQUFBQUFBRHdQbXMzbStQNUQvL1R2OC9Kc3cvbUMzL25INlZjcnFSYXIyZXZmT2pra1R4OGZENWZlS3lkelZZdi8rRjdyK2VOOVViT05lNjlyeGpObHZzNU85SFBWeDQ5UGh3bmNteTZsa01UMWRRcWxleWxkbXQ0WGdlRDhYa2RYVzQxZGdNQUFBQUFCNG1BRVFBQUFBQUFBQUFBQUFBQUFMelBCb1BCZU41WVcwbDljaXE3MjV1Wm1KemUwNEJSdlZvZWo5RXp6ZFY3ZWZUWVZBYjlYcTczM256dXpYWi9mTnNncFJ4RWI3N3k1TWhFSlhPMVNzN09ESEo2dnA0UHpOVXpNMUhMUkhWdjQwVWpqZTJ0NGJudGo4OXJ0OU42Nnp3REFBQUF3RUVoWUFRQUFBQUFBQUFBQUFBQUFBQjNpSnVMQzJuc2JPZFBuLzZ2T2ZQSVIvTEVGNTdLWHB1ZHFDWEQ4YnUvK2RqNCt1OC8rMG8yMnIzODU1ZlcweHFVc2p2WSs1RFBuV0N1M00reGlYSis5NVBIY214bU1uL3I0Wk81M1g3d3pQL0k3dmJXK0x3Q0FBQUF3RUVrWUFRQUFBQUFBQUFBQUFBQUFBQjNrRjZ2aysyTlc5bTh0WktWeGF1Wm5wdlA5T3g4YnBmNzU2Y3kyZTdsVXcvMHM5VVo1TnBXYXppL2VibVhVZ2E1TzVXSGUxNGV6cU5vMFVTbGxBL09UK1RVVEgwY0w1cWZxdWQyMnQzZXpPN1c1dkFjcnFhNXV4TUFBQUFBT0tnRWpBQUFBQUFBQUFBQUFBQUFBT0FPMHRqWnpzVVhuOHZhamFWc3JDN244ZC80Y3M0K2V2c0NSbC8reUpueC9BOC9rWnhidXBYLy9mSzEvT2htS3o5ZWFXZXJYMGszcGR5TjZxVkJwa3I5Zk9WVVBhZG1xdm50eno2VytjbGE5c1BMejMwL0N4ZlA1NVVYZnBoMnF4a0FBQUFBT0tnRWpBQUFBQUFBQUFBQUFBQUFBT0FPMU5qZHl0S1ZTN2wwL29Yc2JtL203S01menZUczdRc1pqWnlZbmNxbmYrMUV6cHpvNVRNNzNaeGYzc3BtcTV0WDFocHA5Z2E1MmEza1RsVXBKY2VydlJ5WnJPU0IyWW1jUGpTVkQ4eFA1dEhEdGN6VnlwbW9sbk83clN4ZHpjcml0U3k4ZWo1TEM1ZlM2M1VEQUFBQUFBZVpnQkVBQUFBQUFBQUFBQUFBQUFEY2dSbzcyK05SbjV6TSt1cHk3anY1Z2RzZU1McHZkbkk4ZnVxYjV4WnlZN09SVm1NM3QxcWpnRkh1V0pVTWNxcmV6Ni9OMWZQcFU1UDUrT21qdzNFcysya1VMN3J3L1BkejVlTDVyQzB2QmdBQUFBQU9PZ0VqQUFBQUFBQUFBQUFBQUFBQXVJT3RMUzlsZTMwOWMwZitMSWVQSGM4VFgvaHk5c3ZIVGgvTFE2MU96cDQ0a3QxdVA5ZDNlN20xMjhxRkd4dTUxZXBtdGRITmVqdlo2U1dOd1NnaGRIdFZoODlRTC9WenBKWk1WNU96Y3hPcFYwcjU3SU1uVWl1VjhzQk1KVE8xY281UDEzSmtaaUw3WldQMVpsNDc5M3dXWGoyZks4T3h2WGtyQUFBQUFIQXZFREFDQUFBQUFBQUFBQUFBQUFDQU85ajJ4cHN4bk1YTHIyYnIxc3ErQm94T3prK1A1NGVQSjczK0lMZDJtN214MVVpOXZaT0Z6VjVxdlVGNnZhVGJUNXFEUVFZcDVYWXFEeDkrb2pRWUI0eEc0NUc1VWc1TlZQUDNIemt5dksyVW96T1RlVDkwMnEwc1hEeWZwWVZMV2J1NUdBQUFBQUM0VndnWUFRQUFBQUFBQUFBQUFBQUF3RjNnMHNzL1NhVlN6YzdtZW1ibmorUnZmLzBiS1pjcnFkYnIyUStWY2lsSHB5Zkc0OHlSdWZUNi9YUUh5WEJLYnpoZld0dEt0OWZMNWRYdHJEYzd1WEJ6NjYyZlhkanBaYU05ZUVmUGMzcW1rc1AxdDBOSW56bHpORk8xYXU2Zm44emNaRDBuNTZaVEdkNWNMaWZWMG1pL3lwbXRWN0xmMnExbXR0Zlg4ci8rNEwrazNXeG04Y3JyNmZXNkFRQUFBSUI3aVlBUkFBQUFBQUFBQUFBQUFBQUEzQVY2M2U1NGJLM2Z5bUF3ZUhQa25VV0I5a3A1VkEwYW1wOHMvOEp0aldZam5WNDVXenVWVkFiOXpGVGZqaEJOVlpMZDBqdmIxOUZELyt6UEhwdXNaS3BXeWYzVHRSeWFxdWZVL0VUdUNQLy9ISXpPUjN2NDJrZEJJd0FBQUFDNDE1Uys4ZFVuOS9ldmxBQUFBQUFBQUFBQUFBQUFBTUI3VXE1VU1uL2tXQjU4N09QNXpGTi9OelB6aHpONzZIQzQvZGFXbDlKcE5mUDA3LzNIYksydlpmUFdhZ0FBZ0YvdFJ1ZFErb05TMnFsbXJ6UnFVMW1hUDV2dGlmbXN6SndLQUxEUFN2bjIzdjFtQndBQUFBQUFBQUFBQUFBQUFQWk50OU5PWTJjejF5OWZ6SkVUSjlQdjl6STlkeWpWcXE4TTNRNnR4bTVhelVhV3IxNGVIdmZ0TkxZM3grY0FBQUFBQU81bC9ob0pBQUFBQUFBQUFBQUFBQUFBZDVsK3I1ZnRqZlc4L1B3UHh1T1JqejQrSEUva3cwOStMdk5Iam9XOWQzTnhJZGRlZnlVL2VPWlBzcmE4RkFBQUFBQkF3QWdBQUFBQUFBQUFBQUFBQUFEdWVsdTMxbkx0MHF1Wm1Kck83S0VqT1hYMjRkUW5KbE9ibUFqdnptQXdTS2ZWeXU3MlpsYVdydWJHMWN1NXNYQTUzVTQ3QUFBQUFNQ2JCSXdBQUFBQUFBQUFBQUFBQUFEZ0xuZmoyaHZqY2ZQNlFpYW5aL0tWZi93N21aMC9MR0QwSGd6Ni9UUjJ0ckp3OFh4Ky9KMXZabjFsT2V1cnl3RUFBQUFBM2laZ0JBQUFBQUFBQUFBQUFBQUFBQWZFS0xCVDNham5PMy95M3pJek41ZUhQL3BFWmc4ZHp1bUhIZ3Z2M012UGZUL2RUaXNYZi9KY3RqZldzcko0TGUxMkl3QUFBQURBenhNd0FnQUFBQUFBQUFBQUFBQUFnQU9pdWJzei9IOG5yNTkvTHBOVHM1azlkR1M0N1lTQVVVRTNGaTZsMWRqTmhSZCtrRjYzbTA2N0ZRQUFBQURnRndrWUFRQUFBQUFBQUFBQUFBQUF3QUhUYWJYVDcyM2wrZTgrazRtcHFWeDg2Y2M1ZWViQjRYZ294eDg0blVOSGo0ZTMzVnhjeU1icVNpNisrS05zYjY3bjJtdXZwTmZ0cE4xc1pqRG9Cd0FBQUFENHF3a1lBUUFBQUFBQUFBQUFBQUFBd0FIVDcvZlNiL2V5dnRwTXRWWkxxOWxJclZiUDNLRWpPWHJpWlBoNWpaM3Q3R3pleW8yRnk4Tmp0andlQUFBQUFNQ3ZKbUFFQUFBQUFBQUFBQUFBQUFBQUIxaTMwOG42eW5LZVgza216My8zbVV6UHpxYytPWmxQZk82M2N2aStFL21idy9sZXM3MnhudGRlK25FdVgzaHhQSGEzTnROdU5RTUFBQUFBRkNOZ0JBQUFBQUFBQUFBQUFBQUFBUGVRUWZycDkzdlozZDVNZldJeUcyczN4OXRIbDZ2VmVpcTFXa3JENjZWeU9RZEJ2OThmejYzR3puZ2VoWW9hMjF0dlJvdWF6Zkd4R0F6L0FRQUFkNS95b0o5cXY1TjZ0NVhKem00QWdQM1ZLMWRUK3NaWG4vVFhOUUFBQUFBQUFBQUFBQUFBQUxoSFRVN1BqT05GSC9uazUzTDhnVE41K0NPUFoySnFlcno5SU5qZVdFK3YyOGx6Zi82dGJLMnY1ZHlQdmplT0ZvM2lSUUFBd1A2NTBUbVUvcUNVZHFvQkFBNkdRZkp0djlrQkFBQUFBQUFBQUFBQUFBRGdIdGJyZHROT016ZXZMYVRWYUtTMTI4alV6RnltWm1kejZPaDlxVlJybVo2ZFQ2Vld5K1RVZE81VS9YNS91UCs3NmJSYjJkM2VUTE94TTN3dHU5bTh0Wkp1dTVPbEs2K2wxV3lPWCs5ZzBBOEFBQUFBOE40SkdBRUFBQUFBQUFBQUFBQUFBTUE5YkJUOEdZM1h6ajMvMXJiWitjT1pQWFFrajN6MDhmRjgrcUhITWpFNWZVY0hqQWI5ZmpiWFZyS3hlak9MVjE3THl1TFZyQ3hkeTlyeVl0cXRaZ0FBQUFDQXZTZGdCQUFBQUFBQUFBQUFBQUFBQVB5Y1VmQm5lK05XcnJ4NlB2WEp5U3hmdTVKcXRaNjVvMGRUcmRVeU8zOWt1SDBxOVluSlRNL09qK2VKNGZWU3Vaeko2Wm5zdFg2dk45Nm5YcmM3amkzdGJtK09yemQydG9mYk9sbGZYUjdmWit2V1dwcU4zZUcrcjQzdnM3dTFPZjRaQUFBQUFPRDJFREFDQUFBQUFBQUFBQUFBQUFBQWZzNG9EalNPR0cydXY3V3RWQ3BsWW1wNkhDZzZlZWJCek00Znp1eWhJN252NU9ueFBILzBXTXJseXUwSkdQWDdhVFYyMDI0MngyR2lsY1dGOGI2dExTK085L1B5aFJjekdBekc5d0VBQUFBQTlvK0FFUUFBQUFBQUFBQUFBQUFBQVBDckRUSU9DSFhiN1Z4cE5sS3AxbEtwVkZPZm5CeUhpNnExK3ZodWxWb3R0ZUhsdWNOSFU2Njh2YjJveHZabWV2MWV0amZXaDgvZFQ2L2JTMzk0dmQvcnBkMXFET2QrdXAzMmVOdG92MFlCSXdBQUFBQmdmd2tZQVFBQUFBQUFBQUFBQUFBQUFML1NZUFN2LzJaRXFMdmQrV3Z2VzUrWXpORVRwMUtwVkZJYlhuNDNObSt0anA5cmZXVTVBQUFBQU1DZFNjQUlBQUFBQUFBQUFBQUFBQUFBMkZQdFZqTTNGeGRTR2wwcGxmSnU5SHU5QUFBQUFBQjNOZ0VqQUFBQUFBQUFBQUFBQUFBQVlNLzF1dDBBQUFBQUFBZGJPUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQVVKR0FFQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUlVSkdBRUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFJVUpHQUVBQUFBQUFBQUFBQUFBQUFBQUFBQUFBSVVKR0FFQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUlVSkdBRUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFJVUpHQUVBQUFBQUFBQUFBQUFBQUFBQUFBQUFBSVVKR0FFQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUlVSkdBRUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFJVUpHQUVBQUFBQUFBQUFBQUFBQUFBQUFBQUFBSVVKR0FFQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUlVSkdBRUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFJVUpHQUVBQUFBQUFBQUFBQUFBQUFBQUFBQUFBSVVKR0FFQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUlVSkdBRUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFJVUpHQUVBQUFBQUFBQUFBQUFBQUFBQUFBQUFBSVVKR0FFQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUlVSkdBRUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFJVUpHQUVBQUFBQUFBQUFBQUFBQUFBQUFBQUFBSVVKR0FFQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUlVSkdBRUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFJVUpHQUVBQUFBQUFBQUFBQUFBQUFBQUFBQUFBSVVKR0FFQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUlWVkF3QUFBQUFBQUFBQUFBQUFBQUFBQUhBYnpaU2JHYVNVWHNvQkFBNktnWUFSQUFBQUFBQUFBQUFBQUFBQUFBQUFjSHZOVmxvQkFBNGVhVUlBQUFBQUFBQUFBQUFBQUFBQUFBQUFBS0F3QVNNQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUtBd0FTTUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFLQXdBU01BQUFBQUFBQUFBQUFBQUFBQUFBQUFBS0F3QVNNQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUtBd0FTTUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFLQXdBU01BQUFBQUFBQUFBQUFBQUFBQUFBQUFBS0F3QVNNQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUtBd0FTTUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFLQXdBU01BQUFBQUFBQUFBQUFBQUFBQUFBQUFBS0F3QVNNQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUtBd0FTTUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFLQXdBU01BQUFBQUFBQUFBQUFBQUFBQUFBQUFBS0F3QVNNQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUtBd0FTTUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFLQXdBU01BQUFBQUFBQUFBQUFBQUFBQUFBQUFBS0F3QVNNQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUtBd0FTTUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFLQXdBU01BQUFBQUFBQUFBQUFBQUFBQUFBQUFBS0F3QVNNQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUtBd0FTTUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFLQXdBU01BQUFBQUFBQUFBQUFBQUFBQUFBQUFBS0F3QVNNQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUtBd0FTTUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFLQXdBU01BQUFBQUFBQUFBQUFBQUFBQUFBQUFBS0F3QVNNQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUtBd0FTTUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFLQXdBU01BQUFBQUFBQUFBQUFBQUFBQUFBQUFBS0F3QVNNQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUtBd0FTTUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFLQXdBU01BQUFBQUFBQUFBQUFBQUFBQUFBQUFBS0F3QVNNQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUtBd0FTTUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFLQXdBU01BQUFBQUFBQUFBQUFBQUFBQUFBQUFBS0F3QVNNQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUtBd0FTTUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFLQXdBU01BQUFBQUFBQUFBQUFBQUFBQUFBQUFBS0F3QVNNQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUtBd0FTTUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFLQXdBU01BQUFBQUFBQUFBQUFBQUFBQUFBQUFBS0F3QVNNQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUtBd0FTTUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFLQXdBU01BQUFBQUFBQUFBQUFBQUFBQUFBQUFBS0F3QVNNQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUtBd0FTTUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFLQXdBU01BQUFBQUFBQUFBQUFBQUFBQUFBQUFBS0F3QVNNQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUtBd0FTTUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFLQXdBU01BQUFBQUFBQUFBQUFBQUFBQUFBQUFBS0F3QVNNQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUtBd0FTTUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFLQXdBU01BQUFBQUFBQUFBQUFBQUFBQUFBQUFBS0F3QVNNQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUtBd0FTTUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFLQXdBU01BQUFBQUFBQUFBQUFBQUFBQUFBQUFBS0F3QVNNQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUtBd0FTTUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFLQXdBU01BQUFBQUFBQUFBQUFBQUFBQUFBQUFBS0F3QVNNQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUtBd0FTTUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFLQXdBU01BQUFBQUFBQUFBQUFBQUFBQUFBQUFBS0F3QVNNQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUtBd0FTTUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFLQXdBU01BQUFBQUFBQUFBQUFBQUFBQUFBQUFBS0F3QVNNQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUtBd0FTTUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFLQXdBU01BQUFBQUFBQUFBQUFBQUFBQUFBQUFBS0F3QVNNQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUtBd0FTTUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFLQXdBU01BQUFBQUFBQUFBQUFBQUFBQUFBQUFBS0F3QVNNQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUtBd0FTTUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFLQXdBU01BQUFBQUFBQUFBQUFBQUFBQUFBQUFBS0F3QVNNQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUtBd0FTTUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFLQXdBU01BQUFBQUFBQUFBQUFBQUFBQUFBQUFBS0F3QVNNQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUtBd0FTTUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFLQXdBU01BQUFBQUFBQUFBQUFBQUFBQUFBQUFBS0F3QVNNQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUtBd0FTTUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFLQXdBU01BQUFBQUFBQUFBQUFBQUFBQUFBQUFBS0F3QVNNQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUtBd0FTTUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFLQXdBU01BQUFBQUFBQUFBQUFBQUFBQUFBQUFBS0F3QVNNQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUtBd0FTTUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFLQXdBU01BQUFBQUFBQUFBQUFBQUFBQUFBQUFBS0F3QVNNQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUtBd0FTTUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFLQXdBU01BQUFBQUFBQUFBQUFBQUFBQUFBQUFBS0F3QVNNQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUtBd0FTTUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFLQXdBU01BQUFBQUFBQUFBQUFBQUFBQUFBQUFBS0F3QVNNQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUtBd0FTTUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFLQXdBU01BQUFBQUFBQUFBQUFBQUFBQUFBQUFBS0F3QVNNQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUtBd0FTTUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFLQXdBU01BQUFBQUFBQUFBQUFBQUFBQUFBQUFBS0F3QVNNQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUtBd0FTTUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFLQXdBU01BQUFBQUFBQUFBQUFBQUFBQUFBQUFBS0F3QVNNQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUtBd0FTTUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFLQXdBU01BQUFBQUFBQUFBQUFBQUFBQUFBQUFBS0F3QVNNQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUtBd0FTTUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFPRDIrMy9seXJwNXRGNWpXUUFBQUFCSlJVNUVya0pnZ2c9PVwiXG5cbi8qKiovIH0pLFxuLyogMjUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19iYWJlbF9sb2FkZXJfbm9kZV9tb2R1bGVzX3Z1ZV9sb2FkZXJfbGliX3NlbGVjdG9yX3R5cGVfc2NyaXB0X2luZGV4XzBfQWNjb3JkaW9uX3Z1ZV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19ub2RlX21vZHVsZXNfdnVlX2xvYWRlcl9saWJfdGVtcGxhdGVfY29tcGlsZXJfaW5kZXhfaWRfZGF0YV92XzYxYmVlZGE0X2hhc1Njb3BlZF9mYWxzZV9ub2RlX21vZHVsZXNfdnVlX2xvYWRlcl9saWJfc2VsZWN0b3JfdHlwZV90ZW1wbGF0ZV9pbmRleF8wX0FjY29yZGlvbl92dWVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMzIpO1xudmFyIG5vcm1hbGl6ZUNvbXBvbmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMClcbi8qIHNjcmlwdCAqL1xuXG4vKiB0ZW1wbGF0ZSAqL1xuXG4vKiBzdHlsZXMgKi9cbnZhciBfX3Z1ZV9zdHlsZXNfXyA9IG51bGxcbi8qIHNjb3BlSWQgKi9cbnZhciBfX3Z1ZV9zY29wZUlkX18gPSBudWxsXG4vKiBtb2R1bGVJZGVudGlmaWVyIChzZXJ2ZXIgb25seSkgKi9cbnZhciBfX3Z1ZV9tb2R1bGVfaWRlbnRpZmllcl9fID0gbnVsbFxudmFyIENvbXBvbmVudCA9IG5vcm1hbGl6ZUNvbXBvbmVudChcbiAgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19iYWJlbF9sb2FkZXJfbm9kZV9tb2R1bGVzX3Z1ZV9sb2FkZXJfbGliX3NlbGVjdG9yX3R5cGVfc2NyaXB0X2luZGV4XzBfQWNjb3JkaW9uX3Z1ZV9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dLFxuICBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX25vZGVfbW9kdWxlc192dWVfbG9hZGVyX2xpYl90ZW1wbGF0ZV9jb21waWxlcl9pbmRleF9pZF9kYXRhX3ZfNjFiZWVkYTRfaGFzU2NvcGVkX2ZhbHNlX25vZGVfbW9kdWxlc192dWVfbG9hZGVyX2xpYl9zZWxlY3Rvcl90eXBlX3RlbXBsYXRlX2luZGV4XzBfQWNjb3JkaW9uX3Z1ZV9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dLFxuICBfX3Z1ZV9zdHlsZXNfXyxcbiAgX192dWVfc2NvcGVJZF9fLFxuICBfX3Z1ZV9tb2R1bGVfaWRlbnRpZmllcl9fXG4pXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAoQ29tcG9uZW50LmV4cG9ydHMpO1xuXG5cbi8qKiovIH0pLFxuLyogMjYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19BY2NvcmRpb25Hcm91cF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNyk7XG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG5cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9ICh7XG4gICAgbmFtZTogJ0FjY29yZGlvbicsXG4gICAgcHJvcHM6IFsnY2FsbG91dHMnXSxcbiAgICBjb21wb25lbnRzOiB7XG4gICAgICAgIEFjY29yZGlvbkdyb3VwOiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX0FjY29yZGlvbkdyb3VwX19bXCJhXCIgLyogZGVmYXVsdCAqL11cbiAgICB9XG59KTtcblxuLyoqKi8gfSksXG4vKiAyNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX2JhYmVsX2xvYWRlcl9ub2RlX21vZHVsZXNfdnVlX2xvYWRlcl9saWJfc2VsZWN0b3JfdHlwZV9zY3JpcHRfaW5kZXhfMF9BY2NvcmRpb25Hcm91cF92dWVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMzApO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fbm9kZV9tb2R1bGVzX3Z1ZV9sb2FkZXJfbGliX3RlbXBsYXRlX2NvbXBpbGVyX2luZGV4X2lkX2RhdGFfdl83YTlmNDhhMV9oYXNTY29wZWRfdHJ1ZV9ub2RlX21vZHVsZXNfdnVlX2xvYWRlcl9saWJfc2VsZWN0b3JfdHlwZV90ZW1wbGF0ZV9pbmRleF8wX0FjY29yZGlvbkdyb3VwX3Z1ZV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMSk7XG5mdW5jdGlvbiBpbmplY3RTdHlsZSAoc3NyQ29udGV4dCkge1xuICBfX3dlYnBhY2tfcmVxdWlyZV9fKDI4KVxufVxudmFyIG5vcm1hbGl6ZUNvbXBvbmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMClcbi8qIHNjcmlwdCAqL1xuXG4vKiB0ZW1wbGF0ZSAqL1xuXG4vKiBzdHlsZXMgKi9cbnZhciBfX3Z1ZV9zdHlsZXNfXyA9IGluamVjdFN0eWxlXG4vKiBzY29wZUlkICovXG52YXIgX192dWVfc2NvcGVJZF9fID0gXCJkYXRhLXYtN2E5ZjQ4YTFcIlxuLyogbW9kdWxlSWRlbnRpZmllciAoc2VydmVyIG9ubHkpICovXG52YXIgX192dWVfbW9kdWxlX2lkZW50aWZpZXJfXyA9IG51bGxcbnZhciBDb21wb25lbnQgPSBub3JtYWxpemVDb21wb25lbnQoXG4gIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fYmFiZWxfbG9hZGVyX25vZGVfbW9kdWxlc192dWVfbG9hZGVyX2xpYl9zZWxlY3Rvcl90eXBlX3NjcmlwdF9pbmRleF8wX0FjY29yZGlvbkdyb3VwX3Z1ZV9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dLFxuICBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX25vZGVfbW9kdWxlc192dWVfbG9hZGVyX2xpYl90ZW1wbGF0ZV9jb21waWxlcl9pbmRleF9pZF9kYXRhX3ZfN2E5ZjQ4YTFfaGFzU2NvcGVkX3RydWVfbm9kZV9tb2R1bGVzX3Z1ZV9sb2FkZXJfbGliX3NlbGVjdG9yX3R5cGVfdGVtcGxhdGVfaW5kZXhfMF9BY2NvcmRpb25Hcm91cF92dWVfX1tcImFcIiAvKiBkZWZhdWx0ICovXSxcbiAgX192dWVfc3R5bGVzX18sXG4gIF9fdnVlX3Njb3BlSWRfXyxcbiAgX192dWVfbW9kdWxlX2lkZW50aWZpZXJfX1xuKVxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gKENvbXBvbmVudC5leHBvcnRzKTtcblxuXG4vKioqLyB9KSxcbi8qIDI4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI5KTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmksIGNvbnRlbnQsICcnXV07XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpKFwiZWRjY2I1MGFcIiwgY29udGVudCwgdHJ1ZSk7XG5cbi8qKiovIH0pLFxuLyogMjkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKSh1bmRlZmluZWQpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaSwgXCIuYWNjb3JkaW9uLXRpdGxlW2RhdGEtdi03YTlmNDhhMV17Y3Vyc29yOnBvaW50ZXI7YmFja2dyb3VuZC1jb2xvcjojMDA3OGFlO2NvbG9yOiNmZmY7cGFkZGluZzo1cHggMTBweDttYXJnaW46MDtib3JkZXItYm90dG9tOjFweCBzb2xpZCAjZmZmfS5hY2NvcmRpb24tY29udGVudFtkYXRhLXYtN2E5ZjQ4YTFde2NvbG9yOiMwMDc4YWU7bWF4LWhlaWdodDowO29wYWNpdHk6MDt2aXNpYmlsaXR5OmhpZGRlbjttYXJnaW46MDtwYWRkaW5nOjA7b3ZlcmZsb3c6aGlkZGVuO3RyYW5zaXRpb246b3BhY2l0eSAuM3MgZWFzZS1vdXQsbWF4LWhlaWdodCAuNXMgY3ViaWMtYmV6aWVyKDAsMS4wNSwwLDEpLHZpc2liaWxpdHkgLjJzfS5hY2NvcmRpb24tY29udGVudC5hY3RpdmVbZGF0YS12LTdhOWY0OGExXXttYXgtaGVpZ2h0OjEwMDBweDtvdmVyZmxvdzpoaWRkZW47b3BhY2l0eToxO3Zpc2liaWxpdHk6dmlzaWJsZTt0cmFuc2l0aW9uOm9wYWNpdHkgLjNzIGVhc2UtaW4sbWF4LWhlaWdodCAuM3MgZWFzZS1pbix2aXNpYmlsaXR5IC4yc31wW2RhdGEtdi03YTlmNDhhMV17bWFyZ2luOjVweCAwO3BhZGRpbmc6NXB4IDEwcHh9XCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuXG5cbi8qKiovIH0pLFxuLyogMzAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAoe1xuICAgIG5hbWU6ICdBY2NvcmRpb25Hcm91cCcsXG4gICAgcHJvcHM6IFsnY2FsbG91dCddLFxuICAgIG1ldGhvZHM6IHtcbiAgICAgICAgdG9nZ2xlKCkge1xuICAgICAgICAgICAgdGhpcy5jYWxsb3V0LnNob3cgPSB0aGlzLmNhbGxvdXQuc2hvdyA9PT0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxuLyoqKi8gfSksXG4vKiAzMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbnZhciByZW5kZXIgPSBmdW5jdGlvbiAoKSB7dmFyIF92bT10aGlzO3ZhciBfaD1fdm0uJGNyZWF0ZUVsZW1lbnQ7dmFyIF9jPV92bS5fc2VsZi5fY3x8X2g7cmV0dXJuIF9jKCdkaXYnLHtzdGF0aWNDbGFzczpcImFjY29yZGlvbi1ncm91cFwifSxbX2MoJ2gyJyx7c3RhdGljQ2xhc3M6XCJhY2NvcmRpb24tdGl0bGVcIixvbjp7XCJjbGlja1wiOl92bS50b2dnbGV9fSxbX3ZtLl92KF92bS5fcyhfdm0uY2FsbG91dC50aXRsZSkpXSksX3ZtLl92KFwiIFwiKSxfYygnZGl2Jyx7c3RhdGljQ2xhc3M6XCJhY2NvcmRpb24tY29udGVudFwiLGNsYXNzOnsnYWN0aXZlJzogX3ZtLmNhbGxvdXQuc2hvd319LFtfYygncCcsW192bS5fdihfdm0uX3MoX3ZtLmNhbGxvdXQudGV4dCkpXSldKV0pfVxudmFyIHN0YXRpY1JlbmRlckZucyA9IFtdXG52YXIgZXNFeHBvcnRzID0geyByZW5kZXI6IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zOiBzdGF0aWNSZW5kZXJGbnMgfVxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9IChlc0V4cG9ydHMpO1xuXG4vKioqLyB9KSxcbi8qIDMyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xudmFyIHJlbmRlciA9IGZ1bmN0aW9uICgpIHt2YXIgX3ZtPXRoaXM7dmFyIF9oPV92bS4kY3JlYXRlRWxlbWVudDt2YXIgX2M9X3ZtLl9zZWxmLl9jfHxfaDtyZXR1cm4gX2MoJ2Rpdicse3N0YXRpY0NsYXNzOlwiYWNjb3JkaW9uXCJ9LF92bS5fbCgoX3ZtLmNhbGxvdXRzKSxmdW5jdGlvbihjYWxsb3V0KXtyZXR1cm4gX2MoJ2FjY29yZGlvbi1ncm91cCcse2tleTpjYWxsb3V0LnNsdWcsYXR0cnM6e1wiY2FsbG91dFwiOmNhbGxvdXR9fSl9KSl9XG52YXIgc3RhdGljUmVuZGVyRm5zID0gW11cbnZhciBlc0V4cG9ydHMgPSB7IHJlbmRlcjogcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnM6IHN0YXRpY1JlbmRlckZucyB9XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gKGVzRXhwb3J0cyk7XG5cbi8qKiovIH0pLFxuLyogMzMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgcmVuZGVyID0gZnVuY3Rpb24gKCkge3ZhciBfdm09dGhpczt2YXIgX2g9X3ZtLiRjcmVhdGVFbGVtZW50O3ZhciBfYz1fdm0uX3NlbGYuX2N8fF9oO3JldHVybiBfYygnZGl2Jyx7YXR0cnM6e1wiaWRcIjpcImFwcFwifX0sW19jKCdsaW5rJyx7YXR0cnM6e1wiaHJlZlwiOlwiaHR0cHM6Ly9mb250cy5nb29nbGVhcGlzLmNvbS9jc3M/ZmFtaWx5PU9zd2FsZDozMDAsNTAwXCIsXCJyZWxcIjpcInN0eWxlc2hlZXRcIn19KSxfdm0uX3YoXCIgXCIpLF9jKCdob3VzZScse2F0dHJzOntcImNhbGxvdXRzXCI6X3ZtLmNhbGxvdXRzfX0pLF92bS5fdihcIiBcIiksX2MoJ2FjY29yZGlvbicse2F0dHJzOntcImNhbGxvdXRzXCI6X3ZtLmNhbGxvdXRzfX0pXSwxKX1cbnZhciBzdGF0aWNSZW5kZXJGbnMgPSBbXVxudmFyIGVzRXhwb3J0cyA9IHsgcmVuZGVyOiByZW5kZXIsIHN0YXRpY1JlbmRlckZuczogc3RhdGljUmVuZGVyRm5zIH1cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAoZXNFeHBvcnRzKTtcblxuLyoqKi8gfSlcbi8qKioqKiovIF0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2F3cy1ob3VzZS5qcy5tYXAiXX0=
